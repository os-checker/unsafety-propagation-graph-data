{
  "name": "alloc::vec::Vec::<T, A>::recycle",
  "span": "$library/alloc/src/vec/mod.rs:3258:5: 3260:26",
  "doc": " This clears out this `Vec` and recycles the allocation into a new `Vec`.\n The item type of the resulting `Vec` needs to have the same size and\n alignment as the item type of the original `Vec`.\n\n # Examples\n\n  ```\n #![feature(vec_recycle, transmutability)]\n let a: Vec<u8> = vec![0; 100];\n let capacity = a.capacity();\n let addr = a.as_ptr().addr();\n let b: Vec<i8> = a.recycle();\n assert_eq!(b.len(), 0);\n assert_eq!(b.capacity(), capacity);\n assert_eq!(b.as_ptr().addr(), addr);\n ```\n\n The `Recyclable` bound prevents this method from being called when `T` and `U` have different sizes; e.g.:\n\n  ```compile_fail,E0277\n #![feature(vec_recycle, transmutability)]\n let vec: Vec<[u8; 2]> = Vec::new();\n let _: Vec<[u8; 1]> = vec.recycle();\n ```\n ...or different alignments:\n\n  ```compile_fail,E0277\n #![feature(vec_recycle, transmutability)]\n let vec: Vec<[u16; 0]> = Vec::new();\n let _: Vec<[u8; 0]> = vec.recycle();\n ```\n\n However, due to temporary implementation limitations of `Recyclable`,\n this method is not yet callable when `T` or `U` are slices, trait objects,\n or other exotic types; e.g.:\n\n ```compile_fail,E0277\n #![feature(vec_recycle, transmutability)]\n # let inputs = [\"a b c\", \"d e f\"];\n # fn process(_: &[&str]) {}\n let mut storage: Vec<&[&str]> = Vec::new();\n\n for input in inputs {\n     let mut buffer: Vec<&str> = storage.recycle();\n     buffer.extend(input.split(\" \"));\n     process(&buffer);\n     storage = buffer.recycle();\n }\n ```\n"
}