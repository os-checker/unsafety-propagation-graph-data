{
  "name": "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
  "span": "$library/alloc/src/collections/btree/map.rs:3322:5: 3322:71",
  "src": "pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {\n        let edge = match self.current.take() {\n            None => {\n                // SAFETY: We have no other reference to the tree.\n                match unsafe { self.root.reborrow() } {\n                    root @ None => {\n                        // Tree is empty, allocate a new root.\n                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n                        // SAFETY: We don't touch the root while the handle is alive.\n                        let handle = unsafe { node.borrow_mut().push_with_handle(key, value) };\n                        *root = Some(node.forget_type());\n                        *self.length += 1;\n                        self.current = Some(handle.right_edge());\n                        return;\n                    }\n                    Some(root) => root.borrow_mut().last_leaf_edge(),\n                }\n            }\n            Some(current) => current,\n        };\n\n        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n            drop(ins.left);\n            // SAFETY: The handle to the newly inserted value is always on a\n            // leaf node, so adding a new root node doesn't invalidate it.\n            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n        });\n        self.current = Some(handle.right_edge());\n        *self.length += 1;\n    }"
}