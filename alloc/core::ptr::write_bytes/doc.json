{
  "name": "core::ptr::write_bytes",
  "span": "$library/core/src/ptr/mod.rs:697:1: 697:71",
  "doc": " Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n `val`.\n\n `write_bytes` is similar to C's [`memset`], but sets `count *\n size_of::<T>()` bytes to `val`.\n\n [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * `dst` must be properly aligned.\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointer must be properly aligned.\n\n Additionally, note that changing `*dst` in this way can easily lead to undefined behavior (UB)\n later if the written bytes are not a valid representation of some `T`. For instance, the\n following is an **incorrect** use of this function:\n\n ```rust,no_run\n unsafe {\n     let mut value: u8 = 0;\n     let ptr: *mut bool = &mut value as *mut u8 as *mut bool;\n     let _bool = ptr.read(); // This is fine, `ptr` points to a valid `bool`.\n     ptr.write_bytes(42u8, 1); // This function itself does not cause UB...\n     let _bool = ptr.read(); // ...but it makes this operation UB! ⚠️\n }\n ```\n\n [valid]: crate::ptr#safety\n\n # Examples\n\n Basic usage:\n\n ```\n use std::ptr;\n\n let mut vec = vec![0u32; 4];\n unsafe {\n     let vec_ptr = vec.as_mut_ptr();\n     ptr::write_bytes(vec_ptr, 0xfe, 2);\n }\n assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n ```\n"
}