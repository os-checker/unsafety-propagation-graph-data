{
  "name": "alloc::slice::<impl [T]>::sort_by_cached_key",
  "span": "$library/alloc/src/slice.rs:312:5: 315:16",
  "src": "pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n        macro_rules! sort_by_key {\n            ($t:ty, $slice:ident, $f:ident) => {{\n                let mut indices: Vec<_> =\n                    $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                // The elements of `indices` are unique, as they are indexed, so any sort will be\n                // stable with respect to the original slice. We use `sort_unstable` here because\n                // it requires no memory allocation.\n                indices.sort_unstable();\n                for i in 0..$slice.len() {\n                    let mut index = indices[i].1;\n                    while (index as usize) < i {\n                        index = indices[index as usize].1;\n                    }\n                    indices[i].1 = index;\n                    $slice.swap(i, index as usize);\n                }\n            }};\n        }\n\n        let len = self.len();\n        if len < 2 {\n            return;\n        }\n\n        // Avoids binary-size usage in cases where the alignment doesn't work out to make this\n        // beneficial or on 32-bit platforms.\n        let is_using_u32_as_idx_type_helpful =\n            const { size_of::<(K, u32)>() < size_of::<(K, usize)>() };\n\n        // It's possible to instantiate this for u8 and u16 but, doing so is very wasteful in terms\n        // of compile-times and binary-size, the peak saved heap memory for u16 is (u8 + u16) -> 4\n        // bytes * u16::MAX vs (u8 + u32) -> 8 bytes * u16::MAX, the saved heap memory is at peak\n        // ~262KB.\n        if is_using_u32_as_idx_type_helpful && len <= (u32::MAX as usize) {\n            return sort_by_key!(u32, self, f);\n        }\n\n        sort_by_key!(usize, self, f)\n    }"
}