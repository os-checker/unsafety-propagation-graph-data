{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::drain",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1801:5: 1803:31",
  "src": "pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>\n    where\n        R: RangeBounds<usize>,\n    {\n        // Memory safety\n        //\n        // When the Drain is first created, the source deque is shortened to\n        // make sure no uninitialized or moved-from elements are accessible at\n        // all if the Drain's destructor never gets to run.\n        //\n        // Drain will ptr::read out the values to remove.\n        // When finished, the remaining data will be copied back to cover the hole,\n        // and the head/tail values will be restored correctly.\n        //\n        let Range { start, end } = slice::range(range, ..self.len);\n        let drain_start = start;\n        let drain_len = end - start;\n\n        // The deque's elements are parted into three segments:\n        // * 0  -> drain_start\n        // * drain_start -> drain_start+drain_len\n        // * drain_start+drain_len -> self.len\n        //\n        // H = self.head; T = self.head+self.len; t = drain_start+drain_len; h = drain_head\n        //\n        // We store drain_start as self.len, and drain_len and self.len as\n        // drain_len and orig_len respectively on the Drain. This also\n        // truncates the effective array such that if the Drain is leaked, we\n        // have forgotten about the potentially moved values after the start of\n        // the drain.\n        //\n        //        H   h   t   T\n        // [. . . o o x x o o . . .]\n        //\n        // \"forget\" about the values after the start of the drain until after\n        // the drain is complete and the Drain destructor is run.\n\n        unsafe { Drain::new(self, drain_start, drain_len) }\n    }"
}