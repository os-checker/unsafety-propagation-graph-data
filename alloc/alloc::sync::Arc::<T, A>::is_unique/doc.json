{
  "name": "alloc::sync::Arc::<T, A>::is_unique",
  "span": "$library/alloc/src/sync.rs:2754:5: 2754:42",
  "doc": " Determine whether this is the unique reference to the underlying data.\n\n Returns `true` if there are no other `Arc` or [`Weak`] pointers to the same allocation;\n returns `false` otherwise.\n\n If this function returns `true`, then is guaranteed to be safe to call [`get_mut_unchecked`]\n on this `Arc`, so long as no clones occur in between.\n\n # Examples\n\n ```\n #![feature(arc_is_unique)]\n\n use std::sync::Arc;\n\n let x = Arc::new(3);\n assert!(Arc::is_unique(&x));\n\n let y = Arc::clone(&x);\n assert!(!Arc::is_unique(&x));\n drop(y);\n\n // Weak references also count, because they could be upgraded at any time.\n let z = Arc::downgrade(&x);\n assert!(!Arc::is_unique(&x));\n ```\n\n # Pointer invalidation\n\n This function will always return the same value as `Arc::get_mut(arc).is_some()`. However,\n unlike that operation it does not produce any mutable references to the underlying data,\n meaning no pointers to the data inside the `Arc` are invalidated by the call. Thus, the\n following code is valid, even though it would be UB if it used `Arc::get_mut`:\n\n ```\n #![feature(arc_is_unique)]\n\n use std::sync::Arc;\n\n let arc = Arc::new(5);\n let pointer: *const i32 = &*arc;\n assert!(Arc::is_unique(&arc));\n assert_eq!(unsafe { *pointer }, 5);\n ```\n\n # Atomic orderings\n\n Concurrent drops to other `Arc` pointers to the same allocation will synchronize with this\n call - that is, this call performs an `Acquire` operation on the underlying strong and weak\n ref counts. This ensures that calling `get_mut_unchecked` is safe.\n\n Note that this operation requires locking the weak ref count, so concurrent calls to\n `downgrade` may spin-loop for a short period of time.\n\n [`get_mut_unchecked`]: Self::get_mut_unchecked\n"
}