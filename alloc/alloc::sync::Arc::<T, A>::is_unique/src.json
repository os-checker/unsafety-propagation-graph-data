{
  "name": "alloc::sync::Arc::<T, A>::is_unique",
  "span": "$library/alloc/src/sync.rs:2754:5: 2754:42",
  "src": "pub fn is_unique(this: &Self) -> bool {\n        // lock the weak pointer count if we appear to be the sole weak pointer\n        // holder.\n        //\n        // The acquire label here ensures a happens-before relationship with any\n        // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements\n        // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded\n        // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.\n        if this.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n            // This needs to be an `Acquire` to synchronize with the decrement of the `strong`\n            // counter in `drop` -- the only access that happens when any but the last reference\n            // is being dropped.\n            let unique = this.inner().strong.load(Acquire) == 1;\n\n            // The release write here synchronizes with a read in `downgrade`,\n            // effectively preventing the above read of `strong` from happening\n            // after the write.\n            this.inner().weak.store(1, Release); // release the lock\n            unique\n        } else {\n            false\n        }\n    }"
}