{
  "name": "alloc::raw_vec::RawVecInner::<A>::try_allocate_in",
  "span": "$library/alloc/src/raw_vec/mod.rs:449:5: 454:39",
  "src": "fn try_allocate_in(\n        capacity: usize,\n        init: AllocInit,\n        alloc: A,\n        elem_layout: Layout,\n    ) -> Result<Self, TryReserveError> {\n        // We avoid `unwrap_or_else` here because it bloats the amount of\n        // LLVM IR generated.\n        let layout = match layout_array(capacity, elem_layout) {\n            Ok(layout) => layout,\n            Err(_) => return Err(CapacityOverflow.into()),\n        };\n\n        // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.\n        if layout.size() == 0 {\n            return Ok(Self::new_in(alloc, elem_layout.alignment()));\n        }\n\n        let result = match init {\n            AllocInit::Uninitialized => alloc.allocate(layout),\n            #[cfg(not(no_global_oom_handling))]\n            AllocInit::Zeroed => alloc.allocate_zeroed(layout),\n        };\n        let ptr = match result {\n            Ok(ptr) => ptr,\n            Err(_) => return Err(AllocError { layout, non_exhaustive: () }.into()),\n        };\n\n        // Allocators currently return a `NonNull<[u8]>` whose length\n        // matches the size requested. If that ever changes, the capacity\n        // here should change to `ptr.len() / size_of::<T>()`.\n        Ok(Self {\n            ptr: Unique::from(ptr.cast()),\n            cap: unsafe { Cap::new_unchecked(capacity) },\n            alloc,\n        })\n    }"
}