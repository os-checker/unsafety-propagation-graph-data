{
  "name": "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_left",
  "span": "$library/alloc/src/collections/btree/node.rs:1528:5: 1528:59",
  "src": "pub(super) fn bulk_steal_left(&mut self, count: usize) {\n        assert!(count > 0);\n        unsafe {\n            let left_node = &mut self.left_child;\n            let old_left_len = left_node.len();\n            let right_node = &mut self.right_child;\n            let old_right_len = right_node.len();\n\n            // Make sure that we may steal safely.\n            assert!(old_right_len + count <= CAPACITY);\n            assert!(old_left_len >= count);\n\n            let new_left_len = old_left_len - count;\n            let new_right_len = old_right_len + count;\n            *left_node.len_mut() = new_left_len as u16;\n            *right_node.len_mut() = new_right_len as u16;\n\n            // Move leaf data.\n            {\n                // Make room for stolen elements in the right child.\n                slice_shr(right_node.key_area_mut(..new_right_len), count);\n                slice_shr(right_node.val_area_mut(..new_right_len), count);\n\n                // Move elements from the left child to the right one.\n                move_to_slice(\n                    left_node.key_area_mut(new_left_len + 1..old_left_len),\n                    right_node.key_area_mut(..count - 1),\n                );\n                move_to_slice(\n                    left_node.val_area_mut(new_left_len + 1..old_left_len),\n                    right_node.val_area_mut(..count - 1),\n                );\n\n                // Move the leftmost stolen pair to the parent.\n                let k = left_node.key_area_mut(new_left_len).assume_init_read();\n                let v = left_node.val_area_mut(new_left_len).assume_init_read();\n                let (k, v) = self.parent.replace_kv(k, v);\n\n                // Move parent's key-value pair to the right child.\n                right_node.key_area_mut(count - 1).write(k);\n                right_node.val_area_mut(count - 1).write(v);\n            }\n\n            match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {\n                    // Make room for stolen edges.\n                    slice_shr(right.edge_area_mut(..new_right_len + 1), count);\n\n                    // Steal edges.\n                    move_to_slice(\n                        left.edge_area_mut(new_left_len + 1..old_left_len + 1),\n                        right.edge_area_mut(..count),\n                    );\n\n                    right.correct_childrens_parent_links(0..new_right_len + 1);\n                }\n                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                _ => unreachable!(),\n            }\n        }\n    }"
}