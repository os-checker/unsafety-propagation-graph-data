{
  "name": "alloc::<sync::Arc<[T]> as core::iter::FromIterator<T>>::from_iter",
  "span": "$library/alloc/src/sync.rs:4136:5: 4136:61",
  "doc": " Takes each element in the `Iterator` and collects it into an `Arc<[T]>`.\n\n # Performance characteristics\n\n ## The general case\n\n In the general case, collecting into `Arc<[T]>` is done by first\n collecting into a `Vec<T>`. That is, when writing the following:\n\n ```rust\n # use std::sync::Arc;\n let evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n ```\n\n this behaves as if we wrote:\n\n ```rust\n # use std::sync::Arc;\n let evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n     .collect::<Vec<_>>() // The first set of allocations happens here.\n     .into(); // A second allocation for `Arc<[T]>` happens here.\n # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n ```\n\n This will allocate as many times as needed for constructing the `Vec<T>`\n and then it will allocate once for turning the `Vec<T>` into the `Arc<[T]>`.\n\n ## Iterators of known length\n\n When your `Iterator` implements `TrustedLen` and is of an exact size,\n a single allocation will be made for the `Arc<[T]>`. For example:\n\n ```rust\n # use std::sync::Arc;\n let evens: Arc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n ```\n"
}