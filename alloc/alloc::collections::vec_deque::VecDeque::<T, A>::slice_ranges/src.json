{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::slice_ranges",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1659:5: 1661:31",
  "src": "fn slice_ranges<R>(&self, range: R, len: usize) -> (Range<usize>, Range<usize>)\n    where\n        R: RangeBounds<usize>,\n    {\n        let Range { start, end } = slice::range(range, ..len);\n        let len = end - start;\n\n        if len == 0 {\n            (0..0, 0..0)\n        } else {\n            // `slice::range` guarantees that `start <= end <= len`.\n            // because `len != 0`, we know that `start < end`, so `start < len`\n            // and the indexing is valid.\n            let wrapped_start = self.to_physical_idx(start);\n\n            // this subtraction can never overflow because `wrapped_start` is\n            // at most `self.capacity()` (and if `self.capacity != 0`, then `wrapped_start` is strictly less\n            // than `self.capacity`).\n            let head_len = self.capacity() - wrapped_start;\n\n            if head_len >= len {\n                // we know that `len + wrapped_start <= self.capacity <= usize::MAX`, so this addition can't overflow\n                (wrapped_start..wrapped_start + len, 0..0)\n            } else {\n                // can't overflow because of the if condition\n                let tail_len = len - head_len;\n                (wrapped_start..self.capacity(), 0..tail_len)\n            }\n        }\n    }"
}