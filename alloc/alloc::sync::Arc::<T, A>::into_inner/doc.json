{
  "name": "alloc::sync::Arc::<T, A>::into_inner",
  "span": "$library/alloc/src/sync.rs:1221:5: 1221:47",
  "doc": " Returns the inner value, if the `Arc` has exactly one strong reference.\n\n Otherwise, [`None`] is returned and the `Arc` is dropped.\n\n This will succeed even if there are outstanding weak references.\n\n If `Arc::into_inner` is called on every clone of this `Arc`,\n it is guaranteed that exactly one of the calls returns the inner value.\n This means in particular that the inner value is not dropped.\n\n [`Arc::try_unwrap`] is conceptually similar to `Arc::into_inner`, but it\n is meant for different use-cases. If used as a direct replacement\n for `Arc::into_inner` anyway, such as with the expression\n <code>[Arc::try_unwrap]\\(this).[ok][Result::ok]()</code>, then it does\n **not** give the same guarantee as described in the previous paragraph.\n For more information, see the examples below and read the documentation\n of [`Arc::try_unwrap`].\n\n # Examples\n\n Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n ```\n use std::sync::Arc;\n\n let x = Arc::new(3);\n let y = Arc::clone(&x);\n\n // Two threads calling `Arc::into_inner` on both clones of an `Arc`:\n let x_thread = std::thread::spawn(|| Arc::into_inner(x));\n let y_thread = std::thread::spawn(|| Arc::into_inner(y));\n\n let x_inner_value = x_thread.join().unwrap();\n let y_inner_value = y_thread.join().unwrap();\n\n // One of the threads is guaranteed to receive the inner value:\n assert!(matches!(\n     (x_inner_value, y_inner_value),\n     (None, Some(3)) | (Some(3), None)\n ));\n // The result could also be `(None, None)` if the threads called\n // `Arc::try_unwrap(x).ok()` and `Arc::try_unwrap(y).ok()` instead.\n ```\n\n A more practical example demonstrating the need for `Arc::into_inner`:\n ```\n use std::sync::Arc;\n\n // Definition of a simple singly linked list using `Arc`:\n #[derive(Clone)]\n struct LinkedList<T>(Option<Arc<Node<T>>>);\n struct Node<T>(T, Option<Arc<Node<T>>>);\n\n // Dropping a long `LinkedList<T>` relying on the destructor of `Arc`\n // can cause a stack overflow. To prevent this, we can provide a\n // manual `Drop` implementation that does the destruction in a loop:\n impl<T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n         let mut link = self.0.take();\n         while let Some(arc_node) = link.take() {\n             if let Some(Node(_value, next)) = Arc::into_inner(arc_node) {\n                 link = next;\n             }\n         }\n     }\n }\n\n // Implementation of `new` and `push` omitted\n impl<T> LinkedList<T> {\n     /* ... */\n #   fn new() -> Self {\n #       LinkedList(None)\n #   }\n #   fn push(&mut self, x: T) {\n #       self.0 = Some(Arc::new(Node(x, self.0.take())));\n #   }\n }\n\n // The following code could have still caused a stack overflow\n // despite the manual `Drop` impl if that `Drop` impl had used\n // `Arc::try_unwrap(arc).ok()` instead of `Arc::into_inner(arc)`.\n\n // Create a long list and clone it\n let mut x = LinkedList::new();\n let size = 100000;\n # let size = if cfg!(miri) { 100 } else { size };\n for i in 0..size {\n     x.push(i); // Adds i to the front of x\n }\n let y = x.clone();\n\n // Drop the clones in parallel\n let x_thread = std::thread::spawn(|| drop(x));\n let y_thread = std::thread::spawn(|| drop(y));\n x_thread.join().unwrap();\n y_thread.join().unwrap();\n ```\n"
}