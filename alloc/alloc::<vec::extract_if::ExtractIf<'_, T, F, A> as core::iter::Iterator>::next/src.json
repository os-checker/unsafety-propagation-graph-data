{
  "name": "alloc::<vec::extract_if::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next",
  "span": "$library/alloc/src/vec/extract_if.rs:67:5: 67:36",
  "src": "fn next(&mut self) -> Option<T> {\n        while self.idx < self.end {\n            let i = self.idx;\n            // SAFETY:\n            //  We know that `i < self.end` from the if guard and that `self.end <= self.old_len` from\n            //  the validity of `Self`. Therefore `i` points to an element within `vec`.\n            //\n            //  Additionally, the i-th element is valid because each element is visited at most once\n            //  and it is the first time we access vec[i].\n            //\n            //  Note: we can't use `vec.get_unchecked_mut(i)` here since the precondition for that\n            //  function is that i < vec.len(), but we've set vec's length to zero.\n            let cur = unsafe { &mut *self.vec.as_mut_ptr().add(i) };\n            let drained = (self.pred)(cur);\n            // Update the index *after* the predicate is called. If the index\n            // is updated prior and the predicate panics, the element at this\n            // index would be leaked.\n            self.idx += 1;\n            if drained {\n                self.del += 1;\n                // SAFETY: We never touch this element again after returning it.\n                return Some(unsafe { ptr::read(cur) });\n            } else if self.del > 0 {\n                // SAFETY: `self.del` > 0, so the hole slot must not overlap with current element.\n                // We use copy for move, and never touch this element again.\n                unsafe {\n                    let hole_slot = self.vec.as_mut_ptr().add(i - self.del);\n                    ptr::copy_nonoverlapping(cur, hole_slot, 1);\n                }\n            }\n        }\n        None\n    }"
}