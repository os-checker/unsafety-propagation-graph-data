{
  "name": "alloc::<collections::btree::map::BTreeMap<K, V, A> as core::clone::Clone>::clone",
  "span": "$library/alloc/src/collections/btree/map.rs:227:5: 227:41",
  "src": "fn clone(&self) -> BTreeMap<K, V, A> {\n        fn clone_subtree<'a, K: Clone, V: Clone, A: Allocator + Clone>(\n            node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>,\n            alloc: A,\n        ) -> BTreeMap<K, V, A>\n        where\n            K: 'a,\n            V: 'a,\n        {\n            match node.force() {\n                Leaf(leaf) => {\n                    let mut out_tree = BTreeMap {\n                        root: Some(Root::new(alloc.clone())),\n                        length: 0,\n                        alloc: ManuallyDrop::new(alloc),\n                        _marker: PhantomData,\n                    };\n\n                    {\n                        let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n                        let mut out_node = match root.borrow_mut().force() {\n                            Leaf(leaf) => leaf,\n                            Internal(_) => unreachable!(),\n                        };\n\n                        let mut in_edge = leaf.first_edge();\n                        while let Ok(kv) = in_edge.right_kv() {\n                            let (k, v) = kv.into_kv();\n                            in_edge = kv.right_edge();\n\n                            out_node.push(k.clone(), v.clone());\n                            out_tree.length += 1;\n                        }\n                    }\n\n                    out_tree\n                }\n                Internal(internal) => {\n                    let mut out_tree =\n                        clone_subtree(internal.first_edge().descend(), alloc.clone());\n\n                    {\n                        let out_root = out_tree.root.as_mut().unwrap();\n                        let mut out_node = out_root.push_internal_level(alloc.clone());\n                        let mut in_edge = internal.first_edge();\n                        while let Ok(kv) = in_edge.right_kv() {\n                            let (k, v) = kv.into_kv();\n                            in_edge = kv.right_edge();\n\n                            let k = (*k).clone();\n                            let v = (*v).clone();\n                            let subtree = clone_subtree(in_edge.descend(), alloc.clone());\n\n                            // We can't destructure subtree directly\n                            // because BTreeMap implements Drop\n                            let (subroot, sublength) = unsafe {\n                                let subtree = ManuallyDrop::new(subtree);\n                                let root = ptr::read(&subtree.root);\n                                let length = subtree.length;\n                                (root, length)\n                            };\n\n                            out_node.push(\n                                k,\n                                v,\n                                subroot.unwrap_or_else(|| Root::new(alloc.clone())),\n                            );\n                            out_tree.length += 1 + sublength;\n                        }\n                    }\n\n                    out_tree\n                }\n            }\n        }\n\n        if self.is_empty() {\n            BTreeMap::new_in((*self.alloc).clone())\n        } else {\n            clone_subtree(self.root.as_ref().unwrap().reborrow(), (*self.alloc).clone()) // unwrap succeeds because not empty\n        }\n    }"
}