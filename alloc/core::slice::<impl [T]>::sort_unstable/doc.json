{
  "name": "core::slice::<impl [T]>::sort_unstable",
  "span": "$library/core/src/slice/mod.rs:3130:5: 3132:16",
  "doc": " Sorts the slice in ascending order **without** preserving the initial order of equal elements.\n\n This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\n allocate), and *O*(*n* \\* log(*n*)) worst-case.\n\n If the implementation of [`Ord`] for `T` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n\n All original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. Same is true if the implementation of [`Ord`] for `T` panics.\n\n Sorting types that only implement [`PartialOrd`] such as [`f32`] and [`f64`] require\n additional precautions. For example, `f32::NAN != f32::NAN`, which doesn't fulfill the\n reflexivity requirement of [`Ord`]. By using an alternative comparison function with\n `slice::sort_unstable_by` such as [`f32::total_cmp`] or [`f64::total_cmp`] that defines a\n [total order] users can sort slices containing floating-point values. Alternatively, if all\n values in the slice are guaranteed to be in a subset for which [`PartialOrd::partial_cmp`]\n forms a [total order], it's possible to sort the slice with `sort_unstable_by(|a, b|\n a.partial_cmp(b).unwrap())`.\n\n # Current implementation\n\n The current implementation is based on [ipnsort] by Lukas Bergdoll and Orson Peters, which\n combines the fast average case of quicksort with the fast worst case of heapsort, achieving\n linear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\n expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n It is typically faster than stable sorting, except in a few special cases, e.g., when the\n slice is partially sorted.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `T` does not implement a [total order], or if\n the [`Ord`] implementation panics.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n\n v.sort_unstable();\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n"
}