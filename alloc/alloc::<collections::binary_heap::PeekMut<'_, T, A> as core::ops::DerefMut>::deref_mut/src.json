{
  "name": "alloc::<collections::binary_heap::PeekMut<'_, T, A> as core::ops::DerefMut>::deref_mut",
  "span": "$library/alloc/src/collections/binary_heap/mod.rs:336:5: 336:38",
  "src": "fn deref_mut(&mut self) -> &mut T {\n        debug_assert!(!self.heap.is_empty());\n\n        let len = self.heap.len();\n        if len > 1 {\n            // Here we preemptively leak all the rest of the underlying vector\n            // after the currently max element. If the caller mutates the &mut T\n            // we're about to give them, and then leaks the PeekMut, all these\n            // elements will remain leaked. If they don't leak the PeekMut, then\n            // either Drop or PeekMut::pop will un-leak the vector elements.\n            //\n            // This is technique is described throughout several other places in\n            // the standard library as \"leak amplification\".\n            unsafe {\n                // SAFETY: len > 1 so len != 0.\n                self.original_len = Some(NonZero::new_unchecked(len));\n                // SAFETY: len > 1 so all this does for now is leak elements,\n                // which is safe.\n                self.heap.data.set_len(1);\n            }\n        }\n\n        // SAFE: PeekMut is only instantiated for non-empty heaps\n        unsafe { self.heap.data.get_unchecked_mut(0) }\n    }"
}