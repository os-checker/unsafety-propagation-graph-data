{
  "name": "alloc::<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtend<T, I>>::spec_extend",
  "span": "$library/alloc/src/collections/vec_deque/spec_extend.rs:48:5: 48:47",
  "src": "default fn spec_extend(&mut self, iter: I) {\n        // This is the case for a TrustedLen iterator.\n        let (low, high) = iter.size_hint();\n        if let Some(additional) = high {\n            debug_assert_eq!(\n                low,\n                additional,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n            self.reserve(additional);\n\n            let written = unsafe {\n                self.write_iter_wrapping(self.to_physical_idx(self.len), iter, additional)\n            };\n\n            debug_assert_eq!(\n                additional, written,\n                \"The number of items written to VecDeque doesn't match the TrustedLen size hint\"\n            );\n        } else {\n            // Per TrustedLen contract a `None` upper bound means that the iterator length\n            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n            // This avoids additional codegen for a fallback code path which would eventually\n            // panic anyway.\n            panic!(\"capacity overflow\");\n        }\n    }"
}