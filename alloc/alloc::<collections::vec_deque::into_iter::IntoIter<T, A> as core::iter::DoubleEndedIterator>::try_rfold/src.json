{
  "name": "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::try_rfold",
  "span": "$library/alloc/src/collections/vec_deque/into_iter.rs:198:5: 201:28",
  "src": "fn try_rfold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n    where\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Output = B>,\n    {\n        struct Guard<'a, T, A: Allocator> {\n            deque: &'a mut VecDeque<T, A>,\n            // `consumed <= deque.len` always holds.\n            consumed: usize,\n        }\n\n        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n            fn drop(&mut self) {\n                self.deque.len -= self.consumed;\n            }\n        }\n\n        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n\n        let (head, tail) = guard.deque.as_slices();\n\n        init = tail\n            .iter()\n            .map(|elem| {\n                guard.consumed += 1;\n                // SAFETY: See `try_fold`'s safety comment.\n                unsafe { ptr::read(elem) }\n            })\n            .try_rfold(init, &mut f)?;\n\n        head.iter()\n            .map(|elem| {\n                guard.consumed += 1;\n                // SAFETY: Same as above.\n                unsafe { ptr::read(elem) }\n            })\n            .try_rfold(init, &mut f)\n    }"
}