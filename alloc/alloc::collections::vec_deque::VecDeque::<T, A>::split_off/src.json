{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::split_off",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:2472:5: 2474:18",
  "src": "pub fn split_off(&mut self, at: usize) -> Self\n    where\n        A: Clone,\n    {\n        let len = self.len;\n        assert!(at <= len, \"`at` out of bounds\");\n\n        let other_len = len - at;\n        let mut other = VecDeque::with_capacity_in(other_len, self.allocator().clone());\n\n        let (first_half, second_half) = self.as_slices();\n        let first_len = first_half.len();\n        let second_len = second_half.len();\n\n        unsafe {\n            if at < first_len {\n                // `at` lies in the first half.\n                let amount_in_first = first_len - at;\n\n                ptr::copy_nonoverlapping(first_half.as_ptr().add(at), other.ptr(), amount_in_first);\n\n                // just take all of the second half.\n                ptr::copy_nonoverlapping(\n                    second_half.as_ptr(),\n                    other.ptr().add(amount_in_first),\n                    second_len,\n                );\n            } else {\n                // `at` lies in the second half, need to factor in the elements we skipped\n                // in the first half.\n                let offset = at - first_len;\n                let amount_in_second = second_len - offset;\n                ptr::copy_nonoverlapping(\n                    second_half.as_ptr().add(offset),\n                    other.ptr(),\n                    amount_in_second,\n                );\n            }\n        }\n\n        // Cleanup where the ends of the buffers are\n        self.len = at;\n        other.len = other_len;\n\n        other\n    }"
}