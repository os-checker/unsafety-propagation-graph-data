{
  "name": "alloc::boxed::Box::<T, A>::try_clone_from_ref_in",
  "span": "$library/alloc/src/boxed.rs:824:5: 824:85",
  "src": "pub fn try_clone_from_ref_in(src: &T, alloc: A) -> Result<Box<T, A>, AllocError> {\n        struct DeallocDropGuard<'a, A: Allocator>(Layout, &'a A, NonNull<u8>);\n        impl<'a, A: Allocator> Drop for DeallocDropGuard<'a, A> {\n            fn drop(&mut self) {\n                let &mut DeallocDropGuard(layout, alloc, ptr) = self;\n                // Safety: `ptr` was allocated by `*alloc` with layout `layout`\n                unsafe {\n                    alloc.deallocate(ptr, layout);\n                }\n            }\n        }\n        let layout = Layout::for_value::<T>(src);\n        let (ptr, guard) = if layout.size() == 0 {\n            (layout.dangling(), None)\n        } else {\n            // Safety: layout is non-zero-sized\n            let ptr = alloc.allocate(layout)?.cast();\n            (ptr, Some(DeallocDropGuard(layout, &alloc, ptr)))\n        };\n        let ptr = ptr.as_ptr();\n        // Safety: `*ptr` is newly allocated, correctly aligned to `align_of_val(src)`,\n        // and is valid for writes for `size_of_val(src)`.\n        // If this panics, then `guard` will deallocate for us (if allocation occuured)\n        unsafe {\n            <T as CloneToUninit>::clone_to_uninit(src, ptr);\n        }\n        // Defuse the deallocate guard\n        core::mem::forget(guard);\n        // Safety: We just initialized `*ptr` as a clone of `src`\n        Ok(unsafe { Box::from_raw_in(ptr.with_metadata_of(src), alloc) })\n    }"
}