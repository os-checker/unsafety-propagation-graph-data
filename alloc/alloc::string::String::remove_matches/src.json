{
  "name": "alloc::string::String::remove_matches",
  "span": "$library/alloc/src/string.rs:1553:5: 1553:57",
  "src": "pub fn remove_matches<P: Pattern>(&mut self, pat: P) {\n        use core::str::pattern::Searcher;\n\n        let rejections = {\n            let mut searcher = pat.into_searcher(self);\n            // Per Searcher::next:\n            //\n            // A Match result needs to contain the whole matched pattern,\n            // however Reject results may be split up into arbitrary many\n            // adjacent fragments. Both ranges may have zero length.\n            //\n            // In practice the implementation of Searcher::next_match tends to\n            // be more efficient, so we use it here and do some work to invert\n            // matches into rejections since that's what we want to copy below.\n            let mut front = 0;\n            let rejections: Vec<_> = from_fn(|| {\n                let (start, end) = searcher.next_match()?;\n                let prev_front = front;\n                front = end;\n                Some((prev_front, start))\n            })\n            .collect();\n            rejections.into_iter().chain(core::iter::once((front, self.len())))\n        };\n\n        let mut len = 0;\n        let ptr = self.vec.as_mut_ptr();\n\n        for (start, end) in rejections {\n            let count = end - start;\n            if start != len {\n                // SAFETY: per Searcher::next:\n                //\n                // The stream of Match and Reject values up to a Done will\n                // contain index ranges that are adjacent, non-overlapping,\n                // covering the whole haystack, and laying on utf8\n                // boundaries.\n                unsafe {\n                    ptr::copy(ptr.add(start), ptr.add(len), count);\n                }\n            }\n            len += count;\n        }\n\n        unsafe {\n            self.vec.set_len(len);\n        }\n    }"
}