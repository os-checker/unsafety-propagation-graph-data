{
  "name": "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing",
  "span": "$library/alloc/src/collections/btree/node.rs:1058:5: 1064:74",
  "src": "pub(super) fn insert_recursing<A: Allocator + Clone>(\n        self,\n        key: K,\n        value: V,\n        alloc: A,\n        split_root: impl FnOnce(SplitResult<'a, K, V, marker::LeafOrInternal>),\n    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n        let (mut split, handle) = match self.insert(key, value, alloc.clone()) {\n            // SAFETY: we have finished splitting and can now re-awaken the\n            // handle to the inserted element.\n            (None, handle) => return unsafe { handle.awaken() },\n            (Some(split), handle) => (split.forget_node_type(), handle),\n        };\n\n        loop {\n            split = match split.left.ascend() {\n                Ok(parent) => {\n                    match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {\n                        // SAFETY: we have finished splitting and can now re-awaken the\n                        // handle to the inserted element.\n                        None => return unsafe { handle.awaken() },\n                        Some(split) => split.forget_node_type(),\n                    }\n                }\n                Err(root) => {\n                    split_root(SplitResult { left: root, ..split });\n                    // SAFETY: we have finished splitting and can now re-awaken the\n                    // handle to the inserted element.\n                    return unsafe { handle.awaken() };\n                }\n            };\n        }\n    }"
}