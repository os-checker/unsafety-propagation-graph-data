{
  "name": "alloc::collections::linked_list::LinkedList::<T, A>::split_off",
  "span": "$library/alloc/src/collections/linked_list.rs:997:5: 999:18",
  "src": "pub fn split_off(&mut self, at: usize) -> LinkedList<T, A>\n    where\n        A: Clone,\n    {\n        let len = self.len();\n        assert!(at <= len, \"Cannot split off at a nonexistent index\");\n        if at == 0 {\n            return mem::replace(self, Self::new_in(self.alloc.clone()));\n        } else if at == len {\n            return Self::new_in(self.alloc.clone());\n        }\n\n        // Below, we iterate towards the `i-1`th node, either from the start or the end,\n        // depending on which would be faster.\n        let split_node = if at - 1 <= len - 1 - (at - 1) {\n            let mut iter = self.iter_mut();\n            // instead of skipping using .skip() (which creates a new struct),\n            // we skip manually so we can access the head field without\n            // depending on implementation details of Skip\n            for _ in 0..at - 1 {\n                iter.next();\n            }\n            iter.head\n        } else {\n            // better off starting from the end\n            let mut iter = self.iter_mut();\n            for _ in 0..len - 1 - (at - 1) {\n                iter.next_back();\n            }\n            iter.tail\n        };\n        unsafe { self.split_off_after_node(split_node, at) }\n    }"
}