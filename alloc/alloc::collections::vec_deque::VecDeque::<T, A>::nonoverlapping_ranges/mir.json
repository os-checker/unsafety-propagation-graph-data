{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::nonoverlapping_ranges",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:264:5: 270:40",
  "mir": "fn alloc::collections::vec_deque::VecDeque::<T, A>::nonoverlapping_ranges(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize, _3: usize, _4: usize, _5: usize) -> [(*const T, *mut T, usize); 2] {\n    let mut _0: [(*const T, *mut T, usize); 2];\n    let mut _6: bool;\n    let mut _7: usize;\n    let  _8: !;\n    let mut _9: core::fmt::Arguments<'_>;\n    let  _10: (&usize, &usize, &usize);\n    let mut _11: &usize;\n    let mut _12: &usize;\n    let mut _13: &usize;\n    let  _14: [core::fmt::rt::Argument<'_>; 3];\n    let mut _15: core::fmt::rt::Argument<'_>;\n    let mut _16: core::fmt::rt::Argument<'_>;\n    let mut _17: core::fmt::rt::Argument<'_>;\n    let mut _18: &[u8; 57];\n    let  _19: &[core::fmt::rt::Argument<'_>; 3];\n    let mut _20: bool;\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: (usize, bool);\n    let mut _24: usize;\n    let mut _25: &collections::vec_deque::VecDeque<T, A>;\n    let  _26: !;\n    let mut _27: core::fmt::Arguments<'_>;\n    let  _28: (&usize, &usize, &usize, &usize);\n    let mut _29: &usize;\n    let  _30: usize;\n    let mut _31: &collections::vec_deque::VecDeque<T, A>;\n    let mut _32: &usize;\n    let mut _33: &usize;\n    let mut _34: &usize;\n    let  _35: [core::fmt::rt::Argument<'_>; 4];\n    let mut _36: core::fmt::rt::Argument<'_>;\n    let mut _37: core::fmt::rt::Argument<'_>;\n    let mut _38: core::fmt::rt::Argument<'_>;\n    let mut _39: core::fmt::rt::Argument<'_>;\n    let mut _40: &[u8; 56];\n    let  _41: &[core::fmt::rt::Argument<'_>; 4];\n    let  _42: usize;\n    let mut _43: &collections::vec_deque::VecDeque<T, A>;\n    let  _44: usize;\n    let mut _45: &collections::vec_deque::VecDeque<T, A>;\n    let  _46: usize;\n    let mut _47: usize;\n    let mut _48: &collections::vec_deque::VecDeque<T, A>;\n    let mut _49: (usize, bool);\n    let  _50: usize;\n    let mut _51: usize;\n    let mut _52: &collections::vec_deque::VecDeque<T, A>;\n    let mut _53: (usize, bool);\n    let  _54: bool;\n    let  _55: bool;\n    let  _56: !;\n    let mut _57: core::fmt::Arguments<'_>;\n    let  _58: (&usize, &usize, &usize, &usize);\n    let mut _59: &usize;\n    let  _60: usize;\n    let mut _61: &collections::vec_deque::VecDeque<T, A>;\n    let mut _62: &usize;\n    let mut _63: &usize;\n    let mut _64: &usize;\n    let  _65: [core::fmt::rt::Argument<'_>; 4];\n    let mut _66: core::fmt::rt::Argument<'_>;\n    let mut _67: core::fmt::rt::Argument<'_>;\n    let mut _68: core::fmt::rt::Argument<'_>;\n    let mut _69: core::fmt::rt::Argument<'_>;\n    let mut _70: &[u8; 72];\n    let  _71: &[core::fmt::rt::Argument<'_>; 4];\n    let  _72: *mut T;\n    let mut _73: &collections::vec_deque::VecDeque<T, A>;\n    let  _74: *mut T;\n    let  _75: *mut T;\n    let mut _76: (*const T, *mut T, usize);\n    let mut _77: *const T;\n    let mut _78: (*const T, *mut T, usize);\n    let mut _79: *const T;\n    let mut _80: *mut T;\n    let mut _81: usize;\n    let mut _82: (usize, bool);\n    let mut _83: (*const T, *mut T, usize);\n    let mut _84: *const T;\n    let mut _85: (*const T, *mut T, usize);\n    let mut _86: *const T;\n    let mut _87: *mut T;\n    let mut _88: usize;\n    let mut _89: (usize, bool);\n    let mut _90: (*const T, *mut T, usize);\n    let mut _91: *const T;\n    let mut _92: (*const T, *mut T, usize);\n    let mut _93: *const T;\n    let mut _94: *mut T;\n    let mut _95: &usize;\n    let mut _96: &usize;\n    let mut _97: &usize;\n    let mut _98: &usize;\n    let mut _99: &usize;\n    let mut _100: &usize;\n    let mut _101: &usize;\n    let mut _102: &usize;\n    let mut _103: &usize;\n    let mut _104: &usize;\n    let mut _105: &usize;\n    debug self => _1;\n    debug src => _2;\n    debug dst => _3;\n    debug count => _4;\n    debug head => _5;\n    debug args => _10;\n    debug args => _14;\n    debug args => _28;\n    debug args => _35;\n    debug wrapped_src => _42;\n    debug wrapped_dst => _44;\n    debug room_after_src => _46;\n    debug room_after_dst => _50;\n    debug src_wraps => _54;\n    debug dst_wraps => _55;\n    debug args => _58;\n    debug args => _65;\n    debug ptr => _72;\n    debug src_ptr => _74;\n    debug dst_ptr => _75;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::num::<impl usize>::abs_diff(_2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = Ge(move _7, _4);\n        switchInt(move _6) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = <usize as core::cmp::Ord>::max(_2, _3) -> [return: bb8, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_2;\n        StorageLive(_12);\n        _12 = &_3;\n        StorageLive(_13);\n        _13 = &_4;\n        _10 = (move _11, move _12, move _13);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_14);\n        StorageLive(_15);\n        _95 = (_10.0: &usize);\n        _15 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_95) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_16);\n        _96 = (_10.1: &usize);\n        _16 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_96) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_17);\n        _97 = (_10.2: &usize);\n        _17 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_97) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _14 = [move _15, move _16, move _17];\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_18);\n        _18 = b\"&`src` and `dst` must not overlap. src=\\xc0\\x05 dst=\\xc0\\x07 count=\\xc0\\x00\";\n        _19 = &_14;\n        _9 = core::fmt::Arguments::<'_>::new::<57, 3>(move _18, _19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        _8 = core::panicking::panic_fmt(move _9) -> unwind unreachable;\n    }\n    bb8: {\n        _23 = CheckedAdd(_22, _4);\n        assert(!move (_23.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _22, _4) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _21 = move (_23.0: usize);\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &(*_1);\n        _24 = collections::vec_deque::VecDeque::<T, A>::capacity(move _25) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_25);\n        _20 = Le(move _21, move _24);\n        switchInt(move _20) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_43);\n        _43 = &(*_1);\n        _42 = collections::vec_deque::VecDeque::<T, A>::wrap_add(move _43, _5, _2) -> [return: bb19, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &(*_1);\n        _30 = collections::vec_deque::VecDeque::<T, A>::capacity(move _31) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_31);\n        _29 = &_30;\n        StorageLive(_32);\n        _32 = &_2;\n        StorageLive(_33);\n        _33 = &_3;\n        StorageLive(_34);\n        _34 = &_4;\n        _28 = (move _29, move _32, move _33, move _34);\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_29);\n        StorageLive(_35);\n        StorageLive(_36);\n        _98 = (_28.1: &usize);\n        _36 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_98) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_37);\n        _99 = (_28.2: &usize);\n        _37 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_99) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_38);\n        _100 = (_28.3: &usize);\n        _38 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_100) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_39);\n        _101 = (_28.0: &usize);\n        _39 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_101) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _35 = [move _36, move _37, move _38, move _39];\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_40);\n        _40 = b\"\\x1eranges must be in bounds. src=\\xc0\\x05 dst=\\xc0\\x07 count=\\xc0\\x05 cap=\\xc0\\x00\";\n        _41 = &_35;\n        _27 = core::fmt::Arguments::<'_>::new::<56, 4>(move _40, _41) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_40);\n        _26 = core::panicking::panic_fmt(move _27) -> unwind unreachable;\n    }\n    bb19: {\n        StorageDead(_43);\n        StorageLive(_45);\n        _45 = &(*_1);\n        _44 = collections::vec_deque::VecDeque::<T, A>::wrap_add(move _45, _5, _3) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_45);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = &(*_1);\n        _47 = collections::vec_deque::VecDeque::<T, A>::capacity(move _48) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_48);\n        _49 = CheckedSub(_47, _42);\n        assert(!move (_49.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _47, _42) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _46 = move (_49.0: usize);\n        StorageDead(_47);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &(*_1);\n        _51 = collections::vec_deque::VecDeque::<T, A>::capacity(move _52) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_52);\n        _53 = CheckedSub(_51, _44);\n        assert(!move (_53.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _51, _44) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _50 = move (_53.0: usize);\n        StorageDead(_51);\n        _54 = Lt(_46, _4);\n        _55 = Lt(_50, _4);\n        switchInt(_54) -> [0: bb33, otherwise: bb25];\n    }\n    bb25: {\n        switchInt(_55) -> [0: bb33, otherwise: bb26];\n    }\n    bb26: {\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &(*_1);\n        _60 = collections::vec_deque::VecDeque::<T, A>::capacity(move _61) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_61);\n        _59 = &_60;\n        StorageLive(_62);\n        _62 = &_2;\n        StorageLive(_63);\n        _63 = &_3;\n        StorageLive(_64);\n        _64 = &_4;\n        _58 = (move _59, move _62, move _63, move _64);\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageDead(_59);\n        StorageLive(_65);\n        StorageLive(_66);\n        _102 = (_58.1: &usize);\n        _66 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_102) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageLive(_67);\n        _103 = (_58.2: &usize);\n        _67 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_103) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_68);\n        _104 = (_58.3: &usize);\n        _68 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_104) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageLive(_69);\n        _105 = (_58.0: &usize);\n        _69 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_105) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _65 = [move _66, move _67, move _68, move _69];\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_67);\n        StorageDead(_66);\n        StorageLive(_70);\n        _70 = b\".BUG: at most one of src and dst can wrap. src=\\xc0\\x05 dst=\\xc0\\x07 count=\\xc0\\x05 cap=\\xc0\\x00\";\n        _71 = &_65;\n        _57 = core::fmt::Arguments::<'_>::new::<72, 4>(move _70, _71) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_70);\n        _56 = core::panicking::panic_fmt(move _57) -> unwind unreachable;\n    }\n    bb33: {\n        StorageLive(_73);\n        _73 = &(*_1);\n        _72 = collections::vec_deque::VecDeque::<T, A>::ptr(move _73) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_73);\n        _74 = core::ptr::mut_ptr::<impl *mut T>::add(_72, _42) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _75 = core::ptr::mut_ptr::<impl *mut T>::add(_72, _44) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        switchInt(_54) -> [0: bb40, otherwise: bb37];\n    }\n    bb37: {\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = _74 as *const T;\n        _76 = (move _77, _75, _46);\n        StorageDead(_77);\n        StorageLive(_78);\n        StorageLive(_79);\n        _79 = _72 as *const T;\n        StorageLive(_80);\n        _80 = core::ptr::mut_ptr::<impl *mut T>::add(_75, _46) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageLive(_81);\n        _82 = CheckedSub(_4, _46);\n        assert(!move (_82.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _46) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _81 = move (_82.0: usize);\n        _78 = (move _79, move _80, move _81);\n        StorageDead(_81);\n        StorageDead(_80);\n        StorageDead(_79);\n        _0 = [move _76, move _78];\n        StorageDead(_78);\n        StorageDead(_76);\n        goto -> bb48;\n    }\n    bb40: {\n        switchInt(_55) -> [0: bb44, otherwise: bb41];\n    }\n    bb41: {\n        StorageLive(_83);\n        StorageLive(_84);\n        _84 = _74 as *const T;\n        _83 = (move _84, _75, _50);\n        StorageDead(_84);\n        StorageLive(_85);\n        StorageLive(_86);\n        StorageLive(_87);\n        _87 = core::ptr::mut_ptr::<impl *mut T>::add(_74, _50) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        _86 = move _87 as *const T;\n        StorageDead(_87);\n        StorageLive(_88);\n        _89 = CheckedSub(_4, _50);\n        assert(!move (_89.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _50) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _88 = move (_89.0: usize);\n        _85 = (move _86, _72, move _88);\n        StorageDead(_88);\n        StorageDead(_86);\n        _0 = [move _83, move _85];\n        StorageDead(_85);\n        StorageDead(_83);\n        goto -> bb47;\n    }\n    bb44: {\n        StorageLive(_90);\n        StorageLive(_91);\n        _91 = _74 as *const T;\n        _90 = (move _91, _75, _4);\n        StorageDead(_91);\n        StorageLive(_92);\n        StorageLive(_93);\n        _93 = core::ptr::null::<T>() -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageLive(_94);\n        _94 = core::ptr::null_mut::<T>() -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _92 = (move _93, move _94, 0_usize);\n        StorageDead(_94);\n        StorageDead(_93);\n        _0 = [move _90, move _92];\n        StorageDead(_92);\n        StorageDead(_90);\n        goto -> bb47;\n    }\n    bb47: {\n        goto -> bb48;\n    }\n    bb48: {\n        return;\n    }\n}\n"
}