{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::nonoverlapping_ranges",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:264:5: 270:40",
  "src": "unsafe fn nonoverlapping_ranges(\n        &mut self,\n        src: usize,\n        dst: usize,\n        count: usize,\n        head: usize,\n    ) -> [(*const T, *mut T, usize); 2] {\n        // \"`src` and `dst` must be at least as far apart as `count`\"\n        debug_assert!(\n            src.abs_diff(dst) >= count,\n            \"`src` and `dst` must not overlap. src={src} dst={dst} count={count}\",\n        );\n        debug_assert!(\n            src.max(dst) + count <= self.capacity(),\n            \"ranges must be in bounds. src={src} dst={dst} count={count} cap={}\",\n            self.capacity(),\n        );\n\n        let wrapped_src = self.wrap_add(head, src);\n        let wrapped_dst = self.wrap_add(head, dst);\n\n        let room_after_src = self.capacity() - wrapped_src;\n        let room_after_dst = self.capacity() - wrapped_dst;\n\n        let src_wraps = room_after_src < count;\n        let dst_wraps = room_after_dst < count;\n\n        // Wrapping occurs if `capacity` is contained within `wrapped_src..wrapped_src + count` or `wrapped_dst..wrapped_dst + count`.\n        // Since these two ranges must not overlap as per the safety invariants of this function, only one range can wrap.\n        debug_assert!(\n            !(src_wraps && dst_wraps),\n            \"BUG: at most one of src and dst can wrap. src={src} dst={dst} count={count} cap={}\",\n            self.capacity(),\n        );\n\n        unsafe {\n            let ptr = self.ptr();\n            let src_ptr = ptr.add(wrapped_src);\n            let dst_ptr = ptr.add(wrapped_dst);\n\n            if src_wraps {\n                [\n                    (src_ptr, dst_ptr, room_after_src),\n                    (ptr, dst_ptr.add(room_after_src), count - room_after_src),\n                ]\n            } else if dst_wraps {\n                [\n                    (src_ptr, dst_ptr, room_after_dst),\n                    (src_ptr.add(room_after_dst), ptr, count - room_after_dst),\n                ]\n            } else {\n                [\n                    (src_ptr, dst_ptr, count),\n                    // null pointers are fine as long as the count is 0\n                    (ptr::null(), ptr::null_mut(), 0),\n                ]\n            }\n        }\n    }"
}