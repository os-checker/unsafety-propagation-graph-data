{
  "name": "alloc::<vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop",
  "span": "$library/alloc/src/vec/drain.rs:175:5: 175:23",
  "src": "fn drop(&mut self) {\n        /// Moves back the un-`Drain`ed elements to restore the original `Vec`.\n        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n\n        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n            fn drop(&mut self) {\n                if self.0.tail_len > 0 {\n                    unsafe {\n                        let source_vec = self.0.vec.as_mut();\n                        // memmove back untouched tail, update to new length\n                        let start = source_vec.len();\n                        let tail = self.0.tail_start;\n                        if tail != start {\n                            let src = source_vec.as_ptr().add(tail);\n                            let dst = source_vec.as_mut_ptr().add(start);\n                            ptr::copy(src, dst, self.0.tail_len);\n                        }\n                        source_vec.set_len(start + self.0.tail_len);\n                    }\n                }\n            }\n        }\n\n        let iter = mem::take(&mut self.iter);\n        let drop_len = iter.len();\n\n        let mut vec = self.vec;\n\n        if T::IS_ZST {\n            // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.\n            // this can be achieved by manipulating the Vec length instead of moving values out from `iter`.\n            unsafe {\n                let vec = vec.as_mut();\n                let old_len = vec.len();\n                vec.set_len(old_len + drop_len + self.tail_len);\n                vec.truncate(old_len + self.tail_len);\n            }\n\n            return;\n        }\n\n        // ensure elements are moved back into their appropriate places, even when drop_in_place panics\n        let _guard = DropGuard(self);\n\n        if drop_len == 0 {\n            return;\n        }\n\n        // as_slice() must only be called when iter.len() is > 0 because\n        // it also gets touched by vec::Splice which may turn it into a dangling pointer\n        // which would make it and the vec pointer point to different allocations which would\n        // lead to invalid pointer arithmetic below.\n        let drop_ptr = iter.as_slice().as_ptr();\n\n        unsafe {\n            // drop_ptr comes from a slice::Iter which only gives us a &[T] but for drop_in_place\n            // a pointer with mutable provenance is necessary. Therefore we must reconstruct\n            // it from the original vec but also avoid creating a &mut to the front since that could\n            // invalidate raw pointers to it which some unsafe code might rely on.\n            let vec_ptr = vec.as_mut().as_mut_ptr();\n            let drop_offset = drop_ptr.offset_from_unsigned(vec_ptr);\n            let to_drop = ptr::slice_from_raw_parts_mut(vec_ptr.add(drop_offset), drop_len);\n            ptr::drop_in_place(to_drop);\n        }\n    }"
}