{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::wrap_copy",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:375:5: 375:71",
  "src": "unsafe fn wrap_copy(&mut self, src: usize, dst: usize, len: usize) {\n        debug_assert!(\n            cmp::min(src.abs_diff(dst), self.capacity() - src.abs_diff(dst)) + len\n                <= self.capacity(),\n            \"wrc dst={} src={} len={} cap={}\",\n            dst,\n            src,\n            len,\n            self.capacity()\n        );\n\n        // If T is a ZST, don't do any copying.\n        if T::IS_ZST || src == dst || len == 0 {\n            return;\n        }\n\n        let dst_after_src = self.wrap_sub(dst, src) < len;\n\n        let src_pre_wrap_len = self.capacity() - src;\n        let dst_pre_wrap_len = self.capacity() - dst;\n        let src_wraps = src_pre_wrap_len < len;\n        let dst_wraps = dst_pre_wrap_len < len;\n\n        match (dst_after_src, src_wraps, dst_wraps) {\n            (_, false, false) => {\n                // src doesn't wrap, dst doesn't wrap\n                //\n                //        S . . .\n                // 1 [_ _ A A B B C C _]\n                // 2 [_ _ A A A A B B _]\n                //            D . . .\n                //\n                unsafe {\n                    self.copy(src, dst, len);\n                }\n            }\n            (false, false, true) => {\n                // dst before src, src doesn't wrap, dst wraps\n                //\n                //    S . . .\n                // 1 [A A B B _ _ _ C C]\n                // 2 [A A B B _ _ _ A A]\n                // 3 [B B B B _ _ _ A A]\n                //    . .           D .\n                //\n                unsafe {\n                    self.copy(src, dst, dst_pre_wrap_len);\n                    self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);\n                }\n            }\n            (true, false, true) => {\n                // src before dst, src doesn't wrap, dst wraps\n                //\n                //              S . . .\n                // 1 [C C _ _ _ A A B B]\n                // 2 [B B _ _ _ A A B B]\n                // 3 [B B _ _ _ A A A A]\n                //    . .           D .\n                //\n                unsafe {\n                    self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);\n                    self.copy(src, dst, dst_pre_wrap_len);\n                }\n            }\n            (false, true, false) => {\n                // dst before src, src wraps, dst doesn't wrap\n                //\n                //    . .           S .\n                // 1 [C C _ _ _ A A B B]\n                // 2 [C C _ _ _ B B B B]\n                // 3 [C C _ _ _ B B C C]\n                //              D . . .\n                //\n                unsafe {\n                    self.copy(src, dst, src_pre_wrap_len);\n                    self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);\n                }\n            }\n            (true, true, false) => {\n                // src before dst, src wraps, dst doesn't wrap\n                //\n                //    . .           S .\n                // 1 [A A B B _ _ _ C C]\n                // 2 [A A A A _ _ _ C C]\n                // 3 [C C A A _ _ _ C C]\n                //    D . . .\n                //\n                unsafe {\n                    self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);\n                    self.copy(src, dst, src_pre_wrap_len);\n                }\n            }\n            (false, true, true) => {\n                // dst before src, src wraps, dst wraps\n                //\n                //    . . .         S .\n                // 1 [A B C D _ E F G H]\n                // 2 [A B C D _ E G H H]\n                // 3 [A B C D _ E G H A]\n                // 4 [B C C D _ E G H A]\n                //    . .         D . .\n                //\n                debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);\n                let delta = dst_pre_wrap_len - src_pre_wrap_len;\n                unsafe {\n                    self.copy(src, dst, src_pre_wrap_len);\n                    self.copy(0, dst + src_pre_wrap_len, delta);\n                    self.copy(delta, 0, len - dst_pre_wrap_len);\n                }\n            }\n            (true, true, true) => {\n                // src before dst, src wraps, dst wraps\n                //\n                //    . .         S . .\n                // 1 [A B C D _ E F G H]\n                // 2 [A A B D _ E F G H]\n                // 3 [H A B D _ E F G H]\n                // 4 [H A B D _ E F F G]\n                //    . . .         D .\n                //\n                debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);\n                let delta = src_pre_wrap_len - dst_pre_wrap_len;\n                unsafe {\n                    self.copy(0, delta, len - src_pre_wrap_len);\n                    self.copy(self.capacity() - delta, 0, delta);\n                    self.copy(src, dst, dst_pre_wrap_len);\n                }\n            }\n        }\n    }"
}