{
  "name": "alloc::collections::vec_deque::drain::Drain::<'a, T, A>::as_slices",
  "span": "$library/alloc/src/collections/vec_deque/drain.rs:56:5: 56:55",
  "src": "unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n        unsafe {\n            let deque = self.deque.as_ref();\n\n            // We know that `self.idx + self.remaining <= deque.len <= usize::MAX`, so this won't overflow.\n            let logical_remaining_range = self.idx..self.idx + self.remaining;\n\n            // SAFETY: `logical_remaining_range` represents the\n            // range into the logical buffer of elements that\n            // haven't been drained yet, so they're all initialized,\n            // and `slice::range(start..end, end) == start..end`,\n            // so the preconditions for `slice_ranges` are met.\n            let (a_range, b_range) =\n                deque.slice_ranges(logical_remaining_range.clone(), logical_remaining_range.end);\n            (deque.buffer_range(a_range), deque.buffer_range(b_range))\n        }\n    }"
}