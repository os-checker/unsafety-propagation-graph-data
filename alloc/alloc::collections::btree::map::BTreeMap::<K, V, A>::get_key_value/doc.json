{
  "name": "alloc::collections::btree::map::BTreeMap::<K, V, A>::get_key_value",
  "span": "$library/alloc/src/collections/btree/map.rs:784:5: 787:16",
  "doc": " Returns the key-value pair corresponding to the supplied key. This is\n potentially useful:\n - for key types where non-identical keys can be considered equal;\n - for getting the `&K` stored key value from a borrowed `&Q` lookup key; or\n - for getting a reference to a key with the same lifetime as the collection.\n\n The supplied key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::cmp::Ordering;\n use std::collections::BTreeMap;\n\n #[derive(Clone, Copy, Debug)]\n struct S {\n     id: u32,\n #   #[allow(unused)] // prevents a \"field `name` is never read\" error\n     name: &'static str, // ignored by equality and ordering operations\n }\n\n impl PartialEq for S {\n     fn eq(&self, other: &S) -> bool {\n         self.id == other.id\n     }\n }\n\n impl Eq for S {}\n\n impl PartialOrd for S {\n     fn partial_cmp(&self, other: &S) -> Option<Ordering> {\n         self.id.partial_cmp(&other.id)\n     }\n }\n\n impl Ord for S {\n     fn cmp(&self, other: &S) -> Ordering {\n         self.id.cmp(&other.id)\n     }\n }\n\n let j_a = S { id: 1, name: \"Jessica\" };\n let j_b = S { id: 1, name: \"Jess\" };\n let p = S { id: 2, name: \"Paul\" };\n assert_eq!(j_a, j_b);\n\n let mut map = BTreeMap::new();\n map.insert(j_a, \"Paris\");\n assert_eq!(map.get_key_value(&j_a), Some((&j_a, &\"Paris\")));\n assert_eq!(map.get_key_value(&j_b), Some((&j_a, &\"Paris\"))); // the notable case\n assert_eq!(map.get_key_value(&p), None);\n ```\n"
}