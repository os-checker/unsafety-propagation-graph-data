{
  "name": "alloc::collections::btree::map::entry::VacantEntry::<'a, K, V, A>::insert_entry",
  "span": "$library/alloc/src/collections/btree/map/entry.rs:398:5: 398:74",
  "src": "pub fn insert_entry(mut self, value: V) -> OccupiedEntry<'a, K, V, A> {\n        let handle = match self.handle {\n            None => {\n                // SAFETY: There is no tree yet so no reference to it exists.\n                let map = unsafe { self.dormant_map.reborrow() };\n                let root = map.root.insert(NodeRef::new_leaf(self.alloc.clone()).forget_type());\n                // SAFETY: We *just* created the root as a leaf, and we're\n                // stacking the new handle on the original borrow lifetime.\n                unsafe {\n                    let mut leaf = root.borrow_mut().cast_to_leaf_unchecked();\n                    leaf.push_with_handle(self.key, value)\n                }\n            }\n            Some(handle) => handle.insert_recursing(self.key, value, self.alloc.clone(), |ins| {\n                drop(ins.left);\n                // SAFETY: Pushing a new root node doesn't invalidate\n                // handles to existing nodes.\n                let map = unsafe { self.dormant_map.reborrow() };\n                let root = map.root.as_mut().unwrap(); // same as ins.left\n                root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n            }),\n        };\n\n        // SAFETY: modifying the length doesn't invalidate handles to existing nodes.\n        unsafe { self.dormant_map.reborrow().length += 1 };\n\n        OccupiedEntry {\n            handle: handle.forget_node_type(),\n            dormant_map: self.dormant_map,\n            alloc: self.alloc,\n            _marker: PhantomData,\n        }\n    }"
}