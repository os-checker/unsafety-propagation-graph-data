{
  "name": "alloc::raw_vec::RawVecInner::<A>::shrink_unchecked",
  "span": "$library/alloc/src/raw_vec/mod.rs:785:5: 789:37",
  "src": "unsafe fn shrink_unchecked(\n        &mut self,\n        cap: usize,\n        elem_layout: Layout,\n    ) -> Result<(), TryReserveError> {\n        // SAFETY: Precondition passed to caller\n        let (ptr, layout) = if let Some(mem) = unsafe { self.current_memory(elem_layout) } {\n            mem\n        } else {\n            return Ok(());\n        };\n\n        // If shrinking to 0, deallocate the buffer. We don't reach this point\n        // for the T::IS_ZST case since current_memory() will have returned\n        // None.\n        if cap == 0 {\n            unsafe { self.alloc.deallocate(ptr, layout) };\n            self.ptr =\n                unsafe { Unique::new_unchecked(ptr::without_provenance_mut(elem_layout.align())) };\n            self.cap = ZERO_CAP;\n        } else {\n            let ptr = unsafe {\n                // Layout cannot overflow here because it would have\n                // overflowed earlier when capacity was larger.\n                let new_size = elem_layout.size().unchecked_mul(cap);\n                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n                self.alloc\n                    .shrink(ptr, layout, new_layout)\n                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n            };\n            // SAFETY: if the allocation is valid, then the capacity is too\n            unsafe {\n                self.set_ptr_and_cap(ptr, cap);\n            }\n        }\n        Ok(())\n    }"
}