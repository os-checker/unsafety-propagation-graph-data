{
  "name": "alloc::vec::into_iter::IntoIter::<T, A>::into_vecdeque",
  "span": "$library/alloc/src/vec/into_iter.rs:171:5: 171:56",
  "src": "pub(crate) fn into_vecdeque(self) -> VecDeque<T, A> {\n        // Keep our `Drop` impl from dropping the elements and the allocator\n        let mut this = ManuallyDrop::new(self);\n\n        // SAFETY: This allocation originally came from a `Vec`, so it passes\n        // all those checks. We have `this.buf` ≤ `this.ptr` ≤ `this.end`,\n        // so the `offset_from_unsigned`s below cannot wrap, and will produce a well-formed\n        // range. `end` ≤ `buf + cap`, so the range will be in-bounds.\n        // Taking `alloc` is ok because nothing else is going to look at it,\n        // since our `Drop` impl isn't going to run so there's no more code.\n        unsafe {\n            let buf = this.buf.as_ptr();\n            let initialized = if T::IS_ZST {\n                // All the pointers are the same for ZSTs, so it's fine to\n                // say that they're all at the beginning of the \"allocation\".\n                0..this.len()\n            } else {\n                this.ptr.offset_from_unsigned(this.buf)..this.end.offset_from_unsigned(buf)\n            };\n            let cap = this.cap;\n            let alloc = ManuallyDrop::take(&mut this.alloc);\n            VecDeque::from_contiguous_raw_parts_in(buf, initialized, cap, alloc)\n        }\n    }"
}