{
  "name": "alloc::collections::btree::node::BalancingContext::<'a, K, V>::do_merge",
  "span": "$library/alloc/src/collections/btree/node.rs:1394:5: 1405:11",
  "src": "fn do_merge<\n        F: FnOnce(\n            NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n            NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n        ) -> R,\n        R,\n        A: Allocator,\n    >(\n        self,\n        result: F,\n        alloc: A,\n    ) -> R {\n        let Handle { node: mut parent_node, idx: parent_idx, _marker } = self.parent;\n        let old_parent_len = parent_node.len();\n        let mut left_node = self.left_child;\n        let old_left_len = left_node.len();\n        let mut right_node = self.right_child;\n        let right_len = right_node.len();\n        let new_left_len = old_left_len + 1 + right_len;\n\n        assert!(new_left_len <= CAPACITY);\n\n        unsafe {\n            *left_node.len_mut() = new_left_len as u16;\n\n            let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);\n            left_node.key_area_mut(old_left_len).write(parent_key);\n            move_to_slice(\n                right_node.key_area_mut(..right_len),\n                left_node.key_area_mut(old_left_len + 1..new_left_len),\n            );\n\n            let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);\n            left_node.val_area_mut(old_left_len).write(parent_val);\n            move_to_slice(\n                right_node.val_area_mut(..right_len),\n                left_node.val_area_mut(old_left_len + 1..new_left_len),\n            );\n\n            slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);\n            parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);\n            *parent_node.len_mut() -= 1;\n\n            if parent_node.height > 1 {\n                // SAFETY: the height of the nodes being merged is one below the height\n                // of the node of this edge, thus above zero, so they are internal.\n                let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n                let mut right_node = right_node.cast_to_internal_unchecked();\n                move_to_slice(\n                    right_node.edge_area_mut(..right_len + 1),\n                    left_node.edge_area_mut(old_left_len + 1..new_left_len + 1),\n                );\n\n                left_node.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n\n                alloc.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n            } else {\n                alloc.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n            }\n        }\n        result(parent_node, left_node)\n    }"
}