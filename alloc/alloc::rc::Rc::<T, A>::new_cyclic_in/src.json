{
  "name": "alloc::rc::Rc::<T, A>::new_cyclic_in",
  "span": "$library/alloc/src/rc.rs:863:5: 865:37",
  "src": "pub fn new_cyclic_in<F>(data_fn: F, alloc: A) -> Rc<T, A>\n    where\n        F: FnOnce(&Weak<T, A>) -> T,\n    {\n        // Construct the inner in the \"uninitialized\" state with a single\n        // weak reference.\n        let (uninit_raw_ptr, alloc) = Box::into_raw_with_allocator(Box::new_in(\n            RcInner {\n                strong: Cell::new(0),\n                weak: Cell::new(1),\n                value: mem::MaybeUninit::<T>::uninit(),\n            },\n            alloc,\n        ));\n        let uninit_ptr: NonNull<_> = (unsafe { &mut *uninit_raw_ptr }).into();\n        let init_ptr: NonNull<RcInner<T>> = uninit_ptr.cast();\n\n        let weak = Weak { ptr: init_ptr, alloc };\n\n        // It's important we don't give up ownership of the weak pointer, or\n        // else the memory might be freed by the time `data_fn` returns. If\n        // we really wanted to pass ownership, we could create an additional\n        // weak pointer for ourselves, but this would result in additional\n        // updates to the weak reference count which might not be necessary\n        // otherwise.\n        let data = data_fn(&weak);\n\n        let strong = unsafe {\n            let inner = init_ptr.as_ptr();\n            ptr::write(&raw mut (*inner).value, data);\n\n            let prev_value = (*inner).strong.get();\n            debug_assert_eq!(prev_value, 0, \"No prior strong references should exist\");\n            (*inner).strong.set(1);\n\n            // Strong references should collectively own a shared weak reference,\n            // so don't run the destructor for our old weak reference.\n            // Calling into_raw_with_allocator has the double effect of giving us back the allocator,\n            // and forgetting the weak reference.\n            let alloc = weak.into_raw_with_allocator().1;\n\n            Rc::from_inner_in(init_ptr, alloc)\n        };\n\n        strong\n    }"
}