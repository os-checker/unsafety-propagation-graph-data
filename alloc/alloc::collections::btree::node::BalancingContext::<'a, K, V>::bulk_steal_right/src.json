{
  "name": "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right",
  "span": "$library/alloc/src/collections/btree/node.rs:1591:5: 1591:60",
  "src": "pub(super) fn bulk_steal_right(&mut self, count: usize) {\n        assert!(count > 0);\n        unsafe {\n            let left_node = &mut self.left_child;\n            let old_left_len = left_node.len();\n            let right_node = &mut self.right_child;\n            let old_right_len = right_node.len();\n\n            // Make sure that we may steal safely.\n            assert!(old_left_len + count <= CAPACITY);\n            assert!(old_right_len >= count);\n\n            let new_left_len = old_left_len + count;\n            let new_right_len = old_right_len - count;\n            *left_node.len_mut() = new_left_len as u16;\n            *right_node.len_mut() = new_right_len as u16;\n\n            // Move leaf data.\n            {\n                // Move the rightmost stolen pair to the parent.\n                let k = right_node.key_area_mut(count - 1).assume_init_read();\n                let v = right_node.val_area_mut(count - 1).assume_init_read();\n                let (k, v) = self.parent.replace_kv(k, v);\n\n                // Move parent's key-value pair to the left child.\n                left_node.key_area_mut(old_left_len).write(k);\n                left_node.val_area_mut(old_left_len).write(v);\n\n                // Move elements from the right child to the left one.\n                move_to_slice(\n                    right_node.key_area_mut(..count - 1),\n                    left_node.key_area_mut(old_left_len + 1..new_left_len),\n                );\n                move_to_slice(\n                    right_node.val_area_mut(..count - 1),\n                    left_node.val_area_mut(old_left_len + 1..new_left_len),\n                );\n\n                // Fill gap where stolen elements used to be.\n                slice_shl(right_node.key_area_mut(..old_right_len), count);\n                slice_shl(right_node.val_area_mut(..old_right_len), count);\n            }\n\n            match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {\n                    // Steal edges.\n                    move_to_slice(\n                        right.edge_area_mut(..count),\n                        left.edge_area_mut(old_left_len + 1..new_left_len + 1),\n                    );\n\n                    // Fill gap where stolen edges used to be.\n                    slice_shl(right.edge_area_mut(..old_right_len + 1), count);\n\n                    left.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n                    right.correct_childrens_parent_links(0..new_right_len + 1);\n                }\n                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                _ => unreachable!(),\n            }\n        }\n    }"
}