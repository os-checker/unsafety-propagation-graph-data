{
  "name": "alloc::boxed::thin::WithHeader::<H>::new_unsize_zst",
  "span": "$library/alloc/src/boxed/thin.rs:309:5: 312:24",
  "src": "fn new_unsize_zst<Dyn, T>(value: T) -> WithHeader<H>\n    where\n        Dyn: Pointee<Metadata = H> + ?Sized,\n        T: Unsize<Dyn>,\n    {\n        assert!(size_of::<T>() == 0);\n\n        const fn max(a: usize, b: usize) -> usize {\n            if a > b { a } else { b }\n        }\n\n        // Compute a pointer to the right metadata. This will point to the beginning\n        // of the header, past the padding, so the assigned type makes sense.\n        // It also ensures that the address at the end of the header is sufficiently\n        // aligned for T.\n        let alloc: &<Dyn as Pointee>::Metadata = const {\n            // FIXME: just call `WithHeader::alloc_layout` with size reset to 0.\n            // Currently that's blocked on `Layout::extend` not being `const fn`.\n\n            let alloc_align = max(align_of::<T>(), align_of::<<Dyn as Pointee>::Metadata>());\n\n            let alloc_size = max(align_of::<T>(), size_of::<<Dyn as Pointee>::Metadata>());\n\n            unsafe {\n                // SAFETY: align is power of two because it is the maximum of two alignments.\n                let alloc: *mut u8 = const_allocate(alloc_size, alloc_align);\n\n                let metadata_offset =\n                    alloc_size.checked_sub(size_of::<<Dyn as Pointee>::Metadata>()).unwrap();\n                // SAFETY: adding offset within the allocation.\n                let metadata_ptr: *mut <Dyn as Pointee>::Metadata =\n                    alloc.add(metadata_offset).cast();\n                // SAFETY: `*metadata_ptr` is within the allocation.\n                metadata_ptr.write(ptr::metadata::<Dyn>(ptr::dangling::<T>() as *const Dyn));\n                // SAFETY: valid heap allocation\n                const_make_global(alloc);\n                // SAFETY: we have just written the metadata.\n                &*metadata_ptr\n            }\n        };\n\n        // SAFETY: `alloc` points to `<Dyn as Pointee>::Metadata`, so addition stays in-bounds.\n        let value_ptr =\n            unsafe { (alloc as *const <Dyn as Pointee>::Metadata).add(1) }.cast::<T>().cast_mut();\n        debug_assert!(value_ptr.is_aligned());\n        mem::forget(value);\n        WithHeader(NonNull::new(value_ptr.cast()).unwrap(), PhantomData)\n    }"
}