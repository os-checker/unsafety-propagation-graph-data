{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::handle_capacity_increase",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:621:5: 621:71",
  "src": "unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n        let new_capacity = self.capacity();\n        debug_assert!(new_capacity >= old_capacity);\n\n        // Move the shortest contiguous section of the ring buffer\n        //\n        // H := head\n        // L := last element (`self.to_physical_idx(self.len - 1)`)\n        //\n        //    H             L\n        //   [o o o o o o o o ]\n        //    H             L\n        // A [o o o o o o o o . . . . . . . . ]\n        //        L H\n        //   [o o o o o o o o ]\n        //          H             L\n        // B [. . . o o o o o o o o . . . . . ]\n        //              L H\n        //   [o o o o o o o o ]\n        //              L                 H\n        // C [o o o o o o . . . . . . . . o o ]\n\n        // can't use is_contiguous() because the capacity is already updated.\n        if self.head <= old_capacity - self.len {\n            // A\n            // Nop\n        } else {\n            let head_len = old_capacity - self.head;\n            let tail_len = self.len - head_len;\n            if head_len > tail_len && new_capacity - old_capacity >= tail_len {\n                // B\n                unsafe {\n                    self.copy_nonoverlapping(0, old_capacity, tail_len);\n                }\n            } else {\n                // C\n                let new_head = new_capacity - head_len;\n                unsafe {\n                    // can't use copy_nonoverlapping here, because if e.g. head_len = 2\n                    // and new_capacity = old_capacity + 1, then the heads overlap.\n                    self.copy(self.head, new_head, head_len);\n                }\n                self.head = new_head;\n            }\n        }\n        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n    }"
}