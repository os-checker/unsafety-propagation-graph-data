{
  "name": "alloc::vec::in_place_collect::needs_realloc",
  "span": "$library/alloc/src/vec/in_place_collect.rs:192:1: 192:74",
  "src": "const fn needs_realloc<SRC, DEST>(src_cap: usize, dst_cap: usize) -> bool {\n    if const { align_of::<SRC>() != align_of::<DEST>() } {\n        // FIXME(const-hack): use unreachable! once that works in const\n        panic!(\"in_place_collectible() prevents this\");\n    }\n\n    // If src type size is an integer multiple of the destination type size then\n    // the caller will have calculated a `dst_cap` that is an integer multiple of\n    // `src_cap` without remainder.\n    if const {\n        let src_sz = size_of::<SRC>();\n        let dest_sz = size_of::<DEST>();\n        dest_sz != 0 && src_sz % dest_sz == 0\n    } {\n        return false;\n    }\n\n    // type layouts don't guarantee a fit, so do a runtime check to see if\n    // the allocations happen to match\n    src_cap > 0 && src_cap * size_of::<SRC>() != dst_cap * size_of::<DEST>()\n}"
}