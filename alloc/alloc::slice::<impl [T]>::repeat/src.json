{
  "name": "alloc::slice::<impl [T]>::repeat",
  "span": "$library/alloc/src/slice.rs:507:5: 509:17",
  "src": "pub fn repeat(&self, n: usize) -> Vec<T>\n    where\n        T: Copy,\n    {\n        if n == 0 {\n            return Vec::new();\n        }\n\n        // If `n` is larger than zero, it can be split as\n        // `n = 2^expn + rem (2^expn > rem, expn >= 0, rem >= 0)`.\n        // `2^expn` is the number represented by the leftmost '1' bit of `n`,\n        // and `rem` is the remaining part of `n`.\n\n        // Using `Vec` to access `set_len()`.\n        let capacity = self.len().checked_mul(n).expect(\"capacity overflow\");\n        let mut buf = Vec::with_capacity(capacity);\n\n        // `2^expn` repetition is done by doubling `buf` `expn`-times.\n        buf.extend(self);\n        {\n            let mut m = n >> 1;\n            // If `m > 0`, there are remaining bits up to the leftmost '1'.\n            while m > 0 {\n                // `buf.extend(buf)`:\n                unsafe {\n                    ptr::copy_nonoverlapping::<T>(\n                        buf.as_ptr(),\n                        (buf.as_mut_ptr()).add(buf.len()),\n                        buf.len(),\n                    );\n                    // `buf` has capacity of `self.len() * n`.\n                    let buf_len = buf.len();\n                    buf.set_len(buf_len * 2);\n                }\n\n                m >>= 1;\n            }\n        }\n\n        // `rem` (`= n - 2^expn`) repetition is done by copying\n        // first `rem` repetitions from `buf` itself.\n        let rem_len = capacity - buf.len(); // `self.len() * rem`\n        if rem_len > 0 {\n            // `buf.extend(buf[0 .. rem_len])`:\n            unsafe {\n                // This is non-overlapping since `2^expn > rem`.\n                ptr::copy_nonoverlapping::<T>(\n                    buf.as_ptr(),\n                    (buf.as_mut_ptr()).add(buf.len()),\n                    rem_len,\n                );\n                // `buf.len() + rem_len` equals to `buf.capacity()` (`= self.len() * n`).\n                buf.set_len(capacity);\n            }\n        }\n        buf\n    }"
}