{
  "name": "alloc::rc::Rc::<T, A>::unwrap_or_clone",
  "span": "$library/alloc/src/rc.rs:2136:5: 2136:44",
  "doc": " If we have the only reference to `T` then unwrap it. Otherwise, clone `T` and return the\n clone.\n\n Assuming `rc_t` is of type `Rc<T>`, this function is functionally equivalent to\n `(*rc_t).clone()`, but will avoid cloning the inner value where possible.\n\n # Examples\n\n ```\n # use std::{ptr, rc::Rc};\n let inner = String::from(\"test\");\n let ptr = inner.as_ptr();\n\n let rc = Rc::new(inner);\n let inner = Rc::unwrap_or_clone(rc);\n // The inner value was not cloned\n assert!(ptr::eq(ptr, inner.as_ptr()));\n\n let rc = Rc::new(inner);\n let rc2 = rc.clone();\n let inner = Rc::unwrap_or_clone(rc);\n // Because there were 2 references, we had to clone the inner value.\n assert!(!ptr::eq(ptr, inner.as_ptr()));\n // `rc2` is the last reference, so when we unwrap it we get back\n // the original `String`.\n let inner = Rc::unwrap_or_clone(rc2);\n assert!(ptr::eq(ptr, inner.as_ptr()));\n ```\n"
}