{
  "name": "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::next_back",
  "span": "$library/alloc/src/vec/into_iter.rs:382:5: 382:41",
  "src": "fn next_back(&mut self) -> Option<T> {\n        if T::IS_ZST {\n            if self.ptr.as_ptr() == self.end as *mut _ {\n                return None;\n            }\n            // See above for why 'ptr.offset' isn't used\n            self.end = self.end.wrapping_byte_sub(1);\n            // Note that even though this is next_back() we're reading from `self.ptr`, not\n            // `self.end`. We track our length using the byte offset from `self.ptr` to `self.end`,\n            // so the end pointer may not be suitably aligned for T.\n            Some(unsafe { ptr::read(self.ptr.as_ptr()) })\n        } else {\n            if self.ptr == non_null!(self.end, T) {\n                return None;\n            }\n            unsafe {\n                self.end = self.end.sub(1);\n                Some(ptr::read(self.end))\n            }\n        }\n    }"
}