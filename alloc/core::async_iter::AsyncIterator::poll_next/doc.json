{
  "name": "core::async_iter::AsyncIterator::poll_next",
  "span": "$library/core/src/async_iter/async_iter.rs:51:5: 51:90",
  "doc": " Attempts to pull out the next value of this async iterator, registering the\n current task for wakeup if the value is not yet available, and returning\n `None` if the async iterator is exhausted.\n\n # Return value\n\n There are several possible return values, each indicating a distinct\n async iterator state:\n\n - `Poll::Pending` means that this async iterator's next value is not ready\n   yet. Implementations will ensure that the current task will be notified\n   when the next value may be ready.\n\n - `Poll::Ready(Some(val))` means that the async iterator has successfully\n   produced a value, `val`, and may produce further values on subsequent\n   `poll_next` calls.\n\n - `Poll::Ready(None)` means that the async iterator has terminated, and\n   `poll_next` should not be invoked again.\n\n # Panics\n\n Once an async iterator has finished (returned `Ready(None)` from `poll_next`), calling its\n `poll_next` method again may panic, block forever, or cause other kinds of\n problems; the `AsyncIterator` trait places no requirements on the effects of\n such a call. However, as the `poll_next` method is not marked `unsafe`,\n Rust's usual rules apply: calls must never cause undefined behavior\n (memory corruption, incorrect use of `unsafe` functions, or the like),\n regardless of the async iterator's state.\n"
}