{
  "name": "alloc::ffi::c_str::CString::from_raw",
  "span": "$library/alloc/src/ffi/c_str.rs:397:5: 397:56",
  "doc": " Retakes ownership of a `CString` that was transferred to C via\n [`CString::into_raw`].\n\n Additionally, the length of the string will be recalculated from the pointer.\n\n # Safety\n\n This should only ever be called with a pointer that was earlier\n obtained by calling [`CString::into_raw`], and the memory it points to must not be accessed\n through any other pointer during the lifetime of reconstructed `CString`.\n Other usage (e.g., trying to take ownership of a string that was allocated by foreign code)\n is likely to lead to undefined behavior or allocator corruption.\n\n This function does not validate ownership of the raw pointer's memory.\n A double-free may occur if the function is called twice on the same raw pointer.\n Additionally, the caller must ensure the pointer is not dangling.\n\n It should be noted that the length isn't just \"recomputed,\" but that\n the recomputed length must match the original length from the\n [`CString::into_raw`] call. This means the [`CString::into_raw`]/`from_raw`\n methods should not be used when passing the string to C functions that can\n modify the string's length.\n\n > **Note:** If you need to borrow a string that was allocated by\n > foreign code, use [`CStr`]. If you need to take ownership of\n > a string that was allocated by foreign code, you will need to\n > make your own provisions for freeing it appropriately, likely\n > with the foreign code's API to do that.\n\n # Examples\n\n Creates a `CString`, pass ownership to an `extern` function (via raw pointer), then retake\n ownership with `from_raw`:\n\n ```ignore (extern-declaration)\n use std::ffi::CString;\n use std::os::raw::c_char;\n\n extern \"C\" {\n     fn some_extern_function(s: *mut c_char);\n }\n\n let c_string = CString::from(c\"Hello!\");\n let raw = c_string.into_raw();\n unsafe {\n     some_extern_function(raw);\n     let c_string = CString::from_raw(raw);\n }\n ```\n"
}