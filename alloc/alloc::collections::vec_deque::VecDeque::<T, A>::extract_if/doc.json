{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::extract_if",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:751:5: 754:31",
  "doc": " Creates an iterator which uses a closure to determine if an element in the range should be removed.\n\n If the closure returns `true`, the element is removed from the deque and yielded. If the closure\n returns `false`, or panics, the element remains in the deque and will not be yielded.\n\n Only elements that fall in the provided range are considered for extraction, but any elements\n after the range will still have to be moved if any element has been extracted.\n\n If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n or the iteration short-circuits, then the remaining elements will be retained.\n Use `extract_if().for_each(drop)` if you do not need the returned iterator,\n or [`retain_mut`] with a negated predicate if you also do not need to restrict the range.\n\n [`retain_mut`]: VecDeque::retain_mut\n\n Using this method is equivalent to the following code:\n\n ```\n #![feature(vec_deque_extract_if)]\n # use std::collections::VecDeque;\n # let some_predicate = |x: &mut i32| { *x % 2 == 1 };\n # let mut deq: VecDeque<_> = (0..10).collect();\n # let mut deq2 = deq.clone();\n # let range = 1..5;\n let mut i = range.start;\n let end_items = deq.len() - range.end;\n # let mut extracted = vec![];\n\n while i < deq.len() - end_items {\n     if some_predicate(&mut deq[i]) {\n         let val = deq.remove(i).unwrap();\n         // your code here\n #         extracted.push(val);\n     } else {\n         i += 1;\n     }\n }\n\n # let extracted2: Vec<_> = deq2.extract_if(range, some_predicate).collect();\n # assert_eq!(deq, deq2);\n # assert_eq!(extracted, extracted2);\n ```\n\n But `extract_if` is easier to use. `extract_if` is also more efficient,\n because it can backshift the elements of the array in bulk.\n\n The iterator also lets you mutate the value of each element in the\n closure, regardless of whether you choose to keep or remove it.\n\n # Panics\n\n If `range` is out of bounds.\n\n # Examples\n\n Splitting a deque into even and odd values, reusing the original deque:\n\n ```\n #![feature(vec_deque_extract_if)]\n use std::collections::VecDeque;\n\n let mut numbers = VecDeque::from([1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15]);\n\n let evens = numbers.extract_if(.., |x| *x % 2 == 0).collect::<VecDeque<_>>();\n let odds = numbers;\n\n assert_eq!(evens, VecDeque::from([2, 4, 6, 8, 14]));\n assert_eq!(odds, VecDeque::from([1, 3, 5, 9, 11, 13, 15]));\n ```\n\n Using the range argument to only process a part of the deque:\n\n ```\n #![feature(vec_deque_extract_if)]\n use std::collections::VecDeque;\n\n let mut items = VecDeque::from([0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 1, 2]);\n let ones = items.extract_if(7.., |x| *x == 1).collect::<VecDeque<_>>();\n assert_eq!(items, VecDeque::from([0, 0, 0, 0, 0, 0, 0, 2, 2, 2]));\n assert_eq!(ones.len(), 3);\n ```\n"
}