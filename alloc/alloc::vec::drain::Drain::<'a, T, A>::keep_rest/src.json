{
  "name": "alloc::vec::drain::Drain::<'a, T, A>::keep_rest",
  "span": "$library/alloc/src/vec/drain.rs:89:5: 89:27",
  "src": "pub fn keep_rest(self) {\n        // At this moment layout looks like this:\n        //\n        // [head] [yielded by next] [unyielded] [yielded by next_back] [tail]\n        //        ^-- start         \\_________/-- unyielded_len        \\____/-- self.tail_len\n        //                          ^-- unyielded_ptr                  ^-- tail\n        //\n        // Normally `Drop` impl would drop [unyielded] and then move [tail] to the `start`.\n        // Here we want to\n        // 1. Move [unyielded] to `start`\n        // 2. Move [tail] to a new start at `start + len(unyielded)`\n        // 3. Update length of the original vec to `len(head) + len(unyielded) + len(tail)`\n        //    a. In case of ZST, this is the only thing we want to do\n        // 4. Do *not* drop self, as everything is put in a consistent state already, there is nothing to do\n        let mut this = ManuallyDrop::new(self);\n\n        unsafe {\n            let source_vec = this.vec.as_mut();\n\n            let start = source_vec.len();\n            let tail = this.tail_start;\n\n            let unyielded_len = this.iter.len();\n            let unyielded_ptr = this.iter.as_slice().as_ptr();\n\n            // ZSTs have no identity, so we don't need to move them around.\n            if !T::IS_ZST {\n                let start_ptr = source_vec.as_mut_ptr().add(start);\n\n                // memmove back unyielded elements\n                if unyielded_ptr != start_ptr {\n                    let src = unyielded_ptr;\n                    let dst = start_ptr;\n\n                    ptr::copy(src, dst, unyielded_len);\n                }\n\n                // memmove back untouched tail\n                if tail != (start + unyielded_len) {\n                    let src = source_vec.as_ptr().add(tail);\n                    let dst = start_ptr.add(unyielded_len);\n                    ptr::copy(src, dst, this.tail_len);\n                }\n            }\n\n            source_vec.set_len(start + unyielded_len + this.tail_len);\n        }\n    }"
}