{
  "name": "alloc::str::convert_while_ascii",
  "span": "$library/alloc/src/str.rs:634:1: 634:78",
  "src": "pub fn convert_while_ascii(s: &str, convert: fn(&u8) -> u8) -> (String, &str) {\n    // Process the input in chunks of 16 bytes to enable auto-vectorization.\n    // Previously the chunk size depended on the size of `usize`,\n    // but on 32-bit platforms with sse or neon is also the better choice.\n    // The only downside on other platforms would be a bit more loop-unrolling.\n    const N: usize = 16;\n\n    let mut slice = s.as_bytes();\n    let mut out = Vec::with_capacity(slice.len());\n    let mut out_slice = out.spare_capacity_mut();\n\n    let mut ascii_prefix_len = 0_usize;\n    let mut is_ascii = [false; N];\n\n    while slice.len() >= N {\n        // SAFETY: checked in loop condition\n        let chunk = unsafe { slice.get_unchecked(..N) };\n        // SAFETY: out_slice has at least same length as input slice and gets sliced with the same offsets\n        let out_chunk = unsafe { out_slice.get_unchecked_mut(..N) };\n\n        for j in 0..N {\n            is_ascii[j] = chunk[j] <= 127;\n        }\n\n        // Auto-vectorization for this check is a bit fragile, sum and comparing against the chunk\n        // size gives the best result, specifically a pmovmsk instruction on x86.\n        // See https://github.com/llvm/llvm-project/issues/96395 for why llvm currently does not\n        // currently recognize other similar idioms.\n        if is_ascii.iter().map(|x| *x as u8).sum::<u8>() as usize != N {\n            break;\n        }\n\n        for j in 0..N {\n            out_chunk[j] = MaybeUninit::new(convert(&chunk[j]));\n        }\n\n        ascii_prefix_len += N;\n        slice = unsafe { slice.get_unchecked(N..) };\n        out_slice = unsafe { out_slice.get_unchecked_mut(N..) };\n    }\n\n    // handle the remainder as individual bytes\n    while slice.len() > 0 {\n        let byte = slice[0];\n        if byte > 127 {\n            break;\n        }\n        // SAFETY: out_slice has at least same length as input slice\n        unsafe {\n            *out_slice.get_unchecked_mut(0) = MaybeUninit::new(convert(&byte));\n        }\n        ascii_prefix_len += 1;\n        slice = unsafe { slice.get_unchecked(1..) };\n        out_slice = unsafe { out_slice.get_unchecked_mut(1..) };\n    }\n\n    unsafe {\n        // SAFETY: ascii_prefix_len bytes have been initialized above\n        out.set_len(ascii_prefix_len);\n\n        // SAFETY: We have written only valid ascii to the output vec\n        let ascii_string = String::from_utf8_unchecked(out);\n\n        // SAFETY: we know this is a valid char boundary\n        // since we only skipped over leading ascii bytes\n        let rest = core::str::from_utf8_unchecked(slice);\n\n        (ascii_string, rest)\n    }\n}"
}