{
  "name": "core::slice::<impl [T]>::binary_search_by",
  "span": "$library/core/src/slice/mod.rs:2967:5: 2969:37",
  "doc": " Binary searches this slice with a comparator function.\n\n The comparator function should return an order code that indicates\n whether its argument is `Less`, `Equal` or `Greater` the desired\n target.\n If the slice is not sorted or if the comparator function does not\n implement an order consistent with the sort order of the underlying\n slice, the returned result is unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search`]: slice::binary_search\n [`binary_search_by_key`]: slice::binary_search_by_key\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n let seek = 13;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n let seek = 4;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n let seek = 100;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n let seek = 1;\n let r = s.binary_search_by(|probe| probe.cmp(&seek));\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n"
}