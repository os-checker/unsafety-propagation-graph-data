{
  "name": "alloc::collections::binary_heap::BinaryHeap::<T, A>::rebuild_tail",
  "span": "$library/alloc/src/collections/binary_heap/mod.rs:871:5: 871:45",
  "src": "fn rebuild_tail(&mut self, start: usize) {\n        if start == self.len() {\n            return;\n        }\n\n        let tail_len = self.len() - start;\n\n        #[inline(always)]\n        fn log2_fast(x: usize) -> usize {\n            (usize::BITS - x.leading_zeros() - 1) as usize\n        }\n\n        // `rebuild` takes O(self.len()) operations\n        // and about 2 * self.len() comparisons in the worst case\n        // while repeating `sift_up` takes O(tail_len * log(start)) operations\n        // and about 1 * tail_len * log_2(start) comparisons in the worst case,\n        // assuming start >= tail_len. For larger heaps, the crossover point\n        // no longer follows this reasoning and was determined empirically.\n        let better_to_rebuild = if start < tail_len {\n            true\n        } else if self.len() <= 2048 {\n            2 * self.len() < tail_len * log2_fast(start)\n        } else {\n            2 * self.len() < tail_len * 11\n        };\n\n        if better_to_rebuild {\n            self.rebuild();\n        } else {\n            for i in start..self.len() {\n                // SAFETY: The index `i` is always less than self.len().\n                unsafe { self.sift_up(0, i) };\n            }\n        }\n    }"
}