{
  "name": "alloc::collections::binary_heap::PeekMut::<'a, T, A>::refresh",
  "span": "$library/alloc/src/collections/binary_heap/mod.rs:411:5: 411:38",
  "doc": " Sifts the current element to its new position.\n\n Afterwards refers to the new element. Returns if the element changed.\n\n ## Examples\n\n The condition can be used to upper bound all elements in the heap. When only few elements\n are affected, the heap's sort ensures this is faster than a reconstruction from the raw\n element list and requires no additional allocation.\n\n ```\n #![feature(binary_heap_peek_mut_refresh)]\n use std::collections::BinaryHeap;\n\n let mut heap: BinaryHeap<u32> = (0..128).collect();\n let mut peek = heap.peek_mut().unwrap();\n\n loop {\n     *peek = 99;\n\n     if !peek.refresh() {\n         break;\n     }\n }\n\n // Post condition, this is now an upper bound.\n assert!(*peek < 100);\n ```\n\n When the element remains the maximum after modification, the peek remains unchanged:\n\n ```\n #![feature(binary_heap_peek_mut_refresh)]\n use std::collections::BinaryHeap;\n\n let mut heap: BinaryHeap<u32> = [1, 2, 3].into();\n let mut peek = heap.peek_mut().unwrap();\n\n assert_eq!(*peek, 3);\n *peek = 42;\n\n // When we refresh, the peek is updated to the new maximum.\n assert!(!peek.refresh(), \"42 is even larger than 3\");\n assert_eq!(*peek, 42);\n ```\n"
}