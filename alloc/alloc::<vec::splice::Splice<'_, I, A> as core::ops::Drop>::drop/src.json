{
  "name": "alloc::<vec::splice::Splice<'_, I, A> as core::ops::Drop>::drop",
  "span": "$library/alloc/src/vec/splice.rs:55:5: 55:23",
  "src": "fn drop(&mut self) {\n        self.drain.by_ref().for_each(drop);\n        // At this point draining is done and the only remaining tasks are splicing\n        // and moving things into the final place.\n        // Which means we can replace the slice::Iter with pointers that won't point to deallocated\n        // memory, so that Drain::drop is still allowed to call iter.len(), otherwise it would break\n        // the ptr.offset_from_unsigned contract.\n        self.drain.iter = (&[]).iter();\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                return;\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return;\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0 {\n                self.drain.move_tail(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return;\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n            // Now we have an exact count.\n            if collected.len() > 0 {\n                self.drain.move_tail(collected.len());\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.len(), 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n    }"
}