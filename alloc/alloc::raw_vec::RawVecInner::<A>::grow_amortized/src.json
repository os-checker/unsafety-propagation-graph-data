{
  "name": "alloc::raw_vec::RawVecInner::<A>::grow_amortized",
  "span": "$library/alloc/src/raw_vec/mod.rs:672:5: 677:37",
  "src": "unsafe fn grow_amortized(\n        &mut self,\n        len: usize,\n        additional: usize,\n        elem_layout: Layout,\n    ) -> Result<(), TryReserveError> {\n        // This is ensured by the calling contexts.\n        debug_assert!(additional > 0);\n\n        if elem_layout.size() == 0 {\n            // Since we return a capacity of `usize::MAX` when `elem_size` is\n            // 0, getting to here necessarily means the `RawVec` is overfull.\n            return Err(CapacityOverflow.into());\n        }\n\n        // Nothing we can really do about these checks, sadly.\n        let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;\n\n        // This guarantees exponential growth. The doubling cannot overflow\n        // because `cap <= isize::MAX` and the type of `cap` is `usize`.\n        let cap = cmp::max(self.cap.as_inner() * 2, required_cap);\n        let cap = cmp::max(min_non_zero_cap(elem_layout.size()), cap);\n\n        // SAFETY:\n        // - cap >= len + additional\n        // - other preconditions passed to caller\n        let ptr = unsafe { self.finish_grow(cap, elem_layout)? };\n\n        // SAFETY: `finish_grow` would have failed if `cap > isize::MAX`\n        unsafe { self.set_ptr_and_cap(ptr, cap) };\n        Ok(())\n    }"
}