{
  "name": "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert",
  "span": "$library/alloc/src/collections/btree/node.rs:953:5: 961:6",
  "src": "fn insert<A: Allocator + Clone>(\n        self,\n        key: K,\n        val: V,\n        alloc: A,\n    ) -> (\n        Option<SplitResult<'a, K, V, marker::Leaf>>,\n        Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,\n    ) {\n        if self.node.len() < CAPACITY {\n            // SAFETY: There is enough space in the node for insertion.\n            let handle = unsafe { self.insert_fit(key, val) };\n            (None, handle.dormant())\n        } else {\n            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n            let mut result = middle.split(alloc);\n            let insertion_edge = match insertion {\n                LeftOrRight::Left(insert_idx) => unsafe {\n                    Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                },\n                LeftOrRight::Right(insert_idx) => unsafe {\n                    Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                },\n            };\n            // SAFETY: We just split the node, so there is enough space for\n            // insertion.\n            let handle = unsafe { insertion_edge.insert_fit(key, val).dormant() };\n            (Some(result), handle)\n        }\n    }"
}