{
  "name": "alloc::collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree_for_bifurcation",
  "span": "$library/alloc/src/collections/btree/search.rs:83:5: 99:27",
  "src": "pub(super) fn search_tree_for_bifurcation<'r, Q: ?Sized, R>(\n        mut self,\n        range: &'r R,\n    ) -> Result<\n        (\n            NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n            usize,\n            usize,\n            SearchBound<&'r Q>,\n            SearchBound<&'r Q>,\n        ),\n        Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n    >\n    where\n        Q: Ord,\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n    {\n        // Determine if map or set is being searched\n        let is_set = <V as super::set_val::IsSetVal>::is_set_val();\n\n        // Inlining these variables should be avoided. We assume the bounds reported by `range`\n        // remain the same, but an adversarial implementation could change between calls (#81138).\n        let (start, end) = (range.start_bound(), range.end_bound());\n        match (start, end) {\n            (Bound::Excluded(s), Bound::Excluded(e)) if s == e => {\n                if is_set {\n                    panic!(\"range start and end are equal and excluded in BTreeSet\")\n                } else {\n                    panic!(\"range start and end are equal and excluded in BTreeMap\")\n                }\n            }\n            (Bound::Included(s) | Bound::Excluded(s), Bound::Included(e) | Bound::Excluded(e))\n                if s > e =>\n            {\n                if is_set {\n                    panic!(\"range start is greater than range end in BTreeSet\")\n                } else {\n                    panic!(\"range start is greater than range end in BTreeMap\")\n                }\n            }\n            _ => {}\n        }\n        let mut lower_bound = SearchBound::from_range(start);\n        let mut upper_bound = SearchBound::from_range(end);\n        loop {\n            let (lower_edge_idx, lower_child_bound) = self.find_lower_bound_index(lower_bound);\n            let (upper_edge_idx, upper_child_bound) =\n                unsafe { self.find_upper_bound_index(upper_bound, lower_edge_idx) };\n            if lower_edge_idx < upper_edge_idx {\n                return Ok((\n                    self,\n                    lower_edge_idx,\n                    upper_edge_idx,\n                    lower_child_bound,\n                    upper_child_bound,\n                ));\n            }\n            debug_assert_eq!(lower_edge_idx, upper_edge_idx);\n            let common_edge = unsafe { Handle::new_edge(self, lower_edge_idx) };\n            match common_edge.force() {\n                Leaf(common_edge) => return Err(common_edge),\n                Internal(common_edge) => {\n                    self = common_edge.descend();\n                    lower_bound = lower_child_bound;\n                    upper_bound = upper_child_bound;\n                }\n            }\n        }\n    }"
}