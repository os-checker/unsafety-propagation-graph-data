{
  "name": "alloc::collections::binary_heap::BinaryHeap::<T, A>::sift_down_range",
  "span": "$library/alloc/src/collections/binary_heap/mod.rs:776:5: 776:74",
  "src": "unsafe fn sift_down_range(&mut self, pos: usize, end: usize) -> usize {\n        // SAFETY: The caller guarantees that pos < end <= self.len().\n        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n        let mut child = 2 * hole.pos() + 1;\n\n        // Loop invariant: child == 2 * hole.pos() + 1.\n        while child <= end.saturating_sub(2) {\n            // compare with the greater of the two children\n            // SAFETY: child < end - 1 < self.len() and\n            //  child + 1 < end <= self.len(), so they're valid indexes.\n            //  child == 2 * hole.pos() + 1 != hole.pos() and\n            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n            //  if T is a ZST\n            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n\n            // if we are already in order, stop.\n            // SAFETY: child is now either the old child or the old child+1\n            //  We already proven that both are < self.len() and != hole.pos()\n            if hole.element() >= unsafe { hole.get(child) } {\n                return hole.pos();\n            }\n\n            // SAFETY: same as above.\n            unsafe { hole.move_to(child) };\n            child = 2 * hole.pos() + 1;\n        }\n\n        // SAFETY: && short circuit, which means that in the\n        //  second condition it's already true that child == end - 1 < self.len().\n        if child == end - 1 && hole.element() < unsafe { hole.get(child) } {\n            // SAFETY: child is already proven to be a valid index and\n            //  child == 2 * hole.pos() + 1 != hole.pos().\n            unsafe { hole.move_to(child) };\n        }\n\n        hole.pos()\n    }"
}