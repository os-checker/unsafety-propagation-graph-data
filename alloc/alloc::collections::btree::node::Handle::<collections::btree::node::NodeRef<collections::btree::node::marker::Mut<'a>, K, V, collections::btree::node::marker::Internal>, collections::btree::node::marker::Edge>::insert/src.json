{
  "name": "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert",
  "span": "$library/alloc/src/collections/btree/node.rs:1020:5: 1026:57",
  "src": "fn insert<A: Allocator + Clone>(\n        mut self,\n        key: K,\n        val: V,\n        edge: Root<K, V>,\n        alloc: A,\n    ) -> Option<SplitResult<'a, K, V, marker::Internal>> {\n        assert!(edge.height == self.node.height - 1);\n\n        if self.node.len() < CAPACITY {\n            self.insert_fit(key, val, edge);\n            None\n        } else {\n            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n            let mut result = middle.split(alloc);\n            let mut insertion_edge = match insertion {\n                LeftOrRight::Left(insert_idx) => unsafe {\n                    Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                },\n                LeftOrRight::Right(insert_idx) => unsafe {\n                    Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                },\n            };\n            insertion_edge.insert_fit(key, val, edge);\n            Some(result)\n        }\n    }"
}