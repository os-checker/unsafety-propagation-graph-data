{
  "name": "alloc::boxed::thin::WithHeader::<H>::drop",
  "span": "$library/alloc/src/boxed/thin.rs:361:5: 361:52",
  "src": "unsafe fn drop<T: ?Sized>(&self, value: *mut T) {\n        struct DropGuard<H> {\n            ptr: NonNull<u8>,\n            value_layout: Layout,\n            _marker: PhantomData<H>,\n        }\n\n        impl<H> Drop for DropGuard<H> {\n            fn drop(&mut self) {\n                // All ZST are allocated statically.\n                if self.value_layout.size() == 0 {\n                    return;\n                }\n\n                unsafe {\n                    // SAFETY: Layout must have been computable if we're in drop\n                    let (layout, value_offset) =\n                        WithHeader::<H>::alloc_layout(self.value_layout).unwrap_unchecked();\n\n                    // Since we only allocate for non-ZSTs, the layout size cannot be zero.\n                    debug_assert!(layout.size() != 0);\n                    alloc::dealloc(self.ptr.as_ptr().sub(value_offset), layout);\n                }\n            }\n        }\n\n        unsafe {\n            // `_guard` will deallocate the memory when dropped, even if `drop_in_place` unwinds.\n            let _guard = DropGuard {\n                ptr: self.0,\n                value_layout: Layout::for_value_raw(value),\n                _marker: PhantomData::<H>,\n            };\n\n            // We only drop the value because the Pointee trait requires that the metadata is copy\n            // aka trivially droppable.\n            ptr::drop_in_place::<T>(value);\n        }\n    }"
}