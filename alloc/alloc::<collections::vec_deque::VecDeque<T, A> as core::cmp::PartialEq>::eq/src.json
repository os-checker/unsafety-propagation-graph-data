{
  "name": "alloc::<collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq>::eq",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:3483:5: 3483:39",
  "src": "fn eq(&self, other: &Self) -> bool {\n        if self.len != other.len() {\n            return false;\n        }\n        let (sa, sb) = self.as_slices();\n        let (oa, ob) = other.as_slices();\n        if sa.len() == oa.len() {\n            sa == oa && sb == ob\n        } else if sa.len() < oa.len() {\n            // Always divisible in three sections, for example:\n            // self:  [a b c|d e f]\n            // other: [0 1 2 3|4 5]\n            // front = 3, mid = 1,\n            // [a b c] == [0 1 2] && [d] == [3] && [e f] == [4 5]\n            let front = sa.len();\n            let mid = oa.len() - front;\n\n            let (oa_front, oa_mid) = oa.split_at(front);\n            let (sb_mid, sb_back) = sb.split_at(mid);\n            debug_assert_eq!(sa.len(), oa_front.len());\n            debug_assert_eq!(sb_mid.len(), oa_mid.len());\n            debug_assert_eq!(sb_back.len(), ob.len());\n            sa == oa_front && sb_mid == oa_mid && sb_back == ob\n        } else {\n            let front = oa.len();\n            let mid = sa.len() - front;\n\n            let (sa_front, sa_mid) = sa.split_at(front);\n            let (ob_mid, ob_back) = ob.split_at(mid);\n            debug_assert_eq!(sa_front.len(), oa.len());\n            debug_assert_eq!(sa_mid.len(), ob_mid.len());\n            debug_assert_eq!(sb.len(), ob_back.len());\n            sa_front == oa && sa_mid == ob_mid && sb == ob_back\n        }\n    }"
}