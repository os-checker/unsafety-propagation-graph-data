{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::truncate_front",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1423:5: 1423:49",
  "src": "pub fn truncate_front(&mut self, len: usize) {\n        /// Runs the destructor for all items in the slice when it gets dropped (normally or\n        /// during unwinding).\n        struct Dropper<'a, T>(&'a mut [T]);\n\n        impl<'a, T> Drop for Dropper<'a, T> {\n            fn drop(&mut self) {\n                unsafe {\n                    ptr::drop_in_place(self.0);\n                }\n            }\n        }\n\n        unsafe {\n            if len >= self.len {\n                // No action is taken\n                return;\n            }\n\n            let (front, back) = self.as_mut_slices();\n            if len > back.len() {\n                // The 'back' slice remains unchanged.\n                // front.len() + back.len() == self.len, so 'end' is non-negative\n                // and end < front.len()\n                let end = front.len() - (len - back.len());\n                let drop_front = front.get_unchecked_mut(..end) as *mut _;\n                self.head += end;\n                self.len = len;\n                ptr::drop_in_place(drop_front);\n            } else {\n                let drop_front = front as *mut _;\n                // 'end' is non-negative by the condition above\n                let end = back.len() - len;\n                let drop_back = back.get_unchecked_mut(..end) as *mut _;\n                self.head = self.to_physical_idx(self.len - len);\n                self.len = len;\n\n                // Make sure the second half is dropped even when a destructor\n                // in the first one panics.\n                let _back_dropper = Dropper(&mut *drop_back);\n                ptr::drop_in_place(drop_front);\n            }\n        }\n    }"
}