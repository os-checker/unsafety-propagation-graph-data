{
  "name": "alloc::string::String::retain",
  "span": "$library/alloc/src/string.rs:1630:5: 1632:32",
  "src": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(char) -> bool,\n    {\n        struct SetLenOnDrop<'a> {\n            s: &'a mut String,\n            idx: usize,\n            del_bytes: usize,\n        }\n\n        impl<'a> Drop for SetLenOnDrop<'a> {\n            fn drop(&mut self) {\n                let new_len = self.idx - self.del_bytes;\n                debug_assert!(new_len <= self.s.len());\n                unsafe { self.s.vec.set_len(new_len) };\n            }\n        }\n\n        let len = self.len();\n        let mut guard = SetLenOnDrop { s: self, idx: 0, del_bytes: 0 };\n\n        while guard.idx < len {\n            let ch =\n                // SAFETY: `guard.idx` is positive-or-zero and less that len so the `get_unchecked`\n                // is in bound. `self` is valid UTF-8 like string and the returned slice starts at\n                // a unicode code point so the `Chars` always return one character.\n                unsafe { guard.s.get_unchecked(guard.idx..len).chars().next().unwrap_unchecked() };\n            let ch_len = ch.len_utf8();\n\n            if !f(ch) {\n                guard.del_bytes += ch_len;\n            } else if guard.del_bytes > 0 {\n                // SAFETY: `guard.idx` is in bound and `guard.del_bytes` represent the number of\n                // bytes that are erased from the string so the resulting `guard.idx -\n                // guard.del_bytes` always represent a valid unicode code point.\n                //\n                // `guard.del_bytes` >= `ch.len_utf8()`, so taking a slice with `ch.len_utf8()` len\n                // is safe.\n                ch.encode_utf8(unsafe {\n                    crate::slice::from_raw_parts_mut(\n                        guard.s.as_mut_ptr().add(guard.idx - guard.del_bytes),\n                        ch.len_utf8(),\n                    )\n                });\n            }\n\n            // Point idx to the next char\n            guard.idx += ch_len;\n        }\n\n        drop(guard);\n    }"
}