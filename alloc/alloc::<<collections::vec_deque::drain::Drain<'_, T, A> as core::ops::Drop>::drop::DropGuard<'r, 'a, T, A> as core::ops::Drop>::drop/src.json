{
  "name": "alloc::<<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'r, 'a, T, A> as core::ops::Drop>::drop",
  "span": "$library/alloc/src/collections/vec_deque/drain.rs:115:13: 115:31",
  "src": "fn drop(&mut self) {\n                if mem::needs_drop::<T>() && self.0.remaining != 0 {\n                    unsafe {\n                        // SAFETY: We just checked that `self.remaining != 0`.\n                        let (front, back) = self.0.as_slices();\n                        ptr::drop_in_place(front);\n                        ptr::drop_in_place(back);\n                    }\n                }\n\n                let source_deque = unsafe { self.0.deque.as_mut() };\n\n                let drain_len = self.0.drain_len;\n                let new_len = self.0.new_len;\n\n                if T::IS_ZST {\n                    // no need to copy around any memory if T is a ZST\n                    source_deque.len = new_len;\n                    return;\n                }\n\n                let head_len = source_deque.len; // #elements in front of the drain\n                let tail_len = new_len - head_len; // #elements behind the drain\n\n                // Next, we will fill the hole left by the drain with as few writes as possible.\n                // The code below handles the following control flow and reduces the amount of\n                // branches under the assumption that `head_len == 0 || tail_len == 0`, i.e.\n                // draining at the front or at the back of the dequeue is especially common.\n                //\n                // H = \"head index\" = `deque.head`\n                // h = elements in front of the drain\n                // d = elements in the drain\n                // t = elements behind the drain\n                //\n                // Note that the buffer may wrap at any point and the wrapping is handled by\n                // `wrap_copy` and `to_physical_idx`.\n                //\n                // Case 1: if `head_len == 0 && tail_len == 0`\n                // Everything was drained, reset the head index back to 0.\n                //             H\n                // [ . . . . . d d d d . . . . . ]\n                //   H\n                // [ . . . . . . . . . . . . . . ]\n                //\n                // Case 2: else if `tail_len == 0`\n                // Don't move data or the head index.\n                //         H\n                // [ . . . h h h h d d d d . . . ]\n                //         H\n                // [ . . . h h h h . . . . . . . ]\n                //\n                // Case 3: else if `head_len == 0`\n                // Don't move data, but move the head index.\n                //         H\n                // [ . . . d d d d t t t t . . . ]\n                //                 H\n                // [ . . . . . . . t t t t . . . ]\n                //\n                // Case 4: else if `tail_len <= head_len`\n                // Move data, but not the head index.\n                //       H\n                // [ . . h h h h d d d d t t . . ]\n                //       H\n                // [ . . h h h h t t . . . . . . ]\n                //\n                // Case 5: else\n                // Move data and the head index.\n                //       H\n                // [ . . h h d d d d t t t t . . ]\n                //               H\n                // [ . . . . . . h h t t t t . . ]\n\n                // When draining at the front (`.drain(..n)`) or at the back (`.drain(n..)`),\n                // we don't need to copy any data. The number of elements copied would be 0.\n                if head_len != 0 && tail_len != 0 {\n                    join_head_and_tail_wrapping(source_deque, drain_len, head_len, tail_len);\n                    // Marking this function as cold helps LLVM to eliminate it entirely if\n                    // this branch is never taken.\n                    // We use `#[cold]` instead of `#[inline(never)]`, because inlining this\n                    // function into the general case (`.drain(n..m)`) is fine.\n                    // See `tests/codegen-llvm/vecdeque-drain.rs` for a test.\n                    #[cold]\n                    fn join_head_and_tail_wrapping<T, A: Allocator>(\n                        source_deque: &mut VecDeque<T, A>,\n                        drain_len: usize,\n                        head_len: usize,\n                        tail_len: usize,\n                    ) {\n                        // Pick whether to move the head or the tail here.\n                        let (src, dst, len);\n                        if head_len < tail_len {\n                            src = source_deque.head;\n                            dst = source_deque.to_physical_idx(drain_len);\n                            len = head_len;\n                        } else {\n                            src = source_deque.to_physical_idx(head_len + drain_len);\n                            dst = source_deque.to_physical_idx(head_len);\n                            len = tail_len;\n                        };\n\n                        unsafe {\n                            source_deque.wrap_copy(src, dst, len);\n                        }\n                    }\n                }\n\n                if new_len == 0 {\n                    // Special case: If the entire dequeue was drained, reset the head back to 0,\n                    // like `.clear()` does.\n                    source_deque.head = 0;\n                } else if head_len < tail_len {\n                    // If we moved the head above, then we need to adjust the head index here.\n                    source_deque.head = source_deque.to_physical_idx(drain_len);\n                }\n                source_deque.len = new_len;\n            }"
}