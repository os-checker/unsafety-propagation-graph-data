{
  "name": "core::slice::<impl [T]>::as_chunks",
  "span": "$library/core/src/slice/mod.rs:1395:5: 1395:71",
  "doc": " Splits the slice into a slice of `N`-element arrays,\n starting at the beginning of the slice,\n and a remainder slice with length strictly less than `N`.\n\n The remainder is meaningful in the division sense.  Given\n `let (chunks, remainder) = slice.as_chunks()`, then:\n - `chunks.len()` equals `slice.len() / N`,\n - `remainder.len()` equals `slice.len() % N`, and\n - `slice.len()` equals `chunks.len() * N + remainder.len()`.\n\n You can flatten the chunks back into a slice-of-`T` with [`as_flattened`].\n\n [`as_flattened`]: slice::as_flattened\n\n # Panics\n\n Panics if `N` is zero.\n\n Note that this check is against a const generic parameter, not a runtime\n value, and thus a particular monomorphization will either always panic\n or it will never panic.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let (chunks, remainder) = slice.as_chunks();\n assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);\n assert_eq!(remainder, &['m']);\n ```\n\n If you expect the slice to be an exact multiple, you can combine\n `let`-`else` with an empty slice pattern:\n ```\n let slice = ['R', 'u', 's', 't'];\n let (chunks, []) = slice.as_chunks::<2>() else {\n     panic!(\"slice didn't have even length\")\n };\n assert_eq!(chunks, &[['R', 'u'], ['s', 't']]);\n ```\n"
}