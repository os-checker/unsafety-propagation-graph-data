{
  "name": "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk",
  "span": "$library/alloc/src/collections/vec_deque/into_iter.rs:132:5: 134:65",
  "src": "fn next_chunk<const N: usize>(\n        &mut self,\n    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n        let mut raw_arr = [const { MaybeUninit::uninit() }; N];\n        let raw_arr_ptr = raw_arr.as_mut_ptr().cast();\n        let (head, tail) = self.inner.as_slices();\n\n        if head.len() >= N {\n            // SAFETY: By manually adjusting the head and length of the deque, we effectively\n            // make it forget the first `N` elements, so taking ownership of them is safe.\n            unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, N) };\n            self.inner.head = self.inner.to_physical_idx(N);\n            self.inner.len -= N;\n            // SAFETY: We initialized the entire array with items from `head`\n            return Ok(unsafe { raw_arr.transpose().assume_init() });\n        }\n\n        // SAFETY: Same argument as above.\n        unsafe { ptr::copy_nonoverlapping(head.as_ptr(), raw_arr_ptr, head.len()) };\n        let remaining = N - head.len();\n\n        if tail.len() >= remaining {\n            // SAFETY: Same argument as above.\n            unsafe {\n                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), remaining)\n            };\n            self.inner.head = self.inner.to_physical_idx(N);\n            self.inner.len -= N;\n            // SAFETY: We initialized the entire array with items from `head` and `tail`\n            Ok(unsafe { raw_arr.transpose().assume_init() })\n        } else {\n            // SAFETY: Same argument as above.\n            unsafe {\n                ptr::copy_nonoverlapping(tail.as_ptr(), raw_arr_ptr.add(head.len()), tail.len())\n            };\n            let init = head.len() + tail.len();\n            // We completely drained all the deques elements.\n            self.inner.head = 0;\n            self.inner.len = 0;\n            // SAFETY: We copied all elements from both slices to the beginning of the array, so\n            // the given range is initialized.\n            Err(unsafe { array::IntoIter::new_unchecked(raw_arr, 0..init) })\n        }\n    }"
}