{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::abort_shrink",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1304:5: 1304:74",
  "src": "unsafe fn abort_shrink(&mut self, old_head: usize, target_cap: usize) {\n        // Moral equivalent of self.head + self.len <= target_cap. Won't overflow\n        // because `self.len <= target_cap`.\n        if self.head <= target_cap - self.len {\n            // The deque's buffer is contiguous, so no need to copy anything around.\n            return;\n        }\n\n        // `shrink_to` already copied the head to fit into the new capacity, so this won't overflow.\n        let head_len = target_cap - self.head;\n        // `self.head > target_cap - self.len` => `self.len > target_cap - self.head =: head_len` so this must be positive.\n        let tail_len = self.len - head_len;\n\n        if tail_len <= cmp::min(head_len, self.capacity() - target_cap) {\n            // There's enough spare capacity to copy the tail to the back (because `tail_len < self.capacity() - target_cap`),\n            // and copying the tail should be cheaper than copying the head (because `tail_len <= head_len`).\n\n            unsafe {\n                // The old tail and the new tail can't overlap because the head slice lies between them. The\n                // head slice ends at `target_cap`, so that's where we copy to.\n                self.copy_nonoverlapping(0, target_cap, tail_len);\n            }\n        } else {\n            // Either there's not enough spare capacity to make the deque contiguous, or the head is shorter than the tail\n            // (and therefore hopefully cheaper to copy).\n            unsafe {\n                // The old and the new head slice can overlap, so we can't use `copy_nonoverlapping` here.\n                self.copy(self.head, old_head, head_len);\n                self.head = old_head;\n            }\n        }\n    }"
}