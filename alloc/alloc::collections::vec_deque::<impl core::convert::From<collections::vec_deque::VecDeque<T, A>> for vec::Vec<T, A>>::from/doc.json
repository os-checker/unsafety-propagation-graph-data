{
  "name": "alloc::collections::vec_deque::<impl core::convert::From<collections::vec_deque::VecDeque<T, A>> for vec::Vec<T, A>>::from",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:3721:5: 3721:47",
  "doc": " Turn a [`VecDeque<T>`] into a [`Vec<T>`].\n\n [`Vec<T>`]: crate::vec::Vec\n [`VecDeque<T>`]: crate::collections::VecDeque\n\n This never needs to re-allocate, but does need to do *O*(*n*) data movement if\n the circular buffer doesn't happen to be at the beginning of the allocation.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n // This one is *O*(1).\n let deque: VecDeque<_> = (1..5).collect();\n let ptr = deque.as_slices().0.as_ptr();\n let vec = Vec::from(deque);\n assert_eq!(vec, [1, 2, 3, 4]);\n assert_eq!(vec.as_ptr(), ptr);\n\n // This one needs data rearranging.\n let mut deque: VecDeque<_> = (1..5).collect();\n deque.push_front(9);\n deque.push_front(8);\n let ptr = deque.as_slices().1.as_ptr();\n let vec = Vec::from(deque);\n assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n assert_eq!(vec.as_ptr(), ptr);\n ```\n"
}