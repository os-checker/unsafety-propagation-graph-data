{
  "name": "alloc::collections::binary_heap::BinaryHeap::<T, A>::sift_down_to_bottom",
  "span": "$library/alloc/src/collections/binary_heap/mod.rs:834:5: 834:61",
  "src": "unsafe fn sift_down_to_bottom(&mut self, mut pos: usize) {\n        let end = self.len();\n        let start = pos;\n\n        // SAFETY: The caller guarantees that pos < self.len().\n        let mut hole = unsafe { Hole::new(&mut self.data, pos) };\n        let mut child = 2 * hole.pos() + 1;\n\n        // Loop invariant: child == 2 * hole.pos() + 1.\n        while child <= end.saturating_sub(2) {\n            // SAFETY: child < end - 1 < self.len() and\n            //  child + 1 < end <= self.len(), so they're valid indexes.\n            //  child == 2 * hole.pos() + 1 != hole.pos() and\n            //  child + 1 == 2 * hole.pos() + 2 != hole.pos().\n            // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow\n            //  if T is a ZST\n            child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;\n\n            // SAFETY: Same as above\n            unsafe { hole.move_to(child) };\n            child = 2 * hole.pos() + 1;\n        }\n\n        if child == end - 1 {\n            // SAFETY: child == end - 1 < self.len(), so it's a valid index\n            //  and child == 2 * hole.pos() + 1 != hole.pos().\n            unsafe { hole.move_to(child) };\n        }\n        pos = hole.pos();\n        drop(hole);\n\n        // SAFETY: pos is the position in the hole and was already proven\n        //  to be a valid index.\n        unsafe { self.sift_up(start, pos) };\n    }"
}