{
  "name": "alloc::rc::Rc::<T, A>::make_mut",
  "span": "$library/alloc/src/rc.rs:2065:5: 2065:47",
  "doc": " Makes a mutable reference into the given `Rc`.\n\n If there are other `Rc` pointers to the same allocation, then `make_mut` will\n [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n referred to as clone-on-write.\n\n However, if there are no other `Rc` pointers to this allocation, but some [`Weak`]\n pointers, then the [`Weak`] pointers will be disassociated and the inner value will not\n be cloned.\n\n See also [`get_mut`], which will fail rather than cloning the inner value\n or disassociating [`Weak`] pointers.\n\n [`clone`]: Clone::clone\n [`get_mut`]: Rc::get_mut\n\n # Examples\n\n ```\n use std::rc::Rc;\n\n let mut data = Rc::new(5);\n\n *Rc::make_mut(&mut data) += 1;         // Won't clone anything\n let mut other_data = Rc::clone(&data); // Won't clone inner data\n *Rc::make_mut(&mut data) += 1;         // Clones inner data\n *Rc::make_mut(&mut data) += 1;         // Won't clone anything\n *Rc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n\n // Now `data` and `other_data` point to different allocations.\n assert_eq!(*data, 8);\n assert_eq!(*other_data, 12);\n ```\n\n [`Weak`] pointers will be disassociated:\n\n ```\n use std::rc::Rc;\n\n let mut data = Rc::new(75);\n let weak = Rc::downgrade(&data);\n\n assert!(75 == *data);\n assert!(75 == *weak.upgrade().unwrap());\n\n *Rc::make_mut(&mut data) += 1;\n\n assert!(76 == *data);\n assert!(weak.upgrade().is_none());\n ```\n"
}