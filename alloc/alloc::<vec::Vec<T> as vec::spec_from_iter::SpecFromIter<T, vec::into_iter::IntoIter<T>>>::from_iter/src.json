{
  "name": "alloc::<vec::Vec<T> as vec::spec_from_iter::SpecFromIter<T, vec::into_iter::IntoIter<T>>>::from_iter",
  "span": "$library/alloc/src/vec/spec_from_iter.rs:38:5: 38:48",
  "src": "fn from_iter(iterator: IntoIter<T>) -> Self {\n        // A common case is passing a vector into a function which immediately\n        // re-collects into a vector. We can short circuit this if the IntoIter\n        // has not been advanced at all.\n        // When it has been advanced We can also reuse the memory and move the data to the front.\n        // But we only do so when the resulting Vec wouldn't have more unused capacity\n        // than creating it through the generic FromIterator implementation would. That limitation\n        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n        // But it is a conservative choice.\n        let has_advanced = iterator.buf != iterator.ptr;\n        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n            unsafe {\n                let it = ManuallyDrop::new(iterator);\n                if has_advanced {\n                    ptr::copy(it.ptr.as_ptr(), it.buf.as_ptr(), it.len());\n                }\n                return Vec::from_parts(it.buf, it.len(), it.cap);\n            }\n        }\n\n        let mut vec = Vec::new();\n        // must delegate to spec_extend() since extend() itself delegates\n        // to spec_from for empty Vecs\n        vec.spec_extend(iterator);\n        vec\n    }"
}