{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::make_contiguous",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:2764:5: 2764:50",
  "src": "pub fn make_contiguous(&mut self) -> &mut [T] {\n        if T::IS_ZST {\n            self.head = 0;\n        }\n\n        if self.is_contiguous() {\n            unsafe { return slice::from_raw_parts_mut(self.ptr().add(self.head), self.len) }\n        }\n\n        let &mut Self { head, len, .. } = self;\n        let ptr = self.ptr();\n        let cap = self.capacity();\n\n        let free = cap - len;\n        let head_len = cap - head;\n        let tail = len - head_len;\n        let tail_len = tail;\n\n        if free >= head_len {\n            // there is enough free space to copy the head in one go,\n            // this means that we first shift the tail backwards, and then\n            // copy the head to the correct position.\n            //\n            // from: DEFGH....ABC\n            // to:   ABCDEFGH....\n            unsafe {\n                self.copy(0, head_len, tail_len);\n                // ...DEFGH.ABC\n                self.copy_nonoverlapping(head, 0, head_len);\n                // ABCDEFGH....\n            }\n\n            self.head = 0;\n        } else if free >= tail_len {\n            // there is enough free space to copy the tail in one go,\n            // this means that we first shift the head forwards, and then\n            // copy the tail to the correct position.\n            //\n            // from: FGH....ABCDE\n            // to:   ...ABCDEFGH.\n            unsafe {\n                self.copy(head, tail, head_len);\n                // FGHABCDE....\n                self.copy_nonoverlapping(0, tail + head_len, tail_len);\n                // ...ABCDEFGH.\n            }\n\n            self.head = tail;\n        } else {\n            // `free` is smaller than both `head_len` and `tail_len`.\n            // the general algorithm for this first moves the slices\n            // right next to each other and then uses `slice::rotate`\n            // to rotate them into place:\n            //\n            // initially:   HIJK..ABCDEFG\n            // step 1:      ..HIJKABCDEFG\n            // step 2:      ..ABCDEFGHIJK\n            //\n            // or:\n            //\n            // initially:   FGHIJK..ABCDE\n            // step 1:      FGHIJKABCDE..\n            // step 2:      ABCDEFGHIJK..\n\n            // pick the shorter of the 2 slices to reduce the amount\n            // of memory that needs to be moved around.\n            if head_len > tail_len {\n                // tail is shorter, so:\n                //  1. copy tail forwards\n                //  2. rotate used part of the buffer\n                //  3. update head to point to the new beginning (which is just `free`)\n\n                unsafe {\n                    // if there is no free space in the buffer, then the slices are already\n                    // right next to each other and we don't need to move any memory.\n                    if free != 0 {\n                        // because we only move the tail forward as much as there's free space\n                        // behind it, we don't overwrite any elements of the head slice, and\n                        // the slices end up right next to each other.\n                        self.copy(0, free, tail_len);\n                    }\n\n                    // We just copied the tail right next to the head slice,\n                    // so all of the elements in the range are initialized\n                    let slice = &mut *self.buffer_range(free..self.capacity());\n\n                    // because the deque wasn't contiguous, we know that `tail_len < self.len == slice.len()`,\n                    // so this will never panic.\n                    slice.rotate_left(tail_len);\n\n                    // the used part of the buffer now is `free..self.capacity()`, so set\n                    // `head` to the beginning of that range.\n                    self.head = free;\n                }\n            } else {\n                // head is shorter so:\n                //  1. copy head backwards\n                //  2. rotate used part of the buffer\n                //  3. update head to point to the new beginning (which is the beginning of the buffer)\n\n                unsafe {\n                    // if there is no free space in the buffer, then the slices are already\n                    // right next to each other and we don't need to move any memory.\n                    if free != 0 {\n                        // copy the head slice to lie right behind the tail slice.\n                        self.copy(self.head, tail_len, head_len);\n                    }\n\n                    // because we copied the head slice so that both slices lie right\n                    // next to each other, all the elements in the range are initialized.\n                    let slice = &mut *self.buffer_range(0..self.len);\n\n                    // because the deque wasn't contiguous, we know that `head_len < self.len == slice.len()`\n                    // so this will never panic.\n                    slice.rotate_right(head_len);\n\n                    // the used part of the buffer now is `0..self.len`, so set\n                    // `head` to the beginning of that range.\n                    self.head = 0;\n                }\n            }\n        }\n\n        unsafe { slice::from_raw_parts_mut(ptr.add(self.head), self.len) }\n    }"
}