{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::make_contiguous",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:2764:5: 2764:50",
  "doc": " Rearranges the internal storage of this deque so it is one contiguous\n slice, which is then returned.\n\n This method does not allocate and does not change the order of the\n inserted elements. As it returns a mutable slice, this can be used to\n sort a deque.\n\n Once the internal storage is contiguous, the [`as_slices`] and\n [`as_mut_slices`] methods will return the entire contents of the\n deque in a single slice.\n\n [`as_slices`]: VecDeque::as_slices\n [`as_mut_slices`]: VecDeque::as_mut_slices\n\n # Examples\n\n Sorting the content of a deque.\n\n ```\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::with_capacity(15);\n\n buf.push_back(2);\n buf.push_back(1);\n buf.push_front(3);\n\n // sorting the deque\n buf.make_contiguous().sort();\n assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n\n // sorting it in reverse order\n buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n ```\n\n Getting immutable access to the contiguous slice.\n\n ```rust\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::new();\n\n buf.push_back(2);\n buf.push_back(1);\n buf.push_front(3);\n\n buf.make_contiguous();\n if let (slice, &[]) = buf.as_slices() {\n     // we can now be sure that `slice` contains all elements of the deque,\n     // while still having immutable access to `buf`.\n     assert_eq!(buf.len(), slice.len());\n     assert_eq!(slice, &[3, 2, 1] as &[_]);\n }\n ```\n"
}