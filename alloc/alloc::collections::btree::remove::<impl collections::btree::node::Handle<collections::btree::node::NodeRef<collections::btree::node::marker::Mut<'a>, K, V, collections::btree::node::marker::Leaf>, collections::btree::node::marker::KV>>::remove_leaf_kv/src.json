{
  "name": "alloc::collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>>::remove_leaf_kv",
  "span": "$library/alloc/src/collections/btree/remove.rs:26:5: 30:86",
  "src": "fn remove_leaf_kv<F: FnOnce(), A: Allocator + Clone>(\n        self,\n        handle_emptied_internal_root: F,\n        alloc: A,\n    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n        let (old_kv, mut pos) = self.remove();\n        let len = pos.reborrow().into_node().len();\n        if len < MIN_LEN {\n            let idx = pos.idx();\n            // We have to temporarily forget the child type, because there is no\n            // distinct node type for the immediate parents of a leaf.\n            let new_pos = match pos.into_node().forget_type().choose_parent_kv() {\n                Ok(Left(left_parent_kv)) => {\n                    debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n                    if left_parent_kv.can_merge() {\n                        left_parent_kv.merge_tracking_child_edge(Right(idx), alloc.clone())\n                    } else {\n                        debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n                        left_parent_kv.steal_left(idx)\n                    }\n                }\n                Ok(Right(right_parent_kv)) => {\n                    debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n                    if right_parent_kv.can_merge() {\n                        right_parent_kv.merge_tracking_child_edge(Left(idx), alloc.clone())\n                    } else {\n                        debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n                        right_parent_kv.steal_right(idx)\n                    }\n                }\n                Err(pos) => unsafe { Handle::new_edge(pos, idx) },\n            };\n            // SAFETY: `new_pos` is the leaf we started from or a sibling.\n            pos = unsafe { new_pos.cast_to_leaf_unchecked() };\n\n            // Only if we merged, the parent (if any) has shrunk, but skipping\n            // the following step otherwise does not pay off in benchmarks.\n            //\n            // SAFETY: We won't destroy or rearrange the leaf where `pos` is at\n            // by handling its parent recursively; at worst we will destroy or\n            // rearrange the parent through the grandparent, thus change the\n            // link to the parent inside the leaf.\n            if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n                if !parent.into_node().forget_type().fix_node_and_affected_ancestors(alloc) {\n                    handle_emptied_internal_root();\n                }\n            }\n        }\n        (old_kv, pos)\n    }"
}