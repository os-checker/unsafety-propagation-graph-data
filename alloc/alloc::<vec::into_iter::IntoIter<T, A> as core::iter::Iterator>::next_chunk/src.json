{
  "name": "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk",
  "span": "$library/alloc/src/vec/into_iter.rs:273:5: 273:92",
  "src": "fn next_chunk<const N: usize>(&mut self) -> Result<[T; N], core::array::IntoIter<T, N>> {\n        let mut raw_ary = [const { MaybeUninit::uninit() }; N];\n\n        let len = self.len();\n\n        if T::IS_ZST {\n            if len < N {\n                self.forget_remaining_elements();\n                // Safety: ZSTs can be conjured ex nihilo, only the amount has to be correct\n                return Err(unsafe { array::IntoIter::new_unchecked(raw_ary, 0..len) });\n            }\n\n            self.end = self.end.wrapping_byte_sub(N);\n            // Safety: ditto\n            return Ok(unsafe { raw_ary.transpose().assume_init() });\n        }\n\n        if len < N {\n            // Safety: `len` indicates that this many elements are available and we just checked that\n            // it fits into the array.\n            unsafe {\n                ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, len);\n                self.forget_remaining_elements();\n                return Err(array::IntoIter::new_unchecked(raw_ary, 0..len));\n            }\n        }\n\n        // Safety: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n        // the array.\n        unsafe {\n            ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, N);\n            self.ptr = self.ptr.add(N);\n            Ok(raw_ary.transpose().assume_init())\n        }\n    }"
}