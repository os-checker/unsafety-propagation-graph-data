{
  "name": "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
  "span": "$library/alloc/src/vec/into_iter.rs:335:5: 339:39",
  "src": "fn try_fold<B, F, R>(&mut self, mut accum: B, mut f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> R,\n        R: core::ops::Try<Output = B>,\n    {\n        if T::IS_ZST {\n            while self.ptr.as_ptr() != self.end.cast_mut() {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // See `next` for why we subtract from `end` here.\n                self.end = self.end.wrapping_byte_sub(1);\n                accum = f(accum, tmp)?;\n            }\n        } else {\n            // SAFETY: `self.end` can only be null if `T` is a ZST.\n            while self.ptr != non_null!(self.end, T) {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // SAFETY: the maximum this can be is `self.end`.\n                // Increment `self.ptr` first to avoid double dropping in the event of a panic.\n                self.ptr = unsafe { self.ptr.add(1) };\n                accum = f(accum, tmp)?;\n            }\n        }\n        R::from_output(accum)\n    }"
}