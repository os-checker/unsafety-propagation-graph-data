{
  "name": "alloc::boxed::thin::WithHeader::<H>::try_new",
  "span": "$library/alloc/src/boxed/thin.rs:271:5: 271:89",
  "src": "fn try_new<T>(header: H, value: T) -> Result<WithHeader<H>, core::alloc::AllocError> {\n        let value_layout = Layout::new::<T>();\n        let Ok((layout, value_offset)) = Self::alloc_layout(value_layout) else {\n            return Err(core::alloc::AllocError);\n        };\n\n        unsafe {\n            // Note: It's UB to pass a layout with a zero size to `alloc::alloc`, so\n            // we use `layout.dangling()` for this case, which should have a valid\n            // alignment for both `T` and `H`.\n            let ptr = if layout.size() == 0 {\n                // Some paranoia checking, mostly so that the ThinBox tests are\n                // more able to catch issues.\n                debug_assert!(value_offset == 0 && size_of::<T>() == 0 && size_of::<H>() == 0);\n                layout.dangling()\n            } else {\n                let ptr = alloc::alloc(layout);\n                if ptr.is_null() {\n                    return Err(core::alloc::AllocError);\n                }\n\n                // Safety:\n                // - The size is at least `aligned_header_size`.\n                let ptr = ptr.add(value_offset) as *mut _;\n\n                NonNull::new_unchecked(ptr)\n            };\n\n            let result = WithHeader(ptr, PhantomData);\n            ptr::write(result.header(), header);\n            ptr::write(result.value().cast(), value);\n\n            Ok(result)\n        }\n    }"
}