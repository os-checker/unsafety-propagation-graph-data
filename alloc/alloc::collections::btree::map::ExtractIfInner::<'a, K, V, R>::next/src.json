{
  "name": "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next",
  "span": "$library/alloc/src/collections/btree/map.rs:2039:5: 2043:38",
  "src": "pub(super) fn next<F, A: Allocator + Clone>(&mut self, pred: &mut F, alloc: A) -> Option<(K, V)>\n    where\n        K: PartialOrd,\n        R: RangeBounds<K>,\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        while let Ok(mut kv) = self.cur_leaf_edge.take()?.next_kv() {\n            let (k, v) = kv.kv_mut();\n\n            // On creation, we navigated directly to the left bound, so we need only check the\n            // right bound here to decide whether to stop.\n            match self.range.end_bound() {\n                Bound::Included(ref end) if (*k).le(end) => (),\n                Bound::Excluded(ref end) if (*k).lt(end) => (),\n                Bound::Unbounded => (),\n                _ => return None,\n            }\n\n            if pred(k, v) {\n                *self.length -= 1;\n                let (kv, pos) = kv.remove_kv_tracking(\n                    || {\n                        // SAFETY: we will touch the root in a way that will not\n                        // invalidate the position returned.\n                        let root = unsafe { self.dormant_root.take().unwrap().awaken() };\n                        root.pop_internal_level(alloc.clone());\n                        self.dormant_root = Some(DormantMutRef::new(root).1);\n                    },\n                    alloc.clone(),\n                );\n                self.cur_leaf_edge = Some(pos);\n                return Some(kv);\n            }\n            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n        }\n        None\n    }"
}