{
  "name": "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::fold",
  "span": "$library/alloc/src/vec/into_iter.rs:309:5: 311:38",
  "src": "fn fold<B, F>(mut self, mut accum: B, mut f: F) -> B\n    where\n        F: FnMut(B, Self::Item) -> B,\n    {\n        if T::IS_ZST {\n            while self.ptr.as_ptr() != self.end.cast_mut() {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // See `next` for why we subtract from `end` here.\n                self.end = self.end.wrapping_byte_sub(1);\n                accum = f(accum, tmp);\n            }\n        } else {\n            // SAFETY: `self.end` can only be null if `T` is a ZST.\n            while self.ptr != non_null!(self.end, T) {\n                // SAFETY: we just checked that `self.ptr` is in bounds.\n                let tmp = unsafe { self.ptr.read() };\n                // SAFETY: the maximum this can be is `self.end`.\n                // Increment `self.ptr` first to avoid double dropping in the event of a panic.\n                self.ptr = unsafe { self.ptr.add(1) };\n                accum = f(accum, tmp);\n            }\n        }\n        accum\n    }"
}