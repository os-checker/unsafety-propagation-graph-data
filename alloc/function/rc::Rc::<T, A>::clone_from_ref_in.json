{
  "name": "rc::Rc::<T, A>::clone_from_ref_in",
  "safe": true,
  "callees": {
    "rc::UniqueRcUninit::<T, A>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a RcInner with layout suitable to contain `for_value` or a clone of it.\n",
      "adt": {
        "rc::UniqueRcUninit": "Constructor"
      }
    },
    "rc::UniqueRcUninit::<T, A>::data_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the pointer to be written into to initialize the [`Rc`].\n",
      "adt": {
        "rc::UniqueRcUninit": "MutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::clone::CloneToUninit::clone_to_uninit": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs copy-assignment from `self` to `dest`.\n\n This is analogous to `std::ptr::write(dest.cast(), self.clone())`,\n except that `Self` may be a dynamically-sized type ([`!Sized`](Sized)).\n\n Before this function is called, `dest` may point to uninitialized memory.\n After this function is called, `dest` will point to initialized memory; it will be\n sound to create a `&Self` reference from the pointer with the [pointer metadata]\n from `self`.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dest` must be [valid] for writes for `size_of_val(self)` bytes.\n * `dest` must be properly aligned to `align_of_val(self)`.\n\n [valid]: crate::ptr#safety\n [pointer metadata]: crate::ptr::metadata()\n\n # Panics\n\n This function may panic. (For example, it might panic if memory allocation for a clone\n of a value owned by `self` fails.)\n If the call panics, then `*dest` should be treated as uninitialized memory; it must not be\n read or dropped, because even if it was previously valid, it may have been partially\n overwritten.\n\n The caller may wish to take care to deallocate the allocation pointed to by `dest`,\n if applicable, to avoid a memory leak (but this is not a requirement).\n\n Implementors should avoid leaking values by, upon unwinding, dropping all component values\n that might have already been created. (For example, if a `[Foo]` of length 3 is being\n cloned, and the second of the three calls to `Foo::clone()` unwinds, then the first `Foo`\n cloned should be dropped.)\n",
      "adt": {}
    },
    "rc::UniqueRcUninit::<T, A>::into_rc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Upgrade this into a normal [`Rc`].\n\n # Safety\n\n The data must have been initialized (by writing to [`Self::data_ptr()`]).\n",
      "adt": {
        "rc::UniqueRcUninit": "MutableAsArgument",
        "rc::Rc": "Constructor"
      }
    }
  },
  "adts": {
    "rc::UniqueRcUninit": [
      "Plain",
      "MutRef"
    ],
    "rc::Rc": [
      "Plain"
    ]
  },
  "path": 1734,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:1345:5: 1358:6",
  "src": "pub fn clone_from_ref_in(value: &T, alloc: A) -> Rc<T, A> {\n        // `in_progress` drops the allocation if we panic before finishing initializing it.\n        let mut in_progress: UniqueRcUninit<T, A> = UniqueRcUninit::new(value, alloc);\n\n        // Initialize with clone of value.\n        let initialized_clone = unsafe {\n            // Clone. If the clone panics, `in_progress` will be dropped and clean up.\n            value.clone_to_uninit(in_progress.data_ptr().cast());\n            // Cast type of pointer, now that it is initialized.\n            in_progress.into_rc()\n        };\n\n        initialized_clone\n    }",
  "mir": "fn rc::Rc::<T, A>::clone_from_ref_in(_1: &T, _2: A) -> rc::Rc<T, A> {\n    let mut _0: rc::Rc<T, A>;\n    let mut _3: rc::UniqueRcUninit<T, A>;\n    let  _4: ();\n    let mut _5: *mut u8;\n    let mut _6: *mut T;\n    let mut _7: &mut rc::UniqueRcUninit<T, A>;\n    let mut _8: rc::UniqueRcUninit<T, A>;\n    debug value => _1;\n    debug alloc => _2;\n    debug in_progress => _3;\n    debug initialized_clone => _0;\n    bb0: {\n        StorageLive(_3);\n        _3 = rc::UniqueRcUninit::<T, A>::new(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _3;\n        _6 = rc::UniqueRcUninit::<T, A>::data_ptr(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = core::ptr::mut_ptr::<impl *mut T>::cast::<u8>(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _4 = <T as core::clone::CloneToUninit>::clone_to_uninit(_1, move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = move _3;\n        _0 = rc::UniqueRcUninit::<T, A>::into_rc(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Constructs a new `Rc<T>` with a clone of `value` in the provided allocator.\n\n # Examples\n\n ```\n #![feature(clone_from_ref)]\n #![feature(allocator_api)]\n use std::rc::Rc;\n use std::alloc::System;\n\n let hello: Rc<str, System> = Rc::clone_from_ref_in(\"hello\", System);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}