{
  "name": "fmt::format",
  "safe": true,
  "callees": {
    "core::fmt::Arguments::<'a>::as_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the formatted string, if it has no arguments to be formatted at runtime.\n\n This can be used to avoid allocations in some cases.\n\n # Guarantees\n\n For `format_args!(\"just a literal\")`, this function is guaranteed to\n return `Some(\"just a literal\")`.\n\n For most cases with placeholders, this function will return `None`.\n\n However, the compiler may perform optimizations that can cause this\n function to return `Some(_)` even if the format string contains\n placeholders. For example, `format_args!(\"Hello, {}!\", \"world\")` may be\n optimized to `format_args!(\"Hello, world!\")`, such that `as_str()`\n returns `Some(\"Hello, world!\")`.\n\n The behavior for anything but the trivial case (without placeholders)\n is not guaranteed, and should not be relied upon for anything other\n than optimization.\n\n # Examples\n\n ```rust\n use std::fmt::Arguments;\n\n fn write_str(_: &str) { /* ... */ }\n\n fn write_fmt(args: &Arguments<'_>) {\n     if let Some(s) = args.as_str() {\n         write_str(s)\n     } else {\n         write_str(&args.to_string());\n     }\n }\n ```\n\n ```rust\n assert_eq!(format_args!(\"hello\").as_str(), Some(\"hello\"));\n assert_eq!(format_args!(\"\").as_str(), Some(\"\"));\n assert_eq!(format_args!(\"{:?}\", std::env::current_dir()).as_str(), None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes a default function result (if none), or\n applies a different function to the contained value (if any).\n\n # Basic examples\n\n ```\n let k = 21;\n\n let x = Some(\"foo\");\n assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);\n\n let x: Option<&str> = None;\n assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);\n ```\n\n # Handling a Result-based fallback\n\n A somewhat common occurrence when dealing with optional values\n in combination with [`Result<T, E>`] is the case where one wants to invoke\n a fallible fallback if the option is not present.  This example\n parses a command line argument (if present), or the contents of a file to\n an integer.  However, unlike accessing the command line argument, reading\n the file is fallible, so it must be wrapped with `Ok`.\n\n ```no_run\n # fn main() -> Result<(), Box<dyn std::error::Error>> {\n let v: u64 = std::env::args()\n    .nth(1)\n    .map_or_else(|| std::fs::read_to_string(\"/etc/someconfig.conf\"), Ok)?\n    .parse()?;\n #   Ok(())\n # }\n ```\n",
      "adt": {}
    },
    "borrow::ToOwned::to_owned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates owned data from borrowed data, usually by cloning.\n\n # Examples\n\n Basic usage:\n\n ```\n let s: &str = \"a\";\n let ss: String = s.to_owned();\n\n let v: &[i32] = &[1, 2];\n let vv: Vec<i32> = v.to_owned();\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Arguments": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "string::String": [
      "Plain"
    ]
  },
  "path": 1626,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:644:1: 655:2",
  "src": "pub fn format(args: Arguments<'_>) -> string::String {\n    fn format_inner(args: Arguments<'_>) -> string::String {\n        let capacity = args.estimated_capacity();\n        let mut output = string::String::with_capacity(capacity);\n        output\n            .write_fmt(args)\n            .expect(\"a formatting trait implementation returned an error when the underlying stream did not\");\n        output\n    }\n\n    args.as_str().map_or_else(|| format_inner(args), crate::borrow::ToOwned::to_owned)\n}",
  "mir": "fn fmt::format(_1: core::fmt::Arguments<'_>) -> string::String {\n    let mut _0: string::String;\n    let mut _2: core::option::Option<&str>;\n    let mut _3: &core::fmt::Arguments<'_>;\n    let mut _4: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:654:31: 654:33};\n    let mut _5: &core::fmt::Arguments<'_>;\n    debug args => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &_1;\n        _2 = core::fmt::Arguments::<'_>::as_str(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_1;\n        _4 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:654:31: 654:33}(move _5);\n        StorageDead(_5);\n        _0 = core::option::Option::<&str>::map_or_else::<string::String, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/fmt.rs:654:31: 654:33}, for<'a> fn(&'a str) -> <str as borrow::ToOwned>::Owned {<str as borrow::ToOwned>::to_owned}>(move _2, move _4, <str as borrow::ToOwned>::to_owned) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Takes an [`Arguments`] struct and returns the resulting formatted string.\n\n The [`Arguments`] instance can be created with the [`format_args!`] macro.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::fmt;\n\n let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n assert_eq!(s, \"Hello, world!\");\n ```\n\n Please note that using [`format!`] might be preferable.\n Example:\n\n ```\n let s = format!(\"Hello, {}!\", \"world\");\n assert_eq!(s, \"Hello, world!\");\n ```\n\n [`format_args!`]: core::format_args\n [`format!`]: crate::format\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}