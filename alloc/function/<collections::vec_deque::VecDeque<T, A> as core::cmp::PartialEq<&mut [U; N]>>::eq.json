{
  "name": "<collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq<&mut [U; N]>>::eq",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n assert_eq!(deque.len(), 0);\n deque.push_back(1);\n assert_eq!(deque.len(), 1);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref"
    ]
  },
  "path": 1437,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/macros.rs:9:13: 16:14",
  "src": "fn eq(&self, other: &$rhs) -> bool {\n                if self.len() != other.len() {\n                    return false;\n                }\n                let (sa, sb) = self.as_slices();\n                let (oa, ob) = other[..].split_at(sa.len());\n                sa == oa && sb == ob\n            }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq<&mut [U; N]>>::eq(_1: &collections::vec_deque::VecDeque<T, A>, _2: &&mut [U; N]) -> bool {\n    let mut _0: bool;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: &[U];\n    let mut _7: &[U; N];\n    let  _8: &[T];\n    let  _9: &[T];\n    let mut _10: (&[T], &[T]);\n    let  _11: &[U];\n    let  _12: &[U];\n    let mut _13: (&[U], &[U]);\n    let  _14: &[U];\n    let mut _15: &[U; N];\n    let mut _16: usize;\n    let mut _17: bool;\n    let mut _18: &&[T];\n    let mut _19: &&[U];\n    let mut _20: &&[T];\n    let mut _21: &&[U];\n    let mut _22: &mut [U; N];\n    let mut _23: &mut [U; N];\n    debug self => _1;\n    debug other => _2;\n    debug sa => _8;\n    debug sb => _9;\n    debug oa => _11;\n    debug ob => _12;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = collections::vec_deque::VecDeque::<T, A>::len(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _22 = (*_2);\n        _7 = &(*_22);\n        _6 = move _7 as &[U];\n        StorageDead(_7);\n        _5 = PtrMetadata(move _6);\n        StorageDead(_6);\n        _3 = Ne(move _4, move _5);\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = false;\n        StorageDead(_3);\n        goto -> bb12;\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_10);\n        _10 = collections::vec_deque::VecDeque::<T, A>::as_slices(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = (_10.0: &[T]);\n        StorageLive(_9);\n        _9 = (_10.1: &[T]);\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_15);\n        _23 = (*_2);\n        _15 = &(*_23);\n        _14 = <[U; N] as core::ops::Index<core::ops::RangeFull>>::index(move _15, core::ops::RangeFull) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = PtrMetadata(_8);\n        _13 = core::slice::<impl [U]>::split_at(_14, move _16) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_16);\n        StorageLive(_11);\n        _11 = (_13.0: &[U]);\n        StorageLive(_12);\n        _12 = (_13.1: &[U]);\n        StorageDead(_13);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_8;\n        StorageLive(_19);\n        _19 = &_11;\n        _17 = <&[T] as core::cmp::PartialEq<&[U]>>::eq(move _18, move _19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _17) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = &_9;\n        StorageLive(_21);\n        _21 = &_12;\n        _0 = <&[T] as core::cmp::PartialEq<&[U]>>::eq(move _20, move _21) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        StorageDead(_18);\n        _0 = false;\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_9);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}