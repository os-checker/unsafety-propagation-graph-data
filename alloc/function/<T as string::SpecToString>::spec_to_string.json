{
  "name": "<T as string::SpecToString>::spec_to_string",
  "safe": true,
  "callees": {
    "string::String::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String`.\n\n Given that the `String` is empty, this will not allocate any initial\n buffer. While that means that this initial operation is very\n inexpensive, it may cause excessive allocation later when you add\n data. If you have an idea of how much data the `String` will hold,\n consider the [`with_capacity`] method to prevent excessive\n re-allocation.\n\n [`with_capacity`]: String::with_capacity\n\n # Examples\n\n ```\n let s = String::new();\n ```\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "core::fmt::FormattingOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Construct a new `FormatterBuilder` with the supplied `Write` trait\n object for output that is equivalent to the `{}` formatting\n specifier:\n\n - no flags,\n - filled with spaces,\n - no alignment,\n - no width,\n - no precision, and\n - no [`DebugAsHex`] output mode.\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new formatter with given [`FormattingOptions`].\n\n If `write` is a reference to a formatter, it is recommended to use\n [`Formatter::with_options`] instead as this can borrow the underlying\n `write`, thereby bypassing one layer of indirection.\n\n You may alternatively use [`FormattingOptions::create_formatter()`].\n",
      "adt": {}
    },
    "core::fmt::Display::fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n use std::fmt;\n\n struct Position {\n     longitude: f32,\n     latitude: f32,\n }\n\n impl fmt::Display for Position {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"({}, {})\", self.longitude, self.latitude)\n     }\n }\n\n assert_eq!(\n     \"(1.987, 2.983)\",\n     format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }),\n );\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "string::String": [
      "Plain",
      "MutRef"
    ],
    "core::fmt::FormattingOptions": [
      "Plain"
    ],
    "core::fmt::Formatter": [
      "Plain",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 106,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2883:5: 2891:6",
  "src": "default fn spec_to_string(&self) -> String {\n        let mut buf = String::new();\n        let mut formatter =\n            core::fmt::Formatter::new(&mut buf, core::fmt::FormattingOptions::new());\n        // Bypass format_args!() to avoid write_str with zero-length strs\n        fmt::Display::fmt(self, &mut formatter)\n            .expect(\"a Display implementation returned an error unexpectedly\");\n        buf\n    }",
  "mir": "fn <T as string::SpecToString>::spec_to_string(_1: &T) -> string::String {\n    let mut _0: string::String;\n    let mut _2: string::String;\n    let mut _3: core::fmt::Formatter<'_>;\n    let mut _4: &mut dyn core::fmt::Write;\n    let mut _5: &mut string::String;\n    let mut _6: core::fmt::FormattingOptions;\n    let  _7: ();\n    let mut _8: core::result::Result<(), core::fmt::Error>;\n    let mut _9: &mut core::fmt::Formatter<'_>;\n    let mut _10: &str;\n    debug self => _1;\n    debug buf => _2;\n    debug formatter => _3;\n    bb0: {\n        StorageLive(_2);\n        _2 = string::String::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = &mut _2;\n        _4 = _5 as &mut dyn core::fmt::Write;\n        StorageLive(_6);\n        _6 = core::fmt::FormattingOptions::new() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = core::fmt::Formatter::<'_>::new(move _4, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_8);\n        _9 = &mut _3;\n        _8 = <T as core::fmt::Display>::fmt(_1, _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_10);\n        _10 = \"a Display implementation returned an error unexpectedly\";\n        _7 = core::result::Result::<(), core::fmt::Error>::expect(move _8, move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_8);\n        _0 = move _2;\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}