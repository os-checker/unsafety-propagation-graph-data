{
  "name": "boxed::iter::<impl core::async_iter::AsyncIterator for boxed::Box<S>>::size_hint",
  "safe": true,
  "callees": {
    "core::async_iter::AsyncIterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the async iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an async iterator implementation yields the declared\n number of elements. A buggy async iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the async iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n async iterator.\n",
      "adt": {}
    }
  },
  "adts": {
    "boxed::Box": [
      "Plain",
      "Deref",
      "Unknown([Field(0, Ty { id: 824, kind: RigidTy(Adt(AdtDef(DefId { id: 2645, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 836, kind: Param(ParamTy { index: 0, name: \"S\" }) })]))) }), Field(0, Ty { id: 825, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 836, kind: Param(ParamTy { index: 0, name: \"S\" }) })]))) })])",
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::boxed::iter::<impl core::async_iter::AsyncIterator for boxed::Box<S>>::size_hint"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed/iter.rs:90:5: 92:6",
  "src": "fn size_hint(&self) -> (usize, Option<usize>) {\n        (**self).size_hint()\n    }",
  "mir": "fn boxed::iter::<impl core::async_iter::AsyncIterator for boxed::Box<S>>::size_hint(_1: &boxed::Box<S>) -> (usize, core::option::Option<usize>) {\n    let mut _0: (usize, core::option::Option<usize>);\n    let mut _2: &S;\n    let mut _3: boxed::Box<S>;\n    let mut _4: *const S;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _3 = (*_1);\n        _4 = ((_3.0: core::ptr::Unique<S>).0: core::ptr::NonNull<S>) as *const S;\n        _2 = &(*_4);\n        _0 = <S as core::async_iter::AsyncIterator>::size_hint(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}