{
  "name": "rc::RcInnerPtr::inc_weak",
  "safe": true,
  "callees": {
    "rc::RcInnerPtr::weak": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "core::num::<impl usize>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "rc::RcInnerPtr::weak_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::cell::Cell::<T>::set": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the contained value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n\n c.set(10);\n ```\n",
      "adt": {}
    },
    "core::intrinsics::unlikely": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Hints to the compiler that branch condition is likely to be false.\n Returns the value passed to it.\n\n Any use other than with `if` statements will probably not have an effect.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n This intrinsic does not have a stable counterpart.\n",
      "adt": {}
    },
    "core::intrinsics::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the execution of the process.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n as its behavior is more user-friendly and more stable.\n\n The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n on most platforms.\n On Unix, the\n process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n `SIGBUS`.  The precise behavior is not guaranteed and not stable.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::cell::Cell": [
      "Ref"
    ]
  },
  "path": "rc::RcInnerPtr::inc_weak",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:3768:5: 3788:6",
  "src": "fn inc_weak(&self) {\n        let weak = self.weak();\n\n        // We insert an `assume` here to hint LLVM at an otherwise\n        // missed optimization.\n        // SAFETY: The reference count will never be zero when this is\n        // called.\n        unsafe {\n            hint::assert_unchecked(weak != 0);\n        }\n\n        let weak = weak.wrapping_add(1);\n        self.weak_ref().set(weak);\n\n        // We want to abort on overflow instead of dropping the value.\n        // Checking for overflow after the store instead of before\n        // allows for slightly better code generation.\n        if core::intrinsics::unlikely(weak == 0) {\n            abort();\n        }\n    }",
  "mir": "fn rc::RcInnerPtr::inc_weak(_1: &Self) -> () {\n    let mut _0: ();\n    let  _2: usize;\n    let  _3: ();\n    let mut _4: bool;\n    let  _5: usize;\n    let  _6: ();\n    let  _7: &core::cell::Cell<usize>;\n    let mut _8: bool;\n    let mut _9: bool;\n    let  _10: !;\n    debug self => _1;\n    debug weak => _2;\n    debug weak => _5;\n    bb0: {\n        _2 = <Self as rc::RcInnerPtr>::weak(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = Ne(_2, 0_usize);\n        _3 = core::hint::assert_unchecked(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = core::num::<impl usize>::wrapping_add(_2, 1_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = <Self as rc::RcInnerPtr>::weak_ref(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = core::cell::Cell::<usize>::set(_7, _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = Eq(_5, 0_usize);\n        _8 = core::intrinsics::unlikely(move _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_9);\n        _10 = core::intrinsics::abort() -> unwind unreachable;\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}