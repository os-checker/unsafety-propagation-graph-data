{
  "name": "<I as sync::ToArcSlice<T>>::to_arc_slice",
  "safe": true,
  "callees": {
    "core::iter::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {}
    },
    "sync::Arc::<[T]>::from_iter_exact": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n\n Behavior is undefined should the size be wrong.\n",
      "adt": {
        "sync::Arc": "Constructor"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 257, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "sync::Arc": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 100,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:4156:5: 4178:6",
  "src": "fn to_arc_slice(self) -> Arc<[T]> {\n        // This is the case for a `TrustedLen` iterator.\n        let (low, high) = self.size_hint();\n        if let Some(high) = high {\n            debug_assert_eq!(\n                low,\n                high,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n\n            unsafe {\n                // SAFETY: We need to ensure that the iterator has an exact length and we have.\n                Arc::from_iter_exact(self, low)\n            }\n        } else {\n            // TrustedLen contract guarantees that `upper_bound == None` implies an iterator\n            // length exceeding `usize::MAX`.\n            // The default implementation would collect into a vec which would panic.\n            // Thus we panic here immediately without invoking `Vec` code.\n            panic!(\"capacity overflow\");\n        }\n    }",
  "mir": "fn <I as sync::ToArcSlice<T>>::to_arc_slice(_1: I) -> sync::Arc<[T]> {\n    let mut _0: sync::Arc<[T]>;\n    let  _2: usize;\n    let  _3: core::option::Option<usize>;\n    let mut _4: (usize, core::option::Option<usize>);\n    let mut _5: &I;\n    let mut _6: isize;\n    let  _7: usize;\n    let mut _8: (&usize, &usize);\n    let mut _9: &usize;\n    let mut _10: &usize;\n    let  _11: &usize;\n    let  _12: &usize;\n    let mut _13: bool;\n    let mut _14: usize;\n    let mut _15: usize;\n    let  _16: core::panicking::AssertKind;\n    let  _17: !;\n    let mut _18: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _19: core::fmt::Arguments<'_>;\n    let  _20: (&(usize, usize),);\n    let mut _21: &(usize, usize);\n    let  _22: (usize, usize);\n    let  _23: [core::fmt::rt::Argument<'_>; 1];\n    let mut _24: core::fmt::rt::Argument<'_>;\n    let mut _25: &[u8; 49];\n    let  _26: &[core::fmt::rt::Argument<'_>; 1];\n    let mut _27: I;\n    let  _28: !;\n    let mut _29: core::fmt::Arguments<'_>;\n    let mut _30: &(usize, usize);\n    debug self => _1;\n    debug low => _2;\n    debug high => _3;\n    debug high => _7;\n    debug left_val => _11;\n    debug right_val => _12;\n    debug kind => _16;\n    debug args => _20;\n    debug args => _23;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_1;\n        _4 = <I as core::iter::Iterator>::size_hint(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _2 = (_4.0: usize);\n        StorageLive(_3);\n        _3 = (_4.1: core::option::Option<usize>);\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [1: bb2, 0: bb8, otherwise: bb10];\n    }\n    bb2: {\n        _7 = ((_3 as variant#1).0: usize);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_2;\n        StorageLive(_10);\n        _10 = &_7;\n        _8 = (move _9, move _10);\n        StorageDead(_10);\n        StorageDead(_9);\n        _11 = (_8.0: &usize);\n        _12 = (_8.1: &usize);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = (*_11);\n        StorageLive(_15);\n        _15 = (*_12);\n        _13 = Eq(move _14, move _15);\n        switchInt(move _13) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_8);\n        StorageLive(_27);\n        _27 = move _1;\n        _0 = sync::Arc::<[T]>::from_iter_exact::<I>(move _27, _2) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _16 = core::panicking::AssertKind::Eq;\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = (_2, _7);\n        _21 = &_22;\n        _20 = (move _21);\n        StorageDead(_21);\n        StorageLive(_23);\n        StorageLive(_24);\n        _30 = (_20.0: &(usize, usize));\n        _24 = core::fmt::rt::Argument::<'_>::new_debug::<(usize, usize)>(_30) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _23 = [move _24];\n        StorageDead(_24);\n        StorageLive(_25);\n        _25 = b\".TrustedLen iterator\\'s size hint is not exact: \\xc0\\x00\";\n        _26 = &_23;\n        _19 = core::fmt::Arguments::<'_>::new::<49, 1>(move _25, _26) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_25);\n        _18 = core::option::Option::Some(move _19);\n        StorageDead(_19);\n        _17 = core::panicking::assert_failed::<usize, usize>(_16, _11, _12, move _18) -> unwind unreachable;\n    }\n    bb7: {\n        StorageDead(_27);\n        StorageDead(_3);\n        return;\n    }\n    bb8: {\n        StorageLive(_29);\n        _29 = core::fmt::Arguments::<'_>::from_str(\"capacity overflow\") -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _28 = core::panicking::panic_fmt(move _29) -> unwind unreachable;\n    }\n    bb10: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}