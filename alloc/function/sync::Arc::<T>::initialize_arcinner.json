{
  "name": "sync::Arc::<T>::initialize_arcinner",
  "safe": false,
  "callees": {
    "core::ptr::NonNull::<[T]>::as_non_null_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a non-null pointer to the slice's buffer.\n\n # Examples\n\n ```rust\n #![feature(slice_ptr_get)]\n use std::ptr::NonNull;\n\n let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n assert_eq!(slice.as_non_null_ptr(), NonNull::<i8>::dangling());\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::alloc::Layout::for_value_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Produces layout describing a record that could be used to\n allocate backing structure for `T` (which could be a trait\n or other unsized type like a slice).\n\n # Safety\n\n This function is only safe to call if the following conditions hold:\n\n - If `T` is `Sized`, this function is always safe to call.\n - If the unsized tail of `T` is:\n     - a [slice], then the length of the slice tail must be an initialized\n       integer, and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n       For the special case where the dynamic tail length is 0, this function\n       is safe to call.\n     - a [trait object], then the vtable part of the pointer must point\n       to a valid vtable for the type `T` acquired by an unsizing coercion,\n       and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n     - an (unstable) [extern type], then this function is always safe to\n       call, but may panic or otherwise return the wrong value, as the\n       extern type's layout is not known. This is the same behavior as\n       [`Layout::for_value`] on a reference to an extern type tail.\n     - otherwise, it is conservatively not allowed to call this function.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n [extern type]: ../../unstable-book/language-features/extern-types.html\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicUsize::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new atomic integer.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::write": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Overwrites a memory location with the given value without reading or\n dropping the old value.\n\n See [`ptr::write`] for safety concerns and examples.\n\n [`ptr::write`]: crate::ptr::write()\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ptr::NonNull": [
      "Plain"
    ],
    "core::alloc::Layout": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2073,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:2187:5: 2201:6",
  "src": "unsafe fn initialize_arcinner(\n        ptr: NonNull<[u8]>,\n        layout: Layout,\n        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n    ) -> *mut ArcInner<T> {\n        let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n        debug_assert_eq!(unsafe { Layout::for_value_raw(inner) }, layout);\n\n        unsafe {\n            (&raw mut (*inner).strong).write(atomic::AtomicUsize::new(1));\n            (&raw mut (*inner).weak).write(atomic::AtomicUsize::new(1));\n        }\n\n        inner\n    }",
  "mir": "fn sync::Arc::<T>::initialize_arcinner(_1: core::ptr::NonNull<[u8]>, _2: core::alloc::Layout, _3: impl FnOnce(*mut u8) -> *mut ArcInner<T>) -> *mut sync::ArcInner<T> {\n    let mut _0: *mut sync::ArcInner<T>;\n    let mut _4: (*mut u8,);\n    let mut _5: *mut u8;\n    let mut _6: core::ptr::NonNull<u8>;\n    let mut _7: (&core::alloc::Layout, &core::alloc::Layout);\n    let mut _8: &core::alloc::Layout;\n    let  _9: core::alloc::Layout;\n    let mut _10: *const sync::ArcInner<T>;\n    let mut _11: &core::alloc::Layout;\n    let  _12: &core::alloc::Layout;\n    let  _13: &core::alloc::Layout;\n    let mut _14: bool;\n    let  _15: core::panicking::AssertKind;\n    let  _16: !;\n    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _18: ();\n    let mut _19: *mut core::sync::atomic::AtomicUsize;\n    let mut _20: core::sync::atomic::AtomicUsize;\n    let  _21: ();\n    let mut _22: *mut core::sync::atomic::AtomicUsize;\n    let mut _23: core::sync::atomic::AtomicUsize;\n    debug ptr => _1;\n    debug layout => _2;\n    debug mem_to_arcinner => _3;\n    debug inner => _0;\n    debug left_val => _12;\n    debug right_val => _13;\n    debug kind => _15;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = core::ptr::NonNull::<[u8]>::as_non_null_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core::ptr::NonNull::<u8>::as_ptr(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = (move _5);\n        _0 = <impl FnOnce(*mut u8) -> *mut ArcInner<T> as core::ops::FnOnce<(*mut u8,)>>::call_once(_3, move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _0 as *const sync::ArcInner<T>;\n        _9 = core::alloc::Layout::for_value_raw::<sync::ArcInner<T>>(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = &_9;\n        StorageLive(_11);\n        _11 = &_2;\n        _7 = (move _8, move _11);\n        StorageDead(_11);\n        StorageDead(_8);\n        _12 = (_7.0: &core::alloc::Layout);\n        _13 = (_7.1: &core::alloc::Layout);\n        StorageLive(_14);\n        _14 = <core::alloc::Layout as core::cmp::PartialEq>::eq(_12, _13) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _14) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageLive(_19);\n        _19 = &raw mut ((*_0).0: core::sync::atomic::AtomicUsize);\n        StorageLive(_20);\n        _20 = core::sync::atomic::AtomicUsize::new(1_usize) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        _15 = core::panicking::AssertKind::Eq;\n        StorageLive(_17);\n        _17 = core::option::Option::None;\n        _16 = core::panicking::assert_failed::<core::alloc::Layout, core::alloc::Layout>(_15, _12, _13, move _17) -> unwind unreachable;\n    }\n    bb8: {\n        _18 = core::ptr::mut_ptr::<impl *mut core::sync::atomic::AtomicUsize>::write(move _19, move _20) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = &raw mut ((*_0).1: core::sync::atomic::AtomicUsize);\n        StorageLive(_23);\n        _23 = core::sync::atomic::AtomicUsize::new(1_usize) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _21 = core::ptr::mut_ptr::<impl *mut core::sync::atomic::AtomicUsize>::write(move _22, move _23) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_23);\n        StorageDead(_22);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}