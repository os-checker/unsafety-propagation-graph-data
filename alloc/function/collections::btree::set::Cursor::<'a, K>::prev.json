{
  "name": "collections::btree::set::Cursor::<'a, K>::prev",
  "safe": true,
  "callees": {
    "collections::btree::map::Cursor::<'a, K, V>::prev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the cursor to the previous gap, returning the key and value of\n the element that it moved over.\n\n If the cursor is already at the start of the map then `None` is returned\n and the cursor is not moved.\n",
      "adt": {
        "collections::btree::map::Cursor": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::map::Cursor": [
      "MutRef"
    ],
    "collections::btree::set::Cursor": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 1086,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:2221:5: 2223:6",
  "src": "pub fn prev(&mut self) -> Option<&'a K> {\n        self.inner.prev().map(|(k, _)| k)\n    }",
  "mir": "fn collections::btree::set::Cursor::<'a, K>::prev(_1: &mut collections::btree::set::Cursor<'_, K>) -> core::option::Option<&K> {\n    let mut _0: core::option::Option<&K>;\n    let mut _2: core::option::Option<(&K, &collections::btree::set_val::SetValZST)>;\n    let mut _3: &mut collections::btree::map::Cursor<'_, K, collections::btree::set_val::SetValZST>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: collections::btree::map::Cursor<'_, K, collections::btree::set_val::SetValZST>);\n        _2 = collections::btree::map::Cursor::<'_, K, collections::btree::set_val::SetValZST>::prev(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = core::option::Option::<(&K, &collections::btree::set_val::SetValZST)>::map::<&K, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:2222:31: 2222:39}>(move _2, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:2222:31: 2222:39}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Advances the cursor to the previous gap, returning the element that it\n moved over.\n\n If the cursor is already at the start of the set then `None` is returned\n and the cursor is not moved.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}