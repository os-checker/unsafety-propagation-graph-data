{
  "name": "collections::btree::node::BalancingContext::<'a, K, V>::do_merge",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::len_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to the length of the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::key_area_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to an element of the key storage area.\n\n # Safety\n `index` is in bounds of 0..CAPACITY\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::slice_remove": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes and returns a value from a slice of all initialized elements, leaving behind one\n trailing uninitialized element.\n\n # Safety\n The slice has more than `idx` elements.\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {}
    },
    "collections::btree::node::move_to_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves all values from a slice of initialized elements to a slice\n of uninitialized elements, leaving behind `src` as all uninitialized.\n Works like `dst.copy_from_slice(src)` but does not require `T` to be `Copy`.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::val_area_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to an element or slice of the node's value storage area.\n\n # Safety\n `index` is in bounds of 0..CAPACITY\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::edge_area_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to an element or slice of the node's storage area for edge contents.\n\n # Safety\n `index` is in bounds of 0..CAPACITY + 1\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n Every item returned by `range` is a valid edge index for the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_internal_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unsafely asserts to the compiler the static information that this node is an `Internal`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a `Layout` suitable for holding a value of type `T`.\n",
      "adt": {}
    },
    "core::alloc::Allocator::deallocate": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Deallocates the memory referenced by `ptr`.\n\n # Safety\n\n * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n * `layout` must [*fit*] that block of memory.\n\n [*currently allocated*]: #currently-allocated-memory\n [*fit*]: #memory-fitting\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Plain",
      "Ref",
      "MutRef",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 4365, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 4367, kind: RigidTy(Adt(AdtDef(DefId { id: 4043, name: \"collections::btree::node::LeafNode\" }), GenericArgs([Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) })])"
    ],
    "collections::btree::node::BalancingContext": [
      "Unknown([Field(0, Ty { id: 2576, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) }), Field(0, Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(0, Ty { id: 2576, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) }), Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])",
      "Plain"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::mem::MaybeUninit": [
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "core::alloc::Layout": [
      "Plain"
    ]
  },
  "path": 855,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:1394:5: 1455:6",
  "src": "fn do_merge<\n        F: FnOnce(\n            NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n            NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n        ) -> R,\n        R,\n        A: Allocator,\n    >(\n        self,\n        result: F,\n        alloc: A,\n    ) -> R {\n        let Handle { node: mut parent_node, idx: parent_idx, _marker } = self.parent;\n        let old_parent_len = parent_node.len();\n        let mut left_node = self.left_child;\n        let old_left_len = left_node.len();\n        let mut right_node = self.right_child;\n        let right_len = right_node.len();\n        let new_left_len = old_left_len + 1 + right_len;\n\n        assert!(new_left_len <= CAPACITY);\n\n        unsafe {\n            *left_node.len_mut() = new_left_len as u16;\n\n            let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);\n            left_node.key_area_mut(old_left_len).write(parent_key);\n            move_to_slice(\n                right_node.key_area_mut(..right_len),\n                left_node.key_area_mut(old_left_len + 1..new_left_len),\n            );\n\n            let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);\n            left_node.val_area_mut(old_left_len).write(parent_val);\n            move_to_slice(\n                right_node.val_area_mut(..right_len),\n                left_node.val_area_mut(old_left_len + 1..new_left_len),\n            );\n\n            slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);\n            parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);\n            *parent_node.len_mut() -= 1;\n\n            if parent_node.height > 1 {\n                // SAFETY: the height of the nodes being merged is one below the height\n                // of the node of this edge, thus above zero, so they are internal.\n                let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n                let mut right_node = right_node.cast_to_internal_unchecked();\n                move_to_slice(\n                    right_node.edge_area_mut(..right_len + 1),\n                    left_node.edge_area_mut(old_left_len + 1..new_left_len + 1),\n                );\n\n                left_node.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n\n                alloc.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());\n            } else {\n                alloc.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());\n            }\n        }\n        result(parent_node, left_node)\n    }",
  "mir": "fn collections::btree::node::BalancingContext::<'a, K, V>::do_merge(_1: collections::btree::node::BalancingContext<'_, K, V>, _2: F, _3: A) -> R {\n    let mut _0: R;\n    let mut _4: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let  _5: usize;\n    let  _6: usize;\n    let mut _7: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _8: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _9: usize;\n    let mut _10: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _11: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _12: usize;\n    let mut _13: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _14: usize;\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let mut _17: (usize, bool);\n    let mut _18: bool;\n    let mut _19: !;\n    let mut _20: &mut u16;\n    let mut _21: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _22: K;\n    let mut _23: &mut [core::mem::MaybeUninit<K>];\n    let mut _24: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _25: core::ops::RangeTo<usize>;\n    let  _26: &mut K;\n    let mut _27: &mut core::mem::MaybeUninit<K>;\n    let mut _28: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _29: ();\n    let mut _30: &mut [core::mem::MaybeUninit<K>];\n    let mut _31: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _32: core::ops::RangeTo<usize>;\n    let mut _33: &mut [core::mem::MaybeUninit<K>];\n    let mut _34: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _35: core::ops::Range<usize>;\n    let mut _36: usize;\n    let mut _37: (usize, bool);\n    let  _38: V;\n    let mut _39: &mut [core::mem::MaybeUninit<V>];\n    let mut _40: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _41: core::ops::RangeTo<usize>;\n    let  _42: &mut V;\n    let mut _43: &mut core::mem::MaybeUninit<V>;\n    let mut _44: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _45: ();\n    let mut _46: &mut [core::mem::MaybeUninit<V>];\n    let mut _47: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _48: core::ops::RangeTo<usize>;\n    let mut _49: &mut [core::mem::MaybeUninit<V>];\n    let mut _50: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _51: core::ops::Range<usize>;\n    let mut _52: usize;\n    let mut _53: (usize, bool);\n    let  _54: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>;\n    let mut _55: &mut &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _56: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _57: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _58: core::ops::RangeTo<usize>;\n    let mut _59: usize;\n    let mut _60: (usize, bool);\n    let mut _61: usize;\n    let mut _62: (usize, bool);\n    let  _63: ();\n    let mut _64: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _65: core::ops::Range<usize>;\n    let mut _66: usize;\n    let mut _67: (usize, bool);\n    let mut _68: &mut u16;\n    let mut _69: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _70: (u16, bool);\n    let mut _71: bool;\n    let mut _72: usize;\n    let mut _73: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _74: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _75: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _76: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _77: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _78: ();\n    let mut _79: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _80: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _81: core::ops::RangeTo<usize>;\n    let mut _82: usize;\n    let mut _83: (usize, bool);\n    let mut _84: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _85: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _86: core::ops::Range<usize>;\n    let mut _87: usize;\n    let mut _88: (usize, bool);\n    let mut _89: usize;\n    let mut _90: (usize, bool);\n    let  _91: ();\n    let mut _92: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _93: core::ops::Range<usize>;\n    let mut _94: usize;\n    let mut _95: (usize, bool);\n    let mut _96: usize;\n    let mut _97: (usize, bool);\n    let  _98: ();\n    let mut _99: &A;\n    let mut _100: core::ptr::NonNull<u8>;\n    let mut _101: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>;\n    let mut _102: core::alloc::Layout;\n    let  _103: ();\n    let mut _104: &A;\n    let mut _105: core::ptr::NonNull<u8>;\n    let mut _106: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>;\n    let mut _107: core::alloc::Layout;\n    let mut _108: (collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n    let mut _109: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _110: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _111: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    debug self => _1;\n    debug result => _2;\n    debug alloc => _3;\n    debug parent_node => _4;\n    debug parent_idx => _5;\n    debug _marker => core::marker::PhantomData::<collections::btree::node::marker::KV>;\n    debug old_parent_len => _6;\n    debug left_node => _8;\n    debug old_left_len => _9;\n    debug right_node => _11;\n    debug right_len => _12;\n    debug new_left_len => _14;\n    debug parent_key => _22;\n    debug parent_val => _38;\n    debug left_node => _73;\n    debug right_node => _76;\n    bb0: {\n        StorageLive(_4);\n        _4 = move ((_1.0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>).0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>);\n        _5 = ((_1.0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>).1: usize);\n        StorageLive(_7);\n        _7 = &_4;\n        _6 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::len(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = move (_1.1: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_10);\n        _10 = &_8;\n        _9 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = move (_1.2: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_13);\n        _13 = &_11;\n        _12 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _13) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_13);\n        StorageLive(_15);\n        _16 = CheckedAdd(_9, 1_usize);\n        assert(!move (_16.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _15 = move (_16.0: usize);\n        _17 = CheckedAdd(_15, _12);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _15, _12) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _14 = move (_17.0: usize);\n        StorageDead(_15);\n        StorageLive(_18);\n        _18 = Le(_14, collections::btree::node::CAPACITY);\n        switchInt(move _18) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_18);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &mut _8;\n        _20 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len_mut(move _21) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        _19 = core::panicking::panic(\"assertion failed: new_left_len <= CAPACITY\") -> unwind unreachable;\n    }\n    bb8: {\n        StorageDead(_21);\n        (*_20) = _14 as u16;\n        StorageDead(_20);\n        StorageLive(_24);\n        _24 = &mut _4;\n        StorageLive(_25);\n        _25 = RangeTo(_6);\n        _23 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::key_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<K>]>(move _24, move _25) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_25);\n        StorageDead(_24);\n        _22 = collections::btree::node::slice_remove::<K>(_23, _5) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_26);\n        StorageLive(_28);\n        _28 = &mut _8;\n        _27 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<usize, core::mem::MaybeUninit<K>>(move _28, _9) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_28);\n        _26 = core::mem::MaybeUninit::<K>::write(_27, _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_26);\n        StorageLive(_31);\n        _31 = &mut _11;\n        StorageLive(_32);\n        _32 = RangeTo(_12);\n        _30 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<K>]>(move _31, move _32) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_34);\n        _34 = &mut _8;\n        StorageLive(_35);\n        StorageLive(_36);\n        _37 = CheckedAdd(_9, 1_usize);\n        assert(!move (_37.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _36 = move (_37.0: usize);\n        _35 = Range(move _36, _14);\n        StorageDead(_36);\n        _33 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<core::ops::Range<usize>, [core::mem::MaybeUninit<K>]>(move _34, move _35) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_35);\n        StorageDead(_34);\n        _29 = collections::btree::node::move_to_slice::<K>(_30, _33) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_40);\n        _40 = &mut _4;\n        StorageLive(_41);\n        _41 = RangeTo(_6);\n        _39 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::val_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<V>]>(move _40, move _41) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_41);\n        StorageDead(_40);\n        _38 = collections::btree::node::slice_remove::<V>(_39, _5) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_42);\n        StorageLive(_44);\n        _44 = &mut _8;\n        _43 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<usize, core::mem::MaybeUninit<V>>(move _44, _9) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_44);\n        _42 = core::mem::MaybeUninit::<V>::write(_43, _38) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_42);\n        StorageLive(_47);\n        _47 = &mut _11;\n        StorageLive(_48);\n        _48 = RangeTo(_12);\n        _46 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<V>]>(move _47, move _48) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageLive(_50);\n        _50 = &mut _8;\n        StorageLive(_51);\n        StorageLive(_52);\n        _53 = CheckedAdd(_9, 1_usize);\n        assert(!move (_53.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _52 = move (_53.0: usize);\n        _51 = Range(move _52, _14);\n        StorageDead(_52);\n        _49 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<core::ops::Range<usize>, [core::mem::MaybeUninit<V>]>(move _50, move _51) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_51);\n        StorageDead(_50);\n        _45 = collections::btree::node::move_to_slice::<V>(_46, _49) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageLive(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &mut _4;\n        StorageLive(_58);\n        StorageLive(_59);\n        _60 = CheckedAdd(_6, 1_usize);\n        assert(!move (_60.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _59 = move (_60.0: usize);\n        _58 = RangeTo(move _59);\n        StorageDead(_59);\n        _56 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::edge_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>]>(move _57, move _58) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_58);\n        StorageDead(_57);\n        _55 = &mut _56;\n        _111 = (*_55);\n        StorageLive(_61);\n        _62 = CheckedAdd(_5, 1_usize);\n        assert(!move (_62.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, 1_usize) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _61 = move (_62.0: usize);\n        _54 = collections::btree::node::slice_remove::<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>(_111, move _61) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_61);\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageLive(_64);\n        _64 = &mut _4;\n        StorageLive(_65);\n        StorageLive(_66);\n        _67 = CheckedAdd(_5, 1_usize);\n        assert(!move (_67.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, 1_usize) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _66 = move (_67.0: usize);\n        _65 = Range(move _66, _6);\n        StorageDead(_66);\n        _63 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links::<core::ops::Range<usize>>(move _64, move _65) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_65);\n        StorageDead(_64);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = &mut _4;\n        _68 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::len_mut(move _69) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_69);\n        _70 = CheckedSub((*_68), 1_u16);\n        assert(!move (_70.1: bool), \"attempt to compute `{} - {}`, which would overflow\", (*_68), 1_u16) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        (*_68) = move (_70.0: u16);\n        StorageDead(_68);\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = (_4.0: usize);\n        _71 = Gt(move _72, 1_usize);\n        switchInt(move _71) -> [0: bb49, otherwise: bb33];\n    }\n    bb33: {\n        StorageDead(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        StorageLive(_75);\n        _75 = &mut _8;\n        _74 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow_mut(move _75) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_75);\n        _73 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_internal_unchecked(move _74) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_74);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = move _11;\n        _76 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_internal_unchecked(move _77) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_77);\n        StorageLive(_80);\n        _80 = &mut _76;\n        StorageLive(_81);\n        StorageLive(_82);\n        _83 = CheckedAdd(_12, 1_usize);\n        assert(!move (_83.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _12, 1_usize) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _82 = move (_83.0: usize);\n        _81 = RangeTo(move _82);\n        StorageDead(_82);\n        _79 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::edge_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>]>(move _80, move _81) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_81);\n        StorageDead(_80);\n        StorageLive(_85);\n        _85 = &mut _73;\n        StorageLive(_86);\n        StorageLive(_87);\n        _88 = CheckedAdd(_9, 1_usize);\n        assert(!move (_88.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _87 = move (_88.0: usize);\n        StorageLive(_89);\n        _90 = CheckedAdd(_14, 1_usize);\n        assert(!move (_90.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, 1_usize) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _89 = move (_90.0: usize);\n        _86 = Range(move _87, move _89);\n        StorageDead(_89);\n        StorageDead(_87);\n        _84 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::edge_area_mut::<core::ops::Range<usize>, [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>]>(move _85, move _86) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_86);\n        StorageDead(_85);\n        _78 = collections::btree::node::move_to_slice::<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>(_79, _84) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageLive(_92);\n        _92 = &mut _73;\n        StorageLive(_93);\n        StorageLive(_94);\n        _95 = CheckedAdd(_9, 1_usize);\n        assert(!move (_95.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _94 = move (_95.0: usize);\n        StorageLive(_96);\n        _97 = CheckedAdd(_14, 1_usize);\n        assert(!move (_97.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, 1_usize) -> [success: bb44, unwind unreachable];\n    }\n    bb44: {\n        _96 = move (_97.0: usize);\n        _93 = Range(move _94, move _96);\n        StorageDead(_96);\n        StorageDead(_94);\n        _91 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links::<core::ops::Range<usize>>(move _92, move _93) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_93);\n        StorageDead(_92);\n        StorageLive(_99);\n        _99 = &_3;\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = (_76.1: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>);\n        _100 = core::ptr::NonNull::<collections::btree::node::LeafNode<K, V>>::cast::<u8>(move _101) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_101);\n        StorageLive(_102);\n        _102 = core::alloc::Layout::new::<collections::btree::node::InternalNode<K, V>>() -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _98 = <A as core::alloc::Allocator>::deallocate(move _99, move _100, move _102) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_102);\n        StorageDead(_100);\n        StorageDead(_99);\n        StorageDead(_76);\n        StorageDead(_73);\n        goto -> bb53;\n    }\n    bb49: {\n        StorageDead(_72);\n        StorageLive(_104);\n        _104 = &_3;\n        StorageLive(_105);\n        StorageLive(_106);\n        _106 = (_11.1: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>);\n        _105 = core::ptr::NonNull::<collections::btree::node::LeafNode<K, V>>::cast::<u8>(move _106) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_106);\n        StorageLive(_107);\n        _107 = core::alloc::Layout::new::<collections::btree::node::LeafNode<K, V>>() -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        _103 = <A as core::alloc::Allocator>::deallocate(move _104, move _105, move _107) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_107);\n        StorageDead(_105);\n        StorageDead(_104);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_71);\n        StorageLive(_108);\n        StorageLive(_109);\n        _109 = move _4;\n        StorageLive(_110);\n        _110 = move _8;\n        _108 = (move _109, move _110);\n        _0 = <F as core::ops::FnOnce<(collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>)>>::call_once(_2, move _108) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_110);\n        StorageDead(_109);\n        StorageDead(_108);\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageDead(_4);\n        drop(_3) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        return;\n    }\n}\n",
  "doc": " Performs a merge and lets a closure decide what to return.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}