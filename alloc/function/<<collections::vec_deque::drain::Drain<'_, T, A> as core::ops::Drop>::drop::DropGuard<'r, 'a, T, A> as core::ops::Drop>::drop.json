{
  "name": "<<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'r, 'a, T, A> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "core::mem::needs_drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if dropping values of type `T` matters.\n\n This is purely an optimization hint, and may be implemented conservatively:\n it may return `true` for types that don't actually need to be dropped.\n As such always returning `true` would be a valid implementation of\n this function. However if this function actually returns `false`, then you\n can be certain dropping `T` has no side effect.\n\n Low level implementations of things like collections, which need to manually\n drop their data, should use this function to avoid unnecessarily\n trying to drop all their contents when they are destroyed. This might not\n make a difference in release builds (where a loop that has no side-effects\n is easily detected and eliminated), but is often a big win for debug builds.\n\n Note that [`drop_in_place`] already performs this check, so if your workload\n can be reduced to some small number of [`drop_in_place`] calls, using this is\n unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n will do a single needs_drop check for all the values.\n\n Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n values one at a time and should use this API.\n\n [`drop_in_place`]: crate::ptr::drop_in_place\n [`HashMap`]: ../../std/collections/struct.HashMap.html\n\n # Examples\n\n Here's an example of how a collection might make use of `needs_drop`:\n\n ```\n use std::{mem, ptr};\n\n pub struct MyCollection<T> {\n #   data: [T; 1],\n     /* ... */\n }\n # impl<T> MyCollection<T> {\n #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n #   fn free_buffer(&mut self) {}\n # }\n\n impl<T> Drop for MyCollection<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // drop the data\n             if mem::needs_drop::<T>() {\n                 for x in self.iter_mut() {\n                     ptr::drop_in_place(x);\n                 }\n             }\n             self.free_buffer();\n         }\n     }\n }\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::drain::Drain::<'a, T, A>::as_slices": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::drain::Drain": "ImmutableAsArgument"
      }
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n must be used instead.\n\n For the shared counterpart see [`as_ref`].\n\n [`as_uninit_mut`]: NonNull::as_uninit_mut\n [`as_ref`]: NonNull::as_ref\n\n # Safety\n\n When calling this method, you have to ensure that\n the pointer is [convertible to a reference](crate::ptr#pointer-to-reference-conversion).\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let mut ptr = NonNull::new(&mut x).expect(\"null pointer\");\n\n let x_ref = unsafe { ptr.as_mut() };\n assert_eq!(*x_ref, 0);\n *x_ref += 2;\n assert_eq!(*x_ref, 2);\n ```\n\n [the module documentation]: crate::ptr#safety\n",
      "adt": {}
    },
    "<<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'r, 'a, T, A> as core::ops::Drop>::drop::join_head_and_tail_wrapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::to_physical_idx": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::vec_deque::drain::Drain": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::ptr::NonNull": [
      "MutRef"
    ],
    "collections::vec_deque::VecDeque": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref",
      "Deref"
    ]
  },
  "path": 1318,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/drain.rs:115:13: 230:14",
  "src": "fn drop(&mut self) {\n                if mem::needs_drop::<T>() && self.0.remaining != 0 {\n                    unsafe {\n                        // SAFETY: We just checked that `self.remaining != 0`.\n                        let (front, back) = self.0.as_slices();\n                        ptr::drop_in_place(front);\n                        ptr::drop_in_place(back);\n                    }\n                }\n\n                let source_deque = unsafe { self.0.deque.as_mut() };\n\n                let drain_len = self.0.drain_len;\n                let new_len = self.0.new_len;\n\n                if T::IS_ZST {\n                    // no need to copy around any memory if T is a ZST\n                    source_deque.len = new_len;\n                    return;\n                }\n\n                let head_len = source_deque.len; // #elements in front of the drain\n                let tail_len = new_len - head_len; // #elements behind the drain\n\n                // Next, we will fill the hole left by the drain with as few writes as possible.\n                // The code below handles the following control flow and reduces the amount of\n                // branches under the assumption that `head_len == 0 || tail_len == 0`, i.e.\n                // draining at the front or at the back of the dequeue is especially common.\n                //\n                // H = \"head index\" = `deque.head`\n                // h = elements in front of the drain\n                // d = elements in the drain\n                // t = elements behind the drain\n                //\n                // Note that the buffer may wrap at any point and the wrapping is handled by\n                // `wrap_copy` and `to_physical_idx`.\n                //\n                // Case 1: if `head_len == 0 && tail_len == 0`\n                // Everything was drained, reset the head index back to 0.\n                //             H\n                // [ . . . . . d d d d . . . . . ]\n                //   H\n                // [ . . . . . . . . . . . . . . ]\n                //\n                // Case 2: else if `tail_len == 0`\n                // Don't move data or the head index.\n                //         H\n                // [ . . . h h h h d d d d . . . ]\n                //         H\n                // [ . . . h h h h . . . . . . . ]\n                //\n                // Case 3: else if `head_len == 0`\n                // Don't move data, but move the head index.\n                //         H\n                // [ . . . d d d d t t t t . . . ]\n                //                 H\n                // [ . . . . . . . t t t t . . . ]\n                //\n                // Case 4: else if `tail_len <= head_len`\n                // Move data, but not the head index.\n                //       H\n                // [ . . h h h h d d d d t t . . ]\n                //       H\n                // [ . . h h h h t t . . . . . . ]\n                //\n                // Case 5: else\n                // Move data and the head index.\n                //       H\n                // [ . . h h d d d d t t t t . . ]\n                //               H\n                // [ . . . . . . h h t t t t . . ]\n\n                // When draining at the front (`.drain(..n)`) or at the back (`.drain(n..)`),\n                // we don't need to copy any data. The number of elements copied would be 0.\n                if head_len != 0 && tail_len != 0 {\n                    join_head_and_tail_wrapping(source_deque, drain_len, head_len, tail_len);\n                    // Marking this function as cold helps LLVM to eliminate it entirely if\n                    // this branch is never taken.\n                    // We use `#[cold]` instead of `#[inline(never)]`, because inlining this\n                    // function into the general case (`.drain(n..m)`) is fine.\n                    // See `tests/codegen-llvm/vecdeque-drain.rs` for a test.\n                    #[cold]\n                    fn join_head_and_tail_wrapping<T, A: Allocator>(\n                        source_deque: &mut VecDeque<T, A>,\n                        drain_len: usize,\n                        head_len: usize,\n                        tail_len: usize,\n                    ) {\n                        // Pick whether to move the head or the tail here.\n                        let (src, dst, len);\n                        if head_len < tail_len {\n                            src = source_deque.head;\n                            dst = source_deque.to_physical_idx(drain_len);\n                            len = head_len;\n                        } else {\n                            src = source_deque.to_physical_idx(head_len + drain_len);\n                            dst = source_deque.to_physical_idx(head_len);\n                            len = tail_len;\n                        };\n\n                        unsafe {\n                            source_deque.wrap_copy(src, dst, len);\n                        }\n                    }\n                }\n\n                if new_len == 0 {\n                    // Special case: If the entire dequeue was drained, reset the head back to 0,\n                    // like `.clear()` does.\n                    source_deque.head = 0;\n                } else if head_len < tail_len {\n                    // If we moved the head above, then we need to adjust the head index here.\n                    source_deque.head = source_deque.to_physical_idx(drain_len);\n                }\n                source_deque.len = new_len;\n            }",
  "mir": "fn <<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'r, 'a, T, A> as core::ops::Drop>::drop(_1: &mut <collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'_, '_, T, A>) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: usize;\n    let  _4: *mut [T];\n    let  _5: *mut [T];\n    let mut _6: (*mut [T], *mut [T]);\n    let mut _7: &collections::vec_deque::drain::Drain<'_, T, A>;\n    let  _8: ();\n    let  _9: ();\n    let mut _10: &mut collections::vec_deque::VecDeque<T, A>;\n    let mut _11: &mut core::ptr::NonNull<collections::vec_deque::VecDeque<T, A>>;\n    let  _12: usize;\n    let  _13: usize;\n    let  _14: usize;\n    let  _15: usize;\n    let mut _16: (usize, bool);\n    let  _17: ();\n    let mut _18: bool;\n    let mut _19: usize;\n    let mut _20: &collections::vec_deque::VecDeque<T, A>;\n    let mut _21: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _22: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _23: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _24: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _25: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    debug self => _1;\n    debug front => _4;\n    debug back => _5;\n    debug source_deque => _10;\n    debug drain_len => _12;\n    debug new_len => _13;\n    debug head_len => _14;\n    debug tail_len => _15;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::needs_drop::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb8, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_3);\n        _21 = ((*_1).0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _3 = ((*_21).4: usize);\n        switchInt(move _3) -> [0: bb7, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _22 = ((*_1).0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _7 = &(*_22);\n        _6 = collections::vec_deque::drain::Drain::<'_, T, A>::as_slices(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _4 = (_6.0: *mut [T]);\n        _5 = (_6.1: *mut [T]);\n        StorageDead(_6);\n        _8 = core::ptr::drop_in_place::<[T]>(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = core::ptr::drop_in_place::<[T]>(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb8;\n    }\n    bb7: {\n        StorageDead(_3);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_2);\n        StorageLive(_11);\n        _23 = ((*_1).0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _11 = &mut ((*_23).0: core::ptr::NonNull<collections::vec_deque::VecDeque<T, A>>);\n        _10 = core::ptr::NonNull::<collections::vec_deque::VecDeque<T, A>>::as_mut::<'_>(move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        _24 = ((*_1).0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _12 = ((*_24).1: usize);\n        _25 = ((*_1).0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _13 = ((*_25).3: usize);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        ((*_10).1: usize) = _13;\n        goto -> bb26;\n    }\n    bb11: {\n        _14 = ((*_10).1: usize);\n        _16 = CheckedSub(_13, _14);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _13, _14) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _15 = move (_16.0: usize);\n        switchInt(_14) -> [0: bb17, otherwise: bb13];\n    }\n    bb13: {\n        switchInt(_15) -> [0: bb16, otherwise: bb14];\n    }\n    bb14: {\n        _17 = <<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'r, 'a, T, A> as core::ops::Drop>::drop::join_head_and_tail_wrapping::<T, A>(_10, _12, _14, _15) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        goto -> bb18;\n    }\n    bb16: {\n        goto -> bb18;\n    }\n    bb17: {\n        goto -> bb18;\n    }\n    bb18: {\n        switchInt(_13) -> [0: bb19, otherwise: bb20];\n    }\n    bb19: {\n        ((*_10).0: usize) = 0_usize;\n        goto -> bb25;\n    }\n    bb20: {\n        StorageLive(_18);\n        _18 = Lt(_14, _15);\n        switchInt(move _18) -> [0: bb23, otherwise: bb21];\n    }\n    bb21: {\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &(*_10);\n        _19 = collections::vec_deque::VecDeque::<T, A>::to_physical_idx(move _20, _12) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_20);\n        ((*_10).0: usize) = move _19;\n        StorageDead(_19);\n        goto -> bb24;\n    }\n    bb23: {\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_18);\n        goto -> bb25;\n    }\n    bb25: {\n        ((*_10).1: usize) = _13;\n        goto -> bb26;\n    }\n    bb26: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}