{
  "name": "<vec::Vec<T, A> as vec::ExtendFromWithinSpec>::spec_extend_from_within",
  "safe": false,
  "callees": {
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::split_at_spare_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns vector content as a slice of `T`, along with the remaining spare\n capacity of the vector as a slice of `MaybeUninit<T>`.\n\n The returned spare capacity slice can be used to fill the vector with data\n (e.g. by reading from a file) before marking the data as initialized using\n the [`set_len`] method.\n\n [`set_len`]: Vec::set_len\n\n Note that this is a low-level API, which should be used with care for\n optimization purposes. If you need to append data to a `Vec`\n you can use [`push`], [`extend`], [`extend_from_slice`],\n [`extend_from_within`], [`insert`], [`append`], [`resize`] or\n [`resize_with`], depending on your exact needs.\n\n [`push`]: Vec::push\n [`extend`]: Vec::extend\n [`extend_from_slice`]: Vec::extend_from_slice\n [`extend_from_within`]: Vec::extend_from_within\n [`insert`]: Vec::insert\n [`append`]: Vec::append\n [`resize`]: Vec::resize\n [`resize_with`]: Vec::resize_with\n\n # Examples\n\n ```\n #![feature(vec_split_at_spare)]\n\n let mut v = vec![1, 1, 2];\n\n // Reserve additional space big enough for 10 elements.\n v.reserve(10);\n\n let (init, uninit) = v.split_at_spare_mut();\n let sum = init.iter().copied().sum::<u32>();\n\n // Fill in the next 4 elements.\n uninit[0].write(sum);\n uninit[1].write(sum * 2);\n uninit[2].write(sum * 3);\n uninit[3].write(sum * 4);\n\n // Mark the 4 elements of the vector as being initialized.\n unsafe {\n     let len = v.len();\n     v.set_len(len + 4);\n }\n\n assert_eq!(&v, &[1, 1, 2, 4, 8, 12, 16]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice, without doing bounds\n checking.\n\n For a safe alternative see [`get`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get(index).unwrap_unchecked()`.  It's UB\n to call `.get_unchecked(len)`, even if you immediately convert to a\n pointer.  And it's UB to call `.get_unchecked(..len + 1)`,\n `.get_unchecked(..=len)`, or similar.\n\n [`get`]: slice::get\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n\n unsafe {\n     assert_eq!(x.get_unchecked(1), &2);\n }\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ops::Range": [
      "Ref",
      "Plain"
    ],
    "vec::Vec": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<vec::Vec<T, A> as vec::ExtendFromWithinSpec>::spec_extend_from_within"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3551:5: 3575:6",
  "src": "unsafe fn spec_extend_from_within(&mut self, src: Range<usize>) {\n        let count = src.len();\n        {\n            let (init, spare) = self.split_at_spare_mut();\n\n            // SAFETY:\n            // - caller guarantees that `src` is a valid index\n            let source = unsafe { init.get_unchecked(src) };\n\n            // SAFETY:\n            // - Both pointers are created from unique slice references (`&mut [_]`)\n            //   so they are valid and do not overlap.\n            // - Elements implement `TrivialClone` so this is equivalent to calling\n            //   `clone` on every one of them.\n            // - `count` is equal to the len of `source`, so source is valid for\n            //   `count` reads\n            // - `.reserve(count)` guarantees that `spare.len() >= count` so spare\n            //   is valid for `count` writes\n            unsafe { ptr::copy_nonoverlapping(source.as_ptr(), spare.as_mut_ptr() as _, count) };\n        }\n\n        // SAFETY:\n        // - The elements were just initialized by `copy_nonoverlapping`\n        self.len += count;\n    }",
  "mir": "fn <vec::Vec<T, A> as vec::ExtendFromWithinSpec>::spec_extend_from_within(_1: &mut vec::Vec<T, A>, _2: core::ops::Range<usize>) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &core::ops::Range<usize>;\n    let  _5: &mut [T];\n    let  _6: &mut [core::mem::MaybeUninit<T>];\n    let mut _7: (&mut [T], &mut [core::mem::MaybeUninit<T>]);\n    let  _8: &[T];\n    let mut _9: &[T];\n    let  _10: ();\n    let mut _11: *const T;\n    let mut _12: *mut T;\n    let mut _13: *mut core::mem::MaybeUninit<T>;\n    let mut _14: (usize, bool);\n    debug self => _1;\n    debug src => _2;\n    debug count => _3;\n    debug init => _5;\n    debug spare => _6;\n    debug source => _8;\n    bb0: {\n        StorageLive(_4);\n        _4 = &_2;\n        _3 = <core::ops::Range<usize> as core::iter::ExactSizeIterator>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = vec::Vec::<T, A>::split_at_spare_mut(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = move (_7.0: &mut [T]);\n        _6 = move (_7.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = &(*_5);\n        _8 = core::slice::<impl [T]>::get_unchecked::<core::ops::Range<usize>>(move _9, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = core::slice::<impl [T]>::as_ptr(_8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_13);\n        _13 = core::slice::<impl [core::mem::MaybeUninit<T>]>::as_mut_ptr(_6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = move _13 as *mut T;\n        StorageDead(_13);\n        _10 = core::ptr::copy_nonoverlapping::<T>(move _11, _12, _3) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageDead(_5);\n        _14 = CheckedAdd(((*_1).1: usize), _3);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).1: usize), _3) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        ((*_1).1: usize) = move (_14.0: usize);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}