{
  "name": "collections::vec_deque::VecDeque::<T, A>::split_off",
  "safe": true,
  "callees": {
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::allocator": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the underlying allocator.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::with_capacity_in": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an empty deque with space for at least `capacity` elements.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let deque: VecDeque<u32> = VecDeque::with_capacity(10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "Constructor"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marginally more convenient\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "Deref",
      "Plain",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "MutRef"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 1525,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:2472:5: 2517:6",
  "src": "pub fn split_off(&mut self, at: usize) -> Self\n    where\n        A: Clone,\n    {\n        let len = self.len;\n        assert!(at <= len, \"`at` out of bounds\");\n\n        let other_len = len - at;\n        let mut other = VecDeque::with_capacity_in(other_len, self.allocator().clone());\n\n        let (first_half, second_half) = self.as_slices();\n        let first_len = first_half.len();\n        let second_len = second_half.len();\n\n        unsafe {\n            if at < first_len {\n                // `at` lies in the first half.\n                let amount_in_first = first_len - at;\n\n                ptr::copy_nonoverlapping(first_half.as_ptr().add(at), other.ptr(), amount_in_first);\n\n                // just take all of the second half.\n                ptr::copy_nonoverlapping(\n                    second_half.as_ptr(),\n                    other.ptr().add(amount_in_first),\n                    second_len,\n                );\n            } else {\n                // `at` lies in the second half, need to factor in the elements we skipped\n                // in the first half.\n                let offset = at - first_len;\n                let amount_in_second = second_len - offset;\n                ptr::copy_nonoverlapping(\n                    second_half.as_ptr().add(offset),\n                    other.ptr(),\n                    amount_in_second,\n                );\n            }\n        }\n\n        // Cleanup where the ends of the buffers are\n        self.len = at;\n        other.len = other_len;\n\n        other\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::split_off(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize) -> collections::vec_deque::VecDeque<T, A> {\n    let mut _0: collections::vec_deque::VecDeque<T, A>;\n    let  _3: usize;\n    let mut _4: bool;\n    let  _5: !;\n    let mut _6: core::fmt::Arguments<'_>;\n    let  _7: usize;\n    let mut _8: (usize, bool);\n    let mut _9: collections::vec_deque::VecDeque<T, A>;\n    let mut _10: A;\n    let  _11: &A;\n    let mut _12: &collections::vec_deque::VecDeque<T, A>;\n    let  _13: &[T];\n    let  _14: &[T];\n    let mut _15: (&[T], &[T]);\n    let mut _16: &collections::vec_deque::VecDeque<T, A>;\n    let  _17: usize;\n    let  _18: usize;\n    let mut _19: bool;\n    let  _20: usize;\n    let mut _21: (usize, bool);\n    let  _22: ();\n    let mut _23: *const T;\n    let mut _24: *const T;\n    let mut _25: *mut T;\n    let mut _26: &collections::vec_deque::VecDeque<T, A>;\n    let  _27: ();\n    let mut _28: *const T;\n    let mut _29: *mut T;\n    let mut _30: *mut T;\n    let mut _31: &collections::vec_deque::VecDeque<T, A>;\n    let  _32: usize;\n    let mut _33: (usize, bool);\n    let  _34: usize;\n    let mut _35: (usize, bool);\n    let  _36: ();\n    let mut _37: *const T;\n    let mut _38: *const T;\n    let mut _39: *mut T;\n    let mut _40: &collections::vec_deque::VecDeque<T, A>;\n    debug self => _1;\n    debug at => _2;\n    debug len => _3;\n    debug other_len => _7;\n    debug other => _9;\n    debug first_half => _13;\n    debug second_half => _14;\n    debug first_len => _17;\n    debug second_len => _18;\n    debug amount_in_first => _20;\n    debug offset => _32;\n    debug amount_in_second => _34;\n    bb0: {\n        _3 = ((*_1).1: usize);\n        StorageLive(_4);\n        _4 = Le(_2, _3);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        _8 = CheckedSub(_3, _2);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _2) -> [success: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = core::fmt::Arguments::<'_>::from_str(\"`at` out of bounds\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = core::panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n    bb4: {\n        _7 = move (_8.0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = collections::vec_deque::VecDeque::<T, A>::allocator(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _10 = <A as core::clone::Clone>::clone(_11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = collections::vec_deque::VecDeque::<T, A>::with_capacity_in(_7, move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &(*_1);\n        _15 = collections::vec_deque::VecDeque::<T, A>::as_slices(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _13 = (_15.0: &[T]);\n        _14 = (_15.1: &[T]);\n        StorageDead(_15);\n        _17 = PtrMetadata(_13);\n        _18 = PtrMetadata(_14);\n        StorageLive(_19);\n        _19 = Lt(_2, _17);\n        switchInt(move _19) -> [0: bb19, otherwise: bb9];\n    }\n    bb9: {\n        _21 = CheckedSub(_17, _2);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _17, _2) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _20 = move (_21.0: usize);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = core::slice::<impl [T]>::as_ptr(_13) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _23 = core::ptr::const_ptr::<impl *const T>::add(move _24, _2) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_9;\n        _25 = collections::vec_deque::VecDeque::<T, A>::ptr(move _26) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_26);\n        _22 = core::ptr::copy_nonoverlapping::<T>(move _23, move _25, _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageLive(_28);\n        _28 = core::slice::<impl [T]>::as_ptr(_14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &_9;\n        _30 = collections::vec_deque::VecDeque::<T, A>::ptr(move _31) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_31);\n        _29 = core::ptr::mut_ptr::<impl *mut T>::add(move _30, _20) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_30);\n        _27 = core::ptr::copy_nonoverlapping::<T>(move _28, move _29, _18) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        StorageDead(_28);\n        goto -> bb26;\n    }\n    bb19: {\n        _33 = CheckedSub(_2, _17);\n        assert(!move (_33.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, _17) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _32 = move (_33.0: usize);\n        _35 = CheckedSub(_18, _32);\n        assert(!move (_35.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _18, _32) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _34 = move (_35.0: usize);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = core::slice::<impl [T]>::as_ptr(_14) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _37 = core::ptr::const_ptr::<impl *const T>::add(move _38, _32) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_9;\n        _39 = collections::vec_deque::VecDeque::<T, A>::ptr(move _40) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_40);\n        _36 = core::ptr::copy_nonoverlapping::<T>(move _37, move _39, _34) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_39);\n        StorageDead(_37);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_19);\n        ((*_1).1: usize) = _2;\n        (_9.1: usize) = _7;\n        _0 = move _9;\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": " Splits the deque into two at the given index.\n\n Returns a newly allocated `VecDeque`. `self` contains elements `[0, at)`,\n and the returned deque contains elements `[at, len)`.\n\n Note that the capacity of `self` does not change.\n\n Element at index 0 is the front of the queue.\n\n # Panics\n\n Panics if `at > len`.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf: VecDeque<_> = ['a', 'b', 'c'].into();\n let buf2 = buf.split_off(1);\n assert_eq!(buf, ['a']);\n assert_eq!(buf2, ['b', 'c']);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}