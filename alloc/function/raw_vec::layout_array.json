{
  "name": "raw_vec::layout_array",
  "safe": true,
  "callees": {
    "core::alloc::Layout::repeat": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout describing the record for `n` instances of\n `self`, with a suitable amount of padding between each to\n ensure that each instance is given its requested size and\n alignment. On success, returns `(k, offs)` where `k` is the\n layout of the array and `offs` is the distance between the start\n of each element in the array.\n\n (That distance between elements is sometimes known as \"stride\".)\n\n On arithmetic overflow, returns `LayoutError`.\n\n # Examples\n\n ```\n #![feature(alloc_layout_extra)]\n use std::alloc::Layout;\n\n // All rust types have a size that's a multiple of their alignment.\n let normal = Layout::from_size_align(12, 4).unwrap();\n let repeated = normal.repeat(3).unwrap();\n assert_eq!(repeated, (Layout::from_size_align(36, 4).unwrap(), 12));\n\n // But you can manually make layouts which don't meet that rule.\n let padding_needed = Layout::from_size_align(6, 4).unwrap();\n let repeated = padding_needed.repeat(3).unwrap();\n assert_eq!(repeated, (Layout::from_size_align(24, 4).unwrap(), 8));\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Ref",
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1632,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:852:1: 854:2",
  "src": "fn layout_array(cap: usize, elem_layout: Layout) -> Result<Layout, TryReserveError> {\n    elem_layout.repeat(cap).map(|(layout, _pad)| layout).map_err(|_| CapacityOverflow.into())\n}",
  "mir": "fn raw_vec::layout_array(_1: usize, _2: core::alloc::Layout) -> core::result::Result<core::alloc::Layout, collections::TryReserveError> {\n    let mut _0: core::result::Result<core::alloc::Layout, collections::TryReserveError>;\n    let mut _3: core::result::Result<core::alloc::Layout, core::alloc::LayoutError>;\n    let mut _4: core::result::Result<(core::alloc::Layout, usize), core::alloc::LayoutError>;\n    let mut _5: &core::alloc::Layout;\n    debug cap => _1;\n    debug elem_layout => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_2;\n        _4 = core::alloc::Layout::repeat(move _5, _1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = core::result::Result::<(core::alloc::Layout, usize), core::alloc::LayoutError>::map::<core::alloc::Layout, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:853:33: 853:49}>(move _4, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:853:33: 853:49}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _0 = core::result::Result::<core::alloc::Layout, core::alloc::LayoutError>::map_err::<collections::TryReserveError, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:853:66: 853:69}>(move _3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:853:66: 853:69}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}