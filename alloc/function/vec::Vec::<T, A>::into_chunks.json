{
  "name": "vec::Vec::<T, A>::into_chunks",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::truncate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shortens the vector, keeping the first `len` elements and dropping\n the rest.\n\n If `len` is greater or equal to the vector's current length, this has\n no effect.\n\n The [`drain`] method can emulate `truncate`, but causes the excess\n elements to be returned instead of dropped.\n\n Note that this method has no effect on the allocated capacity\n of the vector.\n\n # Examples\n\n Truncating a five element vector to two elements:\n\n ```\n let mut vec = vec![1, 2, 3, 4, 5];\n vec.truncate(2);\n assert_eq!(vec, [1, 2]);\n ```\n\n No truncation occurs when `len` is greater than the vector's current\n length:\n\n ```\n let mut vec = vec![1, 2, 3];\n vec.truncate(8);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n Truncating when `len == 0` is equivalent to calling the [`clear`]\n method.\n\n ```\n let mut vec = vec![1, 2, 3];\n vec.truncate(0);\n assert_eq!(vec, []);\n ```\n\n [`clear`]: Vec::clear\n [`drain`]: Vec::drain\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "raw_vec::RawVec::<T, A>::shrink_to_fit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shrinks the buffer down to the specified capacity. If the given amount\n is 0, actually completely deallocates.\n\n # Panics\n\n Panics if the given amount is *larger* than the current capacity.\n\n # Aborts\n\n Aborts on OOM.\n",
      "adt": {
        "raw_vec::RawVec": "MutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::into_raw_parts_with_alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Decomposes a `Vec<T>` into its raw components: `(pointer, length, capacity, allocator)`.\n\n Returns the raw pointer to the underlying data, the length of the vector (in elements),\n the allocated capacity of the data (in elements), and the allocator. These are the same\n arguments in the same order as the arguments to [`from_raw_parts_in`].\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Vec`. The only way to do\n this is to convert the raw pointer, length, and capacity back\n into a `Vec` with the [`from_raw_parts_in`] function, allowing\n the destructor to perform the cleanup.\n\n [`from_raw_parts_in`]: Vec::from_raw_parts_in\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let mut v: Vec<i32, System> = Vec::new_in(System);\n v.push(-1);\n v.push(0);\n v.push(1);\n\n let (ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();\n\n let rebuilt = unsafe {\n     // We can now make changes to the components, such as\n     // transmuting the raw pointer to a compatible type.\n     let ptr = ptr as *mut u32;\n\n     Vec::from_raw_parts_in(ptr, len, cap, alloc)\n };\n assert_eq!(rebuilt, [4294967295, 0, 1]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::from_raw_parts_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `Vec<T, A>` directly from a pointer, a length, a capacity,\n and an allocator.\n\n # Safety\n\n This is highly unsafe, due to the number of invariants that aren't\n checked:\n\n * `ptr` must be [*currently allocated*] via the given allocator `alloc`.\n * `T` needs to have the same alignment as what `ptr` was allocated with.\n   (`T` having a less strict alignment is not sufficient, the alignment really\n   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n   allocated and deallocated with the same layout.)\n * The size of `T` times the `capacity` (ie. the allocated size in bytes) needs\n   to be the same size as the pointer was allocated with. (Because similar to\n   alignment, [`dealloc`] must be called with the same layout `size`.)\n * `length` needs to be less than or equal to `capacity`.\n * The first `length` values must be properly initialized values of type `T`.\n * `capacity` needs to [*fit*] the layout size that the pointer was allocated with.\n * The allocated size in bytes must be no larger than `isize::MAX`.\n   See the safety documentation of [`pointer::offset`].\n\n These requirements are always upheld by any `ptr` that has been allocated\n via `Vec<T, A>`. Other allocation sources are allowed if the invariants are\n upheld.\n\n Violating these may cause problems like corrupting the allocator's\n internal data structures. For example it is **not** safe\n to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n It's also not safe to build one from a `Vec<u16>` and its length, because\n the allocator cares about the alignment, and these two types have different\n alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n\n The ownership of `ptr` is effectively transferred to the\n `Vec<T>` which may then deallocate, reallocate or change the\n contents of memory pointed to by the pointer at will. Ensure\n that nothing else uses the pointer after calling this\n function.\n\n [`String`]: crate::string::String\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [*currently allocated*]: crate::alloc::Allocator#currently-allocated-memory\n [*fit*]: crate::alloc::Allocator#memory-fitting\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n use std::ptr;\n\n let mut v = Vec::with_capacity_in(3, System);\n v.push(1);\n v.push(2);\n v.push(3);\n\n // Deconstruct the vector into parts.\n let (p, len, cap, alloc) = v.into_raw_parts_with_alloc();\n\n unsafe {\n     // Overwrite memory with 4, 5, 6\n     for i in 0..len {\n         ptr::write(p.add(i), 4 + i);\n     }\n\n     // Put everything back together into a Vec\n     let rebuilt = Vec::from_raw_parts_in(p, len, cap, alloc.clone());\n     assert_eq!(rebuilt, [4, 5, 6]);\n }\n ```\n\n Using memory that was allocated elsewhere:\n\n ```rust\n #![feature(allocator_api)]\n\n use std::alloc::{AllocError, Allocator, Global, Layout};\n\n fn main() {\n     let layout = Layout::array::<u32>(16).expect(\"overflow cannot happen\");\n\n     let vec = unsafe {\n         let mem = match Global.allocate(layout) {\n             Ok(mem) => mem.cast::<u32>().as_ptr(),\n             Err(AllocError) => return,\n         };\n\n         mem.write(1_000_000);\n\n         Vec::from_raw_parts_in(mem, 1, 16, Global)\n     };\n\n     assert_eq!(vec, &[1_000_000]);\n     assert_eq!(vec.capacity(), 16);\n }\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Ref",
      "Plain",
      "MutRef",
      "Unknown([Field(0, Ty { id: 22, kind: RigidTy(Adt(AdtDef(DefId { id: 2584, name: \"raw_vec::RawVec\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }), Type(Ty { id: 21, kind: Param(ParamTy { index: 1, name: \"A\" }) })]))) })])"
    ],
    "raw_vec::RawVec": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::vec::Vec::<T, A>::into_chunks"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3178:5: 3205:6",
  "src": "pub fn into_chunks<const N: usize>(mut self) -> Vec<[T; N], A> {\n        const {\n            assert!(N != 0, \"chunk size must be greater than zero\");\n        }\n\n        let (len, cap) = (self.len(), self.capacity());\n\n        let len_remainder = len % N;\n        if len_remainder != 0 {\n            self.truncate(len - len_remainder);\n        }\n\n        let cap_remainder = cap % N;\n        if !T::IS_ZST && cap_remainder != 0 {\n            self.buf.shrink_to_fit(cap - cap_remainder);\n        }\n\n        let (ptr, _, _, alloc) = self.into_raw_parts_with_alloc();\n\n        // SAFETY:\n        // - `ptr` and `alloc` were just returned from `self.into_raw_parts_with_alloc()`\n        // - `[T; N]` has the same alignment as `T`\n        // - `size_of::<[T; N]>() * cap / N == size_of::<T>() * cap`\n        // - `len / N <= cap / N` because `len <= cap`\n        // - the allocated memory consists of `len / N` valid values of type `[T; N]`\n        // - `cap / N` fits the size of the allocated memory after shrinking\n        unsafe { Vec::from_raw_parts_in(ptr.cast(), len / N, cap / N, alloc) }\n    }",
  "mir": "fn vec::Vec::<T, A>::into_chunks(_1: vec::Vec<T, A>) -> vec::Vec<[T; N], A> {\n    let mut _0: vec::Vec<[T; N], A>;\n    let  _2: usize;\n    let  _3: usize;\n    let mut _4: (usize, usize);\n    let mut _5: usize;\n    let mut _6: &vec::Vec<T, A>;\n    let mut _7: usize;\n    let mut _8: &vec::Vec<T, A>;\n    let  _9: usize;\n    let mut _10: bool;\n    let  _11: ();\n    let mut _12: &mut vec::Vec<T, A>;\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let  _15: usize;\n    let mut _16: bool;\n    let  _17: ();\n    let mut _18: &mut raw_vec::RawVec<T, A>;\n    let mut _19: usize;\n    let mut _20: (usize, bool);\n    let  _21: *mut T;\n    let  _22: A;\n    let mut _23: (*mut T, usize, usize, A);\n    let mut _24: vec::Vec<T, A>;\n    let mut _25: *mut [T; N];\n    let mut _26: usize;\n    let mut _27: bool;\n    let mut _28: usize;\n    let mut _29: bool;\n    debug self => _1;\n    debug len => _2;\n    debug cap => _3;\n    debug len_remainder => _9;\n    debug cap_remainder => _15;\n    debug ptr => _21;\n    debug alloc => _22;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_1;\n        _5 = vec::Vec::<T, A>::len(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_1;\n        _7 = vec::Vec::<T, A>::capacity(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _4 = (move _5, move _7);\n        StorageDead(_7);\n        StorageDead(_5);\n        _2 = (_4.0: usize);\n        _3 = (_4.1: usize);\n        StorageDead(_4);\n        _10 = Eq(N, 0_usize);\n        assert(!move _10, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _2) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = Rem(_2, N);\n        switchInt(_9) -> [0: bb7, otherwise: bb4];\n    }\n    bb4: {\n        StorageLive(_12);\n        _12 = &mut _1;\n        StorageLive(_13);\n        _14 = CheckedSub(_2, _9);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, _9) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _13 = move (_14.0: usize);\n        _11 = vec::Vec::<T, A>::truncate(move _12, move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb8;\n    }\n    bb7: {\n        goto -> bb8;\n    }\n    bb8: {\n        _16 = Eq(N, 0_usize);\n        assert(!move _16, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _3) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _15 = Rem(_3, N);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb10, otherwise: bb15];\n    }\n    bb10: {\n        switchInt(_15) -> [0: bb14, otherwise: bb11];\n    }\n    bb11: {\n        StorageLive(_18);\n        _18 = &mut (_1.0: raw_vec::RawVec<T, A>);\n        StorageLive(_19);\n        _20 = CheckedSub(_3, _15);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _15) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _19 = move (_20.0: usize);\n        _17 = raw_vec::RawVec::<T, A>::shrink_to_fit(move _18, move _19) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb15;\n    }\n    bb14: {\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = move _1;\n        _23 = vec::Vec::<T, A>::into_raw_parts_with_alloc(move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_24);\n        _21 = (_23.0: *mut T);\n        _22 = move (_23.3: A);\n        StorageDead(_23);\n        StorageLive(_25);\n        _25 = core::ptr::mut_ptr::<impl *mut T>::cast::<[T; N]>(_21) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_26);\n        _27 = Eq(N, 0_usize);\n        assert(!move _27, \"attempt to divide `{}` by zero\", _2) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _26 = Div(_2, N);\n        StorageLive(_28);\n        _29 = Eq(N, 0_usize);\n        assert(!move _29, \"attempt to divide `{}` by zero\", _3) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _28 = Div(_3, N);\n        _0 = vec::Vec::<[T; N], A>::from_raw_parts_in(move _25, move _26, move _28, _22) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_28);\n        StorageDead(_26);\n        StorageDead(_25);\n        return;\n    }\n}\n",
  "doc": " Groups every `N` elements in the `Vec<T>` into chunks to produce a `Vec<[T; N]>`, dropping\n elements in the remainder. `N` must be greater than zero.\n\n If the capacity is not a multiple of the chunk size, the buffer will shrink down to the\n nearest multiple with a reallocation or deallocation.\n\n This function can be used to reverse [`Vec::into_flattened`].\n\n # Examples\n\n ```\n #![feature(vec_into_chunks)]\n\n let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];\n assert_eq!(vec.into_chunks::<3>(), [[0, 1, 2], [3, 4, 5]]);\n\n let vec = vec![0, 1, 2, 3];\n let chunks: Vec<[u8; 10]> = vec.into_chunks();\n assert!(chunks.is_empty());\n\n let flat = vec![0; 8 * 8 * 8];\n let reshaped: Vec<[[[u8; 8]; 8]; 8]> = flat.into_chunks().into_chunks().into_chunks();\n assert_eq!(reshaped.len(), 1);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}