{
  "name": "collections::vec_deque::VecDeque::<T, A>::contains",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice contains an element with the given value.\n\n This operation is *O*(*n*).\n\n Note that if you have a sorted slice, [`binary_search`] may be faster.\n\n [`binary_search`]: slice::binary_search\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert!(v.contains(&30));\n assert!(!v.contains(&50));\n ```\n\n If you do not have a `&T`, but some other value that you can compare\n with one (for example, `String` implements `PartialEq<str>`), you can\n use `iter().any`:\n\n ```\n let v = [String::from(\"hello\"), String::from(\"world\")]; // slice of `String`\n assert!(v.iter().any(|e| e == \"hello\")); // search with `&str`\n assert!(!v.iter().any(|e| e == \"hi\"));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref"
    ]
  },
  "path": 1467,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1884:5: 1890:6",
  "src": "pub fn contains(&self, x: &T) -> bool\n    where\n        T: PartialEq<T>,\n    {\n        let (a, b) = self.as_slices();\n        a.contains(x) || b.contains(x)\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::contains(_1: &collections::vec_deque::VecDeque<T, A>, _2: &T) -> bool {\n    let mut _0: bool;\n    let  _3: &[T];\n    let  _4: &[T];\n    let mut _5: (&[T], &[T]);\n    let mut _6: bool;\n    debug self => _1;\n    debug x => _2;\n    debug a => _3;\n    debug b => _4;\n    bb0: {\n        StorageLive(_5);\n        _5 = collections::vec_deque::VecDeque::<T, A>::as_slices(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = (_5.0: &[T]);\n        _4 = (_5.1: &[T]);\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = core::slice::<impl [T]>::contains(_3, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _0 = true;\n        goto -> bb6;\n    }\n    bb4: {\n        _0 = core::slice::<impl [T]>::contains(_4, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Returns `true` if the deque contains an element equal to the\n given value.\n\n This operation is *O*(*n*).\n\n Note that if you have a sorted `VecDeque`, [`binary_search`] may be faster.\n\n [`binary_search`]: VecDeque::binary_search\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque: VecDeque<u32> = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n\n assert_eq!(deque.contains(&1), true);\n assert_eq!(deque.contains(&10), false);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}