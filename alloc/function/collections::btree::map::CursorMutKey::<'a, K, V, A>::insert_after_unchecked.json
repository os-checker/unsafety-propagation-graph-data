{
  "name": "collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
  "safe": false,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows a new mutable reference from the unique borrow initially captured.\n\n # Safety\n\n The reborrow must have ended, i.e., the reference returned by `new` and\n all pointers and references derived from it, must not be used anymore.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "MutableAsArgument"
      }
    },
    "core::option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::new_leaf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>::push_with_handle": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a key-value pair to the end of the node, and returns\n a handle to the inserted value.\n\n # Safety\n\n The returned handle has an unbound lifetime.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Leaf>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::KV>::left_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a new key-value pair between the key-value pairs to the right and left of\n this edge. This method splits the node if there isn't enough room, and tries to\n insert the split off portion into the parent node recursively, until the root is reached.\n\n If the returned result is some `SplitResult`, the `left` field will be the root node.\n The returned pointer points to the inserted value, which in the case of `SplitResult`\n is in the `left` or `right` tree.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Ref",
      "Deref"
    ],
    "collections::btree::map::CursorMutKey": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 663,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3279:5: 3306:6",
  "src": "pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {\n        let edge = match self.current.take() {\n            None => {\n                // Tree is empty, allocate a new root.\n                // SAFETY: We have no other reference to the tree.\n                let root = unsafe { self.root.reborrow() };\n                debug_assert!(root.is_none());\n                let mut node = NodeRef::new_leaf(self.alloc.clone());\n                // SAFETY: We don't touch the root while the handle is alive.\n                let handle = unsafe { node.borrow_mut().push_with_handle(key, value) };\n                *root = Some(node.forget_type());\n                *self.length += 1;\n                self.current = Some(handle.left_edge());\n                return;\n            }\n            Some(current) => current,\n        };\n\n        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n            drop(ins.left);\n            // SAFETY: The handle to the newly inserted value is always on a\n            // leaf node, so adding a new root node doesn't invalidate it.\n            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n        });\n        self.current = Some(handle.left_edge());\n        *self.length += 1;\n    }",
  "mir": "fn collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked(_1: &mut collections::btree::map::CursorMutKey<'_, K, V, A>, _2: K, _3: V) -> () {\n    let mut _0: ();\n    let mut _4: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _5: &mut core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _6: isize;\n    let mut _7: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _8: &mut collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _9: bool;\n    let mut _10: &core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _11: !;\n    let mut _12: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _13: A;\n    let mut _14: &A;\n    let  _15: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _16: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _17: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _18: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _19: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _20: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _21: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _22: (usize, bool);\n    let mut _23: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _24: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let  _25: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let  _26: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _27: A;\n    let mut _28: &A;\n    let mut _29: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3297:76: 3297:81};\n    let mut _30: &mut collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _31: &A;\n    let mut _32: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _33: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _34: (usize, bool);\n    let mut _35: &mut A;\n    let mut _36: &mut A;\n    let mut _37: &mut usize;\n    let mut _38: &mut usize;\n    let mut _39: &mut usize;\n    let mut _40: &mut A;\n    let mut _41: &mut usize;\n    let mut _42: &mut usize;\n    let mut _43: &mut usize;\n    debug self => _1;\n    debug key => _2;\n    debug value => _3;\n    debug edge => _25;\n    debug root => _7;\n    debug node => _12;\n    debug handle => _15;\n    debug current => _25;\n    debug handle => _26;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>);\n        _4 = core::option::Option::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::take(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _25 = move ((_4 as variant#1).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        StorageDead(_4);\n        StorageLive(_27);\n        StorageLive(_28);\n        _35 = ((*_1).3: &mut A);\n        _28 = &(*_35);\n        _27 = <A as core::clone::Clone>::clone(move _28) -> [return: bb16, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = &mut ((*_1).1: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        _7 = collections::btree::borrow::DormantMutRef::<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>::reborrow(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_7);\n        _9 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::is_none(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _9) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _36 = ((*_1).3: &mut A);\n        _14 = &(*_36);\n        _13 = <A as core::clone::Clone>::clone(move _14) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        _11 = core::panicking::panic(\"assertion failed: root.is_none()\") -> unwind unreachable;\n    }\n    bb9: {\n        StorageDead(_14);\n        _12 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::new_leaf::<A>(move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &mut _12;\n        _17 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::borrow_mut(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _16 = &mut _17;\n        StorageDead(_18);\n        _15 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::push_with_handle::<'_>(move _16, _2, _3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = move _12;\n        _20 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::forget_type(move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        _19 = core::option::Option::Some(move _20);\n        StorageDead(_20);\n        (*_7) = move _19;\n        StorageDead(_19);\n        _37 = ((*_1).2: &mut usize);\n        _22 = CheckedAdd((*_37), 1_usize);\n        _38 = ((*_1).2: &mut usize);\n        assert(!move (_22.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (*_38), 1_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _39 = ((*_1).2: &mut usize);\n        (*_39) = move (_22.0: usize);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::left_edge(_15) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _23 = core::option::Option::Some(move _24);\n        StorageDead(_24);\n        ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _23;\n        StorageDead(_23);\n        StorageDead(_12);\n        StorageDead(_4);\n        goto -> bb20;\n    }\n    bb16: {\n        StorageDead(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &mut ((*_1).1: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        StorageLive(_31);\n        _40 = ((*_1).3: &mut A);\n        _31 = &(*_40);\n        _29 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3297:76: 3297:81}(move _30, move _31);\n        StorageDead(_31);\n        StorageDead(_30);\n        _26 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing::<A, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3297:76: 3297:81}>(_25, _2, _3, move _27, move _29) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::left_edge(_26) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _32 = core::option::Option::Some(move _33);\n        StorageDead(_33);\n        ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _32;\n        StorageDead(_32);\n        _41 = ((*_1).2: &mut usize);\n        _34 = CheckedAdd((*_41), 1_usize);\n        _42 = ((*_1).2: &mut usize);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (*_42), 1_usize) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _43 = ((*_1).2: &mut usize);\n        (*_43) = move (_34.0: usize);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": " Inserts a new key-value pair into the map in the gap that the\n cursor is currently pointing to.\n\n After the insertion the cursor will be pointing at the gap before the\n newly inserted element.\n\n # Safety\n\n You must ensure that the `BTreeMap` invariants are maintained.\n Specifically:\n\n * The key of the newly inserted element must be unique in the tree.\n * All keys in the tree must remain in sorted order.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}