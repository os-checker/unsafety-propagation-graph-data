{
  "name": "<string::String as core::iter::FromIterator<borrow::Cow<'a, str>>>::from_iter",
  "safe": true,
  "callees": {
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "borrow::Cow::<'_, B>::into_owned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the owned data.\n\n Clones the data if it is not already owned.\n\n # Examples\n\n Calling `into_owned` on a `Cow::Borrowed` returns a clone of the borrowed data:\n\n ```\n use std::borrow::Cow;\n\n let s = \"Hello world!\";\n let cow = Cow::Borrowed(s);\n\n assert_eq!(\n   cow.into_owned(),\n   String::from(s)\n );\n ```\n\n Calling `into_owned` on a `Cow::Owned` returns the owned data. The data is moved out of the\n `Cow` without being cloned.\n\n ```\n use std::borrow::Cow;\n\n let s = \"Hello world!\";\n let cow: Cow<'_, str> = Cow::Owned(String::from(s));\n\n assert_eq!(\n   cow.into_owned(),\n   String::from(s)\n );\n ```\n",
      "adt": {}
    },
    "string::String::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String`.\n\n Given that the `String` is empty, this will not allocate any initial\n buffer. While that means that this initial operation is very\n inexpensive, it may cause excessive allocation later when you add\n data. If you have an idea of how much data the `String` will hold,\n consider the [`with_capacity`] method to prevent excessive\n re-allocation.\n\n [`with_capacity`]: String::with_capacity\n\n # Examples\n\n ```\n let s = String::new();\n ```\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "core::iter::Extend::extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends a collection with the contents of an iterator.\n\n As this is the only required method for this trait, the [trait-level] docs\n contain more details.\n\n [trait-level]: Extend\n\n # Examples\n\n ```\n // You can extend a String with some chars:\n let mut message = String::from(\"abc\");\n\n message.extend(['d', 'e', 'f'].iter());\n\n assert_eq!(\"abcdef\", &message);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 541, kind: RigidTy(Adt(AdtDef(DefId { id: 2741, name: \"borrow::Cow\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 5, kind: RigidTy(Str) })]))) })])"
    ],
    "borrow::Cow": [
      "Plain"
    ],
    "string::String": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 1943,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2423:5: 2437:6",
  "src": "fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>(iter: I) -> String {\n        let mut iterator = iter.into_iter();\n\n        // Because we're iterating over CoWs, we can (potentially) avoid at least\n        // one allocation by getting the first item and appending to it all the\n        // subsequent items.\n        match iterator.next() {\n            None => String::new(),\n            Some(cow) => {\n                let mut buf = cow.into_owned();\n                buf.extend(iterator);\n                buf\n            }\n        }\n    }",
  "mir": "fn <string::String as core::iter::FromIterator<borrow::Cow<'a, str>>>::from_iter(_1: I) -> string::String {\n    let mut _0: string::String;\n    let mut _2: <I as core::iter::IntoIterator>::IntoIter;\n    let mut _3: core::option::Option<borrow::Cow<'_, str>>;\n    let mut _4: &mut <I as core::iter::IntoIterator>::IntoIter;\n    let mut _5: isize;\n    let  _6: borrow::Cow<'_, str>;\n    let mut _7: string::String;\n    let  _8: ();\n    let mut _9: &mut string::String;\n    let mut _10: <I as core::iter::IntoIterator>::IntoIter;\n    let mut _11: bool;\n    debug iter => _1;\n    debug iterator => _2;\n    debug cow => _6;\n    debug buf => _7;\n    bb0: {\n        _11 = false;\n        StorageLive(_2);\n        _2 = <I as core::iter::IntoIterator>::into_iter(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _11 = true;\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut _2;\n        _3 = <<I as core::iter::IntoIterator>::IntoIter as core::iter::Iterator>::next(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _6 = move ((_3 as variant#1).0: borrow::Cow<'_, str>);\n        StorageLive(_7);\n        _7 = borrow::Cow::<'_, str>::into_owned(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        _0 = string::String::new() -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_9);\n        _9 = &mut _7;\n        StorageLive(_10);\n        _11 = false;\n        _10 = move _2;\n        _8 = <string::String as core::iter::Extend<borrow::Cow<'_, str>>>::extend::<<I as core::iter::IntoIterator>::IntoIter>(move _9, move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageDead(_9);\n        _0 = move _7;\n        StorageDead(_7);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_3);\n        switchInt(_11) -> [0: bb9, otherwise: bb10];\n    }\n    bb9: {\n        _11 = false;\n        StorageDead(_2);\n        return;\n    }\n    bb10: {\n        drop(_2) -> [return: bb9, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}