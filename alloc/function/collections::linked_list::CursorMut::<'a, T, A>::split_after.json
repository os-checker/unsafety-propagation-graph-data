{
  "name": "collections::linked_list::CursorMut::<'a, T, A>::split_after",
  "safe": true,
  "callees": {
    "collections::linked_list::LinkedList::<T, A>::split_off_after_node": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::linked_list::LinkedList": "Constructor",
        "core::option::Option": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::linked_list::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "collections::linked_list::LinkedList": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::linked_list::CursorMut::<'a, T, A>::split_after"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/linked_list.rs:1778:5: 1788:6",
  "src": "pub fn split_after(&mut self) -> LinkedList<T, A>\n    where\n        A: Clone,\n    {\n        let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n        if self.index == self.list.len {\n            // The \"ghost\" non-element's index has changed to 0.\n            self.index = 0;\n        }\n        unsafe { self.list.split_off_after_node(self.current, split_off_idx) }\n    }",
  "mir": "fn collections::linked_list::CursorMut::<'a, T, A>::split_after(_1: &mut collections::linked_list::CursorMut<'_, T, A>) -> collections::linked_list::LinkedList<T, A> {\n    let mut _0: collections::linked_list::LinkedList<T, A>;\n    let  _2: usize;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: (usize, bool);\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let mut _12: usize;\n    let mut _13: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _14: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _15: &mut collections::linked_list::LinkedList<T, A>;\n    debug self => _1;\n    debug split_off_idx => _2;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).0: usize);\n        StorageLive(_5);\n        _13 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _5 = ((*_13).2: usize);\n        _3 = Eq(move _4, move _5);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _2 = 0_usize;\n        goto -> bb4;\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = ((*_1).0: usize);\n        _7 = CheckedAdd(_6, 1_usize);\n        assert(!move (_7.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _6, 1_usize) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _2 = move (_7.0: usize);\n        StorageDead(_6);\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = ((*_1).0: usize);\n        StorageLive(_10);\n        _14 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _10 = ((*_14).2: usize);\n        _8 = Eq(move _9, move _10);\n        switchInt(move _8) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_8);\n        _15 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        StorageLive(_11);\n        _11 = ((*_1).1: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>);\n        StorageLive(_12);\n        _12 = _2;\n        _0 = collections::linked_list::LinkedList::<T, A>::split_off_after_node(_15, move _11, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Splits the list into two after the current element. This will return a\n new list consisting of everything after the cursor, with the original\n list retaining everything before.\n\n If the cursor is pointing at the \"ghost\" non-element then the entire contents\n of the `LinkedList` are moved.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}