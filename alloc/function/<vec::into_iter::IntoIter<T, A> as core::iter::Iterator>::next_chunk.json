{
  "name": "<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk",
  "safe": true,
  "callees": {
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "vec::into_iter::IntoIter::<T, A>::forget_remaining_elements": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forgets to Drop the remaining elements while still allowing the backing allocation to be freed.\n",
      "adt": {
        "vec::into_iter::IntoIter": "MutableAsArgument"
      }
    },
    "core::array::IntoIter::<T, N>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the elements in a partially-initialized buffer.\n\n If you have a fully-initialized array, then use [`IntoIterator`].\n But this is useful for returning partial results from unsafe code.\n\n # Safety\n\n - The `buffer[initialized]` elements must all be initialized.\n - The range must be canonical, with `initialized.start <= initialized.end`.\n - The range must be in-bounds for the buffer, with `initialized.end <= N`.\n   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n\n It's sound to have more elements initialized than mentioned, though that\n will most likely result in them being leaked.\n\n # Examples\n\n ```\n #![feature(array_into_iter_constructors)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n use std::array::IntoIter;\n use std::mem::MaybeUninit;\n\n # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n # // otherwise it could leak. A fully-general version this would need a drop\n # // guard to handle panics from the iterator, but this works for an example.\n fn next_chunk<T: Copy, const N: usize>(\n     it: &mut impl Iterator<Item = T>,\n ) -> Result<[T; N], IntoIter<T, N>> {\n     let mut buffer = [const { MaybeUninit::uninit() }; N];\n     let mut i = 0;\n     while i < N {\n         match it.next() {\n             Some(x) => {\n                 buffer[i].write(x);\n                 i += 1;\n             }\n             None => {\n                 // SAFETY: We've initialized the first `i` items\n                 unsafe {\n                     return Err(IntoIter::new_unchecked(buffer, 0..i));\n                 }\n             }\n         }\n     }\n\n     // SAFETY: We've initialized all N items\n     unsafe { Ok(buffer.transpose().assume_init()) }\n }\n\n let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n assert_eq!(r, [10, 11, 12, 13]);\n let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n ```\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::wrapping_byte_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Subtracts an unsigned offset in bytes from a pointer using wrapping arithmetic.\n\n `count` is in units of bytes.\n\n This is purely a convenience for casting to a `u8` pointer and\n using [wrapping_sub][pointer::wrapping_sub] on it. See that method for documentation.\n\n For non-`Sized` pointees this operation changes only the data pointer,\n leaving the metadata untouched.\n",
      "adt": {}
    },
    "<[core::mem::MaybeUninit<T>; N]>::transpose": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transposes a `[MaybeUninit<T>; N]` into a `MaybeUninit<[T; N]>`.\n\n # Examples\n\n ```\n #![feature(maybe_uninit_uninit_array_transpose)]\n # use std::mem::MaybeUninit;\n\n let data = [MaybeUninit::<u8>::uninit(); 1000];\n let data: MaybeUninit<[u8; 1000]> = data.transpose();\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the value from the `MaybeUninit<T>` container. This is a great way\n to ensure that the data will get dropped, because the resulting `T` is\n subject to the usual drop handling.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes immediate undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n [inv]: #initialization-invariant\n\n On top of that, remember that most types have additional invariants beyond merely\n being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n is considered initialized (under the current implementation; this does not constitute\n a stable guarantee) because the only requirement the compiler knows about it\n is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n *immediate* undefined behavior, but will cause undefined behavior with most\n safe operations (including dropping it).\n\n [`Vec<T>`]: ../../std/vec/struct.Vec.html\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<bool>::uninit();\n x.write(true);\n let x_init = unsafe { x.assume_init() };\n assert_eq!(x_init, true);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_init = unsafe { x.assume_init() };\n // `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an offset to a pointer (convenience for `.offset(count as isize)`).\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let s: &str = \"123\";\n let ptr: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap();\n\n unsafe {\n     println!(\"{}\", ptr.add(1).read() as char);\n     println!(\"{}\", ptr.add(2).read() as char);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "vec::into_iter::IntoIter": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::array::IntoIter": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::mem::MaybeUninit": [
      "Plain"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/into_iter.rs:273:5: 307:6",
  "src": "fn next_chunk<const N: usize>(&mut self) -> Result<[T; N], core::array::IntoIter<T, N>> {\n        let mut raw_ary = [const { MaybeUninit::uninit() }; N];\n\n        let len = self.len();\n\n        if T::IS_ZST {\n            if len < N {\n                self.forget_remaining_elements();\n                // Safety: ZSTs can be conjured ex nihilo, only the amount has to be correct\n                return Err(unsafe { array::IntoIter::new_unchecked(raw_ary, 0..len) });\n            }\n\n            self.end = self.end.wrapping_byte_sub(N);\n            // Safety: ditto\n            return Ok(unsafe { raw_ary.transpose().assume_init() });\n        }\n\n        if len < N {\n            // Safety: `len` indicates that this many elements are available and we just checked that\n            // it fits into the array.\n            unsafe {\n                ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, len);\n                self.forget_remaining_elements();\n                return Err(array::IntoIter::new_unchecked(raw_ary, 0..len));\n            }\n        }\n\n        // Safety: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n        // the array.\n        unsafe {\n            ptr::copy_nonoverlapping(self.ptr.as_ptr(), raw_ary.as_mut_ptr() as *mut T, N);\n            self.ptr = self.ptr.add(N);\n            Ok(raw_ary.transpose().assume_init())\n        }\n    }",
  "mir": "fn <vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk(_1: &mut vec::into_iter::IntoIter<T, A>) -> core::result::Result<[T; N], core::array::IntoIter<T, N>> {\n    let mut _0: core::result::Result<[T; N], core::array::IntoIter<T, N>>;\n    let mut _2: [core::mem::MaybeUninit<T>; N];\n    let  _3: usize;\n    let mut _4: &&mut vec::into_iter::IntoIter<T, A>;\n    let mut _5: bool;\n    let  _6: ();\n    let mut _7: core::array::IntoIter<T, N>;\n    let mut _8: [core::mem::MaybeUninit<T>; N];\n    let mut _9: core::ops::Range<usize>;\n    let mut _10: *const T;\n    let mut _11: *const T;\n    let mut _12: [T; N];\n    let mut _13: core::mem::MaybeUninit<[T; N]>;\n    let mut _14: [core::mem::MaybeUninit<T>; N];\n    let mut _15: bool;\n    let  _16: ();\n    let mut _17: *const T;\n    let mut _18: *mut T;\n    let mut _19: core::ptr::NonNull<T>;\n    let mut _20: *mut T;\n    let mut _21: *mut core::mem::MaybeUninit<T>;\n    let mut _22: &mut [core::mem::MaybeUninit<T>];\n    let mut _23: &mut [core::mem::MaybeUninit<T>; N];\n    let  _24: ();\n    let mut _25: core::array::IntoIter<T, N>;\n    let mut _26: [core::mem::MaybeUninit<T>; N];\n    let mut _27: core::ops::Range<usize>;\n    let  _28: ();\n    let mut _29: *const T;\n    let mut _30: *mut T;\n    let mut _31: core::ptr::NonNull<T>;\n    let mut _32: *mut T;\n    let mut _33: *mut core::mem::MaybeUninit<T>;\n    let mut _34: &mut [core::mem::MaybeUninit<T>];\n    let mut _35: &mut [core::mem::MaybeUninit<T>; N];\n    let mut _36: core::ptr::NonNull<T>;\n    let mut _37: core::ptr::NonNull<T>;\n    let mut _38: [T; N];\n    let mut _39: core::mem::MaybeUninit<[T; N]>;\n    let mut _40: [core::mem::MaybeUninit<T>; N];\n    debug self => _1;\n    debug raw_ary => _2;\n    debug len => _3;\n    bb0: {\n        StorageLive(_2);\n        _2 = [<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk::<N>::{constant#1}; N];\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = <&mut vec::into_iter::IntoIter<T, A> as core::iter::ExactSizeIterator>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb10, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = Lt(_3, N);\n        switchInt(move _5) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        _6 = vec::into_iter::IntoIter::<T, A>::forget_remaining_elements(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = move _2;\n        StorageLive(_9);\n        _9 = Range(0_usize, _3);\n        _7 = core::array::IntoIter::<T, N>::new_unchecked(move _8, move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _0 = core::result::Result::Err(move _7);\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb24;\n    }\n    bb6: {\n        StorageDead(_5);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = ((*_1).5: *const T);\n        _10 = core::ptr::const_ptr::<impl *const T>::wrapping_byte_sub(move _11, N) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        ((*_1).5: *const T) = move _10;\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = move _2;\n        _13 = <[core::mem::MaybeUninit<T>; N]>::transpose(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        _12 = core::mem::MaybeUninit::<[T; N]>::assume_init(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _0 = core::result::Result::Ok(move _12);\n        StorageDead(_12);\n        goto -> bb24;\n    }\n    bb10: {\n        StorageLive(_15);\n        _15 = Lt(_3, N);\n        switchInt(move _15) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = ((*_1).4: core::ptr::NonNull<T>);\n        _18 = core::ptr::NonNull::<T>::as_ptr(move _19) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = ((*_1).4: core::ptr::NonNull<T>);\n        _30 = core::ptr::NonNull::<T>::as_ptr(move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb13: {\n        _17 = move _18 as *const T;\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &mut _2;\n        _22 = move _23 as &mut [core::mem::MaybeUninit<T>];\n        StorageDead(_23);\n        _21 = core::slice::<impl [core::mem::MaybeUninit<T>]>::as_mut_ptr(move _22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_22);\n        _20 = move _21 as *mut T;\n        StorageDead(_21);\n        _16 = core::ptr::copy_nonoverlapping::<T>(move _17, move _20, _3) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageDead(_17);\n        _24 = vec::into_iter::IntoIter::<T, A>::forget_remaining_elements(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = move _2;\n        StorageLive(_27);\n        _27 = Range(0_usize, _3);\n        _25 = core::array::IntoIter::<T, N>::new_unchecked(move _26, move _27) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_27);\n        StorageDead(_26);\n        _0 = core::result::Result::Err(move _25);\n        StorageDead(_25);\n        StorageDead(_15);\n        goto -> bb25;\n    }\n    bb18: {\n        _29 = move _30 as *const T;\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &mut _2;\n        _34 = move _35 as &mut [core::mem::MaybeUninit<T>];\n        StorageDead(_35);\n        _33 = core::slice::<impl [core::mem::MaybeUninit<T>]>::as_mut_ptr(move _34) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_34);\n        _32 = move _33 as *mut T;\n        StorageDead(_33);\n        _28 = core::ptr::copy_nonoverlapping::<T>(move _29, move _32, N) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_32);\n        StorageDead(_29);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = ((*_1).4: core::ptr::NonNull<T>);\n        _36 = core::ptr::NonNull::<T>::add(move _37, N) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_37);\n        ((*_1).4: core::ptr::NonNull<T>) = move _36;\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = move _2;\n        _39 = <[core::mem::MaybeUninit<T>; N]>::transpose(move _40) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_40);\n        _38 = core::mem::MaybeUninit::<[T; N]>::assume_init(move _39) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_39);\n        _0 = core::result::Result::Ok(move _38);\n        StorageDead(_38);\n        StorageDead(_2);\n        goto -> bb26;\n    }\n    bb24: {\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_2);\n        goto -> bb26;\n    }\n    bb26: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}