{
  "name": "collections::vec_deque::VecDeque::<T, A>::iter_mut",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::as_mut_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n\n deque.push_front(10);\n deque.push_front(9);\n\n // Since the split point is not guaranteed, we may need to update\n // either slice.\n let mut update_nth = |index: usize, val: u32| {\n     let (front, back) = deque.as_mut_slices();\n     if index > front.len() - 1 {\n         back[index - front.len()] = val;\n     } else {\n         front[index] = val;\n     }\n };\n\n update_nth(0, 42);\n update_nth(2, 24);\n\n let v: Vec<_> = deque.into();\n assert_eq!(v, [42, 10, 24, 1]);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::iter_mut::IterMut::<'a, T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::iter_mut::IterMut": "Constructor"
      }
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "MutRef"
    ],
    "core::slice::IterMut": [
      "Plain"
    ],
    "collections::vec_deque::iter_mut::IterMut": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::iter_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1515:5: 1518:6",
  "src": "pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n        let (a, b) = self.as_mut_slices();\n        IterMut::new(a.iter_mut(), b.iter_mut())\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::iter_mut(_1: &mut collections::vec_deque::VecDeque<T, A>) -> collections::vec_deque::iter_mut::IterMut<'_, T> {\n    let mut _0: collections::vec_deque::iter_mut::IterMut<'_, T>;\n    let  _2: &mut [T];\n    let  _3: &mut [T];\n    let mut _4: (&mut [T], &mut [T]);\n    let mut _5: core::slice::IterMut<'_, T>;\n    let mut _6: core::slice::IterMut<'_, T>;\n    debug self => _1;\n    debug a => _2;\n    debug b => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = collections::vec_deque::VecDeque::<T, A>::as_mut_slices(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = move (_4.0: &mut [T]);\n        _3 = move (_4.1: &mut [T]);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = core::slice::<impl [T]>::iter_mut(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = core::slice::<impl [T]>::iter_mut(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = collections::vec_deque::iter_mut::IterMut::<'_, T>::new(move _5, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Returns a front-to-back iterator that returns mutable references.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::new();\n buf.push_back(5);\n buf.push_back(3);\n buf.push_back(4);\n for num in buf.iter_mut() {\n     *num = *num - 2;\n }\n let b: &[_] = &[&mut 3, &mut 1, &mut 2];\n assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[..], b);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}