{
  "name": "<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::advance_by",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the deque, removing all values.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n deque.push_back(1);\n deque.clear();\n assert!(deque.is_empty());\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::drain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the specified range from the deque in bulk, returning all\n removed elements as an iterator. If the iterator is dropped before\n being fully consumed, it drops the remaining removed elements.\n\n The returned iterator keeps a mutable borrow on the queue to optimize\n its implementation.\n\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and past the length of the deque.\n\n # Leaking\n\n If the returned iterator goes out of scope without being dropped (due to\n [`mem::forget`], for example), the deque may have lost and leaked\n elements arbitrarily, including elements outside the range.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque: VecDeque<_> = [1, 2, 3].into();\n let drained = deque.drain(2..).collect::<VecDeque<_>>();\n assert_eq!(drained, [3]);\n assert_eq!(deque, [1, 2]);\n\n // A full range clears all contents, like `clear()` does\n deque.drain(..);\n assert!(deque.is_empty());\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument",
        "collections::vec_deque::drain::Drain": "Constructor"
      }
    },
    "core::num::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {}
    },
    "core::option::Option::<T>::map_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the provided default result (if none),\n or applies a function to the contained value (if any).\n\n Arguments passed to `map_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`map_or_else`],\n which is lazily evaluated.\n\n [`map_or_else`]: Option::map_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.map_or(42, |v| v.len()), 3);\n\n let x: Option<&str> = None;\n assert_eq!(x.map_or(42, |v| v.len()), 42);\n ```\n",
      "adt": {}
    },
    "core::prelude::v1::Err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Contains the error value\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::into_iter::IntoIter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "collections::vec_deque::VecDeque": [
      "MutRef"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "collections::vec_deque::drain::Drain": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::advance_by"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:58:5: 68:6",
  "src": "fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        let len = self.inner.len;\n        let rem = if len < n {\n            self.inner.clear();\n            n - len\n        } else {\n            self.inner.drain(..n);\n            0\n        };\n        NonZero::new(rem).map_or(Ok(()), Err)\n    }",
  "mir": "fn <collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::advance_by(_1: &mut collections::vec_deque::into_iter::IntoIter<T, A>, _2: usize) -> core::result::Result<(), core::num::NonZero<usize>> {\n    let mut _0: core::result::Result<(), core::num::NonZero<usize>>;\n    let  _3: usize;\n    let  _4: usize;\n    let mut _5: bool;\n    let  _6: ();\n    let mut _7: &mut collections::vec_deque::VecDeque<T, A>;\n    let mut _8: (usize, bool);\n    let  _9: collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _10: &mut collections::vec_deque::VecDeque<T, A>;\n    let mut _11: core::ops::RangeTo<usize>;\n    let mut _12: core::option::Option<core::num::NonZero<usize>>;\n    let mut _13: usize;\n    let mut _14: core::result::Result<(), core::num::NonZero<usize>>;\n    debug self => _1;\n    debug n => _2;\n    debug len => _3;\n    debug rem => _4;\n    bb0: {\n        _3 = (((*_1).0: collections::vec_deque::VecDeque<T, A>).1: usize);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = Lt(_3, _2);\n        switchInt(move _5) -> [0: bb4, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_7);\n        _7 = &mut ((*_1).0: collections::vec_deque::VecDeque<T, A>);\n        _6 = collections::vec_deque::VecDeque::<T, A>::clear(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _8 = CheckedSub(_2, _3);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, _3) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = move (_8.0: usize);\n        goto -> bb7;\n    }\n    bb4: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut ((*_1).0: collections::vec_deque::VecDeque<T, A>);\n        StorageLive(_11);\n        _11 = RangeTo(_2);\n        _9 = collections::vec_deque::VecDeque::<T, A>::drain::<core::ops::RangeTo<usize>>(move _10, move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageDead(_10);\n        drop(_9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_9);\n        _4 = 0_usize;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_5);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = _4;\n        _12 = core::num::NonZero::<usize>::new(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageLive(_14);\n        _14 = core::result::Result::Ok(());\n        _0 = core::option::Option::<core::num::NonZero<usize>>::map_or::<core::result::Result<(), core::num::NonZero<usize>>, fn(core::num::NonZero<usize>) -> core::result::Result<(), core::num::NonZero<usize>> {core::result::Result::<(), core::num::NonZero<usize>>::Err}>(move _12, move _14, core::result::Result::<(), core::num::NonZero<usize>>::Err) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}