{
  "name": "collections::btree::set::BTreeSet::<T, A>::split_off",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::split_off": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the collection into two at the given key. Returns everything after the given key,\n including the key. If the key is not present, the split will occur at the nearest\n greater key, or return an empty map if no such key exists.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n a.insert(1, \"a\");\n a.insert(2, \"b\");\n a.insert(3, \"c\");\n a.insert(17, \"d\");\n a.insert(41, \"e\");\n\n let b = a.split_off(&3);\n\n assert_eq!(a.len(), 2);\n assert_eq!(b.len(), 3);\n\n assert_eq!(a[&1], \"a\");\n assert_eq!(a[&2], \"b\");\n\n assert_eq!(b[&3], \"c\");\n assert_eq!(b[&17], \"d\");\n assert_eq!(b[&41], \"e\");\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::set::BTreeSet": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain",
      "MutRef"
    ]
  },
  "path": 1074,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:1175:5: 1181:6",
  "src": "pub fn split_off<Q: ?Sized + Ord>(&mut self, value: &Q) -> Self\n    where\n        T: Borrow<Q> + Ord,\n        A: Clone,\n    {\n        BTreeSet { map: self.map.split_off(value) }\n    }",
  "mir": "fn collections::btree::set::BTreeSet::<T, A>::split_off(_1: &mut collections::btree::set::BTreeSet<T, A>, _2: &Q) -> collections::btree::set::BTreeSet<T, A> {\n    let mut _0: collections::btree::set::BTreeSet<T, A>;\n    let mut _3: collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>;\n    let mut _4: &mut collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>;\n    debug self => _1;\n    debug value => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>);\n        _3 = collections::btree::map::BTreeMap::<T, collections::btree::set_val::SetValZST, A>::split_off::<Q>(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = BTreeSet(move _3);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Splits the collection into two at the value. Returns a new collection\n with all elements greater than or equal to the value.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::collections::BTreeSet;\n\n let mut a = BTreeSet::new();\n a.insert(1);\n a.insert(2);\n a.insert(3);\n a.insert(17);\n a.insert(41);\n\n let b = a.split_off(&3);\n\n assert_eq!(a.len(), 2);\n assert_eq!(b.len(), 3);\n\n assert!(a.contains(&1));\n assert!(a.contains(&2));\n\n assert!(b.contains(&3));\n assert!(b.contains(&17));\n assert!(b.contains(&41));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}