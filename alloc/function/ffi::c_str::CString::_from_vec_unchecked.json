{
  "name": "ffi::c_str::CString::_from_vec_unchecked",
  "safe": false,
  "callees": {
    "vec::Vec::<T, A>::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves the minimum capacity for at least `additional` more elements to\n be inserted in the given `Vec<T>`. Unlike [`reserve`], this will not\n deliberately over-allocate to speculatively avoid frequent allocations.\n After calling `reserve_exact`, capacity will be greater than or equal to\n `self.len() + additional`. Does nothing if the capacity is already\n sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`reserve`] if future insertions are expected.\n\n [`reserve`]: Vec::reserve\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.reserve_exact(10);\n assert!(vec.capacity() >= 11);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::into_boxed_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the vector into [`Box<[T]>`][owned slice].\n\n Before doing the conversion, this method discards excess capacity like [`shrink_to_fit`].\n\n [owned slice]: Box\n [`shrink_to_fit`]: Vec::shrink_to_fit\n\n # Examples\n\n ```\n let v = vec![1, 2, 3];\n\n let slice = v.into_boxed_slice();\n ```\n\n Any excess capacity is removed:\n\n ```\n let mut vec = Vec::with_capacity(10);\n vec.extend([1, 2, 3]);\n\n assert!(vec.capacity() >= 10);\n let slice = vec.into_boxed_slice();\n assert_eq!(slice.into_vec().capacity(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument",
        "boxed::Box": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "MutRef",
      "Plain"
    ],
    "boxed::Box": [
      "Plain"
    ],
    "ffi::c_str::CString": [
      "Plain"
    ]
  },
  "path": 1578,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/ffi/c_str.rs:340:5: 344:6",
  "src": "unsafe fn _from_vec_unchecked(mut v: Vec<u8>) -> Self {\n        v.reserve_exact(1);\n        v.push(0);\n        Self { inner: v.into_boxed_slice() }\n    }",
  "mir": "fn ffi::c_str::CString::_from_vec_unchecked(_1: vec::Vec<u8>) -> ffi::c_str::CString {\n    let mut _0: ffi::c_str::CString;\n    let  _2: ();\n    let mut _3: &mut vec::Vec<u8>;\n    let  _4: ();\n    let mut _5: &mut vec::Vec<u8>;\n    let mut _6: boxed::Box<[u8]>;\n    let mut _7: vec::Vec<u8>;\n    debug v => _1;\n    bb0: {\n        StorageLive(_3);\n        _3 = &mut _1;\n        _2 = vec::Vec::<u8>::reserve_exact(move _3, 1_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = &mut _1;\n        _4 = vec::Vec::<u8>::push(move _5, 0_u8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = move _1;\n        _6 = vec::Vec::<u8>::into_boxed_slice(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _0 = CString(move _6);\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}