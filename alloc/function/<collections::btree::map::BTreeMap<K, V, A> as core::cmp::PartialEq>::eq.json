{
  "name": "<collections::btree::map::BTreeMap<K, V, A> as core::cmp::PartialEq>::eq",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the map.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n assert_eq!(a.len(), 0);\n a.insert(1, \"a\");\n assert_eq!(a.len(), 1);\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "ImmutableAsArgument"
      }
    },
    "collections::btree::map::BTreeMap::<K, V, A>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets an iterator over the entries of the map, sorted by key.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(3, \"c\");\n map.insert(2, \"b\");\n map.insert(1, \"a\");\n\n for (key, value) in map.iter() {\n     println!(\"{key}: {value}\");\n }\n\n let (first_key, first_value) = map.iter().next().unwrap();\n assert_eq!((*first_key, *first_value), (1, \"a\"));\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "ImmutableAsArgument",
        "collections::btree::map::Iter": "Constructor"
      }
    },
    "core::iter::Iterator::zip": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " 'Zips up' two iterators into a single iterator of pairs.\n\n `zip()` returns a new iterator that will iterate over two other\n iterators, returning a tuple where the first element comes from the\n first iterator, and the second element comes from the second iterator.\n\n In other words, it zips two iterators together, into a single one.\n\n If either iterator returns [`None`], [`next`] from the zipped iterator\n will return [`None`].\n If the zipped iterator has no more elements to return then each further attempt to advance\n it will first try to advance the first iterator at most one time and if it still yielded an item\n try to advance the second iterator at most one time.\n\n To 'undo' the result of zipping up two iterators, see [`unzip`].\n\n [`unzip`]: Iterator::unzip\n\n # Examples\n\n Basic usage:\n\n ```\n let s1 = \"abc\".chars();\n let s2 = \"def\".chars();\n\n let mut iter = s1.zip(s2);\n\n assert_eq!(iter.next(), Some(('a', 'd')));\n assert_eq!(iter.next(), Some(('b', 'e')));\n assert_eq!(iter.next(), Some(('c', 'f')));\n assert_eq!(iter.next(), None);\n ```\n\n Since the argument to `zip()` uses [`IntoIterator`], we can pass\n anything that can be converted into an [`Iterator`], not just an\n [`Iterator`] itself. For example, arrays (`[T]`) implement\n [`IntoIterator`], and so can be passed to `zip()` directly:\n\n ```\n let a1 = [1, 2, 3];\n let a2 = [4, 5, 6];\n\n let mut iter = a1.into_iter().zip(a2);\n\n assert_eq!(iter.next(), Some((1, 4)));\n assert_eq!(iter.next(), Some((2, 5)));\n assert_eq!(iter.next(), Some((3, 6)));\n assert_eq!(iter.next(), None);\n ```\n\n `zip()` is often used to zip an infinite iterator to a finite one.\n This works because the finite iterator will eventually return [`None`],\n ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`]:\n\n ```\n let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n\n let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n\n assert_eq!((0, 'f'), enumerate[0]);\n assert_eq!((0, 'f'), zipper[0]);\n\n assert_eq!((1, 'o'), enumerate[1]);\n assert_eq!((1, 'o'), zipper[1]);\n\n assert_eq!((2, 'o'), enumerate[2]);\n assert_eq!((2, 'o'), zipper[2]);\n ```\n\n If both iterators have roughly equivalent syntax, it may be more readable to use [`zip`]:\n\n ```\n use std::iter::zip;\n\n let a = [1, 2, 3];\n let b = [2, 3, 4];\n\n let mut zipped = zip(\n     a.into_iter().map(|x| x * 2).skip(1),\n     b.into_iter().map(|x| x * 2).skip(1),\n );\n\n assert_eq!(zipped.next(), Some((4, 6)));\n assert_eq!(zipped.next(), Some((6, 8)));\n assert_eq!(zipped.next(), None);\n ```\n\n compared to:\n\n ```\n # let a = [1, 2, 3];\n # let b = [2, 3, 4];\n #\n let mut zipped = a\n     .into_iter()\n     .map(|x| x * 2)\n     .skip(1)\n     .zip(b.into_iter().map(|x| x * 2).skip(1));\n #\n # assert_eq!(zipped.next(), Some((4, 6)));\n # assert_eq!(zipped.next(), Some((6, 8)));\n # assert_eq!(zipped.next(), None);\n ```\n\n [`enumerate`]: Iterator::enumerate\n [`next`]: Iterator::next\n [`zip`]: crate::iter::zip\n",
      "adt": {}
    },
    "core::iter::Iterator::all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests if every element of the iterator matches a predicate.\n\n `all()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if they all return\n `true`, then so does `all()`. If any of them return `false`, it\n returns `false`.\n\n `all()` is short-circuiting; in other words, it will stop processing\n as soon as it finds a `false`, given that no matter what else happens,\n the result will also be `false`.\n\n An empty iterator returns `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert!(a.into_iter().all(|x| x > 0));\n\n assert!(!a.into_iter().all(|x| x > 2));\n ```\n\n Stopping at the first `false`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert!(!iter.all(|x| x != 2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "Ref"
    ],
    "collections::btree::map::Iter": [
      "Plain"
    ],
    "core::iter::Zip": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::btree::map::BTreeMap<K, V, A> as core::cmp::PartialEq>::eq"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2446:5: 2448:6",
  "src": "fn eq(&self, other: &BTreeMap<K, V, A>) -> bool {\n        self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n    }",
  "mir": "fn <collections::btree::map::BTreeMap<K, V, A> as core::cmp::PartialEq>::eq(_1: &collections::btree::map::BTreeMap<K, V, A>, _2: &collections::btree::map::BTreeMap<K, V, A>) -> bool {\n    let mut _0: bool;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: &mut core::iter::Zip<collections::btree::map::Iter<'_, K, V>, collections::btree::map::Iter<'_, K, V>>;\n    let mut _7: core::iter::Zip<collections::btree::map::Iter<'_, K, V>, collections::btree::map::Iter<'_, K, V>>;\n    let mut _8: collections::btree::map::Iter<'_, K, V>;\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = collections::btree::map::BTreeMap::<K, V, A>::len(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = collections::btree::map::BTreeMap::<K, V, A>::len(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = Eq(move _4, move _5);\n        switchInt(move _3) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = collections::btree::map::BTreeMap::<K, V, A>::iter(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = false;\n        goto -> bb8;\n    }\n    bb5: {\n        _7 = <collections::btree::map::Iter<'_, K, V> as core::iter::Iterator>::zip::<&collections::btree::map::BTreeMap<K, V, A>>(move _8, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _6 = &mut _7;\n        StorageDead(_8);\n        _0 = <core::iter::Zip<collections::btree::map::Iter<'_, K, V>, collections::btree::map::Iter<'_, K, V>> as core::iter::Iterator>::all::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2447:65: 2447:73}>(move _6, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2447:65: 2447:73}) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}