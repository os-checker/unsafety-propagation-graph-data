{
  "name": "wtf8::Wtf8Buf::from_wide",
  "safe": true,
  "callees": {
    "wtf8::Wtf8Buf::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new, empty WTF-8 string with pre-allocated capacity for `capacity` bytes.\n",
      "adt": {
        "wtf8::Wtf8Buf": "Constructor"
      }
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::cloned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which [`clone`]s all of its elements.\n\n This is useful when you have an iterator over `&T`, but you need an\n iterator over `T`.\n\n There is no guarantee whatsoever about the `clone` method actually\n being called *or* optimized away. So code should not depend on\n either.\n\n [`clone`]: Clone::clone\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let v_cloned: Vec<_> = a.iter().cloned().collect();\n\n // cloned is the same as .map(|&x| x), for integers\n let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\n assert_eq!(v_cloned, [1, 2, 3]);\n assert_eq!(v_map, [1, 2, 3]);\n ```\n\n To get the best performance, try to clone late:\n\n ```\n let a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];\n // don't do this:\n let slower: Vec<_> = a.iter().cloned().filter(|s| s.len() == 1).collect();\n assert_eq!(&[vec![23]], &slower[..]);\n // instead call `cloned` late\n let faster: Vec<_> = a.iter().filter(|s| s.len() == 1).cloned().collect();\n assert_eq!(&[vec![23]], &faster[..]);\n ```\n",
      "adt": {}
    },
    "core::char::methods::<impl char>::decode_utf16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the native endian UTF-16 encoded code points in `iter`,\n returning unpaired surrogates as `Err`s.\n\n # Examples\n\n Basic usage:\n\n ```\n // ùÑûmus<invalid>ic<invalid>\n let v = [\n     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n ];\n\n assert_eq!(\n     char::decode_utf16(v)\n         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n         .collect::<Vec<_>>(),\n     vec![\n         Ok('ùÑû'),\n         Ok('m'), Ok('u'), Ok('s'),\n         Err(0xDD1E),\n         Ok('i'), Ok('c'),\n         Err(0xD834)\n     ]\n );\n ```\n\n A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n\n ```\n // ùÑûmus<invalid>ic<invalid>\n let v = [\n     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n ];\n\n assert_eq!(\n     char::decode_utf16(v)\n        .map(|r| r.unwrap_or(char::REPLACEMENT_CHARACTER))\n        .collect::<String>(),\n     \"ùÑûmusÔøΩicÔøΩ\"\n );\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::char::DecodeUtf16Error::unpaired_surrogate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the unpaired surrogate which caused this error.\n",
      "adt": {}
    },
    "wtf8::Wtf8Buf::push_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Append a Unicode scalar value at the end of the string.\n",
      "adt": {
        "wtf8::Wtf8Buf": "MutableAsArgument"
      }
    },
    "core::wtf8::CodePoint::from_u32_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unsafely creates a new `CodePoint` without checking the value.\n\n Only use when `value` is known to be less than or equal to 0x10FFFF.\n",
      "adt": {}
    },
    "wtf8::Wtf8Buf::push_code_point_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends the given `char` to the end of this string.\n This does **not** include the WTF-8 concatenation check or `is_known_utf8` check.\n Copied from String::push.\n",
      "adt": {
        "wtf8::Wtf8Buf": "MutableAsArgument",
        "core::wtf8::CodePoint": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "wtf8::Wtf8Buf": [
      "Plain",
      "MutRef",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Bool) })])"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Cloned": [
      "Plain"
    ],
    "core::char::DecodeUtf16": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8749, kind: RigidTy(Adt(AdtDef(DefId { id: 2596, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 904, kind: RigidTy(Char) }), Type(Ty { id: 8758, kind: RigidTy(Adt(AdtDef(DefId { id: 5437, name: \"core::char::DecodeUtf16Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8758, kind: RigidTy(Adt(AdtDef(DefId { id: 5437, name: \"core::char::DecodeUtf16Error\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 904, kind: RigidTy(Char) })])"
    ],
    "core::char::DecodeUtf16Error": [
      "Plain",
      "Ref"
    ],
    "core::wtf8::CodePoint": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::wtf8::Wtf8Buf::from_wide"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/wtf8/mod.rs:143:5: 163:6",
  "src": "pub fn from_wide(v: &[u16]) -> Wtf8Buf {\n        let mut string = Wtf8Buf::with_capacity(v.len());\n        for item in char::decode_utf16(v.iter().cloned()) {\n            match item {\n                Ok(ch) => string.push_char(ch),\n                Err(surrogate) => {\n                    let surrogate = surrogate.unpaired_surrogate();\n                    // Surrogates are known to be in the code point range.\n                    let code_point = unsafe { CodePoint::from_u32_unchecked(surrogate as u32) };\n                    // The string will now contain an unpaired surrogate.\n                    string.is_known_utf8 = false;\n                    // Skip the WTF-8 concatenation check,\n                    // surrogate pairs are already decoded by decode_utf16\n                    unsafe {\n                        string.push_code_point_unchecked(code_point);\n                    }\n                }\n            }\n        }\n        string\n    }",
  "mir": "fn wtf8::Wtf8Buf::from_wide(_1: &[u16]) -> wtf8::Wtf8Buf {\n    let mut _0: wtf8::Wtf8Buf;\n    let mut _2: wtf8::Wtf8Buf;\n    let mut _3: usize;\n    let mut _4: core::char::DecodeUtf16<core::iter::Cloned<core::slice::Iter<'_, u16>>>;\n    let mut _5: core::char::DecodeUtf16<core::iter::Cloned<core::slice::Iter<'_, u16>>>;\n    let mut _6: core::iter::Cloned<core::slice::Iter<'_, u16>>;\n    let mut _7: core::slice::Iter<'_, u16>;\n    let mut _8: core::char::DecodeUtf16<core::iter::Cloned<core::slice::Iter<'_, u16>>>;\n    let  _9: ();\n    let mut _10: core::option::Option<core::result::Result<char, core::char::DecodeUtf16Error>>;\n    let mut _11: &mut core::char::DecodeUtf16<core::iter::Cloned<core::slice::Iter<'_, u16>>>;\n    let mut _12: isize;\n    let  _13: core::result::Result<char, core::char::DecodeUtf16Error>;\n    let mut _14: isize;\n    let  _15: char;\n    let mut _16: &mut wtf8::Wtf8Buf;\n    let  _17: core::char::DecodeUtf16Error;\n    let  _18: u16;\n    let mut _19: &core::char::DecodeUtf16Error;\n    let  _20: core::wtf8::CodePoint;\n    let mut _21: u32;\n    let  _22: ();\n    let mut _23: &mut wtf8::Wtf8Buf;\n    debug v => _1;\n    debug string => _2;\n    debug iter => _8;\n    debug item => _13;\n    debug ch => _15;\n    debug surrogate => _17;\n    debug surrogate => _18;\n    debug code_point => _20;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        _2 = wtf8::Wtf8Buf::with_capacity(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::slice::<impl [u16]>::iter(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = <core::slice::Iter<'_, u16> as core::iter::Iterator>::cloned::<'_, u16>(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _5 = core::char::methods::<impl char>::decode_utf16::<core::iter::Cloned<core::slice::Iter<'_, u16>>>(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        _4 = <core::char::DecodeUtf16<core::iter::Cloned<core::slice::Iter<'_, u16>>> as core::iter::IntoIterator>::into_iter(move _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = move _4;\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_10);\n        _11 = &mut _8;\n        _10 = <core::char::DecodeUtf16<core::iter::Cloned<core::slice::Iter<'_, u16>>> as core::iter::Iterator>::next(_11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb10, 1: bb9, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageLive(_13);\n        _13 = move ((_10 as variant#1).0: core::result::Result<char, core::char::DecodeUtf16Error>);\n        _14 = discriminant(_13);\n        switchInt(move _14) -> [0: bb12, 1: bb11, otherwise: bb8];\n    }\n    bb10: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageDead(_4);\n        _0 = move _2;\n        StorageDead(_2);\n        return;\n    }\n    bb11: {\n        StorageLive(_17);\n        _17 = move ((_13 as variant#1).0: core::char::DecodeUtf16Error);\n        StorageLive(_19);\n        _19 = &_17;\n        _18 = core::char::DecodeUtf16Error::unpaired_surrogate(move _19) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _15 = ((_13 as variant#0).0: char);\n        StorageLive(_16);\n        _16 = &mut _2;\n        _9 = wtf8::Wtf8Buf::push_char(move _16, _15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        goto -> bb17;\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageLive(_21);\n        _21 = _18 as u32;\n        _20 = core::wtf8::CodePoint::from_u32_unchecked(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        (_2.1: bool) = false;\n        StorageLive(_23);\n        _23 = &mut _2;\n        _22 = wtf8::Wtf8Buf::push_code_point_unchecked(move _23, _20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageDead(_17);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb6;\n    }\n}\n",
  "doc": " Creates a WTF-8 string from a potentially ill-formed UTF-16 slice of 16-bit code units.\n\n This is lossless: calling `.encode_wide()` on the resulting string\n will always return the original code units.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}