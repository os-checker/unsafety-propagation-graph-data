{
  "name": "collections::btree::map::CursorMut::<'a, K, V, A>::next",
  "safe": true,
  "callees": {
    "collections::btree::map::CursorMutKey::<'a, K, V, A>::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the cursor to the next gap, returning the key and value of the\n element that it moved over.\n\n If the cursor is already at the end of the map then `None` is returned\n and the cursor is not moved.\n",
      "adt": {
        "collections::btree::map::CursorMutKey": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::map::CursorMutKey": [
      "MutRef"
    ],
    "collections::btree::map::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2762, kind: RigidTy(Tuple([Ty { id: 2761, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Mut)) }, Ty { id: 2687, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }, Mut)) }])) })])"
    ]
  },
  "path": 652,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3109:5: 3112:6",
  "src": "pub fn next(&mut self) -> Option<(&K, &mut V)> {\n        let (k, v) = self.inner.next()?;\n        Some((&*k, v))\n    }",
  "mir": "fn collections::btree::map::CursorMut::<'a, K, V, A>::next(_1: &mut collections::btree::map::CursorMut<'_, K, V, A>) -> core::option::Option<(&K, &mut V)> {\n    let mut _0: core::option::Option<(&K, &mut V)>;\n    let  _2: &mut K;\n    let  _3: &mut V;\n    let mut _4: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, (&mut K, &mut V)>;\n    let mut _5: core::option::Option<(&mut K, &mut V)>;\n    let mut _6: &mut collections::btree::map::CursorMutKey<'_, K, V, A>;\n    let mut _7: isize;\n    let  _8: (&mut K, &mut V);\n    let mut _9: (&K, &mut V);\n    let  _10: &K;\n    debug self => _1;\n    debug k => _2;\n    debug v => _3;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _8;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut ((*_1).0: collections::btree::map::CursorMutKey<'_, K, V, A>);\n        _5 = collections::btree::map::CursorMutKey::<'_, K, V, A>::next(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _4 = <core::option::Option<(&mut K, &mut V)> as core::ops::Try>::branch(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _7 = discriminant(_4);\n        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _8 = move ((_4 as variant#0).0: (&mut K, &mut V));\n        StorageLive(_2);\n        _2 = (_8.0: &mut K);\n        _3 = (_8.1: &mut V);\n        StorageDead(_4);\n        StorageLive(_9);\n        _10 = &(*_2);\n        _9 = (_10, _3);\n        _0 = core::option::Option::Some(move _9);\n        StorageDead(_9);\n        StorageDead(_2);\n        goto -> bb7;\n    }\n    bb5: {\n        _0 = <core::option::Option<(&K, &mut V)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": " Advances the cursor to the next gap, returning the key and value of the\n element that it moved over.\n\n If the cursor is already at the end of the map then `None` is returned\n and the cursor is not moved.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}