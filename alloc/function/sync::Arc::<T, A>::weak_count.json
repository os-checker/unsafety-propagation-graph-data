{
  "name": "sync::Arc::<T, A>::weak_count",
  "safe": true,
  "callees": {
    "sync::Arc::<T, A>::inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::Arc": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicUsize::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::Arc": [
      "Ref"
    ],
    "sync::ArcInner": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::sync::Arc::<T, A>::weak_count"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:1973:5: 1978:6",
  "src": "pub fn weak_count(this: &Self) -> usize {\n        let cnt = this.inner().weak.load(Relaxed);\n        // If the weak count is currently locked, the value of the\n        // count was 0 just before taking the lock.\n        if cnt == usize::MAX { 0 } else { cnt - 1 }\n    }",
  "mir": "fn sync::Arc::<T, A>::weak_count(_1: &sync::Arc<T, A>) -> usize {\n    let mut _0: usize;\n    let  _2: usize;\n    let mut _3: &core::sync::atomic::AtomicUsize;\n    let  _4: &sync::ArcInner<T>;\n    let mut _5: core::sync::atomic::Ordering;\n    let mut _6: bool;\n    let mut _7: (usize, bool);\n    debug this => _1;\n    debug cnt => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = sync::Arc::<T, A>::inner(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &((*_4).1: core::sync::atomic::AtomicUsize);\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Relaxed;\n        _2 = core::sync::atomic::AtomicUsize::load(move _3, move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = Eq(_2, core::num::<impl usize>::MAX);\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _0 = 0_usize;\n        goto -> bb6;\n    }\n    bb4: {\n        _7 = CheckedSub(_2, 1_usize);\n        assert(!move (_7.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = move (_7.0: usize);\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Gets the number of [`Weak`] pointers to this allocation.\n\n # Safety\n\n This method by itself is safe, but using it correctly requires extra care.\n Another thread can change the weak count at any time,\n including potentially between calling this method and acting on the result.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n let _weak_five = Arc::downgrade(&five);\n\n // This assertion is deterministic because we haven't shared\n // the `Arc` or `Weak` between threads.\n assert_eq!(1, Arc::weak_count(&five));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}