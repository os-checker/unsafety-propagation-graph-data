{
  "name": "<vec::Vec<T> as vec::spec_from_iter_nested::SpecFromIterNested<T, I>>::from_iter",
  "safe": true,
  "callees": {
    "core::iter::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "vec::spec_extend::SpecExtend::spec_extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Field(1, Ty { id: 257, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Field(1, Ty { id: 257, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "vec::Vec": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 2310,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/spec_from_iter_nested.rs:50:5: 62:6",
  "src": "fn from_iter(iterator: I) -> Self {\n        let mut vector = match iterator.size_hint() {\n            (_, Some(upper)) => Vec::with_capacity(upper),\n            // TrustedLen contract guarantees that `size_hint() == (_, None)` means that there\n            // are more than `usize::MAX` elements.\n            // Since the previous branch would eagerly panic if the capacity is too large\n            // (via `with_capacity`) we do the same here.\n            _ => panic!(\"capacity overflow\"),\n        };\n        // reuse extend specialization for TrustedLen\n        vector.spec_extend(iterator);\n        vector\n    }",
  "mir": "fn <vec::Vec<T> as vec::spec_from_iter_nested::SpecFromIterNested<T, I>>::from_iter(_1: I) -> vec::Vec<T> {\n    let mut _0: vec::Vec<T>;\n    let mut _2: vec::Vec<T>;\n    let mut _3: (usize, core::option::Option<usize>);\n    let mut _4: &I;\n    let mut _5: isize;\n    let  _6: usize;\n    let  _7: !;\n    let mut _8: core::fmt::Arguments<'_>;\n    let  _9: ();\n    let mut _10: &mut vec::Vec<T>;\n    let mut _11: I;\n    debug iterator => _1;\n    debug vector => _2;\n    debug upper => _6;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = <I as core::iter::Iterator>::size_hint(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _5 = discriminant((_3.1: core::option::Option<usize>));\n        switchInt(move _5) -> [1: bb3, 0: bb2, otherwise: bb7];\n    }\n    bb2: {\n        StorageLive(_8);\n        _8 = core::fmt::Arguments::<'_>::from_str(\"capacity overflow\") -> [return: bb5, unwind unreachable];\n    }\n    bb3: {\n        _6 = (((_3.1: core::option::Option<usize>) as variant#1).0: usize);\n        _2 = vec::Vec::<T>::with_capacity(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_10);\n        _10 = &mut _2;\n        StorageLive(_11);\n        _11 = move _1;\n        _9 = <vec::Vec<T> as vec::spec_extend::SpecExtend<T, I>>::spec_extend(move _10, move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        _7 = core::panicking::panic_fmt(move _8) -> unwind unreachable;\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _0 = move _2;\n        StorageDead(_2);\n        return;\n    }\n    bb7: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}