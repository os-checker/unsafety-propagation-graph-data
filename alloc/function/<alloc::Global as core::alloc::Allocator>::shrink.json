{
  "name": "<alloc::Global as core::alloc::Allocator>::shrink",
  "safe": false,
  "callees": {
    "core::alloc::Layout::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum size in bytes for a memory block of this layout.\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "core::alloc::Layout::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum byte alignment for a memory block of this layout.\n\n The returned alignment is guaranteed to be a power of two.\n",
      "adt": {}
    },
    "core::alloc::Allocator::deallocate": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Deallocates the memory referenced by `ptr`.\n\n # Safety\n\n * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n * `layout` must [*fit*] that block of memory.\n\n [*currently allocated*]: #currently-allocated-memory\n [*fit*]: #memory-fitting\n",
      "adt": {}
    },
    "core::alloc::Layout::dangling": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `NonNull` that is dangling, but well-aligned for this Layout.\n\n Note that the address of the returned pointer may potentially\n be that of a valid pointer, which means this must not be used\n as a \"not yet initialized\" sentinel value.\n Types that lazily allocate must track initialization by some other means.\n",
      "adt": {}
    },
    "core::ptr::NonNull::<[T]>::slice_from_raw_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-null raw slice from a thin pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n This function is safe, but dereferencing the return value is unsafe.\n See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n\n # Examples\n\n ```rust\n use std::ptr::NonNull;\n\n // create a slice pointer when starting out with a pointer to the first element\n let mut x = [5, 6, 7];\n let nonnull_pointer = NonNull::new(x.as_mut_ptr()).unwrap();\n let slice = NonNull::slice_from_raw_parts(nonnull_pointer, 3);\n assert_eq!(unsafe { slice.as_ref()[2] }, 7);\n ```\n\n (Note that this example artificially demonstrates a use of this method,\n but `let slice = NonNull::from(&x[..]);` would be a better way to write code like this.)\n",
      "adt": {}
    },
    "core::alloc::Allocator::allocate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to allocate a block of memory.\n\n On success, returns a [`NonNull<[u8]>`][NonNull] meeting the size and alignment guarantees of `layout`.\n\n The returned block may have a larger size than specified by `layout.size()`, and may or may\n not have its contents initialized.\n\n The returned block of memory remains valid as long as it is [*currently allocated*] and the shorter of:\n   - the borrow-checker lifetime of the allocator type itself.\n   - as long as the allocator and all its clones have not been dropped.\n\n [*currently allocated*]: #currently-allocated-memory\n\n # Errors\n\n Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n allocator's size or alignment constraints.\n\n Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an allocation error are encouraged to\n call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "core::hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "alloc::realloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reallocates memory with the global allocator.\n\n This function forwards calls to the [`GlobalAlloc::realloc`] method\n of the allocator registered with the `#[global_allocator]` attribute\n if there is one, or the `std` crateâ€™s default.\n\n This function is expected to be deprecated in favor of the `grow` and `shrink` methods\n of the [`Global`] type when it and the [`Allocator`] trait become stable.\n\n # Safety\n\n See [`GlobalAlloc::realloc`].\n",
      "adt": {
        "core::alloc::Layout": "ImmutableAsArgument"
      }
    },
    "core::ptr::NonNull::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull` if `ptr` is non-null.\n\n # Panics during const evaluation\n\n This method will panic during const evaluation if the pointer cannot be\n determined to be null or not. See [`is_null`] for more information.\n\n [`is_null`]: ../primitive.pointer.html#method.is_null-1\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::<u32>::new(&mut x as *mut _).expect(\"ptr is null!\");\n\n if let Some(ptr) = NonNull::<u32>::new(std::ptr::null_mut()) {\n     unreachable!();\n }\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::ok_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err)`].\n\n Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n result of a function call, it is recommended to use [`ok_or_else`], which is\n lazily evaluated.\n\n [`Ok(v)`]: Ok\n [`Err(err)`]: Err\n [`Some(v)`]: Some\n [`ok_or_else`]: Option::ok_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.ok_or(0), Ok(\"foo\"));\n\n let x: Option<&str> = None;\n assert_eq!(x.ok_or(0), Err(0));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<[T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n # Examples\n\n ```rust\n #![feature(slice_ptr_get)]\n use std::ptr::NonNull;\n\n let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n assert_eq!(slice.as_mut_ptr(), NonNull::<i8>::dangling().as_ptr());\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "alloc::Global": [
      "Ref"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 102, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 93, kind: RigidTy(Uint(U8)) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 188, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 195, kind: RigidTy(Slice(Ty { id: 93, kind: RigidTy(Uint(U8)) })) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<alloc::Global as core::alloc::Allocator>::shrink"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:302:5: 342:6",
  "src": "unsafe fn shrink(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        debug_assert!(\n            new_layout.size() <= old_layout.size(),\n            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n        );\n\n        match new_layout.size() {\n            // SAFETY: conditions must be upheld by the caller\n            0 => unsafe {\n                self.deallocate(ptr, old_layout);\n                Ok(NonNull::slice_from_raw_parts(new_layout.dangling(), 0))\n            },\n\n            // SAFETY: `new_size` is non-zero. Other conditions must be upheld by the caller\n            new_size if old_layout.align() == new_layout.align() => unsafe {\n                // `realloc` probably checks for `new_size <= old_layout.size()` or something similar.\n                hint::assert_unchecked(new_size <= old_layout.size());\n\n                let raw_ptr = realloc(ptr.as_ptr(), old_layout, new_size);\n                let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;\n                Ok(NonNull::slice_from_raw_parts(ptr, new_size))\n            },\n\n            // SAFETY: because `new_size` must be smaller than or equal to `old_layout.size()`,\n            // both the old and new memory allocation are valid for reads and writes for `new_size`\n            // bytes. Also, because the old allocation wasn't yet deallocated, it cannot overlap\n            // `new_ptr`. Thus, the call to `copy_nonoverlapping` is safe. The safety contract\n            // for `dealloc` must be upheld by the caller.\n            new_size => unsafe {\n                let new_ptr = self.allocate(new_layout)?;\n                ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_size);\n                self.deallocate(ptr, old_layout);\n                Ok(new_ptr)\n            },\n        }\n    }",
  "mir": "fn <alloc::Global as core::alloc::Allocator>::shrink(_1: &alloc::Global, _2: core::ptr::NonNull<u8>, _3: core::alloc::Layout, _4: core::alloc::Layout) -> core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError> {\n    let mut _0: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: &core::alloc::Layout;\n    let mut _8: usize;\n    let mut _9: &core::alloc::Layout;\n    let  _10: !;\n    let mut _11: core::fmt::Arguments<'_>;\n    let mut _12: usize;\n    let mut _13: &core::alloc::Layout;\n    let  _14: ();\n    let mut _15: core::ptr::NonNull<[u8]>;\n    let mut _16: core::ptr::NonNull<u8>;\n    let mut _17: &core::alloc::Layout;\n    let  _18: &usize;\n    let mut _19: bool;\n    let mut _20: usize;\n    let mut _21: &core::alloc::Layout;\n    let mut _22: usize;\n    let mut _23: &core::alloc::Layout;\n    let  _24: ();\n    let mut _25: bool;\n    let mut _26: usize;\n    let mut _27: &core::alloc::Layout;\n    let  _28: *mut u8;\n    let mut _29: *mut u8;\n    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::alloc::AllocError>, core::ptr::NonNull<u8>>;\n    let mut _31: core::result::Result<core::ptr::NonNull<u8>, core::alloc::AllocError>;\n    let mut _32: core::option::Option<core::ptr::NonNull<u8>>;\n    let mut _33: isize;\n    let  _34: core::ptr::NonNull<u8>;\n    let mut _35: core::ptr::NonNull<[u8]>;\n    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::alloc::AllocError>, core::ptr::NonNull<[u8]>>;\n    let mut _37: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _38: isize;\n    let  _39: core::ptr::NonNull<[u8]>;\n    let  _40: ();\n    let mut _41: *const u8;\n    let mut _42: *mut u8;\n    let mut _43: *mut u8;\n    let  _44: ();\n    debug self => _1;\n    debug ptr => _2;\n    debug old_layout => _3;\n    debug new_layout => _4;\n    debug new_size => _12;\n    debug new_size => _18;\n    debug raw_ptr => _28;\n    debug ptr => _34;\n    debug residual => core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError);\n    debug val => _34;\n    debug new_size => _12;\n    debug new_ptr => _39;\n    debug residual => core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError);\n    debug val => _39;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_4;\n        _6 = core::alloc::Layout::size(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_3;\n        _8 = core::alloc::Layout::size(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        _5 = Le(move _6, move _8);\n        switchInt(move _5) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_13);\n        _13 = &_4;\n        _12 = core::alloc::Layout::size(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_11);\n        _11 = core::fmt::Arguments::<'_>::from_str(\"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\") -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = core::panicking::panic_fmt(move _11) -> unwind unreachable;\n    }\n    bb6: {\n        StorageDead(_13);\n        switchInt(_12) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_18);\n        _18 = &_12;\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_3;\n        _20 = core::alloc::Layout::align(move _21) -> [return: bb12, unwind unreachable];\n    }\n    bb8: {\n        _14 = <alloc::Global as core::alloc::Allocator>::deallocate(_1, _2, _3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_4;\n        _16 = core::alloc::Layout::dangling(move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        _15 = core::ptr::NonNull::<[u8]>::slice_from_raw_parts(move _16, 0_usize) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        _0 = core::result::Result::Ok(move _15);\n        StorageDead(_15);\n        goto -> bb37;\n    }\n    bb12: {\n        StorageDead(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_4;\n        _22 = core::alloc::Layout::align(move _23) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_23);\n        _19 = Eq(move _20, move _22);\n        switchInt(move _19) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &_3;\n        _26 = core::alloc::Layout::size(move _27) -> [return: bb16, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = <alloc::Global as core::alloc::Allocator>::allocate(_1, _4) -> [return: bb28, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_27);\n        _25 = Le(_12, move _26);\n        StorageDead(_26);\n        _24 = core::hint::assert_unchecked(move _25) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_25);\n        StorageLive(_29);\n        _29 = core::ptr::NonNull::<u8>::as_ptr(_2) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _28 = alloc::realloc(move _29, _3, _12) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = core::ptr::NonNull::<u8>::new(_28) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _31 = core::option::Option::<core::ptr::NonNull<u8>>::ok_or::<core::alloc::AllocError>(move _32, core::alloc::AllocError) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_32);\n        _30 = <core::result::Result<core::ptr::NonNull<u8>, core::alloc::AllocError> as core::ops::Try>::branch(move _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_31);\n        _33 = discriminant(_30);\n        switchInt(move _33) -> [0: bb24, 1: bb25, otherwise: bb23];\n    }\n    bb23: {\n        unreachable;\n    }\n    bb24: {\n        _34 = ((_30 as variant#0).0: core::ptr::NonNull<u8>);\n        StorageDead(_30);\n        StorageLive(_35);\n        _35 = core::ptr::NonNull::<[u8]>::slice_from_raw_parts(_34, _12) -> [return: bb27, unwind unreachable];\n    }\n    bb25: {\n        _0 = <core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::alloc::AllocError>>>::from_residual(core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError)) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_30);\n        StorageDead(_18);\n        goto -> bb38;\n    }\n    bb27: {\n        _0 = core::result::Result::Ok(move _35);\n        StorageDead(_35);\n        StorageDead(_18);\n        goto -> bb37;\n    }\n    bb28: {\n        _36 = <core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError> as core::ops::Try>::branch(move _37) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_37);\n        _38 = discriminant(_36);\n        switchInt(move _38) -> [0: bb30, 1: bb31, otherwise: bb23];\n    }\n    bb30: {\n        _39 = ((_36 as variant#0).0: core::ptr::NonNull<[u8]>);\n        StorageDead(_36);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = core::ptr::NonNull::<u8>::as_ptr(_2) -> [return: bb33, unwind unreachable];\n    }\n    bb31: {\n        _0 = <core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::alloc::AllocError>>>::from_residual(core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError)) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_36);\n        goto -> bb38;\n    }\n    bb33: {\n        _41 = move _42 as *const u8;\n        StorageDead(_42);\n        StorageLive(_43);\n        _43 = core::ptr::NonNull::<[u8]>::as_mut_ptr(_39) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _40 = core::ptr::copy_nonoverlapping::<u8>(move _41, move _43, _12) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_43);\n        StorageDead(_41);\n        _44 = <alloc::Global as core::alloc::Allocator>::deallocate(_1, _2, _3) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _0 = core::result::Result::Ok(_39);\n        goto -> bb37;\n    }\n    bb37: {\n        goto -> bb39;\n    }\n    bb38: {\n        goto -> bb39;\n    }\n    bb39: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}