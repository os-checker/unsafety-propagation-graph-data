{
  "name": "collections::btree::merge_iter::MergeIterInner::<I>::nexts",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "collections::btree::merge_iter::Peeked::B": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "collections::btree::merge_iter::Peeked::A": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4015, kind: RigidTy(Adt(AdtDef(DefId { id: 3991, name: \"collections::btree::merge_iter::Peeked\" }), GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4015, kind: RigidTy(Adt(AdtDef(DefId { id: 3991, name: \"collections::btree::merge_iter::Peeked\" }), GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 768, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2857, name: \"core::iter::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4015, kind: RigidTy(Adt(AdtDef(DefId { id: 3991, name: \"collections::btree::merge_iter::Peeked\" }), GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 768, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2857, name: \"core::iter::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])",
      "Ref",
      "Unknown([Field(0, Ty { id: 4022, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 763, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 768, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2857, name: \"core::iter::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })]))) }, Not)) })])",
      "Deref",
      "Unknown([Field(1, Ty { id: 4022, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 763, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 768, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2857, name: \"core::iter::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })]))) }, Not)) })])",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 768, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2857, name: \"core::iter::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])"
    ],
    "collections::btree::merge_iter::MergeIterInner": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::cmp::Ordering": [
      "Plain"
    ]
  },
  "path": 795,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/merge_iter.rs:54:5: 85:6",
  "src": "pub(super) fn nexts<Cmp: Fn(&I::Item, &I::Item) -> Ordering>(\n        &mut self,\n        cmp: Cmp,\n    ) -> (Option<I::Item>, Option<I::Item>)\n    where\n        I: FusedIterator,\n    {\n        let mut a_next;\n        let mut b_next;\n        match self.peeked.take() {\n            Some(Peeked::A(next)) => {\n                a_next = Some(next);\n                b_next = self.b.next();\n            }\n            Some(Peeked::B(next)) => {\n                b_next = Some(next);\n                a_next = self.a.next();\n            }\n            None => {\n                a_next = self.a.next();\n                b_next = self.b.next();\n            }\n        }\n        if let (Some(a1), Some(b1)) = (&a_next, &b_next) {\n            match cmp(a1, b1) {\n                Ordering::Less => self.peeked = b_next.take().map(Peeked::B),\n                Ordering::Greater => self.peeked = a_next.take().map(Peeked::A),\n                Ordering::Equal => (),\n            }\n        }\n        (a_next, b_next)\n    }",
  "mir": "fn collections::btree::merge_iter::MergeIterInner::<I>::nexts(_1: &mut collections::btree::merge_iter::MergeIterInner<I>, _2: Cmp) -> (core::option::Option<<I as core::iter::Iterator>::Item>, core::option::Option<<I as core::iter::Iterator>::Item>) {\n    let mut _0: (core::option::Option<<I as core::iter::Iterator>::Item>, core::option::Option<<I as core::iter::Iterator>::Item>);\n    let mut _3: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _4: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _5: core::option::Option<collections::btree::merge_iter::Peeked<I>>;\n    let mut _6: &mut core::option::Option<collections::btree::merge_iter::Peeked<I>>;\n    let mut _7: isize;\n    let mut _8: isize;\n    let  _9: <I as core::iter::Iterator>::Item;\n    let mut _10: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _11: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _12: &mut I;\n    let  _13: <I as core::iter::Iterator>::Item;\n    let mut _14: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _15: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _16: &mut I;\n    let mut _17: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _18: &mut I;\n    let mut _19: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _20: &mut I;\n    let mut _21: (&core::option::Option<<I as core::iter::Iterator>::Item>, &core::option::Option<<I as core::iter::Iterator>::Item>);\n    let mut _22: &core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _23: &core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _24: isize;\n    let mut _25: isize;\n    let  _26: &<I as core::iter::Iterator>::Item;\n    let  _27: &<I as core::iter::Iterator>::Item;\n    let mut _28: core::cmp::Ordering;\n    let mut _29: &Cmp;\n    let mut _30: (&<I as core::iter::Iterator>::Item, &<I as core::iter::Iterator>::Item);\n    let mut _31: i8;\n    let mut _32: core::option::Option<collections::btree::merge_iter::Peeked<I>>;\n    let mut _33: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _34: &mut core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _35: core::option::Option<collections::btree::merge_iter::Peeked<I>>;\n    let mut _36: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _37: &mut core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _38: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _39: core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _40: &core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _41: &core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _42: &core::option::Option<<I as core::iter::Iterator>::Item>;\n    let mut _43: &core::option::Option<<I as core::iter::Iterator>::Item>;\n    debug self => _1;\n    debug cmp => _2;\n    debug a_next => _3;\n    debug b_next => _4;\n    debug next => _9;\n    debug next => _13;\n    debug a1 => _26;\n    debug b1 => _27;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut ((*_1).2: core::option::Option<collections::btree::merge_iter::Peeked<I>>);\n        _5 = core::option::Option::<collections::btree::merge_iter::Peeked<I>>::take(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _7 = discriminant(((_5 as variant#1).0: collections::btree::merge_iter::Peeked<I>));\n        switchInt(move _7) -> [0: bb6, 1: bb5, otherwise: bb2];\n    }\n    bb4: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &mut ((*_1).0: I);\n        _17 = <I as core::iter::Iterator>::next(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb5: {\n        _13 = move ((((_5 as variant#1).0: collections::btree::merge_iter::Peeked<I>) as variant#1).0: <I as core::iter::Iterator>::Item);\n        StorageLive(_14);\n        _14 = core::option::Option::Some(_13);\n        _4 = move _14;\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut ((*_1).0: I);\n        _15 = <I as core::iter::Iterator>::next(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _9 = move ((((_5 as variant#1).0: collections::btree::merge_iter::Peeked<I>) as variant#0).0: <I as core::iter::Iterator>::Item);\n        StorageLive(_10);\n        _10 = core::option::Option::Some(_9);\n        _3 = move _10;\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut ((*_1).1: I);\n        _11 = <I as core::iter::Iterator>::next(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _4 = move _11;\n        StorageDead(_11);\n        goto -> bb11;\n    }\n    bb8: {\n        StorageDead(_16);\n        _3 = move _15;\n        StorageDead(_15);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageDead(_18);\n        _3 = move _17;\n        StorageDead(_17);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &mut ((*_1).1: I);\n        _19 = <I as core::iter::Iterator>::next(move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        _4 = move _19;\n        StorageDead(_19);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_5);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_3;\n        StorageLive(_23);\n        _23 = &_4;\n        _21 = (move _22, move _23);\n        StorageDead(_23);\n        StorageDead(_22);\n        _40 = (_21.0: &core::option::Option<<I as core::iter::Iterator>::Item>);\n        _25 = discriminant((*_40));\n        switchInt(move _25) -> [1: bb12, 0: bb24, otherwise: bb2];\n    }\n    bb12: {\n        _41 = (_21.1: &core::option::Option<<I as core::iter::Iterator>::Item>);\n        _24 = discriminant((*_41));\n        switchInt(move _24) -> [1: bb13, 0: bb24, otherwise: bb2];\n    }\n    bb13: {\n        _42 = (_21.0: &core::option::Option<<I as core::iter::Iterator>::Item>);\n        _26 = &(((*_42) as variant#1).0: <I as core::iter::Iterator>::Item);\n        _43 = (_21.1: &core::option::Option<<I as core::iter::Iterator>::Item>);\n        _27 = &(((*_43) as variant#1).0: <I as core::iter::Iterator>::Item);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &_2;\n        StorageLive(_30);\n        _30 = (_26, _27);\n        _28 = <Cmp as core::ops::Fn<(&<I as core::iter::Iterator>::Item, &<I as core::iter::Iterator>::Item)>>::call(move _29, move _30) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_30);\n        StorageDead(_29);\n        _31 = discriminant(_28);\n        switchInt(move _31) -> [255: bb16, 0: bb23, 1: bb15, otherwise: bb2];\n    }\n    bb15: {\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &mut _3;\n        _36 = core::option::Option::<<I as core::iter::Iterator>::Item>::take(move _37) -> [return: bb20, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _4;\n        _33 = core::option::Option::<<I as core::iter::Iterator>::Item>::take(move _34) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_34);\n        _32 = core::option::Option::<<I as core::iter::Iterator>::Item>::map::<collections::btree::merge_iter::Peeked<I>, fn(<I as core::iter::Iterator>::Item) -> collections::btree::merge_iter::Peeked<I> {collections::btree::merge_iter::Peeked::<I>::B}>(move _33, collections::btree::merge_iter::Peeked::<I>::B) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_33);\n        drop(((*_1).2: core::option::Option<collections::btree::merge_iter::Peeked<I>>)) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        ((*_1).2: core::option::Option<collections::btree::merge_iter::Peeked<I>>) = move _32;\n        StorageDead(_32);\n        goto -> bb23;\n    }\n    bb20: {\n        StorageDead(_37);\n        _35 = core::option::Option::<<I as core::iter::Iterator>::Item>::map::<collections::btree::merge_iter::Peeked<I>, fn(<I as core::iter::Iterator>::Item) -> collections::btree::merge_iter::Peeked<I> {collections::btree::merge_iter::Peeked::<I>::A}>(move _36, collections::btree::merge_iter::Peeked::<I>::A) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_36);\n        drop(((*_1).2: core::option::Option<collections::btree::merge_iter::Peeked<I>>)) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        ((*_1).2: core::option::Option<collections::btree::merge_iter::Peeked<I>>) = move _35;\n        StorageDead(_35);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_28);\n        StorageDead(_21);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_21);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_38);\n        _38 = move _3;\n        StorageLive(_39);\n        _39 = move _4;\n        _0 = (move _38, move _39);\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_4);\n        StorageDead(_3);\n        drop(_2) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        return;\n    }\n}\n",
  "doc": " Returns the next pair of items stemming from the pair of sources\n being merged. If both returned options contain a value, that value\n is equal and occurs in both sources. If one of the returned options\n contains a value, that value doesn't occur in the other source (or\n the sources are not strictly ascending). If neither returned option\n contains a value, iteration has finished and subsequent calls will\n return the same empty pair.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}