{
  "name": "vec::Vec::<T, A>::extract_if",
  "safe": true,
  "callees": {
    "vec::extract_if::ExtractIf::<'a, T, F, A>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "vec::Vec": "MutableAsArgument",
        "vec::extract_if::ExtractIf": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "MutRef"
    ],
    "vec::extract_if::ExtractIf": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::vec::Vec::<T, A>::extract_if"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:4007:5: 4013:6",
  "src": "pub fn extract_if<F, R>(&mut self, range: R, filter: F) -> ExtractIf<'_, T, F, A>\n    where\n        F: FnMut(&mut T) -> bool,\n        R: RangeBounds<usize>,\n    {\n        ExtractIf::new(self, filter, range)\n    }",
  "mir": "fn vec::Vec::<T, A>::extract_if(_1: &mut vec::Vec<T, A>, _2: R, _3: F) -> vec::extract_if::ExtractIf<'_, T, F, A> {\n    let mut _0: vec::extract_if::ExtractIf<'_, T, F, A>;\n    debug self => _1;\n    debug range => _2;\n    debug filter => _3;\n    bb0: {\n        _0 = vec::extract_if::ExtractIf::<'_, T, F, A>::new::<R>(_1, _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Creates an iterator which uses a closure to determine if an element in the range should be removed.\n\n If the closure returns `true`, the element is removed from the vector\n and yielded. If the closure returns `false`, or panics, the element\n remains in the vector and will not be yielded.\n\n Only elements that fall in the provided range are considered for extraction, but any elements\n after the range will still have to be moved if any element has been extracted.\n\n If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n or the iteration short-circuits, then the remaining elements will be retained.\n Use `extract_if().for_each(drop)` if you do not need the returned iterator,\n or [`retain_mut`] with a negated predicate if you also do not need to restrict the range.\n\n [`retain_mut`]: Vec::retain_mut\n\n Using this method is equivalent to the following code:\n\n ```\n # let some_predicate = |x: &mut i32| { *x % 2 == 1 };\n # let mut vec = vec![0, 1, 2, 3, 4, 5, 6];\n # let mut vec2 = vec.clone();\n # let range = 1..5;\n let mut i = range.start;\n let end_items = vec.len() - range.end;\n # let mut extracted = vec![];\n\n while i < vec.len() - end_items {\n     if some_predicate(&mut vec[i]) {\n         let val = vec.remove(i);\n         // your code here\n #         extracted.push(val);\n     } else {\n         i += 1;\n     }\n }\n\n # let extracted2: Vec<_> = vec2.extract_if(range, some_predicate).collect();\n # assert_eq!(vec, vec2);\n # assert_eq!(extracted, extracted2);\n ```\n\n But `extract_if` is easier to use. `extract_if` is also more efficient,\n because it can backshift the elements of the array in bulk.\n\n The iterator also lets you mutate the value of each element in the\n closure, regardless of whether you choose to keep or remove it.\n\n # Panics\n\n If `range` is out of bounds.\n\n # Examples\n\n Splitting a vector into even and odd values, reusing the original vector:\n\n ```\n let mut numbers = vec![1, 2, 3, 4, 5, 6, 8, 9, 11, 13, 14, 15];\n\n let evens = numbers.extract_if(.., |x| *x % 2 == 0).collect::<Vec<_>>();\n let odds = numbers;\n\n assert_eq!(evens, vec![2, 4, 6, 8, 14]);\n assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n ```\n\n Using the range argument to only process a part of the vector:\n\n ```\n let mut items = vec![0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 1, 2];\n let ones = items.extract_if(7.., |x| *x == 1).collect::<Vec<_>>();\n assert_eq!(items, vec![0, 0, 0, 0, 0, 0, 0, 2, 2, 2]);\n assert_eq!(ones.len(), 3);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}