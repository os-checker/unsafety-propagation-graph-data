{
  "name": "rc::Rc::<T, A>::try_clone_from_ref_in",
  "safe": true,
  "callees": {
    "rc::UniqueRcUninit::<T, A>::try_new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a RcInner with layout suitable to contain `for_value` or a clone of it,\n returning an error if allocation fails.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "rc::UniqueRcUninit": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "rc::UniqueRcUninit::<T, A>::data_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the pointer to be written into to initialize the [`Rc`].\n",
      "adt": {
        "rc::UniqueRcUninit": "MutableAsArgument"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::clone::CloneToUninit::clone_to_uninit": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs copy-assignment from `self` to `dest`.\n\n This is analogous to `std::ptr::write(dest.cast(), self.clone())`,\n except that `Self` may be a dynamically-sized type ([`!Sized`](Sized)).\n\n Before this function is called, `dest` may point to uninitialized memory.\n After this function is called, `dest` will point to initialized memory; it will be\n sound to create a `&Self` reference from the pointer with the [pointer metadata]\n from `self`.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dest` must be [valid] for writes for `size_of_val(self)` bytes.\n * `dest` must be properly aligned to `align_of_val(self)`.\n\n [valid]: crate::ptr#safety\n [pointer metadata]: crate::ptr::metadata()\n\n # Panics\n\n This function may panic. (For example, it might panic if memory allocation for a clone\n of a value owned by `self` fails.)\n If the call panics, then `*dest` should be treated as uninitialized memory; it must not be\n read or dropped, because even if it was previously valid, it may have been partially\n overwritten.\n\n The caller may wish to take care to deallocate the allocation pointed to by `dest`,\n if applicable, to avoid a memory leak (but this is not a requirement).\n\n Implementors should avoid leaking values by, upon unwinding, dropping all component values\n that might have already been created. (For example, if a `[Foo]` of length 3 is being\n cloned, and the second of the three calls to `Foo::clone()` unwinds, then the first `Foo`\n cloned should be dropped.)\n",
      "adt": {}
    },
    "rc::UniqueRcUninit::<T, A>::into_rc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Upgrade this into a normal [`Rc`].\n\n # Safety\n\n The data must have been initialized (by writing to [`Self::data_ptr()`]).\n",
      "adt": {
        "rc::UniqueRcUninit": "MutableAsArgument",
        "rc::Rc": "Constructor"
      }
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7731, kind: RigidTy(Adt(AdtDef(DefId { id: 5091, name: \"rc::UniqueRcUninit\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }), Type(Ty { id: 21, kind: Param(ParamTy { index: 1, name: \"A\" }) })]))) })])"
    ],
    "rc::UniqueRcUninit": [
      "Plain",
      "MutRef"
    ],
    "rc::Rc": [
      "Plain"
    ]
  },
  "path": 1781,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:1375:5: 1388:6",
  "src": "pub fn try_clone_from_ref_in(value: &T, alloc: A) -> Result<Rc<T, A>, AllocError> {\n        // `in_progress` drops the allocation if we panic before finishing initializing it.\n        let mut in_progress: UniqueRcUninit<T, A> = UniqueRcUninit::try_new(value, alloc)?;\n\n        // Initialize with clone of value.\n        let initialized_clone = unsafe {\n            // Clone. If the clone panics, `in_progress` will be dropped and clean up.\n            value.clone_to_uninit(in_progress.data_ptr().cast());\n            // Cast type of pointer, now that it is initialized.\n            in_progress.into_rc()\n        };\n\n        Ok(initialized_clone)\n    }",
  "mir": "fn rc::Rc::<T, A>::try_clone_from_ref_in(_1: &T, _2: A) -> core::result::Result<rc::Rc<T, A>, core::alloc::AllocError> {\n    let mut _0: core::result::Result<rc::Rc<T, A>, core::alloc::AllocError>;\n    let mut _3: rc::UniqueRcUninit<T, A>;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::alloc::AllocError>, rc::UniqueRcUninit<T, A>>;\n    let mut _5: core::result::Result<rc::UniqueRcUninit<T, A>, core::alloc::AllocError>;\n    let mut _6: isize;\n    let  _7: rc::UniqueRcUninit<T, A>;\n    let  _8: rc::Rc<T, A>;\n    let  _9: ();\n    let mut _10: *mut u8;\n    let mut _11: *mut T;\n    let mut _12: &mut rc::UniqueRcUninit<T, A>;\n    let mut _13: rc::UniqueRcUninit<T, A>;\n    debug value => _1;\n    debug alloc => _2;\n    debug in_progress => _3;\n    debug residual => core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError);\n    debug val => _7;\n    debug initialized_clone => _8;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = rc::UniqueRcUninit::<T, A>::try_new(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <core::result::Result<rc::UniqueRcUninit<T, A>, core::alloc::AllocError> as core::ops::Try>::branch(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = move ((_4 as variant#0).0: rc::UniqueRcUninit<T, A>);\n        _3 = move _7;\n        StorageDead(_7);\n        StorageDead(_4);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut _3;\n        _11 = rc::UniqueRcUninit::<T, A>::data_ptr(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::result::Result<rc::Rc<T, A>, core::alloc::AllocError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::alloc::AllocError>>>::from_residual(core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError)) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb11;\n    }\n    bb7: {\n        StorageDead(_12);\n        _10 = core::ptr::mut_ptr::<impl *mut T>::cast::<u8>(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _9 = <T as core::clone::CloneToUninit>::clone_to_uninit(_1, move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageLive(_13);\n        _13 = move _3;\n        _8 = rc::UniqueRcUninit::<T, A>::into_rc(move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        _0 = core::result::Result::Ok(_8);\n        StorageDead(_3);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Constructs a new `Rc<T>` with a clone of `value` in the provided allocator, returning an error if allocation fails\n\n # Examples\n\n ```\n #![feature(clone_from_ref)]\n #![feature(allocator_api)]\n use std::rc::Rc;\n use std::alloc::System;\n\n let hello: Rc<str, System> = Rc::try_clone_from_ref_in(\"hello\", System)?;\n # Ok::<(), std::alloc::AllocError>(())\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}