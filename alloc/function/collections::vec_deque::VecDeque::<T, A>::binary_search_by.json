{
  "name": "collections::vec_deque::VecDeque::<T, A>::binary_search_by",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::first": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the first element of the slice, or `None` if it is empty.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&10), v.first());\n\n let w: &[i32] = &[];\n assert_eq!(None, w.first());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::binary_search_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Binary searches this slice with a comparator function.\n\n The comparator function should return an order code that indicates\n whether its argument is `Less`, `Equal` or `Greater` the desired\n target.\n If the slice is not sorted or if the comparator function does not\n implement an order consistent with the sort order of the underlying\n slice, the returned result is unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search`]: slice::binary_search\n [`binary_search_by_key`]: slice::binary_search_by_key\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n let seek = 13;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n let seek = 4;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n let seek = 100;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n let seek = 1;\n let r = s.binary_search_by(|probe| probe.cmp(&seek));\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 466, kind: RigidTy(Adt(AdtDef(DefId { id: 2767, name: \"core::cmp::Ordering\" }), GenericArgs([]))) })])"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::binary_search_by"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3097:5: 3111:6",
  "src": "pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        let (front, back) = self.as_slices();\n        let cmp_back = back.first().map(|elem| f(elem));\n\n        if let Some(Ordering::Equal) = cmp_back {\n            Ok(front.len())\n        } else if let Some(Ordering::Less) = cmp_back {\n            back.binary_search_by(f).map(|idx| idx + front.len()).map_err(|idx| idx + front.len())\n        } else {\n            front.binary_search_by(f)\n        }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::binary_search_by(_1: &collections::vec_deque::VecDeque<T, A>, _2: F) -> core::result::Result<usize, usize> {\n    let mut _0: core::result::Result<usize, usize>;\n    let  _3: &[T];\n    let  _4: &[T];\n    let mut _5: (&[T], &[T]);\n    let  _6: core::option::Option<core::cmp::Ordering>;\n    let mut _7: core::option::Option<&T>;\n    let mut _8: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3102:41: 3102:47};\n    let mut _9: &mut F;\n    let mut _10: i8;\n    let mut _11: isize;\n    let mut _12: usize;\n    let mut _13: i8;\n    let mut _14: isize;\n    let mut _15: core::result::Result<usize, usize>;\n    let mut _16: core::result::Result<usize, usize>;\n    let mut _17: F;\n    let mut _18: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3107:42: 3107:47};\n    let mut _19: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3107:75: 3107:80};\n    let mut _20: F;\n    let mut _21: bool;\n    debug self => _1;\n    debug f => _2;\n    debug front => _3;\n    debug back => _4;\n    debug cmp_back => _6;\n    bb0: {\n        _21 = false;\n        _21 = true;\n        StorageLive(_5);\n        _5 = collections::vec_deque::VecDeque::<T, A>::as_slices(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = (_5.0: &[T]);\n        _4 = (_5.1: &[T]);\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::slice::<impl [T]>::first(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &mut _2;\n        _8 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3102:41: 3102:47}(move _9);\n        StorageDead(_9);\n        _6 = core::option::Option::<&T>::map::<core::cmp::Ordering, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3102:41: 3102:47}>(move _7, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _11 = discriminant(_6);\n        switchInt(move _11) -> [1: bb4, 0: bb6, otherwise: bb17];\n    }\n    bb4: {\n        _10 = discriminant(((_6 as variant#1).0: core::cmp::Ordering));\n        switchInt(move _10) -> [0: bb5, otherwise: bb6];\n    }\n    bb5: {\n        StorageLive(_12);\n        _12 = PtrMetadata(_3);\n        _0 = core::result::Result::Ok(move _12);\n        StorageDead(_12);\n        goto -> bb14;\n    }\n    bb6: {\n        _14 = discriminant(_6);\n        switchInt(move _14) -> [1: bb7, 0: bb12, otherwise: bb17];\n    }\n    bb7: {\n        _13 = discriminant(((_6 as variant#1).0: core::cmp::Ordering));\n        switchInt(move _13) -> [255: bb8, otherwise: bb12];\n    }\n    bb8: {\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _21 = false;\n        _17 = move _2;\n        _16 = core::slice::<impl [T]>::binary_search_by::<'_, F>(_4, move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageLive(_18);\n        _18 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3107:42: 3107:47}(_3);\n        _15 = core::result::Result::<usize, usize>::map::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3107:42: 3107:47}>(move _16, move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageLive(_19);\n        _19 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3107:75: 3107:80}(_3);\n        _0 = core::result::Result::<usize, usize>::map_err::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3107:75: 3107:80}>(move _15, move _19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageDead(_15);\n        goto -> bb14;\n    }\n    bb12: {\n        StorageLive(_20);\n        _21 = false;\n        _20 = move _2;\n        _0 = core::slice::<impl [T]>::binary_search_by::<'_, F>(_3, move _20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_20);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_6);\n        switchInt(_21) -> [0: bb15, otherwise: bb16];\n    }\n    bb15: {\n        return;\n    }\n    bb16: {\n        drop(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb17: {\n        unreachable;\n    }\n}\n",
  "doc": " Binary searches this `VecDeque` with a comparator function.\n\n The comparator function should return an order code that indicates\n whether its argument is `Less`, `Equal` or `Greater` the desired\n target.\n If the `VecDeque` is not sorted or if the comparator function does not\n implement an order consistent with the sort order of the underlying\n `VecDeque`, the returned result is unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. If the value is not found then\n [`Result::Err`] is returned, containing the index where a matching\n element could be inserted while maintaining sorted order.\n\n See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search`]: VecDeque::binary_search\n [`binary_search_by_key`]: VecDeque::binary_search_by_key\n [`partition_point`]: VecDeque::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n use std::collections::VecDeque;\n\n let deque: VecDeque<_> = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n\n assert_eq!(deque.binary_search_by(|x| x.cmp(&13)),  Ok(9));\n assert_eq!(deque.binary_search_by(|x| x.cmp(&4)),   Err(7));\n assert_eq!(deque.binary_search_by(|x| x.cmp(&100)), Err(13));\n let r = deque.binary_search_by(|x| x.cmp(&1));\n assert!(matches!(r, Ok(1..=4)));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}