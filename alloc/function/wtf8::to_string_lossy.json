{
  "name": "wtf8::to_string_lossy",
  "safe": true,
  "callees": {
    "core::wtf8::Wtf8::next_surrogate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::str::from_utf8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.\n\n This is an alias to [`str::from_utf8_unchecked`].\n\n See the safe version, [`from_utf8`], for more information.\n\n # Safety\n\n The bytes passed in must be valid UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = unsafe {\n     str::from_utf8_unchecked(&sparkle_heart)\n };\n\n assert_eq!(\"üíñ\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "core::wtf8::Wtf8::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Access raw bytes of WTF-8 data\n",
      "adt": {}
    },
    "core::wtf8::Wtf8::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length, in WTF-8 bytes.\n",
      "adt": {}
    },
    "vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::extend_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clones and appends all elements in a slice to the `Vec`.\n\n Iterates over the slice `other`, clones each element, and then appends\n it to this `Vec`. The `other` slice is traversed in-order.\n\n Note that this function is the same as [`extend`],\n except that it also works with slice elements that are Clone but not Copy.\n If Rust gets specialization this function may be deprecated.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.extend_from_slice(&[2, 3, 4]);\n assert_eq!(vec, [1, 2, 3, 4]);\n ```\n\n [`extend`]: Vec::extend\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "string::String::from_utf8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a vector of bytes to a `String` without checking that the\n string contains valid UTF-8.\n\n See the safe version, [`from_utf8`], for more details.\n\n [`from_utf8`]: String::from_utf8\n\n # Safety\n\n This function is unsafe because it does not check that the bytes passed\n to it are valid UTF-8. If this constraint is violated, it may cause\n memory unsafety issues with future users of the `String`, as the rest of\n the standard library assumes that `String`s are valid UTF-8.\n\n # Examples\n\n ```\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = unsafe {\n     String::from_utf8_unchecked(sparkle_heart)\n };\n\n assert_eq!(\"üíñ\", sparkle_heart);\n ```\n",
      "adt": {
        "string::String": "Constructor"
      }
    }
  },
  "adts": {
    "core::wtf8::Wtf8": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11028, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 1383, kind: RigidTy(Uint(U16)) }])) }), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "borrow::Cow": [
      "Plain"
    ],
    "vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "string::String": [
      "Plain"
    ]
  },
  "path": 2414,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/wtf8/mod.rs:465:1: 487:2",
  "src": "pub(super) fn to_string_lossy(slice: &Wtf8) -> Cow<'_, str> {\n    let Some((surrogate_pos, _)) = slice.next_surrogate(0) else {\n        return Cow::Borrowed(unsafe { str::from_utf8_unchecked(slice.as_bytes()) });\n    };\n    let wtf8_bytes = slice.as_bytes();\n    let mut utf8_bytes = Vec::with_capacity(slice.len());\n    utf8_bytes.extend_from_slice(&wtf8_bytes[..surrogate_pos]);\n    utf8_bytes.extend_from_slice(\"\\u{FFFD}\".as_bytes());\n    let mut pos = surrogate_pos + 3;\n    loop {\n        match slice.next_surrogate(pos) {\n            Some((surrogate_pos, _)) => {\n                utf8_bytes.extend_from_slice(&wtf8_bytes[pos..surrogate_pos]);\n                utf8_bytes.extend_from_slice(\"\\u{FFFD}\".as_bytes());\n                pos = surrogate_pos + 3;\n            }\n            None => {\n                utf8_bytes.extend_from_slice(&wtf8_bytes[pos..]);\n                return Cow::Owned(unsafe { String::from_utf8_unchecked(utf8_bytes) });\n            }\n        }\n    }\n}",
  "mir": "fn wtf8::to_string_lossy(_1: &core::wtf8::Wtf8) -> borrow::Cow<'_, str> {\n    let mut _0: borrow::Cow<'_, str>;\n    let  _2: &str;\n    let  _3: &[u8];\n    let  _4: usize;\n    let mut _5: core::option::Option<(usize, u16)>;\n    let mut _6: isize;\n    let  _7: &[u8];\n    let mut _8: vec::Vec<u8>;\n    let mut _9: usize;\n    let  _10: ();\n    let mut _11: &mut vec::Vec<u8>;\n    let  _12: &[u8];\n    let mut _13: core::ops::RangeTo<usize>;\n    let  _14: ();\n    let mut _15: &mut vec::Vec<u8>;\n    let  _16: &[u8];\n    let mut _17: &str;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let mut _20: core::option::Option<(usize, u16)>;\n    let mut _21: usize;\n    let mut _22: isize;\n    let  _23: usize;\n    let  _24: ();\n    let mut _25: &mut vec::Vec<u8>;\n    let  _26: &[u8];\n    let mut _27: core::ops::Range<usize>;\n    let mut _28: usize;\n    let  _29: ();\n    let mut _30: &mut vec::Vec<u8>;\n    let  _31: &[u8];\n    let mut _32: &str;\n    let mut _33: (usize, bool);\n    let  _34: ();\n    let mut _35: &mut vec::Vec<u8>;\n    let  _36: &[u8];\n    let mut _37: core::ops::RangeFrom<usize>;\n    let mut _38: usize;\n    let mut _39: string::String;\n    let mut _40: vec::Vec<u8>;\n    debug slice => _1;\n    debug surrogate_pos => _4;\n    debug wtf8_bytes => _7;\n    debug utf8_bytes => _8;\n    debug pos => _18;\n    debug surrogate_pos => _23;\n    bb0: {\n        StorageLive(_5);\n        _5 = core::wtf8::Wtf8::next_surrogate(_1, 0_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::str::from_utf8_unchecked(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = borrow::Cow::Borrowed(_2);\n        goto -> bb27;\n    }\n    bb3: {\n        _6 = discriminant(_5);\n        switchInt(move _6) -> [1: bb4, 0: bb5, otherwise: bb16];\n    }\n    bb4: {\n        _4 = (((_5 as variant#1).0: (usize, u16)).0: usize);\n        StorageDead(_5);\n        _7 = core::wtf8::Wtf8::as_bytes(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        _3 = core::wtf8::Wtf8::as_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::wtf8::Wtf8::len(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _8 = vec::Vec::<u8>::with_capacity(move _9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = &mut _8;\n        StorageLive(_13);\n        _13 = RangeTo(_4);\n        _12 = <[u8] as core::ops::Index<core::ops::RangeTo<usize>>>::index(_7, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _10 = vec::Vec::<u8>::extend_from_slice(move _11, _12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = &mut _8;\n        StorageLive(_17);\n        _17 = \"ÔøΩ\";\n        _16 = core::str::<impl str>::as_bytes(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        _14 = vec::Vec::<u8>::extend_from_slice(move _15, _16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageLive(_18);\n        _19 = CheckedAdd(_4, 3_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, 3_usize) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = move (_19.0: usize);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _18;\n        _20 = core::wtf8::Wtf8::next_surrogate(_1, move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        _22 = discriminant(_20);\n        switchInt(move _22) -> [0: bb17, 1: bb18, otherwise: bb16];\n    }\n    bb16: {\n        unreachable;\n    }\n    bb17: {\n        StorageLive(_35);\n        _35 = &mut _8;\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _18;\n        _37 = RangeFrom(move _38);\n        StorageDead(_38);\n        _36 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_7, move _37) -> [return: bb24, unwind unreachable];\n    }\n    bb18: {\n        _23 = (((_20 as variant#1).0: (usize, u16)).0: usize);\n        StorageLive(_25);\n        _25 = &mut _8;\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _18;\n        _27 = Range(move _28, _23);\n        StorageDead(_28);\n        _26 = <[u8] as core::ops::Index<core::ops::Range<usize>>>::index(_7, move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        _24 = vec::Vec::<u8>::extend_from_slice(move _25, _26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_25);\n        StorageLive(_30);\n        _30 = &mut _8;\n        StorageLive(_32);\n        _32 = \"ÔøΩ\";\n        _31 = core::str::<impl str>::as_bytes(move _32) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_32);\n        _29 = vec::Vec::<u8>::extend_from_slice(move _30, _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        _33 = CheckedAdd(_23, 3_usize);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _23, 3_usize) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _18 = move (_33.0: usize);\n        StorageDead(_20);\n        goto -> bb14;\n    }\n    bb24: {\n        StorageDead(_37);\n        _34 = vec::Vec::<u8>::extend_from_slice(move _35, _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = move _8;\n        _39 = string::String::from_utf8_unchecked(move _40) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_40);\n        _0 = borrow::Cow::Owned(move _39);\n        StorageDead(_39);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_8);\n        goto -> bb27;\n    }\n    bb27: {\n        return;\n    }\n}\n",
  "doc": " Lossily converts the string to UTF-8.\n Returns a UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n\n Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character ‚ÄúÔøΩ‚Äù).\n\n This only copies the data if necessary (if it contains any surrogate).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}