{
  "name": "boxed::Box::<T, A>::as_ptr",
  "safe": true,
  "callees": {},
  "adts": {
    "boxed::Box": [
      "Plain",
      "Deref",
      "Unknown([Field(0, Ty { id: 176, kind: RigidTy(Adt(AdtDef(DefId { id: 2645, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) }), Field(0, Ty { id: 101, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::boxed::Box::<T, A>::as_ptr"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:1763:5: 1767:6",
  "src": "pub fn as_ptr(b: &Self) -> *const T {\n        // This is a primitive deref, not going through `DerefMut`, and therefore not materializing\n        // any references.\n        &raw const **b\n    }",
  "mir": "fn boxed::Box::<T, A>::as_ptr(_1: &boxed::Box<T, A>) -> *const T {\n    let mut _0: *const T;\n    let mut _2: boxed::Box<T, A>;\n    debug b => _1;\n    bb0: {\n        _2 = (*_1);\n        _0 = ((_2.0: core::ptr::Unique<T>).0: core::ptr::NonNull<T>) as *const T;\n        return;\n    }\n}\n",
  "doc": " Returns a raw pointer to the `Box`'s contents.\n\n The caller must ensure that the `Box` outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the `Box`, use [`as_mut_ptr`].\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying memory, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`] and [`as_mut_ptr`].\n Note that calling other methods that materialize mutable references to the memory,\n as well as writing to this memory, may still invalidate this pointer.\n See the example below for how this guarantee can be used.\n\n # Examples\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n #![feature(box_as_ptr)]\n\n unsafe {\n     let mut v = Box::new(0);\n     let ptr1 = Box::as_ptr(&v);\n     let ptr2 = Box::as_mut_ptr(&mut v);\n     let _val = ptr2.read();\n     // No write to this memory has happened yet, so `ptr1` is still valid.\n     let _val = ptr1.read();\n     // However, once we do a write...\n     ptr2.write(1);\n     // ... `ptr1` is no longer valid.\n     // This would be UB: let _val = ptr1.read();\n }\n ```\n\n [`as_mut_ptr`]: Self::as_mut_ptr\n [`as_ptr`]: Self::as_ptr\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}