{
  "name": "raw_vec::RawVec::<T, A>::reserve_exact",
  "safe": true,
  "callees": {
    "raw_vec::RawVecInner::<A>::reserve_exact": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n - `elem_layout` must be valid for `self`, i.e. it must be the same `elem_layout` used to\n   initially construct `self`\n - `elem_layout`'s size must be a multiple of its alignment\n",
      "adt": {
        "raw_vec::RawVecInner": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "raw_vec::RawVecInner": [
      "MutRef"
    ],
    "raw_vec::RawVec": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 1648,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:367:5: 370:6",
  "src": "pub(crate) fn reserve_exact(&mut self, len: usize, additional: usize) {\n        // SAFETY: All calls on self.inner pass T::LAYOUT as the elem_layout\n        unsafe { self.inner.reserve_exact(len, additional, T::LAYOUT) }\n    }",
  "mir": "fn raw_vec::RawVec::<T, A>::reserve_exact(_1: &mut raw_vec::RawVec<T, A>, _2: usize, _3: usize) -> () {\n    let mut _0: ();\n    let mut _4: &mut raw_vec::RawVecInner<A>;\n    debug self => _1;\n    debug len => _2;\n    debug additional => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: raw_vec::RawVecInner<A>);\n        _0 = raw_vec::RawVecInner::<A>::reserve_exact(move _4, _2, _3, <T as core::mem::SizedTypeProperties>::LAYOUT) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Ensures that the buffer contains at least enough space to hold `len +\n additional` elements. If it doesn't already, will reallocate the\n minimum possible amount of memory necessary. Generally this will be\n exactly the amount of memory necessary, but in principle the allocator\n is free to give back more than we asked for.\n\n If `len` exceeds `self.capacity()`, this may fail to actually allocate\n the requested space. This is not really unsafe, but the unsafe code\n *you* write that relies on the behavior of this function may break.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Aborts\n\n Aborts on OOM.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}