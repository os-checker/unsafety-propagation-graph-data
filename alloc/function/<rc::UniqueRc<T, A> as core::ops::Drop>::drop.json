{
  "name": "<rc::UniqueRc<T, A> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a shared reference to the value. If the value may be uninitialized, [`as_uninit_ref`]\n must be used instead.\n\n For the mutable counterpart see [`as_mut`].\n\n [`as_uninit_ref`]: NonNull::as_uninit_ref\n [`as_mut`]: NonNull::as_mut\n\n # Safety\n\n When calling this method, you have to ensure that\n the pointer is [convertible to a reference](crate::ptr#pointer-to-reference-conversion).\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"ptr is null!\");\n\n let ref_x = unsafe { ptr.as_ref() };\n println!(\"{ref_x}\");\n ```\n\n [the module documentation]: crate::ptr#safety\n",
      "adt": {}
    },
    "rc::RcInnerPtr::dec_weak": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "rc::RcInnerPtr::weak": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::for_value_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Produces layout describing a record that could be used to\n allocate backing structure for `T` (which could be a trait\n or other unsized type like a slice).\n\n # Safety\n\n This function is only safe to call if the following conditions hold:\n\n - If `T` is `Sized`, this function is always safe to call.\n - If the unsized tail of `T` is:\n     - a [slice], then the length of the slice tail must be an initialized\n       integer, and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n       For the special case where the dynamic tail length is 0, this function\n       is safe to call.\n     - a [trait object], then the vtable part of the pointer must point\n       to a valid vtable for the type `T` acquired by an unsizing coercion,\n       and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n     - an (unstable) [extern type], then this function is always safe to\n       call, but may panic or otherwise return the wrong value, as the\n       extern type's layout is not known. This is the same behavior as\n       [`Layout::for_value`] on a reference to an extern type tail.\n     - otherwise, it is conservatively not allowed to call this function.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n [extern type]: ../../unstable-book/language-features/extern-types.html\n",
      "adt": {}
    },
    "core::alloc::Allocator::deallocate": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Deallocates the memory referenced by `ptr`.\n\n # Safety\n\n * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n * `layout` must [*fit*] that block of memory.\n\n [*currently allocated*]: #currently-allocated-memory\n [*fit*]: #memory-fitting\n",
      "adt": {}
    }
  },
  "adts": {
    "rc::UniqueRc": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "core::ptr::NonNull": [
      "Ref",
      "Plain"
    ],
    "rc::RcInner": [
      "Ref"
    ],
    "core::alloc::Layout": [
      "Plain"
    ]
  },
  "path": 1814,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:4423:5: 4435:6",
  "src": "fn drop(&mut self) {\n        unsafe {\n            // destroy the contained object\n            drop_in_place(DerefMut::deref_mut(self));\n\n            // remove the implicit \"strong weak\" pointer now that we've destroyed the contents.\n            self.ptr.as_ref().dec_weak();\n\n            if self.ptr.as_ref().weak() == 0 {\n                self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()));\n            }\n        }\n    }",
  "mir": "fn <rc::UniqueRc<T, A> as core::ops::Drop>::drop(_1: &mut rc::UniqueRc<T, A>) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: *mut T;\n    let mut _4: &mut T;\n    let  _5: ();\n    let  _6: &rc::RcInner<T>;\n    let mut _7: &core::ptr::NonNull<rc::RcInner<T>>;\n    let mut _8: usize;\n    let  _9: &rc::RcInner<T>;\n    let mut _10: &core::ptr::NonNull<rc::RcInner<T>>;\n    let  _11: ();\n    let mut _12: &A;\n    let mut _13: core::ptr::NonNull<u8>;\n    let mut _14: core::ptr::NonNull<rc::RcInner<T>>;\n    let mut _15: core::alloc::Layout;\n    let mut _16: *const rc::RcInner<T>;\n    let mut _17: *mut rc::RcInner<T>;\n    let mut _18: core::ptr::NonNull<rc::RcInner<T>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <rc::UniqueRc<T, A> as core::ops::DerefMut>::deref_mut(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &raw mut (*_4);\n        _2 = core::ptr::drop_in_place::<T>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = &((*_1).0: core::ptr::NonNull<rc::RcInner<T>>);\n        _6 = core::ptr::NonNull::<rc::RcInner<T>>::as_ref::<'_>(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _5 = <rc::RcInner<T> as rc::RcInnerPtr>::dec_weak(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_8);\n        StorageLive(_10);\n        _10 = &((*_1).0: core::ptr::NonNull<rc::RcInner<T>>);\n        _9 = core::ptr::NonNull::<rc::RcInner<T>>::as_ref::<'_>(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        _8 = <rc::RcInner<T> as rc::RcInnerPtr>::weak(_9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb7, otherwise: bb12];\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageLive(_12);\n        _12 = &((*_1).3: A);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ((*_1).0: core::ptr::NonNull<rc::RcInner<T>>);\n        _13 = core::ptr::NonNull::<rc::RcInner<T>>::cast::<u8>(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = ((*_1).0: core::ptr::NonNull<rc::RcInner<T>>);\n        _17 = core::ptr::NonNull::<rc::RcInner<T>>::as_ptr(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _16 = move _17 as *const rc::RcInner<T>;\n        StorageDead(_18);\n        StorageDead(_17);\n        _15 = core::alloc::Layout::for_value_raw::<rc::RcInner<T>>(move _16) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        _11 = <A as core::alloc::Allocator>::deallocate(move _12, move _13, move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_8);\n        goto -> bb13;\n    }\n    bb13: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}