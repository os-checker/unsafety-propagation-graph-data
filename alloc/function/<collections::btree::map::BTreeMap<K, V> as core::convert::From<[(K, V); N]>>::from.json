{
  "name": "<collections::btree::map::BTreeMap<K, V> as core::convert::From<[(K, V); N]>>::from",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a new, empty `BTreeMap`.\n\n Does not allocate anything on its own.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n\n // entries can now be inserted into the empty map\n map.insert(1, \"a\");\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    },
    "slice::<impl [T]>::sort_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order with a comparison function, preserving initial order of\n equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\n worst-case.\n\n If the comparison function `compare` does not implement a [total order], the function may\n panic; even if the function exits normally, the resulting order of elements in the slice is\n unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n # Current implementation\n\n The current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\n combines the fast average case of quicksort with the fast worst case and partial run\n detection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\n with k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n The auxiliary memory allocation behavior depends on the input length. Short slices are\n handled without allocation, medium sized slices allocate `self.len()` and beyond that it\n clamps at `self.len() / 2`.\n\n # Panics\n\n May panic if `compare` does not implement a [total order], or if `compare` itself panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n v.sort_by(|a, b| a.cmp(b));\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n\n // reverse sorting\n v.sort_by(|a, b| b.cmp(a));\n assert_eq!(v, [4, 2, 1, -3, -5]);\n ```\n\n [driftsort]: https://github.com/Voultapher/driftsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    },
    "collections::btree::map::BTreeMap::<K, V, A>::bulk_build_from_sorted_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a `BTreeMap` from a sorted iterator.\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "Plain"
    ]
  },
  "path": 587,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2510:5: 2518:6",
  "src": "fn from(mut arr: [(K, V); N]) -> Self {\n        if N == 0 {\n            return BTreeMap::new();\n        }\n\n        // use stable sort to preserve the insertion order.\n        arr.sort_by(|a, b| a.0.cmp(&b.0));\n        BTreeMap::bulk_build_from_sorted_iter(arr, Global)\n    }",
  "mir": "fn <collections::btree::map::BTreeMap<K, V> as core::convert::From<[(K, V); N]>>::from(_1: [(K, V); N]) -> collections::btree::map::BTreeMap<K, V> {\n    let mut _0: collections::btree::map::BTreeMap<K, V>;\n    let mut _2: bool;\n    let  _3: ();\n    let mut _4: &mut [(K, V)];\n    let mut _5: &mut [(K, V); N];\n    let mut _6: [(K, V); N];\n    debug arr => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = Eq(N, 0_usize);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = collections::btree::map::BTreeMap::<K, V>::new() -> [return: bb5, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _1;\n        _4 = move _5 as &mut [(K, V)];\n        StorageDead(_5);\n        _3 = slice::<impl [(K, V)]>::sort_by::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2516:21: 2516:27}>(move _4, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2516:21: 2516:27}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = move _1;\n        _0 = collections::btree::map::BTreeMap::<K, V>::bulk_build_from_sorted_iter::<[(K, V); N]>(move _6, alloc::Global) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        goto -> bb6;\n    }\n    bb5: {\n        StorageDead(_2);\n        drop(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Converts a `[(K, V); N]` into a `BTreeMap<K, V>`.\n\n If any entries in the array have equal keys,\n all but one of the corresponding values will be dropped.\n\n ```\n use std::collections::BTreeMap;\n\n let map1 = BTreeMap::from([(1, 2), (3, 4)]);\n let map2: BTreeMap<_, _> = [(1, 2), (3, 4)].into();\n assert_eq!(map1, map2);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}