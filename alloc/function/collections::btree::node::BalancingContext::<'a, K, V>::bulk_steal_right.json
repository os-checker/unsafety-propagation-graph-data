{
  "name": "collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::len_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to the length of the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::key_area_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to an element of the key storage area.\n\n # Safety\n `index` is in bounds of 0..CAPACITY\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "core::mem::MaybeUninit::<T>::assume_init_read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n to the usual drop handling.\n\n Whenever possible, it is preferable to use [`assume_init`] instead, which\n prevents duplicating the content of the `MaybeUninit<T>`.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n Moreover, similar to the [`ptr::read`] function, this function creates a\n bitwise copy of the contents, regardless whether the contained type\n implements the [`Copy`] trait or not. When using multiple copies of the\n data (by calling `assume_init_read` multiple times, or first calling\n `assume_init_read` and then [`assume_init`]), it is your responsibility\n to ensure that data may indeed be duplicated.\n\n [inv]: #initialization-invariant\n [`assume_init`]: MaybeUninit::assume_init\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<u32>::uninit();\n x.write(13);\n let x1 = unsafe { x.assume_init_read() };\n // `u32` is `Copy`, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(None);\n let x1 = unsafe { x.assume_init_read() };\n // Duplicating a `None` value is okay, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(Some(vec![0, 1, 2]));\n let x1 = unsafe { x.assume_init_read() };\n let x2 = unsafe { x.assume_init_read() };\n // We now created two copies of the same vector, leading to a double-free ⚠️ when\n // they both get dropped!\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::val_area_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to an element or slice of the node's value storage area.\n\n # Safety\n `index` is in bounds of 0..CAPACITY\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::replace_kv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Replaces the key and value that the KV handle refers to.\n",
      "adt": {
        "collections::btree::node::Handle": "MutableAsArgument"
      }
    },
    "core::mem::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {}
    },
    "collections::btree::node::move_to_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves all values from a slice of initialized elements to a slice\n of uninitialized elements, leaving behind `src` as all uninitialized.\n Works like `dst.copy_from_slice(src)` but does not require `T` to be `Copy`.\n",
      "adt": {}
    },
    "collections::btree::node::slice_shl": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shifts the elements in a slice `distance` positions to the left.\n\n # Safety\n The slice has at least `distance` elements.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>::force": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether a node is an `Internal` node or a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::ForceResult": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::edge_area_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to an element or slice of the node's storage area for edge contents.\n\n # Safety\n `index` is in bounds of 0..CAPACITY + 1\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n Every item returned by `range` is a valid edge index for the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Ref",
      "Deref",
      "Plain"
    ],
    "collections::btree::node::BalancingContext": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::mem::MaybeUninit": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "collections::btree::node::Handle": [
      "MutRef"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "collections::btree::node::ForceResult": [
      "Plain",
      "Unknown([Field(0, Ty { id: 2862, kind: RigidTy(Adt(AdtDef(DefId { id: 3533, name: \"collections::btree::node::ForceResult\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 2862, kind: RigidTy(Adt(AdtDef(DefId { id: 3533, name: \"collections::btree::node::ForceResult\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Field(0, Ty { id: 2862, kind: RigidTy(Adt(AdtDef(DefId { id: 3533, name: \"collections::btree::node::ForceResult\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 2862, kind: RigidTy(Adt(AdtDef(DefId { id: 3533, name: \"collections::btree::node::ForceResult\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:1591:5: 1652:6",
  "src": "pub(super) fn bulk_steal_right(&mut self, count: usize) {\n        assert!(count > 0);\n        unsafe {\n            let left_node = &mut self.left_child;\n            let old_left_len = left_node.len();\n            let right_node = &mut self.right_child;\n            let old_right_len = right_node.len();\n\n            // Make sure that we may steal safely.\n            assert!(old_left_len + count <= CAPACITY);\n            assert!(old_right_len >= count);\n\n            let new_left_len = old_left_len + count;\n            let new_right_len = old_right_len - count;\n            *left_node.len_mut() = new_left_len as u16;\n            *right_node.len_mut() = new_right_len as u16;\n\n            // Move leaf data.\n            {\n                // Move the rightmost stolen pair to the parent.\n                let k = right_node.key_area_mut(count - 1).assume_init_read();\n                let v = right_node.val_area_mut(count - 1).assume_init_read();\n                let (k, v) = self.parent.replace_kv(k, v);\n\n                // Move parent's key-value pair to the left child.\n                left_node.key_area_mut(old_left_len).write(k);\n                left_node.val_area_mut(old_left_len).write(v);\n\n                // Move elements from the right child to the left one.\n                move_to_slice(\n                    right_node.key_area_mut(..count - 1),\n                    left_node.key_area_mut(old_left_len + 1..new_left_len),\n                );\n                move_to_slice(\n                    right_node.val_area_mut(..count - 1),\n                    left_node.val_area_mut(old_left_len + 1..new_left_len),\n                );\n\n                // Fill gap where stolen elements used to be.\n                slice_shl(right_node.key_area_mut(..old_right_len), count);\n                slice_shl(right_node.val_area_mut(..old_right_len), count);\n            }\n\n            match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {\n                (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {\n                    // Steal edges.\n                    move_to_slice(\n                        right.edge_area_mut(..count),\n                        left.edge_area_mut(old_left_len + 1..new_left_len + 1),\n                    );\n\n                    // Fill gap where stolen edges used to be.\n                    slice_shl(right.edge_area_mut(..old_right_len + 1), count);\n\n                    left.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n                    right.correct_childrens_parent_links(0..new_right_len + 1);\n                }\n                (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}\n                _ => unreachable!(),\n            }\n        }\n    }",
  "mir": "fn collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right(_1: &mut collections::btree::node::BalancingContext<'_, K, V>, _2: usize) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: !;\n    let  _5: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _6: usize;\n    let mut _7: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _8: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _9: usize;\n    let mut _10: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: (usize, bool);\n    let mut _14: !;\n    let mut _15: bool;\n    let mut _16: !;\n    let  _17: usize;\n    let mut _18: (usize, bool);\n    let  _19: usize;\n    let mut _20: (usize, bool);\n    let mut _21: &mut u16;\n    let mut _22: &mut u16;\n    let  _23: K;\n    let mut _24: &core::mem::MaybeUninit<K>;\n    let  _25: &mut core::mem::MaybeUninit<K>;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let  _28: V;\n    let mut _29: &core::mem::MaybeUninit<V>;\n    let  _30: &mut core::mem::MaybeUninit<V>;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    let  _33: K;\n    let  _34: V;\n    let mut _35: (K, V);\n    let mut _36: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>;\n    let  _37: &mut K;\n    let mut _38: &mut core::mem::MaybeUninit<K>;\n    let  _39: &mut V;\n    let mut _40: &mut core::mem::MaybeUninit<V>;\n    let  _41: ();\n    let mut _42: &mut [core::mem::MaybeUninit<K>];\n    let mut _43: core::ops::RangeTo<usize>;\n    let mut _44: usize;\n    let mut _45: (usize, bool);\n    let mut _46: &mut [core::mem::MaybeUninit<K>];\n    let mut _47: core::ops::Range<usize>;\n    let mut _48: usize;\n    let mut _49: (usize, bool);\n    let  _50: ();\n    let mut _51: &mut [core::mem::MaybeUninit<V>];\n    let mut _52: core::ops::RangeTo<usize>;\n    let mut _53: usize;\n    let mut _54: (usize, bool);\n    let mut _55: &mut [core::mem::MaybeUninit<V>];\n    let mut _56: core::ops::Range<usize>;\n    let mut _57: usize;\n    let mut _58: (usize, bool);\n    let  _59: ();\n    let mut _60: &mut [core::mem::MaybeUninit<K>];\n    let mut _61: core::ops::RangeTo<usize>;\n    let  _62: ();\n    let mut _63: &mut [core::mem::MaybeUninit<V>];\n    let mut _64: core::ops::RangeTo<usize>;\n    let mut _65: (collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>, collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>);\n    let mut _66: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let mut _67: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _68: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let mut _69: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _70: isize;\n    let mut _71: isize;\n    let mut _72: isize;\n    let mut _73: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _74: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let  _75: ();\n    let mut _76: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _77: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _78: core::ops::RangeTo<usize>;\n    let mut _79: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _80: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _81: core::ops::Range<usize>;\n    let mut _82: usize;\n    let mut _83: (usize, bool);\n    let mut _84: usize;\n    let mut _85: (usize, bool);\n    let  _86: ();\n    let mut _87: &mut [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>];\n    let mut _88: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _89: core::ops::RangeTo<usize>;\n    let mut _90: usize;\n    let mut _91: (usize, bool);\n    let  _92: ();\n    let mut _93: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _94: core::ops::Range<usize>;\n    let mut _95: usize;\n    let mut _96: (usize, bool);\n    let mut _97: usize;\n    let mut _98: (usize, bool);\n    let  _99: ();\n    let mut _100: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _101: core::ops::Range<usize>;\n    let mut _102: usize;\n    let mut _103: (usize, bool);\n    let mut _104: !;\n    debug self => _1;\n    debug count => _2;\n    debug left_node => _5;\n    debug old_left_len => _6;\n    debug right_node => _8;\n    debug old_right_len => _9;\n    debug new_left_len => _17;\n    debug new_right_len => _19;\n    debug k => _23;\n    debug v => _28;\n    debug k => _33;\n    debug v => _34;\n    debug left => _73;\n    debug right => _74;\n    bb0: {\n        StorageLive(_3);\n        _3 = Gt(_2, 0_usize);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        _5 = &mut ((*_1).1: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_7);\n        _7 = &(*_5);\n        _6 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        _4 = core::panicking::panic(\"assertion failed: count > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_7);\n        _8 = &mut ((*_1).2: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_10);\n        _10 = &(*_8);\n        _9 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _13 = CheckedAdd(_6, _2);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, _2) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = move (_13.0: usize);\n        _11 = Le(move _12, collections::btree::node::CAPACITY);\n        switchInt(move _11) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = Ge(_9, _2);\n        switchInt(move _15) -> [0: bb9, otherwise: bb8];\n    }\n    bb7: {\n        StorageDead(_12);\n        _14 = core::panicking::panic(\"assertion failed: old_left_len + count <= CAPACITY\") -> unwind unreachable;\n    }\n    bb8: {\n        StorageDead(_15);\n        _18 = CheckedAdd(_6, _2);\n        assert(!move (_18.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, _2) -> [success: bb10, unwind unreachable];\n    }\n    bb9: {\n        _16 = core::panicking::panic(\"assertion failed: old_right_len >= count\") -> unwind unreachable;\n    }\n    bb10: {\n        _17 = move (_18.0: usize);\n        _20 = CheckedSub(_9, _2);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _9, _2) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _19 = move (_20.0: usize);\n        StorageLive(_21);\n        _21 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len_mut(_5) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        (*_21) = _17 as u16;\n        StorageDead(_21);\n        StorageLive(_22);\n        _22 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len_mut(_8) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        (*_22) = _19 as u16;\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _27 = CheckedSub(_2, 1_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _26 = move (_27.0: usize);\n        _25 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<usize, core::mem::MaybeUninit<K>>(_8, move _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _24 = &(*_25);\n        StorageDead(_26);\n        _23 = core::mem::MaybeUninit::<K>::assume_init_read(move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_24);\n        StorageDead(_25);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _32 = CheckedSub(_2, 1_usize);\n        assert(!move (_32.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _31 = move (_32.0: usize);\n        _30 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<usize, core::mem::MaybeUninit<V>>(_8, move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _29 = &(*_30);\n        StorageDead(_31);\n        _28 = core::mem::MaybeUninit::<V>::assume_init_read(move _29) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageDead(_30);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &mut ((*_1).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>);\n        _35 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>::replace_kv(move _36, _23, _28) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_36);\n        _33 = move (_35.0: K);\n        _34 = move (_35.1: V);\n        StorageDead(_35);\n        StorageLive(_37);\n        _38 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<usize, core::mem::MaybeUninit<K>>(_5, _6) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _37 = core::mem::MaybeUninit::<K>::write(_38, _33) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_37);\n        StorageLive(_39);\n        _40 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<usize, core::mem::MaybeUninit<V>>(_5, _6) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _39 = core::mem::MaybeUninit::<V>::write(_40, _34) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_39);\n        StorageLive(_43);\n        StorageLive(_44);\n        _45 = CheckedSub(_2, 1_usize);\n        assert(!move (_45.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _44 = move (_45.0: usize);\n        _43 = RangeTo(move _44);\n        StorageDead(_44);\n        _42 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<K>]>(_8, move _43) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_43);\n        StorageLive(_47);\n        StorageLive(_48);\n        _49 = CheckedAdd(_6, 1_usize);\n        assert(!move (_49.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _48 = move (_49.0: usize);\n        _47 = Range(move _48, _17);\n        StorageDead(_48);\n        _46 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<core::ops::Range<usize>, [core::mem::MaybeUninit<K>]>(_5, move _47) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_47);\n        _41 = collections::btree::node::move_to_slice::<K>(_42, _46) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_52);\n        StorageLive(_53);\n        _54 = CheckedSub(_2, 1_usize);\n        assert(!move (_54.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _53 = move (_54.0: usize);\n        _52 = RangeTo(move _53);\n        StorageDead(_53);\n        _51 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<V>]>(_8, move _52) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_52);\n        StorageLive(_56);\n        StorageLive(_57);\n        _58 = CheckedAdd(_6, 1_usize);\n        assert(!move (_58.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _57 = move (_58.0: usize);\n        _56 = Range(move _57, _17);\n        StorageDead(_57);\n        _55 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<core::ops::Range<usize>, [core::mem::MaybeUninit<V>]>(_5, move _56) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_56);\n        _50 = collections::btree::node::move_to_slice::<V>(_51, _55) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageLive(_61);\n        _61 = RangeTo(_9);\n        _60 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::key_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<K>]>(_8, move _61) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_61);\n        _59 = collections::btree::node::slice_shl::<K>(_60, _2) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageLive(_64);\n        _64 = RangeTo(_9);\n        _63 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::val_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<V>]>(_8, move _64) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_64);\n        _62 = collections::btree::node::slice_shl::<V>(_63, _2) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow_mut(_5) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _66 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::force(move _67) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_67);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow_mut(_8) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _68 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::force(move _69) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_69);\n        _65 = (move _66, move _68);\n        StorageDead(_68);\n        StorageDead(_66);\n        _72 = discriminant((_65.0: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>));\n        switchInt(move _72) -> [0: bb45, 1: bb44, otherwise: bb61];\n    }\n    bb43: {\n        _104 = core::panicking::panic(\"internal error: entered unreachable code\") -> unwind unreachable;\n    }\n    bb44: {\n        _70 = discriminant((_65.1: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>));\n        switchInt(move _70) -> [1: bb46, 0: bb43, otherwise: bb61];\n    }\n    bb45: {\n        _71 = discriminant((_65.1: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>));\n        switchInt(move _71) -> [0: bb60, 1: bb43, otherwise: bb61];\n    }\n    bb46: {\n        StorageLive(_73);\n        _73 = move (((_65.0: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>) as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>);\n        StorageLive(_74);\n        _74 = move (((_65.1: collections::btree::node::ForceResult<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>) as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>);\n        StorageLive(_77);\n        _77 = &mut _74;\n        StorageLive(_78);\n        _78 = RangeTo(_2);\n        _76 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::edge_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>]>(move _77, move _78) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_78);\n        StorageDead(_77);\n        StorageLive(_80);\n        _80 = &mut _73;\n        StorageLive(_81);\n        StorageLive(_82);\n        _83 = CheckedAdd(_6, 1_usize);\n        assert(!move (_83.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _82 = move (_83.0: usize);\n        StorageLive(_84);\n        _85 = CheckedAdd(_17, 1_usize);\n        assert(!move (_85.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _17, 1_usize) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _84 = move (_85.0: usize);\n        _81 = Range(move _82, move _84);\n        StorageDead(_84);\n        StorageDead(_82);\n        _79 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::edge_area_mut::<core::ops::Range<usize>, [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>]>(move _80, move _81) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_81);\n        StorageDead(_80);\n        _75 = collections::btree::node::move_to_slice::<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>(_76, _79) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageLive(_88);\n        _88 = &mut _74;\n        StorageLive(_89);\n        StorageLive(_90);\n        _91 = CheckedAdd(_9, 1_usize);\n        assert(!move (_91.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        _90 = move (_91.0: usize);\n        _89 = RangeTo(move _90);\n        StorageDead(_90);\n        _87 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::edge_area_mut::<core::ops::RangeTo<usize>, [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>]>(move _88, move _89) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_89);\n        StorageDead(_88);\n        _86 = collections::btree::node::slice_shl::<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>(_87, _2) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageLive(_93);\n        _93 = &mut _73;\n        StorageLive(_94);\n        StorageLive(_95);\n        _96 = CheckedAdd(_6, 1_usize);\n        assert(!move (_96.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb55, unwind unreachable];\n    }\n    bb55: {\n        _95 = move (_96.0: usize);\n        StorageLive(_97);\n        _98 = CheckedAdd(_17, 1_usize);\n        assert(!move (_98.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _17, 1_usize) -> [success: bb56, unwind unreachable];\n    }\n    bb56: {\n        _97 = move (_98.0: usize);\n        _94 = Range(move _95, move _97);\n        StorageDead(_97);\n        StorageDead(_95);\n        _92 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links::<core::ops::Range<usize>>(move _93, move _94) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_94);\n        StorageDead(_93);\n        StorageLive(_100);\n        _100 = &mut _74;\n        StorageLive(_101);\n        StorageLive(_102);\n        _103 = CheckedAdd(_19, 1_usize);\n        assert(!move (_103.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _19, 1_usize) -> [success: bb58, unwind unreachable];\n    }\n    bb58: {\n        _102 = move (_103.0: usize);\n        _101 = Range(0_usize, move _102);\n        StorageDead(_102);\n        _99 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links::<core::ops::Range<usize>>(move _100, move _101) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_101);\n        StorageDead(_100);\n        StorageDead(_74);\n        StorageDead(_73);\n        goto -> bb60;\n    }\n    bb60: {\n        StorageDead(_65);\n        return;\n    }\n    bb61: {\n        unreachable;\n    }\n}\n",
  "doc": " The symmetric clone of `bulk_steal_left`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}