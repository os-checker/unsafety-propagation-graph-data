{
  "name": "collections::btree::node::slice_insert",
  "safe": false,
  "callees": {
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n\n If the source and destination will *never* overlap,\n [`copy_nonoverlapping`] can be used instead.\n\n `copy` is semantically equivalent to C's [`memmove`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n Copying takes place as if the bytes were copied from `src`\n to a temporary array and then copied from the array to `dst`.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\n   when `src` is read for `count * size_of::<T>()` bytes. (This means if the memory ranges\n   overlap, the `dst` pointer must not be invalidated by `src` reads.)\n\n * Both `src` and `dst` must be properly aligned.\n\n Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Efficiently create a Rust vector from an unsafe buffer:\n\n ```\n use std::ptr;\n\n /// # Safety\n ///\n /// * `ptr` must be correctly aligned for its type and non-zero.\n /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n /// * Those elements must not be used after calling this function unless `T: Copy`.\n # #[allow(dead_code)]\n unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     let mut dst = Vec::with_capacity(elts);\n\n     // SAFETY: Our precondition ensures the source is aligned and valid,\n     // and `Vec::with_capacity` ensures that we have usable space to write them.\n     unsafe { ptr::copy(ptr, dst.as_mut_ptr(), elts); }\n\n     // SAFETY: We created it with this much capacity earlier,\n     // and the previous `copy` has initialized these elements.\n     unsafe { dst.set_len(elts); }\n     dst\n }\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::mem::MaybeUninit": [
      "MutRef"
    ]
  },
  "path": 846,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:1822:1: 1832:2",
  "src": "unsafe fn slice_insert<T>(slice: &mut [MaybeUninit<T>], idx: usize, val: T) {\n    unsafe {\n        let len = slice.len();\n        debug_assert!(len > idx);\n        let slice_ptr = slice.as_mut_ptr();\n        if len > idx + 1 {\n            ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx - 1);\n        }\n        (*slice_ptr.add(idx)).write(val);\n    }\n}",
  "mir": "fn collections::btree::node::slice_insert(_1: &mut [core::mem::MaybeUninit<T>], _2: usize, _3: T) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let mut _5: &[core::mem::MaybeUninit<T>];\n    let mut _6: bool;\n    let mut _7: !;\n    let  _8: *mut core::mem::MaybeUninit<T>;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let  _12: ();\n    let mut _13: *const core::mem::MaybeUninit<T>;\n    let mut _14: *mut core::mem::MaybeUninit<T>;\n    let mut _15: *mut core::mem::MaybeUninit<T>;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: (usize, bool);\n    let mut _21: (usize, bool);\n    let  _22: &mut T;\n    let mut _23: &mut core::mem::MaybeUninit<T>;\n    let mut _24: *mut core::mem::MaybeUninit<T>;\n    debug slice => _1;\n    debug idx => _2;\n    debug val => _3;\n    debug len => _4;\n    debug slice_ptr => _8;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = Gt(_4, _2);\n        switchInt(move _6) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_6);\n        _8 = core::slice::<impl [core::mem::MaybeUninit<T>]>::as_mut_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        _7 = core::panicking::panic(\"assertion failed: len > idx\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _11 = CheckedAdd(_2, 1_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = move (_11.0: usize);\n        _9 = Gt(_4, move _10);\n        switchInt(move _9) -> [0: bb12, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::add(_8, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = move _14 as *const core::mem::MaybeUninit<T>;\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _17 = CheckedAdd(_2, 1_usize);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _16 = move (_17.0: usize);\n        _15 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::add(_8, move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = CheckedSub(_4, _2);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _2) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _19 = move (_20.0: usize);\n        _21 = CheckedSub(_19, 1_usize);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _19, 1_usize) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _18 = move (_21.0: usize);\n        StorageDead(_19);\n        _12 = core::ptr::copy::<core::mem::MaybeUninit<T>>(move _13, move _15, move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_18);\n        StorageDead(_15);\n        StorageDead(_13);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_10);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_9);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::add(_8, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _23 = &mut (*_24);\n        _22 = core::mem::MaybeUninit::<T>::write(move _23, _3) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        StorageDead(_24);\n        StorageDead(_22);\n        return;\n    }\n}\n",
  "doc": " Inserts a value into a slice of initialized elements followed by one uninitialized element.\n\n # Safety\n The slice has more than `idx` elements.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}