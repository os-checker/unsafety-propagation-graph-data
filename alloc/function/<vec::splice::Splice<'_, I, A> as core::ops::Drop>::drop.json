{
  "name": "<vec::splice::Splice<'_, I, A> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "core::iter::Iterator::by_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a \"by reference\" adapter for this instance of `Iterator`.\n\n Consuming method calls (direct or indirect calls to `next`)\n on the \"by reference\" adapter will consume the original iterator,\n but ownership-taking methods (those with a `self` parameter)\n only take ownership of the \"by reference\" iterator.\n\n This is useful for applying ownership-taking methods\n (such as `take` in the example below)\n without giving up ownership of the original iterator,\n so you can use the original iterator afterwards.\n\n Uses [`impl<I: Iterator + ?Sized> Iterator for &mut I { type Item = I::Item; ...}`](https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#impl-Iterator-for-%26mut+I).\n\n # Examples\n\n ```\n let mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();\n\n // Take the first two words.\n let hello_world: Vec<_> = words.by_ref().take(2).collect();\n assert_eq!(hello_world, vec![\"hello\", \"world\"]);\n\n // Collect the rest of the words.\n // We can only do this because we used `by_ref` earlier.\n let of_rust: Vec<_> = words.collect();\n assert_eq!(of_rust, vec![\"of\", \"Rust\"]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls a closure on each element of an iterator.\n\n This is equivalent to using a [`for`] loop on the iterator, although\n `break` and `continue` are not possible from a closure. It's generally\n more idiomatic to use a `for` loop, but `for_each` may be more legible\n when processing items at the end of longer iterator chains. In some\n cases `for_each` may also be faster than a loop, because it will use\n internal iteration on adapters like `Chain`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n use std::sync::mpsc::channel;\n\n let (tx, rx) = channel();\n (0..5).map(|x| x * 2 + 1)\n       .for_each(move |x| tx.send(x).unwrap());\n\n let v: Vec<_> = rx.iter().collect();\n assert_eq!(v, vec![1, 3, 5, 7, 9]);\n ```\n\n For such a small example, a `for` loop may be cleaner, but `for_each`\n might be preferable to keep a functional style with longer iterators:\n\n ```\n (0..5).flat_map(|x| (x * 100)..(x * 110))\n       .enumerate()\n       .filter(|&(i, x)| (i + x) % 3 == 0)\n       .for_each(|(i, x)| println!(\"{i}:{x}\"));\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n must be used instead.\n\n For the shared counterpart see [`as_ref`].\n\n [`as_uninit_mut`]: NonNull::as_uninit_mut\n [`as_ref`]: NonNull::as_ref\n\n # Safety\n\n When calling this method, you have to ensure that\n the pointer is [convertible to a reference](crate::ptr#pointer-to-reference-conversion).\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let mut ptr = NonNull::new(&mut x).expect(\"null pointer\");\n\n let x_ref = unsafe { ptr.as_mut() };\n assert_eq!(*x_ref, 0);\n *x_ref += 2;\n assert_eq!(*x_ref, 2);\n ```\n\n [the module documentation]: crate::ptr#safety\n",
      "adt": {}
    },
    "core::iter::Extend::extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends a collection with the contents of an iterator.\n\n As this is the only required method for this trait, the [trait-level] docs\n contain more details.\n\n [trait-level]: Extend\n\n # Examples\n\n ```\n // You can extend a String with some chars:\n let mut message = String::from(\"abc\");\n\n message.extend(['d', 'e', 'f'].iter());\n\n assert_eq!(\"abcdef\", &message);\n ```\n",
      "adt": {}
    },
    "vec::splice::<impl vec::drain::Drain<'_, T, A>>::fill": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The range from `self.vec.len` to `self.tail_start` contains elements\n that have been moved out.\n Fill that range as much as possible with new elements from the `replace_with` iterator.\n Returns `true` if we filled the entire range. (`replace_with.next()` didnâ€™t return `None`.)\n",
      "adt": {
        "vec::drain::Drain": "MutableAsArgument"
      }
    },
    "core::iter::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {}
    },
    "vec::splice::<impl vec::drain::Drain<'_, T, A>>::move_tail": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes room for inserting more elements before the tail.\n",
      "adt": {
        "vec::drain::Drain": "MutableAsArgument"
      }
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "vec::drain::Drain": [
      "MutRef"
    ],
    "vec::splice::Splice": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::ptr::NonNull": [
      "MutRef"
    ],
    "vec::Vec": [
      "MutRef",
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 257, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "vec::into_iter::IntoIter": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ]
  },
  "path": 2294,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/splice.rs:55:5: 97:6",
  "src": "fn drop(&mut self) {\n        self.drain.by_ref().for_each(drop);\n        // At this point draining is done and the only remaining tasks are splicing\n        // and moving things into the final place.\n        // Which means we can replace the slice::Iter with pointers that won't point to deallocated\n        // memory, so that Drain::drop is still allowed to call iter.len(), otherwise it would break\n        // the ptr.offset_from_unsigned contract.\n        self.drain.iter = (&[]).iter();\n\n        unsafe {\n            if self.drain.tail_len == 0 {\n                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                return;\n            }\n\n            // First fill the range left by drain().\n            if !self.drain.fill(&mut self.replace_with) {\n                return;\n            }\n\n            // There may be more elements. Use the lower bound as an estimate.\n            // FIXME: Is the upper bound a better guess? Or something else?\n            let (lower_bound, _upper_bound) = self.replace_with.size_hint();\n            if lower_bound > 0 {\n                self.drain.move_tail(lower_bound);\n                if !self.drain.fill(&mut self.replace_with) {\n                    return;\n                }\n            }\n\n            // Collect any remaining elements.\n            // This is a zero-length vector which does not allocate if `lower_bound` was exact.\n            let mut collected = self.replace_with.by_ref().collect::<Vec<I::Item>>().into_iter();\n            // Now we have an exact count.\n            if collected.len() > 0 {\n                self.drain.move_tail(collected.len());\n                let filled = self.drain.fill(&mut collected);\n                debug_assert!(filled);\n                debug_assert_eq!(collected.len(), 0);\n            }\n        }\n        // Let `Drain::drop` move the tail back if necessary and restore `vec.len`.\n    }",
  "mir": "fn <vec::splice::Splice<'_, I, A> as core::ops::Drop>::drop(_1: &mut vec::splice::Splice<'_, I, A>) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _4: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _5: core::slice::Iter<'_, <I as core::iter::Iterator>::Item>;\n    let mut _6: &[<I as core::iter::Iterator>::Item];\n    let  _7: &[<I as core::iter::Iterator>::Item; 0];\n    let mut _8: usize;\n    let  _9: ();\n    let mut _10: &mut vec::Vec<<I as core::iter::Iterator>::Item, A>;\n    let mut _11: &mut core::ptr::NonNull<vec::Vec<<I as core::iter::Iterator>::Item, A>>;\n    let mut _12: &mut I;\n    let mut _13: &mut I;\n    let mut _14: bool;\n    let mut _15: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _16: &mut I;\n    let  _17: usize;\n    let  _18: core::option::Option<usize>;\n    let mut _19: (usize, core::option::Option<usize>);\n    let mut _20: &I;\n    let mut _21: bool;\n    let  _22: ();\n    let mut _23: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _24: bool;\n    let mut _25: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _26: &mut I;\n    let mut _27: vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item>;\n    let mut _28: vec::Vec<<I as core::iter::Iterator>::Item>;\n    let mut _29: &mut I;\n    let mut _30: &mut I;\n    let mut _31: bool;\n    let mut _32: usize;\n    let mut _33: &vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item>;\n    let  _34: ();\n    let mut _35: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _36: usize;\n    let mut _37: &vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item>;\n    let  _38: bool;\n    let mut _39: &mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>;\n    let mut _40: &mut vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item>;\n    let mut _41: !;\n    let mut _42: (&usize, &usize);\n    let mut _43: &usize;\n    let  _44: usize;\n    let mut _45: &vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item>;\n    let mut _46: &usize;\n    let  _47: &usize;\n    let  _48: &usize;\n    let mut _49: bool;\n    let mut _50: usize;\n    let mut _51: usize;\n    let  _52: core::panicking::AssertKind;\n    let  _53: !;\n    let mut _54: core::option::Option<core::fmt::Arguments<'_>>;\n    debug self => _1;\n    debug lower_bound => _17;\n    debug _upper_bound => _18;\n    debug collected => _27;\n    debug filled => _38;\n    debug left_val => _47;\n    debug right_val => _48;\n    debug kind => _52;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>);\n        _3 = <vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A> as core::iter::Iterator>::by_ref(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = <&mut vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A> as core::iter::Iterator>::for_each::<fn(<I as core::iter::Iterator>::Item) {core::mem::drop::<<I as core::iter::Iterator>::Item>}>(_3, core::mem::drop::<<I as core::iter::Iterator>::Item>) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _7 = <vec::splice::Splice<'_, I, A> as core::ops::Drop>::drop::promoted[1];\n        _6 = _7 as &[<I as core::iter::Iterator>::Item];\n        _5 = core::slice::<impl [<I as core::iter::Iterator>::Item]>::iter(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        (((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>).2: core::slice::Iter<'_, <I as core::iter::Iterator>::Item>) = move _5;\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = (((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>).1: usize);\n        switchInt(move _8) -> [0: bb4, otherwise: bb8];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_11);\n        _11 = &mut (((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>).3: core::ptr::NonNull<vec::Vec<<I as core::iter::Iterator>::Item, A>>);\n        _10 = core::ptr::NonNull::<vec::Vec<<I as core::iter::Iterator>::Item, A>>::as_mut::<'_>(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut ((*_1).1: I);\n        _12 = <I as core::iter::Iterator>::by_ref(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _9 = <vec::Vec<<I as core::iter::Iterator>::Item, A> as core::iter::Extend<<I as core::iter::Iterator>::Item>>::extend::<&mut I>(_10, move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        goto -> bb36;\n    }\n    bb8: {\n        StorageDead(_8);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut ((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>);\n        _16 = &mut ((*_1).1: I);\n        _14 = vec::splice::<impl vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>>::fill::<I>(move _15, _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _14) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &((*_1).1: I);\n        _19 = <I as core::iter::Iterator>::size_hint(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb36;\n    }\n    bb12: {\n        StorageDead(_20);\n        _17 = (_19.0: usize);\n        StorageLive(_18);\n        _18 = (_19.1: core::option::Option<usize>);\n        StorageDead(_19);\n        StorageLive(_21);\n        _21 = Gt(_17, 0_usize);\n        switchInt(move _21) -> [0: bb18, otherwise: bb13];\n    }\n    bb13: {\n        StorageLive(_23);\n        _23 = &mut ((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>);\n        _22 = vec::splice::<impl vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>>::move_tail(move _23, _17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &mut ((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>);\n        _26 = &mut ((*_1).1: I);\n        _24 = vec::splice::<impl vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>>::fill::<I>(move _25, _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _24) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_25);\n        StorageDead(_24);\n        goto -> bb19;\n    }\n    bb17: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageDead(_18);\n        goto -> bb36;\n    }\n    bb18: {\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_21);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_30);\n        _30 = &mut ((*_1).1: I);\n        _29 = <I as core::iter::Iterator>::by_ref(move _30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_30);\n        _28 = <&mut I as core::iter::Iterator>::collect::<vec::Vec<<I as core::iter::Iterator>::Item>>(_29) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _27 = <vec::Vec<<I as core::iter::Iterator>::Item> as core::iter::IntoIterator>::into_iter(move _28) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_28);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_27;\n        _32 = <vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item> as core::iter::ExactSizeIterator>::len(move _33) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_33);\n        _31 = Gt(move _32, 0_usize);\n        switchInt(move _31) -> [0: bb33, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_32);\n        StorageLive(_35);\n        _35 = &mut ((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &_27;\n        _36 = <vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item> as core::iter::ExactSizeIterator>::len(move _37) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_37);\n        _34 = vec::splice::<impl vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>>::move_tail(move _35, move _36) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_39);\n        _39 = &mut ((*_1).0: vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>);\n        _40 = &mut _27;\n        _38 = vec::splice::<impl vec::drain::Drain<'_, <I as core::iter::Iterator>::Item, A>>::fill::<vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item>>(move _39, _40) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_39);\n        switchInt(_38) -> [0: bb28, otherwise: bb29];\n    }\n    bb28: {\n        _41 = core::panicking::panic(\"assertion failed: filled\") -> unwind unreachable;\n    }\n    bb29: {\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &_27;\n        _44 = <vec::into_iter::IntoIter<<I as core::iter::Iterator>::Item> as core::iter::ExactSizeIterator>::len(move _45) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_45);\n        _43 = &_44;\n        StorageLive(_46);\n        _46 = <vec::splice::Splice<'_, I, A> as core::ops::Drop>::drop::promoted[0];\n        _42 = (move _43, move _46);\n        StorageDead(_46);\n        StorageDead(_43);\n        _47 = (_42.0: &usize);\n        _48 = (_42.1: &usize);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = (*_47);\n        StorageLive(_51);\n        _51 = (*_48);\n        _49 = Eq(move _50, move _51);\n        switchInt(move _49) -> [0: bb32, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_51);\n        StorageDead(_50);\n        StorageDead(_49);\n        StorageDead(_44);\n        StorageDead(_42);\n        goto -> bb34;\n    }\n    bb32: {\n        StorageDead(_51);\n        StorageDead(_50);\n        _52 = core::panicking::AssertKind::Eq;\n        StorageLive(_54);\n        _54 = core::option::Option::None;\n        _53 = core::panicking::assert_failed::<usize, usize>(_52, _47, _48, move _54) -> unwind unreachable;\n    }\n    bb33: {\n        StorageDead(_32);\n        goto -> bb34;\n    }\n    bb34: {\n        StorageDead(_31);\n        drop(_27) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_27);\n        StorageDead(_18);\n        goto -> bb36;\n    }\n    bb36: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}