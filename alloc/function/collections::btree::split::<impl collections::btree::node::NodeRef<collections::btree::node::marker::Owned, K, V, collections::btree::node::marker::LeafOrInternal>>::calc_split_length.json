{
  "name": "collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_split_length",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::height": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of levels that the node and leaves are apart. Zero\n height means the node is a leaf itself. If you picture trees with the\n root on top, the number says at which elevation the node appears.\n If you picture trees with leaves on top, the number says how high\n the tree extends above the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::reborrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another, immutable reference to the same node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_length": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the number of elements in a (sub)tree.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Ref",
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_split_length"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/split.rs:11:5: 27:6",
  "src": "pub(super) fn calc_split_length(\n        total_num: usize,\n        root_a: &Root<K, V>,\n        root_b: &Root<K, V>,\n    ) -> (usize, usize) {\n        let (length_a, length_b);\n        if root_a.height() < root_b.height() {\n            length_a = root_a.reborrow().calc_length();\n            length_b = total_num - length_a;\n            debug_assert_eq!(length_b, root_b.reborrow().calc_length());\n        } else {\n            length_b = root_b.reborrow().calc_length();\n            length_a = total_num - length_b;\n            debug_assert_eq!(length_a, root_a.reborrow().calc_length());\n        }\n        (length_a, length_b)\n    }",
  "mir": "fn collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_split_length(_1: usize, _2: &collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, _3: &collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>) -> (usize, usize) {\n    let mut _0: (usize, usize);\n    let  _4: usize;\n    let  _5: usize;\n    let mut _6: bool;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let mut _13: (&usize, &usize);\n    let mut _14: &usize;\n    let mut _15: &usize;\n    let  _16: usize;\n    let mut _17: collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _18: &usize;\n    let  _19: &usize;\n    let mut _20: bool;\n    let mut _21: usize;\n    let mut _22: usize;\n    let  _23: core::panicking::AssertKind;\n    let  _24: !;\n    let mut _25: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _26: usize;\n    let mut _27: collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let mut _30: (&usize, &usize);\n    let mut _31: &usize;\n    let mut _32: &usize;\n    let  _33: usize;\n    let mut _34: collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _35: &usize;\n    let  _36: &usize;\n    let mut _37: bool;\n    let mut _38: usize;\n    let mut _39: usize;\n    let  _40: core::panicking::AssertKind;\n    let  _41: !;\n    let mut _42: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _43: usize;\n    let mut _44: usize;\n    debug total_num => _1;\n    debug root_a => _2;\n    debug root_b => _3;\n    debug length_a => _4;\n    debug length_b => _5;\n    debug left_val => _18;\n    debug right_val => _19;\n    debug kind => _23;\n    debug left_val => _35;\n    debug right_val => _36;\n    debug kind => _40;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::height(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_8);\n        _8 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::height(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = Lt(move _7, move _8);\n        switchInt(move _6) -> [0: bb11, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_length(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        _4 = move _9;\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = _4;\n        _12 = CheckedSub(_1, _11);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _1, move _11) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _5 = move (_12.0: usize);\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_5;\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow(_3) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _16 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_length(move _17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        _15 = &_16;\n        _13 = (move _14, move _15);\n        StorageDead(_15);\n        StorageDead(_14);\n        _18 = (_13.0: &usize);\n        _19 = (_13.1: &usize);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = (*_18);\n        StorageLive(_22);\n        _22 = (*_19);\n        _20 = Eq(move _21, move _22);\n        switchInt(move _20) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_16);\n        StorageDead(_13);\n        goto -> bb19;\n    }\n    bb10: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _23 = core::panicking::AssertKind::Eq;\n        StorageLive(_25);\n        _25 = core::option::Option::None;\n        _24 = core::panicking::assert_failed::<usize, usize>(_23, _18, _19, move _25) -> unwind unreachable;\n    }\n    bb11: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow(_3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _26 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_length(move _27) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_27);\n        _5 = move _26;\n        StorageDead(_26);\n        StorageLive(_28);\n        _28 = _5;\n        _29 = CheckedSub(_1, _28);\n        assert(!move (_29.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _1, move _28) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _4 = move (_29.0: usize);\n        StorageDead(_28);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &_4;\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::reborrow(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _33 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_length(move _34) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_34);\n        _32 = &_33;\n        _30 = (move _31, move _32);\n        StorageDead(_32);\n        StorageDead(_31);\n        _35 = (_30.0: &usize);\n        _36 = (_30.1: &usize);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = (*_35);\n        StorageLive(_39);\n        _39 = (*_36);\n        _37 = Eq(move _38, move _39);\n        switchInt(move _37) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_33);\n        StorageDead(_30);\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _40 = core::panicking::AssertKind::Eq;\n        StorageLive(_42);\n        _42 = core::option::Option::None;\n        _41 = core::panicking::assert_failed::<usize, usize>(_40, _35, _36, move _42) -> unwind unreachable;\n    }\n    bb19: {\n        StorageDead(_6);\n        StorageLive(_43);\n        _43 = _4;\n        StorageLive(_44);\n        _44 = _5;\n        _0 = (move _43, move _44);\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Calculates the length of both trees that result from splitting up\n a given number of distinct key-value pairs.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}