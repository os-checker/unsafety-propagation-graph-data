{
  "name": "collections::btree::node::slice_remove",
  "safe": false,
  "callees": {
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::assume_init_read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n to the usual drop handling.\n\n Whenever possible, it is preferable to use [`assume_init`] instead, which\n prevents duplicating the content of the `MaybeUninit<T>`.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n Moreover, similar to the [`ptr::read`] function, this function creates a\n bitwise copy of the contents, regardless whether the contained type\n implements the [`Copy`] trait or not. When using multiple copies of the\n data (by calling `assume_init_read` multiple times, or first calling\n `assume_init_read` and then [`assume_init`]), it is your responsibility\n to ensure that data may indeed be duplicated.\n\n [inv]: #initialization-invariant\n [`assume_init`]: MaybeUninit::assume_init\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<u32>::uninit();\n x.write(13);\n let x1 = unsafe { x.assume_init_read() };\n // `u32` is `Copy`, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(None);\n let x1 = unsafe { x.assume_init_read() };\n // Duplicating a `None` value is okay, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(Some(vec![0, 1, 2]));\n let x1 = unsafe { x.assume_init_read() };\n let x2 = unsafe { x.assume_init_read() };\n // We now created two copies of the same vector, leading to a double-free ⚠️ when\n // they both get dropped!\n ```\n",
      "adt": {}
    },
    "core::ptr::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n\n If the source and destination will *never* overlap,\n [`copy_nonoverlapping`] can be used instead.\n\n `copy` is semantically equivalent to C's [`memmove`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n Copying takes place as if the bytes were copied from `src`\n to a temporary array and then copied from the array to `dst`.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\n   when `src` is read for `count * size_of::<T>()` bytes. (This means if the memory ranges\n   overlap, the `dst` pointer must not be invalidated by `src` reads.)\n\n * Both `src` and `dst` must be properly aligned.\n\n Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Efficiently create a Rust vector from an unsafe buffer:\n\n ```\n use std::ptr;\n\n /// # Safety\n ///\n /// * `ptr` must be correctly aligned for its type and non-zero.\n /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n /// * Those elements must not be used after calling this function unless `T: Copy`.\n # #[allow(dead_code)]\n unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     let mut dst = Vec::with_capacity(elts);\n\n     // SAFETY: Our precondition ensures the source is aligned and valid,\n     // and `Vec::with_capacity` ensures that we have usable space to write them.\n     unsafe { ptr::copy(ptr, dst.as_mut_ptr(), elts); }\n\n     // SAFETY: We created it with this much capacity earlier,\n     // and the previous `copy` has initialized these elements.\n     unsafe { dst.set_len(elts); }\n     dst\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::mem::MaybeUninit": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::node::slice_remove"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:1839:1: 1848:2",
  "src": "unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {\n    unsafe {\n        let len = slice.len();\n        debug_assert!(idx < len);\n        let slice_ptr = slice.as_mut_ptr();\n        let ret = (*slice_ptr.add(idx)).assume_init_read();\n        ptr::copy(slice_ptr.add(idx + 1), slice_ptr.add(idx), len - idx - 1);\n        ret\n    }\n}",
  "mir": "fn collections::btree::node::slice_remove(_1: &mut [core::mem::MaybeUninit<T>], _2: usize) -> T {\n    let mut _0: T;\n    let  _3: usize;\n    let mut _4: &[core::mem::MaybeUninit<T>];\n    let mut _5: bool;\n    let mut _6: !;\n    let  _7: *mut core::mem::MaybeUninit<T>;\n    let mut _8: &core::mem::MaybeUninit<T>;\n    let  _9: *mut core::mem::MaybeUninit<T>;\n    let  _10: ();\n    let mut _11: *const core::mem::MaybeUninit<T>;\n    let mut _12: *mut core::mem::MaybeUninit<T>;\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let mut _15: *mut core::mem::MaybeUninit<T>;\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: (usize, bool);\n    let mut _19: (usize, bool);\n    debug slice => _1;\n    debug idx => _2;\n    debug len => _3;\n    debug slice_ptr => _7;\n    debug ret => _0;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = Lt(_2, _3);\n        switchInt(move _5) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        _7 = core::slice::<impl [core::mem::MaybeUninit<T>]>::as_mut_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        _6 = core::panicking::panic(\"assertion failed: idx < len\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::add(_7, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = &(*_9);\n        _0 = core::mem::MaybeUninit::<T>::assume_init_read(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _14 = CheckedAdd(_2, 1_usize);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = move (_14.0: usize);\n        _12 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::add(_7, move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = move _12 as *const core::mem::MaybeUninit<T>;\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_15);\n        _15 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::add(_7, _2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _18 = CheckedSub(_3, _2);\n        assert(!move (_18.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _2) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _17 = move (_18.0: usize);\n        _19 = CheckedSub(_17, 1_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _17, 1_usize) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _16 = move (_19.0: usize);\n        StorageDead(_17);\n        _10 = core::ptr::copy::<core::mem::MaybeUninit<T>>(move _11, move _15, move _16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_11);\n        return;\n    }\n}\n",
  "doc": " Removes and returns a value from a slice of all initialized elements, leaving behind one\n trailing uninitialized element.\n\n # Safety\n The slice has more than `idx` elements.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}