{
  "name": "vec::Vec::<T, A>::retain_mut::process_loop",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "vec::Vec<T, A>::retain_mut::BackshiftOnDrop": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "vec::Vec": [
      "MutRef"
    ]
  },
  "path": 2304,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2285:9: 2318:10",
  "src": "fn process_loop<F, T, A: Allocator, const DELETED: bool>(\n            original_len: usize,\n            f: &mut F,\n            g: &mut BackshiftOnDrop<'_, T, A>,\n        ) where\n            F: FnMut(&mut T) -> bool,\n        {\n            while g.processed_len != original_len {\n                // SAFETY: Unchecked element must be valid.\n                let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n                if !f(cur) {\n                    // Advance early to avoid double drop if `drop_in_place` panicked.\n                    g.processed_len += 1;\n                    g.deleted_cnt += 1;\n                    // SAFETY: We never touch this element again after dropped.\n                    unsafe { ptr::drop_in_place(cur) };\n                    // We already advanced the counter.\n                    if DELETED {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if DELETED {\n                    // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n                    // We use copy for move, and never touch this element again.\n                    unsafe {\n                        let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n                        ptr::copy_nonoverlapping(cur, hole_slot, 1);\n                    }\n                }\n                g.processed_len += 1;\n            }\n        }",
  "mir": "fn vec::Vec::<T, A>::retain_mut::process_loop(_1: usize, _2: &mut F, _3: &mut vec::Vec<T, A>::retain_mut::BackshiftOnDrop<'_, T, A>) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: &mut T;\n    let mut _7: *mut T;\n    let mut _8: *mut T;\n    let mut _9: usize;\n    let mut _10: bool;\n    let mut _11: (&mut T,);\n    let mut _12: (usize, bool);\n    let mut _13: (usize, bool);\n    let  _14: ();\n    let mut _15: *mut T;\n    let  _16: *mut T;\n    let mut _17: *mut T;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let  _22: ();\n    let mut _23: *const T;\n    let mut _24: (usize, bool);\n    let mut _25: &mut vec::Vec<T, A>;\n    let mut _26: &mut vec::Vec<T, A>;\n    debug original_len => _1;\n    debug f => _2;\n    debug g => _3;\n    debug cur => _6;\n    debug hole_slot => _16;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_3).1: usize);\n        _4 = Ne(move _5, _1);\n        switchInt(move _4) -> [0: bb19, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        _25 = ((*_3).0: &mut vec::Vec<T, A>);\n        _8 = vec::Vec::<T, A>::as_mut_ptr(_25) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = ((*_3).1: usize);\n        _7 = core::ptr::mut_ptr::<impl *mut T>::add(move _8, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _6 = &mut (*_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = (_6);\n        _10 = <F as core::ops::FnMut<(&mut T,)>>::call_mut(_2, move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _10) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageDead(_10);\n        switchInt(DELETED) -> [0: bb17, otherwise: bb12];\n    }\n    bb7: {\n        StorageDead(_11);\n        _12 = CheckedAdd(((*_3).1: usize), 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_3).1: usize), 1_usize) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        ((*_3).1: usize) = move (_12.0: usize);\n        _13 = CheckedAdd(((*_3).2: usize), 1_usize);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_3).2: usize), 1_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        ((*_3).2: usize) = move (_13.0: usize);\n        StorageLive(_15);\n        _15 = &raw mut (*_6);\n        _14 = core::ptr::drop_in_place::<T>(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        switchInt(DELETED) -> [0: bb11, otherwise: bb21];\n    }\n    bb11: {\n        StorageDead(_10);\n        StorageDead(_7);\n        goto -> bb20;\n    }\n    bb12: {\n        StorageLive(_17);\n        _26 = ((*_3).0: &mut vec::Vec<T, A>);\n        _17 = vec::Vec::<T, A>::as_mut_ptr(_26) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = ((*_3).1: usize);\n        StorageLive(_20);\n        _20 = ((*_3).2: usize);\n        _21 = CheckedSub(_19, _20);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _19, move _20) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _18 = move (_21.0: usize);\n        StorageDead(_20);\n        StorageDead(_19);\n        _16 = core::ptr::mut_ptr::<impl *mut T>::add(move _17, move _18) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_23);\n        _23 = &raw const (*_6);\n        _22 = core::ptr::copy_nonoverlapping::<T>(move _23, _16, 1_usize) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        goto -> bb17;\n    }\n    bb17: {\n        _24 = CheckedAdd(((*_3).1: usize), 1_usize);\n        assert(!move (_24.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_3).1: usize), 1_usize) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        ((*_3).1: usize) = move (_24.0: usize);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb1;\n    }\n    bb19: {\n        StorageDead(_5);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_4);\n        return;\n    }\n    bb21: {\n        StorageDead(_10);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb1;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}