{
  "name": "collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
  "safe": false,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows a new mutable reference from the unique borrow initially captured.\n\n # Safety\n\n The reborrow must have ended, i.e., the reference returned by `new` and\n all pointers and references derived from it, must not be used anymore.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::new_leaf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>::push_with_handle": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a key-value pair to the end of the node, and returns\n a handle to the inserted value.\n\n # Safety\n\n The returned handle has an unbound lifetime.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Leaf>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::KV>::right_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the rightmost leaf edge in or underneath a node - in other words, the edge\n you need last when navigating forward (or first when navigating backward).\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a new key-value pair between the key-value pairs to the right and left of\n this edge. This method splits the node if there isn't enough room, and tries to\n insert the split off portion into the parent node recursively, until the root is reached.\n\n If the returned result is some `SplitResult`, the `left` field will be the root node.\n The returned pointer points to the inserted value, which in the case of `SplitResult`\n is in the `left` or `right` tree.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2464, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::map::CursorMutKey": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain"
    ]
  },
  "path": 665,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3322:5: 3352:6",
  "src": "pub unsafe fn insert_before_unchecked(&mut self, key: K, value: V) {\n        let edge = match self.current.take() {\n            None => {\n                // SAFETY: We have no other reference to the tree.\n                match unsafe { self.root.reborrow() } {\n                    root @ None => {\n                        // Tree is empty, allocate a new root.\n                        let mut node = NodeRef::new_leaf(self.alloc.clone());\n                        // SAFETY: We don't touch the root while the handle is alive.\n                        let handle = unsafe { node.borrow_mut().push_with_handle(key, value) };\n                        *root = Some(node.forget_type());\n                        *self.length += 1;\n                        self.current = Some(handle.right_edge());\n                        return;\n                    }\n                    Some(root) => root.borrow_mut().last_leaf_edge(),\n                }\n            }\n            Some(current) => current,\n        };\n\n        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n            drop(ins.left);\n            // SAFETY: The handle to the newly inserted value is always on a\n            // leaf node, so adding a new root node doesn't invalidate it.\n            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n        });\n        self.current = Some(handle.right_edge());\n        *self.length += 1;\n    }",
  "mir": "fn collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked(_1: &mut collections::btree::map::CursorMutKey<'_, K, V, A>, _2: K, _3: V) -> () {\n    let mut _0: ();\n    let  _4: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _5: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _6: &mut core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _7: isize;\n    let mut _8: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _9: &mut collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _10: isize;\n    let mut _11: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _12: A;\n    let mut _13: &A;\n    let  _14: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _15: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _16: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _17: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _18: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _19: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _20: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _21: (usize, bool);\n    let mut _22: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _23: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let  _24: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _25: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _26: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let  _27: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _28: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _29: A;\n    let mut _30: &A;\n    let mut _31: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3343:76: 3343:81};\n    let mut _32: &mut collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _33: &A;\n    let mut _34: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _35: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _36: (usize, bool);\n    let mut _37: &mut A;\n    let mut _38: &mut usize;\n    let mut _39: &mut usize;\n    let mut _40: &mut usize;\n    let mut _41: &mut A;\n    let mut _42: &mut A;\n    let mut _43: &mut usize;\n    let mut _44: &mut usize;\n    let mut _45: &mut usize;\n    debug self => _1;\n    debug key => _2;\n    debug value => _3;\n    debug edge => _4;\n    debug root => _8;\n    debug node => _11;\n    debug handle => _14;\n    debug root => _24;\n    debug current => _26;\n    debug handle => _27;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>);\n        _5 = core::option::Option::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::take(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_26);\n        _26 = move ((_5 as variant#1).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        _4 = move _26;\n        StorageDead(_26);\n        goto -> bb17;\n    }\n    bb4: {\n        StorageLive(_9);\n        _9 = &mut ((*_1).1: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        _8 = collections::btree::borrow::DormantMutRef::<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>::reborrow(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _10 = discriminant((*_8));\n        switchInt(move _10) -> [0: bb7, 1: bb6, otherwise: bb2];\n    }\n    bb6: {\n        _24 = &mut (((*_8) as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_25);\n        _25 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_24) -> [return: bb15, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _37 = ((*_1).3: &mut A);\n        _13 = &(*_37);\n        _12 = <A as core::clone::Clone>::clone(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        _11 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::new_leaf::<A>(move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _11;\n        _16 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::borrow_mut(move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _15 = &mut _16;\n        StorageDead(_17);\n        _14 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::push_with_handle::<'_>(move _15, _2, _3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = move _11;\n        _19 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::forget_type(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        _18 = core::option::Option::Some(move _19);\n        StorageDead(_19);\n        (*_8) = move _18;\n        StorageDead(_18);\n        _38 = ((*_1).2: &mut usize);\n        _21 = CheckedAdd((*_38), 1_usize);\n        _39 = ((*_1).2: &mut usize);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (*_39), 1_usize) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _40 = ((*_1).2: &mut usize);\n        (*_40) = move (_21.0: usize);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::right_edge(_14) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _22 = core::option::Option::Some(move _23);\n        StorageDead(_23);\n        ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _22;\n        StorageDead(_22);\n        StorageDead(_11);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb22;\n    }\n    bb15: {\n        _4 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge(move _25) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_25);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_5);\n        StorageLive(_28);\n        _28 = move _4;\n        StorageLive(_29);\n        StorageLive(_30);\n        _41 = ((*_1).3: &mut A);\n        _30 = &(*_41);\n        _29 = <A as core::clone::Clone>::clone(move _30) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &mut ((*_1).1: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        StorageLive(_33);\n        _42 = ((*_1).3: &mut A);\n        _33 = &(*_42);\n        _31 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3343:76: 3343:81}(move _32, move _33);\n        StorageDead(_33);\n        StorageDead(_32);\n        _27 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing::<A, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3343:76: 3343:81}>(move _28, _2, _3, move _29, move _31) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_31);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::right_edge(_27) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _34 = core::option::Option::Some(move _35);\n        StorageDead(_35);\n        ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _34;\n        StorageDead(_34);\n        _43 = ((*_1).2: &mut usize);\n        _36 = CheckedAdd((*_43), 1_usize);\n        _44 = ((*_1).2: &mut usize);\n        assert(!move (_36.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (*_44), 1_usize) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _45 = ((*_1).2: &mut usize);\n        (*_45) = move (_36.0: usize);\n        StorageDead(_4);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": " Inserts a new key-value pair into the map in the gap that the\n cursor is currently pointing to.\n\n After the insertion the cursor will be pointing at the gap after the\n newly inserted element.\n\n # Safety\n\n You must ensure that the `BTreeMap` invariants are maintained.\n Specifically:\n\n * The key of the newly inserted element must be unique in the tree.\n * All keys in the tree must remain in sorted order.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}