{
  "name": "<ffi::c_str::CString as core::convert::From<vec::Vec<core::num::NonZero<u8>>>>::from",
  "safe": true,
  "callees": {
    "vec::Vec::<T>::into_raw_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Decomposes a `Vec<T>` into its raw components: `(pointer, length, capacity)`.\n\n Returns the raw pointer to the underlying data, the length of\n the vector (in elements), and the allocated capacity of the\n data (in elements). These are the same arguments in the same\n order as the arguments to [`from_raw_parts`].\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Vec`. Most often, one does\n this by converting the raw pointer, length, and capacity back\n into a `Vec` with the [`from_raw_parts`] function; more generally,\n if `T` is non-zero-sized and the capacity is nonzero, one may use\n any method that calls [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)`; if `T` is zero-sized or the\n capacity is zero, nothing needs to be done.\n\n [`from_raw_parts`]: Vec::from_raw_parts\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n\n # Examples\n\n ```\n let v: Vec<i32> = vec![-1, 0, 1];\n\n let (ptr, len, cap) = v.into_raw_parts();\n\n let rebuilt = unsafe {\n     // We can now make changes to the components, such as\n     // transmuting the raw pointer to a compatible type.\n     let ptr = ptr as *mut u32;\n\n     Vec::from_raw_parts(ptr, len, cap)\n };\n assert_eq!(rebuilt, [4294967295, 0, 1]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "vec::Vec::<T>::from_raw_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `Vec<T>` directly from a pointer, a length, and a capacity.\n\n # Safety\n\n This is highly unsafe, due to the number of invariants that aren't\n checked:\n\n * If `T` is not a zero-sized type and the capacity is nonzero, `ptr` must have\n   been allocated using the global allocator, such as via the [`alloc::alloc`]\n   function. If `T` is a zero-sized type or the capacity is zero, `ptr` need\n   only be non-null and aligned.\n * `T` needs to have the same alignment as what `ptr` was allocated with,\n   if the pointer is required to be allocated.\n   (`T` having a less strict alignment is not sufficient, the alignment really\n   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n   allocated and deallocated with the same layout.)\n * The size of `T` times the `capacity` (ie. the allocated size in bytes), if\n   nonzero, needs to be the same size as the pointer was allocated with.\n   (Because similar to alignment, [`dealloc`] must be called with the same\n   layout `size`.)\n * `length` needs to be less than or equal to `capacity`.\n * The first `length` values must be properly initialized values of type `T`.\n * `capacity` needs to be the capacity that the pointer was allocated with,\n   if the pointer is required to be allocated.\n * The allocated size in bytes must be no larger than `isize::MAX`.\n   See the safety documentation of [`pointer::offset`].\n\n These requirements are always upheld by any `ptr` that has been allocated\n via `Vec<T>`. Other allocation sources are allowed if the invariants are\n upheld.\n\n Violating these may cause problems like corrupting the allocator's\n internal data structures. For example it is normally **not** safe\n to build a `Vec<u8>` from a pointer to a C `char` array with length\n `size_t`, doing so is only safe if the array was initially allocated by\n a `Vec` or `String`.\n It's also not safe to build one from a `Vec<u16>` and its length, because\n the allocator cares about the alignment, and these two types have different\n alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n turning it into a `Vec<u8>` it'll be deallocated with alignment 1. To avoid\n these issues, it is often preferable to do casting/transmuting using\n [`slice::from_raw_parts`] instead.\n\n The ownership of `ptr` is effectively transferred to the\n `Vec<T>` which may then deallocate, reallocate or change the\n contents of memory pointed to by the pointer at will. Ensure\n that nothing else uses the pointer after calling this\n function.\n\n [`String`]: crate::string::String\n [`alloc::alloc`]: crate::alloc::alloc\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n\n # Examples\n\n ```\n use std::ptr;\n\n let v = vec![1, 2, 3];\n\n // Deconstruct the vector into parts.\n let (p, len, cap) = v.into_raw_parts();\n\n unsafe {\n     // Overwrite memory with 4, 5, 6\n     for i in 0..len {\n         ptr::write(p.add(i), 4 + i);\n     }\n\n     // Put everything back together into a Vec\n     let rebuilt = Vec::from_raw_parts(p, len, cap);\n     assert_eq!(rebuilt, [4, 5, 6]);\n }\n ```\n\n Using memory that was allocated elsewhere:\n\n ```rust\n use std::alloc::{alloc, Layout};\n\n fn main() {\n     let layout = Layout::array::<u32>(16).expect(\"overflow cannot happen\");\n\n     let vec = unsafe {\n         let mem = alloc(layout).cast::<u32>();\n         if mem.is_null() {\n             return;\n         }\n\n         mem.write(1_000_000);\n\n         Vec::from_raw_parts(mem, 1, 16)\n     };\n\n     assert_eq!(vec, &[1_000_000]);\n     assert_eq!(vec.capacity(), 16);\n }\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "ffi::c_str::CString::_from_vec_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "vec::Vec": "MutableAsArgument",
        "ffi::c_str::CString": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Plain"
    ],
    "ffi::c_str::CString": [
      "Plain"
    ]
  },
  "path": 1570,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/ffi/c_str.rs:810:5: 824:6",
  "src": "fn from(v: Vec<NonZero<u8>>) -> CString {\n        unsafe {\n            // Transmute `Vec<NonZero<u8>>` to `Vec<u8>`.\n            let v: Vec<u8> = {\n                // SAFETY:\n                //   - transmuting between `NonZero<u8>` and `u8` is sound;\n                //   - `alloc::Layout<NonZero<u8>> == alloc::Layout<u8>`.\n                let (ptr, len, cap): (*mut NonZero<u8>, _, _) = Vec::into_raw_parts(v);\n                Vec::from_raw_parts(ptr.cast::<u8>(), len, cap)\n            };\n            // SAFETY: `v` cannot contain nul bytes, given the type-level\n            // invariant of `NonZero<u8>`.\n            Self::_from_vec_unchecked(v)\n        }\n    }",
  "mir": "fn <ffi::c_str::CString as core::convert::From<vec::Vec<core::num::NonZero<u8>>>>::from(_1: vec::Vec<core::num::NonZero<u8>>) -> ffi::c_str::CString {\n    let mut _0: ffi::c_str::CString;\n    let  _2: vec::Vec<u8>;\n    let  _3: *mut core::num::NonZero<u8>;\n    let  _4: usize;\n    let  _5: usize;\n    let mut _6: (*mut core::num::NonZero<u8>, usize, usize);\n    let mut _7: *mut u8;\n    debug v => _1;\n    debug v => _2;\n    debug ptr => _3;\n    debug len => _4;\n    debug cap => _5;\n    bb0: {\n        StorageLive(_6);\n        _6 = vec::Vec::<core::num::NonZero<u8>>::into_raw_parts(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = (_6.0: *mut core::num::NonZero<u8>);\n        _4 = (_6.1: usize);\n        _5 = (_6.2: usize);\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = core::ptr::mut_ptr::<impl *mut core::num::NonZero<u8>>::cast::<u8>(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _2 = vec::Vec::<u8>::from_raw_parts(move _7, _4, _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _0 = ffi::c_str::CString::_from_vec_unchecked(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": " Converts a <code>[Vec]<[NonZero]<[u8]>></code> into a [`CString`] without\n copying nor checking for inner nul bytes.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}