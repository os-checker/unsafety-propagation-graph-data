{
  "name": "sync::arcinner_layout_for_value_layout",
  "safe": true,
  "callees": {
    "core::alloc::Layout::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a `Layout` suitable for holding a value of type `T`.\n",
      "adt": {}
    },
    "core::alloc::Layout::extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout describing the record for `self` followed by\n `next`, including any necessary padding to ensure that `next`\n will be properly aligned, but *no trailing padding*.\n\n In order to match C representation layout `repr(C)`, you should\n call `pad_to_align` after extending the layout with all fields.\n (There is no way to match the default Rust representation\n layout `repr(Rust)`, as it is unspecified.)\n\n Note that the alignment of the resulting layout will be the maximum of\n those of `self` and `next`, in order to ensure alignment of both parts.\n\n Returns `Ok((k, offset))`, where `k` is layout of the concatenated\n record and `offset` is the relative location, in bytes, of the\n start of the `next` embedded within the concatenated record\n (assuming that the record itself starts at offset 0).\n\n On arithmetic overflow, returns `LayoutError`.\n\n # Examples\n\n To calculate the layout of a `#[repr(C)]` structure and the offsets of\n the fields from its fields' layouts:\n\n ```rust\n # use std::alloc::{Layout, LayoutError};\n pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutError> {\n     let mut offsets = Vec::new();\n     let mut layout = Layout::from_size_align(0, 1)?;\n     for &field in fields {\n         let (new_layout, offset) = layout.extend(field)?;\n         layout = new_layout;\n         offsets.push(offset);\n     }\n     // Remember to finalize with `pad_to_align`!\n     Ok((layout.pad_to_align(), offsets))\n }\n # // test that it works\n # #[repr(C)] struct S { a: u64, b: u32, c: u16, d: u32 }\n # let s = Layout::new::<S>();\n # let u16 = Layout::new::<u16>();\n # let u32 = Layout::new::<u32>();\n # let u64 = Layout::new::<u64>();\n # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::pad_to_align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout by rounding the size of this layout up to a multiple\n of the layout's alignment.\n\n This is equivalent to adding the result of `padding_needed_for`\n to the layout's current size.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) })])"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2007,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:395:1: 401:2",
  "src": "fn arcinner_layout_for_value_layout(layout: Layout) -> Layout {\n    // Calculate layout using the given value layout.\n    // Previously, layout was calculated on the expression\n    // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n    // reference (see #54908).\n    Layout::new::<ArcInner<()>>().extend(layout).unwrap().0.pad_to_align()\n}",
  "mir": "fn sync::arcinner_layout_for_value_layout(_1: core::alloc::Layout) -> core::alloc::Layout {\n    let mut _0: core::alloc::Layout;\n    let mut _2: &core::alloc::Layout;\n    let  _3: (core::alloc::Layout, usize);\n    let mut _4: core::result::Result<(core::alloc::Layout, usize), core::alloc::LayoutError>;\n    let mut _5: &core::alloc::Layout;\n    let  _6: core::alloc::Layout;\n    debug layout => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = core::alloc::Layout::new::<sync::ArcInner<()>>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &_6;\n        _4 = core::alloc::Layout::extend(move _5, _1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = core::result::Result::<(core::alloc::Layout, usize), core::alloc::LayoutError>::unwrap(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _2 = &(_3.0: core::alloc::Layout);\n        _0 = core::alloc::Layout::pad_to_align(move _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Calculate layout for `ArcInner<T>` using the inner value's layout\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}