{
  "name": "str::join_generic_copy",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "core::num::<impl usize>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::and_then": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n wrapped value and returns the result.\n\n Some languages call this operation flatmap.\n\n # Examples\n\n ```\n fn sq_then_to_string(x: u32) -> Option<String> {\n     x.checked_mul(x).map(|sq| sq.to_string())\n }\n\n assert_eq!(Some(2).and_then(sq_then_to_string), Some(4.to_string()));\n assert_eq!(Some(1_000_000).and_then(sq_then_to_string), None); // overflowed!\n assert_eq!(None.and_then(sq_then_to_string), None);\n ```\n\n Often used to chain fallible operations that may return [`None`].\n\n ```\n let arr_2d = [[\"A0\", \"A1\"], [\"B0\", \"B1\"]];\n\n let item_0_1 = arr_2d.get(0).and_then(|row| row.get(1));\n assert_eq!(item_0_1, Some(&\"A1\"));\n\n let item_2_0 = arr_2d.get(2).and_then(|row| row.get(0));\n assert_eq!(item_2_0, None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "core::borrow::Borrow::borrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Immutably borrows from an owned value.\n\n # Examples\n\n ```\n use std::borrow::Borrow;\n\n fn check<T: Borrow<str>>(s: T) {\n     assert_eq!(\"Hello\", s.borrow());\n }\n\n let s = \"Hello\".to_string();\n\n check(s);\n\n let s = \"Hello\";\n\n check(s);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::extend_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clones and appends all elements in a slice to the `Vec`.\n\n Iterates over the slice `other`, clones each element, and then appends\n it to this `Vec`. The `other` slice is traversed in-order.\n\n Note that this function is the same as [`extend`],\n except that it also works with slice elements that are Clone but not Copy.\n If Rust gets specialization this function may be deprecated.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.extend_from_slice(&[2, 3, 4]);\n assert_eq!(vec, [1, 2, 3, 4]);\n ```\n\n [`extend`]: Vec::extend\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::spare_capacity_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the remaining spare capacity of the vector as a slice of\n `MaybeUninit<T>`.\n\n The returned slice can be used to fill the vector with data (e.g. by\n reading from a file) before marking the data as initialized using the\n [`set_len`] method.\n\n [`set_len`]: Vec::set_len\n\n # Examples\n\n ```\n // Allocate vector big enough for 10 elements.\n let mut v = Vec::with_capacity(10);\n\n // Fill in the first 3 elements.\n let uninit = v.spare_capacity_mut();\n uninit[0].write(0);\n uninit[1].write(1);\n uninit[2].write(2);\n\n // Mark the first 3 elements of the vector as being initialized.\n unsafe {\n     v.set_len(3);\n }\n\n assert_eq!(&v, &[0, 1, 2]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::get_unchecked_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to an element or subslice, without doing\n bounds checking.\n\n For a safe alternative see [`get_mut`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get_mut(index).unwrap_unchecked()`.  It's\n UB to call `.get_unchecked_mut(len)`, even if you immediately convert\n to a pointer.  And it's UB to call `.get_unchecked_mut(..len + 1)`,\n `.get_unchecked_mut(..=len)`, or similar.\n\n [`get_mut`]: slice::get_mut\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n\n unsafe {\n     let elem = x.get_unchecked_mut(1);\n     *elem = 13;\n }\n assert_eq!(x, &[1, 13, 4]);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::slice::from_raw_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for reads for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations. See [below](#incorrect-usage)\n       for an example incorrectly not taking this into account.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be mutated for the duration\n   of lifetime `'a`, except inside an `UnsafeCell`.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To\n prevent accidental misuse, it's suggested to tie the lifetime to whichever\n source lifetime is safe in the context, such as by providing a helper\n function taking the lifetime of a host value for the slice, or by explicit\n annotation.\n\n # Examples\n\n ```\n use std::slice;\n\n // manifest a slice for a single element\n let x = 42;\n let ptr = &x as *const _;\n let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n assert_eq!(slice[0], 42);\n ```\n\n ### Incorrect usage\n\n The following `join_slices` function is **unsound** ⚠️\n\n ```rust,no_run\n use std::slice;\n\n fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n     let snd_start = snd.as_ptr();\n     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n     unsafe {\n         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n         // still be contained within _different allocations_, in which case\n         // creating this slice is undefined behavior.\n         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n     }\n }\n\n fn main() {\n     // `a` and `b` are different allocations...\n     let a = 42;\n     let b = 27;\n     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n }\n ```\n\n ### FFI: Handling null pointers\n\n In languages such as C++, pointers to empty collections are not guaranteed to be non-null.\n When accepting such pointers, they have to be checked for null-ness to avoid undefined\n behavior.\n\n ```\n use std::slice;\n\n /// Sum the elements of an FFI slice.\n ///\n /// # Safety\n ///\n /// If ptr is not NULL, it must be correctly aligned and\n /// point to `len` initialized items of type `f32`.\n unsafe extern \"C\" fn sum_slice(ptr: *const f32, len: usize) -> f32 {\n     let data = if ptr.is_null() {\n         // `len` is assumed to be 0.\n         &[]\n     } else {\n         // SAFETY: see function docstring.\n         unsafe { slice::from_raw_parts(ptr, len) }\n     };\n     data.into_iter().sum()\n }\n\n // This could be the result of C++'s std::vector::data():\n let ptr = std::ptr::null();\n // And this could be std::vector::size():\n let len = 0;\n assert_eq!(unsafe { sum_slice(ptr, len) }, 0.0);\n ```\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_mut_checked`](slice::split_at_mut_checked).\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n let (left, right) = v.split_at_mut(2);\n assert_eq!(left, [1, 0]);\n assert_eq!(right, [3, 0, 5, 6]);\n left[1] = 2;\n right[1] = 4;\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::copy_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies all elements from `src` into `self`, using a memcpy.\n\n The length of `src` must be the same as `self`.\n\n If `T` does not implement `Copy`, use [`clone_from_slice`].\n\n # Panics\n\n This function will panic if the two slices have different lengths.\n\n # Examples\n\n Copying two elements from a slice into another:\n\n ```\n let src = [1, 2, 3, 4];\n let mut dst = [0, 0];\n\n // Because the slices have to be the same length,\n // we slice the source slice from four elements\n // to two. It will panic if we don't do this.\n dst.copy_from_slice(&src[2..]);\n\n assert_eq!(src, [1, 2, 3, 4]);\n assert_eq!(dst, [3, 4]);\n ```\n\n Rust enforces that there can only be one mutable reference with no\n immutable references to a particular piece of data in a particular\n scope. Because of this, attempting to use `copy_from_slice` on a\n single slice will result in a compile failure:\n\n ```compile_fail\n let mut slice = [1, 2, 3, 4, 5];\n\n slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n ```\n\n To work around this, we can use [`split_at_mut`] to create two distinct\n sub-slices from a slice:\n\n ```\n let mut slice = [1, 2, 3, 4, 5];\n\n {\n     let (left, right) = slice.split_at_mut(2);\n     left.copy_from_slice(&right[1..]);\n }\n\n assert_eq!(slice, [4, 5, 3, 4, 5]);\n ```\n\n [`clone_from_slice`]: slice::clone_from_slice\n [`split_at_mut`]: slice::split_at_mut\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "core::slice::Iter": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8496, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 8490, kind: Param(ParamTy { index: 2, name: \"S\" }) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8514, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 8534, kind: RigidTy(Slice(Ty { id: 4764, kind: RigidTy(Adt(AdtDef(DefId { id: 2984, name: \"core::mem::MaybeUninit\" }), GenericArgs([Type(Ty { id: 110, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })) }, Not)) })])"
    ],
    "vec::Vec": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::str::join_generic_copy"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:130:1: 186:2",
  "src": "fn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\nwhere\n    T: Copy,\n    B: AsRef<[T]> + ?Sized,\n    S: Borrow<B>,\n{\n    let sep_len = sep.len();\n    let mut iter = slice.iter();\n\n    // the first slice is the only one without a separator preceding it\n    let first = match iter.next() {\n        Some(first) => first,\n        None => return vec![],\n    };\n\n    // compute the exact total length of the joined Vec\n    // if the `len` calculation overflows, we'll panic\n    // we would have run out of memory anyway and the rest of the function requires\n    // the entire Vec pre-allocated for safety\n    let reserved_len = sep_len\n        .checked_mul(iter.len())\n        .and_then(|n| {\n            slice.iter().map(|s| s.borrow().as_ref().len()).try_fold(n, usize::checked_add)\n        })\n        .expect(\"attempt to join into collection with len > usize::MAX\");\n\n    // prepare an uninitialized buffer\n    let mut result = Vec::with_capacity(reserved_len);\n    debug_assert!(result.capacity() >= reserved_len);\n\n    result.extend_from_slice(first.borrow().as_ref());\n\n    unsafe {\n        let pos = result.len();\n        let target = result.spare_capacity_mut().get_unchecked_mut(..reserved_len - pos);\n\n        // Convert the separator and slices to slices of MaybeUninit\n        // to simplify implementation in specialize_for_lengths\n        let sep_uninit = core::slice::from_raw_parts(sep.as_ptr().cast(), sep.len());\n        let iter_uninit = iter.map(|it| {\n            let it = it.borrow().as_ref();\n            core::slice::from_raw_parts(it.as_ptr().cast(), it.len())\n        });\n\n        // copy separator and slices over without bounds checks\n        // generate loops with hardcoded offsets for small separators\n        // massive improvements possible (~ x2)\n        let remain = specialize_for_lengths!(sep_uninit, target, iter_uninit; 0, 1, 2, 3, 4);\n\n        // A weird borrow implementation may return different\n        // slices for the length calculation and the actual copy.\n        // Make sure we don't expose uninitialized bytes to the caller.\n        let result_len = reserved_len - remain.len();\n        result.set_len(result_len);\n    }\n    result\n}",
  "mir": "fn str::join_generic_copy(_1: &[S], _2: &[T]) -> vec::Vec<T> {\n    let mut _0: vec::Vec<T>;\n    let  _3: usize;\n    let mut _4: core::slice::Iter<'_, S>;\n    let mut _5: core::option::Option<&S>;\n    let mut _6: &mut core::slice::Iter<'_, S>;\n    let mut _7: isize;\n    let  _8: &S;\n    let  _9: usize;\n    let mut _10: core::option::Option<usize>;\n    let mut _11: core::option::Option<usize>;\n    let mut _12: usize;\n    let mut _13: &core::slice::Iter<'_, S>;\n    let mut _14: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:151:19: 151:22};\n    let mut _15: &str;\n    let mut _16: vec::Vec<T>;\n    let mut _17: bool;\n    let mut _18: usize;\n    let mut _19: &vec::Vec<T>;\n    let mut _20: !;\n    let  _21: ();\n    let mut _22: &mut vec::Vec<T>;\n    let  _23: &[T];\n    let  _24: &B;\n    let  _25: usize;\n    let mut _26: &vec::Vec<T>;\n    let  _27: &mut [core::mem::MaybeUninit<T>];\n    let mut _28: &mut [core::mem::MaybeUninit<T>];\n    let mut _29: &mut vec::Vec<T>;\n    let mut _30: core::ops::RangeTo<usize>;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    let  _33: &[core::mem::MaybeUninit<T>];\n    let mut _34: *const core::mem::MaybeUninit<T>;\n    let mut _35: *const T;\n    let mut _36: usize;\n    let  _37: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _38: core::slice::Iter<'_, S>;\n    let mut _39: &mut [core::mem::MaybeUninit<T>];\n    let mut _40: &mut [core::mem::MaybeUninit<T>];\n    let mut _41: usize;\n    let mut _42: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _43: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _44: core::option::Option<&[core::mem::MaybeUninit<T>]>;\n    let mut _45: &mut core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _46: isize;\n    let  _47: &[core::mem::MaybeUninit<T>];\n    let  _48: usize;\n    let  _49: &mut [core::mem::MaybeUninit<T>];\n    let  _50: &mut [core::mem::MaybeUninit<T>];\n    let mut _51: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _52: &mut [core::mem::MaybeUninit<T>];\n    let  _53: ();\n    let  _54: &[core::mem::MaybeUninit<T>];\n    let  _55: &[core::mem::MaybeUninit<T>];\n    let  _56: usize;\n    let  _57: &mut [core::mem::MaybeUninit<T>];\n    let  _58: &mut [core::mem::MaybeUninit<T>];\n    let mut _59: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _60: &mut [core::mem::MaybeUninit<T>];\n    let  _61: ();\n    let mut _62: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _63: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _64: core::option::Option<&[core::mem::MaybeUninit<T>]>;\n    let mut _65: &mut core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _66: isize;\n    let  _67: &[core::mem::MaybeUninit<T>];\n    let  _68: usize;\n    let  _69: &mut [core::mem::MaybeUninit<T>];\n    let  _70: &mut [core::mem::MaybeUninit<T>];\n    let mut _71: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _72: &mut [core::mem::MaybeUninit<T>];\n    let  _73: ();\n    let  _74: &[core::mem::MaybeUninit<T>];\n    let  _75: &[core::mem::MaybeUninit<T>];\n    let  _76: usize;\n    let  _77: &mut [core::mem::MaybeUninit<T>];\n    let  _78: &mut [core::mem::MaybeUninit<T>];\n    let mut _79: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _80: &mut [core::mem::MaybeUninit<T>];\n    let  _81: ();\n    let mut _82: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _83: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _84: core::option::Option<&[core::mem::MaybeUninit<T>]>;\n    let mut _85: &mut core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _86: isize;\n    let  _87: &[core::mem::MaybeUninit<T>];\n    let  _88: usize;\n    let  _89: &mut [core::mem::MaybeUninit<T>];\n    let  _90: &mut [core::mem::MaybeUninit<T>];\n    let mut _91: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _92: &mut [core::mem::MaybeUninit<T>];\n    let  _93: ();\n    let  _94: &[core::mem::MaybeUninit<T>];\n    let  _95: &[core::mem::MaybeUninit<T>];\n    let  _96: usize;\n    let  _97: &mut [core::mem::MaybeUninit<T>];\n    let  _98: &mut [core::mem::MaybeUninit<T>];\n    let mut _99: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _100: &mut [core::mem::MaybeUninit<T>];\n    let  _101: ();\n    let mut _102: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _103: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _104: core::option::Option<&[core::mem::MaybeUninit<T>]>;\n    let mut _105: &mut core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _106: isize;\n    let  _107: &[core::mem::MaybeUninit<T>];\n    let  _108: usize;\n    let  _109: &mut [core::mem::MaybeUninit<T>];\n    let  _110: &mut [core::mem::MaybeUninit<T>];\n    let mut _111: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _112: &mut [core::mem::MaybeUninit<T>];\n    let  _113: ();\n    let  _114: &[core::mem::MaybeUninit<T>];\n    let  _115: &[core::mem::MaybeUninit<T>];\n    let  _116: usize;\n    let  _117: &mut [core::mem::MaybeUninit<T>];\n    let  _118: &mut [core::mem::MaybeUninit<T>];\n    let mut _119: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _120: &mut [core::mem::MaybeUninit<T>];\n    let  _121: ();\n    let mut _122: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _123: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _124: core::option::Option<&[core::mem::MaybeUninit<T>]>;\n    let mut _125: &mut core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _126: isize;\n    let  _127: &[core::mem::MaybeUninit<T>];\n    let  _128: usize;\n    let  _129: &mut [core::mem::MaybeUninit<T>];\n    let  _130: &mut [core::mem::MaybeUninit<T>];\n    let mut _131: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _132: &mut [core::mem::MaybeUninit<T>];\n    let  _133: ();\n    let  _134: &[core::mem::MaybeUninit<T>];\n    let  _135: &[core::mem::MaybeUninit<T>];\n    let  _136: usize;\n    let  _137: &mut [core::mem::MaybeUninit<T>];\n    let  _138: &mut [core::mem::MaybeUninit<T>];\n    let mut _139: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _140: &mut [core::mem::MaybeUninit<T>];\n    let  _141: ();\n    let mut _142: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _143: core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _144: core::option::Option<&[core::mem::MaybeUninit<T>]>;\n    let mut _145: &mut core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>;\n    let mut _146: isize;\n    let  _147: &[core::mem::MaybeUninit<T>];\n    let  _148: usize;\n    let  _149: &mut [core::mem::MaybeUninit<T>];\n    let  _150: &mut [core::mem::MaybeUninit<T>];\n    let mut _151: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _152: &mut [core::mem::MaybeUninit<T>];\n    let  _153: ();\n    let  _154: &[core::mem::MaybeUninit<T>];\n    let  _155: &[core::mem::MaybeUninit<T>];\n    let  _156: usize;\n    let  _157: &mut [core::mem::MaybeUninit<T>];\n    let  _158: &mut [core::mem::MaybeUninit<T>];\n    let mut _159: (&mut [core::mem::MaybeUninit<T>], &mut [core::mem::MaybeUninit<T>]);\n    let mut _160: &mut [core::mem::MaybeUninit<T>];\n    let  _161: ();\n    let  _162: usize;\n    let mut _163: usize;\n    let mut _164: &[core::mem::MaybeUninit<T>];\n    let mut _165: (usize, bool);\n    let  _166: ();\n    let mut _167: &mut vec::Vec<T>;\n    debug slice => _1;\n    debug sep => _2;\n    debug sep_len => _3;\n    debug iter => _4;\n    debug first => _8;\n    debug first => _8;\n    debug reserved_len => _9;\n    debug result => _16;\n    debug pos => _25;\n    debug target => _27;\n    debug sep_uninit => _33;\n    debug iter_uninit => _37;\n    debug remain => _39;\n    debug target => _40;\n    debug iter => _37;\n    debug sep_bytes => _33;\n    debug iter => _43;\n    debug s => _47;\n    debug len => _48;\n    debug head => _49;\n    debug tail => _50;\n    debug content_bytes => _54;\n    debug len => _56;\n    debug head => _57;\n    debug tail => _58;\n    debug iter => _63;\n    debug s => _67;\n    debug len => _68;\n    debug head => _69;\n    debug tail => _70;\n    debug content_bytes => _74;\n    debug len => _76;\n    debug head => _77;\n    debug tail => _78;\n    debug iter => _83;\n    debug s => _87;\n    debug len => _88;\n    debug head => _89;\n    debug tail => _90;\n    debug content_bytes => _94;\n    debug len => _96;\n    debug head => _97;\n    debug tail => _98;\n    debug iter => _103;\n    debug s => _107;\n    debug len => _108;\n    debug head => _109;\n    debug tail => _110;\n    debug content_bytes => _114;\n    debug len => _116;\n    debug head => _117;\n    debug tail => _118;\n    debug iter => _123;\n    debug s => _127;\n    debug len => _128;\n    debug head => _129;\n    debug tail => _130;\n    debug content_bytes => _134;\n    debug len => _136;\n    debug head => _137;\n    debug tail => _138;\n    debug iter => _143;\n    debug s => _147;\n    debug len => _148;\n    debug head => _149;\n    debug tail => _150;\n    debug content_bytes => _154;\n    debug len => _156;\n    debug head => _157;\n    debug tail => _158;\n    debug result_len => _162;\n    bb0: {\n        _3 = PtrMetadata(_2);\n        StorageLive(_4);\n        _4 = core::slice::<impl [S]>::iter(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut _4;\n        _5 = <core::slice::Iter<'_, S> as core::iter::Iterator>::next(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _0 = vec::Vec::<T>::new() -> [return: bb100, unwind unreachable];\n    }\n    bb5: {\n        _8 = ((_5 as variant#1).0: &S);\n        StorageDead(_5);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_4;\n        _12 = <core::slice::Iter<'_, S> as core::iter::ExactSizeIterator>::len(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _11 = core::num::<impl usize>::checked_mul(_3, move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageLive(_14);\n        _14 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:151:19: 151:22}(_1);\n        _10 = core::option::Option::<usize>::and_then::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:151:19: 151:22}>(move _11, move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = \"attempt to join into collection with len > usize::MAX\";\n        _9 = core::option::Option::<usize>::expect(move _10, move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageDead(_10);\n        StorageLive(_16);\n        _16 = vec::Vec::<T>::with_capacity(_9) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_16;\n        _18 = vec::Vec::<T>::capacity(move _19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        _17 = Ge(move _18, _9);\n        switchInt(move _17) -> [0: bb13, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_22);\n        _22 = &mut _16;\n        _24 = <S as core::borrow::Borrow<B>>::borrow(_8) -> [return: bb14, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        _20 = core::panicking::panic(\"assertion failed: result.capacity() >= reserved_len\") -> unwind unreachable;\n    }\n    bb14: {\n        _23 = <B as core::convert::AsRef<[T]>>::as_ref(_24) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _21 = vec::Vec::<T>::extend_from_slice(move _22, _23) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageLive(_26);\n        _26 = &_16;\n        _25 = vec::Vec::<T>::len(move _26) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_26);\n        StorageLive(_27);\n        StorageLive(_29);\n        _29 = &mut _16;\n        _28 = vec::Vec::<T>::spare_capacity_mut(move _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _32 = CheckedSub(_9, _25);\n        assert(!move (_32.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _9, _25) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _31 = move (_32.0: usize);\n        _30 = RangeTo(move _31);\n        StorageDead(_31);\n        _27 = core::slice::<impl [core::mem::MaybeUninit<T>]>::get_unchecked_mut::<core::ops::RangeTo<usize>>(_28, move _30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_30);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = core::slice::<impl [T]>::as_ptr(_2) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _34 = core::ptr::const_ptr::<impl *const T>::cast::<core::mem::MaybeUninit<T>>(move _35) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_35);\n        StorageLive(_36);\n        _36 = PtrMetadata(_2);\n        _33 = core::slice::from_raw_parts::<'_, core::mem::MaybeUninit<T>>(move _34, move _36) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_36);\n        StorageDead(_34);\n        StorageLive(_38);\n        _38 = move _4;\n        _37 = <core::slice::Iter<'_, S> as core::iter::Iterator>::map::<&[core::mem::MaybeUninit<T>], {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}>(move _38, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_38);\n        StorageLive(_40);\n        _40 = move _27;\n        StorageLive(_41);\n        _41 = PtrMetadata(_33);\n        switchInt(_41) -> [0: bb30, 1: bb29, 2: bb28, 3: bb27, 4: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageLive(_142);\n        _142 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::IntoIterator>::into_iter(_37) -> [return: bb86, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_122);\n        _122 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::IntoIterator>::into_iter(_37) -> [return: bb75, unwind unreachable];\n    }\n    bb27: {\n        StorageLive(_102);\n        _102 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::IntoIterator>::into_iter(_37) -> [return: bb64, unwind unreachable];\n    }\n    bb28: {\n        StorageLive(_82);\n        _82 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::IntoIterator>::into_iter(_37) -> [return: bb53, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_62);\n        _62 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::IntoIterator>::into_iter(_37) -> [return: bb42, unwind unreachable];\n    }\n    bb30: {\n        StorageLive(_42);\n        _42 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::IntoIterator>::into_iter(_37) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageLive(_43);\n        _43 = move _42;\n        goto -> bb32;\n    }\n    bb32: {\n        StorageLive(_44);\n        _45 = &mut _43;\n        _44 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::Iterator>::next(_45) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        _46 = discriminant(_44);\n        switchInt(move _46) -> [0: bb35, 1: bb34, otherwise: bb3];\n    }\n    bb34: {\n        _47 = ((_44 as variant#1).0: &[core::mem::MaybeUninit<T>]);\n        _48 = PtrMetadata(_33);\n        StorageLive(_51);\n        _52 = move _40;\n        _51 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_52, _48) -> [return: bb36, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageDead(_42);\n        goto -> bb97;\n    }\n    bb36: {\n        _49 = move (_51.0: &mut [core::mem::MaybeUninit<T>]);\n        _50 = move (_51.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_51);\n        _53 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_49, _33) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _40 = _50;\n        _55 = <[core::mem::MaybeUninit<T>] as core::borrow::Borrow<[core::mem::MaybeUninit<T>]>>::borrow(_47) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        _54 = <[core::mem::MaybeUninit<T>] as core::convert::AsRef<[core::mem::MaybeUninit<T>]>>::as_ref(_55) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _56 = PtrMetadata(_54);\n        StorageLive(_59);\n        _60 = move _40;\n        _59 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_60, _56) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _57 = move (_59.0: &mut [core::mem::MaybeUninit<T>]);\n        _58 = move (_59.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_59);\n        _61 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_57, _54) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _40 = _58;\n        StorageDead(_44);\n        goto -> bb32;\n    }\n    bb42: {\n        StorageLive(_63);\n        _63 = move _62;\n        goto -> bb43;\n    }\n    bb43: {\n        StorageLive(_64);\n        _65 = &mut _63;\n        _64 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::Iterator>::next(_65) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _66 = discriminant(_64);\n        switchInt(move _66) -> [0: bb46, 1: bb45, otherwise: bb3];\n    }\n    bb45: {\n        _67 = ((_64 as variant#1).0: &[core::mem::MaybeUninit<T>]);\n        _68 = PtrMetadata(_33);\n        StorageLive(_71);\n        _72 = move _40;\n        _71 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_72, _68) -> [return: bb47, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageDead(_62);\n        goto -> bb97;\n    }\n    bb47: {\n        _69 = move (_71.0: &mut [core::mem::MaybeUninit<T>]);\n        _70 = move (_71.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_71);\n        _73 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_69, _33) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        _40 = _70;\n        _75 = <[core::mem::MaybeUninit<T>] as core::borrow::Borrow<[core::mem::MaybeUninit<T>]>>::borrow(_67) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _74 = <[core::mem::MaybeUninit<T>] as core::convert::AsRef<[core::mem::MaybeUninit<T>]>>::as_ref(_75) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _76 = PtrMetadata(_74);\n        StorageLive(_79);\n        _80 = move _40;\n        _79 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_80, _76) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        _77 = move (_79.0: &mut [core::mem::MaybeUninit<T>]);\n        _78 = move (_79.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_79);\n        _81 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_77, _74) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        _40 = _78;\n        StorageDead(_64);\n        goto -> bb43;\n    }\n    bb53: {\n        StorageLive(_83);\n        _83 = move _82;\n        goto -> bb54;\n    }\n    bb54: {\n        StorageLive(_84);\n        _85 = &mut _83;\n        _84 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::Iterator>::next(_85) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        _86 = discriminant(_84);\n        switchInt(move _86) -> [0: bb57, 1: bb56, otherwise: bb3];\n    }\n    bb56: {\n        _87 = ((_84 as variant#1).0: &[core::mem::MaybeUninit<T>]);\n        _88 = PtrMetadata(_33);\n        StorageLive(_91);\n        _92 = move _40;\n        _91 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_92, _88) -> [return: bb58, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_84);\n        StorageDead(_83);\n        StorageDead(_82);\n        goto -> bb97;\n    }\n    bb58: {\n        _89 = move (_91.0: &mut [core::mem::MaybeUninit<T>]);\n        _90 = move (_91.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_91);\n        _93 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_89, _33) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        _40 = _90;\n        _95 = <[core::mem::MaybeUninit<T>] as core::borrow::Borrow<[core::mem::MaybeUninit<T>]>>::borrow(_87) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        _94 = <[core::mem::MaybeUninit<T>] as core::convert::AsRef<[core::mem::MaybeUninit<T>]>>::as_ref(_95) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        _96 = PtrMetadata(_94);\n        StorageLive(_99);\n        _100 = move _40;\n        _99 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_100, _96) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        _97 = move (_99.0: &mut [core::mem::MaybeUninit<T>]);\n        _98 = move (_99.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_99);\n        _101 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_97, _94) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        _40 = _98;\n        StorageDead(_84);\n        goto -> bb54;\n    }\n    bb64: {\n        StorageLive(_103);\n        _103 = move _102;\n        goto -> bb65;\n    }\n    bb65: {\n        StorageLive(_104);\n        _105 = &mut _103;\n        _104 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::Iterator>::next(_105) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        _106 = discriminant(_104);\n        switchInt(move _106) -> [0: bb68, 1: bb67, otherwise: bb3];\n    }\n    bb67: {\n        _107 = ((_104 as variant#1).0: &[core::mem::MaybeUninit<T>]);\n        _108 = PtrMetadata(_33);\n        StorageLive(_111);\n        _112 = move _40;\n        _111 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_112, _108) -> [return: bb69, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_104);\n        StorageDead(_103);\n        StorageDead(_102);\n        goto -> bb97;\n    }\n    bb69: {\n        _109 = move (_111.0: &mut [core::mem::MaybeUninit<T>]);\n        _110 = move (_111.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_111);\n        _113 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_109, _33) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        _40 = _110;\n        _115 = <[core::mem::MaybeUninit<T>] as core::borrow::Borrow<[core::mem::MaybeUninit<T>]>>::borrow(_107) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        _114 = <[core::mem::MaybeUninit<T>] as core::convert::AsRef<[core::mem::MaybeUninit<T>]>>::as_ref(_115) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        _116 = PtrMetadata(_114);\n        StorageLive(_119);\n        _120 = move _40;\n        _119 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_120, _116) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        _117 = move (_119.0: &mut [core::mem::MaybeUninit<T>]);\n        _118 = move (_119.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_119);\n        _121 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_117, _114) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        _40 = _118;\n        StorageDead(_104);\n        goto -> bb65;\n    }\n    bb75: {\n        StorageLive(_123);\n        _123 = move _122;\n        goto -> bb76;\n    }\n    bb76: {\n        StorageLive(_124);\n        _125 = &mut _123;\n        _124 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::Iterator>::next(_125) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        _126 = discriminant(_124);\n        switchInt(move _126) -> [0: bb79, 1: bb78, otherwise: bb3];\n    }\n    bb78: {\n        _127 = ((_124 as variant#1).0: &[core::mem::MaybeUninit<T>]);\n        _128 = PtrMetadata(_33);\n        StorageLive(_131);\n        _132 = move _40;\n        _131 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_132, _128) -> [return: bb80, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_124);\n        StorageDead(_123);\n        StorageDead(_122);\n        goto -> bb97;\n    }\n    bb80: {\n        _129 = move (_131.0: &mut [core::mem::MaybeUninit<T>]);\n        _130 = move (_131.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_131);\n        _133 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_129, _33) -> [return: bb81, unwind unreachable];\n    }\n    bb81: {\n        _40 = _130;\n        _135 = <[core::mem::MaybeUninit<T>] as core::borrow::Borrow<[core::mem::MaybeUninit<T>]>>::borrow(_127) -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        _134 = <[core::mem::MaybeUninit<T>] as core::convert::AsRef<[core::mem::MaybeUninit<T>]>>::as_ref(_135) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        _136 = PtrMetadata(_134);\n        StorageLive(_139);\n        _140 = move _40;\n        _139 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_140, _136) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        _137 = move (_139.0: &mut [core::mem::MaybeUninit<T>]);\n        _138 = move (_139.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_139);\n        _141 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_137, _134) -> [return: bb85, unwind unreachable];\n    }\n    bb85: {\n        _40 = _138;\n        StorageDead(_124);\n        goto -> bb76;\n    }\n    bb86: {\n        StorageLive(_143);\n        _143 = move _142;\n        goto -> bb87;\n    }\n    bb87: {\n        StorageLive(_144);\n        _145 = &mut _143;\n        _144 = <core::iter::Map<core::slice::Iter<'_, S>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:169:36: 169:40}> as core::iter::Iterator>::next(_145) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        _146 = discriminant(_144);\n        switchInt(move _146) -> [0: bb90, 1: bb89, otherwise: bb3];\n    }\n    bb89: {\n        _147 = ((_144 as variant#1).0: &[core::mem::MaybeUninit<T>]);\n        _148 = PtrMetadata(_33);\n        StorageLive(_151);\n        _152 = move _40;\n        _151 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_152, _148) -> [return: bb91, unwind unreachable];\n    }\n    bb90: {\n        StorageDead(_144);\n        StorageDead(_143);\n        StorageDead(_142);\n        goto -> bb97;\n    }\n    bb91: {\n        _149 = move (_151.0: &mut [core::mem::MaybeUninit<T>]);\n        _150 = move (_151.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_151);\n        _153 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_149, _33) -> [return: bb92, unwind unreachable];\n    }\n    bb92: {\n        _40 = _150;\n        _155 = <[core::mem::MaybeUninit<T>] as core::borrow::Borrow<[core::mem::MaybeUninit<T>]>>::borrow(_147) -> [return: bb93, unwind unreachable];\n    }\n    bb93: {\n        _154 = <[core::mem::MaybeUninit<T>] as core::convert::AsRef<[core::mem::MaybeUninit<T>]>>::as_ref(_155) -> [return: bb94, unwind unreachable];\n    }\n    bb94: {\n        _156 = PtrMetadata(_154);\n        StorageLive(_159);\n        _160 = move _40;\n        _159 = core::slice::<impl [core::mem::MaybeUninit<T>]>::split_at_mut(_160, _156) -> [return: bb95, unwind unreachable];\n    }\n    bb95: {\n        _157 = move (_159.0: &mut [core::mem::MaybeUninit<T>]);\n        _158 = move (_159.1: &mut [core::mem::MaybeUninit<T>]);\n        StorageDead(_159);\n        _161 = core::slice::<impl [core::mem::MaybeUninit<T>]>::copy_from_slice(_157, _154) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        _40 = _158;\n        StorageDead(_144);\n        goto -> bb87;\n    }\n    bb97: {\n        StorageDead(_41);\n        _39 = move _40;\n        StorageDead(_40);\n        StorageLive(_163);\n        StorageLive(_164);\n        _164 = &(*_39);\n        _163 = PtrMetadata(move _164);\n        StorageDead(_164);\n        _165 = CheckedSub(_9, _163);\n        assert(!move (_165.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _9, move _163) -> [success: bb98, unwind unreachable];\n    }\n    bb98: {\n        _162 = move (_165.0: usize);\n        StorageDead(_163);\n        StorageLive(_167);\n        _167 = &mut _16;\n        _166 = vec::Vec::<T>::set_len(move _167, _162) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        StorageDead(_167);\n        StorageDead(_27);\n        _0 = move _16;\n        StorageDead(_16);\n        StorageDead(_4);\n        goto -> bb101;\n    }\n    bb100: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb101;\n    }\n    bb101: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}