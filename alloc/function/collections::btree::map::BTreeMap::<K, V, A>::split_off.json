{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::split_off",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the map contains no elements.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n assert!(a.is_empty());\n a.insert(1, \"a\");\n assert!(!a.is_empty());\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::map::BTreeMap::<K, V, A>::new_in": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a new empty BTreeMap with a reasonable choice for B.\n\n # Examples\n\n ```\n # #![feature(allocator_api)]\n # #![feature(btreemap_alloc)]\n use std::collections::BTreeMap;\n use std::alloc::Global;\n\n let mut map = BTreeMap::new_in(Global);\n\n // entries can now be inserted into the empty map\n map.insert(1, \"a\");\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    },
    "collections::btree::map::BTreeMap::<K, V, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the map.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n assert_eq!(a.len(), 0);\n a.insert(1, \"a\");\n assert_eq!(a.len(), 1);\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "ImmutableAsArgument"
      }
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::split_off": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Split off a tree with key-value pairs at and after the given key.\n The result is meaningful only if the tree is ordered by key,\n and if the ordering of `Q` corresponds to that of `K`.\n If `self` respects all `BTreeMap` tree invariants, then both\n `self` and the returned tree will respect those invariants.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_split_length": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the length of both trees that result from splitting up\n a given number of distinct key-value pairs.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Plain",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::mem::ManuallyDrop": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain",
      "Ref",
      "Deref"
    ]
  },
  "path": 632,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1403:5: 1426:6",
  "src": "pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n    where\n        K: Borrow<Q> + Ord,\n        A: Clone,\n    {\n        if self.is_empty() {\n            return Self::new_in((*self.alloc).clone());\n        }\n\n        let total_num = self.len();\n        let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n\n        let right_root = left_root.split_off(key, (*self.alloc).clone());\n\n        let (new_left_len, right_len) = Root::calc_split_length(total_num, &left_root, &right_root);\n        self.length = new_left_len;\n\n        BTreeMap {\n            root: Some(right_root),\n            length: right_len,\n            alloc: self.alloc.clone(),\n            _marker: PhantomData,\n        }\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::split_off(_1: &mut collections::btree::map::BTreeMap<K, V, A>, _2: &Q) -> collections::btree::map::BTreeMap<K, V, A> {\n    let mut _0: collections::btree::map::BTreeMap<K, V, A>;\n    let mut _3: bool;\n    let mut _4: &collections::btree::map::BTreeMap<K, V, A>;\n    let mut _5: A;\n    let  _6: &A;\n    let mut _7: &core::mem::ManuallyDrop<A>;\n    let  _8: usize;\n    let mut _9: &collections::btree::map::BTreeMap<K, V, A>;\n    let  _10: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _11: core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _12: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let  _13: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _14: A;\n    let  _15: &A;\n    let mut _16: &core::mem::ManuallyDrop<A>;\n    let  _17: usize;\n    let  _18: usize;\n    let mut _19: (usize, usize);\n    let mut _20: &collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _21: &&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _22: &collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _23: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _24: core::mem::ManuallyDrop<A>;\n    let mut _25: &core::mem::ManuallyDrop<A>;\n    let mut _26: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    debug self => _1;\n    debug key => _2;\n    debug total_num => _8;\n    debug left_root => _10;\n    debug right_root => _13;\n    debug new_left_len => _17;\n    debug right_len => _18;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = collections::btree::map::BTreeMap::<K, V, A>::is_empty(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb6, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _6 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _5 = <A as core::clone::Clone>::clone(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _0 = collections::btree::map::BTreeMap::<K, V, A>::new_in(move _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb15;\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_9);\n        _9 = &(*_1);\n        _8 = collections::btree::map::BTreeMap::<K, V, A>::len(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut ((*_1).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _11 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::as_mut(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        _10 = core::option::Option::<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::unwrap(move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageLive(_14);\n        StorageLive(_16);\n        _16 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _15 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _16) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        _14 = <A as core::clone::Clone>::clone(_15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _13 = collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::split_off::<Q, A>(_10, _2, move _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_10;\n        _26 = (*_21);\n        _20 = &(*_26);\n        _22 = &_13;\n        _19 = collections::btree::split::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::calc_split_length(_8, move _20, _22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_20);\n        _17 = (_19.0: usize);\n        _18 = (_19.1: usize);\n        StorageDead(_21);\n        StorageDead(_19);\n        ((*_1).1: usize) = _17;\n        StorageLive(_23);\n        _23 = core::option::Option::Some(_13);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _24 = <core::mem::ManuallyDrop<A> as core::clone::Clone>::clone(move _25) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_25);\n        _0 = BTreeMap(move _23, _18, move _24, ZeroSized: core::marker::PhantomData<boxed::Box<(K, V), A>>);\n        StorageDead(_24);\n        StorageDead(_23);\n        goto -> bb15;\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": " Splits the collection into two at the given key. Returns everything after the given key,\n including the key. If the key is not present, the split will occur at the nearest\n greater key, or return an empty map if no such key exists.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n a.insert(1, \"a\");\n a.insert(2, \"b\");\n a.insert(3, \"c\");\n a.insert(17, \"d\");\n a.insert(41, \"e\");\n\n let b = a.split_off(&3);\n\n assert_eq!(a.len(), 2);\n assert_eq!(b.len(), 3);\n\n assert_eq!(a[&1], \"a\");\n assert_eq!(a[&2], \"b\");\n\n assert_eq!(b[&3], \"c\");\n assert_eq!(b[&17], \"d\");\n assert_eq!(b[&41], \"e\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}