{
  "name": "<[T; N] as vec::is_zero::IsZero>::is_zero",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice depending on the type of\n index.\n\n - If given a position, returns a reference to the element at that\n   position or `None` if out of bounds.\n - If given a range, returns the subslice corresponding to that range,\n   or `None` if out of bounds.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&40), v.get(1));\n assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n assert_eq!(None, v.get(3));\n assert_eq!(None, v.get(0..4));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::is_none_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] or the value inside of it matches a predicate.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none_or(|x| x > 1), true);\n\n let x: Option<u32> = Some(0);\n assert_eq!(x.is_none_or(|x| x > 1), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none_or(|x| x > 1), true);\n\n let x: Option<String> = Some(\"ownership\".to_string());\n assert_eq!(x.as_ref().is_none_or(|x| x.len() > 1), true);\n println!(\"still alive {:?}\", x);\n ```\n",
      "adt": {}
    },
    "vec::is_zero::IsZero::is_zero": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Whether this value's representation is all zeros,\n or can be represented with all zeroes.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests if every element of the iterator matches a predicate.\n\n `all()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if they all return\n `true`, then so does `all()`. If any of them return `false`, it\n returns `false`.\n\n `all()` is short-circuiting; in other words, it will stop processing\n as soon as it finds a `false`, given that no matter what else happens,\n the result will also be `false`.\n\n An empty iterator returns `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert!(a.into_iter().all(|x| x > 0));\n\n assert!(!a.into_iter().all(|x| x > 2));\n ```\n\n Stopping at the first `false`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert!(!iter.all(|x| x != 2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<[T; N] as vec::is_zero::IsZero>::is_zero"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/is_zero.rs:62:5: 81:6",
  "src": "fn is_zero(&self) -> bool {\n        if T::IS_ZST {\n            // If T is a ZST, then there is at most one possible value of `T`,\n            // so we only need to check one element for zeroness.\n            // We can't unconditionally return `true` here, since, e.g.\n            // `T = [NonTrivialCloneZst; 5]` is a ZST that implements `IsZero`\n            // due to the generic array impl, but `T::is_zero` returns `false`\n            // since the length is not 0.\n            self.get(0).is_none_or(IsZero::is_zero)\n        } else {\n            // Because this is generated as a runtime check, it's not obvious that\n            // it's worth doing if the array is really long. The threshold here\n            // is largely arbitrary, but was picked because as of 2022-07-01 LLVM\n            // fails to const-fold the check in `vec![[1; 32]; n]`\n            // See https://github.com/rust-lang/rust/pull/97581#issuecomment-1166628022\n            // Feel free to tweak if you have better evidence.\n\n            N <= 16 && self.iter().all(IsZero::is_zero)\n        }\n    }",
  "mir": "fn <[T; N] as vec::is_zero::IsZero>::is_zero(_1: &[T; N]) -> bool {\n    let mut _0: bool;\n    let mut _2: core::option::Option<&T>;\n    let mut _3: &[T];\n    let mut _4: bool;\n    let mut _5: &mut core::slice::Iter<'_, T>;\n    let mut _6: core::slice::Iter<'_, T>;\n    let mut _7: &[T];\n    debug self => _1;\n    bb0: {\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb4, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = _1 as &[T];\n        _2 = core::slice::<impl [T]>::get::<usize>(move _3, 0_usize) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = core::option::Option::<&T>::is_none_or::<for<'a> fn(&'a T) -> bool {<T as vec::is_zero::IsZero>::is_zero}>(move _2, <T as vec::is_zero::IsZero>::is_zero) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        goto -> bb10;\n    }\n    bb4: {\n        StorageLive(_4);\n        _4 = Le(N, 16_usize);\n        switchInt(move _4) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _1 as &[T];\n        _6 = core::slice::<impl [T]>::iter(move _7) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        _0 = false;\n        goto -> bb9;\n    }\n    bb7: {\n        _5 = &mut _6;\n        StorageDead(_7);\n        _0 = <core::slice::Iter<'_, T> as core::iter::Iterator>::all::<for<'a> fn(&'a T) -> bool {<T as vec::is_zero::IsZero>::is_zero}>(move _5, <T as vec::is_zero::IsZero>::is_zero) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb10: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}