{
  "name": "collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>>::remove_leaf_kv",
  "safe": true,
  "callees": {
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the key-value pair pointed to by this handle and returns it, along with the edge\n that the key-value pair collapsed into.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, HandleType>::reborrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another immutable handle on the same location.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<Node, Type>::into_node": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Retrieves the node that contains the edge or key-value pair this handle points to.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::Handle::<Node, Type>::idx": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the position of this handle in the node.\n",
      "adt": {
        "collections::btree::node::Handle": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Leaf>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::choose_parent_kv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Chooses a balancing context involving the node as a child, thus between\n the KV immediately to the left or to the right in the parent node.\n Returns an `Err` if there is no parent.\n Panics if the parent is empty.\n\n Prefers the left side, to be optimal if the given node is somehow\n underfull, meaning here only that it has fewer elements than its left\n sibling and than its right sibling, if they exist. In that case,\n merging with the left sibling is faster, since we only need to move\n the node's N elements, instead of shifting them to the right and moving\n more than N elements in front. Stealing from the left sibling is also\n typically faster, since we only need to shift the node's N elements to\n the right, instead of shifting at least N of the sibling's elements to\n the left.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "core::result::Result": "Constructor",
        "collections::btree::node::BalancingContext": "Constructor",
        "collections::btree::node::LeftOrRight": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::new_edge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to an edge in `node`.\n Unsafe because the caller must ensure that `idx <= node.len()`.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::left_child_len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::BalancingContext": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::right_child_len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::BalancingContext": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::can_merge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether merging is possible, i.e., whether there is enough room\n in a node to combine the central KV with both adjacent child nodes.\n",
      "adt": {
        "collections::btree::node::BalancingContext": "ImmutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::merge_tracking_child_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Merges the parent's key-value pair and both adjacent child nodes into\n the left child node and returns the edge handle in that child node\n where the tracked child edge ended up,\n\n Panics unless we `.can_merge()`.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::steal_left": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key-value pair from the left child and places it in the key-value storage\n of the parent, while pushing the old parent key-value pair into the right child.\n Returns a handle to the edge in the right child corresponding to where the original\n edge specified by `track_right_edge_idx` ended up.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::BalancingContext": "MutableAsArgument"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::steal_right": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key-value pair from the right child and places it in the key-value storage\n of the parent, while pushing the old parent key-value pair onto the left child.\n Returns a handle to the edge in the left child specified by `track_left_edge_idx`,\n which didn't move.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::BalancingContext": "MutableAsArgument"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>, Type>::cast_to_leaf_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unsafely asserts to the compiler the static information that the handle's node is a `Leaf`.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, HandleType>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable handle on the same location. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n For details, see `NodeRef::reborrow_mut`.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::ascend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the parent of the current node. Returns `Ok(handle)` if the current\n node actually has a parent, where `handle` points to the edge of the parent\n that points to the current node. Returns `Err(self)` if the current node has\n no parent, giving back the original `NodeRef`.\n\n The method name assumes you picture trees with the root node on top.\n\n `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n both, upon success, do nothing.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Internal>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is an `Internal` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_node_and_affected_ancestors": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stocks up a possibly underfull node, and if that causes its parent node\n to shrink, stocks up the parent, recursively.\n Returns `true` if it fixed the tree, `false` if it couldn't because the\n root node became empty.\n\n This method does not expect ancestors to already be underfull upon entry\n and panics if it encounters an empty ancestor.\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::node::Handle": [
      "Plain",
      "Unknown([Field(0, Ty { id: 2767, kind: RigidTy(Tuple([Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }])) })])",
      "Unknown([Field(1, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Ref",
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2514, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2514, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2514, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4544, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::node::BalancingContext": [
      "Plain",
      "Ref"
    ],
    "collections::btree::node::LeftOrRight": [
      "Plain"
    ]
  },
  "path": 915,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/remove.rs:26:5: 75:6",
  "src": "fn remove_leaf_kv<F: FnOnce(), A: Allocator + Clone>(\n        self,\n        handle_emptied_internal_root: F,\n        alloc: A,\n    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n        let (old_kv, mut pos) = self.remove();\n        let len = pos.reborrow().into_node().len();\n        if len < MIN_LEN {\n            let idx = pos.idx();\n            // We have to temporarily forget the child type, because there is no\n            // distinct node type for the immediate parents of a leaf.\n            let new_pos = match pos.into_node().forget_type().choose_parent_kv() {\n                Ok(Left(left_parent_kv)) => {\n                    debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n                    if left_parent_kv.can_merge() {\n                        left_parent_kv.merge_tracking_child_edge(Right(idx), alloc.clone())\n                    } else {\n                        debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n                        left_parent_kv.steal_left(idx)\n                    }\n                }\n                Ok(Right(right_parent_kv)) => {\n                    debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n                    if right_parent_kv.can_merge() {\n                        right_parent_kv.merge_tracking_child_edge(Left(idx), alloc.clone())\n                    } else {\n                        debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n                        right_parent_kv.steal_right(idx)\n                    }\n                }\n                Err(pos) => unsafe { Handle::new_edge(pos, idx) },\n            };\n            // SAFETY: `new_pos` is the leaf we started from or a sibling.\n            pos = unsafe { new_pos.cast_to_leaf_unchecked() };\n\n            // Only if we merged, the parent (if any) has shrunk, but skipping\n            // the following step otherwise does not pay off in benchmarks.\n            //\n            // SAFETY: We won't destroy or rearrange the leaf where `pos` is at\n            // by handling its parent recursively; at worst we will destroy or\n            // rearrange the parent through the grandparent, thus change the\n            // link to the parent inside the leaf.\n            if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n                if !parent.into_node().forget_type().fix_node_and_affected_ancestors(alloc) {\n                    handle_emptied_internal_root();\n                }\n            }\n        }\n        (old_kv, pos)\n    }",
  "mir": "fn collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>>::remove_leaf_kv(_1: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>, _2: F, _3: A) -> ((K, V), collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>) {\n    let mut _0: ((K, V), collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n    let  _4: (K, V);\n    let mut _5: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _6: ((K, V), collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n    let  _7: usize;\n    let mut _8: &collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let  _9: collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _10: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _11: &collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _12: bool;\n    let  _13: usize;\n    let mut _14: &collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let  _15: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>;\n    let mut _16: core::result::Result<collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _17: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _18: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _19: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _20: isize;\n    let mut _21: isize;\n    let  _22: collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _23: bool;\n    let mut _24: usize;\n    let mut _25: &collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let mut _28: !;\n    let mut _29: bool;\n    let mut _30: &collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _31: collections::btree::node::LeftOrRight<usize>;\n    let mut _32: A;\n    let mut _33: &A;\n    let mut _34: bool;\n    let mut _35: usize;\n    let mut _36: &collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _37: !;\n    let  _38: collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _39: bool;\n    let mut _40: usize;\n    let mut _41: &collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _42: usize;\n    let mut _43: (usize, bool);\n    let mut _44: !;\n    let mut _45: bool;\n    let mut _46: &collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _47: collections::btree::node::LeftOrRight<usize>;\n    let mut _48: A;\n    let mut _49: &A;\n    let mut _50: bool;\n    let mut _51: usize;\n    let mut _52: &collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _53: !;\n    let  _54: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _55: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _56: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>;\n    let mut _57: core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>>;\n    let mut _58: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _59: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _60: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _61: isize;\n    let  _62: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let mut _63: bool;\n    let mut _64: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _65: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _66: A;\n    let  _67: ();\n    let mut _68: F;\n    let mut _69: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _70: bool;\n    let mut _71: bool;\n    debug self => _1;\n    debug handle_emptied_internal_root => _2;\n    debug alloc => _3;\n    debug old_kv => _4;\n    debug pos => _5;\n    debug len => _7;\n    debug idx => _13;\n    debug new_pos => _15;\n    debug left_parent_kv => _22;\n    debug right_parent_kv => _38;\n    debug pos => _54;\n    debug parent => _62;\n    bb0: {\n        _71 = false;\n        _70 = false;\n        _71 = true;\n        _70 = true;\n        StorageLive(_6);\n        _6 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::remove(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = move (_6.0: (K, V));\n        StorageLive(_5);\n        _5 = move (_6.1: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        StorageDead(_6);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_5;\n        _10 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::reborrow(move _11) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_11);\n        _9 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::into_node(move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &_9;\n        StorageDead(_10);\n        _7 = collections::btree::node::NodeRef::<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>::len(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_9);\n        StorageLive(_12);\n        _12 = Lt(_7, collections::btree::map::MIN_LEN);\n        switchInt(move _12) -> [0: bb59, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_14);\n        _14 = &_5;\n        _13 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::idx(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = move _5;\n        _18 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::into_node(move _19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_19);\n        _17 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::forget_type(move _18) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_18);\n        _16 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::choose_parent_kv(move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        _21 = discriminant(_16);\n        switchInt(move _21) -> [0: bb11, 1: bb12, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _20 = discriminant(((_16 as variant#0).0: collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>));\n        switchInt(move _20) -> [0: bb14, 1: bb13, otherwise: bb10];\n    }\n    bb12: {\n        _54 = move ((_16 as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        _15 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>::new_edge(_54, _13) -> [return: bb43, unwind unreachable];\n    }\n    bb13: {\n        _38 = move ((((_16 as variant#0).0: collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>) as variant#1).0: collections::btree::node::BalancingContext<'_, K, V>);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &_38;\n        _40 = collections::btree::node::BalancingContext::<'_, K, V>::left_child_len(move _41) -> [return: bb29, unwind unreachable];\n    }\n    bb14: {\n        _22 = move ((((_16 as variant#0).0: collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>) as variant#0).0: collections::btree::node::BalancingContext<'_, K, V>);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &_22;\n        _24 = collections::btree::node::BalancingContext::<'_, K, V>::right_child_len(move _25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageLive(_26);\n        _27 = CheckedSub(collections::btree::map::MIN_LEN, 1_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} - {}`, which would overflow\", collections::btree::map::MIN_LEN, 1_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _26 = move (_27.0: usize);\n        _23 = Eq(move _24, move _26);\n        switchInt(move _23) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        StorageDead(_26);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_22;\n        _29 = collections::btree::node::BalancingContext::<'_, K, V>::can_merge(move _30) -> [return: bb19, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_26);\n        StorageDead(_24);\n        _28 = core::panicking::panic(\"assertion failed: left_parent_kv.right_child_len() == MIN_LEN - 1\") -> unwind unreachable;\n    }\n    bb19: {\n        switchInt(move _29) -> [0: bb23, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_30);\n        StorageLive(_31);\n        _31 = collections::btree::node::LeftOrRight::Right(_13);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_3;\n        _32 = <A as core::clone::Clone>::clone(move _33) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        _15 = collections::btree::node::BalancingContext::<'_, K, V>::merge_tracking_child_edge::<A>(_22, move _31, move _32) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_32);\n        StorageDead(_31);\n        goto -> bb28;\n    }\n    bb23: {\n        StorageDead(_30);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &_22;\n        _35 = collections::btree::node::BalancingContext::<'_, K, V>::left_child_len(move _36) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_36);\n        _34 = Gt(move _35, collections::btree::map::MIN_LEN);\n        switchInt(move _34) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageDead(_34);\n        _15 = collections::btree::node::BalancingContext::<'_, K, V>::steal_left(_22, _13) -> [return: bb27, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        _37 = core::panicking::panic(\"assertion failed: left_parent_kv.left_child_len() > MIN_LEN\") -> unwind unreachable;\n    }\n    bb27: {\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_29);\n        goto -> bb44;\n    }\n    bb29: {\n        StorageDead(_41);\n        StorageLive(_42);\n        _43 = CheckedSub(collections::btree::map::MIN_LEN, 1_usize);\n        assert(!move (_43.1: bool), \"attempt to compute `{} - {}`, which would overflow\", collections::btree::map::MIN_LEN, 1_usize) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _42 = move (_43.0: usize);\n        _39 = Eq(move _40, move _42);\n        switchInt(move _39) -> [0: bb32, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_42);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &_38;\n        _45 = collections::btree::node::BalancingContext::<'_, K, V>::can_merge(move _46) -> [return: bb33, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_42);\n        StorageDead(_40);\n        _44 = core::panicking::panic(\"assertion failed: right_parent_kv.left_child_len() == MIN_LEN - 1\") -> unwind unreachable;\n    }\n    bb33: {\n        switchInt(move _45) -> [0: bb37, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_46);\n        StorageLive(_47);\n        _47 = collections::btree::node::LeftOrRight::Left(_13);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &_3;\n        _48 = <A as core::clone::Clone>::clone(move _49) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_49);\n        _15 = collections::btree::node::BalancingContext::<'_, K, V>::merge_tracking_child_edge::<A>(_38, move _47, move _48) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_48);\n        StorageDead(_47);\n        goto -> bb42;\n    }\n    bb37: {\n        StorageDead(_46);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &_38;\n        _51 = collections::btree::node::BalancingContext::<'_, K, V>::right_child_len(move _52) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_52);\n        _50 = Gt(move _51, collections::btree::map::MIN_LEN);\n        switchInt(move _50) -> [0: bb40, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_51);\n        StorageDead(_50);\n        _15 = collections::btree::node::BalancingContext::<'_, K, V>::steal_right(_38, _13) -> [return: bb41, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_51);\n        _53 = core::panicking::panic(\"assertion failed: right_parent_kv.right_child_len() > MIN_LEN\") -> unwind unreachable;\n    }\n    bb41: {\n        goto -> bb42;\n    }\n    bb42: {\n        StorageDead(_45);\n        goto -> bb44;\n    }\n    bb43: {\n        goto -> bb44;\n    }\n    bb44: {\n        StorageDead(_16);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = move _15;\n        _55 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>::cast_to_leaf_unchecked(move _56) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_56);\n        _5 = move _55;\n        StorageDead(_55);\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &mut _5;\n        _59 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::reborrow_mut(move _60) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_60);\n        _58 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::into_node(move _59) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_59);\n        _57 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::ascend(move _58) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_58);\n        _61 = discriminant(_57);\n        switchInt(move _61) -> [0: bb49, 1: bb57, otherwise: bb10];\n    }\n    bb49: {\n        _62 = move ((_57 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>);\n        StorageLive(_63);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::into_node(_62) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _64 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::forget_type(move _65) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_65);\n        StorageLive(_66);\n        _70 = false;\n        _66 = move _3;\n        _63 = collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_node_and_affected_ancestors::<A>(move _64, move _66) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        switchInt(move _63) -> [0: bb54, otherwise: bb53];\n    }\n    bb53: {\n        StorageDead(_66);\n        StorageDead(_64);\n        goto -> bb56;\n    }\n    bb54: {\n        StorageDead(_66);\n        StorageDead(_64);\n        StorageLive(_68);\n        _71 = false;\n        _68 = move _2;\n        _67 = <F as core::ops::FnOnce<()>>::call_once(move _68, ()) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_68);\n        goto -> bb56;\n    }\n    bb56: {\n        StorageDead(_63);\n        StorageDead(_57);\n        goto -> bb58;\n    }\n    bb57: {\n        StorageDead(_57);\n        goto -> bb58;\n    }\n    bb58: {\n        StorageDead(_15);\n        goto -> bb60;\n    }\n    bb59: {\n        goto -> bb60;\n    }\n    bb60: {\n        StorageDead(_12);\n        StorageLive(_69);\n        _69 = move _5;\n        _0 = (_4, move _69);\n        StorageDead(_69);\n        StorageDead(_5);\n        switchInt(_70) -> [0: bb61, otherwise: bb63];\n    }\n    bb61: {\n        switchInt(_71) -> [0: bb62, otherwise: bb64];\n    }\n    bb62: {\n        return;\n    }\n    bb63: {\n        drop(_3) -> [return: bb61, unwind unreachable];\n    }\n    bb64: {\n        drop(_2) -> [return: bb62, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}