{
  "name": "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert_fit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a new key-value pair and an edge that will go to the right of that new pair\n between this edge and the key-value pair to the right of this edge. This method assumes\n that there is enough space in the node for the new pair to fit.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument",
        "collections::btree::node::Handle": "MutableAsArgument"
      }
    },
    "collections::btree::node::splitpoint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given an edge index where we want to insert into a node filled to capacity,\n computes a sensible KV index of a split point and where to perform the insertion.\n The goal of the split point is for its key and value to end up in a parent node;\n the keys, values and edges to the left of the split point become the left child;\n the keys, values and edges to the right of the split point become the right child.\n",
      "adt": {
        "collections::btree::node::LeftOrRight": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::KV>::new_kv": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to a key-value pair in `node`.\n Unsafe because the caller must ensure that `idx < node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the underlying node into three parts:\n\n - The node is truncated to only contain the edges and key-value pairs to the\n   left of this handle.\n - The key and value pointed to by this handle are extracted.\n - All the edges and key-value pairs to the right of this handle are put into\n   a newly allocated node.\n",
      "adt": {
        "collections::btree::node::Handle": "MutableAsArgument",
        "collections::btree::node::SplitResult": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::new_edge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to an edge in `node`.\n Unsafe because the caller must ensure that `idx <= node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Ref",
      "Plain",
      "MutRef"
    ],
    "collections::btree::node::Handle": [
      "Unknown([Field(0, Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) }), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(0, Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })])",
      "MutRef",
      "Plain",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "collections::btree::node::LeftOrRight": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 4647, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "collections::btree::node::SplitResult": [
      "Plain",
      "Unknown([Field(2, Ty { id: 4687, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(0, Ty { id: 2510, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": 888,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:1020:5: 1047:6",
  "src": "fn insert<A: Allocator + Clone>(\n        mut self,\n        key: K,\n        val: V,\n        edge: Root<K, V>,\n        alloc: A,\n    ) -> Option<SplitResult<'a, K, V, marker::Internal>> {\n        assert!(edge.height == self.node.height - 1);\n\n        if self.node.len() < CAPACITY {\n            self.insert_fit(key, val, edge);\n            None\n        } else {\n            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n            let mut result = middle.split(alloc);\n            let mut insertion_edge = match insertion {\n                LeftOrRight::Left(insert_idx) => unsafe {\n                    Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                },\n                LeftOrRight::Right(insert_idx) => unsafe {\n                    Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                },\n            };\n            insertion_edge.insert_fit(key, val, edge);\n            Some(result)\n        }\n    }",
  "mir": "fn collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert(_1: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>, _2: K, _3: V, _4: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, _5: A) -> core::option::Option<collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Internal>> {\n    let mut _0: core::option::Option<collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Internal>>;\n    let mut _6: bool;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: (usize, bool);\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let  _15: ();\n    let mut _16: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let  _17: usize;\n    let  _18: collections::btree::node::LeftOrRight<usize>;\n    let mut _19: (usize, collections::btree::node::LeftOrRight<usize>);\n    let mut _20: usize;\n    let  _21: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>;\n    let mut _22: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _23: collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Internal>;\n    let mut _24: A;\n    let mut _25: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let mut _26: isize;\n    let  _27: usize;\n    let mut _28: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _29: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let  _30: usize;\n    let mut _31: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _32: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Internal>;\n    let  _33: ();\n    let mut _34: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let mut _35: collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Internal>;\n    let mut _36: bool;\n    debug self => _1;\n    debug key => _2;\n    debug val => _3;\n    debug edge => _4;\n    debug alloc => _5;\n    debug middle_kv_idx => _17;\n    debug insertion => _18;\n    debug middle => _21;\n    debug result => _23;\n    debug insertion_edge => _25;\n    debug insert_idx => _27;\n    debug insert_idx => _30;\n    bb0: {\n        _36 = false;\n        _36 = true;\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = (_4.0: usize);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = ((_1.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>).0: usize);\n        _10 = CheckedSub(_9, 1_usize);\n        assert(!move (_10.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _9, 1_usize) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _8 = move (_10.0: usize);\n        StorageDead(_9);\n        _6 = Eq(move _7, move _8);\n        switchInt(move _6) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(_1.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>);\n        _13 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::len(move _14) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _11 = core::panicking::panic(\"assertion failed: edge.height == self.node.height - 1\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_14);\n        _12 = Lt(move _13, collections::btree::node::CAPACITY);\n        switchInt(move _12) -> [0: bb7, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_13);\n        StorageLive(_16);\n        _16 = &mut _1;\n        _15 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert_fit(move _16, _2, _3, _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_16);\n        _0 = core::option::Option::None;\n        goto -> bb20;\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = (_1.1: usize);\n        _19 = collections::btree::node::splitpoint(move _20) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_20);\n        _17 = (_19.0: usize);\n        StorageLive(_18);\n        _18 = move (_19.1: collections::btree::node::LeftOrRight<usize>);\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = move (_1.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>);\n        _21 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>::new_kv(move _22, _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _36 = false;\n        _24 = move _5;\n        _23 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>::split::<A>(_21, move _24) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_24);\n        StorageLive(_25);\n        _26 = discriminant(_18);\n        switchInt(move _26) -> [0: bb13, 1: bb12, otherwise: bb11];\n    }\n    bb11: {\n        unreachable;\n    }\n    bb12: {\n        _30 = ((_18 as variant#1).0: usize);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &mut (_23.2: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Internal>);\n        _31 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Internal>::borrow_mut(move _32) -> [return: bb16, unwind unreachable];\n    }\n    bb13: {\n        _27 = ((_18 as variant#0).0: usize);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &mut (_23.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>);\n        _28 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::reborrow_mut(move _29) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_29);\n        _25 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::new_edge(move _28, _27) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_28);\n        goto -> bb18;\n    }\n    bb16: {\n        StorageDead(_32);\n        _25 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::new_edge(move _31, _30) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_31);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_34);\n        _34 = &mut _25;\n        _33 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert_fit(move _34, _2, _3, _4) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_34);\n        StorageLive(_35);\n        _35 = move _23;\n        _0 = core::option::Option::Some(move _35);\n        StorageDead(_35);\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_18);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_12);\n        switchInt(_36) -> [0: bb21, otherwise: bb22];\n    }\n    bb21: {\n        return;\n    }\n    bb22: {\n        drop(_5) -> [return: bb21, unwind unreachable];\n    }\n}\n",
  "doc": " Inserts a new key-value pair and an edge that will go to the right of that new pair\n between this edge and the key-value pair to the right of this edge. This method splits\n the node if there isn't enough room.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}