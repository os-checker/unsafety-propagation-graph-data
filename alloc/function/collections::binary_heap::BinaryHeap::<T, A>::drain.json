{
  "name": "collections::binary_heap::BinaryHeap::<T, A>::drain",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::drain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the subslice indicated by the given range from the vector,\n returning a double-ended iterator over the removed subslice.\n\n If the iterator is dropped before being fully consumed,\n it drops the remaining removed elements.\n\n The returned iterator keeps a mutable borrow on the vector to optimize\n its implementation.\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and past the length of the vector.\n\n # Leaking\n\n If the returned iterator goes out of scope without being dropped (due to\n [`mem::forget`], for example), the vector may have lost and leaked\n elements arbitrarily, including elements outside the range.\n\n # Examples\n\n ```\n let mut v = vec![1, 2, 3];\n let u: Vec<_> = v.drain(1..).collect();\n assert_eq!(v, &[1]);\n assert_eq!(u, &[2, 3]);\n\n // A full range clears the vector, like `clear()` does\n v.drain(..);\n assert_eq!(v, &[]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument",
        "vec::drain::Drain": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "MutRef"
    ],
    "collections::binary_heap::BinaryHeap": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "vec::drain::Drain": [
      "Plain"
    ],
    "collections::binary_heap::Drain": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::binary_heap::BinaryHeap::<T, A>::drain"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/binary_heap/mod.rs:1402:5: 1404:6",
  "src": "pub fn drain(&mut self) -> Drain<'_, T, A> {\n        Drain { iter: self.data.drain(..) }\n    }",
  "mir": "fn collections::binary_heap::BinaryHeap::<T, A>::drain(_1: &mut collections::binary_heap::BinaryHeap<T, A>) -> collections::binary_heap::Drain<'_, T, A> {\n    let mut _0: collections::binary_heap::Drain<'_, T, A>;\n    let mut _2: vec::drain::Drain<'_, T, A>;\n    let mut _3: &mut vec::Vec<T, A>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: vec::Vec<T, A>);\n        _2 = vec::Vec::<T, A>::drain::<core::ops::RangeFull>(move _3, core::ops::RangeFull) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = Drain(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Clears the binary heap, returning an iterator over the removed elements\n in arbitrary order. If the iterator is dropped before being fully\n consumed, it drops the remaining elements in arbitrary order.\n\n The returned iterator keeps a mutable borrow on the heap to optimize\n its implementation.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::collections::BinaryHeap;\n let mut heap = BinaryHeap::from([1, 3]);\n\n assert!(!heap.is_empty());\n\n for x in heap.drain() {\n     println!(\"{x}\");\n }\n\n assert!(heap.is_empty());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}