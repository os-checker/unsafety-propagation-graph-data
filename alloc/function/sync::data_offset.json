{
  "name": "sync::data_offset",
  "safe": false,
  "callees": {
    "core::mem::align_of_val_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of the type of the value that `val` points to in\n bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Safety\n\n This function is only safe to call if the following conditions hold:\n\n - If `T` is `Sized`, this function is always safe to call.\n - If the unsized tail of `T` is:\n     - a [slice], then the length of the slice tail must be an initialized\n       integer, and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n       For the special case where the dynamic tail length is 0, this function\n       is safe to call.\n     - a [trait object], then the vtable part of the pointer must point\n       to a valid vtable acquired by an unsizing coercion, and the size\n       of the *entire value* (dynamic tail length + statically sized prefix)\n       must fit in `isize`.\n     - an (unstable) [extern type], then this function is always safe to\n       call, but may panic or otherwise return the wrong value, as the\n       extern type's layout is not known. This is the same behavior as\n       [`align_of_val`] on a reference to a type with an extern type tail.\n     - otherwise, it is conservatively not allowed to call this function.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n [extern type]: ../../unstable-book/language-features/extern-types.html\n\n # Examples\n\n ```\n #![feature(layout_for_ptr)]\n use std::mem;\n\n assert_eq!(4, unsafe { mem::align_of_val_raw(&5i32) });\n ```\n",
      "adt": {}
    },
    "sync::data_offset_align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {},
  "path": 2009,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:4204:1: 4212:2",
  "src": "unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {\n    // Align the unsized value to the end of the ArcInner.\n    // Because ArcInner is repr(C), it will always be the last field in memory.\n    // SAFETY: since the only unsized types possible are slices, trait objects,\n    // and extern types, the input safety requirement is currently enough to\n    // satisfy the requirements of align_of_val_raw; this is an implementation\n    // detail of the language that must not be relied upon outside of std.\n    unsafe { data_offset_align(align_of_val_raw(ptr)) }\n}",
  "mir": "fn sync::data_offset(_1: *const T) -> usize {\n    let mut _0: usize;\n    let mut _2: usize;\n    debug ptr => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::align_of_val_raw::<T>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = sync::data_offset_align(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Gets the offset within an `ArcInner` for the payload behind a pointer.\n\n # Safety\n\n The pointer must point to (and have valid metadata for) a previously\n valid instance of T, but the T is allowed to be dropped.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}