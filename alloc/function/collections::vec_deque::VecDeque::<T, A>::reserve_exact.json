{
  "name": "collections::vec_deque::VecDeque::<T, A>::reserve_exact",
  "safe": true,
  "callees": {
    "core::num::<impl usize>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "raw_vec::RawVec::<T, A>::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Ensures that the buffer contains at least enough space to hold `len +\n additional` elements. If it doesn't already, will reallocate the\n minimum possible amount of memory necessary. Generally this will be\n exactly the amount of memory necessary, but in principle the allocator\n is free to give back more than we asked for.\n\n If `len` exceeds `self.capacity()`, this may fail to actually allocate\n the requested space. This is not really unsafe, but the unsafe code\n *you* write that relies on the behavior of this function may break.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Aborts\n\n Aborts on OOM.\n",
      "adt": {
        "raw_vec::RawVec": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::handle_capacity_increase": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Frobs the head and tail sections around to handle the fact that we\n just reallocated. Unsafe because it trusts old_capacity.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "raw_vec::RawVec": [
      "MutRef"
    ]
  },
  "path": 1513,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1011:5: 1021:6",
  "src": "pub fn reserve_exact(&mut self, additional: usize) {\n        let new_cap = self.len.checked_add(additional).expect(\"capacity overflow\");\n        let old_cap = self.capacity();\n\n        if new_cap > old_cap {\n            self.buf.reserve_exact(self.len, additional);\n            unsafe {\n                self.handle_capacity_increase(old_cap);\n            }\n        }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::reserve_exact(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: core::option::Option<usize>;\n    let mut _5: usize;\n    let mut _6: &str;\n    let  _7: usize;\n    let mut _8: &collections::vec_deque::VecDeque<T, A>;\n    let mut _9: bool;\n    let  _10: ();\n    let mut _11: &mut raw_vec::RawVec<T, A>;\n    let mut _12: usize;\n    let  _13: ();\n    debug self => _1;\n    debug additional => _2;\n    debug new_cap => _3;\n    debug old_cap => _7;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).1: usize);\n        _4 = core::num::<impl usize>::checked_add(move _5, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = \"capacity overflow\";\n        _3 = core::option::Option::<usize>::expect(move _4, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_8);\n        _8 = &(*_1);\n        _7 = collections::vec_deque::VecDeque::<T, A>::capacity(move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageLive(_9);\n        _9 = Gt(_3, _7);\n        switchInt(move _9) -> [0: bb7, otherwise: bb4];\n    }\n    bb4: {\n        StorageLive(_11);\n        _11 = &mut ((*_1).2: raw_vec::RawVec<T, A>);\n        StorageLive(_12);\n        _12 = ((*_1).1: usize);\n        _10 = raw_vec::RawVec::<T, A>::reserve_exact(move _11, move _12, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _13 = collections::vec_deque::VecDeque::<T, A>::handle_capacity_increase(_1, _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb8;\n    }\n    bb7: {\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": " Reserves the minimum capacity for at least `additional` more elements to be inserted in the\n given deque. Does nothing if the capacity is already sufficient.\n\n Note that the allocator may give the collection more space than it requests. Therefore\n capacity can not be relied upon to be precisely minimal. Prefer [`reserve`] if future\n insertions are expected.\n\n # Panics\n\n Panics if the new capacity overflows `usize`.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf: VecDeque<i32> = [1].into();\n buf.reserve_exact(10);\n assert!(buf.capacity() >= 11);\n ```\n\n [`reserve`]: VecDeque::reserve\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}