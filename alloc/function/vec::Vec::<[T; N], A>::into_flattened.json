{
  "name": "vec::Vec::<[T; N], A>::into_flattened",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::into_raw_parts_with_alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Decomposes a `Vec<T>` into its raw components: `(pointer, length, capacity, allocator)`.\n\n Returns the raw pointer to the underlying data, the length of the vector (in elements),\n the allocated capacity of the data (in elements), and the allocator. These are the same\n arguments in the same order as the arguments to [`from_raw_parts_in`].\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Vec`. The only way to do\n this is to convert the raw pointer, length, and capacity back\n into a `Vec` with the [`from_raw_parts_in`] function, allowing\n the destructor to perform the cleanup.\n\n [`from_raw_parts_in`]: Vec::from_raw_parts_in\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let mut v: Vec<i32, System> = Vec::new_in(System);\n v.push(-1);\n v.push(0);\n v.push(1);\n\n let (ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();\n\n let rebuilt = unsafe {\n     // We can now make changes to the components, such as\n     // transmuting the raw pointer to a compatible type.\n     let ptr = ptr as *mut u32;\n\n     Vec::from_raw_parts_in(ptr, len, cap, alloc)\n };\n assert_eq!(rebuilt, [4294967295, 0, 1]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::num::<impl usize>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "core::num::<impl usize>::unchecked_mul": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur.\n\n Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n\n If you're just trying to avoid the panic in debug mode, then **do not**\n use this.  Instead, you're looking for [`wrapping_mul`].\n\n # Safety\n\n This results in undefined behavior when\n i.e. when [`checked_mul`] would return `None`.\n\n [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::from_raw_parts_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `Vec<T, A>` directly from a pointer, a length, a capacity,\n and an allocator.\n\n # Safety\n\n This is highly unsafe, due to the number of invariants that aren't\n checked:\n\n * `ptr` must be [*currently allocated*] via the given allocator `alloc`.\n * `T` needs to have the same alignment as what `ptr` was allocated with.\n   (`T` having a less strict alignment is not sufficient, the alignment really\n   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n   allocated and deallocated with the same layout.)\n * The size of `T` times the `capacity` (ie. the allocated size in bytes) needs\n   to be the same size as the pointer was allocated with. (Because similar to\n   alignment, [`dealloc`] must be called with the same layout `size`.)\n * `length` needs to be less than or equal to `capacity`.\n * The first `length` values must be properly initialized values of type `T`.\n * `capacity` needs to [*fit*] the layout size that the pointer was allocated with.\n * The allocated size in bytes must be no larger than `isize::MAX`.\n   See the safety documentation of [`pointer::offset`].\n\n These requirements are always upheld by any `ptr` that has been allocated\n via `Vec<T, A>`. Other allocation sources are allowed if the invariants are\n upheld.\n\n Violating these may cause problems like corrupting the allocator's\n internal data structures. For example it is **not** safe\n to build a `Vec<u8>` from a pointer to a C `char` array with length `size_t`.\n It's also not safe to build one from a `Vec<u16>` and its length, because\n the allocator cares about the alignment, and these two types have different\n alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n turning it into a `Vec<u8>` it'll be deallocated with alignment 1.\n\n The ownership of `ptr` is effectively transferred to the\n `Vec<T>` which may then deallocate, reallocate or change the\n contents of memory pointed to by the pointer at will. Ensure\n that nothing else uses the pointer after calling this\n function.\n\n [`String`]: crate::string::String\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [*currently allocated*]: crate::alloc::Allocator#currently-allocated-memory\n [*fit*]: crate::alloc::Allocator#memory-fitting\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n use std::ptr;\n\n let mut v = Vec::with_capacity_in(3, System);\n v.push(1);\n v.push(2);\n v.push(3);\n\n // Deconstruct the vector into parts.\n let (p, len, cap, alloc) = v.into_raw_parts_with_alloc();\n\n unsafe {\n     // Overwrite memory with 4, 5, 6\n     for i in 0..len {\n         ptr::write(p.add(i), 4 + i);\n     }\n\n     // Put everything back together into a Vec\n     let rebuilt = Vec::from_raw_parts_in(p, len, cap, alloc.clone());\n     assert_eq!(rebuilt, [4, 5, 6]);\n }\n ```\n\n Using memory that was allocated elsewhere:\n\n ```rust\n #![feature(allocator_api)]\n\n use std::alloc::{AllocError, Allocator, Global, Layout};\n\n fn main() {\n     let layout = Layout::array::<u32>(16).expect(\"overflow cannot happen\");\n\n     let vec = unsafe {\n         let mem = match Global.allocate(layout) {\n             Ok(mem) => mem.cast::<u32>().as_ptr(),\n             Err(AllocError) => return,\n         };\n\n         mem.write(1_000_000);\n\n         Vec::from_raw_parts_in(mem, 1, 16, Global)\n     };\n\n     assert_eq!(vec, &[1_000_000]);\n     assert_eq!(vec.capacity(), 16);\n }\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::vec::Vec::<[T; N], A>::into_flattened"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3425:5: 3444:6",
  "src": "pub fn into_flattened(self) -> Vec<T, A> {\n        let (ptr, len, cap, alloc) = self.into_raw_parts_with_alloc();\n        let (new_len, new_cap) = if T::IS_ZST {\n            (len.checked_mul(N).expect(\"vec len overflow\"), usize::MAX)\n        } else {\n            // SAFETY:\n            // - `cap * N` cannot overflow because the allocation is already in\n            // the address space.\n            // - Each `[T; N]` has `N` valid elements, so there are `len * N`\n            // valid elements in the allocation.\n            unsafe { (len.unchecked_mul(N), cap.unchecked_mul(N)) }\n        };\n        // SAFETY:\n        // - `ptr` was allocated by `self`\n        // - `ptr` is well-aligned because `[T; N]` has the same alignment as `T`.\n        // - `new_cap` refers to the same sized allocation as `cap` because\n        // `new_cap * size_of::<T>()` == `cap * size_of::<[T; N]>()`\n        // - `len` <= `cap`, so `len * N` <= `cap * N`.\n        unsafe { Vec::<T, A>::from_raw_parts_in(ptr.cast(), new_len, new_cap, alloc) }\n    }",
  "mir": "fn vec::Vec::<[T; N], A>::into_flattened(_1: vec::Vec<[T; N], A>) -> vec::Vec<T, A> {\n    let mut _0: vec::Vec<T, A>;\n    let  _2: *mut [T; N];\n    let  _3: usize;\n    let  _4: usize;\n    let  _5: A;\n    let mut _6: (*mut [T; N], usize, usize, A);\n    let  _7: usize;\n    let  _8: usize;\n    let mut _9: (usize, usize);\n    let mut _10: usize;\n    let mut _11: core::option::Option<usize>;\n    let mut _12: &str;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: *mut T;\n    debug self => _1;\n    debug ptr => _2;\n    debug len => _3;\n    debug cap => _4;\n    debug alloc => _5;\n    debug new_len => _7;\n    debug new_cap => _8;\n    bb0: {\n        StorageLive(_6);\n        _6 = vec::Vec::<[T; N], A>::into_raw_parts_with_alloc(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = (_6.0: *mut [T; N]);\n        _3 = (_6.1: usize);\n        _4 = (_6.2: usize);\n        _5 = move (_6.3: A);\n        StorageDead(_6);\n        StorageLive(_9);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = core::num::<impl usize>::checked_mul(_3, N) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_12);\n        _12 = \"vec len overflow\";\n        _10 = core::option::Option::<usize>::expect(move _11, move _12) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = (move _10, core::num::<impl usize>::MAX);\n        StorageDead(_10);\n        goto -> bb8;\n    }\n    bb5: {\n        StorageLive(_13);\n        _13 = core::num::<impl usize>::unchecked_mul(_3, N) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_14);\n        _14 = core::num::<impl usize>::unchecked_mul(_4, N) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = (move _13, move _14);\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb8;\n    }\n    bb8: {\n        _7 = (_9.0: usize);\n        _8 = (_9.1: usize);\n        StorageDead(_9);\n        StorageLive(_15);\n        _15 = core::ptr::mut_ptr::<impl *mut [T; N]>::cast::<T>(_2) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _0 = vec::Vec::<T, A>::from_raw_parts_in(move _15, _7, _8, _5) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        return;\n    }\n}\n",
  "doc": " Takes a `Vec<[T; N]>` and flattens it into a `Vec<T>`.\n\n # Panics\n\n Panics if the length of the resulting vector would overflow a `usize`.\n\n This is only possible when flattening a vector of arrays of zero-sized\n types, and thus tends to be irrelevant in practice. If\n `size_of::<T>() > 0`, this will never panic.\n\n # Examples\n\n ```\n let mut vec = vec![[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n assert_eq!(vec.pop(), Some([7, 8, 9]));\n\n let mut flattened = vec.into_flattened();\n assert_eq!(flattened.pop(), Some(6));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}