{
  "name": "sync::Arc::<T, A>::strong_count",
  "safe": true,
  "callees": {
    "sync::Arc::<T, A>::inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::Arc": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicUsize::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::Arc": [
      "Ref"
    ],
    "sync::ArcInner": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": 2098,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:2003:5: 2005:6",
  "src": "pub fn strong_count(this: &Self) -> usize {\n        this.inner().strong.load(Relaxed)\n    }",
  "mir": "fn sync::Arc::<T, A>::strong_count(_1: &sync::Arc<T, A>) -> usize {\n    let mut _0: usize;\n    let mut _2: &core::sync::atomic::AtomicUsize;\n    let  _3: &sync::ArcInner<T>;\n    let mut _4: core::sync::atomic::Ordering;\n    debug this => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = sync::Arc::<T, A>::inner(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = &((*_3).0: core::sync::atomic::AtomicUsize);\n        StorageLive(_4);\n        _4 = core::sync::atomic::Ordering::Relaxed;\n        _0 = core::sync::atomic::AtomicUsize::load(move _2, move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Gets the number of strong (`Arc`) pointers to this allocation.\n\n # Safety\n\n This method by itself is safe, but using it correctly requires extra care.\n Another thread can change the strong count at any time,\n including potentially between calling this method and acting on the result.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n let _also_five = Arc::clone(&five);\n\n // This assertion is deterministic because we haven't shared\n // the `Arc` between threads.\n assert_eq!(2, Arc::strong_count(&five));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}