{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::extract_if",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::map::BTreeMap": "MutableAsArgument",
        "collections::btree::map::ExtractIfInner": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "MutRef"
    ],
    "collections::btree::map::ExtractIfInner": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3267, kind: RigidTy(Adt(AdtDef(DefId { id: 3755, name: \"collections::btree::map::ExtractIfInner\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 3210, kind: Param(ParamTy { index: 4, name: \"R\" }) })]))) })])",
      "Unknown([Field(1, Ty { id: 881, kind: Param(ParamTy { index: 2, name: \"A\" }) })])"
    ],
    "collections::btree::map::ExtractIf": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1466:5: 1474:6",
  "src": "pub fn extract_if<F, R>(&mut self, range: R, pred: F) -> ExtractIf<'_, K, V, R, F, A>\n    where\n        K: Ord,\n        R: RangeBounds<K>,\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        let (inner, alloc) = self.extract_if_inner(range);\n        ExtractIf { pred, inner, alloc }\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::extract_if(_1: &mut collections::btree::map::BTreeMap<K, V, A>, _2: R, _3: F) -> collections::btree::map::ExtractIf<'_, K, V, R, F, A> {\n    let mut _0: collections::btree::map::ExtractIf<'_, K, V, R, F, A>;\n    let  _4: collections::btree::map::ExtractIfInner<'_, K, V, R>;\n    let  _5: A;\n    let mut _6: (collections::btree::map::ExtractIfInner<'_, K, V, R>, A);\n    debug self => _1;\n    debug range => _2;\n    debug pred => _3;\n    debug inner => _4;\n    debug alloc => _5;\n    bb0: {\n        StorageLive(_6);\n        _6 = collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner::<R>(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = move (_6.0: collections::btree::map::ExtractIfInner<'_, K, V, R>);\n        _5 = move (_6.1: A);\n        StorageDead(_6);\n        _0 = ExtractIf(_3, _4, _5);\n        return;\n    }\n}\n",
  "doc": " Creates an iterator that visits elements (key-value pairs) in the specified range in\n ascending key order and uses a closure to determine if an element\n should be removed.\n\n If the closure returns `true`, the element is removed from the map and\n yielded. If the closure returns `false`, or panics, the element remains\n in the map and will not be yielded.\n\n The iterator also lets you mutate the value of each element in the\n closure, regardless of whether you choose to keep or remove it.\n\n If the returned `ExtractIf` is not exhausted, e.g. because it is dropped without iterating\n or the iteration short-circuits, then the remaining elements will be retained.\n Use `extract_if().for_each(drop)` if you do not need the returned iterator,\n or [`retain`] with a negated predicate if you also do not need to restrict the range.\n\n [`retain`]: BTreeMap::retain\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n // Splitting a map into even and odd keys, reusing the original map:\n let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n let evens: BTreeMap<_, _> = map.extract_if(.., |k, _v| k % 2 == 0).collect();\n let odds = map;\n assert_eq!(evens.keys().copied().collect::<Vec<_>>(), [0, 2, 4, 6]);\n assert_eq!(odds.keys().copied().collect::<Vec<_>>(), [1, 3, 5, 7]);\n\n // Splitting a map into low and high halves, reusing the original map:\n let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n let low: BTreeMap<_, _> = map.extract_if(0..4, |_k, _v| true).collect();\n let high = map;\n assert_eq!(low.keys().copied().collect::<Vec<_>>(), [0, 1, 2, 3]);\n assert_eq!(high.keys().copied().collect::<Vec<_>>(), [4, 5, 6, 7]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}