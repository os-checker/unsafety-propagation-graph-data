{
  "name": "collections::vec_deque::VecDeque::<T, A>::copy_slice",
  "safe": false,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marginally more convenient\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::copy_slice"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:509:5: 523:6",
  "src": "unsafe fn copy_slice(&mut self, dst: usize, src: &[T]) {\n        debug_assert!(src.len() <= self.capacity());\n        let head_room = self.capacity() - dst;\n        if src.len() <= head_room {\n            unsafe {\n                ptr::copy_nonoverlapping(src.as_ptr(), self.ptr().add(dst), src.len());\n            }\n        } else {\n            let (left, right) = src.split_at(head_room);\n            unsafe {\n                ptr::copy_nonoverlapping(left.as_ptr(), self.ptr().add(dst), left.len());\n                ptr::copy_nonoverlapping(right.as_ptr(), self.ptr(), right.len());\n            }\n        }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::copy_slice(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize, _3: &[T]) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: &collections::vec_deque::VecDeque<T, A>;\n    let mut _8: !;\n    let  _9: usize;\n    let mut _10: usize;\n    let mut _11: &collections::vec_deque::VecDeque<T, A>;\n    let mut _12: (usize, bool);\n    let mut _13: bool;\n    let mut _14: usize;\n    let  _15: ();\n    let mut _16: *const T;\n    let mut _17: *mut T;\n    let mut _18: *mut T;\n    let mut _19: &collections::vec_deque::VecDeque<T, A>;\n    let mut _20: usize;\n    let  _21: &[T];\n    let  _22: &[T];\n    let mut _23: (&[T], &[T]);\n    let  _24: ();\n    let mut _25: *const T;\n    let mut _26: *mut T;\n    let mut _27: *mut T;\n    let mut _28: &collections::vec_deque::VecDeque<T, A>;\n    let mut _29: usize;\n    let  _30: ();\n    let mut _31: *const T;\n    let mut _32: *mut T;\n    let mut _33: &collections::vec_deque::VecDeque<T, A>;\n    let mut _34: usize;\n    debug self => _1;\n    debug dst => _2;\n    debug src => _3;\n    debug head_room => _9;\n    debug left => _21;\n    debug right => _22;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = PtrMetadata(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = collections::vec_deque::VecDeque::<T, A>::capacity(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _4 = Le(move _5, move _6);\n        switchInt(move _4) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(*_1);\n        _10 = collections::vec_deque::VecDeque::<T, A>::capacity(move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _8 = core::panicking::panic(\"assertion failed: src.len() <= self.capacity()\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_11);\n        _12 = CheckedSub(_10, _2);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _10, _2) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = move (_12.0: usize);\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = PtrMetadata(_3);\n        _13 = Le(move _14, _9);\n        switchInt(move _13) -> [0: bb11, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = core::slice::<impl [T]>::as_ptr(_3) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &(*_1);\n        _18 = collections::vec_deque::VecDeque::<T, A>::ptr(move _19) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_19);\n        _17 = core::ptr::mut_ptr::<impl *mut T>::add(move _18, _2) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = PtrMetadata(_3);\n        _15 = core::ptr::copy_nonoverlapping::<T>(move _16, move _17, move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb20;\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageLive(_23);\n        _23 = core::slice::<impl [T]>::split_at(_3, _9) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _21 = (_23.0: &[T]);\n        _22 = (_23.1: &[T]);\n        StorageDead(_23);\n        StorageLive(_25);\n        _25 = core::slice::<impl [T]>::as_ptr(_21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &(*_1);\n        _27 = collections::vec_deque::VecDeque::<T, A>::ptr(move _28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_28);\n        _26 = core::ptr::mut_ptr::<impl *mut T>::add(move _27, _2) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_27);\n        StorageLive(_29);\n        _29 = PtrMetadata(_21);\n        _24 = core::ptr::copy_nonoverlapping::<T>(move _25, move _26, move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_31);\n        _31 = core::slice::<impl [T]>::as_ptr(_22) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &(*_1);\n        _32 = collections::vec_deque::VecDeque::<T, A>::ptr(move _33) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_33);\n        StorageLive(_34);\n        _34 = PtrMetadata(_22);\n        _30 = core::ptr::copy_nonoverlapping::<T>(move _31, move _32, move _34) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_34);\n        StorageDead(_32);\n        StorageDead(_31);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " Copies all values from `src` to `dst`, wrapping around if needed.\n Assumes capacity is sufficient.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}