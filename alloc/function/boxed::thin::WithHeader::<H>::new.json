{
  "name": "boxed::thin::WithHeader::<H>::new",
  "safe": true,
  "callees": {
    "core::alloc::Layout::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a `Layout` suitable for holding a value of type `T`.\n",
      "adt": {}
    },
    "boxed::thin::WithHeader::<H>::alloc_layout": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::alloc::Layout": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "alloc::handle_alloc_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Signals a memory allocation error.\n\n Callers of memory allocation APIs wishing to cease execution\n in response to an allocation error are encouraged to call this function,\n rather than directly invoking [`panic!`] or similar.\n\n This function is guaranteed to diverge (not return normally with a value), but depending on\n global configuration, it may either panic (resulting in unwinding or aborting as per\n configuration for all panics), or abort the process (with no unwinding).\n\n The default behavior is:\n\n  * If the binary links against `std` (typically the case), then\n   print a message to standard error and abort the process.\n   This behavior can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n   Future versions of Rust may panic by default instead.\n\n * If the binary does not link against `std` (all of its crates are marked\n   [`#![no_std]`][no_std]), then call [`panic!`] with a message.\n   [The panic handler] applies as to any panic.\n\n [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n [The panic handler]: https://doc.rust-lang.org/reference/runtime.html#the-panic_handler-attribute\n [no_std]: https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute\n",
      "adt": {}
    },
    "core::alloc::Layout::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum size in bytes for a memory block of this layout.\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::alloc::Layout::dangling": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `NonNull` that is dangling, but well-aligned for this Layout.\n\n Note that the address of the returned pointer may potentially\n be that of a valid pointer, which means this must not be used\n as a \"not yet initialized\" sentinel value.\n Types that lazily allocate must track initialization by some other means.\n",
      "adt": {}
    },
    "alloc::alloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates memory with the global allocator.\n\n This function forwards calls to the [`GlobalAlloc::alloc`] method\n of the allocator registered with the `#[global_allocator]` attribute\n if there is one, or the `std` crate’s default.\n\n This function is expected to be deprecated in favor of the `allocate` method\n of the [`Global`] type when it and the [`Allocator`] trait become stable.\n\n # Safety\n\n See [`GlobalAlloc::alloc`].\n\n # Examples\n\n ```\n use std::alloc::{alloc, dealloc, handle_alloc_error, Layout};\n\n unsafe {\n     let layout = Layout::new::<u16>();\n     let ptr = alloc(layout);\n     if ptr.is_null() {\n         handle_alloc_error(layout);\n     }\n\n     *(ptr as *mut u16) = 42;\n     assert_eq!(*(ptr as *mut u16), 42);\n\n     dealloc(ptr, layout);\n }\n ```\n",
      "adt": {
        "core::alloc::Layout": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull`.\n\n # Safety\n\n `ptr` must be non-null.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = unsafe { NonNull::new_unchecked(&mut x as *mut _) };\n ```\n\n *Incorrect* usage of this function:\n\n ```rust,no_run\n use std::ptr::NonNull;\n\n // NEVER DO THAT!!! This is undefined behavior. ⚠️\n let ptr = unsafe { NonNull::<u32>::new_unchecked(std::ptr::null_mut()) };\n ```\n",
      "adt": {}
    },
    "boxed::thin::WithHeader::<H>::header": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "boxed::thin::WithHeader": "ImmutableAsArgument"
      }
    },
    "core::ptr::write": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Overwrites a memory location with the given value without reading or\n dropping the old value.\n\n `write` does not drop the contents of `dst`. This is safe, but it could leak\n allocations or resources, so care should be taken not to overwrite an object\n that should be dropped.\n\n Additionally, it does not drop `src`. Semantically, `src` is moved into the\n location pointed to by `dst`.\n\n This is appropriate for initializing uninitialized memory, or overwriting\n memory that has previously been [`read`] from.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be [valid] for writes.\n\n * `dst` must be properly aligned. Use [`write_unaligned`] if this is not the\n   case.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n [valid]: self#safety\n\n # Examples\n\n Basic usage:\n\n ```\n let mut x = 0;\n let y = &mut x as *mut i32;\n let z = 12;\n\n unsafe {\n     std::ptr::write(y, z);\n     assert_eq!(std::ptr::read(y), 12);\n }\n ```\n\n Manually implement [`mem::swap`]:\n\n ```\n use std::ptr;\n\n fn swap<T>(a: &mut T, b: &mut T) {\n     unsafe {\n         // Create a bitwise copy of the value at `a` in `tmp`.\n         let tmp = ptr::read(a);\n\n         // Exiting at this point (either by explicitly returning or by\n         // calling a function which panics) would cause the value in `tmp` to\n         // be dropped while the same value is still referenced by `a`. This\n         // could trigger undefined behavior if `T` is not `Copy`.\n\n         // Create a bitwise copy of the value at `b` in `a`.\n         // This is safe because mutable references cannot alias.\n         ptr::copy_nonoverlapping(b, a, 1);\n\n         // As above, exiting here could trigger undefined behavior because\n         // the same value is referenced by `a` and `b`.\n\n         // Move `tmp` into `b`.\n         ptr::write(b, tmp);\n\n         // `tmp` has been moved (`write` takes ownership of its second argument),\n         // so nothing is dropped implicitly here.\n     }\n }\n\n let mut foo = \"foo\".to_owned();\n let mut bar = \"bar\".to_owned();\n\n swap(&mut foo, &mut bar);\n\n assert_eq!(foo, \"bar\");\n assert_eq!(bar, \"foo\");\n ```\n",
      "adt": {}
    },
    "boxed::thin::WithHeader::<H>::value": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "boxed::thin::WithHeader": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 318, kind: RigidTy(Tuple([Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(0, Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 318, kind: RigidTy(Tuple([Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "boxed::thin::WithHeader": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::boxed::thin::WithHeader::<H>::new"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed/thin.rs:228:5: 267:6",
  "src": "fn new<T>(header: H, value: T) -> WithHeader<H> {\n        let value_layout = Layout::new::<T>();\n        let Ok((layout, value_offset)) = Self::alloc_layout(value_layout) else {\n            // We pass an empty layout here because we do not know which layout caused the\n            // arithmetic overflow in `Layout::extend` and `handle_alloc_error` takes `Layout` as\n            // its argument rather than `Result<Layout, LayoutError>`, also this function has been\n            // stable since 1.28 ._.\n            //\n            // On the other hand, look at this gorgeous turbofish!\n            alloc::handle_alloc_error(Layout::new::<()>());\n        };\n\n        unsafe {\n            // Note: It's UB to pass a layout with a zero size to `alloc::alloc`, so\n            // we use `layout.dangling()` for this case, which should have a valid\n            // alignment for both `T` and `H`.\n            let ptr = if layout.size() == 0 {\n                // Some paranoia checking, mostly so that the ThinBox tests are\n                // more able to catch issues.\n                debug_assert!(value_offset == 0 && T::IS_ZST && H::IS_ZST);\n                layout.dangling()\n            } else {\n                let ptr = alloc::alloc(layout);\n                if ptr.is_null() {\n                    alloc::handle_alloc_error(layout);\n                }\n                // Safety:\n                // - The size is at least `aligned_header_size`.\n                let ptr = ptr.add(value_offset) as *mut _;\n\n                NonNull::new_unchecked(ptr)\n            };\n\n            let result = WithHeader(ptr, PhantomData);\n            ptr::write(result.header(), header);\n            ptr::write(result.value().cast(), value);\n\n            result\n        }\n    }",
  "mir": "fn boxed::thin::WithHeader::<H>::new(_1: H, _2: T) -> boxed::thin::WithHeader<H> {\n    let mut _0: boxed::thin::WithHeader<H>;\n    let  _3: core::alloc::Layout;\n    let  _4: !;\n    let mut _5: core::alloc::Layout;\n    let  _6: core::alloc::Layout;\n    let  _7: usize;\n    let mut _8: core::result::Result<(core::alloc::Layout, usize), core::alloc::LayoutError>;\n    let mut _9: isize;\n    let  _10: core::ptr::NonNull<u8>;\n    let mut _11: usize;\n    let mut _12: &core::alloc::Layout;\n    let mut _13: !;\n    let mut _14: &core::alloc::Layout;\n    let  _15: *mut u8;\n    let mut _16: bool;\n    let  _17: !;\n    let mut _18: *mut u8;\n    let mut _19: core::ptr::NonNull<u8>;\n    let  _20: ();\n    let mut _21: *mut H;\n    let mut _22: &boxed::thin::WithHeader<H>;\n    let  _23: ();\n    let mut _24: *mut T;\n    let mut _25: *mut u8;\n    let mut _26: &boxed::thin::WithHeader<H>;\n    debug header => _1;\n    debug value => _2;\n    debug value_layout => _3;\n    debug layout => _6;\n    debug value_offset => _7;\n    debug ptr => _10;\n    debug ptr => _15;\n    debug ptr => _18;\n    debug result => _0;\n    bb0: {\n        _3 = core::alloc::Layout::new::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_8);\n        _8 = boxed::thin::WithHeader::<H>::alloc_layout(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        _4 = alloc::handle_alloc_error(move _5) -> unwind unreachable;\n    }\n    bb3: {\n        _9 = discriminant(_8);\n        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb27];\n    }\n    bb4: {\n        _6 = (((_8 as variant#0).0: (core::alloc::Layout, usize)).0: core::alloc::Layout);\n        _7 = (((_8 as variant#0).0: (core::alloc::Layout, usize)).1: usize);\n        StorageDead(_8);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_6;\n        _11 = core::alloc::Layout::size(move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageLive(_5);\n        _5 = core::alloc::Layout::new::<()>() -> [return: bb2, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        switchInt(move _11) -> [0: bb7, otherwise: bb14];\n    }\n    bb7: {\n        StorageDead(_11);\n        switchInt(_7) -> [0: bb8, otherwise: bb10];\n    }\n    bb8: {\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb11, otherwise: bb9];\n    }\n    bb9: {\n        switchInt(<H as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb11, otherwise: bb12];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        _13 = core::panicking::panic(\"assertion failed: value_offset == 0 && T::IS_ZST && H::IS_ZST\") -> unwind unreachable;\n    }\n    bb12: {\n        StorageLive(_14);\n        _14 = &_6;\n        _10 = core::alloc::Layout::dangling(move _14) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_14);\n        goto -> bb21;\n    }\n    bb14: {\n        StorageDead(_11);\n        _15 = alloc::alloc(_6) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_16);\n        _16 = core::ptr::mut_ptr::<impl *mut u8>::is_null(_15) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        switchInt(move _16) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        _17 = alloc::handle_alloc_error(_6) -> unwind unreachable;\n    }\n    bb18: {\n        StorageDead(_16);\n        _18 = core::ptr::mut_ptr::<impl *mut u8>::add(_15, _7) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _10 = core::ptr::NonNull::<u8>::new_unchecked(_18) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_19);\n        _19 = _10;\n        _0 = WithHeader(move _19, ZeroSized: core::marker::PhantomData<H>);\n        StorageDead(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_0;\n        _21 = boxed::thin::WithHeader::<H>::header(move _22) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_22);\n        _20 = core::ptr::write::<H>(move _21, _1) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_21);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_0;\n        _25 = boxed::thin::WithHeader::<H>::value(move _26) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_26);\n        _24 = core::ptr::mut_ptr::<impl *mut u8>::cast::<T>(move _25) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_25);\n        _23 = core::ptr::write::<T>(move _24, _2) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_24);\n        StorageDead(_10);\n        return;\n    }\n    bb27: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}