{
  "name": "collections::btree::node::BalancingContext::<'a, K, V>::merge_tracking_child_edge",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::merge_tracking_child": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Merges the parent's key-value pair and both adjacent child nodes into\n the left child node and returns that child node.\n\n Panics unless we `.can_merge()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::new_edge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to an edge in `node`.\n Unsafe because the caller must ensure that `idx <= node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Ref",
      "Plain"
    ],
    "collections::btree::node::BalancingContext": [
      "Unknown([Field(1, Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])",
      "Plain"
    ],
    "collections::btree::node::LeftOrRight": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::node::BalancingContext::<'a, K, V>::merge_tracking_child_edge"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:1484:5: 1501:6",
  "src": "pub(super) fn merge_tracking_child_edge<A: Allocator + Clone>(\n        self,\n        track_edge_idx: LeftOrRight<usize>,\n        alloc: A,\n    ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {\n        let old_left_len = self.left_child.len();\n        let right_len = self.right_child.len();\n        assert!(match track_edge_idx {\n            LeftOrRight::Left(idx) => idx <= old_left_len,\n            LeftOrRight::Right(idx) => idx <= right_len,\n        });\n        let child = self.merge_tracking_child(alloc);\n        let new_idx = match track_edge_idx {\n            LeftOrRight::Left(idx) => idx,\n            LeftOrRight::Right(idx) => old_left_len + 1 + idx,\n        };\n        unsafe { Handle::new_edge(child, new_idx) }\n    }",
  "mir": "fn collections::btree::node::BalancingContext::<'a, K, V>::merge_tracking_child_edge(_1: collections::btree::node::BalancingContext<'_, K, V>, _2: collections::btree::node::LeftOrRight<usize>, _3: A) -> collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge> {\n    let mut _0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>;\n    let  _4: usize;\n    let mut _5: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _6: usize;\n    let mut _7: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _8: bool;\n    let mut _9: isize;\n    let  _10: usize;\n    let  _11: usize;\n    let mut _12: !;\n    let  _13: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _14: usize;\n    let mut _15: isize;\n    let  _16: usize;\n    let  _17: usize;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let mut _20: (usize, bool);\n    let mut _21: usize;\n    debug self => _1;\n    debug track_edge_idx => _2;\n    debug alloc => _3;\n    debug old_left_len => _4;\n    debug right_len => _6;\n    debug idx => _10;\n    debug idx => _11;\n    debug child => _13;\n    debug new_idx => _14;\n    debug idx => _16;\n    debug idx => _17;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(_1.1: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        _4 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_7);\n        _7 = &(_1.2: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        _6 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _9 = discriminant(_2);\n        switchInt(move _9) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _11 = ((_2 as variant#1).0: usize);\n        _8 = Le(_11, _6);\n        goto -> bb6;\n    }\n    bb5: {\n        _10 = ((_2 as variant#0).0: usize);\n        _8 = Le(_10, _4);\n        goto -> bb6;\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb7, otherwise: bb8];\n    }\n    bb7: {\n        _12 = core::panicking::panic(\"assertion failed: match track_edge_idx {\\n    LeftOrRight::Left(idx) => idx <= old_left_len,\\n    LeftOrRight::Right(idx) => idx <= right_len,\\n}\") -> unwind unreachable;\n    }\n    bb8: {\n        StorageDead(_8);\n        _13 = collections::btree::node::BalancingContext::<'_, K, V>::merge_tracking_child::<A>(_1, _3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_14);\n        _15 = discriminant(_2);\n        switchInt(move _15) -> [0: bb11, 1: bb10, otherwise: bb3];\n    }\n    bb10: {\n        _17 = ((_2 as variant#1).0: usize);\n        StorageLive(_18);\n        _19 = CheckedAdd(_4, 1_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, 1_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_16);\n        _16 = ((_2 as variant#0).0: usize);\n        _14 = _16;\n        StorageDead(_16);\n        goto -> bb14;\n    }\n    bb12: {\n        _18 = move (_19.0: usize);\n        _20 = CheckedAdd(_18, _17);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _18, _17) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _14 = move (_20.0: usize);\n        StorageDead(_18);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_21);\n        _21 = _14;\n        _0 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>::new_edge(_13, move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        StorageDead(_14);\n        return;\n    }\n}\n",
  "doc": " Merges the parent's key-value pair and both adjacent child nodes into\n the left child node and returns the edge handle in that child node\n where the tracked child edge ended up,\n\n Panics unless we `.can_merge()`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}