{
  "name": "<collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq>::eq",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n assert_eq!(deque.len(), 0);\n deque.push_back(1);\n assert_eq!(deque.len(), 1);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq>::eq"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3483:5: 3517:6",
  "src": "fn eq(&self, other: &Self) -> bool {\n        if self.len != other.len() {\n            return false;\n        }\n        let (sa, sb) = self.as_slices();\n        let (oa, ob) = other.as_slices();\n        if sa.len() == oa.len() {\n            sa == oa && sb == ob\n        } else if sa.len() < oa.len() {\n            // Always divisible in three sections, for example:\n            // self:  [a b c|d e f]\n            // other: [0 1 2 3|4 5]\n            // front = 3, mid = 1,\n            // [a b c] == [0 1 2] && [d] == [3] && [e f] == [4 5]\n            let front = sa.len();\n            let mid = oa.len() - front;\n\n            let (oa_front, oa_mid) = oa.split_at(front);\n            let (sb_mid, sb_back) = sb.split_at(mid);\n            debug_assert_eq!(sa.len(), oa_front.len());\n            debug_assert_eq!(sb_mid.len(), oa_mid.len());\n            debug_assert_eq!(sb_back.len(), ob.len());\n            sa == oa_front && sb_mid == oa_mid && sb_back == ob\n        } else {\n            let front = oa.len();\n            let mid = sa.len() - front;\n\n            let (sa_front, sa_mid) = sa.split_at(front);\n            let (ob_mid, ob_back) = ob.split_at(mid);\n            debug_assert_eq!(sa_front.len(), oa.len());\n            debug_assert_eq!(sa_mid.len(), ob_mid.len());\n            debug_assert_eq!(sb.len(), ob_back.len());\n            sa_front == oa && sa_mid == ob_mid && sb == ob_back\n        }\n    }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq>::eq(_1: &collections::vec_deque::VecDeque<T, A>, _2: &collections::vec_deque::VecDeque<T, A>) -> bool {\n    let mut _0: bool;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let  _6: &[T];\n    let  _7: &[T];\n    let mut _8: (&[T], &[T]);\n    let  _9: &[T];\n    let  _10: &[T];\n    let mut _11: (&[T], &[T]);\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: bool;\n    let mut _16: &&[T];\n    let mut _17: &&[T];\n    let mut _18: &&[T];\n    let mut _19: &&[T];\n    let mut _20: bool;\n    let mut _21: usize;\n    let mut _22: usize;\n    let  _23: usize;\n    let  _24: usize;\n    let mut _25: usize;\n    let mut _26: (usize, bool);\n    let  _27: &[T];\n    let  _28: &[T];\n    let mut _29: (&[T], &[T]);\n    let  _30: &[T];\n    let  _31: &[T];\n    let mut _32: (&[T], &[T]);\n    let mut _33: (&usize, &usize);\n    let mut _34: &usize;\n    let  _35: usize;\n    let mut _36: &usize;\n    let  _37: usize;\n    let  _38: &usize;\n    let  _39: &usize;\n    let mut _40: bool;\n    let mut _41: usize;\n    let mut _42: usize;\n    let  _43: core::panicking::AssertKind;\n    let  _44: !;\n    let mut _45: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _46: (&usize, &usize);\n    let mut _47: &usize;\n    let  _48: usize;\n    let mut _49: &usize;\n    let  _50: usize;\n    let  _51: &usize;\n    let  _52: &usize;\n    let mut _53: bool;\n    let mut _54: usize;\n    let mut _55: usize;\n    let  _56: core::panicking::AssertKind;\n    let  _57: !;\n    let mut _58: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _59: (&usize, &usize);\n    let mut _60: &usize;\n    let  _61: usize;\n    let mut _62: &usize;\n    let  _63: usize;\n    let  _64: &usize;\n    let  _65: &usize;\n    let mut _66: bool;\n    let mut _67: usize;\n    let mut _68: usize;\n    let  _69: core::panicking::AssertKind;\n    let  _70: !;\n    let mut _71: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _72: bool;\n    let mut _73: &&[T];\n    let mut _74: &&[T];\n    let mut _75: bool;\n    let mut _76: &&[T];\n    let mut _77: &&[T];\n    let mut _78: &&[T];\n    let mut _79: &&[T];\n    let  _80: usize;\n    let  _81: usize;\n    let mut _82: usize;\n    let mut _83: (usize, bool);\n    let  _84: &[T];\n    let  _85: &[T];\n    let mut _86: (&[T], &[T]);\n    let  _87: &[T];\n    let  _88: &[T];\n    let mut _89: (&[T], &[T]);\n    let mut _90: (&usize, &usize);\n    let mut _91: &usize;\n    let  _92: usize;\n    let mut _93: &usize;\n    let  _94: usize;\n    let  _95: &usize;\n    let  _96: &usize;\n    let mut _97: bool;\n    let mut _98: usize;\n    let mut _99: usize;\n    let  _100: core::panicking::AssertKind;\n    let  _101: !;\n    let mut _102: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _103: (&usize, &usize);\n    let mut _104: &usize;\n    let  _105: usize;\n    let mut _106: &usize;\n    let  _107: usize;\n    let  _108: &usize;\n    let  _109: &usize;\n    let mut _110: bool;\n    let mut _111: usize;\n    let mut _112: usize;\n    let  _113: core::panicking::AssertKind;\n    let  _114: !;\n    let mut _115: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _116: (&usize, &usize);\n    let mut _117: &usize;\n    let  _118: usize;\n    let mut _119: &usize;\n    let  _120: usize;\n    let  _121: &usize;\n    let  _122: &usize;\n    let mut _123: bool;\n    let mut _124: usize;\n    let mut _125: usize;\n    let  _126: core::panicking::AssertKind;\n    let  _127: !;\n    let mut _128: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _129: bool;\n    let mut _130: &&[T];\n    let mut _131: &&[T];\n    let mut _132: bool;\n    let mut _133: &&[T];\n    let mut _134: &&[T];\n    let mut _135: &&[T];\n    let mut _136: &&[T];\n    debug self => _1;\n    debug other => _2;\n    debug sa => _6;\n    debug sb => _7;\n    debug oa => _9;\n    debug ob => _10;\n    debug front => _23;\n    debug mid => _24;\n    debug oa_front => _27;\n    debug oa_mid => _28;\n    debug sb_mid => _30;\n    debug sb_back => _31;\n    debug left_val => _38;\n    debug right_val => _39;\n    debug kind => _43;\n    debug left_val => _51;\n    debug right_val => _52;\n    debug kind => _56;\n    debug left_val => _64;\n    debug right_val => _65;\n    debug kind => _69;\n    debug front => _80;\n    debug mid => _81;\n    debug sa_front => _84;\n    debug sa_mid => _85;\n    debug ob_mid => _87;\n    debug ob_back => _88;\n    debug left_val => _95;\n    debug right_val => _96;\n    debug kind => _100;\n    debug left_val => _108;\n    debug right_val => _109;\n    debug kind => _113;\n    debug left_val => _121;\n    debug right_val => _122;\n    debug kind => _126;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).1: usize);\n        StorageLive(_5);\n        _5 = collections::vec_deque::VecDeque::<T, A>::len(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = Ne(move _4, move _5);\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = false;\n        StorageDead(_3);\n        goto -> bb53;\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_8);\n        _8 = collections::vec_deque::VecDeque::<T, A>::as_slices(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = (_8.0: &[T]);\n        _7 = (_8.1: &[T]);\n        StorageDead(_8);\n        StorageLive(_11);\n        _11 = collections::vec_deque::VecDeque::<T, A>::as_slices(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = (_11.0: &[T]);\n        _10 = (_11.1: &[T]);\n        StorageDead(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = PtrMetadata(_6);\n        StorageLive(_14);\n        _14 = PtrMetadata(_9);\n        _12 = Eq(move _13, move _14);\n        switchInt(move _12) -> [0: bb12, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_6;\n        StorageLive(_17);\n        _17 = &_9;\n        _15 = <&[T] as core::cmp::PartialEq>::eq(move _16, move _17) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _15) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_18);\n        _18 = &_7;\n        StorageLive(_19);\n        _19 = &_10;\n        _0 = <&[T] as core::cmp::PartialEq>::eq(move _18, move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _0 = false;\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_15);\n        goto -> bb52;\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = PtrMetadata(_6);\n        StorageLive(_22);\n        _22 = PtrMetadata(_9);\n        _20 = Lt(move _21, move _22);\n        switchInt(move _20) -> [0: bb32, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _23 = PtrMetadata(_6);\n        StorageLive(_25);\n        _25 = PtrMetadata(_9);\n        _26 = CheckedSub(_25, _23);\n        assert(!move (_26.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _25, _23) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _24 = move (_26.0: usize);\n        StorageDead(_25);\n        StorageLive(_29);\n        _29 = core::slice::<impl [T]>::split_at(_9, _23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _27 = (_29.0: &[T]);\n        _28 = (_29.1: &[T]);\n        StorageDead(_29);\n        StorageLive(_32);\n        _32 = core::slice::<impl [T]>::split_at(_7, _24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _30 = (_32.0: &[T]);\n        _31 = (_32.1: &[T]);\n        StorageDead(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = PtrMetadata(_6);\n        _34 = &_35;\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = PtrMetadata(_27);\n        _36 = &_37;\n        _33 = (move _34, move _36);\n        StorageDead(_36);\n        StorageDead(_34);\n        _38 = (_33.0: &usize);\n        _39 = (_33.1: &usize);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = (*_38);\n        StorageLive(_42);\n        _42 = (*_39);\n        _40 = Eq(move _41, move _42);\n        switchInt(move _40) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_37);\n        StorageDead(_35);\n        StorageDead(_33);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = PtrMetadata(_30);\n        _47 = &_48;\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = PtrMetadata(_28);\n        _49 = &_50;\n        _46 = (move _47, move _49);\n        StorageDead(_49);\n        StorageDead(_47);\n        _51 = (_46.0: &usize);\n        _52 = (_46.1: &usize);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = (*_51);\n        StorageLive(_55);\n        _55 = (*_52);\n        _53 = Eq(move _54, move _55);\n        switchInt(move _53) -> [0: bb20, otherwise: bb19];\n    }\n    bb18: {\n        StorageDead(_42);\n        StorageDead(_41);\n        _43 = core::panicking::AssertKind::Eq;\n        StorageLive(_45);\n        _45 = core::option::Option::None;\n        _44 = core::panicking::assert_failed::<usize, usize>(_43, _38, _39, move _45) -> unwind unreachable;\n    }\n    bb19: {\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageDead(_50);\n        StorageDead(_48);\n        StorageDead(_46);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = PtrMetadata(_31);\n        _60 = &_61;\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = PtrMetadata(_10);\n        _62 = &_63;\n        _59 = (move _60, move _62);\n        StorageDead(_62);\n        StorageDead(_60);\n        _64 = (_59.0: &usize);\n        _65 = (_59.1: &usize);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = (*_64);\n        StorageLive(_68);\n        _68 = (*_65);\n        _66 = Eq(move _67, move _68);\n        switchInt(move _66) -> [0: bb22, otherwise: bb21];\n    }\n    bb20: {\n        StorageDead(_55);\n        StorageDead(_54);\n        _56 = core::panicking::AssertKind::Eq;\n        StorageLive(_58);\n        _58 = core::option::Option::None;\n        _57 = core::panicking::assert_failed::<usize, usize>(_56, _51, _52, move _58) -> unwind unreachable;\n    }\n    bb21: {\n        StorageDead(_68);\n        StorageDead(_67);\n        StorageDead(_66);\n        StorageDead(_63);\n        StorageDead(_61);\n        StorageDead(_59);\n        StorageLive(_72);\n        StorageLive(_73);\n        _73 = &_6;\n        StorageLive(_74);\n        _74 = &_27;\n        _72 = <&[T] as core::cmp::PartialEq>::eq(move _73, move _74) -> [return: bb23, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_68);\n        StorageDead(_67);\n        _69 = core::panicking::AssertKind::Eq;\n        StorageLive(_71);\n        _71 = core::option::Option::None;\n        _70 = core::panicking::assert_failed::<usize, usize>(_69, _64, _65, move _71) -> unwind unreachable;\n    }\n    bb23: {\n        switchInt(move _72) -> [0: bb28, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = &_30;\n        StorageLive(_77);\n        _77 = &_28;\n        _75 = <&[T] as core::cmp::PartialEq>::eq(move _76, move _77) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _75) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_77);\n        StorageDead(_76);\n        StorageLive(_78);\n        _78 = &_31;\n        StorageLive(_79);\n        _79 = &_10;\n        _0 = <&[T] as core::cmp::PartialEq>::eq(move _78, move _79) -> [return: bb30, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_77);\n        StorageDead(_76);\n        goto -> bb29;\n    }\n    bb28: {\n        StorageDead(_74);\n        StorageDead(_73);\n        goto -> bb29;\n    }\n    bb29: {\n        _0 = false;\n        goto -> bb31;\n    }\n    bb30: {\n        StorageDead(_79);\n        StorageDead(_78);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_75);\n        StorageDead(_72);\n        goto -> bb51;\n    }\n    bb32: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _80 = PtrMetadata(_9);\n        StorageLive(_82);\n        _82 = PtrMetadata(_6);\n        _83 = CheckedSub(_82, _80);\n        assert(!move (_83.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _82, _80) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _81 = move (_83.0: usize);\n        StorageDead(_82);\n        StorageLive(_86);\n        _86 = core::slice::<impl [T]>::split_at(_6, _80) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _84 = (_86.0: &[T]);\n        _85 = (_86.1: &[T]);\n        StorageDead(_86);\n        StorageLive(_89);\n        _89 = core::slice::<impl [T]>::split_at(_10, _81) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _87 = (_89.0: &[T]);\n        _88 = (_89.1: &[T]);\n        StorageDead(_89);\n        StorageLive(_90);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = PtrMetadata(_84);\n        _91 = &_92;\n        StorageLive(_93);\n        StorageLive(_94);\n        _94 = PtrMetadata(_9);\n        _93 = &_94;\n        _90 = (move _91, move _93);\n        StorageDead(_93);\n        StorageDead(_91);\n        _95 = (_90.0: &usize);\n        _96 = (_90.1: &usize);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = (*_95);\n        StorageLive(_99);\n        _99 = (*_96);\n        _97 = Eq(move _98, move _99);\n        switchInt(move _97) -> [0: bb37, otherwise: bb36];\n    }\n    bb36: {\n        StorageDead(_99);\n        StorageDead(_98);\n        StorageDead(_97);\n        StorageDead(_94);\n        StorageDead(_92);\n        StorageDead(_90);\n        StorageLive(_103);\n        StorageLive(_104);\n        StorageLive(_105);\n        _105 = PtrMetadata(_85);\n        _104 = &_105;\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = PtrMetadata(_87);\n        _106 = &_107;\n        _103 = (move _104, move _106);\n        StorageDead(_106);\n        StorageDead(_104);\n        _108 = (_103.0: &usize);\n        _109 = (_103.1: &usize);\n        StorageLive(_110);\n        StorageLive(_111);\n        _111 = (*_108);\n        StorageLive(_112);\n        _112 = (*_109);\n        _110 = Eq(move _111, move _112);\n        switchInt(move _110) -> [0: bb39, otherwise: bb38];\n    }\n    bb37: {\n        StorageDead(_99);\n        StorageDead(_98);\n        _100 = core::panicking::AssertKind::Eq;\n        StorageLive(_102);\n        _102 = core::option::Option::None;\n        _101 = core::panicking::assert_failed::<usize, usize>(_100, _95, _96, move _102) -> unwind unreachable;\n    }\n    bb38: {\n        StorageDead(_112);\n        StorageDead(_111);\n        StorageDead(_110);\n        StorageDead(_107);\n        StorageDead(_105);\n        StorageDead(_103);\n        StorageLive(_116);\n        StorageLive(_117);\n        StorageLive(_118);\n        _118 = PtrMetadata(_7);\n        _117 = &_118;\n        StorageLive(_119);\n        StorageLive(_120);\n        _120 = PtrMetadata(_88);\n        _119 = &_120;\n        _116 = (move _117, move _119);\n        StorageDead(_119);\n        StorageDead(_117);\n        _121 = (_116.0: &usize);\n        _122 = (_116.1: &usize);\n        StorageLive(_123);\n        StorageLive(_124);\n        _124 = (*_121);\n        StorageLive(_125);\n        _125 = (*_122);\n        _123 = Eq(move _124, move _125);\n        switchInt(move _123) -> [0: bb41, otherwise: bb40];\n    }\n    bb39: {\n        StorageDead(_112);\n        StorageDead(_111);\n        _113 = core::panicking::AssertKind::Eq;\n        StorageLive(_115);\n        _115 = core::option::Option::None;\n        _114 = core::panicking::assert_failed::<usize, usize>(_113, _108, _109, move _115) -> unwind unreachable;\n    }\n    bb40: {\n        StorageDead(_125);\n        StorageDead(_124);\n        StorageDead(_123);\n        StorageDead(_120);\n        StorageDead(_118);\n        StorageDead(_116);\n        StorageLive(_129);\n        StorageLive(_130);\n        _130 = &_84;\n        StorageLive(_131);\n        _131 = &_9;\n        _129 = <&[T] as core::cmp::PartialEq>::eq(move _130, move _131) -> [return: bb42, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_125);\n        StorageDead(_124);\n        _126 = core::panicking::AssertKind::Eq;\n        StorageLive(_128);\n        _128 = core::option::Option::None;\n        _127 = core::panicking::assert_failed::<usize, usize>(_126, _121, _122, move _128) -> unwind unreachable;\n    }\n    bb42: {\n        switchInt(move _129) -> [0: bb47, otherwise: bb43];\n    }\n    bb43: {\n        StorageDead(_131);\n        StorageDead(_130);\n        StorageLive(_132);\n        StorageLive(_133);\n        _133 = &_85;\n        StorageLive(_134);\n        _134 = &_87;\n        _132 = <&[T] as core::cmp::PartialEq>::eq(move _133, move _134) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        switchInt(move _132) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_134);\n        StorageDead(_133);\n        StorageLive(_135);\n        _135 = &_7;\n        StorageLive(_136);\n        _136 = &_88;\n        _0 = <&[T] as core::cmp::PartialEq>::eq(move _135, move _136) -> [return: bb49, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_134);\n        StorageDead(_133);\n        goto -> bb48;\n    }\n    bb47: {\n        StorageDead(_131);\n        StorageDead(_130);\n        goto -> bb48;\n    }\n    bb48: {\n        _0 = false;\n        goto -> bb50;\n    }\n    bb49: {\n        StorageDead(_136);\n        StorageDead(_135);\n        goto -> bb50;\n    }\n    bb50: {\n        StorageDead(_132);\n        StorageDead(_129);\n        goto -> bb51;\n    }\n    bb51: {\n        StorageDead(_20);\n        goto -> bb52;\n    }\n    bb52: {\n        StorageDead(_12);\n        goto -> bb53;\n    }\n    bb53: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}