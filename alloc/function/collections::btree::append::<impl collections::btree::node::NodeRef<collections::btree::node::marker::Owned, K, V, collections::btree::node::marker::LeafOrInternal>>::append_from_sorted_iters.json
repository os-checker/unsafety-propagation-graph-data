{
  "name": "collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::append_from_sorted_iters",
  "safe": true,
  "callees": {
    "collections::btree::merge_iter::MergeIterInner::<I>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new core for an iterator merging a pair of sources.\n",
      "adt": {
        "collections::btree::merge_iter::MergeIterInner": "Constructor"
      }
    },
    "collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::bulk_push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Pushes all key-value pairs to the end of the tree, incrementing a\n `length` variable along the way. The latter makes it easier for the\n caller to avoid a leak when the iterator panicks.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::merge_iter::MergeIterInner": [
      "Plain"
    ],
    "collections::btree::append::MergeIter": [
      "Plain"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef"
    ]
  },
  "path": 928,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/append.rs:19:5: 34:6",
  "src": "pub(super) fn append_from_sorted_iters<I, A: Allocator + Clone>(\n        &mut self,\n        left: I,\n        right: I,\n        length: &mut usize,\n        alloc: A,\n    ) where\n        K: Ord,\n        I: Iterator<Item = (K, V)> + FusedIterator,\n    {\n        // We prepare to merge `left` and `right` into a sorted sequence in linear time.\n        let iter = MergeIter(MergeIterInner::new(left, right));\n\n        // Meanwhile, we build a tree from the sorted sequence in linear time.\n        self.bulk_push(iter, length, alloc)\n    }",
  "mir": "fn collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::append_from_sorted_iters(_1: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, _2: I, _3: I, _4: &mut usize, _5: A) -> () {\n    let mut _0: ();\n    let  _6: collections::btree::append::MergeIter<K, V, I>;\n    let mut _7: collections::btree::merge_iter::MergeIterInner<I>;\n    debug self => _1;\n    debug left => _2;\n    debug right => _3;\n    debug length => _4;\n    debug alloc => _5;\n    debug iter => _6;\n    bb0: {\n        StorageLive(_7);\n        _7 = collections::btree::merge_iter::MergeIterInner::<I>::new(_2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = MergeIter(move _7);\n        StorageDead(_7);\n        _0 = collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::bulk_push::<collections::btree::append::MergeIter<K, V, I>, A>(_1, _6, _4, _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Appends all key-value pairs from the union of two ascending iterators,\n incrementing a `length` variable along the way. The latter makes it\n easier for the caller to avoid a leak when a drop handler panicks.\n\n If both iterators produce the same key, this method drops the pair from\n the left iterator and appends the pair from the right iterator.\n\n If you want the tree to end up in a strictly ascending order, like for\n a `BTreeMap`, both iterators should produce keys in strictly ascending\n order, each greater than all keys in the tree, including any keys\n already in the tree upon entry.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}