{
  "name": "collections::linked_list::CursorMut::<'a, T, A>::pop_front",
  "safe": true,
  "callees": {
    "collections::linked_list::LinkedList::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the `LinkedList` is empty.\n\n This operation should compute in *O*(1) time.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut dl = LinkedList::new();\n assert!(dl.is_empty());\n\n dl.push_front(\"foo\");\n assert!(!dl.is_empty());\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "collections::linked_list::CursorMut::<'a, T, A>::move_next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves the cursor to the next element of the `LinkedList`.\n\n If the cursor is pointing to the \"ghost\" non-element then this will move it to\n the first element of the `LinkedList`. If it is pointing to the last\n element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n",
      "adt": {
        "collections::linked_list::CursorMut": "MutableAsArgument"
      }
    },
    "collections::linked_list::LinkedList::<T, A>::pop_front": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the first element and returns it, or `None` if the list is\n empty.\n\n This operation should compute in *O*(1) time.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut d = LinkedList::new();\n assert_eq!(d.pop_front(), None);\n\n d.push_front(1);\n d.push_front(3);\n assert_eq!(d.pop_front(), Some(3));\n assert_eq!(d.pop_front(), Some(1));\n assert_eq!(d.pop_front(), None);\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "collections::linked_list::LinkedList": [
      "MutRef",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "collections::linked_list::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::linked_list::CursorMut::<'a, T, A>::pop_front"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/linked_list.rs:1846:5: 1864:6",
  "src": "pub fn pop_front(&mut self) -> Option<T> {\n        // We can't check if current is empty, we must check the list directly.\n        // It is possible for `self.current == None` and the list to be\n        // non-empty.\n        if self.list.is_empty() {\n            None\n        } else {\n            // We can't point to the node that we pop. Copying the behavior of\n            // `remove_current`, we move on to the next node in the sequence.\n            // If the list is of length 1 then we end pointing to the \"ghost\"\n            // node at index 0, which is expected.\n            if self.list.head == self.current {\n                self.move_next();\n            } else {\n                self.index -= 1;\n            }\n            self.list.pop_front()\n        }\n    }",
  "mir": "fn collections::linked_list::CursorMut::<'a, T, A>::pop_front(_1: &mut collections::linked_list::CursorMut<'_, T, A>) -> core::option::Option<T> {\n    let mut _0: core::option::Option<T>;\n    let mut _2: bool;\n    let mut _3: &collections::linked_list::LinkedList<T, A>;\n    let mut _4: bool;\n    let mut _5: &core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let mut _6: &core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let  _7: ();\n    let mut _8: (usize, bool);\n    let mut _9: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _10: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _11: &mut collections::linked_list::LinkedList<T, A>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _9 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _3 = &(*_9);\n        _2 = collections::linked_list::LinkedList::<T, A>::is_empty(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        goto -> bb11;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _10 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _5 = &((*_10).0: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>);\n        StorageLive(_6);\n        _6 = &((*_1).1: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>);\n        _4 = <core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>> as core::cmp::PartialEq>::eq(move _5, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _4) -> [0: bb7, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _7 = collections::linked_list::CursorMut::<'_, T, A>::move_next(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb9;\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _8 = CheckedSub(((*_1).0: usize), 1_usize);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_1).0: usize), 1_usize) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        ((*_1).0: usize) = move (_8.0: usize);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_4);\n        _11 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _0 = collections::linked_list::LinkedList::<T, A>::pop_front(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Removes the first element from the cursor's parent list and returns it,\n or None if the list is empty. The element the cursor points to remains\n unchanged, unless it was pointing to the front element. In that case, it\n points to the new front element.\n\n This operation should compute in *O*(1) time.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}