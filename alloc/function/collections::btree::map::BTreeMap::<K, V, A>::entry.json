{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::entry",
  "safe": true,
  "callees": {
    "collections::btree::borrow::DormantMutRef::<'a, T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Capture a unique borrow, and immediately reborrow it. For the compiler,\n the lifetime of the new reference is the same as the lifetime of the\n original reference, but you promise to use it for a shorter period.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Looks up a given key in a (sub)tree headed by the node, recursively.\n Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n returns a `GoDown` with the handle of the leaf edge where the key belongs.\n\n The result is meaningful only if the tree is ordered by key, like the tree\n in a `BTreeMap` is.\n",
      "adt": {
        "collections::btree::search::SearchResult": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "MutRef",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "Plain",
      "Unknown([Field(0, Ty { id: 2800, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2802, kind: RigidTy(Adt(AdtDef(DefId { id: 3598, name: \"collections::btree::map::BTreeMap\" }), GenericArgs([Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 881, kind: Param(ParamTy { index: 2, name: \"A\" }) })]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 3116, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2802, kind: RigidTy(Adt(AdtDef(DefId { id: 3598, name: \"collections::btree::map::BTreeMap\" }), GenericArgs([Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 881, kind: Param(ParamTy { index: 2, name: \"A\" }) })]))) })]))) })])"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "Ref"
    ],
    "collections::btree::map::entry::VacantEntry": [
      "Plain"
    ],
    "collections::btree::map::entry::Entry": [
      "Plain"
    ],
    "collections::btree::search::SearchResult": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2413, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2412, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2547, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2414, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "collections::btree::map::entry::OccupiedEntry": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::BTreeMap::<K, V, A>::entry"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1343:5: 1372:6",
  "src": "pub fn entry(&mut self, key: K) -> Entry<'_, K, V, A>\n    where\n        K: Ord,\n    {\n        let (map, dormant_map) = DormantMutRef::new(self);\n        match map.root {\n            None => Vacant(VacantEntry {\n                key,\n                handle: None,\n                dormant_map,\n                alloc: (*map.alloc).clone(),\n                _marker: PhantomData,\n            }),\n            Some(ref mut root) => match root.borrow_mut().search_tree(&key) {\n                Found(handle) => Occupied(OccupiedEntry {\n                    handle,\n                    dormant_map,\n                    alloc: (*map.alloc).clone(),\n                    _marker: PhantomData,\n                }),\n                GoDown(handle) => Vacant(VacantEntry {\n                    key,\n                    handle: Some(handle),\n                    dormant_map,\n                    alloc: (*map.alloc).clone(),\n                    _marker: PhantomData,\n                }),\n            },\n        }\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::entry(_1: &mut collections::btree::map::BTreeMap<K, V, A>, _2: K) -> collections::btree::map::entry::Entry<'_, K, V, A> {\n    let mut _0: collections::btree::map::entry::Entry<'_, K, V, A>;\n    let  _3: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let  _4: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _5: (&mut collections::btree::map::BTreeMap<K, V, A>, collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n    let mut _6: isize;\n    let mut _7: collections::btree::map::entry::VacantEntry<'_, K, V, A>;\n    let mut _8: K;\n    let mut _9: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _10: A;\n    let  _11: &A;\n    let mut _12: &core::mem::ManuallyDrop<A>;\n    let  _13: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _14: collections::btree::search::SearchResult<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal, collections::btree::node::marker::Leaf>;\n    let mut _15: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _16: &K;\n    let mut _17: isize;\n    let  _18: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _19: collections::btree::map::entry::OccupiedEntry<'_, K, V, A>;\n    let mut _20: A;\n    let  _21: &A;\n    let mut _22: &core::mem::ManuallyDrop<A>;\n    let  _23: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _24: collections::btree::map::entry::VacantEntry<'_, K, V, A>;\n    let mut _25: K;\n    let mut _26: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _27: A;\n    let  _28: &A;\n    let mut _29: &core::mem::ManuallyDrop<A>;\n    let mut _30: bool;\n    debug self => _1;\n    debug key => _2;\n    debug map => _3;\n    debug dormant_map => _4;\n    debug root => _13;\n    debug handle => _18;\n    debug handle => _23;\n    bb0: {\n        _30 = false;\n        _30 = true;\n        StorageLive(_5);\n        _5 = collections::btree::borrow::DormantMutRef::<'_, collections::btree::map::BTreeMap<K, V, A>>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = move (_5.0: &mut collections::btree::map::BTreeMap<K, V, A>);\n        _4 = move (_5.1: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        StorageDead(_5);\n        _6 = discriminant(((*_3).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>));\n        switchInt(move _6) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _13 = &mut ((((*_3).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>) as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_13) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _30 = false;\n        _8 = move _2;\n        StorageLive(_9);\n        _9 = core::option::Option::None;\n        StorageLive(_10);\n        StorageLive(_12);\n        _12 = &((*_3).2: core::mem::ManuallyDrop<A>);\n        _11 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _10 = <A as core::clone::Clone>::clone(_11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _7 = VacantEntry(move _8, move _9, _4, move _10, ZeroSized: core::marker::PhantomData<&mut (K, V)>);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        _0 = collections::btree::map::entry::Entry::Vacant(move _7);\n        StorageDead(_7);\n        goto -> bb16;\n    }\n    bb7: {\n        _16 = &_2;\n        _14 = collections::btree::search::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree::<K>(move _15, _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        _17 = discriminant(_14);\n        switchInt(move _17) -> [0: bb10, 1: bb9, otherwise: bb2];\n    }\n    bb9: {\n        _23 = move ((_14 as variant#1).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        StorageLive(_24);\n        StorageLive(_25);\n        _30 = false;\n        _25 = move _2;\n        StorageLive(_26);\n        _26 = core::option::Option::Some(_23);\n        StorageLive(_27);\n        StorageLive(_29);\n        _29 = &((*_3).2: core::mem::ManuallyDrop<A>);\n        _28 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _29) -> [return: bb13, unwind unreachable];\n    }\n    bb10: {\n        _18 = move ((_14 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_22);\n        _22 = &((*_3).2: core::mem::ManuallyDrop<A>);\n        _21 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _22) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_22);\n        _20 = <A as core::clone::Clone>::clone(_21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _19 = OccupiedEntry(_18, _4, move _20, ZeroSized: core::marker::PhantomData<&mut (K, V)>);\n        StorageDead(_20);\n        _0 = collections::btree::map::entry::Entry::Occupied(move _19);\n        StorageDead(_19);\n        goto -> bb15;\n    }\n    bb13: {\n        StorageDead(_29);\n        _27 = <A as core::clone::Clone>::clone(_28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _24 = VacantEntry(move _25, move _26, _4, move _27, ZeroSized: core::marker::PhantomData<&mut (K, V)>);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_25);\n        _0 = collections::btree::map::entry::Entry::Vacant(move _24);\n        StorageDead(_24);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_14);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_3);\n        switchInt(_30) -> [0: bb17, otherwise: bb18];\n    }\n    bb17: {\n        return;\n    }\n    bb18: {\n        drop(_2) -> [return: bb17, unwind unreachable];\n    }\n}\n",
  "doc": " Gets the given key's corresponding entry in the map for in-place manipulation.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut count: BTreeMap<&str, usize> = BTreeMap::new();\n\n // count the number of occurrences of letters in the vec\n for x in [\"a\", \"b\", \"a\", \"c\", \"a\", \"b\"] {\n     count.entry(x).and_modify(|curr| *curr += 1).or_insert(1);\n }\n\n assert_eq!(count[\"a\"], 3);\n assert_eq!(count[\"b\"], 2);\n assert_eq!(count[\"c\"], 1);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}