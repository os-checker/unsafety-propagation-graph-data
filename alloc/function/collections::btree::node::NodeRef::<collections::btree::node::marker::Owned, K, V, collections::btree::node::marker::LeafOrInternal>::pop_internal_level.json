{
  "name": "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_internal_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unsafely asserts to the compiler the static information that this node is an `Internal`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::as_internal_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows exclusive access to the data of an internal node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "core::mem::MaybeUninit::<T>::assume_init_read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n to the usual drop handling.\n\n Whenever possible, it is preferable to use [`assume_init`] instead, which\n prevents duplicating the content of the `MaybeUninit<T>`.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n Moreover, similar to the [`ptr::read`] function, this function creates a\n bitwise copy of the contents, regardless whether the contained type\n implements the [`Copy`] trait or not. When using multiple copies of the\n data (by calling `assume_init_read` multiple times, or first calling\n `assume_init_read` and then [`assume_init`]), it is your responsibility\n to ensure that data may indeed be duplicated.\n\n [inv]: #initialization-invariant\n [`assume_init`]: MaybeUninit::assume_init\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<u32>::uninit();\n x.write(13);\n let x1 = unsafe { x.assume_init_read() };\n // `u32` is `Copy`, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(None);\n let x1 = unsafe { x.assume_init_read() };\n // Duplicating a `None` value is okay, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(Some(vec![0, 1, 2]));\n let x1 = unsafe { x.assume_init_read() };\n let x2 = unsafe { x.assume_init_read() };\n // We now created two copies of the same vector, leading to a double-free ⚠️ when\n // they both get dropped!\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::clear_parent_link": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the root's link to its parent edge.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a `Layout` suitable for holding a value of type `T`.\n",
      "adt": {}
    },
    "core::alloc::Allocator::deallocate": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Deallocates the memory referenced by `ptr`.\n\n # Safety\n\n * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n * `layout` must [*fit*] that block of memory.\n\n [*currently allocated*]: #currently-allocated-memory\n [*fit*]: #memory-fitting\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef",
      "Plain"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "collections::btree::node::InternalNode": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::mem::MaybeUninit": [
      "Ref"
    ],
    "core::alloc::Layout": [
      "Plain"
    ]
  },
  "path": 989,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:617:5: 633:6",
  "src": "pub(super) fn pop_internal_level<A: Allocator + Clone>(&mut self, alloc: A) {\n        assert!(self.height > 0);\n\n        let top = self.node;\n\n        // SAFETY: we asserted to be internal.\n        let mut internal_self = unsafe { self.borrow_mut().cast_to_internal_unchecked() };\n        let internal_node = internal_self.as_internal_mut();\n        // SAFETY: the first edge is always initialized.\n        self.node = unsafe { internal_node.edges[0].assume_init_read() };\n        self.height -= 1;\n        self.clear_parent_link();\n\n        unsafe {\n            alloc.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());\n        }\n    }",
  "mir": "fn collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level(_1: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, _2: A) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: !;\n    let  _6: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>;\n    let mut _7: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _8: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _9: &mut collections::btree::node::InternalNode<K, V>;\n    let mut _10: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _11: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>;\n    let mut _12: &core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>;\n    let  _13: usize;\n    let mut _14: bool;\n    let mut _15: (usize, bool);\n    let  _16: ();\n    let  _17: ();\n    let mut _18: &A;\n    let mut _19: core::ptr::NonNull<u8>;\n    let mut _20: core::alloc::Layout;\n    debug self => _1;\n    debug alloc => _2;\n    debug top => _6;\n    debug internal_self => _7;\n    debug internal_node => _9;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).0: usize);\n        _3 = Gt(move _4, 0_usize);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        _6 = ((*_1).1: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = core::panicking::panic(\"assertion failed: self.height > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        _7 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_internal_unchecked(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut _7;\n        _9 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::as_internal_mut(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = 0_usize;\n        _14 = Lt(_13, 12_usize);\n        assert(move _14, \"index out of bounds: the length is {} but the index is {}\", 12_usize, _13) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = &((*_9).1: [core::mem::MaybeUninit<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>; 12])[_13];\n        _11 = core::mem::MaybeUninit::<core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>>::assume_init_read(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_12);\n        ((*_1).1: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>) = move _11;\n        StorageDead(_11);\n        _15 = CheckedSub(((*_1).0: usize), 1_usize);\n        assert(!move (_15.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_1).0: usize), 1_usize) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        ((*_1).0: usize) = move (_15.0: usize);\n        _16 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::clear_parent_link(_1) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_18);\n        _18 = &_2;\n        StorageLive(_19);\n        _19 = core::ptr::NonNull::<collections::btree::node::LeafNode<K, V>>::cast::<u8>(_6) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_20);\n        _20 = core::alloc::Layout::new::<collections::btree::node::InternalNode<K, V>>() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _17 = <A as core::alloc::Allocator>::deallocate(move _18, move _19, move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_9);\n        StorageDead(_7);\n        drop(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        return;\n    }\n}\n",
  "doc": " Removes the internal root node, using its first child as the new root node.\n As it is intended only to be called when the root node has only one child,\n no cleanup is done on any of the keys, values and other children.\n This decreases the height by 1 and is the opposite of `push_internal_level`.\n\n Does not invalidate any handles or references pointing into the subtree\n rooted at the first child of `self`.\n\n Panics if there is no internal level, i.e., if the root node is a leaf.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}