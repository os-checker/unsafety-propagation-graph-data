{
  "name": "rc::Rc::<T, A>::get_mut",
  "safe": true,
  "callees": {
    "rc::Rc::<T, A>::is_unique": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if there are no other `Rc` or [`Weak`] pointers to\n this allocation.\n",
      "adt": {
        "rc::Rc": "ImmutableAsArgument"
      }
    },
    "rc::Rc::<T, A>::get_mut_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference into the given `Rc`,\n without any check.\n\n See also [`get_mut`], which is safe and does appropriate checks.\n\n [`get_mut`]: Rc::get_mut\n\n # Safety\n\n If any other `Rc` or [`Weak`] pointers to the same allocation exist, then\n they must not be dereferenced or have active borrows for the duration\n of the returned borrow, and their inner type must be exactly the same as the\n inner type of this Rc (including lifetimes). This is trivially the case if no\n such pointers exist, for example immediately after `Rc::new`.\n\n # Examples\n\n ```\n #![feature(get_mut_unchecked)]\n\n use std::rc::Rc;\n\n let mut x = Rc::new(String::new());\n unsafe {\n     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n }\n assert_eq!(*x, \"foo\");\n ```\n Other `Rc` pointers to the same allocation must be to the same type.\n ```no_run\n #![feature(get_mut_unchecked)]\n\n use std::rc::Rc;\n\n let x: Rc<str> = Rc::from(\"Hello, world!\");\n let mut y: Rc<[u8]> = x.clone().into();\n unsafe {\n     // this is Undefined Behavior, because x's inner type is str, not [u8]\n     Rc::get_mut_unchecked(&mut y).fill(0xff); // 0xff is invalid in UTF-8\n }\n println!(\"{}\", &*x); // Invalid UTF-8 in a str\n ```\n Other `Rc` pointers to the same allocation must be to the exact same type, including lifetimes.\n ```no_run\n #![feature(get_mut_unchecked)]\n\n use std::rc::Rc;\n\n let x: Rc<&str> = Rc::new(\"Hello, world!\");\n {\n     let s = String::from(\"Oh, no!\");\n     let mut y: Rc<&str> = x.clone();\n     unsafe {\n         // this is Undefined Behavior, because x's inner type\n         // is &'long str, not &'short str\n         *Rc::get_mut_unchecked(&mut y) = &s;\n     }\n }\n println!(\"{}\", &*x); // Use-after-free\n ```\n",
      "adt": {
        "rc::Rc": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "rc::Rc": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::rc::Rc::<T, A>::get_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:1917:5: 1919:6",
  "src": "pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n        if Rc::is_unique(this) { unsafe { Some(Rc::get_mut_unchecked(this)) } } else { None }\n    }",
  "mir": "fn rc::Rc::<T, A>::get_mut(_1: &mut rc::Rc<T, A>) -> core::option::Option<&mut T> {\n    let mut _0: core::option::Option<&mut T>;\n    let mut _2: bool;\n    let mut _3: &rc::Rc<T, A>;\n    let mut _4: &mut T;\n    debug this => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &(*_1);\n        _2 = rc::Rc::<T, A>::is_unique(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = rc::Rc::<T, A>::get_mut_unchecked(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core::option::Option::Some(_4);\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a mutable reference into the given `Rc`, if there are\n no other `Rc` or [`Weak`] pointers to the same allocation.\n\n Returns [`None`] otherwise, because it is not safe to\n mutate a shared value.\n\n See also [`make_mut`][make_mut], which will [`clone`][clone]\n the inner value when there are other `Rc` pointers.\n\n [make_mut]: Rc::make_mut\n [clone]: Clone::clone\n\n # Examples\n\n ```\n use std::rc::Rc;\n\n let mut x = Rc::new(3);\n *Rc::get_mut(&mut x).unwrap() = 4;\n assert_eq!(*x, 4);\n\n let _y = Rc::clone(&x);\n assert!(Rc::get_mut(&mut x).is_none());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}