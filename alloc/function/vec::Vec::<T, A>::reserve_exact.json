{
  "name": "vec::Vec::<T, A>::reserve_exact",
  "safe": true,
  "callees": {
    "raw_vec::RawVec::<T, A>::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Ensures that the buffer contains at least enough space to hold `len +\n additional` elements. If it doesn't already, will reallocate the\n minimum possible amount of memory necessary. Generally this will be\n exactly the amount of memory necessary, but in principle the allocator\n is free to give back more than we asked for.\n\n If `len` exceeds `self.capacity()`, this may fail to actually allocate\n the requested space. This is not really unsafe, but the unsafe code\n *you* write that relies on the behavior of this function may break.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Aborts\n\n Aborts on OOM.\n",
      "adt": {
        "raw_vec::RawVec": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "raw_vec::RawVec": [
      "MutRef"
    ],
    "vec::Vec": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::vec::Vec::<T, A>::reserve_exact"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1329:5: 1331:6",
  "src": "pub fn reserve_exact(&mut self, additional: usize) {\n        self.buf.reserve_exact(self.len, additional);\n    }",
  "mir": "fn vec::Vec::<T, A>::reserve_exact(_1: &mut vec::Vec<T, A>, _2: usize) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: &mut raw_vec::RawVec<T, A>;\n    let mut _5: usize;\n    debug self => _1;\n    debug additional => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: raw_vec::RawVec<T, A>);\n        StorageLive(_5);\n        _5 = ((*_1).1: usize);\n        _3 = raw_vec::RawVec::<T, A>::reserve_exact(move _4, move _5, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Reserves the minimum capacity for at least `additional` more elements to\n be inserted in the given `Vec<T>`. Unlike [`reserve`], this will not\n deliberately over-allocate to speculatively avoid frequent allocations.\n After calling `reserve_exact`, capacity will be greater than or equal to\n `self.len() + additional`. Does nothing if the capacity is already\n sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`reserve`] if future insertions are expected.\n\n [`reserve`]: Vec::reserve\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.reserve_exact(10);\n assert!(vec.capacity() >= 11);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}