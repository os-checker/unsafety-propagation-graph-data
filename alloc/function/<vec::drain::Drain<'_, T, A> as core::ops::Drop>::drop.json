{
  "name": "<vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "core::mem::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Replaces `dest` with the default value of `T`, returning the previous `dest` value.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a passed value instead of the default value, see [`replace`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::take(&mut v);\n assert_eq!(vec![1, 2], old_v);\n assert!(v.is_empty());\n ```\n\n `take` allows taking ownership of a struct field by replacing it with an \"empty\" value.\n Without `take` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn get_and_reset(&mut self) -> Vec<T> {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let buf = self.buf;\n         self.buf = Vec::new();\n         buf\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n `self.buf`. But `take` can be used to disassociate the original value of `self.buf` from\n `self`, allowing it to be returned:\n\n ```\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn get_and_reset(&mut self) -> Vec<T> {\n         mem::take(&mut self.buf)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf.len(), 2);\n\n assert_eq!(buffer.get_and_reset(), vec![0, 1]);\n assert_eq!(buffer.buf.len(), 0);\n ```\n",
      "adt": {}
    },
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n must be used instead.\n\n For the shared counterpart see [`as_ref`].\n\n [`as_uninit_mut`]: NonNull::as_uninit_mut\n [`as_ref`]: NonNull::as_ref\n\n # Safety\n\n When calling this method, you have to ensure that\n the pointer is [convertible to a reference](crate::ptr#pointer-to-reference-conversion).\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let mut ptr = NonNull::new(&mut x).expect(\"null pointer\");\n\n let x_ref = unsafe { ptr.as_mut() };\n assert_eq!(*x_ref, 0);\n *x_ref += 2;\n assert_eq!(*x_ref, 2);\n ```\n\n [the module documentation]: crate::ptr#safety\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::truncate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shortens the vector, keeping the first `len` elements and dropping\n the rest.\n\n If `len` is greater or equal to the vector's current length, this has\n no effect.\n\n The [`drain`] method can emulate `truncate`, but causes the excess\n elements to be returned instead of dropped.\n\n Note that this method has no effect on the allocated capacity\n of the vector.\n\n # Examples\n\n Truncating a five element vector to two elements:\n\n ```\n let mut vec = vec![1, 2, 3, 4, 5];\n vec.truncate(2);\n assert_eq!(vec, [1, 2]);\n ```\n\n No truncation occurs when `len` is greater than the vector's current\n length:\n\n ```\n let mut vec = vec![1, 2, 3];\n vec.truncate(8);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n Truncating when `len == 0` is equivalent to calling the [`clear`]\n method.\n\n ```\n let mut vec = vec![1, 2, 3];\n vec.truncate(0);\n assert_eq!(vec, []);\n ```\n\n [`clear`]: Vec::clear\n [`drain`]: Vec::drain\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::slice::Iter::<'a, T>::as_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Views the underlying data as a subslice of the original data.\n\n # Examples\n\n Basic usage:\n\n ```\n // First, we need a slice to call the `iter` method on:\n let slice = &[1, 2, 3];\n\n // Then we call `iter` on the slice to get the `Iter` iterator:\n let mut iter = slice.iter();\n // Here `as_slice` still returns the whole slice, so this prints \"[1, 2, 3]\":\n println!(\"{:?}\", iter.as_slice());\n\n // Now, we call the `next` method to remove the first element from the iterator:\n iter.next();\n // Here the iterator does not contain the first element of the slice any more,\n // so `as_slice` only returns the last two elements of the slice,\n // and so this prints \"[2, 3]\":\n println!(\"{:?}\", iter.as_slice());\n\n // The underlying slice has not been modified and still contains three elements,\n // so this prints \"[1, 2, 3]\":\n println!(\"{:?}\", slice);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::ptr::const_ptr::<impl *const T>::offset_from_unsigned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the distance between two pointers within the same allocation, *where it's known that\n `self` is equal to or greater than `origin`*. The returned value is in\n units of T: the distance in bytes is divided by `size_of::<T>()`.\n\n This computes the same value that [`offset_from`](#method.offset_from)\n would compute, but with the added precondition that the offset is\n guaranteed to be non-negative.  This method is equivalent to\n `usize::try_from(self.offset_from(origin)).unwrap_unchecked()`,\n but it provides slightly more information to the optimizer, which can\n sometimes allow it to optimize slightly better with some backends.\n\n This method can be thought of as recovering the `count` that was passed\n to [`add`](#method.add) (or, with the parameters in the other order,\n to [`sub`](#method.sub)).  The following are all equivalent, assuming\n that their safety preconditions are met:\n ```rust\n # unsafe fn blah(ptr: *const i32, origin: *const i32, count: usize) -> bool { unsafe {\n ptr.offset_from_unsigned(origin) == count\n # &&\n origin.add(count) == ptr\n # &&\n ptr.sub(count) == origin\n # } }\n ```\n\n # Safety\n\n - The distance between the pointers must be non-negative (`self >= origin`)\n\n - *All* the safety conditions of [`offset_from`](#method.offset_from)\n   apply to this method as well; see it for the full details.\n\n Importantly, despite the return type of this method being able to represent\n a larger offset, it's still *not permitted* to pass pointers which differ\n by more than `isize::MAX` *bytes*.  As such, the result of this method will\n always be less than or equal to `isize::MAX as usize`.\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n ```\n let a = [0; 5];\n let ptr1: *const i32 = &a[1];\n let ptr2: *const i32 = &a[3];\n unsafe {\n     assert_eq!(ptr2.offset_from_unsigned(ptr1), 2);\n     assert_eq!(ptr1.add(2), ptr2);\n     assert_eq!(ptr2.sub(2), ptr1);\n     assert_eq!(ptr2.offset_from_unsigned(ptr2), 0);\n }\n\n // This would be incorrect, as the pointers are not correctly ordered:\n // ptr1.offset_from_unsigned(ptr2)\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::slice_from_raw_parts_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a raw mutable slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n Performs the same functionality as [`slice_from_raw_parts`], except that a\n raw mutable slice is returned, as opposed to a raw immutable slice.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.\n\n [`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut\n\n # Examples\n\n ```rust\n use std::ptr;\n\n let x = &mut [5, 6, 7];\n let raw_pointer = x.as_mut_ptr();\n let slice = ptr::slice_from_raw_parts_mut(raw_pointer, 3);\n\n unsafe {\n     (*slice)[2] = 99; // assign a value at an index in the slice\n };\n\n assert_eq!(unsafe { &*slice }[2], 99);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *mut [u8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 0);\n unsafe {\n     danger.as_mut().expect(\"references must not be null\");\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::slice::Iter": [
      "MutRef",
      "Plain",
      "Ref"
    ],
    "vec::drain::Drain": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::ptr::NonNull": [
      "Plain",
      "MutRef"
    ],
    "vec::Vec": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "<vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/drain.rs:175:5: 239:6",
  "src": "fn drop(&mut self) {\n        /// Moves back the un-`Drain`ed elements to restore the original `Vec`.\n        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n\n        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n            fn drop(&mut self) {\n                if self.0.tail_len > 0 {\n                    unsafe {\n                        let source_vec = self.0.vec.as_mut();\n                        // memmove back untouched tail, update to new length\n                        let start = source_vec.len();\n                        let tail = self.0.tail_start;\n                        if tail != start {\n                            let src = source_vec.as_ptr().add(tail);\n                            let dst = source_vec.as_mut_ptr().add(start);\n                            ptr::copy(src, dst, self.0.tail_len);\n                        }\n                        source_vec.set_len(start + self.0.tail_len);\n                    }\n                }\n            }\n        }\n\n        let iter = mem::take(&mut self.iter);\n        let drop_len = iter.len();\n\n        let mut vec = self.vec;\n\n        if T::IS_ZST {\n            // ZSTs have no identity, so we don't need to move them around, we only need to drop the correct amount.\n            // this can be achieved by manipulating the Vec length instead of moving values out from `iter`.\n            unsafe {\n                let vec = vec.as_mut();\n                let old_len = vec.len();\n                vec.set_len(old_len + drop_len + self.tail_len);\n                vec.truncate(old_len + self.tail_len);\n            }\n\n            return;\n        }\n\n        // ensure elements are moved back into their appropriate places, even when drop_in_place panics\n        let _guard = DropGuard(self);\n\n        if drop_len == 0 {\n            return;\n        }\n\n        // as_slice() must only be called when iter.len() is > 0 because\n        // it also gets touched by vec::Splice which may turn it into a dangling pointer\n        // which would make it and the vec pointer point to different allocations which would\n        // lead to invalid pointer arithmetic below.\n        let drop_ptr = iter.as_slice().as_ptr();\n\n        unsafe {\n            // drop_ptr comes from a slice::Iter which only gives us a &[T] but for drop_in_place\n            // a pointer with mutable provenance is necessary. Therefore we must reconstruct\n            // it from the original vec but also avoid creating a &mut to the front since that could\n            // invalidate raw pointers to it which some unsafe code might rely on.\n            let vec_ptr = vec.as_mut().as_mut_ptr();\n            let drop_offset = drop_ptr.offset_from_unsigned(vec_ptr);\n            let to_drop = ptr::slice_from_raw_parts_mut(vec_ptr.add(drop_offset), drop_len);\n            ptr::drop_in_place(to_drop);\n        }\n    }",
  "mir": "fn <vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop(_1: &mut vec::drain::Drain<'_, T, A>) -> () {\n    let mut _0: ();\n    let  _2: core::slice::Iter<'_, T>;\n    let mut _3: &mut core::slice::Iter<'_, T>;\n    let  _4: usize;\n    let mut _5: &core::slice::Iter<'_, T>;\n    let mut _6: core::ptr::NonNull<vec::Vec<T, A>>;\n    let  _7: &mut vec::Vec<T, A>;\n    let mut _8: &mut core::ptr::NonNull<vec::Vec<T, A>>;\n    let  _9: usize;\n    let mut _10: &vec::Vec<T, A>;\n    let  _11: ();\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let  _17: ();\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: (usize, bool);\n    let  _21: <vec::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'_, '_, T, A>;\n    let  _22: *const T;\n    let  _23: &[T];\n    let mut _24: &core::slice::Iter<'_, T>;\n    let  _25: *mut T;\n    let mut _26: &mut vec::Vec<T, A>;\n    let mut _27: &mut core::ptr::NonNull<vec::Vec<T, A>>;\n    let  _28: usize;\n    let mut _29: *const T;\n    let  _30: *mut [T];\n    let mut _31: *mut T;\n    let  _32: ();\n    debug self => _1;\n    debug iter => _2;\n    debug drop_len => _4;\n    debug vec => _6;\n    debug vec => _7;\n    debug old_len => _9;\n    debug _guard => _21;\n    debug drop_ptr => _22;\n    debug vec_ptr => _25;\n    debug drop_offset => _28;\n    debug to_drop => _30;\n    bb0: {\n        StorageLive(_2);\n        _3 = &mut ((*_1).2: core::slice::Iter<'_, T>);\n        _2 = core::mem::take::<core::slice::Iter<'_, T>>(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = &_2;\n        _4 = <core::slice::Iter<'_, T> as core::iter::ExactSizeIterator>::len(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = ((*_1).3: core::ptr::NonNull<vec::Vec<T, A>>);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb11, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_8);\n        _8 = &mut _6;\n        _7 = core::ptr::NonNull::<vec::Vec<T, A>>::as_mut::<'_>(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = &(*_7);\n        _9 = vec::Vec::<T, A>::len(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        _14 = CheckedAdd(_9, _4);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, _4) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = move (_14.0: usize);\n        StorageLive(_15);\n        _15 = ((*_1).1: usize);\n        _16 = CheckedAdd(_13, _15);\n        assert(!move (_16.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _13, move _15) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = move (_16.0: usize);\n        StorageDead(_15);\n        StorageDead(_13);\n        _11 = vec::Vec::<T, A>::set_len(_7, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = ((*_1).1: usize);\n        _20 = CheckedAdd(_9, _19);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, move _19) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _18 = move (_20.0: usize);\n        StorageDead(_19);\n        _17 = vec::Vec::<T, A>::truncate(_7, move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        goto -> bb24;\n    }\n    bb11: {\n        StorageLive(_21);\n        _21 = DropGuard(_1);\n        switchInt(_4) -> [0: bb12, otherwise: bb13];\n    }\n    bb12: {\n        drop(_21) -> [return: bb23, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_24);\n        _24 = &_2;\n        _23 = core::slice::Iter::<'_, T>::as_slice(move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        _22 = core::slice::<impl [T]>::as_ptr(_23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_27);\n        _27 = &mut _6;\n        _26 = core::ptr::NonNull::<vec::Vec<T, A>>::as_mut::<'_>(move _27) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_27);\n        _25 = vec::Vec::<T, A>::as_mut_ptr(_26) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_29);\n        _29 = _25 as *const T;\n        _28 = core::ptr::const_ptr::<impl *const T>::offset_from_unsigned(_22, move _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        StorageLive(_31);\n        _31 = core::ptr::mut_ptr::<impl *mut T>::add(_25, _28) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _30 = core::ptr::slice_from_raw_parts_mut::<T>(move _31, _4) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_31);\n        _32 = core::ptr::drop_in_place::<[T]>(_30) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        drop(_21) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_21);\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb25;\n    }\n    bb23: {\n        StorageDead(_21);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb25;\n    }\n    bb25: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}