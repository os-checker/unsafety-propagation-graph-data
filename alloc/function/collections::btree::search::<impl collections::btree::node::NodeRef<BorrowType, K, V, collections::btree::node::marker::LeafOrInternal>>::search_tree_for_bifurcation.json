{
  "name": "collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree_for_bifurcation",
  "safe": true,
  "callees": {
    "collections::btree::set_val::IsSetVal::is_set_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::RangeBounds::start_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Start index bound.\n\n Returns the start value as a `Bound`.\n\n # Examples\n\n ```\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n\n assert_eq!((..10).start_bound(), Unbounded);\n assert_eq!((3..10).start_bound(), Included(&3));\n ```\n",
      "adt": {}
    },
    "core::ops::RangeBounds::end_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " End index bound.\n\n Returns the end value as a `Bound`.\n\n # Examples\n\n ```\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n\n assert_eq!((3..).end_bound(), Unbounded);\n assert_eq!((3..10).end_bound(), Excluded(&10));\n ```\n",
      "adt": {}
    },
    "collections::btree::search::SearchBound::<T>::from_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::search::SearchBound": "Constructor"
      }
    },
    "core::cmp::PartialOrd::gt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests greater than (for `self` and `other`) and is used by the `>`\n operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 > 1.0, false);\n assert_eq!(1.0 > 2.0, false);\n assert_eq!(2.0 > 1.0, true);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, Type>>::find_lower_bound_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds an edge index in the node delimiting the lower bound of a range.\n Also returns the lower bound to be used for continuing the search in\n the matching child node, if `self` is an internal node.\n\n The result is meaningful only if the tree is ordered by key.\n",
      "adt": {
        "collections::btree::search::SearchBound": "Constructor",
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, Type>>::find_upper_bound_index": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mirror image of `find_lower_bound_index` for the upper bound,\n with an additional parameter to skip part of the key array.\n\n # Safety\n `start_index` must be a valid edge index for the node.\n",
      "adt": {
        "collections::btree::search::SearchBound": "Constructor",
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::new_edge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to an edge in `node`.\n Unsafe because the caller must ensure that `idx <= node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, Type>::force": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the underlying node is an `Internal` node or a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::ForceResult": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::descend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the node pointed to by this edge.\n\n The method name assumes you picture trees with the root node on top.\n\n `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n both, upon success, do nothing.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    }
  },
  "adts": {
    "core::ops::Bound": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3782, kind: RigidTy(Adt(AdtDef(DefId { id: 3763, name: \"core::ops::Bound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) })])",
      "Unknown([Field(1, Ty { id: 3782, kind: RigidTy(Adt(AdtDef(DefId { id: 3763, name: \"core::ops::Bound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) })])",
      "Unknown([Field(0, Ty { id: 3782, kind: RigidTy(Adt(AdtDef(DefId { id: 3763, name: \"core::ops::Bound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 3782, kind: RigidTy(Adt(AdtDef(DefId { id: 3763, name: \"core::ops::Bound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 3782, kind: RigidTy(Adt(AdtDef(DefId { id: 3763, name: \"core::ops::Bound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })])",
      "Unknown([Field(0, Ty { id: 3782, kind: RigidTy(Adt(AdtDef(DefId { id: 3763, name: \"core::ops::Bound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })])"
    ],
    "collections::btree::search::SearchBound": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 3784, kind: RigidTy(Adt(AdtDef(DefId { id: 3762, name: \"collections::btree::search::SearchBound\" }), GenericArgs([Type(Ty { id: 3086, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2927, kind: Param(ParamTy { index: 3, name: \"Q\" }) }, Not)) })]))) })])"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "collections::btree::node::NodeRef": [
      "Ref",
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "collections::btree::node::ForceResult": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2884, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2455, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2434, kind: Param(ParamTy { index: 0, name: \"BorrowType\" }) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2438, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2450, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2434, kind: Param(ParamTy { index: 0, name: \"BorrowType\" }) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree_for_bifurcation"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/search.rs:83:5: 152:6",
  "src": "pub(super) fn search_tree_for_bifurcation<'r, Q: ?Sized, R>(\n        mut self,\n        range: &'r R,\n    ) -> Result<\n        (\n            NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n            usize,\n            usize,\n            SearchBound<&'r Q>,\n            SearchBound<&'r Q>,\n        ),\n        Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n    >\n    where\n        Q: Ord,\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n    {\n        // Determine if map or set is being searched\n        let is_set = <V as super::set_val::IsSetVal>::is_set_val();\n\n        // Inlining these variables should be avoided. We assume the bounds reported by `range`\n        // remain the same, but an adversarial implementation could change between calls (#81138).\n        let (start, end) = (range.start_bound(), range.end_bound());\n        match (start, end) {\n            (Bound::Excluded(s), Bound::Excluded(e)) if s == e => {\n                if is_set {\n                    panic!(\"range start and end are equal and excluded in BTreeSet\")\n                } else {\n                    panic!(\"range start and end are equal and excluded in BTreeMap\")\n                }\n            }\n            (Bound::Included(s) | Bound::Excluded(s), Bound::Included(e) | Bound::Excluded(e))\n                if s > e =>\n            {\n                if is_set {\n                    panic!(\"range start is greater than range end in BTreeSet\")\n                } else {\n                    panic!(\"range start is greater than range end in BTreeMap\")\n                }\n            }\n            _ => {}\n        }\n        let mut lower_bound = SearchBound::from_range(start);\n        let mut upper_bound = SearchBound::from_range(end);\n        loop {\n            let (lower_edge_idx, lower_child_bound) = self.find_lower_bound_index(lower_bound);\n            let (upper_edge_idx, upper_child_bound) =\n                unsafe { self.find_upper_bound_index(upper_bound, lower_edge_idx) };\n            if lower_edge_idx < upper_edge_idx {\n                return Ok((\n                    self,\n                    lower_edge_idx,\n                    upper_edge_idx,\n                    lower_child_bound,\n                    upper_child_bound,\n                ));\n            }\n            debug_assert_eq!(lower_edge_idx, upper_edge_idx);\n            let common_edge = unsafe { Handle::new_edge(self, lower_edge_idx) };\n            match common_edge.force() {\n                Leaf(common_edge) => return Err(common_edge),\n                Internal(common_edge) => {\n                    self = common_edge.descend();\n                    lower_bound = lower_child_bound;\n                    upper_bound = upper_child_bound;\n                }\n            }\n        }\n    }",
  "mir": "fn collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree_for_bifurcation(_1: collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, _2: &R) -> core::result::Result<(collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, usize, usize, collections::btree::search::SearchBound<&Q>, collections::btree::search::SearchBound<&Q>), collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>> {\n    let mut _0: core::result::Result<(collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, usize, usize, collections::btree::search::SearchBound<&Q>, collections::btree::search::SearchBound<&Q>), collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let  _3: bool;\n    let  _4: core::ops::Bound<&Q>;\n    let  _5: core::ops::Bound<&Q>;\n    let mut _6: (core::ops::Bound<&Q>, core::ops::Bound<&Q>);\n    let mut _7: core::ops::Bound<&Q>;\n    let mut _8: core::ops::Bound<&Q>;\n    let mut _9: (core::ops::Bound<&Q>, core::ops::Bound<&Q>);\n    let mut _10: isize;\n    let mut _11: isize;\n    let mut _12: isize;\n    let mut _13: isize;\n    let  _14: &Q;\n    let  _15: &&Q;\n    let  _16: &Q;\n    let  _17: &&Q;\n    let mut _18: bool;\n    let  _19: !;\n    let mut _20: core::fmt::Arguments<'_>;\n    let  _21: !;\n    let mut _22: core::fmt::Arguments<'_>;\n    let  _23: &Q;\n    let  _24: &&Q;\n    let  _25: &Q;\n    let  _26: &&Q;\n    let mut _27: bool;\n    let mut _28: &&Q;\n    let mut _29: &&Q;\n    let  _30: &Q;\n    let mut _31: bool;\n    let mut _32: &&Q;\n    let mut _33: &&Q;\n    let  _34: &Q;\n    let mut _35: bool;\n    let mut _36: &&Q;\n    let mut _37: &&Q;\n    let  _38: &Q;\n    let mut _39: bool;\n    let mut _40: &&Q;\n    let mut _41: &&Q;\n    let  _42: &Q;\n    let  _43: !;\n    let mut _44: core::fmt::Arguments<'_>;\n    let  _45: !;\n    let mut _46: core::fmt::Arguments<'_>;\n    let mut _47: collections::btree::search::SearchBound<&Q>;\n    let mut _48: collections::btree::search::SearchBound<&Q>;\n    let  _49: usize;\n    let  _50: collections::btree::search::SearchBound<&Q>;\n    let mut _51: (usize, collections::btree::search::SearchBound<&Q>);\n    let mut _52: &collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _53: collections::btree::search::SearchBound<&Q>;\n    let  _54: usize;\n    let  _55: collections::btree::search::SearchBound<&Q>;\n    let mut _56: (usize, collections::btree::search::SearchBound<&Q>);\n    let mut _57: &collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _58: collections::btree::search::SearchBound<&Q>;\n    let mut _59: bool;\n    let mut _60: (collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, usize, usize, collections::btree::search::SearchBound<&Q>, collections::btree::search::SearchBound<&Q>);\n    let mut _61: collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _62: (&usize, &usize);\n    let mut _63: &usize;\n    let mut _64: &usize;\n    let  _65: &usize;\n    let  _66: &usize;\n    let mut _67: bool;\n    let mut _68: usize;\n    let mut _69: usize;\n    let  _70: core::panicking::AssertKind;\n    let  _71: !;\n    let mut _72: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _73: collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>;\n    let mut _74: collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _75: collections::btree::node::ForceResult<collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>, collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>>;\n    let mut _76: isize;\n    let  _77: collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let  _78: collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let mut _79: collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _80: &Q;\n    let mut _81: &Q;\n    let mut _82: &Q;\n    let mut _83: &Q;\n    debug self => _1;\n    debug range => _2;\n    debug is_set => _3;\n    debug start => _4;\n    debug end => _5;\n    debug s => _14;\n    debug s => _15;\n    debug e => _16;\n    debug e => _17;\n    debug s => _23;\n    debug s => _24;\n    debug e => _25;\n    debug e => _26;\n    debug lower_bound => _47;\n    debug upper_bound => _48;\n    debug lower_edge_idx => _49;\n    debug lower_child_bound => _50;\n    debug upper_edge_idx => _54;\n    debug upper_child_bound => _55;\n    debug left_val => _65;\n    debug right_val => _66;\n    debug kind => _70;\n    debug common_edge => _73;\n    debug common_edge => _77;\n    debug common_edge => _78;\n    bb0: {\n        _3 = <V as collections::btree::set_val::IsSetVal>::is_set_val() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = <R as core::ops::RangeBounds<Q>>::start_bound(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_8);\n        _8 = <R as core::ops::RangeBounds<Q>>::end_bound(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = (move _7, move _8);\n        StorageDead(_8);\n        StorageDead(_7);\n        _4 = (_6.0: core::ops::Bound<&Q>);\n        _5 = (_6.1: core::ops::Bound<&Q>);\n        StorageDead(_6);\n        StorageLive(_9);\n        _9 = (_4, _5);\n        _11 = discriminant((_9.0: core::ops::Bound<&Q>));\n        switchInt(move _11) -> [0: bb7, 1: bb5, 2: bb4, otherwise: bb48];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_47);\n        _47 = collections::btree::search::SearchBound::<&Q>::from_range(_4) -> [return: bb37, unwind unreachable];\n    }\n    bb5: {\n        _10 = discriminant((_9.1: core::ops::Bound<&Q>));\n        switchInt(move _10) -> [1: bb12, otherwise: bb6];\n    }\n    bb6: {\n        _13 = discriminant((_9.1: core::ops::Bound<&Q>));\n        switchInt(move _13) -> [0: bb9, 1: bb8, 2: bb4, otherwise: bb48];\n    }\n    bb7: {\n        _12 = discriminant((_9.1: core::ops::Bound<&Q>));\n        switchInt(move _12) -> [0: bb11, 1: bb10, 2: bb4, otherwise: bb48];\n    }\n    bb8: {\n        StorageLive(_24);\n        _24 = &(((_9.0: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_26);\n        _26 = &(((_9.1: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _24;\n        StorageLive(_29);\n        StorageLive(_30);\n        _80 = (*_26);\n        _30 = _80;\n        _29 = &_30;\n        _27 = <&Q as core::cmp::PartialOrd>::gt(move _28, move _29) -> [return: bb21, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_24);\n        _24 = &(((_9.0: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_26);\n        _26 = &(((_9.1: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _24;\n        StorageLive(_33);\n        StorageLive(_34);\n        _81 = (*_26);\n        _34 = _81;\n        _33 = &_34;\n        _31 = <&Q as core::cmp::PartialOrd>::gt(move _32, move _33) -> [return: bb24, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_24);\n        _24 = &(((_9.0: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        StorageLive(_26);\n        _26 = &(((_9.1: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = _24;\n        StorageLive(_37);\n        StorageLive(_38);\n        _82 = (*_26);\n        _38 = _82;\n        _37 = &_38;\n        _35 = <&Q as core::cmp::PartialOrd>::gt(move _36, move _37) -> [return: bb27, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_24);\n        _24 = &(((_9.0: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        StorageLive(_26);\n        _26 = &(((_9.1: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = _24;\n        StorageLive(_41);\n        StorageLive(_42);\n        _83 = (*_26);\n        _42 = _83;\n        _41 = &_42;\n        _39 = <&Q as core::cmp::PartialOrd>::gt(move _40, move _41) -> [return: bb30, unwind unreachable];\n    }\n    bb12: {\n        _15 = &(((_9.0: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        _17 = &(((_9.1: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_18);\n        _18 = <&Q as core::cmp::PartialEq>::eq(_15, _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _18) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageLive(_14);\n        _14 = (((_9.0: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_16);\n        _16 = (((_9.1: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        switchInt(_3) -> [0: bb18, otherwise: bb16];\n    }\n    bb15: {\n        StorageDead(_18);\n        goto -> bb6;\n    }\n    bb16: {\n        StorageLive(_20);\n        _20 = core::fmt::Arguments::<'_>::from_str(\"range start and end are equal and excluded in BTreeSet\") -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _19 = core::panicking::panic_fmt(move _20) -> unwind unreachable;\n    }\n    bb18: {\n        StorageLive(_22);\n        _22 = core::fmt::Arguments::<'_>::from_str(\"range start and end are equal and excluded in BTreeMap\") -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _21 = core::panicking::panic_fmt(move _22) -> unwind unreachable;\n    }\n    bb20: {\n        switchInt(_3) -> [0: bb35, otherwise: bb33];\n    }\n    bb21: {\n        switchInt(move _27) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageLive(_23);\n        _23 = (((_9.0: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_25);\n        _25 = (((_9.1: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        goto -> bb20;\n    }\n    bb23: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_24);\n        goto -> bb4;\n    }\n    bb24: {\n        switchInt(move _31) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_23);\n        _23 = (((_9.0: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        StorageLive(_25);\n        _25 = (((_9.1: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        goto -> bb20;\n    }\n    bb26: {\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_26);\n        StorageDead(_24);\n        goto -> bb4;\n    }\n    bb27: {\n        switchInt(move _35) -> [0: bb29, otherwise: bb28];\n    }\n    bb28: {\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_23);\n        _23 = (((_9.0: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        StorageLive(_25);\n        _25 = (((_9.1: core::ops::Bound<&Q>) as variant#1).0: &Q);\n        goto -> bb20;\n    }\n    bb29: {\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_26);\n        StorageDead(_24);\n        goto -> bb4;\n    }\n    bb30: {\n        switchInt(move _39) -> [0: bb32, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_23);\n        _23 = (((_9.0: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        StorageLive(_25);\n        _25 = (((_9.1: core::ops::Bound<&Q>) as variant#0).0: &Q);\n        goto -> bb20;\n    }\n    bb32: {\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_26);\n        StorageDead(_24);\n        goto -> bb4;\n    }\n    bb33: {\n        StorageLive(_44);\n        _44 = core::fmt::Arguments::<'_>::from_str(\"range start is greater than range end in BTreeSet\") -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _43 = core::panicking::panic_fmt(move _44) -> unwind unreachable;\n    }\n    bb35: {\n        StorageLive(_46);\n        _46 = core::fmt::Arguments::<'_>::from_str(\"range start is greater than range end in BTreeMap\") -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _45 = core::panicking::panic_fmt(move _46) -> unwind unreachable;\n    }\n    bb37: {\n        StorageLive(_48);\n        _48 = collections::btree::search::SearchBound::<&Q>::from_range(_5) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        goto -> bb39;\n    }\n    bb39: {\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &_1;\n        StorageLive(_53);\n        _53 = move _47;\n        _51 = collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::find_lower_bound_index::<Q>(move _52, move _53) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_53);\n        StorageDead(_52);\n        _49 = (_51.0: usize);\n        _50 = move (_51.1: collections::btree::search::SearchBound<&Q>);\n        StorageDead(_51);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_1;\n        StorageLive(_58);\n        _58 = move _48;\n        _56 = collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::find_upper_bound_index::<Q>(move _57, move _58, _49) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_58);\n        StorageDead(_57);\n        _54 = (_56.0: usize);\n        _55 = move (_56.1: collections::btree::search::SearchBound<&Q>);\n        StorageDead(_56);\n        StorageLive(_59);\n        _59 = Lt(_49, _54);\n        switchInt(move _59) -> [0: bb43, otherwise: bb42];\n    }\n    bb42: {\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = move _1;\n        _60 = (move _61, _49, _54, _50, _55);\n        StorageDead(_61);\n        _0 = core::result::Result::Ok(move _60);\n        StorageDead(_60);\n        StorageDead(_59);\n        goto -> bb52;\n    }\n    bb43: {\n        StorageDead(_59);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = &_49;\n        StorageLive(_64);\n        _64 = &_54;\n        _62 = (move _63, move _64);\n        StorageDead(_64);\n        StorageDead(_63);\n        _65 = (_62.0: &usize);\n        _66 = (_62.1: &usize);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = (*_65);\n        StorageLive(_69);\n        _69 = (*_66);\n        _67 = Eq(move _68, move _69);\n        switchInt(move _67) -> [0: bb45, otherwise: bb44];\n    }\n    bb44: {\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_67);\n        StorageDead(_62);\n        StorageLive(_74);\n        _74 = move _1;\n        _73 = collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>::new_edge(move _74, _49) -> [return: bb46, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_69);\n        StorageDead(_68);\n        _70 = core::panicking::AssertKind::Eq;\n        StorageLive(_72);\n        _72 = core::option::Option::None;\n        _71 = core::panicking::assert_failed::<usize, usize>(_70, _65, _66, move _72) -> unwind unreachable;\n    }\n    bb46: {\n        StorageDead(_74);\n        StorageLive(_75);\n        _75 = collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>::force(_73) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _76 = discriminant(_75);\n        switchInt(move _76) -> [0: bb50, 1: bb49, otherwise: bb48];\n    }\n    bb48: {\n        unreachable;\n    }\n    bb49: {\n        _78 = move ((_75 as variant#1).0: collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>);\n        StorageLive(_79);\n        _79 = collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::descend(_78) -> [return: bb51, unwind unreachable];\n    }\n    bb50: {\n        _77 = move ((_75 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        _0 = core::result::Result::Err(_77);\n        StorageDead(_75);\n        goto -> bb52;\n    }\n    bb51: {\n        _1 = move _79;\n        StorageDead(_79);\n        _47 = _50;\n        _48 = _55;\n        StorageDead(_75);\n        goto -> bb39;\n    }\n    bb52: {\n        StorageDead(_48);\n        StorageDead(_47);\n        return;\n    }\n}\n",
  "doc": " Descends to the nearest node where the edge matching the lower bound\n of the range is different from the edge matching the upper bound, i.e.,\n the nearest node that has at least one key contained in the range.\n\n If found, returns an `Ok` with that node, the strictly ascending pair of\n edge indices in the node delimiting the range, and the corresponding\n pair of bounds for continuing the search in the child nodes, in case\n the node is internal.\n\n If not found, returns an `Err` with the leaf edge matching the entire\n range.\n\n As a diagnostic service, panics if the range specifies impossible bounds.\n\n The result is meaningful only if the tree is ordered by key.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}