{
  "name": "string::String::from_utf16be",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::as_chunks": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the slice into a slice of `N`-element arrays,\n starting at the beginning of the slice,\n and a remainder slice with length strictly less than `N`.\n\n The remainder is meaningful in the division sense.  Given\n `let (chunks, remainder) = slice.as_chunks()`, then:\n - `chunks.len()` equals `slice.len() / N`,\n - `remainder.len()` equals `slice.len() % N`, and\n - `slice.len()` equals `chunks.len() * N + remainder.len()`.\n\n You can flatten the chunks back into a slice-of-`T` with [`as_flattened`].\n\n [`as_flattened`]: slice::as_flattened\n\n # Panics\n\n Panics if `N` is zero.\n\n Note that this check is against a const generic parameter, not a runtime\n value, and thus a particular monomorphization will either always panic\n or it will never panic.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let (chunks, remainder) = slice.as_chunks();\n assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);\n assert_eq!(remainder, &['m']);\n ```\n\n If you expect the slice to be an exact multiple, you can combine\n `let`-`else` with an empty slice pattern:\n ```\n let slice = ['R', 'u', 's', 't'];\n let (chunks, []) = slice.as_chunks::<2>() else {\n     panic!(\"slice didn't have even length\")\n };\n assert_eq!(chunks, &[['R', 'u'], ['s', 't']]);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::align_to": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transmutes the slice to a slice of another type, ensuring alignment of the types is\n maintained.\n\n This method splits the slice into three distinct slices: prefix, correctly aligned middle\n slice of a new type, and the suffix slice. The middle part will be as big as possible under\n the given alignment constraint and element size.\n\n This method has no purpose when either input element `T` or output element `U` are\n zero-sized and will return the original slice without splitting anything.\n\n # Safety\n\n This method is essentially a `transmute` with respect to the elements in the returned\n middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n\n # Examples\n\n Basic usage:\n\n ```\n unsafe {\n     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n     // less_efficient_algorithm_for_bytes(prefix);\n     // more_efficient_algorithm_for_aligned_shorts(shorts);\n     // less_efficient_algorithm_for_bytes(suffix);\n }\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "string::String::from_utf16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Decode a native endian UTF-16‚Äìencoded vector `v` into a `String`,\n returning [`Err`] if `v` contains any invalid data.\n\n # Examples\n\n ```\n // ùÑûmusic\n let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n           0x0073, 0x0069, 0x0063];\n assert_eq!(String::from(\"ùÑûmusic\"),\n            String::from_utf16(v).unwrap());\n\n // ùÑûmu<invalid>ic\n let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n           0xD800, 0x0069, 0x0063];\n assert!(String::from_utf16(v).is_err());\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::iter::Iterator::copied": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which copies all of its elements.\n\n This is useful when you have an iterator over `&T`, but you need an\n iterator over `T`.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let v_copied: Vec<_> = a.iter().copied().collect();\n\n // copied is the same as .map(|&x| x)\n let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\n assert_eq!(v_copied, [1, 2, 3]);\n assert_eq!(v_map, [1, 2, 3]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::num::<impl u16>::from_be_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a native endian integer value from its representation\n as a byte array in big endian.\n\n\n # Examples\n\n ```\n ```\n\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n\n ```\n     *input = rest;\n }\n ```\n",
      "adt": {}
    },
    "core::char::methods::<impl char>::decode_utf16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the native endian UTF-16 encoded code points in `iter`,\n returning unpaired surrogates as `Err`s.\n\n # Examples\n\n Basic usage:\n\n ```\n // ùÑûmus<invalid>ic<invalid>\n let v = [\n     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n ];\n\n assert_eq!(\n     char::decode_utf16(v)\n         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n         .collect::<Vec<_>>(),\n     vec![\n         Ok('ùÑû'),\n         Ok('m'), Ok('u'), Ok('s'),\n         Err(0xDD1E),\n         Ok('i'), Ok('c'),\n         Err(0xD834)\n     ]\n );\n ```\n\n A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n\n ```\n // ùÑûmus<invalid>ic<invalid>\n let v = [\n     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n ];\n\n assert_eq!(\n     char::decode_utf16(v)\n        .map(|r| r.unwrap_or(char::REPLACEMENT_CHARACTER))\n        .collect::<String>(),\n     \"ùÑûmusÔøΩicÔøΩ\"\n );\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Copied": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain"
    ],
    "core::char::DecodeUtf16": [
      "Plain"
    ]
  },
  "path": 1962,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:861:5: 871:6",
  "src": "pub fn from_utf16be(v: &[u8]) -> Result<String, FromUtf16Error> {\n        let (chunks, []) = v.as_chunks::<2>() else {\n            return Err(FromUtf16Error(()));\n        };\n        match (cfg!(target_endian = \"big\"), unsafe { v.align_to::<u16>() }) {\n            (true, ([], v, [])) => Self::from_utf16(v),\n            _ => char::decode_utf16(chunks.iter().copied().map(u16::from_be_bytes))\n                .collect::<Result<_, _>>()\n                .map_err(|_| FromUtf16Error(())),\n        }\n    }",
  "mir": "fn string::String::from_utf16be(_1: &[u8]) -> core::result::Result<string::String, string::FromUtf16Error> {\n    let mut _0: core::result::Result<string::String, string::FromUtf16Error>;\n    let  _2: &[[u8; 2]];\n    let mut _3: (&[[u8; 2]], &[u8]);\n    let mut _4: *const [u8];\n    let mut _5: usize;\n    let mut _6: (bool, (&[u8], &[u16], &[u8]));\n    let mut _7: (&[u8], &[u16], &[u8]);\n    let mut _8: *const [u8];\n    let mut _9: usize;\n    let mut _10: *const [u8];\n    let mut _11: usize;\n    let  _12: &[u16];\n    let mut _13: core::result::Result<string::String, core::char::DecodeUtf16Error>;\n    let mut _14: core::char::DecodeUtf16<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_be_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_be_bytes}>>;\n    let mut _15: core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_be_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_be_bytes}>;\n    let mut _16: core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>;\n    let mut _17: core::slice::Iter<'_, [u8; 2]>;\n    let mut _18: &[u8];\n    let mut _19: &[u8];\n    let mut _20: &[u8];\n    debug v => _1;\n    debug chunks => _2;\n    debug v => _12;\n    bb0: {\n        StorageLive(_3);\n        _3 = core::slice::<impl [u8]>::as_chunks::<2>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _18 = (_3.1: &[u8]);\n        _4 = &raw const (fake) (*_18);\n        _5 = PtrMetadata(move _4);\n        switchInt(_5) -> [0: bb2, otherwise: bb3];\n    }\n    bb2: {\n        _2 = (_3.0: &[[u8; 2]]);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::slice::<impl [u8]>::align_to::<u16>(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        _0 = core::result::Result::Err(string::FromUtf16Error(()));\n        goto -> bb17;\n    }\n    bb4: {\n        _6 = (false, move _7);\n        StorageDead(_7);\n        switchInt((_6.0: bool)) -> [0: bb5, otherwise: bb6];\n    }\n    bb5: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = core::slice::<impl [[u8; 2]]>::iter(_2) -> [return: bb10, unwind unreachable];\n    }\n    bb6: {\n        _19 = ((_6.1: (&[u8], &[u16], &[u8])).0: &[u8]);\n        _10 = &raw const (fake) (*_19);\n        _11 = PtrMetadata(move _10);\n        switchInt(_11) -> [0: bb7, otherwise: bb5];\n    }\n    bb7: {\n        _20 = ((_6.1: (&[u8], &[u16], &[u8])).2: &[u8]);\n        _8 = &raw const (fake) (*_20);\n        _9 = PtrMetadata(move _8);\n        switchInt(_9) -> [0: bb8, otherwise: bb5];\n    }\n    bb8: {\n        _12 = ((_6.1: (&[u8], &[u16], &[u8])).1: &[u16]);\n        _0 = string::String::from_utf16(_12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        goto -> bb16;\n    }\n    bb10: {\n        _16 = <core::slice::Iter<'_, [u8; 2]> as core::iter::Iterator>::copied::<'_, [u8; 2]>(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        _15 = <core::iter::Copied<core::slice::Iter<'_, [u8; 2]>> as core::iter::Iterator>::map::<u16, fn([u8; core::::num::{impl#7}::from_be_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_be_bytes}>(move _16, core::num::<impl u16>::from_be_bytes) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        _14 = core::char::methods::<impl char>::decode_utf16::<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_be_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_be_bytes}>>(move _15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_15);\n        _13 = <core::char::DecodeUtf16<core::iter::Map<core::iter::Copied<core::slice::Iter<'_, [u8; 2]>>, fn([u8; core::::num::{impl#7}::from_be_bytes::{constant#0}]) -> u16 {core::num::<impl u16>::from_be_bytes}>> as core::iter::Iterator>::collect::<core::result::Result<string::String, core::char::DecodeUtf16Error>>(move _14) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_14);\n        _0 = core::result::Result::<string::String, core::char::DecodeUtf16Error>::map_err::<string::FromUtf16Error, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:869:26: 869:29}>(move _13, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:869:26: 869:29}) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_13);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_6);\n        goto -> bb17;\n    }\n    bb17: {\n        return;\n    }\n}\n",
  "doc": " Decode a UTF-16BE‚Äìencoded vector `v` into a `String`,\n returning [`Err`] if `v` contains any invalid data.\n\n # Examples\n\n Basic usage:\n\n ```\n #![feature(str_from_utf16_endian)]\n // ùÑûmusic\n let v = &[0xD8, 0x34, 0xDD, 0x1E, 0x00, 0x6d, 0x00, 0x75,\n           0x00, 0x73, 0x00, 0x69, 0x00, 0x63];\n assert_eq!(String::from(\"ùÑûmusic\"),\n            String::from_utf16be(v).unwrap());\n\n // ùÑûmu<invalid>ic\n let v = &[0xD8, 0x34, 0xDD, 0x1E, 0x00, 0x6d, 0x00, 0x75,\n           0xD8, 0x00, 0x00, 0x69, 0x00, 0x63];\n assert!(String::from_utf16be(v).is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}