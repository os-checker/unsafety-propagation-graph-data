{
  "name": "collections::btree::map::ExtractIfInner::<'a, K, V, R>::next",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::next_kv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n on the right side, which is either in the same leaf node or in an ancestor node.\n If the leaf edge is the last one in the tree, returns [`Result::Err`] with the root node.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::kv_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::Handle": "MutableAsArgument"
      }
    },
    "core::ops::RangeBounds::end_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " End index bound.\n\n Returns the end value as a `Bound`.\n\n # Examples\n\n ```\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n\n assert_eq!((3..).end_bound(), Unbounded);\n assert_eq!((3..10).end_bound(), Excluded(&10));\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::remove_kv_tracking": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key-value pair from the tree, and returns that pair, as well as\n the leaf edge corresponding to that former pair. It's possible this empties\n a root node that is internal, which the caller should pop from the map\n holding the tree. The caller should also decrement the map's length.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::next_leaf_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the leaf edge closest to a KV for forward navigation.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::map::ExtractIfInner": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::node::Handle": [
      "Plain",
      "MutRef",
      "Unknown([Field(0, Ty { id: 2767, kind: RigidTy(Tuple([Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }])) })])",
      "Unknown([Field(1, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2554, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::ops::Bound": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2625, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2625, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Not)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2039:5: 2075:6",
  "src": "pub(super) fn next<F, A: Allocator + Clone>(&mut self, pred: &mut F, alloc: A) -> Option<(K, V)>\n    where\n        K: PartialOrd,\n        R: RangeBounds<K>,\n        F: FnMut(&K, &mut V) -> bool,\n    {\n        while let Ok(mut kv) = self.cur_leaf_edge.take()?.next_kv() {\n            let (k, v) = kv.kv_mut();\n\n            // On creation, we navigated directly to the left bound, so we need only check the\n            // right bound here to decide whether to stop.\n            match self.range.end_bound() {\n                Bound::Included(ref end) if (*k).le(end) => (),\n                Bound::Excluded(ref end) if (*k).lt(end) => (),\n                Bound::Unbounded => (),\n                _ => return None,\n            }\n\n            if pred(k, v) {\n                *self.length -= 1;\n                let (kv, pos) = kv.remove_kv_tracking(\n                    || {\n                        // SAFETY: we will touch the root in a way that will not\n                        // invalidate the position returned.\n                        let root = unsafe { self.dormant_root.take().unwrap().awaken() };\n                        root.pop_internal_level(alloc.clone());\n                        self.dormant_root = Some(DormantMutRef::new(root).1);\n                    },\n                    alloc.clone(),\n                );\n                self.cur_leaf_edge = Some(pos);\n                return Some(kv);\n            }\n            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n        }\n        None\n    }",
  "mir": "fn collections::btree::map::ExtractIfInner::<'a, K, V, R>::next(_1: &mut collections::btree::map::ExtractIfInner<'_, K, V, R>, _2: &mut F, _3: A) -> core::option::Option<(K, V)> {\n    let mut _0: core::option::Option<(K, V)>;\n    let mut _4: core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _5: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _6: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _7: &mut core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _8: isize;\n    let  _9: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _10: isize;\n    let mut _11: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let  _12: &mut K;\n    let  _13: &mut V;\n    let mut _14: (&mut K, &mut V);\n    let mut _15: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _16: core::ops::Bound<&K>;\n    let mut _17: &R;\n    let mut _18: isize;\n    let  _19: &&K;\n    let  _20: &&&K;\n    let mut _21: bool;\n    let mut _22: &K;\n    let  _23: &&K;\n    let  _24: &&&K;\n    let mut _25: bool;\n    let mut _26: &K;\n    let mut _27: bool;\n    let mut _28: (&K, &mut V);\n    let mut _29: &K;\n    let mut _30: (usize, bool);\n    let  _31: (K, V);\n    let  _32: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _33: ((K, V), collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n    let mut _34: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _35: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2060:21: 2060:23};\n    let mut _36: &mut core::option::Option<collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _37: &A;\n    let mut _38: A;\n    let mut _39: &A;\n    let mut _40: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _41: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _42: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _43: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _44: &&K;\n    let mut _45: &K;\n    let mut _46: &&K;\n    let mut _47: &K;\n    let mut _48: &mut usize;\n    let mut _49: &mut usize;\n    let mut _50: &mut usize;\n    debug self => _1;\n    debug pred => _2;\n    debug alloc => _3;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _9;\n    debug kv => _11;\n    debug k => _12;\n    debug v => _13;\n    debug end => _19;\n    debug end => _20;\n    debug end => _23;\n    debug end => _24;\n    debug kv => _31;\n    debug pos => _32;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut ((*_1).2: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>);\n        _6 = core::option::Option::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::take(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = <core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>> as core::ops::Try>::branch(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _9 = move ((_5 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        _4 = collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::next_kv(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = <core::option::Option<(K, V)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb31;\n    }\n    bb8: {\n        _10 = discriminant(_4);\n        switchInt(move _10) -> [0: bb9, 1: bb29, otherwise: bb4];\n    }\n    bb9: {\n        StorageLive(_11);\n        _11 = move ((_4 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _11;\n        _14 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>::kv_mut(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageLive(_12);\n        _12 = move (_14.0: &mut K);\n        _13 = move (_14.1: &mut V);\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &((*_1).3: R);\n        _16 = <R as core::ops::RangeBounds<K>>::end_bound(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb14, 1: bb13, 2: bb21, otherwise: bb4];\n    }\n    bb12: {\n        _0 = core::option::Option::None;\n        StorageDead(_16);\n        goto -> bb30;\n    }\n    bb13: {\n        StorageLive(_24);\n        StorageLive(_23);\n        _23 = &((_16 as variant#1).0: &K);\n        _24 = &_23;\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_12);\n        _44 = (*_24);\n        _45 = (*_44);\n        _25 = <K as core::cmp::PartialOrd>::lt(move _26, _45) -> [return: bb18, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_20);\n        StorageLive(_19);\n        _19 = &((_16 as variant#0).0: &K);\n        _20 = &_19;\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_12);\n        _46 = (*_20);\n        _47 = (*_46);\n        _21 = <K as core::cmp::PartialOrd>::le(move _22, _47) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _21) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageDead(_20);\n        goto -> bb21;\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageDead(_20);\n        goto -> bb12;\n    }\n    bb18: {\n        switchInt(move _25) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_24);\n        goto -> bb21;\n    }\n    bb20: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_24);\n        goto -> bb12;\n    }\n    bb21: {\n        StorageDead(_16);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &(*_12);\n        _28 = (move _29, _13);\n        _27 = <F as core::ops::FnMut<(&K, &mut V)>>::call_mut(_2, move _28) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _27) -> [0: bb27, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_29);\n        StorageDead(_28);\n        _48 = ((*_1).0: &mut usize);\n        _30 = CheckedSub((*_48), 1_usize);\n        _49 = ((*_1).0: &mut usize);\n        assert(!move (_30.1: bool), \"attempt to compute `{} - {}`, which would overflow\", (*_49), 1_usize) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _50 = ((*_1).0: &mut usize);\n        (*_50) = move (_30.0: usize);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = move _11;\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &mut ((*_1).1: core::option::Option<collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        StorageLive(_37);\n        _37 = &_3;\n        _35 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2060:21: 2060:23}(move _36, move _37);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &_3;\n        _38 = <A as core::clone::Clone>::clone(move _39) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_39);\n        _33 = collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::remove_kv_tracking::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2060:21: 2060:23}, A>(move _34, move _35, move _38) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_38);\n        StorageDead(_35);\n        StorageDead(_34);\n        _31 = move (_33.0: (K, V));\n        _32 = move (_33.1: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        StorageDead(_33);\n        StorageLive(_40);\n        _40 = core::option::Option::Some(_32);\n        ((*_1).2: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _40;\n        StorageDead(_40);\n        _0 = core::option::Option::Some(_31);\n        StorageDead(_27);\n        goto -> bb30;\n    }\n    bb27: {\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = move _11;\n        _42 = collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::next_leaf_edge(move _43) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_43);\n        _41 = core::option::Option::Some(move _42);\n        StorageDead(_42);\n        ((*_1).2: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _41;\n        StorageDead(_41);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb1;\n    }\n    bb29: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = core::option::Option::None;\n        drop(_3) -> [return: bb32, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_5);\n        StorageDead(_4);\n        drop(_3) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        return;\n    }\n}\n",
  "doc": " Implementation of a typical `ExtractIf::next` method, given the predicate.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}