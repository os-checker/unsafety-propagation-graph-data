{
  "name": "<collections::linked_list::LinkedList<T, A> as core::clone::Clone>::clone_from",
  "safe": true,
  "callees": {
    "collections::linked_list::LinkedList::<T, A>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Provides a forward iterator.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut list: LinkedList<u32> = LinkedList::new();\n\n list.push_back(0);\n list.push_back(1);\n list.push_back(2);\n\n let mut iter = list.iter();\n assert_eq!(iter.next(), Some(&0));\n assert_eq!(iter.next(), Some(&1));\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "ImmutableAsArgument",
        "collections::linked_list::Iter": "Constructor"
      }
    },
    "collections::linked_list::LinkedList::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of the `LinkedList`.\n\n This operation should compute in *O*(1) time.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut dl = LinkedList::new();\n\n dl.push_front(2);\n assert_eq!(dl.len(), 1);\n\n dl.push_front(1);\n assert_eq!(dl.len(), 2);\n\n dl.push_back(3);\n assert_eq!(dl.len(), 3);\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "ImmutableAsArgument"
      }
    },
    "collections::linked_list::LinkedList::<T, A>::split_off": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the list into two at the given index. Returns everything after the given index,\n including the index.\n\n This operation should compute in *O*(*n*) time.\n\n # Panics\n\n Panics if `at > len`.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut d = LinkedList::new();\n\n d.push_front(1);\n d.push_front(2);\n d.push_front(3);\n\n let mut split = d.split_off(2);\n\n assert_eq!(split.pop_front(), Some(1));\n assert_eq!(split.pop_front(), None);\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "Constructor"
      }
    },
    "collections::linked_list::LinkedList::<T, A>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Provides a forward iterator with mutable references.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut list: LinkedList<u32> = LinkedList::new();\n\n list.push_back(0);\n list.push_back(1);\n list.push_back(2);\n\n for element in list.iter_mut() {\n     *element += 10;\n }\n\n let mut iter = list.iter();\n assert_eq!(iter.next(), Some(&10));\n assert_eq!(iter.next(), Some(&11));\n assert_eq!(iter.next(), Some(&12));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "MutableAsArgument",
        "collections::linked_list::IterMut": "Constructor"
      }
    },
    "core::iter::Iterator::zip": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " 'Zips up' two iterators into a single iterator of pairs.\n\n `zip()` returns a new iterator that will iterate over two other\n iterators, returning a tuple where the first element comes from the\n first iterator, and the second element comes from the second iterator.\n\n In other words, it zips two iterators together, into a single one.\n\n If either iterator returns [`None`], [`next`] from the zipped iterator\n will return [`None`].\n If the zipped iterator has no more elements to return then each further attempt to advance\n it will first try to advance the first iterator at most one time and if it still yielded an item\n try to advance the second iterator at most one time.\n\n To 'undo' the result of zipping up two iterators, see [`unzip`].\n\n [`unzip`]: Iterator::unzip\n\n # Examples\n\n Basic usage:\n\n ```\n let s1 = \"abc\".chars();\n let s2 = \"def\".chars();\n\n let mut iter = s1.zip(s2);\n\n assert_eq!(iter.next(), Some(('a', 'd')));\n assert_eq!(iter.next(), Some(('b', 'e')));\n assert_eq!(iter.next(), Some(('c', 'f')));\n assert_eq!(iter.next(), None);\n ```\n\n Since the argument to `zip()` uses [`IntoIterator`], we can pass\n anything that can be converted into an [`Iterator`], not just an\n [`Iterator`] itself. For example, arrays (`[T]`) implement\n [`IntoIterator`], and so can be passed to `zip()` directly:\n\n ```\n let a1 = [1, 2, 3];\n let a2 = [4, 5, 6];\n\n let mut iter = a1.into_iter().zip(a2);\n\n assert_eq!(iter.next(), Some((1, 4)));\n assert_eq!(iter.next(), Some((2, 5)));\n assert_eq!(iter.next(), Some((3, 6)));\n assert_eq!(iter.next(), None);\n ```\n\n `zip()` is often used to zip an infinite iterator to a finite one.\n This works because the finite iterator will eventually return [`None`],\n ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`]:\n\n ```\n let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n\n let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n\n assert_eq!((0, 'f'), enumerate[0]);\n assert_eq!((0, 'f'), zipper[0]);\n\n assert_eq!((1, 'o'), enumerate[1]);\n assert_eq!((1, 'o'), zipper[1]);\n\n assert_eq!((2, 'o'), enumerate[2]);\n assert_eq!((2, 'o'), zipper[2]);\n ```\n\n If both iterators have roughly equivalent syntax, it may be more readable to use [`zip`]:\n\n ```\n use std::iter::zip;\n\n let a = [1, 2, 3];\n let b = [2, 3, 4];\n\n let mut zipped = zip(\n     a.into_iter().map(|x| x * 2).skip(1),\n     b.into_iter().map(|x| x * 2).skip(1),\n );\n\n assert_eq!(zipped.next(), Some((4, 6)));\n assert_eq!(zipped.next(), Some((6, 8)));\n assert_eq!(zipped.next(), None);\n ```\n\n compared to:\n\n ```\n # let a = [1, 2, 3];\n # let b = [2, 3, 4];\n #\n let mut zipped = a\n     .into_iter()\n     .map(|x| x * 2)\n     .skip(1)\n     .zip(b.into_iter().map(|x| x * 2).skip(1));\n #\n # assert_eq!(zipped.next(), Some((4, 6)));\n # assert_eq!(zipped.next(), Some((6, 8)));\n # assert_eq!(zipped.next(), None);\n ```\n\n [`enumerate`]: Iterator::enumerate\n [`next`]: Iterator::next\n [`zip`]: crate::iter::zip\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone_from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs copy-assignment from `source`.\n\n `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n but can be overridden to reuse the resources of `a` to avoid unnecessary\n allocations.\n",
      "adt": {}
    },
    "core::iter::ExactSizeIterator::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the iterator is empty.\n\n This method has a default implementation using\n [`ExactSizeIterator::len()`], so you don't need to implement it yourself.\n\n # Examples\n\n Basic usage:\n\n ```\n #![feature(exact_size_is_empty)]\n\n let mut one_element = std::iter::once(0);\n assert!(!one_element.is_empty());\n\n assert_eq!(one_element.next(), Some(0));\n assert!(one_element.is_empty());\n\n assert_eq!(one_element.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::cloned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which [`clone`]s all of its elements.\n\n This is useful when you have an iterator over `&T`, but you need an\n iterator over `T`.\n\n There is no guarantee whatsoever about the `clone` method actually\n being called *or* optimized away. So code should not depend on\n either.\n\n [`clone`]: Clone::clone\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let v_cloned: Vec<_> = a.iter().cloned().collect();\n\n // cloned is the same as .map(|&x| x), for integers\n let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\n assert_eq!(v_cloned, [1, 2, 3]);\n assert_eq!(v_map, [1, 2, 3]);\n ```\n\n To get the best performance, try to clone late:\n\n ```\n let a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];\n // don't do this:\n let slower: Vec<_> = a.iter().cloned().filter(|s| s.len() == 1).collect();\n assert_eq!(&[vec![23]], &slower[..]);\n // instead call `cloned` late\n let faster: Vec<_> = a.iter().filter(|s| s.len() == 1).cloned().collect();\n assert_eq!(&[vec![23]], &faster[..]);\n ```\n",
      "adt": {}
    },
    "core::iter::Extend::extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends a collection with the contents of an iterator.\n\n As this is the only required method for this trait, the [trait-level] docs\n contain more details.\n\n [trait-level]: Extend\n\n # Examples\n\n ```\n // You can extend a String with some chars:\n let mut message = String::from(\"abc\");\n\n message.extend(['d', 'e', 'f'].iter());\n\n assert_eq!(\"abcdef\", &message);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::linked_list::LinkedList": [
      "Ref",
      "Deref",
      "MutRef",
      "Plain"
    ],
    "collections::linked_list::Iter": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "collections::linked_list::IterMut": [
      "Plain"
    ],
    "core::iter::Zip": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6254, kind: RigidTy(Tuple([Ty { id: 428, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) }, Ty { id: 422, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) }])) }), Field(0, Ty { id: 428, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6254, kind: RigidTy(Tuple([Ty { id: 428, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) }, Ty { id: 422, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) }])) }), Field(1, Ty { id: 422, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) })])"
    ],
    "core::iter::Cloned": [
      "Plain"
    ]
  },
  "path": 1261,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/linked_list.rs:2165:5: 2176:6",
  "src": "fn clone_from(&mut self, source: &Self) {\n        let mut source_iter = source.iter();\n        if self.len() > source.len() {\n            self.split_off(source.len());\n        }\n        for (elem, source_elem) in self.iter_mut().zip(&mut source_iter) {\n            elem.clone_from(source_elem);\n        }\n        if !source_iter.is_empty() {\n            self.extend(source_iter.cloned());\n        }\n    }",
  "mir": "fn <collections::linked_list::LinkedList<T, A> as core::clone::Clone>::clone_from(_1: &mut collections::linked_list::LinkedList<T, A>, _2: &collections::linked_list::LinkedList<T, A>) -> () {\n    let mut _0: ();\n    let mut _3: collections::linked_list::Iter<'_, T>;\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: &collections::linked_list::LinkedList<T, A>;\n    let mut _7: usize;\n    let  _8: collections::linked_list::LinkedList<T, A>;\n    let mut _9: usize;\n    let mut _10: core::iter::Zip<collections::linked_list::IterMut<'_, T>, &mut collections::linked_list::Iter<'_, T>>;\n    let mut _11: core::iter::Zip<collections::linked_list::IterMut<'_, T>, &mut collections::linked_list::Iter<'_, T>>;\n    let mut _12: collections::linked_list::IterMut<'_, T>;\n    let mut _13: &mut collections::linked_list::Iter<'_, T>;\n    let mut _14: core::iter::Zip<collections::linked_list::IterMut<'_, T>, &mut collections::linked_list::Iter<'_, T>>;\n    let mut _15: core::option::Option<(&mut T, &T)>;\n    let mut _16: &mut core::iter::Zip<collections::linked_list::IterMut<'_, T>, &mut collections::linked_list::Iter<'_, T>>;\n    let mut _17: isize;\n    let  _18: &mut T;\n    let  _19: &T;\n    let  _20: ();\n    let mut _21: bool;\n    let mut _22: &collections::linked_list::Iter<'_, T>;\n    let  _23: ();\n    let mut _24: core::iter::Cloned<collections::linked_list::Iter<'_, T>>;\n    let mut _25: collections::linked_list::Iter<'_, T>;\n    debug self => _1;\n    debug source => _2;\n    debug source_iter => _3;\n    debug iter => _14;\n    debug elem => _18;\n    debug source_elem => _19;\n    bb0: {\n        StorageLive(_3);\n        _3 = collections::linked_list::LinkedList::<T, A>::iter(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = collections::linked_list::LinkedList::<T, A>::len(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = collections::linked_list::LinkedList::<T, A>::len(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = Gt(move _5, move _7);\n        switchInt(move _4) -> [0: bb8, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = collections::linked_list::LinkedList::<T, A>::len(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = collections::linked_list::LinkedList::<T, A>::split_off(_1, move _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_9);\n        drop(_8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_4);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = collections::linked_list::LinkedList::<T, A>::iter_mut(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_13);\n        _13 = &mut _3;\n        _11 = <collections::linked_list::IterMut<'_, T> as core::iter::Iterator>::zip::<&mut collections::linked_list::Iter<'_, T>>(move _12, move _13) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _10 = <core::iter::Zip<collections::linked_list::IterMut<'_, T>, &mut collections::linked_list::Iter<'_, T>> as core::iter::IntoIterator>::into_iter(move _11) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_11);\n        StorageLive(_14);\n        _14 = move _10;\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_15);\n        _16 = &mut _14;\n        _15 = <core::iter::Zip<collections::linked_list::IterMut<'_, T>, &mut collections::linked_list::Iter<'_, T>> as core::iter::Iterator>::next(_16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _17 = discriminant(_15);\n        switchInt(move _17) -> [0: bb17, 1: bb16, otherwise: bb15];\n    }\n    bb15: {\n        unreachable;\n    }\n    bb16: {\n        _18 = move (((_15 as variant#1).0: (&mut T, &T)).0: &mut T);\n        _19 = (((_15 as variant#1).0: (&mut T, &T)).1: &T);\n        _20 = <T as core::clone::Clone>::clone_from(_18, _19) -> [return: bb18, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_10);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_3;\n        _21 = <collections::linked_list::Iter<'_, T> as core::iter::ExactSizeIterator>::is_empty(move _22) -> [return: bb19, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_15);\n        goto -> bb13;\n    }\n    bb19: {\n        switchInt(move _21) -> [0: bb21, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_22);\n        goto -> bb24;\n    }\n    bb21: {\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = move _3;\n        _24 = <collections::linked_list::Iter<'_, T> as core::iter::Iterator>::cloned::<'_, T>(move _25) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_25);\n        _23 = <collections::linked_list::LinkedList<T, A> as core::iter::Extend<T>>::extend::<core::iter::Cloned<collections::linked_list::Iter<'_, T>>>(_1, move _24) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_24);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_21);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Overwrites the contents of `self` with a clone of the contents of `source`.\n\n This method is preferred over simply assigning `source.clone()` to `self`,\n as it avoids reallocation of the nodes of the linked list. Additionally,\n if the element type `T` overrides `clone_from()`, this will reuse the\n resources of `self`'s elements as well.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}