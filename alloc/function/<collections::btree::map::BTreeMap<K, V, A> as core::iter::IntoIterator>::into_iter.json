{
  "name": "<collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter",
  "safe": true,
  "callees": {
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::into_dying": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Irreversibly transitions to a reference that permits traversal and offers\n destructive methods and little else.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::LeafOrInternal>>::full_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits a unique reference into a pair of leaf edges delimiting the full range of the tree.\n The results are non-unique references allowing massively destructive mutation, so must be\n used with the utmost care.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument",
        "collections::btree::navigate::LazyLeafRange": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::take": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value from the `ManuallyDrop<T>` container out.\n\n This method is primarily intended for moving out values in drop.\n Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n you can use this method to take the value and use it however desired.\n\n Whenever possible, it is preferable to use [`into_inner`][`ManuallyDrop::into_inner`]\n instead, which prevents duplicating the content of the `ManuallyDrop<T>`.\n\n # Safety\n\n This function semantically moves out the contained value without preventing further usage,\n leaving the state of this container unchanged.\n It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n\n",
      "adt": {}
    },
    "collections::btree::navigate::LazyLeafRange::<BorrowType, K, V>::none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::navigate::LazyLeafRange": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "Plain",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::mem::ManuallyDrop": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::node::NodeRef": [
      "Plain"
    ],
    "collections::btree::navigate::LazyLeafRange": [
      "Plain"
    ],
    "collections::btree::map::IntoIter": [
      "Plain"
    ]
  },
  "path": 594,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1726:5: 1743:6",
  "src": "fn into_iter(self) -> IntoIter<K, V, A> {\n        let mut me = ManuallyDrop::new(self);\n        if let Some(root) = me.root.take() {\n            let full_range = root.into_dying().full_range();\n\n            IntoIter {\n                range: full_range,\n                length: me.length,\n                alloc: unsafe { ManuallyDrop::take(&mut me.alloc) },\n            }\n        } else {\n            IntoIter {\n                range: LazyLeafRange::none(),\n                length: 0,\n                alloc: unsafe { ManuallyDrop::take(&mut me.alloc) },\n            }\n        }\n    }",
  "mir": "fn <collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter(_1: collections::btree::map::BTreeMap<K, V, A>) -> collections::btree::map::IntoIter<K, V, A> {\n    let mut _0: collections::btree::map::IntoIter<K, V, A>;\n    let mut _2: core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _3: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _4: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _5: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let mut _6: &mut core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _7: isize;\n    let  _8: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _9: collections::btree::navigate::LazyLeafRange<collections::btree::node::marker::Dying, K, V>;\n    let mut _10: collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _11: usize;\n    let mut _12: &collections::btree::map::BTreeMap<K, V, A>;\n    let mut _13: &core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _14: A;\n    let mut _15: &mut core::mem::ManuallyDrop<A>;\n    let mut _16: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let mut _17: &mut core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _18: collections::btree::navigate::LazyLeafRange<collections::btree::node::marker::Dying, K, V>;\n    let mut _19: A;\n    let mut _20: &mut core::mem::ManuallyDrop<A>;\n    let mut _21: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let mut _22: &mut core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>>;\n    debug self => _1;\n    debug me => _2;\n    debug root => _8;\n    debug full_range => _9;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::ManuallyDrop::<collections::btree::map::BTreeMap<K, V, A>>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut _2;\n        _5 = <core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>> as core::ops::DerefMut>::deref_mut(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = &mut ((*_5).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _3 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::take(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _7 = discriminant(_3);\n        switchInt(move _7) -> [1: bb4, 0: bb10, otherwise: bb15];\n    }\n    bb4: {\n        _8 = move ((_3 as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_10);\n        _10 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::into_dying(_8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::LeafOrInternal>>::full_range(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_2;\n        _12 = <core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>> as core::ops::Deref>::deref(move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        _11 = ((*_12).1: usize);\n        StorageLive(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _2;\n        _16 = <core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>> as core::ops::DerefMut>::deref_mut(move _17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        _15 = &mut ((*_16).2: core::mem::ManuallyDrop<A>);\n        _14 = core::mem::ManuallyDrop::<A>::take(_15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        _0 = IntoIter(_9, move _11, move _14);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb14;\n    }\n    bb10: {\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageLive(_18);\n        _18 = collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::none() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &mut _2;\n        _21 = <core::mem::ManuallyDrop<collections::btree::map::BTreeMap<K, V, A>> as core::ops::DerefMut>::deref_mut(move _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        _20 = &mut ((*_21).2: core::mem::ManuallyDrop<A>);\n        _19 = core::mem::ManuallyDrop::<A>::take(_20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        _0 = IntoIter(move _18, 0_usize, move _19);\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_2);\n        return;\n    }\n    bb15: {\n        unreachable;\n    }\n}\n",
  "doc": " Gets an owning iterator over the entries of the map, sorted by key.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}