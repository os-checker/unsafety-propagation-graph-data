{
  "name": "vec::Vec::<T, A>::extend_trusted",
  "safe": true,
  "callees": {
    "core::iter::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves capacity for at least `additional` more elements to be inserted\n in the given `Vec<T>`. The collection may reserve more space to\n speculatively avoid frequent reallocations. After calling `reserve`,\n capacity will be greater than or equal to `self.len() + additional`.\n Does nothing if capacity is already sufficient.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.reserve(10);\n assert!(vec.capacity() >= 11);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "vec::set_len_on_drop::SetLenOnDrop::<'a>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "vec::set_len_on_drop::SetLenOnDrop": "Constructor"
      }
    },
    "core::iter::Iterator::for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls a closure on each element of an iterator.\n\n This is equivalent to using a [`for`] loop on the iterator, although\n `break` and `continue` are not possible from a closure. It's generally\n more idiomatic to use a `for` loop, but `for_each` may be more legible\n when processing items at the end of longer iterator chains. In some\n cases `for_each` may also be faster than a loop, because it will use\n internal iteration on adapters like `Chain`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n use std::sync::mpsc::channel;\n\n let (tx, rx) = channel();\n (0..5).map(|x| x * 2 + 1)\n       .for_each(move |x| tx.send(x).unwrap());\n\n let v: Vec<_> = rx.iter().collect();\n assert_eq!(v, vec![1, 3, 5, 7, 9]);\n ```\n\n For such a small example, a `for` loop may be cleaner, but `for_each`\n might be preferable to keep a functional style with longer iterators:\n\n ```\n (0..5).flat_map(|x| (x * 100)..(x * 110))\n       .enumerate()\n       .filter(|&(i, x)| (i + x) % 3 == 0)\n       .for_each(|(i, x)| println!(\"{i}:{x}\"));\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 257, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "vec::Vec": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "vec::set_len_on_drop::SetLenOnDrop": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::vec::Vec::<T, A>::extend_trusted"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3847:5: 3876:6",
  "src": "fn extend_trusted(&mut self, iterator: impl iter::TrustedLen<Item = T>) {\n        let (low, high) = iterator.size_hint();\n        if let Some(additional) = high {\n            debug_assert_eq!(\n                low,\n                additional,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n            self.reserve(additional);\n            unsafe {\n                let ptr = self.as_mut_ptr();\n                let mut local_len = SetLenOnDrop::new(&mut self.len);\n                iterator.for_each(move |element| {\n                    ptr::write(ptr.add(local_len.current_len()), element);\n                    // Since the loop executes user code which can panic we have to update\n                    // the length every step to correctly drop what we've written.\n                    // NB can't overflow since we would have had to alloc the address space\n                    local_len.increment_len(1);\n                });\n            }\n        } else {\n            // Per TrustedLen contract a `None` upper bound means that the iterator length\n            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n            // This avoids additional codegen for a fallback code path which would eventually\n            // panic anyway.\n            panic!(\"capacity overflow\");\n        }\n    }",
  "mir": "fn vec::Vec::<T, A>::extend_trusted(_1: &mut vec::Vec<T, A>, _2: impl iter::TrustedLen<Item = T>) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let  _4: core::option::Option<usize>;\n    let mut _5: (usize, core::option::Option<usize>);\n    let mut _6: &impl iter::TrustedLen<Item = T>;\n    let mut _7: isize;\n    let  _8: usize;\n    let mut _9: (&usize, &usize);\n    let mut _10: &usize;\n    let mut _11: &usize;\n    let  _12: &usize;\n    let  _13: &usize;\n    let mut _14: bool;\n    let mut _15: usize;\n    let mut _16: usize;\n    let  _17: core::panicking::AssertKind;\n    let  _18: !;\n    let mut _19: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _20: core::fmt::Arguments<'_>;\n    let  _21: (&(usize, core::option::Option<usize>),);\n    let mut _22: &(usize, core::option::Option<usize>);\n    let  _23: (usize, core::option::Option<usize>);\n    let  _24: [core::fmt::rt::Argument<'_>; 1];\n    let mut _25: core::fmt::rt::Argument<'_>;\n    let mut _26: &[u8; 49];\n    let  _27: &[core::fmt::rt::Argument<'_>; 1];\n    let  _28: ();\n    let  _29: *mut T;\n    let mut _30: vec::set_len_on_drop::SetLenOnDrop<'_>;\n    let mut _31: &mut usize;\n    let  _32: ();\n    let mut _33: impl iter::TrustedLen<Item = T>;\n    let mut _34: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3860:35: 3860:49};\n    let  _35: !;\n    let mut _36: core::fmt::Arguments<'_>;\n    let mut _37: &(usize, core::option::Option<usize>);\n    debug self => _1;\n    debug iterator => _2;\n    debug low => _3;\n    debug high => _4;\n    debug additional => _8;\n    debug left_val => _12;\n    debug right_val => _13;\n    debug kind => _17;\n    debug args => _21;\n    debug args => _24;\n    debug ptr => _29;\n    debug local_len => _30;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = <impl iter::TrustedLen<Item = T> as core::iter::Iterator>::size_hint(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _3 = (_5.0: usize);\n        _4 = (_5.1: core::option::Option<usize>);\n        StorageDead(_5);\n        _7 = discriminant(_4);\n        switchInt(move _7) -> [1: bb2, 0: bb11, otherwise: bb13];\n    }\n    bb2: {\n        _8 = ((_4 as variant#1).0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_3;\n        StorageLive(_11);\n        _11 = &_8;\n        _9 = (move _10, move _11);\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = (_9.0: &usize);\n        _13 = (_9.1: &usize);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (*_12);\n        StorageLive(_16);\n        _16 = (*_13);\n        _14 = Eq(move _15, move _16);\n        switchInt(move _14) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_9);\n        _28 = vec::Vec::<T, A>::reserve(_1, _8) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_16);\n        StorageDead(_15);\n        _17 = core::panicking::AssertKind::Eq;\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = (_3, _4);\n        _22 = &_23;\n        _21 = (move _22);\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _37 = (_21.0: &(usize, core::option::Option<usize>));\n        _25 = core::fmt::rt::Argument::<'_>::new_debug::<(usize, core::option::Option<usize>)>(_37) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _24 = [move _25];\n        StorageDead(_25);\n        StorageLive(_26);\n        _26 = b\".TrustedLen iterator\\'s size hint is not exact: \\xc0\\x00\";\n        _27 = &_24;\n        _20 = core::fmt::Arguments::<'_>::new::<49, 1>(move _26, _27) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_26);\n        _19 = core::option::Option::Some(move _20);\n        StorageDead(_20);\n        _18 = core::panicking::assert_failed::<usize, usize>(_17, _12, _13, move _19) -> unwind unreachable;\n    }\n    bb7: {\n        StorageLive(_29);\n        _29 = vec::Vec::<T, A>::as_mut_ptr(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_30);\n        _31 = &mut ((*_1).1: usize);\n        _30 = vec::set_len_on_drop::SetLenOnDrop::<'_>::new(_31) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_33);\n        _33 = move _2;\n        StorageLive(_34);\n        _34 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3860:35: 3860:49}(_29, move _30);\n        _32 = <impl iter::TrustedLen<Item = T> as core::iter::Iterator>::for_each::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3860:35: 3860:49}>(move _33, move _34) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_30);\n        StorageDead(_29);\n        return;\n    }\n    bb11: {\n        StorageLive(_36);\n        _36 = core::fmt::Arguments::<'_>::from_str(\"capacity overflow\") -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _35 = core::panicking::panic_fmt(move _36) -> unwind unreachable;\n    }\n    bb13: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}