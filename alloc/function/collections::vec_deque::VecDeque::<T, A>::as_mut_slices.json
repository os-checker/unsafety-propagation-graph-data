{
  "name": "collections::vec_deque::VecDeque::<T, A>::as_mut_slices",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::slice_ranges": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given a range into the logical buffer of the deque, this function\n return two ranges into the physical buffer that correspond to\n the given range. The `len` parameter should usually just be `self.len`;\n the reason it's passed explicitly is that if the deque is wrapped in\n a `Drain`, then `self.len` is not actually the length of the deque.\n\n # Safety\n\n This function is always safe to call. For the resulting ranges to be valid\n ranges into the physical buffer, the caller must ensure that the result of\n calling `slice::range(range, ..len)` represents a valid range into the\n logical buffer, and that all elements in that range are initialized.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument",
        "core::ops::Range": "Constructor"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::buffer_range": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a slice pointer into the buffer.\n `range` must lie inside `0..self.capacity()`.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1762, kind: RigidTy(Adt(AdtDef(DefId { id: 3232, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Field(1, Ty { id: 1762, kind: RigidTy(Adt(AdtDef(DefId { id: 3232, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])"
    ]
  },
  "path": 1455,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1605:5: 1610:6",
  "src": "pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n        let (a_range, b_range) = self.slice_ranges(.., self.len);\n        // SAFETY: `slice_ranges` always returns valid ranges into\n        // the physical buffer.\n        unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::as_mut_slices(_1: &mut collections::vec_deque::VecDeque<T, A>) -> (&mut [T], &mut [T]) {\n    let mut _0: (&mut [T], &mut [T]);\n    let  _2: core::ops::Range<usize>;\n    let  _3: core::ops::Range<usize>;\n    let mut _4: (core::ops::Range<usize>, core::ops::Range<usize>);\n    let mut _5: &collections::vec_deque::VecDeque<T, A>;\n    let mut _6: usize;\n    let mut _7: &mut [T];\n    let mut _8: *mut [T];\n    let mut _9: &collections::vec_deque::VecDeque<T, A>;\n    let mut _10: &mut [T];\n    let mut _11: *mut [T];\n    let mut _12: &collections::vec_deque::VecDeque<T, A>;\n    debug self => _1;\n    debug a_range => _2;\n    debug b_range => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        StorageLive(_6);\n        _6 = ((*_1).1: usize);\n        _4 = collections::vec_deque::VecDeque::<T, A>::slice_ranges::<core::ops::RangeFull>(move _5, core::ops::RangeFull, move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _2 = move (_4.0: core::ops::Range<usize>);\n        _3 = move (_4.1: core::ops::Range<usize>);\n        StorageDead(_4);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_1);\n        _8 = collections::vec_deque::VecDeque::<T, A>::buffer_range(move _9, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        _7 = &mut (*_8);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = collections::vec_deque::VecDeque::<T, A>::buffer_range(move _12, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_12);\n        _10 = &mut (*_11);\n        _0 = (_7, _10);\n        StorageDead(_11);\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n\n deque.push_front(10);\n deque.push_front(9);\n\n // Since the split point is not guaranteed, we may need to update\n // either slice.\n let mut update_nth = |index: usize, val: u32| {\n     let (front, back) = deque.as_mut_slices();\n     if index > front.len() - 1 {\n         back[index - front.len()] = val;\n     } else {\n         front[index] = val;\n     }\n };\n\n update_nth(0, 42);\n update_nth(2, 24);\n\n let v: Vec<_> = deque.into();\n assert_eq!(v, [42, 10, 24, 1]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}