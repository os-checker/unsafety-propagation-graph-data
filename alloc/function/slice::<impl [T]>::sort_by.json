{
  "name": "slice::<impl [T]>::sort_by",
  "safe": true,
  "callees": {
    "slice::stable_sort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "alloc::slice::<impl [T]>::sort_by"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:192:5: 197:6",
  "src": "pub fn sort_by<F>(&mut self, mut compare: F)\n    where\n        F: FnMut(&T, &T) -> Ordering,\n    {\n        stable_sort(self, |a, b| compare(a, b) == Less);\n    }",
  "mir": "fn slice::<impl [T]>::sort_by(_1: &mut [T], _2: F) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:196:27: 196:33};\n    let mut _5: &mut F;\n    debug self => _1;\n    debug compare => _2;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _2;\n        _4 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:196:27: 196:33}(move _5);\n        StorageDead(_5);\n        _3 = slice::stable_sort::<T, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:196:27: 196:33}>(_1, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        drop(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Sorts the slice in ascending order with a comparison function, preserving initial order of\n equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\n worst-case.\n\n If the comparison function `compare` does not implement a [total order], the function may\n panic; even if the function exits normally, the resulting order of elements in the slice is\n unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n # Current implementation\n\n The current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\n combines the fast average case of quicksort with the fast worst case and partial run\n detection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\n with k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n The auxiliary memory allocation behavior depends on the input length. Short slices are\n handled without allocation, medium sized slices allocate `self.len()` and beyond that it\n clamps at `self.len() / 2`.\n\n # Panics\n\n May panic if `compare` does not implement a [total order], or if `compare` itself panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n v.sort_by(|a, b| a.cmp(b));\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n\n // reverse sorting\n v.sort_by(|a, b| b.cmp(a));\n assert_eq!(v, [4, 2, 1, -3, -5]);\n ```\n\n [driftsort]: https://github.com/Voultapher/driftsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}