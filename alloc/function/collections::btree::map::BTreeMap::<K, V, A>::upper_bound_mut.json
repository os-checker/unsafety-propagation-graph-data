{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut",
  "safe": true,
  "callees": {
    "collections::btree::borrow::DormantMutRef::<'a, T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Capture a unique borrow, and immediately reborrow it. For the compiler,\n the lifetime of the new reference is the same as the lifetime of the\n original reference, but you promise to use it for a shorter period.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "Constructor"
      }
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "collections::btree::search::SearchBound::<T>::from_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::search::SearchBound": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::upper_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the leaf edge corresponding to the last point at which the\n given bound is true.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Unknown([Field(0, Ty { id: 3074, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2811, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 3790, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2811, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })]))) })]))) })])",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2378, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }, Mut)) })])"
    ],
    "collections::btree::map::BTreeMap": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3074, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2811, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 3790, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2811, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })]))) })]))) })])"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "MutRef"
    ],
    "collections::btree::map::CursorMutKey": [
      "Plain"
    ],
    "collections::btree::map::CursorMut": [
      "Plain"
    ],
    "core::ops::Bound": [
      "Plain"
    ],
    "collections::btree::search::SearchBound": [
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2908:5: 2936:6",
  "src": "pub fn upper_bound_mut<Q: ?Sized>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, K, V, A>\n    where\n        K: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        let (root, dormant_root) = DormantMutRef::new(&mut self.root);\n        let root_node = match root.as_mut() {\n            None => {\n                return CursorMut {\n                    inner: CursorMutKey {\n                        current: None,\n                        root: dormant_root,\n                        length: &mut self.length,\n                        alloc: &mut *self.alloc,\n                    },\n                };\n            }\n            Some(root) => root.borrow_mut(),\n        };\n        let edge = root_node.upper_bound(SearchBound::from_range(bound));\n        CursorMut {\n            inner: CursorMutKey {\n                current: Some(edge),\n                root: dormant_root,\n                length: &mut self.length,\n                alloc: &mut *self.alloc,\n            },\n        }\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut(_1: &mut collections::btree::map::BTreeMap<K, V, A>, _2: core::ops::Bound<&Q>) -> collections::btree::map::CursorMut<'_, K, V, A> {\n    let mut _0: collections::btree::map::CursorMut<'_, K, V, A>;\n    let  _3: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let  _4: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _5: (&mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>, collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n    let mut _6: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let  _7: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _8: core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _9: isize;\n    let mut _10: collections::btree::map::CursorMutKey<'_, K, V, A>;\n    let mut _11: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _12: &mut usize;\n    let mut _13: &mut A;\n    let mut _14: &mut core::mem::ManuallyDrop<A>;\n    let  _15: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _16: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _17: collections::btree::search::SearchBound<&Q>;\n    let mut _18: collections::btree::map::CursorMutKey<'_, K, V, A>;\n    let mut _19: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _20: &mut usize;\n    let mut _21: &mut A;\n    let mut _22: &mut core::mem::ManuallyDrop<A>;\n    debug self => _1;\n    debug bound => _2;\n    debug root => _3;\n    debug dormant_root => _4;\n    debug root_node => _7;\n    debug root => _15;\n    debug edge => _16;\n    bb0: {\n        StorageLive(_5);\n        _6 = &mut ((*_1).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _5 = collections::btree::borrow::DormantMutRef::<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>::new(_6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = move (_5.0: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _4 = move (_5.1: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::as_mut(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _9 = discriminant(_8);\n        switchInt(move _9) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _15 = move ((_8 as variant#1).0: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        _7 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_15) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = core::option::Option::None;\n        _12 = &mut ((*_1).1: usize);\n        StorageLive(_14);\n        _14 = &mut ((*_1).2: core::mem::ManuallyDrop<A>);\n        _13 = <core::mem::ManuallyDrop<A> as core::ops::DerefMut>::deref_mut(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _10 = CursorMutKey(move _11, _4, _12, _13);\n        StorageDead(_11);\n        _0 = CursorMut(move _10);\n        StorageDead(_10);\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageLive(_17);\n        _17 = collections::btree::search::SearchBound::<&Q>::from_range(_2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _16 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::upper_bound::<Q>(_7, move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = core::option::Option::Some(_16);\n        _20 = &mut ((*_1).1: usize);\n        StorageLive(_22);\n        _22 = &mut ((*_1).2: core::mem::ManuallyDrop<A>);\n        _21 = <core::mem::ManuallyDrop<A> as core::ops::DerefMut>::deref_mut(move _22) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_22);\n        _18 = CursorMutKey(move _19, _4, _20, _21);\n        StorageDead(_19);\n        _0 = CursorMut(move _18);\n        StorageDead(_18);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Returns a [`CursorMut`] pointing at the gap after the greatest key\n smaller than the given bound.\n\n Passing `Bound::Included(x)` will return a cursor pointing to the\n gap after the greatest key smaller than or equal to `x`.\n\n Passing `Bound::Excluded(x)` will return a cursor pointing to the\n gap after the greatest key smaller than `x`.\n\n Passing `Bound::Unbounded` will return a cursor pointing to the\n gap after the greatest key in the map.\n\n # Examples\n\n ```\n #![feature(btree_cursors)]\n\n use std::collections::BTreeMap;\n use std::ops::Bound;\n\n let mut map = BTreeMap::from([\n     (1, \"a\"),\n     (2, \"b\"),\n     (3, \"c\"),\n     (4, \"d\"),\n ]);\n\n let mut cursor = map.upper_bound_mut(Bound::Included(&3));\n assert_eq!(cursor.peek_prev(), Some((&3, &mut \"c\")));\n assert_eq!(cursor.peek_next(), Some((&4, &mut \"d\")));\n\n let mut cursor = map.upper_bound_mut(Bound::Excluded(&3));\n assert_eq!(cursor.peek_prev(), Some((&2, &mut \"b\")));\n assert_eq!(cursor.peek_next(), Some((&3, &mut \"c\")));\n\n let mut cursor = map.upper_bound_mut(Bound::Unbounded);\n assert_eq!(cursor.peek_prev(), Some((&4, &mut \"d\")));\n assert_eq!(cursor.peek_next(), None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}