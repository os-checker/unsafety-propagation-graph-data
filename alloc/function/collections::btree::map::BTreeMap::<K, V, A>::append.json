{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::append",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the map contains no elements.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n assert!(a.is_empty());\n a.insert(1, \"a\");\n assert!(!a.is_empty());\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "ImmutableAsArgument"
      }
    },
    "core::mem::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps the values at two mutable locations, without deinitializing either one.\n\n * If you want to swap with a default or dummy value, see [`take`].\n * If you want to swap with a passed value, returning the old value, see [`replace`].\n\n # Examples\n\n ```\n use std::mem;\n\n let mut x = 5;\n let mut y = 42;\n\n mem::swap(&mut x, &mut y);\n\n assert_eq!(42, x);\n assert_eq!(5, y);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::map::BTreeMap::<K, V, A>::new_in": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a new empty BTreeMap with a reasonable choice for B.\n\n # Examples\n\n ```\n # #![feature(allocator_api)]\n # #![feature(btreemap_alloc)]\n use std::collections::BTreeMap;\n use std::alloc::Global;\n\n let mut map = BTreeMap::new_in(Global);\n\n // entries can now be inserted into the empty map\n map.insert(1, \"a\");\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    },
    "core::mem::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves `src` into the referenced `dest`, returning the previous `dest` value.\n\n Neither value is dropped.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a default value, see [`take`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n assert_eq!(vec![1, 2], old_v);\n assert_eq!(vec![3, 4, 5], v);\n ```\n\n `replace` allows consumption of a struct field by replacing it with another value.\n Without `replace` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let t = self.buf[i];\n         self.buf[i] = v;\n         t\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n avoid the move. But `replace` can be used to disassociate the original value at that index from\n `self`, allowing it to be returned:\n\n ```\n # #![allow(dead_code)]\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         mem::replace(&mut self.buf[i], v)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf[0], 0);\n\n assert_eq!(buffer.replace_index(0, 2), 0);\n assert_eq!(buffer.buf[0], 2);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::get_or_insert_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a value computed from `f` into the option if it is [`None`],\n then returns a mutable reference to the contained value.\n\n # Examples\n\n ```\n let mut x = None;\n\n {\n     let y: &mut u32 = x.get_or_insert_with(|| 5);\n     assert_eq!(y, &5);\n\n     *y = 7;\n }\n\n assert_eq!(x, Some(7));\n ```\n",
      "adt": {}
    },
    "collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::append_from_sorted_iters": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends all key-value pairs from the union of two ascending iterators,\n incrementing a `length` variable along the way. The latter makes it\n easier for the caller to avoid a leak when a drop handler panicks.\n\n If both iterators produce the same key, this method drops the pair from\n the left iterator and appends the pair from the right iterator.\n\n If you want the tree to end up in a strictly ascending order, like for\n a `BTreeMap`, both iterators should produce keys in strictly ascending\n order, each greater than all keys in the tree, including any keys\n already in the tree upon entry.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "Ref",
      "Deref",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Plain",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::mem::ManuallyDrop": [
      "Ref"
    ],
    "collections::btree::map::IntoIter": [
      "Plain"
    ],
    "core::option::Option": [
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::BTreeMap::<K, V, A>::append"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1216:5: 1241:6",
  "src": "pub fn append(&mut self, other: &mut Self)\n    where\n        K: Ord,\n        A: Clone,\n    {\n        // Do we have to append anything at all?\n        if other.is_empty() {\n            return;\n        }\n\n        // We can just swap `self` and `other` if `self` is empty.\n        if self.is_empty() {\n            mem::swap(self, other);\n            return;\n        }\n\n        let self_iter = mem::replace(self, Self::new_in((*self.alloc).clone())).into_iter();\n        let other_iter = mem::replace(other, Self::new_in((*self.alloc).clone())).into_iter();\n        let root = self.root.get_or_insert_with(|| Root::new((*self.alloc).clone()));\n        root.append_from_sorted_iters(\n            self_iter,\n            other_iter,\n            &mut self.length,\n            (*self.alloc).clone(),\n        )\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::append(_1: &mut collections::btree::map::BTreeMap<K, V, A>, _2: &mut collections::btree::map::BTreeMap<K, V, A>) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: &collections::btree::map::BTreeMap<K, V, A>;\n    let mut _5: bool;\n    let mut _6: &collections::btree::map::BTreeMap<K, V, A>;\n    let  _7: ();\n    let  _8: collections::btree::map::IntoIter<K, V, A>;\n    let mut _9: collections::btree::map::BTreeMap<K, V, A>;\n    let mut _10: collections::btree::map::BTreeMap<K, V, A>;\n    let mut _11: A;\n    let  _12: &A;\n    let mut _13: &core::mem::ManuallyDrop<A>;\n    let  _14: collections::btree::map::IntoIter<K, V, A>;\n    let mut _15: collections::btree::map::BTreeMap<K, V, A>;\n    let mut _16: collections::btree::map::BTreeMap<K, V, A>;\n    let mut _17: A;\n    let  _18: &A;\n    let mut _19: &core::mem::ManuallyDrop<A>;\n    let  _20: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _21: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _22: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1234:49: 1234:51};\n    let mut _23: &core::mem::ManuallyDrop<A>;\n    let mut _24: &mut usize;\n    let mut _25: A;\n    let  _26: &A;\n    let mut _27: &core::mem::ManuallyDrop<A>;\n    debug self => _1;\n    debug other => _2;\n    debug self_iter => _8;\n    debug other_iter => _14;\n    debug root => _20;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_2);\n        _3 = collections::btree::map::BTreeMap::<K, V, A>::is_empty(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb22;\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = collections::btree::map::BTreeMap::<K, V, A>::is_empty(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb7, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_6);\n        _7 = core::mem::swap::<collections::btree::map::BTreeMap<K, V, A>>(_1, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        goto -> bb22;\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_13);\n        _13 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _12 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        _11 = <A as core::clone::Clone>::clone(_12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _10 = collections::btree::map::BTreeMap::<K, V, A>::new_in(move _11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        _9 = core::mem::replace::<collections::btree::map::BTreeMap<K, V, A>>(_1, move _10) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_10);\n        _8 = <collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter(move _9) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_9);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_19);\n        _19 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _18 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _19) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        _17 = <A as core::clone::Clone>::clone(_18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _16 = collections::btree::map::BTreeMap::<K, V, A>::new_in(move _17) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_17);\n        _15 = core::mem::replace::<collections::btree::map::BTreeMap<K, V, A>>(_2, move _16) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_16);\n        _14 = <collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter(move _15) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_15);\n        StorageLive(_21);\n        _21 = &mut ((*_1).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _22 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1234:49: 1234:51}(move _23);\n        StorageDead(_23);\n        _20 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::get_or_insert_with::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1234:49: 1234:51}>(move _21, move _22) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _24 = &mut ((*_1).1: usize);\n        StorageLive(_25);\n        StorageLive(_27);\n        _27 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _26 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        _25 = <A as core::clone::Clone>::clone(_26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _0 = collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::append_from_sorted_iters::<collections::btree::map::IntoIter<K, V, A>, A>(_20, _8, _14, _24, move _25) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_25);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": " Moves all elements from `other` into `self`, leaving `other` empty.\n\n If a key from `other` is already present in `self`, the respective\n value from `self` will be overwritten with the respective value from `other`.\n Similar to [`insert`], though, the key is not overwritten,\n which matters for types that can be `==` without being identical.\n\n [`insert`]: BTreeMap::insert\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n a.insert(1, \"a\");\n a.insert(2, \"b\");\n a.insert(3, \"c\"); // Note: Key (3) also present in b.\n\n let mut b = BTreeMap::new();\n b.insert(3, \"d\"); // Note: Key (3) also present in a.\n b.insert(4, \"e\");\n b.insert(5, \"f\");\n\n a.append(&mut b);\n\n assert_eq!(a.len(), 5);\n assert_eq!(b.len(), 0);\n\n assert_eq!(a[&1], \"a\");\n assert_eq!(a[&2], \"b\");\n assert_eq!(a[&3], \"d\"); // Note: \"c\" has been overwritten.\n assert_eq!(a[&4], \"e\");\n assert_eq!(a[&5], \"f\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}