{
  "name": "<collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq<&mut [U]>>::eq",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n assert_eq!(deque.len(), 0);\n deque.push_back(1);\n assert_eq!(deque.len(), 1);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref"
    ]
  },
  "path": 1437,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/macros.rs:9:13: 16:14",
  "src": "fn eq(&self, other: &$rhs) -> bool {\n                if self.len() != other.len() {\n                    return false;\n                }\n                let (sa, sb) = self.as_slices();\n                let (oa, ob) = other[..].split_at(sa.len());\n                sa == oa && sb == ob\n            }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as core::cmp::PartialEq<&mut [U]>>::eq(_1: &collections::vec_deque::VecDeque<T, A>, _2: &&mut [U]) -> bool {\n    let mut _0: bool;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: &[U];\n    let  _7: &[T];\n    let  _8: &[T];\n    let mut _9: (&[T], &[T]);\n    let  _10: &[U];\n    let  _11: &[U];\n    let mut _12: (&[U], &[U]);\n    let  _13: &[U];\n    let mut _14: &[U];\n    let mut _15: usize;\n    let mut _16: bool;\n    let mut _17: &&[T];\n    let mut _18: &&[U];\n    let mut _19: &&[T];\n    let mut _20: &&[U];\n    let mut _21: &mut [U];\n    let mut _22: &mut [U];\n    debug self => _1;\n    debug other => _2;\n    debug sa => _7;\n    debug sb => _8;\n    debug oa => _10;\n    debug ob => _11;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = collections::vec_deque::VecDeque::<T, A>::len(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _21 = (*_2);\n        _6 = &(*_21);\n        _5 = PtrMetadata(move _6);\n        StorageDead(_6);\n        _3 = Ne(move _4, move _5);\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = false;\n        StorageDead(_3);\n        goto -> bb12;\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_9);\n        _9 = collections::vec_deque::VecDeque::<T, A>::as_slices(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = (_9.0: &[T]);\n        StorageLive(_8);\n        _8 = (_9.1: &[T]);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_14);\n        _22 = (*_2);\n        _14 = &(*_22);\n        _13 = <[U] as core::ops::Index<core::ops::RangeFull>>::index(move _14, core::ops::RangeFull) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageLive(_15);\n        _15 = PtrMetadata(_7);\n        _12 = core::slice::<impl [U]>::split_at(_13, move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        StorageLive(_10);\n        _10 = (_12.0: &[U]);\n        StorageLive(_11);\n        _11 = (_12.1: &[U]);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_7;\n        StorageLive(_18);\n        _18 = &_10;\n        _16 = <&[T] as core::cmp::PartialEq<&[U]>>::eq(move _17, move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _16) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_19);\n        _19 = &_8;\n        StorageLive(_20);\n        _20 = &_11;\n        _0 = <&[T] as core::cmp::PartialEq<&[U]>>::eq(move _19, move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _0 = false;\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_8);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}