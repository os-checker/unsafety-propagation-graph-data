{
  "name": "collections::vec_deque::VecDeque::<T, A>::make_contiguous",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::is_contiguous": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marginally more convenient\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::slice::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies a contiguous block of memory len long from src to dst\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies a contiguous block of memory len long from src to dst\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::buffer_range": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a slice pointer into the buffer.\n `range` must lie inside `0..self.capacity()`.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::rotate_left": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Rotates the slice in-place such that the first `mid` elements of the\n slice move to the end while the last `self.len() - mid` elements move to\n the front.\n\n After calling `rotate_left`, the element previously at index `mid` will\n become the first element in the slice.\n\n # Panics\n\n This function will panic if `mid` is greater than the length of the\n slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n rotation.\n\n # Complexity\n\n Takes linear (in `self.len()`) time.\n\n # Examples\n\n ```\n let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n a.rotate_left(2);\n assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n ```\n\n Rotating a subslice:\n\n ```\n let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n a[1..5].rotate_left(1);\n assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::rotate_right": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Rotates the slice in-place such that the first `self.len() - k`\n elements of the slice move to the end while the last `k` elements move\n to the front.\n\n After calling `rotate_right`, the element previously at index\n `self.len() - k` will become the first element in the slice.\n\n # Panics\n\n This function will panic if `k` is greater than the length of the\n slice. Note that `k == self.len()` does _not_ panic and is a no-op\n rotation.\n\n # Complexity\n\n Takes linear (in `self.len()`) time.\n\n # Examples\n\n ```\n let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n a.rotate_right(2);\n assert_eq!(a, ['e', 'f', 'a', 'b', 'c', 'd']);\n ```\n\n Rotating a subslice:\n\n ```\n let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n a[1..5].rotate_right(1);\n assert_eq!(a, ['a', 'e', 'b', 'c', 'd', 'f']);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": 1491,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:2764:5: 2888:6",
  "src": "pub fn make_contiguous(&mut self) -> &mut [T] {\n        if T::IS_ZST {\n            self.head = 0;\n        }\n\n        if self.is_contiguous() {\n            unsafe { return slice::from_raw_parts_mut(self.ptr().add(self.head), self.len) }\n        }\n\n        let &mut Self { head, len, .. } = self;\n        let ptr = self.ptr();\n        let cap = self.capacity();\n\n        let free = cap - len;\n        let head_len = cap - head;\n        let tail = len - head_len;\n        let tail_len = tail;\n\n        if free >= head_len {\n            // there is enough free space to copy the head in one go,\n            // this means that we first shift the tail backwards, and then\n            // copy the head to the correct position.\n            //\n            // from: DEFGH....ABC\n            // to:   ABCDEFGH....\n            unsafe {\n                self.copy(0, head_len, tail_len);\n                // ...DEFGH.ABC\n                self.copy_nonoverlapping(head, 0, head_len);\n                // ABCDEFGH....\n            }\n\n            self.head = 0;\n        } else if free >= tail_len {\n            // there is enough free space to copy the tail in one go,\n            // this means that we first shift the head forwards, and then\n            // copy the tail to the correct position.\n            //\n            // from: FGH....ABCDE\n            // to:   ...ABCDEFGH.\n            unsafe {\n                self.copy(head, tail, head_len);\n                // FGHABCDE....\n                self.copy_nonoverlapping(0, tail + head_len, tail_len);\n                // ...ABCDEFGH.\n            }\n\n            self.head = tail;\n        } else {\n            // `free` is smaller than both `head_len` and `tail_len`.\n            // the general algorithm for this first moves the slices\n            // right next to each other and then uses `slice::rotate`\n            // to rotate them into place:\n            //\n            // initially:   HIJK..ABCDEFG\n            // step 1:      ..HIJKABCDEFG\n            // step 2:      ..ABCDEFGHIJK\n            //\n            // or:\n            //\n            // initially:   FGHIJK..ABCDE\n            // step 1:      FGHIJKABCDE..\n            // step 2:      ABCDEFGHIJK..\n\n            // pick the shorter of the 2 slices to reduce the amount\n            // of memory that needs to be moved around.\n            if head_len > tail_len {\n                // tail is shorter, so:\n                //  1. copy tail forwards\n                //  2. rotate used part of the buffer\n                //  3. update head to point to the new beginning (which is just `free`)\n\n                unsafe {\n                    // if there is no free space in the buffer, then the slices are already\n                    // right next to each other and we don't need to move any memory.\n                    if free != 0 {\n                        // because we only move the tail forward as much as there's free space\n                        // behind it, we don't overwrite any elements of the head slice, and\n                        // the slices end up right next to each other.\n                        self.copy(0, free, tail_len);\n                    }\n\n                    // We just copied the tail right next to the head slice,\n                    // so all of the elements in the range are initialized\n                    let slice = &mut *self.buffer_range(free..self.capacity());\n\n                    // because the deque wasn't contiguous, we know that `tail_len < self.len == slice.len()`,\n                    // so this will never panic.\n                    slice.rotate_left(tail_len);\n\n                    // the used part of the buffer now is `free..self.capacity()`, so set\n                    // `head` to the beginning of that range.\n                    self.head = free;\n                }\n            } else {\n                // head is shorter so:\n                //  1. copy head backwards\n                //  2. rotate used part of the buffer\n                //  3. update head to point to the new beginning (which is the beginning of the buffer)\n\n                unsafe {\n                    // if there is no free space in the buffer, then the slices are already\n                    // right next to each other and we don't need to move any memory.\n                    if free != 0 {\n                        // copy the head slice to lie right behind the tail slice.\n                        self.copy(self.head, tail_len, head_len);\n                    }\n\n                    // because we copied the head slice so that both slices lie right\n                    // next to each other, all the elements in the range are initialized.\n                    let slice = &mut *self.buffer_range(0..self.len);\n\n                    // because the deque wasn't contiguous, we know that `head_len < self.len == slice.len()`\n                    // so this will never panic.\n                    slice.rotate_right(head_len);\n\n                    // the used part of the buffer now is `0..self.len`, so set\n                    // `head` to the beginning of that range.\n                    self.head = 0;\n                }\n            }\n        }\n\n        unsafe { slice::from_raw_parts_mut(ptr.add(self.head), self.len) }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::make_contiguous(_1: &mut collections::vec_deque::VecDeque<T, A>) -> &mut [T] {\n    let mut _0: &mut [T];\n    let mut _2: bool;\n    let mut _3: &collections::vec_deque::VecDeque<T, A>;\n    let mut _4: &mut [T];\n    let mut _5: *mut T;\n    let mut _6: *mut T;\n    let mut _7: &collections::vec_deque::VecDeque<T, A>;\n    let mut _8: usize;\n    let mut _9: usize;\n    let  _10: usize;\n    let  _11: usize;\n    let  _12: *mut T;\n    let mut _13: &collections::vec_deque::VecDeque<T, A>;\n    let  _14: usize;\n    let mut _15: &collections::vec_deque::VecDeque<T, A>;\n    let  _16: usize;\n    let mut _17: (usize, bool);\n    let  _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: bool;\n    let  _23: ();\n    let  _24: ();\n    let mut _25: bool;\n    let  _26: ();\n    let  _27: ();\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let mut _30: bool;\n    let  _31: ();\n    let  _32: &mut [T];\n    let mut _33: *mut [T];\n    let mut _34: &collections::vec_deque::VecDeque<T, A>;\n    let mut _35: core::ops::Range<usize>;\n    let mut _36: usize;\n    let mut _37: &collections::vec_deque::VecDeque<T, A>;\n    let  _38: ();\n    let  _39: ();\n    let mut _40: usize;\n    let  _41: &mut [T];\n    let mut _42: *mut [T];\n    let mut _43: &collections::vec_deque::VecDeque<T, A>;\n    let mut _44: core::ops::Range<usize>;\n    let mut _45: usize;\n    let  _46: ();\n    let mut _47: &mut [T];\n    let mut _48: *mut T;\n    let mut _49: usize;\n    let mut _50: usize;\n    debug self => _1;\n    debug head => _10;\n    debug len => _11;\n    debug ptr => _12;\n    debug cap => _14;\n    debug free => _16;\n    debug head_len => _18;\n    debug tail => _20;\n    debug tail_len => _20;\n    debug slice => _32;\n    debug slice => _41;\n    bb0: {\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &(*_1);\n        _2 = collections::vec_deque::VecDeque::<T, A>::is_contiguous(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _2) -> [0: bb8, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = collections::vec_deque::VecDeque::<T, A>::ptr(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = ((*_1).0: usize);\n        _5 = core::ptr::mut_ptr::<impl *mut T>::add(move _6, move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_9);\n        _9 = ((*_1).1: usize);\n        _4 = core::slice::from_raw_parts_mut::<'_, T>(move _5, move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _0 = _4;\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_2);\n        goto -> bb43;\n    }\n    bb8: {\n        StorageDead(_3);\n        StorageDead(_2);\n        _10 = ((*_1).0: usize);\n        _11 = ((*_1).1: usize);\n        StorageLive(_13);\n        _13 = &(*_1);\n        _12 = collections::vec_deque::VecDeque::<T, A>::ptr(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = collections::vec_deque::VecDeque::<T, A>::capacity(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        _17 = CheckedSub(_14, _11);\n        assert(!move (_17.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _14, _11) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _16 = move (_17.0: usize);\n        _19 = CheckedSub(_14, _10);\n        assert(!move (_19.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _14, _10) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = move (_19.0: usize);\n        _21 = CheckedSub(_11, _18);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _11, _18) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_21.0: usize);\n        StorageLive(_22);\n        _22 = Ge(_16, _18);\n        switchInt(move _22) -> [0: bb17, otherwise: bb14];\n    }\n    bb14: {\n        _23 = collections::vec_deque::VecDeque::<T, A>::copy(_1, 0_usize, _18, _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _24 = collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1, _10, 0_usize, _18) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb40;\n    }\n    bb17: {\n        StorageLive(_25);\n        _25 = Ge(_16, _20);\n        switchInt(move _25) -> [0: bb22, otherwise: bb18];\n    }\n    bb18: {\n        _26 = collections::vec_deque::VecDeque::<T, A>::copy(_1, _10, _20, _18) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_28);\n        _29 = CheckedAdd(_20, _18);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _20, _18) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _28 = move (_29.0: usize);\n        _27 = collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1, 0_usize, move _28, _20) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_28);\n        ((*_1).0: usize) = _20;\n        goto -> bb39;\n    }\n    bb22: {\n        StorageLive(_30);\n        _30 = Gt(_18, _20);\n        switchInt(move _30) -> [0: bb31, otherwise: bb23];\n    }\n    bb23: {\n        switchInt(_16) -> [0: bb26, otherwise: bb24];\n    }\n    bb24: {\n        _31 = collections::vec_deque::VecDeque::<T, A>::copy(_1, 0_usize, _16, _20) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        goto -> bb27;\n    }\n    bb26: {\n        goto -> bb27;\n    }\n    bb27: {\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &(*_1);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &(*_1);\n        _36 = collections::vec_deque::VecDeque::<T, A>::capacity(move _37) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_37);\n        _35 = Range(_16, move _36);\n        StorageDead(_36);\n        _33 = collections::vec_deque::VecDeque::<T, A>::buffer_range(move _34, move _35) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_35);\n        StorageDead(_34);\n        _32 = &mut (*_33);\n        _38 = core::slice::<impl [T]>::rotate_left(_32, _20) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        ((*_1).0: usize) = _16;\n        StorageDead(_33);\n        goto -> bb38;\n    }\n    bb31: {\n        switchInt(_16) -> [0: bb34, otherwise: bb32];\n    }\n    bb32: {\n        StorageLive(_40);\n        _40 = ((*_1).0: usize);\n        _39 = collections::vec_deque::VecDeque::<T, A>::copy(_1, move _40, _20, _18) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_40);\n        goto -> bb35;\n    }\n    bb34: {\n        goto -> bb35;\n    }\n    bb35: {\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &(*_1);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = ((*_1).1: usize);\n        _44 = Range(0_usize, move _45);\n        StorageDead(_45);\n        _42 = collections::vec_deque::VecDeque::<T, A>::buffer_range(move _43, move _44) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_44);\n        StorageDead(_43);\n        _41 = &mut (*_42);\n        _46 = core::slice::<impl [T]>::rotate_right(_41, _18) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        ((*_1).0: usize) = 0_usize;\n        StorageDead(_42);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_30);\n        goto -> bb39;\n    }\n    bb39: {\n        StorageDead(_25);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageDead(_22);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = ((*_1).0: usize);\n        _48 = core::ptr::mut_ptr::<impl *mut T>::add(_12, move _49) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_49);\n        StorageLive(_50);\n        _50 = ((*_1).1: usize);\n        _47 = core::slice::from_raw_parts_mut::<'_, T>(move _48, move _50) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_50);\n        StorageDead(_48);\n        _0 = _47;\n        goto -> bb43;\n    }\n    bb43: {\n        return;\n    }\n}\n",
  "doc": " Rearranges the internal storage of this deque so it is one contiguous\n slice, which is then returned.\n\n This method does not allocate and does not change the order of the\n inserted elements. As it returns a mutable slice, this can be used to\n sort a deque.\n\n Once the internal storage is contiguous, the [`as_slices`] and\n [`as_mut_slices`] methods will return the entire contents of the\n deque in a single slice.\n\n [`as_slices`]: VecDeque::as_slices\n [`as_mut_slices`]: VecDeque::as_mut_slices\n\n # Examples\n\n Sorting the content of a deque.\n\n ```\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::with_capacity(15);\n\n buf.push_back(2);\n buf.push_back(1);\n buf.push_front(3);\n\n // sorting the deque\n buf.make_contiguous().sort();\n assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n\n // sorting it in reverse order\n buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n ```\n\n Getting immutable access to the contiguous slice.\n\n ```rust\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::new();\n\n buf.push_back(2);\n buf.push_back(1);\n buf.push_front(3);\n\n buf.make_contiguous();\n if let (slice, &[]) = buf.as_slices() {\n     // we can now be sure that `slice` contains all elements of the deque,\n     // while still having immutable access to `buf`.\n     assert_eq!(buf.len(), slice.len());\n     assert_eq!(slice, &[3, 2, 1] as &[_]);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}