{
  "name": "collections::btree::map::entry::OccupiedEntry::<'a, K, V, A>::remove_kv",
  "safe": true,
  "callees": {
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::remove_kv_tracking": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key-value pair from the tree, and returns that pair, as well as\n the leaf edge corresponding to that former pair. It's possible this empties\n a root node that is internal, which the caller should pop from the map\n holding the tree. The caller should also decrement the map's length.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::borrow::DormantMutRef::<'a, T>::awaken": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Revert to the unique borrow initially captured.\n\n # Safety\n\n The reborrow must have ended, i.e., the reference returned by `new` and\n all pointers and references derived from it, must not be used anymore.\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the internal root node, using its first child as the new root node.\n As it is intended only to be called when the root node has only one child,\n no cleanup is done on any of the keys, values and other children.\n This decreases the height by 1 and is the opposite of `push_internal_level`.\n\n Does not invalidate any handles or references pointing into the subtree\n rooted at the first child of `self`.\n\n Panics if there is no internal level, i.e., if the root node is a leaf.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::node::Handle": [
      "Plain",
      "Unknown([Field(0, Ty { id: 2767, kind: RigidTy(Tuple([Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }])) })])"
    ],
    "collections::btree::map::entry::OccupiedEntry": [
      "Unknown([Field(0, Ty { id: 2554, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 2326, kind: Param(ParamTy { index: 3, name: \"A\" }) })])",
      "Unknown([Field(1, Ty { id: 2720, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2741, kind: RigidTy(Adt(AdtDef(DefId { id: 3598, name: \"collections::btree::map::BTreeMap\" }), GenericArgs([Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2326, kind: Param(ParamTy { index: 3, name: \"A\" }) })]))) })]))) })])",
      "Plain"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "Plain"
    ],
    "collections::btree::map::BTreeMap": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::entry::OccupiedEntry::<'a, K, V, A>::remove_kv"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:606:5: 618:6",
  "src": "pub(super) fn remove_kv(self) -> (K, V) {\n        let mut emptied_internal_root = false;\n        let (old_kv, _) =\n            self.handle.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n        let map = unsafe { self.dormant_map.awaken() };\n        map.length -= 1;\n        if emptied_internal_root {\n            let root = map.root.as_mut().unwrap();\n            root.pop_internal_level(self.alloc);\n        }\n        old_kv\n    }",
  "mir": "fn collections::btree::map::entry::OccupiedEntry::<'a, K, V, A>::remove_kv(_1: collections::btree::map::entry::OccupiedEntry<'_, K, V, A>) -> (K, V) {\n    let mut _0: (K, V);\n    let mut _2: bool;\n    let mut _3: ((K, V), collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n    let mut _4: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _5: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:609:44: 609:46};\n    let mut _6: &mut bool;\n    let mut _7: A;\n    let mut _8: &A;\n    let mut _9: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let mut _10: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _11: (usize, bool);\n    let mut _12: bool;\n    let  _13: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _14: core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _15: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let  _16: ();\n    let mut _17: A;\n    let mut _18: bool;\n    debug self => _1;\n    debug emptied_internal_root => _2;\n    debug old_kv => _0;\n    debug map => _9;\n    debug root => _13;\n    bb0: {\n        _18 = false;\n        _18 = true;\n        StorageLive(_2);\n        _2 = false;\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = move (_1.0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut _2;\n        _5 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:609:44: 609:46}(move _6);\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(_1.2: A);\n        _7 = <A as core::clone::Clone>::clone(move _8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_8);\n        _3 = collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::remove_kv_tracking::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:609:44: 609:46}, A>(move _4, move _5, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = move (_3.0: (K, V));\n        StorageDead(_3);\n        StorageLive(_10);\n        _10 = move (_1.1: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        _9 = collections::btree::borrow::DormantMutRef::<'_, collections::btree::map::BTreeMap<K, V, A>>::awaken(move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_10);\n        _11 = CheckedSub(((*_9).1: usize), 1_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_9).1: usize), 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        ((*_9).1: usize) = move (_11.0: usize);\n        StorageLive(_12);\n        _12 = _2;\n        switchInt(move _12) -> [0: bb9, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut ((*_9).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _14 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::as_mut(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _13 = core::option::Option::<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::unwrap(move _14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageLive(_17);\n        _18 = false;\n        _17 = move (_1.2: A);\n        _16 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level::<A>(_13, move _17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_2);\n        switchInt(_18) -> [0: bb10, otherwise: bb11];\n    }\n    bb10: {\n        return;\n    }\n    bb11: {\n        drop((_1.2: A)) -> [return: bb10, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}