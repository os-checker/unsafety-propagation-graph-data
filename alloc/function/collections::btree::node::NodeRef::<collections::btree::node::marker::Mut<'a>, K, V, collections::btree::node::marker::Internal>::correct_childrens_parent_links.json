{
  "name": "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links",
  "safe": false,
  "callees": {
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::new_edge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to an edge in `node`.\n Unsafe because the caller must ensure that `idx <= node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::correct_parent_link": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fixes the parent pointer and index in the child node that this edge\n links to. This is useful when the ordering of edges has been changed,\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "collections::btree::node::NodeRef": [
      "Ref",
      "Deref",
      "MutRef",
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ]
  },
  "path": 946,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:557:5: 562:6",
  "src": "unsafe fn correct_childrens_parent_links<R: Iterator<Item = usize>>(&mut self, range: R) {\n        for i in range {\n            debug_assert!(i <= self.len());\n            unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();\n        }\n    }",
  "mir": "fn collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::correct_childrens_parent_links(_1: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, _2: R) -> () {\n    let mut _0: ();\n    let mut _3: R;\n    let mut _4: R;\n    let mut _5: core::option::Option<usize>;\n    let mut _6: &mut R;\n    let mut _7: isize;\n    let  _8: usize;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _12: !;\n    let  _13: ();\n    let mut _14: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let mut _15: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    debug self => _1;\n    debug range => _2;\n    debug iter => _4;\n    debug i => _8;\n    bb0: {\n        StorageLive(_3);\n        _3 = <R as core::iter::IntoIterator>::into_iter(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = move _3;\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_5);\n        _6 = &mut _4;\n        _5 = <R as core::iter::Iterator>::next(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb6, 1: bb5, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _8 = ((_5 as variant#1).0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(*_1);\n        _10 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::len(move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        drop(_4) -> [return: bb13, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _9 = Le(_8, move _10);\n        switchInt(move _9) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::reborrow_mut(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        _12 = core::panicking::panic(\"assertion failed: i <= self.len()\") -> unwind unreachable;\n    }\n    bb10: {\n        _14 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::new_edge(move _15, _8) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _13 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::correct_parent_link(move _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageDead(_5);\n        goto -> bb2;\n    }\n    bb13: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " # Safety\n Every item returned by `range` is a valid edge index for the node.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}