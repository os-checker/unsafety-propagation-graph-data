{
  "name": "collections::btree::set::BTreeSet::<T, A>::remove",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "MutRef"
    ],
    "collections::btree::set::BTreeSet": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": 1071,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:1051:5: 1057:6",
  "src": "pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        self.map.remove(value).is_some()\n    }",
  "mir": "fn collections::btree::set::BTreeSet::<T, A>::remove(_1: &mut collections::btree::set::BTreeSet<T, A>, _2: &Q) -> bool {\n    let mut _0: bool;\n    let mut _3: &core::option::Option<collections::btree::set_val::SetValZST>;\n    let  _4: core::option::Option<collections::btree::set_val::SetValZST>;\n    let mut _5: &mut collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>;\n    debug self => _1;\n    debug value => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>);\n        _4 = collections::btree::map::BTreeMap::<T, collections::btree::set_val::SetValZST, A>::remove::<Q>(move _5, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &_4;\n        StorageDead(_5);\n        _0 = core::option::Option::<collections::btree::set_val::SetValZST>::is_some(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " If the set contains an element equal to the value, removes it from the\n set and drops it. Returns whether such an element was present.\n\n The value may be any borrowed form of the set's element type,\n but the ordering on the borrowed form *must* match the\n ordering on the element type.\n\n # Examples\n\n ```\n use std::collections::BTreeSet;\n\n let mut set = BTreeSet::new();\n\n set.insert(2);\n assert_eq!(set.remove(&2), true);\n assert_eq!(set.remove(&2), false);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}