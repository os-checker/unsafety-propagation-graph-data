{
  "name": "collections::btree::set::BTreeSet::<T, A>::take",
  "safe": true,
  "callees": {
    "collections::btree::map::BTreeMap::<K, V, A>::remove_entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the stored key and value if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n assert_eq!(map.remove_entry(&1), None);\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "MutRef"
    ],
    "collections::btree::set::BTreeSet": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 1076,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:1076:5: 1082:6",
  "src": "pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n    where\n        T: Borrow<Q> + Ord,\n        Q: Ord,\n    {\n        self.map.remove_entry(value).map(|(k, _)| k)\n    }",
  "mir": "fn collections::btree::set::BTreeSet::<T, A>::take(_1: &mut collections::btree::set::BTreeSet<T, A>, _2: &Q) -> core::option::Option<T> {\n    let mut _0: core::option::Option<T>;\n    let mut _3: core::option::Option<(T, collections::btree::set_val::SetValZST)>;\n    let mut _4: &mut collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>;\n    debug self => _1;\n    debug value => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: collections::btree::map::BTreeMap<T, collections::btree::set_val::SetValZST, A>);\n        _3 = collections::btree::map::BTreeMap::<T, collections::btree::set_val::SetValZST, A>::remove_entry::<Q>(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = core::option::Option::<(T, collections::btree::set_val::SetValZST)>::map::<T, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:1081:42: 1081:50}>(move _3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:1081:42: 1081:50}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Removes and returns the element in the set, if any, that is equal to\n the value.\n\n The value may be any borrowed form of the set's element type,\n but the ordering on the borrowed form *must* match the\n ordering on the element type.\n\n # Examples\n\n ```\n use std::collections::BTreeSet;\n\n let mut set = BTreeSet::from([1, 2, 3]);\n assert_eq!(set.take(&2), Some(2));\n assert_eq!(set.take(&2), None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}