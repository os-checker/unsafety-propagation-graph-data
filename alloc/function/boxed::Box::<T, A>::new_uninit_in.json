{
  "name": "boxed::Box::<T, A>::new_uninit_in",
  "safe": true,
  "callees": {
    "core::alloc::Layout::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a `Layout` suitable for holding a value of type `T`.\n",
      "adt": {}
    },
    "boxed::Box::<T, A>::try_new_uninit_in": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new box with uninitialized contents in the provided allocator,\n returning an error if the allocation fails\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let mut five = Box::<u32, _>::try_new_uninit_in(System)?;\n // Deferred initialization:\n five.write(5);\n let five = unsafe { five.assume_init() };\n\n assert_eq!(*five, 5);\n # Ok::<(), std::alloc::AllocError>(())\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "boxed::Box": "Constructor"
      }
    },
    "alloc::handle_alloc_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Signals a memory allocation error.\n\n Callers of memory allocation APIs wishing to cease execution\n in response to an allocation error are encouraged to call this function,\n rather than directly invoking [`panic!`] or similar.\n\n This function is guaranteed to diverge (not return normally with a value), but depending on\n global configuration, it may either panic (resulting in unwinding or aborting as per\n configuration for all panics), or abort the process (with no unwinding).\n\n The default behavior is:\n\n  * If the binary links against `std` (typically the case), then\n   print a message to standard error and abort the process.\n   This behavior can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n   Future versions of Rust may panic by default instead.\n\n * If the binary does not link against `std` (all of its crates are marked\n   [`#![no_std]`][no_std]), then call [`panic!`] with a message.\n   [The panic handler] applies as to any panic.\n\n [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n [The panic handler]: https://doc.rust-lang.org/reference/runtime.html#the-panic_handler-attribute\n [no_std]: https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1073, kind: RigidTy(Adt(AdtDef(DefId { id: 2609, name: \"boxed::Box\" }), GenericArgs([Type(Ty { id: 73, kind: RigidTy(Adt(AdtDef(DefId { id: 2984, name: \"core::mem::MaybeUninit\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) }), Type(Ty { id: 21, kind: Param(ParamTy { index: 1, name: \"A\" }) })]))) })])"
    ],
    "boxed::Box": [
      "Plain"
    ]
  },
  "path": 377,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:542:5: 553:6",
  "src": "pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>\n    where\n        A: Allocator,\n    {\n        let layout = Layout::new::<mem::MaybeUninit<T>>();\n        // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n        // That would make code size bigger.\n        match Box::try_new_uninit_in(alloc) {\n            Ok(m) => m,\n            Err(_) => handle_alloc_error(layout),\n        }\n    }",
  "mir": "fn boxed::Box::<T, A>::new_uninit_in(_1: A) -> boxed::Box<core::mem::MaybeUninit<T>, A> {\n    let mut _0: boxed::Box<core::mem::MaybeUninit<T>, A>;\n    let  _2: core::alloc::Layout;\n    let mut _3: core::result::Result<boxed::Box<core::mem::MaybeUninit<T>, A>, core::alloc::AllocError>;\n    let mut _4: isize;\n    let mut _5: !;\n    debug alloc => _1;\n    debug layout => _2;\n    debug m => _0;\n    bb0: {\n        _2 = core::alloc::Layout::new::<core::mem::MaybeUninit<T>>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = boxed::Box::<T, A>::try_new_uninit_in(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = discriminant(_3);\n        switchInt(move _4) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _5 = alloc::handle_alloc_error(_2) -> unwind unreachable;\n    }\n    bb5: {\n        _0 = move ((_3 as variant#0).0: boxed::Box<core::mem::MaybeUninit<T>, A>);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Constructs a new box with uninitialized contents in the provided allocator.\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let mut five = Box::<u32, _>::new_uninit_in(System);\n // Deferred initialization:\n five.write(5);\n let five = unsafe { five.assume_init() };\n\n assert_eq!(*five, 5)\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}