{
  "name": "collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, HandleType>::reborrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another immutable handle on the same location.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::next_kv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n on the right side, which is either in the same leaf node or in an ancestor node.\n If the leaf edge is the last one in the tree, returns [`Result::Err`] with the root node.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "core::result::Result": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::result::Result::<T, E>::is_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Err`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_err(), false);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_err(), true);\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::remove_kv_tracking": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key-value pair from the tree, and returns that pair, as well as\n the leaf edge corresponding to that former pair. It's possible this empties\n a root node that is internal, which the caller should pop from the map\n holding the tree. The caller should also decrement the map's length.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows a new mutable reference from the unique borrow initially captured.\n\n # Safety\n\n The reborrow must have ended, i.e., the reference returned by `new` and\n all pointers and references derived from it, must not be used anymore.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "MutableAsArgument"
      }
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the internal root node, using its first child as the new root node.\n As it is intended only to be called when the root node has only one child,\n no cleanup is done on any of the keys, values and other children.\n This decreases the height by 1 and is the opposite of `push_internal_level`.\n\n Does not invalidate any handles or references pointing into the subtree\n rooted at the first child of `self`.\n\n Panics if there is no internal level, i.e., if the root node is a leaf.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::map::CursorMutKey": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2554, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::node::Handle": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 2767, kind: RigidTy(Tuple([Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }])) })])",
      "Unknown([Field(1, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Ref"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3415:5: 3437:6",
  "src": "pub fn remove_next(&mut self) -> Option<(K, V)> {\n        let current = self.current.take()?;\n        if current.reborrow().next_kv().is_err() {\n            self.current = Some(current);\n            return None;\n        }\n        let mut emptied_internal_root = false;\n        let (kv, pos) = current\n            .next_kv()\n            // This should be unwrap(), but that doesn't work because NodeRef\n            // doesn't implement Debug. The condition is checked above.\n            .ok()?\n            .remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());\n        self.current = Some(pos);\n        *self.length -= 1;\n        if emptied_internal_root {\n            // SAFETY: This is safe since current does not point within the now\n            // empty root node.\n            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n            root.pop_internal_level(self.alloc.clone());\n        }\n        Some(kv)\n    }",
  "mir": "fn collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next(_1: &mut collections::btree::map::CursorMutKey<'_, K, V, A>) -> core::option::Option<(K, V)> {\n    let mut _0: core::option::Option<(K, V)>;\n    let  _2: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _4: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _5: &mut core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _6: isize;\n    let  _7: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _8: bool;\n    let mut _9: &core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>, collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let  _10: core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>, collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _11: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _12: &collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _13: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _14: bool;\n    let  _15: (K, V);\n    let  _16: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _17: ((K, V), collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n    let mut _18: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>;\n    let mut _19: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>;\n    let mut _20: core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _21: isize;\n    let  _22: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _23: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3427:33: 3427:35};\n    let mut _24: &mut bool;\n    let mut _25: A;\n    let mut _26: &A;\n    let mut _27: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _28: (usize, bool);\n    let mut _29: bool;\n    let mut _30: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _31: core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _32: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _33: &mut collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let  _34: ();\n    let mut _35: A;\n    let mut _36: &A;\n    let mut _37: &mut A;\n    let mut _38: &mut usize;\n    let mut _39: &mut usize;\n    let mut _40: &mut usize;\n    let mut _41: &mut A;\n    debug self => _1;\n    debug current => _2;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _7;\n    debug emptied_internal_root => _14;\n    debug kv => _15;\n    debug pos => _16;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _22;\n    debug root => _30;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>);\n        _4 = core::option::Option::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::take(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = <core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = move ((_3 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        _2 = move _7;\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_2;\n        _11 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::reborrow(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::option::Option<(K, V)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        goto -> bb28;\n    }\n    bb7: {\n        StorageDead(_12);\n        _10 = collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::next_kv(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _9 = &_10;\n        StorageDead(_11);\n        _8 = core::result::Result::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>, collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::is_err(move _9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _8) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_13);\n        _13 = core::option::Option::Some(_2);\n        ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _13;\n        StorageDead(_13);\n        _0 = core::option::Option::None;\n        StorageDead(_8);\n        goto -> bb28;\n    }\n    bb11: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_14);\n        _14 = false;\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::next_kv(_2) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _19 = core::result::Result::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::ok(move _20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_20);\n        _18 = <core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>> as core::ops::Try>::branch(move _19) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_19);\n        _21 = discriminant(_18);\n        switchInt(move _21) -> [0: bb15, 1: bb16, otherwise: bb3];\n    }\n    bb15: {\n        _22 = move ((_18 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &mut _14;\n        _23 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3427:33: 3427:35}(move _24);\n        StorageDead(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _37 = ((*_1).3: &mut A);\n        _26 = &(*_37);\n        _25 = <A as core::clone::Clone>::clone(move _26) -> [return: bb18, unwind unreachable];\n    }\n    bb16: {\n        _0 = <core::option::Option<(K, V)> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_14);\n        goto -> bb28;\n    }\n    bb18: {\n        StorageDead(_26);\n        _17 = collections::btree::remove::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>>::remove_kv_tracking::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3427:33: 3427:35}, A>(_22, move _23, move _25) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_25);\n        StorageDead(_23);\n        _15 = move (_17.0: (K, V));\n        _16 = move (_17.1: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_27);\n        _27 = core::option::Option::Some(_16);\n        ((*_1).0: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) = move _27;\n        StorageDead(_27);\n        _38 = ((*_1).2: &mut usize);\n        _28 = CheckedSub((*_38), 1_usize);\n        _39 = ((*_1).2: &mut usize);\n        assert(!move (_28.1: bool), \"attempt to compute `{} - {}`, which would overflow\", (*_39), 1_usize) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _40 = ((*_1).2: &mut usize);\n        (*_40) = move (_28.0: usize);\n        StorageLive(_29);\n        _29 = _14;\n        switchInt(move _29) -> [0: bb27, otherwise: bb21];\n    }\n    bb21: {\n        StorageLive(_31);\n        StorageLive(_33);\n        _33 = &mut ((*_1).1: collections::btree::borrow::DormantMutRef<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>);\n        _32 = collections::btree::borrow::DormantMutRef::<'_, core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>::reborrow(move _33) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_33);\n        _31 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::as_mut(_32) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _30 = core::option::Option::<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::unwrap(move _31) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_31);\n        StorageLive(_35);\n        StorageLive(_36);\n        _41 = ((*_1).3: &mut A);\n        _36 = &(*_41);\n        _35 = <A as core::clone::Clone>::clone(move _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        _34 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level::<A>(_30, move _35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_29);\n        _0 = core::option::Option::Some(_15);\n        StorageDead(_14);\n        goto -> bb29;\n    }\n    bb28: {\n        goto -> bb29;\n    }\n    bb29: {\n        return;\n    }\n}\n",
  "doc": " Removes the next element from the `BTreeMap`.\n\n The element that was removed is returned. The cursor position is\n unchanged (before the removed element).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}