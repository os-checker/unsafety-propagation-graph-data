{
  "name": "collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_top",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::height": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of levels that the node and leaves are apart. Zero\n height means the node is a leaf itself. If you picture trees with the\n root on top, the number says at which elevation the node appears.\n If you picture trees with leaves on top, the number says how high\n the tree extends above the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the internal root node, using its first child as the new root node.\n As it is intended only to be called when the root node has only one child,\n no cleanup is done on any of the keys, values and other children.\n This decreases the height by 1 and is the opposite of `push_internal_level`.\n\n Does not invalidate any handles or references pointing into the subtree\n rooted at the first child of `self`.\n\n Panics if there is no internal level, i.e., if the root node is a leaf.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Ref",
      "Deref",
      "MutRef"
    ]
  },
  "path": 965,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/fix.rs:76:5: 80:6",
  "src": "pub(super) fn fix_top<A: Allocator + Clone>(&mut self, alloc: A) {\n        while self.height() > 0 && self.len() == 0 {\n            self.pop_internal_level(alloc.clone());\n        }\n    }",
  "mir": "fn collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_top(_1: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, _2: A) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _6: usize;\n    let mut _7: &collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _8: ();\n    let mut _9: A;\n    let mut _10: &A;\n    debug self => _1;\n    debug alloc => _2;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::height(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = Gt(move _4, 0_usize);\n        switchInt(move _3) -> [0: bb9, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        switchInt(move _6) -> [0: bb5, otherwise: bb8];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        _9 = <A as core::clone::Clone>::clone(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _8 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level::<A>(_1, move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageDead(_3);\n        goto -> bb1;\n    }\n    bb8: {\n        StorageDead(_6);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}