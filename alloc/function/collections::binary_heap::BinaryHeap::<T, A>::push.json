{
  "name": "collections::binary_heap::BinaryHeap::<T, A>::push",
  "safe": true,
  "callees": {
    "collections::binary_heap::BinaryHeap::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of the binary heap.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::collections::BinaryHeap;\n let heap = BinaryHeap::from([1, 3]);\n\n assert_eq!(heap.len(), 2);\n ```\n",
      "adt": {
        "collections::binary_heap::BinaryHeap": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "collections::binary_heap::BinaryHeap::<T, A>::sift_up": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller must guarantee that `pos < self.len()`.\n\n Returns the new position of the element.\n",
      "adt": {
        "collections::binary_heap::BinaryHeap": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::binary_heap::BinaryHeap": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "vec::Vec": [
      "MutRef"
    ]
  },
  "path": 461,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/binary_heap/mod.rs:684:5: 690:6",
  "src": "pub fn push(&mut self, item: T) {\n        let old_len = self.len();\n        self.data.push(item);\n        // SAFETY: Since we pushed a new item it means that\n        //  old_len = self.len() - 1 < self.len()\n        unsafe { self.sift_up(0, old_len) };\n    }",
  "mir": "fn collections::binary_heap::BinaryHeap::<T, A>::push(_1: &mut collections::binary_heap::BinaryHeap<T, A>, _2: T) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &collections::binary_heap::BinaryHeap<T, A>;\n    let  _5: ();\n    let mut _6: &mut vec::Vec<T, A>;\n    let  _7: usize;\n    debug self => _1;\n    debug item => _2;\n    debug old_len => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = collections::binary_heap::BinaryHeap::<T, A>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = &mut ((*_1).0: vec::Vec<T, A>);\n        _5 = vec::Vec::<T, A>::push(move _6, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = collections::binary_heap::BinaryHeap::<T, A>::sift_up(_1, 0_usize, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": " Pushes an item onto the binary heap.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::collections::BinaryHeap;\n let mut heap = BinaryHeap::new();\n heap.push(3);\n heap.push(5);\n heap.push(1);\n\n assert_eq!(heap.len(), 3);\n assert_eq!(heap.peek(), Some(&5));\n ```\n\n # Time complexity\n\n The expected cost of `push`, averaged over every possible ordering of\n the elements being pushed, and over a sufficiently large number of\n pushes, is *O*(1). This is the most meaningful cost metric when pushing\n elements that are *not* already in any sorted pattern.\n\n The time complexity degrades if elements are pushed in predominantly\n ascending order. In the worst case, elements are pushed in ascending\n sorted order and the amortized cost per push is *O*(log(*n*)) against a heap\n containing *n* elements.\n\n The worst case cost of a *single* call to `push` is *O*(*n*). The worst case\n occurs when capacity is exhausted and needs a resize. The resize cost\n has been amortized in the previous figures.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}