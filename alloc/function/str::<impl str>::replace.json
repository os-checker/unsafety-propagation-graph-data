{
  "name": "str::<impl str>::replace",
  "safe": true,
  "callees": {
    "core::str::pattern::Pattern::as_utf8_pattern": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the pattern as utf-8 bytes if possible.\n",
      "adt": {}
    },
    "core::char::methods::<impl char>::as_ascii": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `Some` if the value is within the ASCII range,\n or `None` if it's not.\n\n This is preferred to [`Self::is_ascii`] when you're passing the value\n along to something else that can take [`ascii::Char`] rather than\n needing to check again for itself whether the value is in ASCII.\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "str::replace_ascii": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": " Faster implementation of string replacement for ASCII to ASCII cases.\n Should produce fast vectorized code.\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "core::char::methods::<impl char>::len_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes this `char` would need if encoded in UTF-8.\n\n That number of bytes is always between 1 and 4, inclusive.\n\n # Examples\n\n Basic usage:\n\n ```\n let len = 'A'.len_utf8();\n assert_eq!(len, 1);\n\n let len = '√ü'.len_utf8();\n assert_eq!(len, 2);\n\n let len = '‚Ñù'.len_utf8();\n assert_eq!(len, 3);\n\n let len = 'üí£'.len_utf8();\n assert_eq!(len, 4);\n ```\n\n The `&str` type guarantees that its contents are UTF-8, and so we can compare the length it\n would take if each code point was represented as a `char` vs in the `&str` itself:\n\n ```\n // as chars\n let eastern = 'Êù±';\n let capital = '‰∫¨';\n\n // both can be represented as three bytes\n assert_eq!(3, eastern.len_utf8());\n assert_eq!(3, capital.len_utf8());\n\n // as a &str, these two are encoded in UTF-8\n let tokyo = \"Êù±‰∫¨\";\n\n let len = eastern.len_utf8() + capital.len_utf8();\n\n // we can see that they take six bytes total...\n assert_eq!(6, tokyo.len());\n\n // ... just like the &str\n assert_eq!(len, tokyo.len());\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"∆íoo\".len(), 4); // fancy f!\n assert_eq!(\"∆íoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "string::String::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String` with at least the specified capacity.\n\n `String`s have an internal buffer to hold their data. The capacity is\n the length of that buffer, and can be queried with the [`capacity`]\n method. This method creates an empty `String`, but one with an initial\n buffer that can hold at least `capacity` bytes. This is useful when you\n may be appending a bunch of data to the `String`, reducing the number of\n reallocations it needs to do.\n\n [`capacity`]: String::capacity\n\n If the given capacity is `0`, no allocation will occur, and this method\n is identical to the [`new`] method.\n\n [`new`]: String::new\n\n # Panics\n\n Panics if the capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::with_capacity(10);\n\n // The String contains no chars, even though it has capacity for more\n assert_eq!(s.len(), 0);\n\n // These are all done without reallocating...\n let cap = s.capacity();\n for _ in 0..10 {\n     s.push('a');\n }\n\n assert_eq!(s.capacity(), cap);\n\n // ...but this may make the string reallocate\n s.push('a');\n ```\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "core::str::<impl str>::match_indices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the disjoint matches of a pattern within this string\n slice as well as the index that the match starts at.\n\n For matches of `pat` within `self` that overlap, only the indices\n corresponding to the first match are returned.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Iterator behavior\n\n The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n allows a reverse search and forward/reverse search yields the same\n elements. This is true for, e.g., [`char`], but not for `&str`.\n\n If the pattern allows a reverse search but its results might differ\n from a forward search, the [`rmatch_indices`] method can be used.\n\n [`rmatch_indices`]: str::rmatch_indices\n\n # Examples\n\n ```\n let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\n let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\n let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unchecked subslice of `str`.\n\n This is the unchecked alternative to indexing the `str`.\n\n # Safety\n\n Callers of this function are responsible that these preconditions are\n satisfied:\n\n * The starting index must not exceed the ending index;\n * Indexes must be within bounds of the original slice;\n * Indexes must lie on UTF-8 sequence boundaries.\n\n Failing that, the returned string slice may reference invalid memory or\n violate the invariants communicated by the `str` type.\n\n # Examples\n\n ```\n let v = \"üóª‚ààüåè\";\n unsafe {\n     assert_eq!(\"üóª\", v.get_unchecked(0..4));\n     assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n     assert_eq!(\"üåè\", v.get_unchecked(7..11));\n }\n ```\n",
      "adt": {}
    },
    "string::String::push_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends a given string slice onto the end of this `String`.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::from(\"foo\");\n\n s.push_str(\"bar\");\n\n assert_eq!(\"foobar\", s);\n ```\n",
      "adt": {
        "string::String": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8565, kind: RigidTy(Adt(AdtDef(DefId { id: 5358, name: \"core::str::pattern::Utf8Pattern\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8565, kind: RigidTy(Adt(AdtDef(DefId { id: 5358, name: \"core::str::pattern::Utf8Pattern\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1308, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 195, kind: RigidTy(Slice(Ty { id: 93, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8565, kind: RigidTy(Adt(AdtDef(DefId { id: 5358, name: \"core::str::pattern::Utf8Pattern\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 904, kind: RigidTy(Char) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 93, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8575, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) }])) }), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8575, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) }])) }), Field(1, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) })])"
    ],
    "string::String": [
      "Plain",
      "MutRef"
    ],
    "core::str::MatchIndices": [
      "Plain",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::str::<impl str>::replace"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:268:5: 294:6",
  "src": "pub fn replace<P: Pattern>(&self, from: P, to: &str) -> String {\n        // Fast path for replacing a single ASCII character with another.\n        if let Some(from_byte) = match from.as_utf8_pattern() {\n            Some(Utf8Pattern::StringPattern([from_byte])) => Some(*from_byte),\n            Some(Utf8Pattern::CharPattern(c)) => c.as_ascii().map(|ascii_char| ascii_char.to_u8()),\n            _ => None,\n        } {\n            if let [to_byte] = to.as_bytes() {\n                return unsafe { replace_ascii(self.as_bytes(), from_byte, *to_byte) };\n            }\n        }\n        // Set result capacity to self.len() when from.len() <= to.len()\n        let default_capacity = match from.as_utf8_pattern() {\n            Some(Utf8Pattern::StringPattern(s)) if s.len() <= to.len() => self.len(),\n            Some(Utf8Pattern::CharPattern(c)) if c.len_utf8() <= to.len() => self.len(),\n            _ => 0,\n        };\n        let mut result = String::with_capacity(default_capacity);\n        let mut last_end = 0;\n        for (start, part) in self.match_indices(from) {\n            result.push_str(unsafe { self.get_unchecked(last_end..start) });\n            result.push_str(to);\n            last_end = start + part.len();\n        }\n        result.push_str(unsafe { self.get_unchecked(last_end..self.len()) });\n        result\n    }",
  "mir": "fn str::<impl str>::replace(_1: &str, _2: P, _3: &str) -> string::String {\n    let mut _0: string::String;\n    let mut _4: core::option::Option<u8>;\n    let mut _5: core::option::Option<core::str::pattern::Utf8Pattern<'_>>;\n    let mut _6: &P;\n    let mut _7: *const [u8];\n    let mut _8: usize;\n    let mut _9: isize;\n    let mut _10: isize;\n    let  _11: &u8;\n    let mut _12: u8;\n    let  _13: char;\n    let mut _14: core::option::Option<core::ascii::Char>;\n    let mut _15: &char;\n    let mut _16: isize;\n    let  _17: u8;\n    let mut _18: &[u8];\n    let mut _19: usize;\n    let  _20: &u8;\n    let  _21: &[u8];\n    let mut _22: u8;\n    let  _23: usize;\n    let mut _24: core::option::Option<core::str::pattern::Utf8Pattern<'_>>;\n    let mut _25: &P;\n    let mut _26: isize;\n    let mut _27: isize;\n    let  _28: &[u8];\n    let  _29: &&[u8];\n    let mut _30: bool;\n    let mut _31: usize;\n    let mut _32: usize;\n    let  _33: char;\n    let  _34: &char;\n    let mut _35: bool;\n    let mut _36: usize;\n    let mut _37: char;\n    let mut _38: usize;\n    let mut _39: string::String;\n    let mut _40: usize;\n    let mut _41: usize;\n    let mut _42: core::str::MatchIndices<'_, P>;\n    let mut _43: core::str::MatchIndices<'_, P>;\n    let mut _44: P;\n    let mut _45: core::str::MatchIndices<'_, P>;\n    let mut _46: core::option::Option<(usize, &str)>;\n    let mut _47: &mut core::str::MatchIndices<'_, P>;\n    let mut _48: isize;\n    let  _49: usize;\n    let  _50: &str;\n    let  _51: ();\n    let mut _52: &mut string::String;\n    let  _53: &str;\n    let mut _54: core::ops::Range<usize>;\n    let mut _55: usize;\n    let  _56: ();\n    let mut _57: &mut string::String;\n    let mut _58: usize;\n    let mut _59: (usize, bool);\n    let  _60: ();\n    let mut _61: &mut string::String;\n    let  _62: &str;\n    let mut _63: core::ops::Range<usize>;\n    let mut _64: usize;\n    let mut _65: usize;\n    let mut _66: &[u8];\n    let mut _67: &[u8];\n    let mut _68: &[u8];\n    debug self => _1;\n    debug from => _2;\n    debug to => _3;\n    debug from_byte => _11;\n    debug c => _13;\n    debug from_byte => _17;\n    debug to_byte => _20;\n    debug default_capacity => _23;\n    debug s => _28;\n    debug s => _29;\n    debug c => _33;\n    debug c => _34;\n    debug result => _39;\n    debug last_end => _41;\n    debug iter => _45;\n    debug start => _49;\n    debug part => _50;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = <P as core::str::pattern::Pattern>::as_utf8_pattern(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _10 = discriminant(_5);\n        switchInt(move _10) -> [1: bb3, 0: bb2, otherwise: bb38];\n    }\n    bb2: {\n        _4 = core::option::Option::None;\n        goto -> bb9;\n    }\n    bb3: {\n        _9 = discriminant(((_5 as variant#1).0: core::str::pattern::Utf8Pattern<'_>));\n        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb38];\n    }\n    bb4: {\n        _66 = ((((_5 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#0).0: &[u8]);\n        _7 = &raw const (fake) (*_66);\n        _8 = PtrMetadata(move _7);\n        switchInt(_8) -> [1: bb6, otherwise: bb2];\n    }\n    bb5: {\n        StorageLive(_13);\n        _13 = ((((_5 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#1).0: char);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_13;\n        _14 = core::char::methods::<impl char>::as_ascii(move _15) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_11);\n        _67 = ((((_5 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#0).0: &[u8]);\n        _11 = &(*_67)[0 of 1];\n        StorageLive(_12);\n        _12 = (*_11);\n        _4 = core::option::Option::Some(move _12);\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb9;\n    }\n    bb7: {\n        StorageDead(_15);\n        _4 = core::option::Option::<core::ascii::Char>::map::<u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:272:67: 272:79}>(move _14, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:272:67: 272:79}) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb9;\n    }\n    bb9: {\n        _16 = discriminant(_4);\n        switchInt(move _16) -> [1: bb10, 0: bb16, otherwise: bb38];\n    }\n    bb10: {\n        _17 = ((_4 as variant#1).0: u8);\n        StorageLive(_18);\n        _18 = core::str::<impl str>::as_bytes(_3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _19 = PtrMetadata(_18);\n        switchInt(_19) -> [1: bb12, otherwise: bb15];\n    }\n    bb12: {\n        StorageLive(_20);\n        _20 = &(*_18)[0 of 1];\n        _21 = core::str::<impl str>::as_bytes(_1) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_22);\n        _22 = (*_20);\n        _0 = str::replace_ascii(_21, _17, move _22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_5);\n        StorageDead(_4);\n        drop(_2) -> [return: bb50, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_18);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &_2;\n        _24 = <P as core::str::pattern::Pattern>::as_utf8_pattern(move _25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_25);\n        _27 = discriminant(_24);\n        switchInt(move _27) -> [1: bb20, 0: bb19, otherwise: bb38];\n    }\n    bb19: {\n        _23 = 0_usize;\n        goto -> bb32;\n    }\n    bb20: {\n        _26 = discriminant(((_24 as variant#1).0: core::str::pattern::Utf8Pattern<'_>));\n        switchInt(move _26) -> [0: bb22, 1: bb21, otherwise: bb38];\n    }\n    bb21: {\n        StorageLive(_34);\n        _34 = &((((_24 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#1).0: char);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = (*_34);\n        _36 = core::char::methods::<impl char>::len_utf8(move _37) -> [return: bb27, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_29);\n        _29 = &((((_24 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#0).0: &[u8]);\n        StorageLive(_30);\n        StorageLive(_31);\n        _68 = (*_29);\n        _31 = PtrMetadata(_68);\n        StorageLive(_32);\n        _32 = core::str::<impl str>::len(_3) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _30 = Le(move _31, move _32);\n        switchInt(move _30) -> [0: bb25, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_28);\n        _28 = ((((_24 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#0).0: &[u8]);\n        _23 = core::str::<impl str>::len(_1) -> [return: bb26, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb19;\n    }\n    bb26: {\n        StorageDead(_28);\n        StorageDead(_29);\n        goto -> bb32;\n    }\n    bb27: {\n        StorageDead(_37);\n        StorageLive(_38);\n        _38 = core::str::<impl str>::len(_3) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _35 = Le(move _36, move _38);\n        switchInt(move _35) -> [0: bb30, otherwise: bb29];\n    }\n    bb29: {\n        StorageDead(_38);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_33);\n        _33 = ((((_24 as variant#1).0: core::str::pattern::Utf8Pattern<'_>) as variant#1).0: char);\n        _23 = core::str::<impl str>::len(_1) -> [return: bb31, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_38);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        goto -> bb19;\n    }\n    bb31: {\n        StorageDead(_33);\n        StorageDead(_34);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_24);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = _23;\n        _39 = string::String::with_capacity(move _40) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_40);\n        StorageLive(_41);\n        _41 = 0_usize;\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = move _2;\n        _43 = core::str::<impl str>::match_indices::<P>(_1, move _44) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_44);\n        _42 = <core::str::MatchIndices<'_, P> as core::iter::IntoIterator>::into_iter(move _43) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_43);\n        StorageLive(_45);\n        _45 = move _42;\n        goto -> bb36;\n    }\n    bb36: {\n        StorageLive(_46);\n        _47 = &mut _45;\n        _46 = <core::str::MatchIndices<'_, P> as core::iter::Iterator>::next(_47) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _48 = discriminant(_46);\n        switchInt(move _48) -> [0: bb40, 1: bb39, otherwise: bb38];\n    }\n    bb38: {\n        unreachable;\n    }\n    bb39: {\n        _49 = (((_46 as variant#1).0: (usize, &str)).0: usize);\n        _50 = (((_46 as variant#1).0: (usize, &str)).1: &str);\n        StorageLive(_52);\n        _52 = &mut _39;\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = _41;\n        _54 = Range(move _55, _49);\n        StorageDead(_55);\n        _53 = core::str::<impl str>::get_unchecked::<core::ops::Range<usize>>(_1, move _54) -> [return: bb41, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_46);\n        drop(_45) -> [return: bb46, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_54);\n        _51 = string::String::push_str(move _52, _53) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_52);\n        StorageLive(_57);\n        _57 = &mut _39;\n        _56 = string::String::push_str(move _57, _3) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_57);\n        StorageLive(_58);\n        _58 = core::str::<impl str>::len(_50) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _59 = CheckedAdd(_49, _58);\n        assert(!move (_59.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _49, move _58) -> [success: bb45, unwind unreachable];\n    }\n    bb45: {\n        _41 = move (_59.0: usize);\n        StorageDead(_58);\n        StorageDead(_46);\n        goto -> bb36;\n    }\n    bb46: {\n        StorageDead(_45);\n        StorageDead(_42);\n        StorageLive(_61);\n        _61 = &mut _39;\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _41;\n        StorageLive(_65);\n        _65 = core::str::<impl str>::len(_1) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _63 = Range(move _64, move _65);\n        StorageDead(_65);\n        StorageDead(_64);\n        _62 = core::str::<impl str>::get_unchecked::<core::ops::Range<usize>>(_1, move _63) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_63);\n        _60 = string::String::push_str(move _61, _62) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_61);\n        _0 = move _39;\n        StorageDead(_41);\n        StorageDead(_39);\n        StorageDead(_23);\n        goto -> bb50;\n    }\n    bb50: {\n        return;\n    }\n}\n",
  "doc": " Replaces all matches of a pattern with another string.\n\n `replace` creates a new [`String`], and copies the data from this string slice into it.\n While doing so, it attempts to find matches of a pattern. If it finds any, it\n replaces them with the replacement string slice.\n\n # Examples\n\n ```\n let s = \"this is old\";\n\n assert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\n assert_eq!(\"than an old\", s.replace(\"is\", \"an\"));\n ```\n\n When the pattern doesn't match, it returns this string slice as [`String`]:\n\n ```\n let s = \"this is old\";\n assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}