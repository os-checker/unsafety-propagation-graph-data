{
  "name": "collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::bulk_push",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the rightmost leaf edge in or underneath a node - in other words, the edge\n you need last when navigating forward (or first when navigating backward).\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::Handle::<Node, Type>::into_node": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Retrieves the node that contains the edge or key-value pair this handle points to.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a key-value pair to the end of the node, and returns\n the mutable reference of the inserted value.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Leaf>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::ascend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the parent of the current node. Returns `Ok(handle)` if the current\n node actually has a parent, where `handle` points to the edge of the parent\n that points to the current node. Returns `Err(self)` if the current node has\n no parent, giving back the original `NodeRef`.\n\n The method name assumes you picture trees with the root node on top.\n\n `edge.descend().ascend().unwrap()` and `node.ascend().unwrap().descend()` should\n both, upon success, do nothing.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Internal>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is an `Internal` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::push_internal_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new internal node with a single edge pointing to the previous root node,\n make that new node the root node, and return it. This increases the height by 1\n and is the opposite of `pop_internal_level`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::height": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of levels that the node and leaves are apart. Zero\n height means the node is a leaf itself. If you picture trees with the\n root on top, the number says at which elevation the node appears.\n If you picture trees with leaves on top, the number says how high\n the tree extends above the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a new owned tree, with its own root node that is initially empty.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a key-value pair, and an edge to go to the right of that pair,\n to the end of the node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    },
    "collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_right_border_of_plentiful": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stocks up any underfull nodes on the right border of the tree.\n The other nodes, those that are neither the root nor a rightmost edge,\n must be prepared to have up to MIN_LEN elements stolen.\n",
      "adt": {
        "collections::btree::node::NodeRef": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain",
      "Ref"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2398, kind: RigidTy(Tuple([Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }, Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }])) }), Field(0, Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2398, kind: RigidTy(Tuple([Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }, Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }])) }), Field(1, Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2404, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2420, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2428, kind: RigidTy(Adt(AdtDef(DefId { id: 3499, name: \"collections::btree::node::marker::Internal\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 938,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/append.rs:39:5: 95:6",
  "src": "pub(super) fn bulk_push<I, A: Allocator + Clone>(\n        &mut self,\n        iter: I,\n        length: &mut usize,\n        alloc: A,\n    ) where\n        I: Iterator<Item = (K, V)>,\n    {\n        let mut cur_node = self.borrow_mut().last_leaf_edge().into_node();\n        // Iterate through all key-value pairs, pushing them into nodes at the right level.\n        for (key, value) in iter {\n            // Try to push key-value pair into the current leaf node.\n            if cur_node.len() < node::CAPACITY {\n                cur_node.push(key, value);\n            } else {\n                // No space left, go up and push there.\n                let mut open_node;\n                let mut test_node = cur_node.forget_type();\n                loop {\n                    match test_node.ascend() {\n                        Ok(parent) => {\n                            let parent = parent.into_node();\n                            if parent.len() < node::CAPACITY {\n                                // Found a node with space left, push here.\n                                open_node = parent;\n                                break;\n                            } else {\n                                // Go up again.\n                                test_node = parent.forget_type();\n                            }\n                        }\n                        Err(_) => {\n                            // We are at the top, create a new root node and push there.\n                            open_node = self.push_internal_level(alloc.clone());\n                            break;\n                        }\n                    }\n                }\n\n                // Push key-value pair and new right subtree.\n                let tree_height = open_node.height() - 1;\n                let mut right_tree = Root::new(alloc.clone());\n                for _ in 0..tree_height {\n                    right_tree.push_internal_level(alloc.clone());\n                }\n                open_node.push(key, value, right_tree);\n\n                // Go down to the rightmost leaf again.\n                cur_node = open_node.forget_type().last_leaf_edge().into_node();\n            }\n\n            // Increment length every iteration, to make sure the map drops\n            // the appended elements even if advancing the iterator panicks.\n            *length += 1;\n        }\n        self.fix_right_border_of_plentiful();\n    }",
  "mir": "fn collections::btree::append::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::bulk_push(_1: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, _2: I, _3: &mut usize, _4: A) -> () {\n    let mut _0: ();\n    let mut _5: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _6: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _7: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _8: I;\n    let mut _9: I;\n    let mut _10: core::option::Option<(K, V)>;\n    let mut _11: &mut I;\n    let mut _12: isize;\n    let  _13: K;\n    let  _14: V;\n    let mut _15: bool;\n    let mut _16: usize;\n    let mut _17: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let  _18: *mut V;\n    let mut _19: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _20: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _21: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _22: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _23: core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _24: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _25: isize;\n    let  _26: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>;\n    let  _27: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _28: bool;\n    let mut _29: usize;\n    let mut _30: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _31: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _32: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _33: A;\n    let mut _34: &A;\n    let  _35: usize;\n    let mut _36: usize;\n    let mut _37: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _38: (usize, bool);\n    let mut _39: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _40: A;\n    let mut _41: &A;\n    let mut _42: core::ops::Range<usize>;\n    let mut _43: core::ops::Range<usize>;\n    let mut _44: core::ops::Range<usize>;\n    let mut _45: core::option::Option<usize>;\n    let mut _46: &mut core::ops::Range<usize>;\n    let mut _47: isize;\n    let  _48: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _49: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _50: A;\n    let mut _51: &A;\n    let  _52: ();\n    let mut _53: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _54: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _55: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _56: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _57: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _58: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _59: (usize, bool);\n    let  _60: ();\n    debug self => _1;\n    debug iter => _2;\n    debug length => _3;\n    debug alloc => _4;\n    debug cur_node => _5;\n    debug iter => _9;\n    debug key => _13;\n    debug value => _14;\n    debug open_node => _20;\n    debug test_node => _21;\n    debug parent => _26;\n    debug parent => _27;\n    debug tree_height => _35;\n    debug right_tree => _39;\n    debug iter => _44;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::into_node(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = <I as core::iter::IntoIterator>::into_iter(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_9);\n        _9 = move _8;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_10);\n        _11 = &mut _9;\n        _10 = <I as core::iter::Iterator>::next(_11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _13 = move (((_10 as variant#1).0: (K, V)).0: K);\n        _14 = move (((_10 as variant#1).0: (K, V)).1: V);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_5;\n        _16 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::len(move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        drop(_9) -> [return: bb44, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        _15 = Lt(move _16, collections::btree::node::CAPACITY);\n        switchInt(move _15) -> [0: bb13, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _5;\n        _18 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::push(move _19, _13, _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb42;\n    }\n    bb13: {\n        StorageDead(_16);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = move _5;\n        _21 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::forget_type(move _22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_22);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = move _21;\n        _23 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::ascend(move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_24);\n        _25 = discriminant(_23);\n        switchInt(move _25) -> [0: bb18, 1: bb17, otherwise: bb7];\n    }\n    bb17: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &_4;\n        _33 = <A as core::clone::Clone>::clone(move _34) -> [return: bb24, unwind unreachable];\n    }\n    bb18: {\n        _26 = move ((_23 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>);\n        _27 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::into_node(_26) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_27;\n        _29 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::len(move _30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_30);\n        _28 = Lt(move _29, collections::btree::node::CAPACITY);\n        switchInt(move _28) -> [0: bb22, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_29);\n        _20 = _27;\n        StorageDead(_28);\n        goto -> bb26;\n    }\n    bb22: {\n        StorageDead(_29);\n        StorageLive(_31);\n        _31 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::forget_type(_27) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _21 = move _31;\n        StorageDead(_31);\n        StorageDead(_28);\n        StorageDead(_23);\n        goto -> bb15;\n    }\n    bb24: {\n        StorageDead(_34);\n        _32 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::push_internal_level::<A>(_1, move _33) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_33);\n        _20 = move _32;\n        StorageDead(_32);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_23);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &_20;\n        _36 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::height(move _37) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_37);\n        _38 = CheckedSub(_36, 1_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _36, 1_usize) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _35 = move (_38.0: usize);\n        StorageDead(_36);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &_4;\n        _40 = <A as core::clone::Clone>::clone(move _41) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_41);\n        _39 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::new::<A>(move _40) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_40);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = Range(0_usize, _35);\n        _42 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(move _43) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_43);\n        StorageLive(_44);\n        _44 = move _42;\n        goto -> bb32;\n    }\n    bb32: {\n        StorageLive(_45);\n        _46 = &mut _44;\n        _45 = <core::ops::Range<usize> as core::iter::Iterator>::next(_46) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        _47 = discriminant(_45);\n        switchInt(move _47) -> [0: bb35, 1: bb34, otherwise: bb7];\n    }\n    bb34: {\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &mut _39;\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = &_4;\n        _50 = <A as core::clone::Clone>::clone(move _51) -> [return: bb36, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_45);\n        StorageDead(_44);\n        StorageDead(_42);\n        StorageLive(_53);\n        _53 = &mut _20;\n        StorageLive(_54);\n        _54 = move _39;\n        _52 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::push(move _53, _13, _14, move _54) -> [return: bb38, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_51);\n        _48 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::push_internal_level::<A>(move _49, move _50) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_50);\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageDead(_45);\n        goto -> bb32;\n    }\n    bb38: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = move _20;\n        _57 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>::forget_type(move _58) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_58);\n        _56 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge(move _57) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_57);\n        _55 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::into_node(move _56) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_56);\n        _5 = move _55;\n        StorageDead(_55);\n        StorageDead(_39);\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageDead(_15);\n        _59 = CheckedAdd((*_3), 1_usize);\n        assert(!move (_59.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (*_3), 1_usize) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        (*_3) = move (_59.0: usize);\n        StorageDead(_10);\n        goto -> bb5;\n    }\n    bb44: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _60 = collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_right_border_of_plentiful(_1) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_5);\n        drop(_4) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        return;\n    }\n}\n",
  "doc": " Pushes all key-value pairs to the end of the tree, incrementing a\n `length` variable along the way. The latter makes it easier for the\n caller to avoid a leak when the iterator panicks.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}