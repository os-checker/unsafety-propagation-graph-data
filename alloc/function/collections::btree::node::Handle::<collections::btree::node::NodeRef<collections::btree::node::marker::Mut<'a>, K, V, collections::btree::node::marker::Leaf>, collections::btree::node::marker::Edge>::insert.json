{
  "name": "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_fit": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a new key-value pair between the key-value pairs to the right and left of\n this edge. This method assumes that there is enough space in the node for the new\n pair to fit.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, HandleType>::dormant": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a dormant copy of this handle which can be reawakened later.\n\n See `DormantMutRef` for more details.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::splitpoint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given an edge index where we want to insert into a node filled to capacity,\n computes a sensible KV index of a split point and where to perform the insertion.\n The goal of the split point is for its key and value to end up in a parent node;\n the keys, values and edges to the left of the split point become the left child;\n the keys, values and edges to the right of the split point become the right child.\n",
      "adt": {
        "collections::btree::node::LeftOrRight": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::KV>::new_kv": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to a key-value pair in `node`.\n Unsafe because the caller must ensure that `idx < node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the underlying node into three parts:\n\n - The node is truncated to only contain the key-value pairs to the left of\n   this handle.\n - The key and value pointed to by this handle are extracted.\n - All the key-value pairs to the right of this handle are put into a newly\n   allocated node.\n",
      "adt": {
        "collections::btree::node::Handle": "MutableAsArgument",
        "collections::btree::node::SplitResult": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::new_edge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new handle to an edge in `node`.\n Unsafe because the caller must ensure that `idx <= node.len()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Ref",
      "Plain",
      "MutRef"
    ],
    "collections::btree::node::Handle": [
      "Unknown([Field(0, Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) })])",
      "Plain",
      "Ref",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "collections::btree::node::LeftOrRight": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 4647, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "collections::btree::node::SplitResult": [
      "Plain",
      "Unknown([Field(2, Ty { id: 2737, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(0, Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": 888,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:953:5: 983:6",
  "src": "fn insert<A: Allocator + Clone>(\n        self,\n        key: K,\n        val: V,\n        alloc: A,\n    ) -> (\n        Option<SplitResult<'a, K, V, marker::Leaf>>,\n        Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,\n    ) {\n        if self.node.len() < CAPACITY {\n            // SAFETY: There is enough space in the node for insertion.\n            let handle = unsafe { self.insert_fit(key, val) };\n            (None, handle.dormant())\n        } else {\n            let (middle_kv_idx, insertion) = splitpoint(self.idx);\n            let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n            let mut result = middle.split(alloc);\n            let insertion_edge = match insertion {\n                LeftOrRight::Left(insert_idx) => unsafe {\n                    Handle::new_edge(result.left.reborrow_mut(), insert_idx)\n                },\n                LeftOrRight::Right(insert_idx) => unsafe {\n                    Handle::new_edge(result.right.borrow_mut(), insert_idx)\n                },\n            };\n            // SAFETY: We just split the node, so there is enough space for\n            // insertion.\n            let handle = unsafe { insertion_edge.insert_fit(key, val).dormant() };\n            (Some(result), handle)\n        }\n    }",
  "mir": "fn collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert(_1: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>, _2: K, _3: V, _4: A) -> (core::option::Option<collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Leaf>>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::DormantMut, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>) {\n    let mut _0: (core::option::Option<collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Leaf>>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::DormantMut, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>);\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let  _8: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _9: core::option::Option<collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Leaf>>;\n    let mut _10: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::DormantMut, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _11: &collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let  _12: usize;\n    let  _13: collections::btree::node::LeftOrRight<usize>;\n    let mut _14: (usize, collections::btree::node::LeftOrRight<usize>);\n    let mut _15: usize;\n    let  _16: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _17: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _18: collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Leaf>;\n    let mut _19: A;\n    let  _20: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _21: isize;\n    let  _22: usize;\n    let mut _23: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _24: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let  _25: usize;\n    let mut _26: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _27: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let  _28: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::DormantMut, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _29: &collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let  _30: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _31: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _32: core::option::Option<collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Leaf>>;\n    let mut _33: collections::btree::node::SplitResult<'_, K, V, collections::btree::node::marker::Leaf>;\n    let mut _34: bool;\n    debug self => _1;\n    debug key => _2;\n    debug val => _3;\n    debug alloc => _4;\n    debug handle => _8;\n    debug middle_kv_idx => _12;\n    debug insertion => _13;\n    debug middle => _16;\n    debug result => _18;\n    debug insertion_edge => _20;\n    debug insert_idx => _22;\n    debug insert_idx => _25;\n    debug handle => _28;\n    bb0: {\n        _34 = false;\n        _34 = true;\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(_1.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>);\n        _6 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::len(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _5 = Lt(move _6, collections::btree::node::CAPACITY);\n        switchInt(move _5) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_fit(_1, _2, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = core::option::Option::None;\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_8;\n        _10 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::dormant(move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        _0 = (move _9, move _10);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb19;\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (_1.1: usize);\n        _14 = collections::btree::node::splitpoint(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _12 = (_14.0: usize);\n        StorageLive(_13);\n        _13 = move (_14.1: collections::btree::node::LeftOrRight<usize>);\n        StorageDead(_14);\n        StorageLive(_17);\n        _17 = (_1.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>);\n        _16 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::new_kv(move _17, _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _34 = false;\n        _19 = move _4;\n        _18 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::split::<A>(_16, move _19) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _21 = discriminant(_13);\n        switchInt(move _21) -> [0: bb11, 1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        _25 = ((_13 as variant#1).0: usize);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &mut (_18.2: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>);\n        _26 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::borrow_mut(move _27) -> [return: bb14, unwind unreachable];\n    }\n    bb11: {\n        _22 = ((_13 as variant#0).0: usize);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &mut (_18.0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>);\n        _23 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::reborrow_mut(move _24) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        _20 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::new_edge(move _23, _22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_23);\n        goto -> bb16;\n    }\n    bb14: {\n        StorageDead(_27);\n        _20 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::new_edge(move _26, _25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_26);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = move _20;\n        _30 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_fit(move _31, _2, _3) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _29 = &_30;\n        StorageDead(_31);\n        _28 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::dormant(move _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = move _18;\n        _32 = core::option::Option::Some(move _33);\n        StorageDead(_33);\n        _0 = (move _32, _28);\n        StorageDead(_32);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_13);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_5);\n        switchInt(_34) -> [0: bb20, otherwise: bb21];\n    }\n    bb20: {\n        return;\n    }\n    bb21: {\n        drop(_4) -> [return: bb20, unwind unreachable];\n    }\n}\n",
  "doc": " Inserts a new key-value pair between the key-value pairs to the right and left of\n this edge. This method splits the node if there isn't enough room.\n\n Returns a dormant handle to the inserted node which can be reawakened\n once splitting is complete.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}