{
  "name": "string::String::try_reserve_exact",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::try_reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tries to reserve the minimum capacity for at least `additional`\n elements to be inserted in the given `Vec<T>`. Unlike [`try_reserve`],\n this will not deliberately over-allocate to speculatively avoid frequent\n allocations. After calling `try_reserve_exact`, capacity will be greater\n than or equal to `self.len() + additional` if it returns `Ok(())`.\n Does nothing if the capacity is already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`try_reserve`] if future insertions are expected.\n\n [`try_reserve`]: Vec::try_reserve\n\n # Errors\n\n If the capacity overflows, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n\n fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     let mut output = Vec::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve_exact(data.len())?;\n\n     // Now we know this can't OOM in the middle of our complex work\n     output.extend(data.iter().map(|&val| {\n         val * 2 + 5 // very complicated\n     }));\n\n     Ok(output)\n }\n # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "MutRef"
    ],
    "string::String": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1996,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1331:5: 1333:6",
  "src": "pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        self.vec.try_reserve_exact(additional)\n    }",
  "mir": "fn string::String::try_reserve_exact(_1: &mut string::String, _2: usize) -> core::result::Result<(), collections::TryReserveError> {\n    let mut _0: core::result::Result<(), collections::TryReserveError>;\n    let mut _3: &mut vec::Vec<u8>;\n    debug self => _1;\n    debug additional => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: vec::Vec<u8>);\n        _0 = vec::Vec::<u8>::try_reserve_exact(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Tries to reserve the minimum capacity for at least `additional` bytes\n more than the current length. Unlike [`try_reserve`], this will not\n deliberately over-allocate to speculatively avoid frequent allocations.\n After calling `try_reserve_exact`, capacity will be greater than or\n equal to `self.len() + additional` if it returns `Ok(())`.\n Does nothing if the capacity is already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`try_reserve`] if future insertions are expected.\n\n [`try_reserve`]: String::try_reserve\n\n # Errors\n\n If the capacity overflows, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n\n fn process_data(data: &str) -> Result<String, TryReserveError> {\n     let mut output = String::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve_exact(data.len())?;\n\n     // Now we know this can't OOM in the middle of our complex work\n     output.push_str(data);\n\n     Ok(output)\n }\n # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}