{
  "name": "sync::UniqueArc::<T>::try_map",
  "safe": true,
  "callees": {
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "core::mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "sync::UniqueArc::<T, A>::weak_count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::UniqueArc": "ImmutableAsArgument"
      }
    },
    "sync::UniqueArc::<T>::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::UniqueArc": "ImmutableAsArgument"
      }
    },
    "core::ptr::const_ptr::<impl *const T>::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.\n\n See [`ptr::read`] for safety concerns and examples.\n\n [`ptr::read`]: crate::ptr::read()\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "sync::UniqueArc::<T>::from_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::UniqueArc": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sync::UniqueArc::<core::mem::MaybeUninit<T>, A>::assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::UniqueArc": "Constructor"
      }
    },
    "core::ops::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    },
    "sync::UniqueArc::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::UniqueArc": "ImmutableAsArgument"
      }
    },
    "sync::UniqueArc::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `UniqueArc`.\n\n Weak references to this `UniqueArc` can be created with [`UniqueArc::downgrade`]. Upgrading\n these weak references will fail before the `UniqueArc` has been converted into an [`Arc`].\n After converting the `UniqueArc` into an [`Arc`], any weak references created beforehand will\n point to the new [`Arc`].\n",
      "adt": {
        "sync::UniqueArc": "Constructor"
      }
    },
    "core::ops::try_trait::residual_into_try_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "sync::UniqueArc": [
      "Ref",
      "Plain",
      "MutRef"
    ],
    "core::mem::MaybeUninit": [
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1121, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2989, name: \"core::ops::Try::Output\" }), args: GenericArgs([Type(Ty { id: 238, kind: Param(ParamTy { index: 1, name: \"R\" }) })]) }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1123, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2990, name: \"core::ops::Try::Residual\" }), args: GenericArgs([Type(Ty { id: 238, kind: Param(ParamTy { index: 1, name: \"R\" }) })]) }) })])"
    ]
  },
  "path": 2148,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:4662:5: 4685:6",
  "src": "pub fn try_map<R>(\n        this: Self,\n        f: impl FnOnce(T) -> R,\n    ) -> <R::Residual as Residual<UniqueArc<R::Output>>>::TryType\n    where\n        R: Try,\n        R::Residual: Residual<UniqueArc<R::Output>>,\n    {\n        if size_of::<T>() == size_of::<R::Output>()\n            && align_of::<T>() == align_of::<R::Output>()\n            && UniqueArc::weak_count(&this) == 0\n        {\n            unsafe {\n                let ptr = UniqueArc::into_raw(this);\n                let value = ptr.read();\n                let mut allocation = UniqueArc::from_raw(ptr.cast::<mem::MaybeUninit<R::Output>>());\n\n                allocation.write(f(value)?);\n                try { allocation.assume_init() }\n            }\n        } else {\n            try { UniqueArc::new(f(UniqueArc::unwrap(this))?) }\n        }\n    }",
  "mir": "fn sync::UniqueArc::<T>::try_map(_1: sync::UniqueArc<T>, _2: impl FnOnce(T) -> R) -> <<R as core::ops::Try>::Residual as core::ops::Residual<sync::UniqueArc<<R as core::ops::Try>::Output>>>::TryType {\n    let mut _0: <<R as core::ops::Try>::Residual as core::ops::Residual<sync::UniqueArc<<R as core::ops::Try>::Output>>>::TryType;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: bool;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: usize;\n    let  _10: &sync::UniqueArc<T>;\n    let  _11: *const T;\n    let  _12: T;\n    let mut _13: sync::UniqueArc<core::mem::MaybeUninit<<R as core::ops::Try>::Output>>;\n    let mut _14: *const core::mem::MaybeUninit<<R as core::ops::Try>::Output>;\n    let  _15: &mut <R as core::ops::Try>::Output;\n    let mut _16: &mut core::mem::MaybeUninit<<R as core::ops::Try>::Output>;\n    let mut _17: &mut sync::UniqueArc<core::mem::MaybeUninit<<R as core::ops::Try>::Output>>;\n    let mut _18: core::ops::ControlFlow<<R as core::ops::Try>::Residual, <R as core::ops::Try>::Output>;\n    let mut _19: R;\n    let mut _20: (T,);\n    let mut _21: isize;\n    let  _22: <R as core::ops::Try>::Residual;\n    let  _23: <R as core::ops::Try>::Output;\n    let mut _24: sync::UniqueArc<<R as core::ops::Try>::Output>;\n    let mut _25: sync::UniqueArc<core::mem::MaybeUninit<<R as core::ops::Try>::Output>>;\n    let mut _26: sync::UniqueArc<<R as core::ops::Try>::Output>;\n    let mut _27: core::ops::ControlFlow<<R as core::ops::Try>::Residual, <R as core::ops::Try>::Output>;\n    let mut _28: R;\n    let mut _29: (T,);\n    let mut _30: T;\n    let mut _31: isize;\n    let  _32: <R as core::ops::Try>::Residual;\n    let  _33: <R as core::ops::Try>::Output;\n    debug this => _1;\n    debug f => _2;\n    debug ptr => _11;\n    debug value => _12;\n    debug allocation => _13;\n    debug residual => _22;\n    debug val => _23;\n    debug residual => _32;\n    debug val => _33;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = core::mem::size_of::<<R as core::ops::Try>::Output>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = Eq(move _4, move _5);\n        switchInt(move _3) -> [0: bb25, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::mem::align_of::<T>() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = core::mem::align_of::<<R as core::ops::Try>::Output>() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _6 = Eq(move _7, move _8);\n        switchInt(move _6) -> [0: bb24, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_9);\n        _10 = &_1;\n        _9 = sync::UniqueArc::<T>::weak_count(_10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _9) -> [0: bb8, otherwise: bb23];\n    }\n    bb8: {\n        StorageDead(_9);\n        _11 = sync::UniqueArc::<T>::into_raw(_1) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _12 = core::ptr::const_ptr::<impl *const T>::read(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = core::ptr::const_ptr::<impl *const T>::cast::<core::mem::MaybeUninit<<R as core::ops::Try>::Output>>(_11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _13 = sync::UniqueArc::<core::mem::MaybeUninit<<R as core::ops::Try>::Output>>::from_raw(move _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_17);\n        _17 = &mut _13;\n        _16 = <sync::UniqueArc<core::mem::MaybeUninit<<R as core::ops::Try>::Output>> as core::ops::DerefMut>::deref_mut(move _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = (_12);\n        _19 = <impl FnOnce(T) -> R as core::ops::FnOnce<(T,)>>::call_once(_2, move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        _18 = <R as core::ops::Try>::branch(move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        _21 = discriminant(_18);\n        switchInt(move _21) -> [0: bb17, 1: bb18, otherwise: bb16];\n    }\n    bb16: {\n        unreachable;\n    }\n    bb17: {\n        _23 = move ((_18 as variant#0).0: <R as core::ops::Try>::Output);\n        _15 = core::mem::MaybeUninit::<<R as core::ops::Try>::Output>::write(_16, _23) -> [return: bb20, unwind unreachable];\n    }\n    bb18: {\n        _22 = move ((_18 as variant#1).0: <R as core::ops::Try>::Residual);\n        _0 = <<<R as core::ops::Try>::Residual as core::ops::Residual<sync::UniqueArc<<R as core::ops::Try>::Output>>>::TryType as core::ops::FromResidual<<R as core::ops::Try>::Residual>>::from_residual(_22) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_18);\n        StorageDead(_15);\n        drop(_13) -> [return: bb36, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_18);\n        StorageDead(_15);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = move _13;\n        _24 = sync::UniqueArc::<core::mem::MaybeUninit<<R as core::ops::Try>::Output>>::assume_init(move _25) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_25);\n        _0 = <<<R as core::ops::Try>::Residual as core::ops::Residual<sync::UniqueArc<<R as core::ops::Try>::Output>>>::TryType as core::ops::Try>::from_output(move _24) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_24);\n        StorageDead(_13);\n        goto -> bb35;\n    }\n    bb23: {\n        StorageDead(_9);\n        goto -> bb26;\n    }\n    bb24: {\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb26;\n    }\n    bb25: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = sync::UniqueArc::<T>::unwrap(_1) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _29 = (move _30);\n        _28 = <impl FnOnce(T) -> R as core::ops::FnOnce<(T,)>>::call_once(_2, move _29) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_30);\n        StorageDead(_29);\n        _27 = <R as core::ops::Try>::branch(move _28) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_28);\n        _31 = discriminant(_27);\n        switchInt(move _31) -> [0: bb30, 1: bb31, otherwise: bb16];\n    }\n    bb30: {\n        _33 = move ((_27 as variant#0).0: <R as core::ops::Try>::Output);\n        _26 = sync::UniqueArc::<<R as core::ops::Try>::Output>::new(_33) -> [return: bb33, unwind unreachable];\n    }\n    bb31: {\n        _32 = move ((_27 as variant#1).0: <R as core::ops::Try>::Residual);\n        _0 = core::ops::try_trait::residual_into_try_type::<<R as core::ops::Try>::Residual, sync::UniqueArc<<R as core::ops::Try>::Output>>(_32) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_27);\n        StorageDead(_26);\n        goto -> bb35;\n    }\n    bb33: {\n        _0 = <<<R as core::ops::Try>::Residual as core::ops::Residual<sync::UniqueArc<<R as core::ops::Try>::Output>>>::TryType as core::ops::Try>::from_output(move _26) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_27);\n        StorageDead(_26);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb36: {\n        StorageDead(_13);\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb37: {\n        return;\n    }\n}\n",
  "doc": " Attempts to map the value in a `UniqueArc`, reusing the allocation if possible.\n\n `f` is called on a reference to the value in the `UniqueArc`, and if the operation succeeds,\n the result is returned, also in a `UniqueArc`.\n\n Note: this is an associated function, which means that you have\n to call it as `UniqueArc::try_map(u, f)` instead of `u.try_map(f)`. This\n is so that there is no conflict with a method on the inner type.\n\n # Examples\n\n ```\n #![feature(smart_pointer_try_map)]\n #![feature(unique_rc_arc)]\n\n use std::sync::UniqueArc;\n\n let b = UniqueArc::new(7);\n let new = UniqueArc::try_map(b, u32::try_from).unwrap();\n assert_eq!(*new, 7);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}