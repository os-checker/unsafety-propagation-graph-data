{
  "name": "collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::deallocating_next_back_unchecked",
  "safe": false,
  "callees": {
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    },
    "collections::btree::navigate::LazyLeafRange::<BorrowType, K, V>::init_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "collections::btree::navigate::LazyLeafRange": "MutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::deallocating_next_back_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves the leaf edge handle to the previous leaf edge and returns the key and value\n in between, deallocating any node left behind while leaving the corresponding\n edge in its parent node dangling.\n\n # Safety\n - There must be another KV in the direction travelled.\n - That leaf edge was not previously returned by counterpart\n   `deallocating_next_unchecked` on any copy of the handles\n   being used to traverse the tree.\n\n The only safe way to proceed with the updated handle is to compare it, drop it,\n or call this method or counterpart `deallocating_next_unchecked` again.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Ref",
      "Plain"
    ],
    "collections::btree::navigate::LazyLeafRange": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "collections::btree::node::Handle": [
      "MutRef",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::deallocating_next_back_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/navigate.rs:203:5: 210:6",
  "src": "pub(super) unsafe fn deallocating_next_back_unchecked<A: Allocator + Clone>(\n        &mut self,\n        alloc: A,\n    ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n        debug_assert!(self.back.is_some());\n        let back = self.init_back().unwrap();\n        unsafe { back.deallocating_next_back_unchecked(alloc) }\n    }",
  "mir": "fn collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::deallocating_next_back_unchecked(_1: &mut collections::btree::navigate::LazyLeafRange<collections::btree::node::marker::Dying, K, V>, _2: A) -> collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV> {\n    let mut _0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _3: bool;\n    let mut _4: &core::option::Option<collections::btree::navigate::LazyLeafHandle<collections::btree::node::marker::Dying, K, V>>;\n    let mut _5: !;\n    let  _6: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _7: core::option::Option<&mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    debug self => _1;\n    debug alloc => _2;\n    debug back => _6;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).1: core::option::Option<collections::btree::navigate::LazyLeafHandle<collections::btree::node::marker::Dying, K, V>>);\n        _3 = core::option::Option::<collections::btree::navigate::LazyLeafHandle<collections::btree::node::marker::Dying, K, V>>::is_some(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_7);\n        _7 = collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::init_back(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _5 = core::panicking::panic(\"assertion failed: self.back.is_some()\") -> unwind unreachable;\n    }\n    bb4: {\n        _6 = core::option::Option::<&mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::unwrap(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _0 = collections::btree::navigate::<impl collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::deallocating_next_back_unchecked::<A>(_6, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}