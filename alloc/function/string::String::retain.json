{
  "name": "string::String::retain",
  "safe": true,
  "callees": {
    "string::String::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of this `String`, in bytes, not [`char`]s or\n graphemes. In other words, it might not be what a human considers the\n length of the string.\n\n # Examples\n\n ```\n let a = String::from(\"foo\");\n assert_eq!(a.len(), 3);\n\n let fancy_f = String::from(\"∆íoo\");\n assert_eq!(fancy_f.len(), 4);\n assert_eq!(fancy_f.chars().count(), 3);\n ```\n",
      "adt": {
        "string::String": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::str::<impl str>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unchecked subslice of `str`.\n\n This is the unchecked alternative to indexing the `str`.\n\n # Safety\n\n Callers of this function are responsible that these preconditions are\n satisfied:\n\n * The starting index must not exceed the ending index;\n * Indexes must be within bounds of the original slice;\n * Indexes must lie on UTF-8 sequence boundaries.\n\n Failing that, the returned string slice may reference invalid memory or\n violate the invariants communicated by the `str` type.\n\n # Examples\n\n ```\n let v = \"üóª‚ààüåè\";\n unsafe {\n     assert_eq!(\"üóª\", v.get_unchecked(0..4));\n     assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n     assert_eq!(\"üåè\", v.get_unchecked(7..11));\n }\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"yÃÜ\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value,\n without checking that the value is not [`None`].\n\n # Safety\n\n Calling this method on [`None`] is *[undefined behavior]*.\n\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\");\n ```\n\n ```no_run\n let x: Option<&str> = None;\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\"); // Undefined behavior!\n ```\n",
      "adt": {}
    },
    "core::char::methods::<impl char>::len_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes this `char` would need if encoded in UTF-8.\n\n That number of bytes is always between 1 and 4, inclusive.\n\n # Examples\n\n Basic usage:\n\n ```\n let len = 'A'.len_utf8();\n assert_eq!(len, 1);\n\n let len = '√ü'.len_utf8();\n assert_eq!(len, 2);\n\n let len = '‚Ñù'.len_utf8();\n assert_eq!(len, 3);\n\n let len = 'üí£'.len_utf8();\n assert_eq!(len, 4);\n ```\n\n The `&str` type guarantees that its contents are UTF-8, and so we can compare the length it\n would take if each code point was represented as a `char` vs in the `&str` itself:\n\n ```\n // as chars\n let eastern = 'Êù±';\n let capital = '‰∫¨';\n\n // both can be represented as three bytes\n assert_eq!(3, eastern.len_utf8());\n assert_eq!(3, capital.len_utf8());\n\n // as a &str, these two are encoded in UTF-8\n let tokyo = \"Êù±‰∫¨\";\n\n let len = eastern.len_utf8() + capital.len_utf8();\n\n // we can see that they take six bytes total...\n assert_eq!(6, tokyo.len());\n\n // ... just like the &str\n assert_eq!(len, tokyo.len());\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::str::<impl str>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a mutable string slice to a raw pointer.\n\n As string slices are a slice of bytes, the raw pointer points to a\n [`u8`]. This pointer will be pointing to the first byte of the string\n slice.\n\n It is your responsibility to make sure that the string slice only gets\n modified in a way that it remains valid UTF-8.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::slice::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "core::char::methods::<impl char>::encode_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Encodes this character as UTF-8 into the provided byte buffer,\n and then returns the subslice of the buffer that contains the encoded character.\n\n # Panics\n\n Panics if the buffer is not large enough.\n A buffer of length four is large enough to encode any `char`.\n\n # Examples\n\n In both of these examples, '√ü' takes two bytes to encode.\n\n ```\n let mut b = [0; 2];\n\n let result = '√ü'.encode_utf8(&mut b);\n\n assert_eq!(result, \"√ü\");\n\n assert_eq!(result.len(), 2);\n ```\n\n A buffer that's too small:\n\n ```should_panic\n let mut b = [0; 1];\n\n // this panics\n '√ü'.encode_utf8(&mut b);\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "string::String": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "string::String::retain::SetLenOnDrop": [
      "Plain",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(0, Ty { id: 558, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 557, kind: RigidTy(Adt(AdtDef(DefId { id: 2811, name: \"string::String\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(2, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::str::Chars": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::string::String::retain"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1630:5: 1681:6",
  "src": "pub fn retain<F>(&mut self, mut f: F)\n    where\n        F: FnMut(char) -> bool,\n    {\n        struct SetLenOnDrop<'a> {\n            s: &'a mut String,\n            idx: usize,\n            del_bytes: usize,\n        }\n\n        impl<'a> Drop for SetLenOnDrop<'a> {\n            fn drop(&mut self) {\n                let new_len = self.idx - self.del_bytes;\n                debug_assert!(new_len <= self.s.len());\n                unsafe { self.s.vec.set_len(new_len) };\n            }\n        }\n\n        let len = self.len();\n        let mut guard = SetLenOnDrop { s: self, idx: 0, del_bytes: 0 };\n\n        while guard.idx < len {\n            let ch =\n                // SAFETY: `guard.idx` is positive-or-zero and less that len so the `get_unchecked`\n                // is in bound. `self` is valid UTF-8 like string and the returned slice starts at\n                // a unicode code point so the `Chars` always return one character.\n                unsafe { guard.s.get_unchecked(guard.idx..len).chars().next().unwrap_unchecked() };\n            let ch_len = ch.len_utf8();\n\n            if !f(ch) {\n                guard.del_bytes += ch_len;\n            } else if guard.del_bytes > 0 {\n                // SAFETY: `guard.idx` is in bound and `guard.del_bytes` represent the number of\n                // bytes that are erased from the string so the resulting `guard.idx -\n                // guard.del_bytes` always represent a valid unicode code point.\n                //\n                // `guard.del_bytes` >= `ch.len_utf8()`, so taking a slice with `ch.len_utf8()` len\n                // is safe.\n                ch.encode_utf8(unsafe {\n                    crate::slice::from_raw_parts_mut(\n                        guard.s.as_mut_ptr().add(guard.idx - guard.del_bytes),\n                        ch.len_utf8(),\n                    )\n                });\n            }\n\n            // Point idx to the next char\n            guard.idx += ch_len;\n        }\n\n        drop(guard);\n    }",
  "mir": "fn string::String::retain(_1: &mut string::String, _2: F) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &string::String;\n    let mut _5: string::String::retain::SetLenOnDrop<'_>;\n    let mut _6: bool;\n    let mut _7: usize;\n    let  _8: char;\n    let mut _9: core::option::Option<char>;\n    let mut _10: &mut core::str::Chars<'_>;\n    let mut _11: core::str::Chars<'_>;\n    let  _12: &str;\n    let  _13: &str;\n    let mut _14: &string::String;\n    let mut _15: core::ops::Range<usize>;\n    let mut _16: usize;\n    let  _17: usize;\n    let mut _18: bool;\n    let mut _19: &mut F;\n    let mut _20: (char,);\n    let mut _21: (usize, bool);\n    let mut _22: bool;\n    let mut _23: usize;\n    let  _24: &mut str;\n    let mut _25: &mut [u8];\n    let mut _26: *mut u8;\n    let mut _27: *mut u8;\n    let mut _28: &mut str;\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    let mut _33: usize;\n    let mut _34: (usize, bool);\n    let  _35: ();\n    let mut _36: string::String::retain::SetLenOnDrop<'_>;\n    let mut _37: &mut string::String;\n    let mut _38: &mut string::String;\n    debug self => _1;\n    debug f => _2;\n    debug len => _3;\n    debug guard => _5;\n    debug ch => _8;\n    debug ch_len => _17;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = string::String::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = SetLenOnDrop(_1, 0_usize, 0_usize);\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = (_5.1: usize);\n        _6 = Lt(move _7, _3);\n        switchInt(move _6) -> [0: bb26, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_14);\n        _37 = (_5.0: &mut string::String);\n        _14 = &(*_37);\n        _13 = <string::String as core::ops::Deref>::deref(move _14) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = (_5.1: usize);\n        _15 = Range(move _16, _3);\n        StorageDead(_16);\n        _12 = core::str::<impl str>::get_unchecked::<core::ops::Range<usize>>(_13, move _15) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_15);\n        _11 = core::str::<impl str>::chars(_12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _10 = &mut _11;\n        _9 = <core::str::Chars<'_> as core::iter::Iterator>::next(move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_10);\n        _8 = core::option::Option::<char>::unwrap_unchecked(move _9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageDead(_9);\n        _17 = core::char::methods::<impl char>::len_utf8(_8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _2;\n        StorageLive(_20);\n        _20 = (_8);\n        _18 = <F as core::ops::FnMut<(char,)>>::call_mut(move _19, move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _18) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = (_5.2: usize);\n        _22 = Gt(move _23, 0_usize);\n        switchInt(move _22) -> [0: bb15, otherwise: bb14];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageDead(_19);\n        _21 = CheckedAdd((_5.2: usize), _17);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (_5.2: usize), _17) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        (_5.2: usize) = move (_21.0: usize);\n        goto -> bb24;\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageLive(_24);\n        StorageLive(_26);\n        StorageLive(_27);\n        _38 = (_5.0: &mut string::String);\n        _28 = <string::String as core::ops::DerefMut>::deref_mut(_38) -> [return: bb16, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        goto -> bb23;\n    }\n    bb16: {\n        _27 = core::str::<impl str>::as_mut_ptr(_28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = (_5.1: usize);\n        StorageLive(_31);\n        _31 = (_5.2: usize);\n        _32 = CheckedSub(_30, _31);\n        assert(!move (_32.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _30, move _31) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _29 = move (_32.0: usize);\n        StorageDead(_31);\n        StorageDead(_30);\n        _26 = core::ptr::mut_ptr::<impl *mut u8>::add(move _27, move _29) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageLive(_33);\n        _33 = core::char::methods::<impl char>::len_utf8(_8) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _25 = core::slice::from_raw_parts_mut::<'_, u8>(move _26, move _33) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        StorageDead(_26);\n        _24 = core::char::methods::<impl char>::encode_utf8(_8, _25) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_24);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_22);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_18);\n        _34 = CheckedAdd((_5.1: usize), _17);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (_5.1: usize), _17) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        (_5.1: usize) = move (_34.0: usize);\n        StorageDead(_6);\n        goto -> bb2;\n    }\n    bb26: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_36);\n        _36 = move _5;\n        _35 = core::mem::drop::<string::String::retain::SetLenOnDrop<'_>>(move _36) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_36);\n        StorageDead(_5);\n        drop(_2) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": " Retains only the characters specified by the predicate.\n\n In other words, remove all characters `c` such that `f(c)` returns `false`.\n This method operates in place, visiting each character exactly once in the\n original order, and preserves the order of the retained characters.\n\n # Examples\n\n ```\n let mut s = String::from(\"f_o_ob_ar\");\n\n s.retain(|c| c != '_');\n\n assert_eq!(s, \"foobar\");\n ```\n\n Because the elements are visited exactly once in the original order,\n external state may be used to decide which elements to keep.\n\n ```\n let mut s = String::from(\"abcde\");\n let keep = [false, true, true, false, true];\n let mut iter = keep.iter();\n s.retain(|_| *iter.next().unwrap());\n assert_eq!(s, \"bce\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}