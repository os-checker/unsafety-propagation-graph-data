{
  "name": "collections::vec_deque::VecDeque::<T, A>::write_iter",
  "safe": false,
  "callees": {
    "core::iter::Iterator::enumerate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which gives the current iteration count as well as\n the next value.\n\n The iterator returned yields pairs `(i, val)`, where `i` is the\n current index of iteration and `val` is the value returned by the\n iterator.\n\n `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n different sized integer, the [`zip`] function provides similar\n functionality.\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so enumerating more than\n [`usize::MAX`] elements either produces the wrong result or panics. If\n overflow checks are enabled, a panic is guaranteed.\n\n # Panics\n\n The returned iterator might panic if the to-be-returned index would\n overflow a [`usize`].\n\n [`zip`]: Iterator::zip\n\n # Examples\n\n ```\n let a = ['a', 'b', 'c'];\n\n let mut iter = a.into_iter().enumerate();\n\n assert_eq!(iter.next(), Some((0, 'a')));\n assert_eq!(iter.next(), Some((1, 'b')));\n assert_eq!(iter.next(), Some((2, 'c')));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls a closure on each element of an iterator.\n\n This is equivalent to using a [`for`] loop on the iterator, although\n `break` and `continue` are not possible from a closure. It's generally\n more idiomatic to use a `for` loop, but `for_each` may be more legible\n when processing items at the end of longer iterator chains. In some\n cases `for_each` may also be faster than a loop, because it will use\n internal iteration on adapters like `Chain`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n use std::sync::mpsc::channel;\n\n let (tx, rx) = channel();\n (0..5).map(|x| x * 2 + 1)\n       .for_each(move |x| tx.send(x).unwrap());\n\n let v: Vec<_> = rx.iter().collect();\n assert_eq!(v, vec![1, 3, 5, 7, 9]);\n ```\n\n For such a small example, a `for` loop may be cleaner, but `for_each`\n might be preferable to keep a functional style with longer iterators:\n\n ```\n (0..5).flat_map(|x| (x * 100)..(x * 110))\n       .enumerate()\n       .filter(|&(i, x)| (i + x) % 3 == 0)\n       .for_each(|(i, x)| println!(\"{i}:{x}\"));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::iter::Enumerate": [
      "Plain"
    ],
    "collections::vec_deque::VecDeque": [
      "MutRef"
    ]
  },
  "path": 1540,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:561:5: 571:6",
  "src": "unsafe fn write_iter(\n        &mut self,\n        dst: usize,\n        iter: impl Iterator<Item = T>,\n        written: &mut usize,\n    ) {\n        iter.enumerate().for_each(|(i, element)| unsafe {\n            self.buffer_write(dst + i, element);\n            *written += 1;\n        });\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::write_iter(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize, _3: impl Iterator<Item = T>, _4: &mut usize) -> () {\n    let mut _0: ();\n    let  _5: ();\n    let mut _6: core::iter::Enumerate<impl Iterator<Item = T>>;\n    let mut _7: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:567:35: 567:49};\n    let mut _8: &usize;\n    debug self => _1;\n    debug dst => _2;\n    debug iter => _3;\n    debug written => _4;\n    bb0: {\n        StorageLive(_6);\n        _6 = <impl Iterator<Item = T> as core::iter::Iterator>::enumerate(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_2;\n        _7 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:567:35: 567:49}(_1, move _8, _4);\n        StorageDead(_8);\n        _5 = <core::iter::Enumerate<impl Iterator<Item = T>> as core::iter::Iterator>::for_each::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:567:35: 567:49}>(move _6, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Writes all values from `iter` to `dst`.\n\n # Safety\n\n Assumes no wrapping around happens.\n Assumes capacity is sufficient.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}