{
  "name": "slice::<impl [T]>::sort_by_cached_key",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::enumerate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which gives the current iteration count as well as\n the next value.\n\n The iterator returned yields pairs `(i, val)`, where `i` is the\n current index of iteration and `val` is the value returned by the\n iterator.\n\n `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n different sized integer, the [`zip`] function provides similar\n functionality.\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so enumerating more than\n [`usize::MAX`] elements either produces the wrong result or panics. If\n overflow checks are enabled, a panic is guaranteed.\n\n # Panics\n\n The returned iterator might panic if the to-be-returned index would\n overflow a [`usize`].\n\n [`zip`]: Iterator::zip\n\n # Examples\n\n ```\n let a = ['a', 'b', 'c'];\n\n let mut iter = a.into_iter().enumerate();\n\n assert_eq!(iter.next(), Some((0, 'a')));\n assert_eq!(iter.next(), Some((1, 'b')));\n assert_eq!(iter.next(), Some((2, 'c')));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::sort_unstable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order **without** preserving the initial order of equal elements.\n\n This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\n allocate), and *O*(*n* \\* log(*n*)) worst-case.\n\n If the implementation of [`Ord`] for `T` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n\n All original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. Same is true if the implementation of [`Ord`] for `T` panics.\n\n Sorting types that only implement [`PartialOrd`] such as [`f32`] and [`f64`] require\n additional precautions. For example, `f32::NAN != f32::NAN`, which doesn't fulfill the\n reflexivity requirement of [`Ord`]. By using an alternative comparison function with\n `slice::sort_unstable_by` such as [`f32::total_cmp`] or [`f64::total_cmp`] that defines a\n [total order] users can sort slices containing floating-point values. Alternatively, if all\n values in the slice are guaranteed to be in a subset for which [`PartialOrd::partial_cmp`]\n forms a [total order], it's possible to sort the slice with `sort_unstable_by(|a, b|\n a.partial_cmp(b).unwrap())`.\n\n # Current implementation\n\n The current implementation is based on [ipnsort] by Lukas Bergdoll and Orson Peters, which\n combines the fast average case of quicksort with the fast worst case of heapsort, achieving\n linear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\n expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n It is typically faster than stable sorting, except in a few special cases, e.g., when the\n slice is partially sorted.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `T` does not implement a [total order], or if\n the [`Ord`] implementation panics.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n\n v.sort_unstable();\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::ops::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps two elements in the slice.\n\n If `a` equals to `b`, it's guaranteed that elements won't change value.\n\n # Arguments\n\n * a - The index of the first element\n * b - The index of the second element\n\n # Panics\n\n Panics if `a` or `b` are out of bounds.\n\n # Examples\n\n ```\n let mut v = [\"a\", \"b\", \"c\", \"d\", \"e\"];\n v.swap(2, 4);\n assert!(v == [\"a\", \"b\", \"e\", \"d\", \"c\"]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain"
    ],
    "core::iter::Enumerate": [
      "Plain"
    ],
    "vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": 126,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:312:5: 356:6",
  "src": "pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n    where\n        F: FnMut(&T) -> K,\n        K: Ord,\n    {\n        // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n        macro_rules! sort_by_key {\n            ($t:ty, $slice:ident, $f:ident) => {{\n                let mut indices: Vec<_> =\n                    $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                // The elements of `indices` are unique, as they are indexed, so any sort will be\n                // stable with respect to the original slice. We use `sort_unstable` here because\n                // it requires no memory allocation.\n                indices.sort_unstable();\n                for i in 0..$slice.len() {\n                    let mut index = indices[i].1;\n                    while (index as usize) < i {\n                        index = indices[index as usize].1;\n                    }\n                    indices[i].1 = index;\n                    $slice.swap(i, index as usize);\n                }\n            }};\n        }\n\n        let len = self.len();\n        if len < 2 {\n            return;\n        }\n\n        // Avoids binary-size usage in cases where the alignment doesn't work out to make this\n        // beneficial or on 32-bit platforms.\n        let is_using_u32_as_idx_type_helpful =\n            const { size_of::<(K, u32)>() < size_of::<(K, usize)>() };\n\n        // It's possible to instantiate this for u8 and u16 but, doing so is very wasteful in terms\n        // of compile-times and binary-size, the peak saved heap memory for u16 is (u8 + u16) -> 4\n        // bytes * u16::MAX vs (u8 + u32) -> 8 bytes * u16::MAX, the saved heap memory is at peak\n        // ~262KB.\n        if is_using_u32_as_idx_type_helpful && len <= (u32::MAX as usize) {\n            return sort_by_key!(u32, self, f);\n        }\n\n        sort_by_key!(usize, self, f)\n    }",
  "mir": "fn slice::<impl [T]>::sort_by_cached_key(_1: &mut [T], _2: F) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &[T];\n    let mut _5: bool;\n    let mut _6: bool;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: vec::Vec<(K, u32)>;\n    let mut _10: core::iter::Map<core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}>;\n    let mut _11: core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>>;\n    let mut _12: core::iter::Map<core::slice::Iter<'_, T>, F>;\n    let mut _13: core::slice::Iter<'_, T>;\n    let mut _14: &[T];\n    let mut _15: F;\n    let  _16: ();\n    let mut _17: &mut [(K, u32)];\n    let mut _18: &mut vec::Vec<(K, u32)>;\n    let mut _19: core::ops::Range<usize>;\n    let mut _20: core::ops::Range<usize>;\n    let mut _21: usize;\n    let mut _22: &[T];\n    let mut _23: core::ops::Range<usize>;\n    let mut _24: core::option::Option<usize>;\n    let mut _25: &mut core::ops::Range<usize>;\n    let mut _26: isize;\n    let  _27: usize;\n    let mut _28: u32;\n    let mut _29: &(K, u32);\n    let mut _30: &vec::Vec<(K, u32)>;\n    let mut _31: bool;\n    let mut _32: usize;\n    let mut _33: u32;\n    let mut _34: u32;\n    let mut _35: &(K, u32);\n    let mut _36: &vec::Vec<(K, u32)>;\n    let mut _37: usize;\n    let mut _38: u32;\n    let mut _39: u32;\n    let mut _40: &mut (K, u32);\n    let mut _41: &mut vec::Vec<(K, u32)>;\n    let  _42: ();\n    let mut _43: usize;\n    let mut _44: u32;\n    let mut _45: vec::Vec<(K, usize)>;\n    let mut _46: core::iter::Map<core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}>;\n    let mut _47: core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>>;\n    let mut _48: core::iter::Map<core::slice::Iter<'_, T>, F>;\n    let mut _49: core::slice::Iter<'_, T>;\n    let mut _50: &[T];\n    let mut _51: F;\n    let  _52: ();\n    let mut _53: &mut [(K, usize)];\n    let mut _54: &mut vec::Vec<(K, usize)>;\n    let mut _55: core::ops::Range<usize>;\n    let mut _56: core::ops::Range<usize>;\n    let mut _57: usize;\n    let mut _58: &[T];\n    let mut _59: core::ops::Range<usize>;\n    let mut _60: core::option::Option<usize>;\n    let mut _61: &mut core::ops::Range<usize>;\n    let mut _62: isize;\n    let  _63: usize;\n    let mut _64: usize;\n    let mut _65: &(K, usize);\n    let mut _66: &vec::Vec<(K, usize)>;\n    let mut _67: bool;\n    let mut _68: usize;\n    let mut _69: usize;\n    let mut _70: &(K, usize);\n    let mut _71: &vec::Vec<(K, usize)>;\n    let mut _72: usize;\n    let mut _73: usize;\n    let mut _74: &mut (K, usize);\n    let mut _75: &mut vec::Vec<(K, usize)>;\n    let  _76: ();\n    let mut _77: usize;\n    let mut _78: bool;\n    debug self => _1;\n    debug f => _2;\n    debug len => _3;\n    debug is_using_u32_as_idx_type_helpful => slice::<impl [T]>::sort_by_cached_key::<K, F>::{constant#0};\n    debug indices => _9;\n    debug iter => _23;\n    debug i => _27;\n    debug index => _28;\n    debug indices => _45;\n    debug iter => _59;\n    debug i => _63;\n    debug index => _64;\n    bb0: {\n        _78 = false;\n        _78 = true;\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = Lt(_3, 2_usize);\n        switchInt(move _5) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        goto -> bb48;\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = slice::<impl [T]>::sort_by_cached_key::<K, F>::{constant#0};\n        switchInt(move _6) -> [0: bb27, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = core::num::<impl u32>::MAX as usize;\n        _7 = Le(_3, move _8);\n        switchInt(move _7) -> [0: bb26, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_1);\n        _13 = core::slice::<impl [T]>::iter(move _14) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageLive(_15);\n        _78 = false;\n        _15 = move _2;\n        _12 = <core::slice::Iter<'_, T> as core::iter::Iterator>::map::<K, F>(move _13, move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        StorageDead(_13);\n        _11 = <core::iter::Map<core::slice::Iter<'_, T>, F> as core::iter::Iterator>::enumerate(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _10 = <core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>> as core::iter::Iterator>::map::<(K, u32), {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}>(move _11, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _9 = <core::iter::Map<core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}> as core::iter::Iterator>::collect::<vec::Vec<(K, u32)>>(move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageLive(_18);\n        _18 = &mut _9;\n        _17 = <vec::Vec<(K, u32)> as core::ops::DerefMut>::deref_mut(move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        _16 = core::slice::<impl [(K, u32)]>::sort_unstable(_17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _21 = PtrMetadata(move _22);\n        StorageDead(_22);\n        _20 = Range(0_usize, move _21);\n        StorageDead(_21);\n        _19 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = move _19;\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_24);\n        _25 = &mut _23;\n        _24 = <core::ops::Range<usize> as core::iter::Iterator>::next(_25) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _26 = discriminant(_24);\n        switchInt(move _26) -> [0: bb17, 1: bb16, otherwise: bb15];\n    }\n    bb15: {\n        unreachable;\n    }\n    bb16: {\n        _27 = ((_24 as variant#1).0: usize);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_9;\n        _29 = <vec::Vec<(K, u32)> as core::ops::Index<usize>>::index(move _30, _27) -> [return: bb18, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_19);\n        drop(_9) -> [return: bb25, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        _28 = ((*_29).1: u32);\n        StorageDead(_29);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = _28;\n        _32 = move _33 as usize;\n        StorageDead(_33);\n        _31 = Lt(move _32, _27);\n        switchInt(move _31) -> [0: bb22, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_32);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &_9;\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _28;\n        _37 = move _38 as usize;\n        StorageDead(_38);\n        _35 = <vec::Vec<(K, u32)> as core::ops::Index<usize>>::index(move _36, move _37) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_37);\n        StorageDead(_36);\n        _34 = ((*_35).1: u32);\n        _28 = move _34;\n        StorageDead(_34);\n        StorageDead(_35);\n        StorageDead(_31);\n        goto -> bb19;\n    }\n    bb22: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_39);\n        _39 = _28;\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &mut _9;\n        _40 = <vec::Vec<(K, u32)> as core::ops::IndexMut<usize>>::index_mut(move _41, _27) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_41);\n        ((*_40).1: u32) = move _39;\n        StorageDead(_39);\n        StorageDead(_40);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = _28;\n        _43 = move _44 as usize;\n        StorageDead(_44);\n        _42 = core::slice::<impl [T]>::swap(_1, _27, move _43) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_43);\n        StorageDead(_28);\n        StorageDead(_24);\n        goto -> bb13;\n    }\n    bb25: {\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb48;\n    }\n    bb26: {\n        StorageDead(_8);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = &(*_1);\n        _49 = core::slice::<impl [T]>::iter(move _50) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_50);\n        StorageLive(_51);\n        _78 = false;\n        _51 = move _2;\n        _48 = <core::slice::Iter<'_, T> as core::iter::Iterator>::map::<K, F>(move _49, move _51) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_51);\n        StorageDead(_49);\n        _47 = <core::iter::Map<core::slice::Iter<'_, T>, F> as core::iter::Iterator>::enumerate(move _48) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_48);\n        _46 = <core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>> as core::iter::Iterator>::map::<(K, usize), {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}>(move _47, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_47);\n        _45 = <core::iter::Map<core::iter::Enumerate<core::iter::Map<core::slice::Iter<'_, T>, F>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:321:59: 321:67}> as core::iter::Iterator>::collect::<vec::Vec<(K, usize)>>(move _46) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_46);\n        StorageLive(_54);\n        _54 = &mut _45;\n        _53 = <vec::Vec<(K, usize)> as core::ops::DerefMut>::deref_mut(move _54) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_54);\n        _52 = core::slice::<impl [(K, usize)]>::sort_unstable(_53) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = &(*_1);\n        _57 = PtrMetadata(move _58);\n        StorageDead(_58);\n        _56 = Range(0_usize, move _57);\n        StorageDead(_57);\n        _55 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(move _56) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_56);\n        StorageLive(_59);\n        _59 = move _55;\n        goto -> bb36;\n    }\n    bb36: {\n        StorageLive(_60);\n        _61 = &mut _59;\n        _60 = <core::ops::Range<usize> as core::iter::Iterator>::next(_61) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _62 = discriminant(_60);\n        switchInt(move _62) -> [0: bb39, 1: bb38, otherwise: bb15];\n    }\n    bb38: {\n        _63 = ((_60 as variant#1).0: usize);\n        StorageLive(_64);\n        StorageLive(_65);\n        StorageLive(_66);\n        _66 = &_45;\n        _65 = <vec::Vec<(K, usize)> as core::ops::Index<usize>>::index(move _66, _63) -> [return: bb40, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_55);\n        drop(_45) -> [return: bb47, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_66);\n        _64 = ((*_65).1: usize);\n        StorageDead(_65);\n        goto -> bb41;\n    }\n    bb41: {\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = _64;\n        _67 = Lt(move _68, _63);\n        switchInt(move _67) -> [0: bb44, otherwise: bb42];\n    }\n    bb42: {\n        StorageDead(_68);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = &_45;\n        StorageLive(_72);\n        _72 = _64;\n        _70 = <vec::Vec<(K, usize)> as core::ops::Index<usize>>::index(move _71, move _72) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_72);\n        StorageDead(_71);\n        _69 = ((*_70).1: usize);\n        _64 = move _69;\n        StorageDead(_69);\n        StorageDead(_70);\n        StorageDead(_67);\n        goto -> bb41;\n    }\n    bb44: {\n        StorageDead(_68);\n        StorageDead(_67);\n        StorageLive(_73);\n        _73 = _64;\n        StorageLive(_74);\n        StorageLive(_75);\n        _75 = &mut _45;\n        _74 = <vec::Vec<(K, usize)> as core::ops::IndexMut<usize>>::index_mut(move _75, _63) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_75);\n        ((*_74).1: usize) = move _73;\n        StorageDead(_73);\n        StorageDead(_74);\n        StorageLive(_77);\n        _77 = _64;\n        _76 = core::slice::<impl [T]>::swap(_1, _63, move _77) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_77);\n        StorageDead(_64);\n        StorageDead(_60);\n        goto -> bb36;\n    }\n    bb47: {\n        StorageDead(_45);\n        goto -> bb49;\n    }\n    bb48: {\n        switchInt(_78) -> [0: bb49, otherwise: bb50];\n    }\n    bb49: {\n        return;\n    }\n    bb50: {\n        drop(_2) -> [return: bb49, unwind unreachable];\n    }\n}\n",
  "doc": " Sorts the slice in ascending order with a key extraction function, preserving initial order\n of equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* + *n* \\*\n log(*n*)) worst-case, where the key function is *O*(*m*).\n\n During sorting, the key function is called at most once per element, by using temporary\n storage to remember the results of key evaluation. The order of calls to the key function is\n unspecified and may change in future versions of the standard library.\n\n If the implementation of [`Ord`] for `K` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n For simple key functions (e.g., functions that are property accesses or basic operations),\n [`sort_by_key`](slice::sort_by_key) is likely to be faster.\n\n # Current implementation\n\n The current implementation is based on [instruction-parallel-network sort][ipnsort] by Lukas\n Bergdoll, which combines the fast average case of randomized quicksort with the fast worst\n case of heapsort, while achieving linear time on fully sorted and reversed inputs. And\n *O*(*k* \\* log(*n*)) where *k* is the number of distinct elements in the input. It leverages\n superscalar out-of-order execution capabilities commonly found in CPUs, to efficiently\n perform the operation.\n\n In the worst case, the algorithm allocates temporary storage in a `Vec<(K, usize)>` the\n length of the slice.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `K` does not implement a [total order], or if\n the [`Ord`] implementation panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4i32, -5, 1, -3, 2, 10];\n\n // Strings are sorted by lexicographical order.\n v.sort_by_cached_key(|k| k.to_string());\n assert_eq!(v, [-3, -5, 1, 10, 2, 4]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}