{
  "name": "collections::vec_deque::VecDeque::<T, A>::as_slices",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::slice_ranges": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given a range into the logical buffer of the deque, this function\n return two ranges into the physical buffer that correspond to\n the given range. The `len` parameter should usually just be `self.len`;\n the reason it's passed explicitly is that if the deque is wrapped in\n a `Drain`, then `self.len` is not actually the length of the deque.\n\n # Safety\n\n This function is always safe to call. For the resulting ranges to be valid\n ranges into the physical buffer, the caller must ensure that the result of\n calling `slice::range(range, ..len)` represents a valid range into the\n logical buffer, and that all elements in that range are initialized.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument",
        "core::ops::Range": "Constructor"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::buffer_range": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a slice pointer into the buffer.\n `range` must lie inside `0..self.capacity()`.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1762, kind: RigidTy(Adt(AdtDef(DefId { id: 3232, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Field(1, Ty { id: 1762, kind: RigidTy(Adt(AdtDef(DefId { id: 3232, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])"
    ]
  },
  "path": 1456,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1556:5: 1561:6",
  "src": "pub fn as_slices(&self) -> (&[T], &[T]) {\n        let (a_range, b_range) = self.slice_ranges(.., self.len);\n        // SAFETY: `slice_ranges` always returns valid ranges into\n        // the physical buffer.\n        unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::as_slices(_1: &collections::vec_deque::VecDeque<T, A>) -> (&[T], &[T]) {\n    let mut _0: (&[T], &[T]);\n    let  _2: core::ops::Range<usize>;\n    let  _3: core::ops::Range<usize>;\n    let mut _4: (core::ops::Range<usize>, core::ops::Range<usize>);\n    let mut _5: usize;\n    let  _6: &[T];\n    let  _7: *mut [T];\n    let  _8: &[T];\n    let  _9: *mut [T];\n    debug self => _1;\n    debug a_range => _2;\n    debug b_range => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).1: usize);\n        _4 = collections::vec_deque::VecDeque::<T, A>::slice_ranges::<core::ops::RangeFull>(_1, core::ops::RangeFull, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _2 = move (_4.0: core::ops::Range<usize>);\n        _3 = move (_4.1: core::ops::Range<usize>);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = collections::vec_deque::VecDeque::<T, A>::buffer_range(_1, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = &(*_7);\n        StorageLive(_9);\n        _9 = collections::vec_deque::VecDeque::<T, A>::buffer_range(_1, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &(*_9);\n        _0 = (_6, _8);\n        StorageDead(_9);\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}