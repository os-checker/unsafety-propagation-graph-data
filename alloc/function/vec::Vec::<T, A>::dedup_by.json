{
  "name": "vec::Vec::<T, A>::dedup_by",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::num::<impl usize>::wrapping_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) subtraction. Computes `self - rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::mem::forget": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes ownership and \"forgets\" about the value **without running its destructor**.\n\n Any resources the value manages, such as heap memory or a file handle, will linger\n forever in an unreachable state. However, it does not guarantee that pointers\n to this memory will remain valid.\n\n * If you want to leak memory, see [`Box::leak`].\n * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n * If you want to dispose of a value properly, running its destructor, see\n   [`mem::drop`].\n\n # Safety\n\n `forget` is not marked as `unsafe`, because Rust's safety guarantees\n do not include a guarantee that destructors will always run. For example,\n a program can create a reference cycle using [`Rc`][rc], or call\n [`process::exit`][exit] to exit without running destructors. Thus, allowing\n `mem::forget` from safe code does not fundamentally change Rust's safety\n guarantees.\n\n That said, leaking resources such as memory or I/O objects is usually undesirable.\n The need comes up in some specialized use cases for FFI or unsafe code, but even\n then, [`ManuallyDrop`] is typically preferred.\n\n Because forgetting a value is allowed, any `unsafe` code you write must\n allow for this possibility. You cannot return a value and expect that the\n caller will necessarily run the value's destructor.\n\n [rc]: ../../std/rc/struct.Rc.html\n [exit]: ../../std/process/fn.exit.html\n\n # Examples\n\n The canonical safe use of `mem::forget` is to circumvent a value's destructor\n implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n the space taken by the variable but never close the underlying system resource:\n\n ```no_run\n use std::mem;\n use std::fs::File;\n\n let file = File::open(\"foo.txt\").unwrap();\n mem::forget(file);\n ```\n\n This is useful when the ownership of the underlying resource was previously\n transferred to code outside of Rust, for example by transmitting the raw\n file descriptor to C code.\n\n # Relationship with `ManuallyDrop`\n\n While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n\n ```\n use std::mem;\n\n let mut v = vec![65, 122];\n // Build a `String` using the contents of `v`\n let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n // leak `v` because its memory is now managed by `s`\n mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n There are two issues with the above example:\n\n * If more code were added between the construction of `String` and the invocation of\n   `mem::forget()`, a panic within it would cause a double free because the same memory\n   is handled by both `v` and `s`.\n * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n   inspect it), some types have strict requirements on their values that\n   make them invalid when dangling or no longer owned. Using invalid values in any\n   way, including passing them to or returning them from functions, constitutes\n   undefined behavior and may break the assumptions made by the compiler.\n\n Switching to `ManuallyDrop` avoids both issues:\n\n ```\n use std::mem::ManuallyDrop;\n\n let v = vec![65, 122];\n // Before we disassemble `v` into its raw parts, make sure it\n // does not get dropped!\n let mut v = ManuallyDrop::new(v);\n // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n // Finally, build a `String`.\n let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n argument, forcing us to call it only after extracting anything we need from `v`. Even\n if a panic were introduced between construction of `ManuallyDrop` and building the\n string (which cannot happen in the code as shown), it would result in a leak and not a\n double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n erring on the side of (double-)dropping.\n\n Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n ownership to `s` â€” the final step of interacting with `v` to dispose of it without\n running its destructor is entirely avoided.\n\n [`Box`]: ../../std/boxed/struct.Box.html\n [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n [`mem::drop`]: drop\n [ub]: ../../reference/behavior-considered-undefined.html\n",
      "adt": {}
    }
  },
  "adts": {
    "vec::Vec": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "vec::Vec<T, A>::dedup_by::FillGapOnDrop": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(2, Ty { id: 1989, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 642, kind: RigidTy(Adt(AdtDef(DefId { id: 2824, name: \"vec::Vec\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }), Type(Ty { id: 21, kind: Param(ParamTy { index: 1, name: \"A\" }) })]))) }, Mut)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::vec::Vec::<T, A>::dedup_by"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2373:5: 2499:6",
  "src": "pub fn dedup_by<F>(&mut self, mut same_bucket: F)\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n        let len = self.len();\n        if len <= 1 {\n            return;\n        }\n\n        // Check if we ever want to remove anything.\n        // This allows to use copy_non_overlapping in next cycle.\n        // And avoids any memory writes if we don't need to remove anything.\n        let mut first_duplicate_idx: usize = 1;\n        let start = self.as_mut_ptr();\n        while first_duplicate_idx != len {\n            let found_duplicate = unsafe {\n                // SAFETY: first_duplicate always in range [1..len)\n                // Note that we start iteration from 1 so we never overflow.\n                let prev = start.add(first_duplicate_idx.wrapping_sub(1));\n                let current = start.add(first_duplicate_idx);\n                // We explicitly say in docs that references are reversed.\n                same_bucket(&mut *current, &mut *prev)\n            };\n            if found_duplicate {\n                break;\n            }\n            first_duplicate_idx += 1;\n        }\n        // Don't need to remove anything.\n        // We cannot get bigger than len.\n        if first_duplicate_idx == len {\n            return;\n        }\n\n        /* INVARIANT: vec.len() > read > write > write-1 >= 0 */\n        struct FillGapOnDrop<'a, T, A: core::alloc::Allocator> {\n            /* Offset of the element we want to check if it is duplicate */\n            read: usize,\n\n            /* Offset of the place where we want to place the non-duplicate\n             * when we find it. */\n            write: usize,\n\n            /* The Vec that would need correction if `same_bucket` panicked */\n            vec: &'a mut Vec<T, A>,\n        }\n\n        impl<'a, T, A: core::alloc::Allocator> Drop for FillGapOnDrop<'a, T, A> {\n            fn drop(&mut self) {\n                /* This code gets executed when `same_bucket` panics */\n\n                /* SAFETY: invariant guarantees that `read - write`\n                 * and `len - read` never overflow and that the copy is always\n                 * in-bounds. */\n                unsafe {\n                    let ptr = self.vec.as_mut_ptr();\n                    let len = self.vec.len();\n\n                    /* How many items were left when `same_bucket` panicked.\n                     * Basically vec[read..].len() */\n                    let items_left = len.wrapping_sub(self.read);\n\n                    /* Pointer to first item in vec[write..write+items_left] slice */\n                    let dropped_ptr = ptr.add(self.write);\n                    /* Pointer to first item in vec[read..] slice */\n                    let valid_ptr = ptr.add(self.read);\n\n                    /* Copy `vec[read..]` to `vec[write..write+items_left]`.\n                     * The slices can overlap, so `copy_nonoverlapping` cannot be used */\n                    ptr::copy(valid_ptr, dropped_ptr, items_left);\n\n                    /* How many items have been already dropped\n                     * Basically vec[read..write].len() */\n                    let dropped = self.read.wrapping_sub(self.write);\n\n                    self.vec.set_len(len - dropped);\n                }\n            }\n        }\n\n        /* Drop items while going through Vec, it should be more efficient than\n         * doing slice partition_dedup + truncate */\n\n        // Construct gap first and then drop item to avoid memory corruption if `T::drop` panics.\n        let mut gap =\n            FillGapOnDrop { read: first_duplicate_idx + 1, write: first_duplicate_idx, vec: self };\n        unsafe {\n            // SAFETY: we checked that first_duplicate_idx in bounds before.\n            // If drop panics, `gap` would remove this item without drop.\n            ptr::drop_in_place(start.add(first_duplicate_idx));\n        }\n\n        /* SAFETY: Because of the invariant, read_ptr, prev_ptr and write_ptr\n         * are always in-bounds and read_ptr never aliases prev_ptr */\n        unsafe {\n            while gap.read < len {\n                let read_ptr = start.add(gap.read);\n                let prev_ptr = start.add(gap.write.wrapping_sub(1));\n\n                // We explicitly say in docs that references are reversed.\n                let found_duplicate = same_bucket(&mut *read_ptr, &mut *prev_ptr);\n                if found_duplicate {\n                    // Increase `gap.read` now since the drop may panic.\n                    gap.read += 1;\n                    /* We have found duplicate, drop it in-place */\n                    ptr::drop_in_place(read_ptr);\n                } else {\n                    let write_ptr = start.add(gap.write);\n\n                    /* read_ptr cannot be equal to write_ptr because at this point\n                     * we guaranteed to skip at least one element (before loop starts).\n                     */\n                    ptr::copy_nonoverlapping(read_ptr, write_ptr, 1);\n\n                    /* We have filled that place, so go further */\n                    gap.write += 1;\n                    gap.read += 1;\n                }\n            }\n\n            /* Technically we could let `gap` clean up with its Drop, but\n             * when `same_bucket` is guaranteed to not panic, this bloats a little\n             * the codegen, so we just do it manually */\n            gap.vec.set_len(gap.write);\n            mem::forget(gap);\n        }\n    }",
  "mir": "fn vec::Vec::<T, A>::dedup_by(_1: &mut vec::Vec<T, A>, _2: F) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &vec::Vec<T, A>;\n    let mut _5: bool;\n    let mut _6: usize;\n    let  _7: *mut T;\n    let mut _8: bool;\n    let mut _9: usize;\n    let  _10: bool;\n    let  _11: *mut T;\n    let mut _12: usize;\n    let mut _13: usize;\n    let  _14: *mut T;\n    let mut _15: usize;\n    let mut _16: &mut F;\n    let mut _17: (&mut T, &mut T);\n    let mut _18: &mut T;\n    let mut _19: &mut T;\n    let mut _20: (usize, bool);\n    let mut _21: bool;\n    let mut _22: usize;\n    let mut _23: vec::Vec<T, A>::dedup_by::FillGapOnDrop<'_, T, A>;\n    let mut _24: usize;\n    let mut _25: usize;\n    let mut _26: (usize, bool);\n    let mut _27: usize;\n    let  _28: ();\n    let mut _29: *mut T;\n    let mut _30: usize;\n    let mut _31: bool;\n    let mut _32: usize;\n    let  _33: *mut T;\n    let mut _34: usize;\n    let  _35: *mut T;\n    let mut _36: usize;\n    let mut _37: usize;\n    let  _38: bool;\n    let mut _39: &mut F;\n    let mut _40: (&mut T, &mut T);\n    let mut _41: &mut T;\n    let mut _42: &mut T;\n    let mut _43: (usize, bool);\n    let  _44: ();\n    let  _45: *mut T;\n    let mut _46: usize;\n    let  _47: ();\n    let mut _48: *const T;\n    let mut _49: (usize, bool);\n    let mut _50: (usize, bool);\n    let  _51: ();\n    let mut _52: usize;\n    let  _53: ();\n    let mut _54: vec::Vec<T, A>::dedup_by::FillGapOnDrop<'_, T, A>;\n    let mut _55: &mut vec::Vec<T, A>;\n    debug self => _1;\n    debug same_bucket => _2;\n    debug len => _3;\n    debug first_duplicate_idx => _6;\n    debug start => _7;\n    debug found_duplicate => _10;\n    debug prev => _11;\n    debug current => _14;\n    debug gap => _23;\n    debug read_ptr => _33;\n    debug prev_ptr => _35;\n    debug found_duplicate => _38;\n    debug write_ptr => _45;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = vec::Vec::<T, A>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = Le(_3, 1_usize);\n        switchInt(move _5) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        goto -> bb39;\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = 1_usize;\n        _7 = vec::Vec::<T, A>::as_mut_ptr(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = _6;\n        _8 = Ne(move _9, _3);\n        switchInt(move _8) -> [0: bb14, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = _6;\n        _12 = core::num::<impl usize>::wrapping_sub(move _13, 1_usize) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        _11 = core::ptr::mut_ptr::<impl *mut T>::add(_7, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _6;\n        _14 = core::ptr::mut_ptr::<impl *mut T>::add(_7, move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = &mut _2;\n        StorageLive(_17);\n        _18 = &mut (*_14);\n        _19 = &mut (*_11);\n        _17 = (_18, _19);\n        _10 = <F as core::ops::FnMut<(&mut T, &mut T)>>::call_mut(move _16, move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_11);\n        switchInt(_10) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        goto -> bb15;\n    }\n    bb12: {\n        _20 = CheckedAdd(_6, 1_usize);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _6 = move (_20.0: usize);\n        StorageDead(_8);\n        goto -> bb5;\n    }\n    bb14: {\n        StorageDead(_9);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_8);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _6;\n        _21 = Eq(move _22, _3);\n        switchInt(move _21) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_6);\n        goto -> bb39;\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _6;\n        _26 = CheckedAdd(_25, 1_usize);\n        assert(!move (_26.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _25, 1_usize) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _24 = move (_26.0: usize);\n        StorageDead(_25);\n        StorageLive(_27);\n        _27 = _6;\n        _23 = FillGapOnDrop(move _24, move _27, _1);\n        StorageDead(_27);\n        StorageDead(_24);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _6;\n        _29 = core::ptr::mut_ptr::<impl *mut T>::add(_7, move _30) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_30);\n        _28 = core::ptr::drop_in_place::<T>(move _29) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_29);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = (_23.0: usize);\n        _31 = Lt(move _32, _3);\n        switchInt(move _31) -> [0: bb36, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_32);\n        StorageLive(_34);\n        _34 = (_23.0: usize);\n        _33 = core::ptr::mut_ptr::<impl *mut T>::add(_7, move _34) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = (_23.1: usize);\n        _36 = core::num::<impl usize>::wrapping_sub(move _37, 1_usize) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_37);\n        _35 = core::ptr::mut_ptr::<impl *mut T>::add(_7, move _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        StorageLive(_39);\n        _39 = &mut _2;\n        StorageLive(_40);\n        _41 = &mut (*_33);\n        _42 = &mut (*_35);\n        _40 = (_41, _42);\n        _38 = <F as core::ops::FnMut<(&mut T, &mut T)>>::call_mut(move _39, move _40) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_40);\n        StorageDead(_39);\n        switchInt(_38) -> [0: bb30, otherwise: bb27];\n    }\n    bb27: {\n        _43 = CheckedAdd((_23.0: usize), 1_usize);\n        assert(!move (_43.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (_23.0: usize), 1_usize) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        (_23.0: usize) = move (_43.0: usize);\n        _44 = core::ptr::drop_in_place::<T>(_33) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        goto -> bb35;\n    }\n    bb30: {\n        StorageLive(_46);\n        _46 = (_23.1: usize);\n        _45 = core::ptr::mut_ptr::<impl *mut T>::add(_7, move _46) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_46);\n        StorageLive(_48);\n        _48 = _33 as *const T;\n        _47 = core::ptr::copy_nonoverlapping::<T>(move _48, _45, 1_usize) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_48);\n        _49 = CheckedAdd((_23.1: usize), 1_usize);\n        assert(!move (_49.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (_23.1: usize), 1_usize) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        (_23.1: usize) = move (_49.0: usize);\n        _50 = CheckedAdd((_23.0: usize), 1_usize);\n        assert(!move (_50.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (_23.0: usize), 1_usize) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        (_23.0: usize) = move (_50.0: usize);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_35);\n        StorageDead(_31);\n        goto -> bb21;\n    }\n    bb36: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _55 = (_23.2: &mut vec::Vec<T, A>);\n        StorageLive(_52);\n        _52 = (_23.1: usize);\n        _51 = vec::Vec::<T, A>::set_len(_55, move _52) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_52);\n        StorageLive(_54);\n        _54 = move _23;\n        _53 = core::mem::forget::<vec::Vec<T, A>::dedup_by::FillGapOnDrop<'_, T, A>>(move _54) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_54);\n        StorageDead(_23);\n        StorageDead(_6);\n        drop(_2) -> [return: bb40, unwind unreachable];\n    }\n    bb39: {\n        drop(_2) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        return;\n    }\n}\n",
  "doc": " Removes all but the first of consecutive elements in the vector satisfying a given equality\n relation.\n\n The `same_bucket` function is passed references to two elements from the vector and\n must determine if the elements compare equal. The elements are passed in opposite order\n from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is removed.\n\n If the vector is sorted, this removes all duplicates.\n\n # Examples\n\n ```\n let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n\n vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n\n assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}