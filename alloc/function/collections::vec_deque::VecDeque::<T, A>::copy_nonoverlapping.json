{
  "name": "collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping",
  "safe": false,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marginally more convenient\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:350:5: 370:6",
  "src": "unsafe fn copy_nonoverlapping(&mut self, src: usize, dst: usize, len: usize) {\n        debug_assert!(\n            dst + len <= self.capacity(),\n            \"cno dst={} src={} len={} cap={}\",\n            dst,\n            src,\n            len,\n            self.capacity()\n        );\n        debug_assert!(\n            src + len <= self.capacity(),\n            \"cno dst={} src={} len={} cap={}\",\n            dst,\n            src,\n            len,\n            self.capacity()\n        );\n        unsafe {\n            ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);\n        }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize, _3: usize, _4: usize) -> () {\n    let mut _0: ();\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: (usize, bool);\n    let mut _8: usize;\n    let mut _9: &collections::vec_deque::VecDeque<T, A>;\n    let  _10: !;\n    let mut _11: core::fmt::Arguments<'_>;\n    let  _12: (&usize, &usize, &usize, &usize);\n    let mut _13: &usize;\n    let mut _14: &usize;\n    let mut _15: &usize;\n    let mut _16: &usize;\n    let  _17: usize;\n    let mut _18: &collections::vec_deque::VecDeque<T, A>;\n    let  _19: [core::fmt::rt::Argument<'_>; 4];\n    let mut _20: core::fmt::rt::Argument<'_>;\n    let mut _21: core::fmt::rt::Argument<'_>;\n    let mut _22: core::fmt::rt::Argument<'_>;\n    let mut _23: core::fmt::rt::Argument<'_>;\n    let mut _24: &[u8; 32];\n    let  _25: &[core::fmt::rt::Argument<'_>; 4];\n    let mut _26: bool;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let mut _29: usize;\n    let mut _30: &collections::vec_deque::VecDeque<T, A>;\n    let  _31: !;\n    let mut _32: core::fmt::Arguments<'_>;\n    let  _33: (&usize, &usize, &usize, &usize);\n    let mut _34: &usize;\n    let mut _35: &usize;\n    let mut _36: &usize;\n    let mut _37: &usize;\n    let  _38: usize;\n    let mut _39: &collections::vec_deque::VecDeque<T, A>;\n    let  _40: [core::fmt::rt::Argument<'_>; 4];\n    let mut _41: core::fmt::rt::Argument<'_>;\n    let mut _42: core::fmt::rt::Argument<'_>;\n    let mut _43: core::fmt::rt::Argument<'_>;\n    let mut _44: core::fmt::rt::Argument<'_>;\n    let mut _45: &[u8; 32];\n    let  _46: &[core::fmt::rt::Argument<'_>; 4];\n    let  _47: ();\n    let mut _48: *const T;\n    let mut _49: *mut T;\n    let mut _50: *mut T;\n    let mut _51: &collections::vec_deque::VecDeque<T, A>;\n    let mut _52: *mut T;\n    let mut _53: *mut T;\n    let mut _54: &collections::vec_deque::VecDeque<T, A>;\n    let mut _55: &usize;\n    let mut _56: &usize;\n    let mut _57: &usize;\n    let mut _58: &usize;\n    let mut _59: &usize;\n    let mut _60: &usize;\n    let mut _61: &usize;\n    let mut _62: &usize;\n    debug self => _1;\n    debug src => _2;\n    debug dst => _3;\n    debug len => _4;\n    debug args => _12;\n    debug args => _19;\n    debug args => _33;\n    debug args => _40;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _7 = CheckedAdd(_3, _4);\n        assert(!move (_7.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, _4) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = move (_7.0: usize);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_1);\n        _8 = collections::vec_deque::VecDeque::<T, A>::capacity(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        _5 = Le(move _6, move _8);\n        switchInt(move _5) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_26);\n        StorageLive(_27);\n        _28 = CheckedAdd(_2, _4);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _4) -> [success: bb11, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_3;\n        StorageLive(_14);\n        _14 = &_2;\n        StorageLive(_15);\n        _15 = &_4;\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &(*_1);\n        _17 = collections::vec_deque::VecDeque::<T, A>::capacity(move _18) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_18);\n        _16 = &_17;\n        _12 = (move _13, move _14, move _15, move _16);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_19);\n        StorageLive(_20);\n        _55 = (_12.0: &usize);\n        _20 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_55) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_21);\n        _56 = (_12.1: &usize);\n        _21 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_56) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_22);\n        _57 = (_12.2: &usize);\n        _22 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_57) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_23);\n        _58 = (_12.3: &usize);\n        _23 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_58) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _19 = [move _20, move _21, move _22, move _23];\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_24);\n        _24 = b\"\\x08cno dst=\\xc0\\x05 src=\\xc0\\x05 len=\\xc0\\x05 cap=\\xc0\\x00\";\n        _25 = &_19;\n        _11 = core::fmt::Arguments::<'_>::new::<32, 4>(move _24, _25) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_24);\n        _10 = core::panicking::panic_fmt(move _11) -> unwind unreachable;\n    }\n    bb11: {\n        _27 = move (_28.0: usize);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &(*_1);\n        _29 = collections::vec_deque::VecDeque::<T, A>::capacity(move _30) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_30);\n        _26 = Le(move _27, move _29);\n        switchInt(move _26) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = &(*_1);\n        _50 = collections::vec_deque::VecDeque::<T, A>::ptr(move _51) -> [return: bb21, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &_3;\n        StorageLive(_35);\n        _35 = &_2;\n        StorageLive(_36);\n        _36 = &_4;\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &(*_1);\n        _38 = collections::vec_deque::VecDeque::<T, A>::capacity(move _39) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_39);\n        _37 = &_38;\n        _33 = (move _34, move _35, move _36, move _37);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_40);\n        StorageLive(_41);\n        _59 = (_33.0: &usize);\n        _41 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_59) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_42);\n        _60 = (_33.1: &usize);\n        _42 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_60) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_43);\n        _61 = (_33.2: &usize);\n        _43 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_61) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_44);\n        _62 = (_33.3: &usize);\n        _44 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_62) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _40 = [move _41, move _42, move _43, move _44];\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageLive(_45);\n        _45 = b\"\\x08cno dst=\\xc0\\x05 src=\\xc0\\x05 len=\\xc0\\x05 cap=\\xc0\\x00\";\n        _46 = &_40;\n        _32 = core::fmt::Arguments::<'_>::new::<32, 4>(move _45, _46) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_45);\n        _31 = core::panicking::panic_fmt(move _32) -> unwind unreachable;\n    }\n    bb21: {\n        StorageDead(_51);\n        _49 = core::ptr::mut_ptr::<impl *mut T>::add(move _50, _2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _48 = move _49 as *const T;\n        StorageDead(_50);\n        StorageDead(_49);\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &(*_1);\n        _53 = collections::vec_deque::VecDeque::<T, A>::ptr(move _54) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_54);\n        _52 = core::ptr::mut_ptr::<impl *mut T>::add(move _53, _3) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_53);\n        _47 = core::ptr::copy_nonoverlapping::<T>(move _48, move _52, _4) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_52);\n        StorageDead(_48);\n        return;\n    }\n}\n",
  "doc": " Copies a contiguous block of memory len long from src to dst\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}