{
  "name": "collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed",
  "safe": false,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marginally more convenient\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed::copy_nonoverlapping_reversed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n See [`ptr::copy_nonoverlapping`].\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:529:5: 552:6",
  "src": "unsafe fn copy_slice_reversed(&mut self, dst: usize, src: &[T]) {\n        /// # Safety\n        ///\n        /// See [`ptr::copy_nonoverlapping`].\n        unsafe fn copy_nonoverlapping_reversed<T>(src: *const T, dst: *mut T, count: usize) {\n            for i in 0..count {\n                unsafe { ptr::copy_nonoverlapping(src.add(count - 1 - i), dst.add(i), 1) };\n            }\n        }\n\n        debug_assert!(src.len() <= self.capacity());\n        let head_room = self.capacity() - dst;\n        if src.len() <= head_room {\n            unsafe {\n                copy_nonoverlapping_reversed(src.as_ptr(), self.ptr().add(dst), src.len());\n            }\n        } else {\n            let (left, right) = src.split_at(src.len() - head_room);\n            unsafe {\n                copy_nonoverlapping_reversed(right.as_ptr(), self.ptr().add(dst), right.len());\n                copy_nonoverlapping_reversed(left.as_ptr(), self.ptr(), left.len());\n            }\n        }\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize, _3: &[T]) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: &collections::vec_deque::VecDeque<T, A>;\n    let mut _8: !;\n    let  _9: usize;\n    let mut _10: usize;\n    let mut _11: &collections::vec_deque::VecDeque<T, A>;\n    let mut _12: (usize, bool);\n    let mut _13: bool;\n    let mut _14: usize;\n    let  _15: ();\n    let mut _16: *const T;\n    let mut _17: *mut T;\n    let mut _18: *mut T;\n    let mut _19: &collections::vec_deque::VecDeque<T, A>;\n    let mut _20: usize;\n    let  _21: &[T];\n    let  _22: &[T];\n    let mut _23: (&[T], &[T]);\n    let mut _24: usize;\n    let mut _25: usize;\n    let mut _26: (usize, bool);\n    let  _27: ();\n    let mut _28: *const T;\n    let mut _29: *mut T;\n    let mut _30: *mut T;\n    let mut _31: &collections::vec_deque::VecDeque<T, A>;\n    let mut _32: usize;\n    let  _33: ();\n    let mut _34: *const T;\n    let mut _35: *mut T;\n    let mut _36: &collections::vec_deque::VecDeque<T, A>;\n    let mut _37: usize;\n    debug self => _1;\n    debug dst => _2;\n    debug src => _3;\n    debug head_room => _9;\n    debug left => _21;\n    debug right => _22;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = PtrMetadata(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = collections::vec_deque::VecDeque::<T, A>::capacity(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _4 = Le(move _5, move _6);\n        switchInt(move _4) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(*_1);\n        _10 = collections::vec_deque::VecDeque::<T, A>::capacity(move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _8 = core::panicking::panic(\"assertion failed: src.len() <= self.capacity()\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_11);\n        _12 = CheckedSub(_10, _2);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _10, _2) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = move (_12.0: usize);\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = PtrMetadata(_3);\n        _13 = Le(move _14, _9);\n        switchInt(move _13) -> [0: bb11, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = core::slice::<impl [T]>::as_ptr(_3) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &(*_1);\n        _18 = collections::vec_deque::VecDeque::<T, A>::ptr(move _19) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_19);\n        _17 = core::ptr::mut_ptr::<impl *mut T>::add(move _18, _2) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = PtrMetadata(_3);\n        _15 = collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed::copy_nonoverlapping_reversed::<T>(move _16, move _17, move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb21;\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = PtrMetadata(_3);\n        _26 = CheckedSub(_25, _9);\n        assert(!move (_26.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _25, _9) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _24 = move (_26.0: usize);\n        StorageDead(_25);\n        _23 = core::slice::<impl [T]>::split_at(_3, move _24) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_24);\n        _21 = (_23.0: &[T]);\n        _22 = (_23.1: &[T]);\n        StorageDead(_23);\n        StorageLive(_28);\n        _28 = core::slice::<impl [T]>::as_ptr(_22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &(*_1);\n        _30 = collections::vec_deque::VecDeque::<T, A>::ptr(move _31) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_31);\n        _29 = core::ptr::mut_ptr::<impl *mut T>::add(move _30, _2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_30);\n        StorageLive(_32);\n        _32 = PtrMetadata(_22);\n        _27 = collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed::copy_nonoverlapping_reversed::<T>(move _28, move _29, move _32) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_32);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageLive(_34);\n        _34 = core::slice::<impl [T]>::as_ptr(_21) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &(*_1);\n        _35 = collections::vec_deque::VecDeque::<T, A>::ptr(move _36) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_36);\n        StorageLive(_37);\n        _37 = PtrMetadata(_21);\n        _33 = collections::vec_deque::VecDeque::<T, A>::copy_slice_reversed::copy_nonoverlapping_reversed::<T>(move _34, move _35, move _37) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_37);\n        StorageDead(_35);\n        StorageDead(_34);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " Copies all values from `src` to `dst` in reversed order, wrapping around if needed.\n Assumes capacity is sufficient.\n Equivalent to calling [`VecDeque::copy_slice`] with a [reversed](https://doc.rust-lang.org/std/primitive.slice.html#method.reverse) slice.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}