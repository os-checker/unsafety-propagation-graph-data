{
  "name": "str::<impl str>::replacen",
  "safe": true,
  "callees": {
    "string::String::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String` with at least the specified capacity.\n\n `String`s have an internal buffer to hold their data. The capacity is\n the length of that buffer, and can be queried with the [`capacity`]\n method. This method creates an empty `String`, but one with an initial\n buffer that can hold at least `capacity` bytes. This is useful when you\n may be appending a bunch of data to the `String`, reducing the number of\n reallocations it needs to do.\n\n [`capacity`]: String::capacity\n\n If the given capacity is `0`, no allocation will occur, and this method\n is identical to the [`new`] method.\n\n [`new`]: String::new\n\n # Panics\n\n Panics if the capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::with_capacity(10);\n\n // The String contains no chars, even though it has capacity for more\n assert_eq!(s.len(), 0);\n\n // These are all done without reallocating...\n let cap = s.capacity();\n for _ in 0..10 {\n     s.push('a');\n }\n\n assert_eq!(s.capacity(), cap);\n\n // ...but this may make the string reallocate\n s.push('a');\n ```\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "core::str::<impl str>::match_indices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the disjoint matches of a pattern within this string\n slice as well as the index that the match starts at.\n\n For matches of `pat` within `self` that overlap, only the indices\n corresponding to the first match are returned.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Iterator behavior\n\n The returned iterator will be a [`DoubleEndedIterator`] if the pattern\n allows a reverse search and forward/reverse search yields the same\n elements. This is true for, e.g., [`char`], but not for `&str`.\n\n If the pattern allows a reverse search but its results might differ\n from a forward search, the [`rmatch_indices`] method can be used.\n\n [`rmatch_indices`]: str::rmatch_indices\n\n # Examples\n\n ```\n let v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n assert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\n let v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\n assert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\n let v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\n assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that yields the first `n` elements, or fewer\n if the underlying iterator ends sooner.\n\n `take(n)` yields elements until `n` elements are yielded or the end of\n the iterator is reached (whichever happens first).\n The returned iterator is a prefix of length `n` if the original iterator\n contains at least `n` elements, otherwise it contains all of the\n (fewer than `n`) elements of the original iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().take(2);\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n `take()` is often used with an infinite iterator, to make it finite:\n\n ```\n let mut iter = (0..).take(3);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n If less than `n` elements are available,\n `take` will limit itself to the size of the underlying iterator:\n\n ```\n let v = [1, 2];\n let mut iter = v.into_iter().take(5);\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Use [`by_ref`] to take from the iterator without consuming it, and then\n continue using the original iterator:\n\n ```\n let mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();\n\n // Take the first two words.\n let hello_world: Vec<_> = words.by_ref().take(2).collect();\n assert_eq!(hello_world, vec![\"hello\", \"world\"]);\n\n // Collect the rest of the words.\n // We can only do this because we used `by_ref` earlier.\n let of_rust: Vec<_> = words.collect();\n assert_eq!(of_rust, vec![\"of\", \"Rust\"]);\n ```\n\n [`by_ref`]: Iterator::by_ref\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unchecked subslice of `str`.\n\n This is the unchecked alternative to indexing the `str`.\n\n # Safety\n\n Callers of this function are responsible that these preconditions are\n satisfied:\n\n * The starting index must not exceed the ending index;\n * Indexes must be within bounds of the original slice;\n * Indexes must lie on UTF-8 sequence boundaries.\n\n Failing that, the returned string slice may reference invalid memory or\n violate the invariants communicated by the `str` type.\n\n # Examples\n\n ```\n let v = \"üóª‚ààüåè\";\n unsafe {\n     assert_eq!(\"üóª\", v.get_unchecked(0..4));\n     assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n     assert_eq!(\"üåè\", v.get_unchecked(7..11));\n }\n ```\n",
      "adt": {}
    },
    "string::String::push_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends a given string slice onto the end of this `String`.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::from(\"foo\");\n\n s.push_str(\"bar\");\n\n assert_eq!(\"foobar\", s);\n ```\n",
      "adt": {
        "string::String": "MutableAsArgument"
      }
    },
    "core::str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"∆íoo\".len(), 4); // fancy f!\n assert_eq!(\"∆íoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "string::String": [
      "Plain",
      "MutRef"
    ],
    "core::str::MatchIndices": [
      "Plain"
    ],
    "core::iter::Take": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8575, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) }])) }), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8575, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) }])) }), Field(1, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) })])"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": 164,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:323:5: 334:6",
  "src": "pub fn replacen<P: Pattern>(&self, pat: P, to: &str, count: usize) -> String {\n        // Hope to reduce the times of re-allocation\n        let mut result = String::with_capacity(32);\n        let mut last_end = 0;\n        for (start, part) in self.match_indices(pat).take(count) {\n            result.push_str(unsafe { self.get_unchecked(last_end..start) });\n            result.push_str(to);\n            last_end = start + part.len();\n        }\n        result.push_str(unsafe { self.get_unchecked(last_end..self.len()) });\n        result\n    }",
  "mir": "fn str::<impl str>::replacen(_1: &str, _2: P, _3: &str, _4: usize) -> string::String {\n    let mut _0: string::String;\n    let mut _5: string::String;\n    let mut _6: usize;\n    let mut _7: core::iter::Take<core::str::MatchIndices<'_, P>>;\n    let mut _8: core::iter::Take<core::str::MatchIndices<'_, P>>;\n    let mut _9: core::str::MatchIndices<'_, P>;\n    let mut _10: core::iter::Take<core::str::MatchIndices<'_, P>>;\n    let mut _11: core::option::Option<(usize, &str)>;\n    let mut _12: &mut core::iter::Take<core::str::MatchIndices<'_, P>>;\n    let mut _13: isize;\n    let  _14: usize;\n    let  _15: &str;\n    let  _16: ();\n    let mut _17: &mut string::String;\n    let  _18: &str;\n    let mut _19: core::ops::Range<usize>;\n    let mut _20: usize;\n    let  _21: ();\n    let mut _22: &mut string::String;\n    let mut _23: usize;\n    let mut _24: (usize, bool);\n    let  _25: ();\n    let mut _26: &mut string::String;\n    let  _27: &str;\n    let mut _28: core::ops::Range<usize>;\n    let mut _29: usize;\n    let mut _30: usize;\n    debug self => _1;\n    debug pat => _2;\n    debug to => _3;\n    debug count => _4;\n    debug result => _5;\n    debug last_end => _6;\n    debug iter => _10;\n    debug start => _14;\n    debug part => _15;\n    bb0: {\n        StorageLive(_5);\n        _5 = string::String::with_capacity(32_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = 0_usize;\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::str::<impl str>::match_indices::<P>(_1, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = <core::str::MatchIndices<'_, P> as core::iter::Iterator>::take(move _9, _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        _7 = <core::iter::Take<core::str::MatchIndices<'_, P>> as core::iter::IntoIterator>::into_iter(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = move _7;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_11);\n        _12 = &mut _10;\n        _11 = <core::iter::Take<core::str::MatchIndices<'_, P>> as core::iter::Iterator>::next(_12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _14 = (((_11 as variant#1).0: (usize, &str)).0: usize);\n        _15 = (((_11 as variant#1).0: (usize, &str)).1: &str);\n        StorageLive(_17);\n        _17 = &mut _5;\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = _6;\n        _19 = Range(move _20, _14);\n        StorageDead(_20);\n        _18 = core::str::<impl str>::get_unchecked::<core::ops::Range<usize>>(_1, move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        drop(_10) -> [return: bb15, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        _16 = string::String::push_str(move _17, _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageLive(_22);\n        _22 = &mut _5;\n        _21 = string::String::push_str(move _22, _3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = core::str::<impl str>::len(_15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _24 = CheckedAdd(_14, _23);\n        assert(!move (_24.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, move _23) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _6 = move (_24.0: usize);\n        StorageDead(_23);\n        StorageDead(_11);\n        goto -> bb5;\n    }\n    bb15: {\n        StorageDead(_10);\n        StorageDead(_7);\n        StorageLive(_26);\n        _26 = &mut _5;\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = _6;\n        StorageLive(_30);\n        _30 = core::str::<impl str>::len(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _28 = Range(move _29, move _30);\n        StorageDead(_30);\n        StorageDead(_29);\n        _27 = core::str::<impl str>::get_unchecked::<core::ops::Range<usize>>(_1, move _28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_28);\n        _25 = string::String::push_str(move _26, _27) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_26);\n        _0 = move _5;\n        StorageDead(_6);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Replaces first N matches of a pattern with another string.\n\n `replacen` creates a new [`String`], and copies the data from this string slice into it.\n While doing so, it attempts to find matches of a pattern. If it finds any, it\n replaces them with the replacement string slice at most `count` times.\n\n # Examples\n\n ```\n let s = \"foo foo 123 foo\";\n assert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\n assert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\n assert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n ```\n\n When the pattern doesn't match, it returns this string slice as [`String`]:\n\n ```\n let s = \"this is old\";\n assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}