{
  "name": "sync::Arc::<T, A>::from_box_in",
  "safe": true,
  "callees": {
    "core::mem::size_of_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the pointed-to value in bytes.\n\n This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\n statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n then `size_of_val` can be used to get the dynamically-known size.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n\n # Examples\n\n ```\n assert_eq!(4, size_of_val(&5i32));\n\n let x: [u8; 13] = [0; 13];\n let y: &[u8] = &x;\n assert_eq!(13, size_of_val(y));\n ```\n\n [`size_of::<T>()`]: size_of\n",
      "adt": {}
    },
    "boxed::Box::<T, A>::allocator": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the underlying allocator.\n\n Note: this is an associated function, which means that you have\n to call it as `Box::allocator(&b)` instead of `b.allocator()`. This\n is so that there is no conflict with a method on the inner type.\n",
      "adt": {
        "boxed::Box": "ImmutableAsArgument"
      }
    },
    "sync::Arc::<T, A>::allocate_for_ptr_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "boxed::Box::<T, A>::into_raw_with_allocator": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the `Box`, returning a wrapped raw pointer and the allocator.\n\n The pointer will be properly aligned and non-null.\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Box`. In particular, the\n caller should properly destroy `T` and release the memory, taking\n into account the [memory layout] used by `Box`. The easiest way to\n do this is to convert the raw pointer back into a `Box` with the\n [`Box::from_raw_in`] function, allowing the `Box` destructor to perform\n the cleanup.\n\n Note: this is an associated function, which means that you have\n to call it as `Box::into_raw_with_allocator(b)` instead of `b.into_raw_with_allocator()`. This\n is so that there is no conflict with a method on the inner type.\n\n # Examples\n Converting the raw pointer back into a `Box` with [`Box::from_raw_in`]\n for automatic cleanup:\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let x = Box::new_in(String::from(\"Hello\"), System);\n let (ptr, alloc) = Box::into_raw_with_allocator(x);\n let x = unsafe { Box::from_raw_in(ptr, alloc) };\n ```\n Manual cleanup by explicitly running the destructor and deallocating\n the memory:\n ```\n #![feature(allocator_api)]\n\n use std::alloc::{Allocator, Layout, System};\n use std::ptr::{self, NonNull};\n\n let x = Box::new_in(String::from(\"Hello\"), System);\n let (ptr, alloc) = Box::into_raw_with_allocator(x);\n unsafe {\n     ptr::drop_in_place(ptr);\n     let non_null = NonNull::new_unchecked(ptr);\n     alloc.deallocate(non_null.cast(), Layout::new::<String>());\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {
        "boxed::Box": "MutableAsArgument"
      }
    },
    "core::alloc::Allocator::by_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a \"by reference\" adapter for this instance of `Allocator`.\n\n The returned adapter also implements `Allocator` and will simply borrow this.\n",
      "adt": {}
    },
    "boxed::Box::<T, A>::from_raw_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a box from a raw pointer in the given allocator.\n\n After calling this function, the raw pointer is owned by the\n resulting `Box`. Specifically, the `Box` destructor will call\n the destructor of `T` and free the allocated memory. For this\n to be safe, the memory must have been allocated in accordance\n with the [memory layout] used by `Box` .\n\n # Safety\n\n This function is unsafe because improper use may lead to\n memory problems. For example, a double-free may occur if the\n function is called twice on the same raw pointer.\n\n The raw pointer must point to a block of memory allocated by `alloc`.\n\n # Examples\n\n Recreate a `Box` which was previously converted to a raw pointer\n using [`Box::into_raw_with_allocator`]:\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let x = Box::new_in(5, System);\n let (ptr, alloc) = Box::into_raw_with_allocator(x);\n let x = unsafe { Box::from_raw_in(ptr, alloc) };\n ```\n Manually create a `Box` from scratch by using the system allocator:\n ```\n #![feature(allocator_api, slice_ptr_get)]\n\n use std::alloc::{Allocator, Layout, System};\n\n unsafe {\n     let ptr = System.allocate(Layout::new::<i32>())?.as_mut_ptr() as *mut i32;\n     // In general .write is required to avoid attempting to destruct\n     // the (uninitialized) previous contents of `ptr`, though for this\n     // simple example `*ptr = 5` would have worked as well.\n     ptr.write(5);\n     let x = Box::from_raw_in(ptr, System);\n }\n # Ok::<(), std::alloc::AllocError>(())\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {
        "boxed::Box": "Constructor"
      }
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "sync::Arc::<T, A>::from_ptr_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::Arc": "Constructor"
      }
    }
  },
  "adts": {
    "boxed::Box": [
      "Unknown([Field(0, Ty { id: 176, kind: RigidTy(Adt(AdtDef(DefId { id: 2645, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) }), Field(0, Ty { id: 101, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])",
      "Ref",
      "Plain"
    ],
    "sync::Arc": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::sync::Arc::<T, A>::from_box_in"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:2220:5: 2239:6",
  "src": "fn from_box_in(src: Box<T, A>) -> Arc<T, A> {\n        unsafe {\n            let value_size = size_of_val(&*src);\n            let ptr = Self::allocate_for_ptr_in(&*src, Box::allocator(&src));\n\n            // Copy value as bytes\n            ptr::copy_nonoverlapping(\n                (&raw const *src) as *const u8,\n                (&raw mut (*ptr).data) as *mut u8,\n                value_size,\n            );\n\n            // Free the allocation without dropping its contents\n            let (bptr, alloc) = Box::into_raw_with_allocator(src);\n            let src = Box::from_raw_in(bptr as *mut mem::ManuallyDrop<T>, alloc.by_ref());\n            drop(src);\n\n            Self::from_ptr_in(ptr, alloc)\n        }\n    }",
  "mir": "fn sync::Arc::<T, A>::from_box_in(_1: boxed::Box<T, A>) -> sync::Arc<T, A> {\n    let mut _0: sync::Arc<T, A>;\n    let  _2: usize;\n    let  _3: &T;\n    let  _4: *mut sync::ArcInner<T>;\n    let mut _5: *const T;\n    let  _6: &T;\n    let  _7: &A;\n    let  _8: &boxed::Box<T, A>;\n    let  _9: ();\n    let mut _10: *const u8;\n    let mut _11: *mut u8;\n    let mut _12: *mut T;\n    let  _13: *mut T;\n    let  _14: A;\n    let mut _15: (*mut T, A);\n    let mut _16: boxed::Box<T, A>;\n    let  _17: boxed::Box<core::mem::ManuallyDrop<T>, &A>;\n    let mut _18: *mut core::mem::ManuallyDrop<T>;\n    let mut _19: &A;\n    let mut _20: &A;\n    let  _21: ();\n    let mut _22: A;\n    let mut _23: *const T;\n    let mut _24: *const T;\n    let mut _25: *const T;\n    debug src => _1;\n    debug value_size => _2;\n    debug ptr => _4;\n    debug bptr => _13;\n    debug alloc => _14;\n    debug src => _17;\n    bb0: {\n        _23 = ((_1.0: core::ptr::Unique<T>).0: core::ptr::NonNull<T>) as *const T;\n        _3 = &(*_23);\n        _2 = core::mem::size_of_val::<T>(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _24 = ((_1.0: core::ptr::Unique<T>).0: core::ptr::NonNull<T>) as *const T;\n        _6 = &(*_24);\n        _5 = &raw const (*_6);\n        _8 = &_1;\n        _7 = boxed::Box::<T, A>::allocator(_8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = sync::Arc::<T, A>::allocate_for_ptr_in(move _5, _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_6);\n        StorageLive(_10);\n        _25 = ((_1.0: core::ptr::Unique<T>).0: core::ptr::NonNull<T>) as *const T;\n        _10 = _25 as *const u8;\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &raw mut ((*_4).2: T);\n        _11 = move _12 as *mut u8;\n        StorageDead(_12);\n        _9 = core::ptr::copy_nonoverlapping::<u8>(move _10, move _11, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = move _1;\n        _15 = boxed::Box::<T, A>::into_raw_with_allocator(move _16) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_16);\n        _13 = (_15.0: *mut T);\n        StorageLive(_14);\n        _14 = move (_15.1: A);\n        StorageDead(_15);\n        StorageLive(_18);\n        _18 = _13 as *mut core::mem::ManuallyDrop<T>;\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_14;\n        _19 = <A as core::alloc::Allocator>::by_ref(move _20) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_20);\n        _17 = boxed::Box::<core::mem::ManuallyDrop<T>, &A>::from_raw_in(move _18, move _19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_19);\n        StorageDead(_18);\n        _21 = core::mem::drop::<boxed::Box<core::mem::ManuallyDrop<T>, &A>>(_17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_22);\n        _22 = move _14;\n        _0 = sync::Arc::<T, A>::from_ptr_in(_4, move _22) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_22);\n        StorageDead(_14);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}