{
  "name": "raw_vec::RawVecInner::<A>::finish_grow",
  "safe": false,
  "callees": {
    "raw_vec::layout_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::alloc::Layout": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "raw_vec::RawVecInner::<A>::current_memory": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n - `elem_layout` must be valid for `self`, i.e. it must be the same `elem_layout` used to\n   initially construct `self`\n - `elem_layout`'s size must be a multiple of its alignment\n",
      "adt": {
        "core::alloc::Layout": "Constructor",
        "raw_vec::RawVecInner": "ImmutableAsArgument",
        "core::option::Option": "Constructor",
        "core::ptr::NonNull": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum byte alignment for a memory block of this layout.\n\n The returned alignment is guaranteed to be a power of two.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "core::alloc::Allocator::grow": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to extend the memory block.\n\n Returns a new [`NonNull<[u8]>`][NonNull] containing a pointer and the actual size of the allocated\n memory. The pointer is suitable for holding data described by `new_layout`. To accomplish\n this, the allocator may extend the allocation referenced by `ptr` to fit the new layout.\n\n If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n transferred to this allocator. Any access to the old `ptr` is Undefined Behavior, even if the\n allocation was grown in-place. The newly returned pointer is the only valid pointer\n for accessing this memory now.\n\n If this method returns `Err`, then ownership of the memory block has not been transferred to\n this allocator, and the contents of the memory block are unaltered.\n\n # Safety\n\n * `ptr` must denote a block of memory [*currently allocated*] via this allocator.\n * `old_layout` must [*fit*] that block of memory (The `new_layout` argument need not fit it.).\n * `new_layout.size()` must be greater than or equal to `old_layout.size()`.\n\n Note that `new_layout.align()` need not be the same as `old_layout.align()`.\n\n [*currently allocated*]: #currently-allocated-memory\n [*fit*]: #memory-fitting\n\n # Errors\n\n Returns `Err` if the new layout does not meet the allocator's size and alignment\n constraints of the allocator, or if growing otherwise fails.\n\n Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an allocation error are encouraged to\n call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "core::alloc::Allocator::allocate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to allocate a block of memory.\n\n On success, returns a [`NonNull<[u8]>`][NonNull] meeting the size and alignment guarantees of `layout`.\n\n The returned block may have a larger size than specified by `layout.size()`, and may or may\n not have its contents initialized.\n\n The returned block of memory remains valid as long as it is [*currently allocated*] and the shorter of:\n   - the borrow-checker lifetime of the allocator type itself.\n   - as long as the allocator and all its clones have not been dropped.\n\n [*currently allocated*]: #currently-allocated-memory\n\n # Errors\n\n Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n allocator's size or alignment constraints.\n\n Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an allocation error are encouraged to\n call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 232, kind: RigidTy(Adt(AdtDef(DefId { id: 2596, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 234, kind: RigidTy(Adt(AdtDef(DefId { id: 2685, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 35, kind: RigidTy(Adt(AdtDef(DefId { id: 2595, name: \"collections::TryReserveError\" }), GenericArgs([]))) })]))) })])"
    ],
    "raw_vec::RawVecInner": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 216, kind: RigidTy(Tuple([Ty { id: 102, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 93, kind: RigidTy(Uint(U8)) })]))) }, Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) }])) }), Field(0, Ty { id: 102, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 93, kind: RigidTy(Uint(U8)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 216, kind: RigidTy(Tuple([Ty { id: 102, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 93, kind: RigidTy(Uint(U8)) })]))) }, Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) }])) }), Field(1, Ty { id: 24, kind: RigidTy(Adt(AdtDef(DefId { id: 2588, name: \"core::alloc::Layout\" }), GenericArgs([]))) })])"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::raw_vec::RawVecInner::<A>::finish_grow"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:740:5: 759:6",
  "src": "unsafe fn finish_grow(\n        &self,\n        cap: usize,\n        elem_layout: Layout,\n    ) -> Result<NonNull<[u8]>, TryReserveError> {\n        let new_layout = layout_array(cap, elem_layout)?;\n\n        let memory = if let Some((ptr, old_layout)) = unsafe { self.current_memory(elem_layout) } {\n            debug_assert_eq!(old_layout.align(), new_layout.align());\n            unsafe {\n                // The allocator checks for alignment equality\n                hint::assert_unchecked(old_layout.align() == new_layout.align());\n                self.alloc.grow(ptr, old_layout, new_layout)\n            }\n        } else {\n            self.alloc.allocate(new_layout)\n        };\n\n        memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())\n    }",
  "mir": "fn raw_vec::RawVecInner::<A>::finish_grow(_1: &raw_vec::RawVecInner<A>, _2: usize, _3: core::alloc::Layout) -> core::result::Result<core::ptr::NonNull<[u8]>, collections::TryReserveError> {\n    let mut _0: core::result::Result<core::ptr::NonNull<[u8]>, collections::TryReserveError>;\n    let  _4: core::alloc::Layout;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, collections::TryReserveError>, core::alloc::Layout>;\n    let mut _6: core::result::Result<core::alloc::Layout, collections::TryReserveError>;\n    let mut _7: isize;\n    let  _8: core::result::Result<core::convert::Infallible, collections::TryReserveError>;\n    let  _9: core::alloc::Layout;\n    let  _10: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _11: core::option::Option<(core::ptr::NonNull<u8>, core::alloc::Layout)>;\n    let mut _12: isize;\n    let  _13: core::ptr::NonNull<u8>;\n    let  _14: core::alloc::Layout;\n    let mut _15: (&usize, &usize);\n    let mut _16: &usize;\n    let  _17: usize;\n    let mut _18: &core::alloc::Layout;\n    let mut _19: &usize;\n    let  _20: usize;\n    let mut _21: &core::alloc::Layout;\n    let  _22: &usize;\n    let  _23: &usize;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: usize;\n    let  _27: core::panicking::AssertKind;\n    let  _28: !;\n    let mut _29: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _30: ();\n    let mut _31: bool;\n    let mut _32: usize;\n    let mut _33: &core::alloc::Layout;\n    let mut _34: usize;\n    let mut _35: &core::alloc::Layout;\n    let mut _36: &A;\n    let mut _37: &A;\n    let mut _38: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _39: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:758:24: 758:27};\n    let mut _40: &core::alloc::Layout;\n    debug self => _1;\n    debug cap => _2;\n    debug elem_layout => _3;\n    debug new_layout => _4;\n    debug residual => _8;\n    debug val => _9;\n    debug memory => _10;\n    debug ptr => _13;\n    debug old_layout => _14;\n    debug left_val => _22;\n    debug right_val => _23;\n    debug kind => _27;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = raw_vec::layout_array(_2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = <core::result::Result<core::alloc::Layout, collections::TryReserveError> as core::ops::Try>::branch(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_9);\n        _9 = ((_5 as variant#0).0: core::alloc::Layout);\n        _4 = _9;\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = raw_vec::RawVecInner::<A>::current_memory(_1, _3) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _8 = move ((_5 as variant#1).0: core::result::Result<core::convert::Infallible, collections::TryReserveError>);\n        _0 = <core::result::Result<core::ptr::NonNull<[u8]>, collections::TryReserveError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, collections::TryReserveError>>>::from_residual(_8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        goto -> bb21;\n    }\n    bb7: {\n        _12 = discriminant(_11);\n        switchInt(move _12) -> [1: bb8, 0: bb17, otherwise: bb3];\n    }\n    bb8: {\n        _13 = (((_11 as variant#1).0: (core::ptr::NonNull<u8>, core::alloc::Layout)).0: core::ptr::NonNull<u8>);\n        _14 = (((_11 as variant#1).0: (core::ptr::NonNull<u8>, core::alloc::Layout)).1: core::alloc::Layout);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_14;\n        _17 = core::alloc::Layout::align(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        _16 = &_17;\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_4;\n        _20 = core::alloc::Layout::align(move _21) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_21);\n        _19 = &_20;\n        _15 = (move _16, move _19);\n        StorageDead(_19);\n        StorageDead(_16);\n        _22 = (_15.0: &usize);\n        _23 = (_15.1: &usize);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = (*_22);\n        StorageLive(_26);\n        _26 = (*_23);\n        _24 = Eq(move _25, move _26);\n        switchInt(move _24) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_20);\n        StorageDead(_17);\n        StorageDead(_15);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_14;\n        _32 = core::alloc::Layout::align(move _33) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_26);\n        StorageDead(_25);\n        _27 = core::panicking::AssertKind::Eq;\n        StorageLive(_29);\n        _29 = core::option::Option::None;\n        _28 = core::panicking::assert_failed::<usize, usize>(_27, _22, _23, move _29) -> unwind unreachable;\n    }\n    bb13: {\n        StorageDead(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_4;\n        _34 = core::alloc::Layout::align(move _35) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_35);\n        _31 = Eq(move _32, move _34);\n        StorageDead(_34);\n        StorageDead(_32);\n        _30 = core::hint::assert_unchecked(move _31) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_31);\n        StorageLive(_36);\n        _36 = &((*_1).2: A);\n        _10 = <A as core::alloc::Allocator>::grow(move _36, _13, _14, _4) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_36);\n        StorageDead(_11);\n        goto -> bb19;\n    }\n    bb17: {\n        StorageDead(_11);\n        StorageLive(_37);\n        _37 = &((*_1).2: A);\n        _10 = <A as core::alloc::Allocator>::allocate(move _37, _4) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_37);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_38);\n        _38 = _10;\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_4;\n        _39 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:758:24: 758:27}(move _40);\n        StorageDead(_40);\n        _0 = core::result::Result::<core::ptr::NonNull<[u8]>, core::alloc::AllocError>::map_err::<collections::TryReserveError, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/raw_vec/mod.rs:758:24: 758:27}>(move _38, move _39) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_10);\n        goto -> bb21;\n    }\n    bb21: {\n        return;\n    }\n}\n",
  "doc": " # Safety\n - `elem_layout` must be valid for `self`, i.e. it must be the same `elem_layout` used to\n   initially construct `self`\n - `elem_layout`'s size must be a multiple of its alignment\n - `cap` must be greater than the current capacity\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}