{
  "name": "string::String::drain",
  "safe": true,
  "callees": {
    "string::String::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of this `String`, in bytes, not [`char`]s or\n graphemes. In other words, it might not be what a human considers the\n length of the string.\n\n # Examples\n\n ```\n let a = String::from(\"foo\");\n assert_eq!(a.len(), 3);\n\n let fancy_f = String::from(\"∆íoo\");\n assert_eq!(fancy_f.len(), 4);\n assert_eq!(fancy_f.chars().count(), 3);\n ```\n",
      "adt": {
        "string::String": "ImmutableAsArgument"
      }
    },
    "core::slice::range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs bounds checking of a range.\n\n This method is similar to [`Index::index`] for slices, but it returns a\n [`Range`] equivalent to `range`. You can use this method to turn any range\n into `start` and `end` values.\n\n `bounds` is the range of the slice to use for bounds checking. It should\n be a [`RangeTo`] range that ends at the length of the slice.\n\n The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and\n [`slice::get_unchecked_mut`] for slices with the given range.\n\n [`Range`]: ops::Range\n [`RangeTo`]: ops::RangeTo\n [`slice::get_unchecked`]: slice::get_unchecked\n [`slice::get_unchecked_mut`]: slice::get_unchecked_mut\n\n # Panics\n\n Panics if `range` would be out of bounds.\n\n # Examples\n\n ```\n #![feature(slice_range)]\n\n use std::slice;\n\n let v = [10, 40, 30];\n assert_eq!(1..2, slice::range(1..2, ..v.len()));\n assert_eq!(0..2, slice::range(..2, ..v.len()));\n assert_eq!(1..3, slice::range(1.., ..v.len()));\n ```\n\n Panics when [`Index::index`] would panic:\n\n ```should_panic\n #![feature(slice_range)]\n\n use std::slice;\n\n let _ = slice::range(2..1, ..3);\n ```\n\n ```should_panic\n #![feature(slice_range)]\n\n use std::slice;\n\n let _ = slice::range(1..4, ..3);\n ```\n\n ```should_panic\n #![feature(slice_range)]\n\n use std::slice;\n\n let _ = slice::range(1..=usize::MAX, ..3);\n ```\n\n [`Index::index`]: ops::Index::index\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::str::<impl str>::is_char_boundary": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks that `index`-th byte is the first byte in a UTF-8 code point\n sequence or the end of the string.\n\n The start and end of the string (when `index == self.len()`) are\n considered to be boundaries.\n\n Returns `false` if `index` is greater than `self.len()`.\n\n # Examples\n\n ```\n let s = \"L√∂we ËÄÅËôé L√©opard\";\n assert!(s.is_char_boundary(0));\n // start of `ËÄÅ`\n assert!(s.is_char_boundary(6));\n assert!(s.is_char_boundary(s.len()));\n\n // second byte of `√∂`\n assert!(!s.is_char_boundary(2));\n\n // third byte of `ËÄÅ`\n assert!(!s.is_char_boundary(8));\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::str::<impl str>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unchecked subslice of `str`.\n\n This is the unchecked alternative to indexing the `str`.\n\n # Safety\n\n Callers of this function are responsible that these preconditions are\n satisfied:\n\n * The starting index must not exceed the ending index;\n * Indexes must be within bounds of the original slice;\n * Indexes must lie on UTF-8 sequence boundaries.\n\n Failing that, the returned string slice may reference invalid memory or\n violate the invariants communicated by the `str` type.\n\n # Examples\n\n ```\n let v = \"üóª‚ààüåè\";\n unsafe {\n     assert_eq!(\"üóª\", v.get_unchecked(0..4));\n     assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n     assert_eq!(\"üåè\", v.get_unchecked(7..11));\n }\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"yÃÜ\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "string::String": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::str::Chars": [
      "Plain"
    ],
    "string::Drain": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::string::String::drain"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1961:5: 1982:6",
  "src": "pub fn drain<R>(&mut self, range: R) -> Drain<'_>\n    where\n        R: RangeBounds<usize>,\n    {\n        // Memory safety\n        //\n        // The String version of Drain does not have the memory safety issues\n        // of the vector version. The data is just plain bytes.\n        // Because the range removal happens in Drop, if the Drain iterator is leaked,\n        // the removal will not happen.\n        let Range { start, end } = slice::range(range, ..self.len());\n        assert!(self.is_char_boundary(start));\n        assert!(self.is_char_boundary(end));\n\n        // Take out two simultaneous borrows. The &mut String won't be accessed\n        // until iteration is over, in Drop.\n        let self_ptr = self as *mut _;\n        // SAFETY: `slice::range` and `is_char_boundary` do the appropriate bounds checks.\n        let chars_iter = unsafe { self.get_unchecked(start..end) }.chars();\n\n        Drain { start, end, iter: chars_iter, string: self_ptr }\n    }",
  "mir": "fn string::String::drain(_1: &mut string::String, _2: R) -> string::Drain<'_> {\n    let mut _0: string::Drain<'_>;\n    let  _3: usize;\n    let  _4: usize;\n    let mut _5: core::ops::Range<usize>;\n    let mut _6: core::ops::RangeTo<usize>;\n    let mut _7: usize;\n    let mut _8: &string::String;\n    let mut _9: bool;\n    let  _10: &str;\n    let mut _11: &string::String;\n    let mut _12: !;\n    let mut _13: bool;\n    let  _14: &str;\n    let mut _15: &string::String;\n    let mut _16: !;\n    let mut _17: *mut string::String;\n    let  _18: core::str::Chars<'_>;\n    let  _19: &str;\n    let  _20: &str;\n    let mut _21: &string::String;\n    let mut _22: core::ops::Range<usize>;\n    debug self => _1;\n    debug range => _2;\n    debug start => _3;\n    debug end => _4;\n    debug self_ptr => _17;\n    debug chars_iter => _18;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_1);\n        _7 = string::String::len(move _8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_8);\n        _6 = RangeTo(move _7);\n        StorageDead(_7);\n        _5 = core::slice::range::<R>(_2, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _3 = (_5.0: usize);\n        _4 = (_5.1: usize);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_11);\n        _11 = &(*_1);\n        _10 = <string::String as core::ops::Deref>::deref(move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _9 = core::str::<impl str>::is_char_boundary(_10, _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _9) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageLive(_13);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = <string::String as core::ops::Deref>::deref(move _15) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        _12 = core::panicking::panic(\"assertion failed: self.is_char_boundary(start)\") -> unwind unreachable;\n    }\n    bb7: {\n        StorageDead(_15);\n        _13 = core::str::<impl str>::is_char_boundary(_14, _4) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _13) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_13);\n        _17 = &raw mut (*_1);\n        StorageLive(_21);\n        _21 = &(*_1);\n        _20 = <string::String as core::ops::Deref>::deref(move _21) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        _16 = core::panicking::panic(\"assertion failed: self.is_char_boundary(end)\") -> unwind unreachable;\n    }\n    bb11: {\n        StorageDead(_21);\n        StorageLive(_22);\n        _22 = Range(_3, _4);\n        _19 = core::str::<impl str>::get_unchecked::<core::ops::Range<usize>>(_20, move _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        _18 = core::str::<impl str>::chars(_19) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _0 = Drain(_17, _3, _4, _18);\n        return;\n    }\n}\n",
  "doc": " Removes the specified range from the string in bulk, returning all\n removed characters as an iterator.\n\n The returned iterator keeps a mutable borrow on the string to optimize\n its implementation.\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and does not lie on a [`char`] boundary.\n\n # Leaking\n\n If the returned iterator goes out of scope without being dropped (due to\n [`core::mem::forget`], for example), the string may still contain a copy\n of any drained characters, or may have lost characters arbitrarily,\n including characters outside the range.\n\n # Examples\n\n ```\n let mut s = String::from(\"Œ± is alpha, Œ≤ is beta\");\n let beta_offset = s.find('Œ≤').unwrap_or(s.len());\n\n // Remove the range up until the Œ≤ from the string\n let t: String = s.drain(..beta_offset).collect();\n assert_eq!(t, \"Œ± is alpha, \");\n assert_eq!(s, \"Œ≤ is beta\");\n\n // A full range clears the string, like `clear()` does\n s.drain(..);\n assert_eq!(s, \"\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}