{
  "name": "sync::Arc::<T, A>::get_mut",
  "safe": true,
  "callees": {
    "sync::Arc::<T, A>::is_unique": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determine whether this is the unique reference to the underlying data.\n\n Returns `true` if there are no other `Arc` or [`Weak`] pointers to the same allocation;\n returns `false` otherwise.\n\n If this function returns `true`, then is guaranteed to be safe to call [`get_mut_unchecked`]\n on this `Arc`, so long as no clones occur in between.\n\n # Examples\n\n ```\n #![feature(arc_is_unique)]\n\n use std::sync::Arc;\n\n let x = Arc::new(3);\n assert!(Arc::is_unique(&x));\n\n let y = Arc::clone(&x);\n assert!(!Arc::is_unique(&x));\n drop(y);\n\n // Weak references also count, because they could be upgraded at any time.\n let z = Arc::downgrade(&x);\n assert!(!Arc::is_unique(&x));\n ```\n\n # Pointer invalidation\n\n This function will always return the same value as `Arc::get_mut(arc).is_some()`. However,\n unlike that operation it does not produce any mutable references to the underlying data,\n meaning no pointers to the data inside the `Arc` are invalidated by the call. Thus, the\n following code is valid, even though it would be UB if it used `Arc::get_mut`:\n\n ```\n #![feature(arc_is_unique)]\n\n use std::sync::Arc;\n\n let arc = Arc::new(5);\n let pointer: *const i32 = &*arc;\n assert!(Arc::is_unique(&arc));\n assert_eq!(unsafe { *pointer }, 5);\n ```\n\n # Atomic orderings\n\n Concurrent drops to other `Arc` pointers to the same allocation will synchronize with this\n call - that is, this call performs an `Acquire` operation on the underlying strong and weak\n ref counts. This ensures that calling `get_mut_unchecked` is safe.\n\n Note that this operation requires locking the weak ref count, so concurrent calls to\n `downgrade` may spin-loop for a short period of time.\n\n [`get_mut_unchecked`]: Self::get_mut_unchecked\n",
      "adt": {
        "sync::Arc": "ImmutableAsArgument"
      }
    },
    "sync::Arc::<T, A>::get_mut_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference into the given `Arc`,\n without any check.\n\n See also [`get_mut`], which is safe and does appropriate checks.\n\n [`get_mut`]: Arc::get_mut\n\n # Safety\n\n If any other `Arc` or [`Weak`] pointers to the same allocation exist, then\n they must not be dereferenced or have active borrows for the duration\n of the returned borrow, and their inner type must be exactly the same as the\n inner type of this Arc (including lifetimes). This is trivially the case if no\n such pointers exist, for example immediately after `Arc::new`.\n\n # Examples\n\n ```\n #![feature(get_mut_unchecked)]\n\n use std::sync::Arc;\n\n let mut x = Arc::new(String::new());\n unsafe {\n     Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n }\n assert_eq!(*x, \"foo\");\n ```\n Other `Arc` pointers to the same allocation must be to the same type.\n ```no_run\n #![feature(get_mut_unchecked)]\n\n use std::sync::Arc;\n\n let x: Arc<str> = Arc::from(\"Hello, world!\");\n let mut y: Arc<[u8]> = x.clone().into();\n unsafe {\n     // this is Undefined Behavior, because x's inner type is str, not [u8]\n     Arc::get_mut_unchecked(&mut y).fill(0xff); // 0xff is invalid in UTF-8\n }\n println!(\"{}\", &*x); // Invalid UTF-8 in a str\n ```\n Other `Arc` pointers to the same allocation must be to the exact same type, including lifetimes.\n ```no_run\n #![feature(get_mut_unchecked)]\n\n use std::sync::Arc;\n\n let x: Arc<&str> = Arc::new(\"Hello, world!\");\n {\n     let s = String::from(\"Oh, no!\");\n     let mut y: Arc<&str> = x.clone();\n     unsafe {\n         // this is Undefined Behavior, because x's inner type\n         // is &'long str, not &'short str\n         *Arc::get_mut_unchecked(&mut y) = &s;\n     }\n }\n println!(\"{}\", &*x); // Use-after-free\n ```\n",
      "adt": {
        "sync::Arc": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "sync::Arc": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2069,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:2616:5: 2627:6",
  "src": "pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n        if Self::is_unique(this) {\n            // This unsafety is ok because we're guaranteed that the pointer\n            // returned is the *only* pointer that will ever be returned to T. Our\n            // reference count is guaranteed to be 1 at this point, and we required\n            // the Arc itself to be `mut`, so we're returning the only possible\n            // reference to the inner data.\n            unsafe { Some(Arc::get_mut_unchecked(this)) }\n        } else {\n            None\n        }\n    }",
  "mir": "fn sync::Arc::<T, A>::get_mut(_1: &mut sync::Arc<T, A>) -> core::option::Option<&mut T> {\n    let mut _0: core::option::Option<&mut T>;\n    let mut _2: bool;\n    let mut _3: &sync::Arc<T, A>;\n    let mut _4: &mut T;\n    debug this => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &(*_1);\n        _2 = sync::Arc::<T, A>::is_unique(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = sync::Arc::<T, A>::get_mut_unchecked(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core::option::Option::Some(_4);\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a mutable reference into the given `Arc`, if there are\n no other `Arc` or [`Weak`] pointers to the same allocation.\n\n Returns [`None`] otherwise, because it is not safe to\n mutate a shared value.\n\n See also [`make_mut`][make_mut], which will [`clone`][clone]\n the inner value when there are other `Arc` pointers.\n\n [make_mut]: Arc::make_mut\n [clone]: Clone::clone\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let mut x = Arc::new(3);\n *Arc::get_mut(&mut x).unwrap() = 4;\n assert_eq!(*x, 4);\n\n let _y = Arc::clone(&x);\n assert!(Arc::get_mut(&mut x).is_none());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}