{
  "name": "<collections::btree::map::BTreeMap<K, V> as core::iter::FromIterator<(K, V)>>::from_iter",
  "safe": true,
  "callees": {
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "collections::btree::map::BTreeMap::<K, V>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a new, empty `BTreeMap`.\n\n Does not allocate anything on its own.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n\n // entries can now be inserted into the empty map\n map.insert(1, \"a\");\n ```\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "slice::<impl [T]>::sort_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order with a comparison function, preserving initial order of\n equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\n worst-case.\n\n If the comparison function `compare` does not implement a [total order], the function may\n panic; even if the function exits normally, the resulting order of elements in the slice is\n unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n # Current implementation\n\n The current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\n combines the fast average case of quicksort with the fast worst case and partial run\n detection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\n with k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n The auxiliary memory allocation behavior depends on the input length. Short slices are\n handled without allocation, medium sized slices allocate `self.len()` and beyond that it\n clamps at `self.len() / 2`.\n\n # Panics\n\n May panic if `compare` does not implement a [total order], or if `compare` itself panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n v.sort_by(|a, b| a.cmp(b));\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n\n // reverse sorting\n v.sort_by(|a, b| b.cmp(a));\n assert_eq!(v, [4, 2, 1, -3, -5]);\n ```\n\n [driftsort]: https://github.com/Voultapher/driftsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    },
    "collections::btree::map::BTreeMap::<K, V, A>::bulk_build_from_sorted_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a `BTreeMap` from a sorted iterator.\n",
      "adt": {
        "collections::btree::map::BTreeMap": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "collections::btree::map::BTreeMap": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::btree::map::BTreeMap<K, V> as core::iter::FromIterator<(K, V)>>::from_iter"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2384:5: 2394:6",
  "src": "fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n        let mut inputs: Vec<_> = iter.into_iter().collect();\n\n        if inputs.is_empty() {\n            return BTreeMap::new();\n        }\n\n        // use stable sort to preserve the insertion order.\n        inputs.sort_by(|a, b| a.0.cmp(&b.0));\n        BTreeMap::bulk_build_from_sorted_iter(inputs, Global)\n    }",
  "mir": "fn <collections::btree::map::BTreeMap<K, V> as core::iter::FromIterator<(K, V)>>::from_iter(_1: T) -> collections::btree::map::BTreeMap<K, V> {\n    let mut _0: collections::btree::map::BTreeMap<K, V>;\n    let mut _2: vec::Vec<(K, V)>;\n    let mut _3: <T as core::iter::IntoIterator>::IntoIter;\n    let mut _4: bool;\n    let mut _5: &vec::Vec<(K, V)>;\n    let  _6: ();\n    let mut _7: &mut [(K, V)];\n    let mut _8: &mut vec::Vec<(K, V)>;\n    let mut _9: vec::Vec<(K, V)>;\n    debug iter => _1;\n    debug inputs => _2;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = <T as core::iter::IntoIterator>::into_iter(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = <<T as core::iter::IntoIterator>::IntoIter as core::iter::Iterator>::collect::<vec::Vec<(K, V)>>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_2;\n        _4 = vec::Vec::<(K, V)>::is_empty(move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _4) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_5);\n        _0 = collections::btree::map::BTreeMap::<K, V>::new() -> [return: bb9, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_8);\n        _8 = &mut _2;\n        _7 = <vec::Vec<(K, V)> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        _6 = slice::<impl [(K, V)]>::sort_by::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2392:24: 2392:30}>(_7, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:2392:24: 2392:30}) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_9);\n        _9 = move _2;\n        _0 = collections::btree::map::BTreeMap::<K, V>::bulk_build_from_sorted_iter::<vec::Vec<(K, V)>>(move _9, alloc::Global) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_2);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageDead(_4);\n        drop(_2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_2);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Constructs a `BTreeMap<K, V>` from an iterator of key-value pairs.\n\n If the iterator produces any pairs with equal keys,\n all but one of the corresponding values will be dropped.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}