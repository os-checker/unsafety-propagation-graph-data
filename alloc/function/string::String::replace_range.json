{
  "name": "string::String::replace_range",
  "safe": true,
  "callees": {
    "core::ops::RangeBounds::start_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Start index bound.\n\n Returns the start value as a `Bound`.\n\n # Examples\n\n ```\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n\n assert_eq!((..10).start_bound(), Unbounded);\n assert_eq!((3..10).start_bound(), Included(&3));\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::str::<impl str>::is_char_boundary": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks that `index`-th byte is the first byte in a UTF-8 code point\n sequence or the end of the string.\n\n The start and end of the string (when `index == self.len()`) are\n considered to be boundaries.\n\n Returns `false` if `index` is greater than `self.len()`.\n\n # Examples\n\n ```\n let s = \"Löwe 老虎 Léopard\";\n assert!(s.is_char_boundary(0));\n // start of `老`\n assert!(s.is_char_boundary(6));\n assert!(s.is_char_boundary(s.len()));\n\n // second byte of `ö`\n assert!(!s.is_char_boundary(2));\n\n // third byte of `老`\n assert!(!s.is_char_boundary(8));\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::ops::RangeBounds::end_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " End index bound.\n\n Returns the end value as a `Bound`.\n\n # Examples\n\n ```\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n\n assert_eq!((3..).end_bound(), Unbounded);\n assert_eq!((3..10).end_bound(), Excluded(&10));\n ```\n",
      "adt": {}
    },
    "string::String::as_mut_vec": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the contents of this `String`.\n\n # Safety\n\n This function is unsafe because the returned `&mut Vec` allows writing\n bytes which are not valid UTF-8. If this constraint is violated, using\n the original `String` after dropping the `&mut Vec` may violate memory\n safety, as the rest of the standard library assumes that `String`s are\n valid UTF-8.\n\n # Examples\n\n ```\n let mut s = String::from(\"hello\");\n\n unsafe {\n     let vec = s.as_mut_vec();\n     assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n\n     vec.reverse();\n }\n assert_eq!(s, \"olleh\");\n ```\n",
      "adt": {
        "string::String": "MutableAsArgument"
      }
    },
    "core::str::<impl str>::bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the bytes of a string slice.\n\n As a string slice consists of a sequence of bytes, we can iterate\n through a string slice by byte. This method returns such an iterator.\n\n # Examples\n\n ```\n let mut bytes = \"bors\".bytes();\n\n assert_eq!(Some(b'b'), bytes.next());\n assert_eq!(Some(b'o'), bytes.next());\n assert_eq!(Some(b'r'), bytes.next());\n assert_eq!(Some(b's'), bytes.next());\n\n assert_eq!(None, bytes.next());\n ```\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::splice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a splicing iterator that replaces the specified range in the vector\n with the given `replace_with` iterator and yields the removed items.\n `replace_with` does not need to be the same length as `range`.\n\n `range` is removed even if the `Splice` iterator is not consumed before it is dropped.\n\n It is unspecified how many elements are removed from the vector\n if the `Splice` value is leaked.\n\n The input iterator `replace_with` is only consumed when the `Splice` value is dropped.\n\n This is optimal if:\n\n * The tail (elements in the vector after `range`) is empty,\n * or `replace_with` yields fewer or equal elements than `range`'s length\n * or the lower bound of its `size_hint()` is exact.\n\n Otherwise, a temporary vector is allocated and the tail is moved twice.\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and past the length of the vector.\n\n # Examples\n\n ```\n let mut v = vec![1, 2, 3, 4];\n let new = [7, 8, 9];\n let u: Vec<_> = v.splice(1..3, new).collect();\n assert_eq!(v, [1, 7, 8, 9, 4]);\n assert_eq!(u, [2, 3]);\n ```\n\n Using `splice` to insert new items into a vector efficiently at a specific position\n indicated by an empty range:\n\n ```\n let mut v = vec![1, 5];\n let new = [2, 3, 4];\n v.splice(1..1, new);\n assert_eq!(v, [1, 2, 3, 4, 5]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument",
        "vec::splice::Splice": "Constructor"
      }
    }
  },
  "adts": {
    "core::ops::Bound": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 269, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 269, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Not)) })])"
    ],
    "string::String": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "vec::Vec": [
      "MutRef"
    ],
    "core::str::Bytes": [
      "Plain"
    ],
    "vec::splice::Splice": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::string::String::replace_range"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2061:5: 2089:6",
  "src": "pub fn replace_range<R>(&mut self, range: R, replace_with: &str)\n    where\n        R: RangeBounds<usize>,\n    {\n        // Memory safety\n        //\n        // Replace_range does not have the memory safety issues of a vector Splice.\n        // of the vector version. The data is just plain bytes.\n\n        // WARNING: Inlining this variable would be unsound (#81138)\n        let start = range.start_bound();\n        match start {\n            Included(&n) => assert!(self.is_char_boundary(n)),\n            Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n            Unbounded => {}\n        };\n        // WARNING: Inlining this variable would be unsound (#81138)\n        let end = range.end_bound();\n        match end {\n            Included(&n) => assert!(self.is_char_boundary(n + 1)),\n            Excluded(&n) => assert!(self.is_char_boundary(n)),\n            Unbounded => {}\n        };\n\n        // Using `range` again would be unsound (#81138)\n        // We assume the bounds reported by `range` remain the same, but\n        // an adversarial implementation could change between calls\n        unsafe { self.as_mut_vec() }.splice((start, end), replace_with.bytes());\n    }",
  "mir": "fn string::String::replace_range(_1: &mut string::String, _2: R, _3: &str) -> () {\n    let mut _0: ();\n    let  _4: core::ops::Bound<&usize>;\n    let mut _5: &R;\n    let mut _6: isize;\n    let  _7: usize;\n    let mut _8: bool;\n    let  _9: &str;\n    let mut _10: &string::String;\n    let mut _11: !;\n    let  _12: usize;\n    let mut _13: bool;\n    let  _14: &str;\n    let mut _15: &string::String;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: !;\n    let  _19: core::ops::Bound<&usize>;\n    let mut _20: &R;\n    let mut _21: isize;\n    let  _22: usize;\n    let mut _23: bool;\n    let  _24: &str;\n    let mut _25: &string::String;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let mut _28: !;\n    let  _29: usize;\n    let mut _30: bool;\n    let  _31: &str;\n    let mut _32: &string::String;\n    let mut _33: !;\n    let  _34: vec::splice::Splice<'_, core::str::Bytes<'_>>;\n    let mut _35: &mut vec::Vec<u8>;\n    let mut _36: (core::ops::Bound<&usize>, core::ops::Bound<&usize>);\n    let mut _37: core::str::Bytes<'_>;\n    let mut _38: &usize;\n    let mut _39: &usize;\n    let mut _40: &usize;\n    let mut _41: &usize;\n    debug self => _1;\n    debug range => _2;\n    debug replace_with => _3;\n    debug start => _4;\n    debug n => _7;\n    debug n => _12;\n    debug end => _19;\n    debug n => _22;\n    debug n => _29;\n    bb0: {\n        StorageLive(_5);\n        _5 = &_2;\n        _4 = <R as core::ops::RangeBounds<usize>>::start_bound(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb3, 2: bb14, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _38 = ((_4 as variant#1).0: &usize);\n        _12 = (*_38);\n        StorageLive(_13);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = <string::String as core::ops::Deref>::deref(move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb4: {\n        _39 = ((_4 as variant#0).0: &usize);\n        _7 = (*_39);\n        StorageLive(_8);\n        StorageLive(_10);\n        _10 = &(*_1);\n        _9 = <string::String as core::ops::Deref>::deref(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        _8 = core::str::<impl str>::is_char_boundary(_9, _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_8);\n        goto -> bb14;\n    }\n    bb8: {\n        _11 = core::panicking::panic(\"assertion failed: self.is_char_boundary(n)\") -> unwind unreachable;\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageLive(_16);\n        _17 = CheckedAdd(_12, 1_usize);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _12, 1_usize) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _16 = move (_17.0: usize);\n        _13 = core::str::<impl str>::is_char_boundary(_14, move _16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _13) -> [0: bb13, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_16);\n        StorageDead(_13);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_16);\n        _18 = core::panicking::panic(\"assertion failed: self.is_char_boundary(n + 1)\") -> unwind unreachable;\n    }\n    bb14: {\n        StorageLive(_20);\n        _20 = &_2;\n        _19 = <R as core::ops::RangeBounds<usize>>::end_bound(move _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        _21 = discriminant(_19);\n        switchInt(move _21) -> [0: bb17, 1: bb16, 2: bb27, otherwise: bb2];\n    }\n    bb16: {\n        _40 = ((_19 as variant#1).0: &usize);\n        _29 = (*_40);\n        StorageLive(_30);\n        StorageLive(_32);\n        _32 = &(*_1);\n        _31 = <string::String as core::ops::Deref>::deref(move _32) -> [return: bb23, unwind unreachable];\n    }\n    bb17: {\n        _41 = ((_19 as variant#0).0: &usize);\n        _22 = (*_41);\n        StorageLive(_23);\n        StorageLive(_25);\n        _25 = &(*_1);\n        _24 = <string::String as core::ops::Deref>::deref(move _25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_25);\n        StorageLive(_26);\n        _27 = CheckedAdd(_22, 1_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _22, 1_usize) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _26 = move (_27.0: usize);\n        _23 = core::str::<impl str>::is_char_boundary(_24, move _26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        switchInt(move _23) -> [0: bb22, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_26);\n        StorageDead(_23);\n        goto -> bb27;\n    }\n    bb22: {\n        StorageDead(_26);\n        _28 = core::panicking::panic(\"assertion failed: self.is_char_boundary(n + 1)\") -> unwind unreachable;\n    }\n    bb23: {\n        StorageDead(_32);\n        _30 = core::str::<impl str>::is_char_boundary(_31, _29) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        switchInt(move _30) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_30);\n        goto -> bb27;\n    }\n    bb26: {\n        _33 = core::panicking::panic(\"assertion failed: self.is_char_boundary(n)\") -> unwind unreachable;\n    }\n    bb27: {\n        StorageLive(_34);\n        _35 = string::String::as_mut_vec(_1) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageLive(_36);\n        _36 = (_4, _19);\n        StorageLive(_37);\n        _37 = core::str::<impl str>::bytes(_3) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _34 = vec::Vec::<u8>::splice::<(core::ops::Bound<&usize>, core::ops::Bound<&usize>), core::str::Bytes<'_>>(_35, move _36, move _37) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_37);\n        StorageDead(_36);\n        drop(_34) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_34);\n        drop(_2) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        return;\n    }\n}\n",
  "doc": " Removes the specified range in the string,\n and replaces it with the given string.\n The given string doesn't need to be the same length as the range.\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and does not lie on a [`char`] boundary.\n\n # Examples\n\n ```\n let mut s = String::from(\"α is alpha, β is beta\");\n let beta_offset = s.find('β').unwrap_or(s.len());\n\n // Replace the range up until the β from the string\n s.replace_range(..beta_offset, \"Α is capital alpha; \");\n assert_eq!(s, \"Α is capital alpha; β is beta\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}