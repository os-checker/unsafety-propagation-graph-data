{
  "name": "<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtendFront<T, I>>::spec_extend_front",
  "safe": true,
  "callees": {
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {}
    },
    "core::num::<impl usize>::saturating_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves capacity for at least `additional` more elements to be inserted in the given\n deque. The collection may reserve more space to speculatively avoid frequent reallocations.\n\n # Panics\n\n Panics if the new capacity overflows `usize`.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf: VecDeque<i32> = [1].into();\n buf.reserve(10);\n assert!(buf.capacity() >= 11);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::push_front_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prepends an element to the buffer.\n\n # Safety\n\n May only be called if `deque.len() < deque.capacity()`\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) })])",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "collections::vec_deque::VecDeque": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "Deref"
    ]
  },
  "path": 1430,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/spec_extend.rs:129:5: 152:6",
  "src": "default fn spec_extend_front(&mut self, mut iter: I) {\n        // This function should be the moral equivalent of:\n        //\n        // for item in iter {\n        //     self.push_front(item);\n        // }\n\n        while let Some(element) = iter.next() {\n            let (lower, _) = iter.size_hint();\n            self.reserve(lower.saturating_add(1));\n\n            // SAFETY: We just reserved space for at least one element.\n            unsafe { self.push_front_unchecked(element) };\n\n            // Inner loop to avoid repeatedly calling `reserve`.\n            while self.len < self.capacity() {\n                let Some(element) = iter.next() else {\n                    return;\n                };\n                // SAFETY: The loop condition guarantees that `self.len() < self.capacity()`.\n                unsafe { self.push_front_unchecked(element) };\n            }\n        }\n    }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtendFront<T, I>>::spec_extend_front(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: I) -> () {\n    let mut _0: ();\n    let mut _3: core::option::Option<T>;\n    let mut _4: &mut I;\n    let mut _5: isize;\n    let  _6: T;\n    let  _7: usize;\n    let mut _8: (usize, core::option::Option<usize>);\n    let mut _9: &I;\n    let  _10: ();\n    let mut _11: usize;\n    let  _12: ();\n    let mut _13: bool;\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: &collections::vec_deque::VecDeque<T, A>;\n    let  _17: T;\n    let mut _18: core::option::Option<T>;\n    let mut _19: &mut I;\n    let mut _20: isize;\n    let  _21: ();\n    debug self => _1;\n    debug iter => _2;\n    debug element => _6;\n    debug lower => _7;\n    debug element => _17;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut _2;\n        _3 = <I as core::iter::Iterator>::next(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [1: bb3, 0: bb16, otherwise: bb18];\n    }\n    bb3: {\n        _6 = move ((_3 as variant#1).0: T);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_2;\n        _8 = <I as core::iter::Iterator>::size_hint(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _7 = (_8.0: usize);\n        StorageDead(_8);\n        StorageLive(_11);\n        _11 = core::num::<impl usize>::saturating_add(_7, 1_usize) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = collections::vec_deque::VecDeque::<T, A>::reserve(_1, move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _12 = collections::vec_deque::VecDeque::<T, A>::push_front_unchecked(_1, _6) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ((*_1).1: usize);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &(*_1);\n        _15 = collections::vec_deque::VecDeque::<T, A>::capacity(move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        _13 = Lt(move _14, move _15);\n        switchInt(move _13) -> [0: bb15, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _2;\n        _18 = <I as core::iter::Iterator>::next(move _19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        _20 = discriminant(_18);\n        switchInt(move _20) -> [1: bb12, 0: bb13, otherwise: bb18];\n    }\n    bb12: {\n        _17 = move ((_18 as variant#1).0: T);\n        StorageDead(_18);\n        _21 = collections::vec_deque::VecDeque::<T, A>::push_front_unchecked(_1, _17) -> [return: bb14, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageDead(_13);\n        StorageDead(_3);\n        drop(_2) -> [return: bb17, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_13);\n        goto -> bb8;\n    }\n    bb15: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_3);\n        goto -> bb1;\n    }\n    bb16: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        return;\n    }\n    bb18: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}