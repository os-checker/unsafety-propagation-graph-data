{
  "name": "rc::Rc::<T, A>::into_inner",
  "safe": true,
  "callees": {
    "rc::Rc::<T, A>::try_unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the inner value, if the `Rc` has exactly one strong reference.\n\n Otherwise, an [`Err`] is returned with the same `Rc` that was\n passed in.\n\n This will succeed even if there are outstanding weak references.\n\n # Examples\n\n ```\n use std::rc::Rc;\n\n let x = Rc::new(3);\n assert_eq!(Rc::try_unwrap(x), Ok(3));\n\n let x = Rc::new(4);\n let _y = Rc::clone(&x);\n assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n ```\n",
      "adt": {
        "rc::Rc": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "rc::Rc": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 1756,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:1098:5: 1100:6",
  "src": "pub fn into_inner(this: Self) -> Option<T> {\n        Rc::try_unwrap(this).ok()\n    }",
  "mir": "fn rc::Rc::<T, A>::into_inner(_1: rc::Rc<T, A>) -> core::option::Option<T> {\n    let mut _0: core::option::Option<T>;\n    let mut _2: core::result::Result<T, rc::Rc<T, A>>;\n    debug this => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = rc::Rc::<T, A>::try_unwrap(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = core::result::Result::<T, rc::Rc<T, A>>::ok(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns the inner value, if the `Rc` has exactly one strong reference.\n\n Otherwise, [`None`] is returned and the `Rc` is dropped.\n\n This will succeed even if there are outstanding weak references.\n\n If `Rc::into_inner` is called on every clone of this `Rc`,\n it is guaranteed that exactly one of the calls returns the inner value.\n This means in particular that the inner value is not dropped.\n\n [`Rc::try_unwrap`] is conceptually similar to `Rc::into_inner`.\n And while they are meant for different use-cases, `Rc::into_inner(this)`\n is in fact equivalent to <code>[Rc::try_unwrap]\\(this).[ok][Result::ok]()</code>.\n (Note that the same kind of equivalence does **not** hold true for\n [`Arc`](crate::sync::Arc), due to race conditions that do not apply to `Rc`!)\n\n # Examples\n\n ```\n use std::rc::Rc;\n\n let x = Rc::new(3);\n assert_eq!(Rc::into_inner(x), Some(3));\n\n let x = Rc::new(4);\n let y = Rc::clone(&x);\n\n assert_eq!(Rc::into_inner(y), None);\n assert_eq!(Rc::into_inner(x), Some(4));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}