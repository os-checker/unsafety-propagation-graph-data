{
  "name": "<collections::btree::set::BTreeSet<T> as core::iter::FromIterator<T>>::from_iter",
  "safe": true,
  "callees": {
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "collections::btree::set::BTreeSet::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a new, empty `BTreeSet`.\n\n Does not allocate anything on its own.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n use std::collections::BTreeSet;\n\n let mut set: BTreeSet<i32> = BTreeSet::new();\n ```\n",
      "adt": {
        "collections::btree::set::BTreeSet": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "slice::<impl [T]>::sort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order, preserving initial order of equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\n worst-case.\n\n If the implementation of [`Ord`] for `T` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n When applicable, unstable sorting is preferred because it is generally faster than stable\n sorting and it doesn't allocate auxiliary memory. See\n [`sort_unstable`](slice::sort_unstable). The exception are partially sorted slices, which\n may be better served with `slice::sort`.\n\n Sorting types that only implement [`PartialOrd`] such as [`f32`] and [`f64`] require\n additional precautions. For example, `f32::NAN != f32::NAN`, which doesn't fulfill the\n reflexivity requirement of [`Ord`]. By using an alternative comparison function with\n `slice::sort_by` such as [`f32::total_cmp`] or [`f64::total_cmp`] that defines a [total\n order] users can sort slices containing floating-point values. Alternatively, if all values\n in the slice are guaranteed to be in a subset for which [`PartialOrd::partial_cmp`] forms a\n [total order], it's possible to sort the slice with `sort_by(|a, b|\n a.partial_cmp(b).unwrap())`.\n\n # Current implementation\n\n The current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\n combines the fast average case of quicksort with the fast worst case and partial run\n detection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\n with k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n The auxiliary memory allocation behavior depends on the input length. Short slices are\n handled without allocation, medium sized slices allocate `self.len()` and beyond that it\n clamps at `self.len() / 2`.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `T` does not implement a [total order], or if\n the [`Ord`] implementation itself panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n\n v.sort();\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n ```\n\n [driftsort]: https://github.com/Voultapher/driftsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    },
    "collections::btree::set::BTreeSet::<T, A>::from_sorted_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::set::BTreeSet": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "collections::btree::set::BTreeSet": [
      "Plain"
    ],
    "vec::into_iter::IntoIter": [
      "Plain"
    ]
  },
  "path": 1042,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/set.rs:1469:5: 1479:6",
  "src": "fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeSet<T> {\n        let mut inputs: Vec<_> = iter.into_iter().collect();\n\n        if inputs.is_empty() {\n            return BTreeSet::new();\n        }\n\n        // use stable sort to preserve the insertion order.\n        inputs.sort();\n        BTreeSet::from_sorted_iter(inputs.into_iter(), Global)\n    }",
  "mir": "fn <collections::btree::set::BTreeSet<T> as core::iter::FromIterator<T>>::from_iter(_1: I) -> collections::btree::set::BTreeSet<T> {\n    let mut _0: collections::btree::set::BTreeSet<T>;\n    let mut _2: vec::Vec<T>;\n    let mut _3: <I as core::iter::IntoIterator>::IntoIter;\n    let mut _4: bool;\n    let mut _5: &vec::Vec<T>;\n    let  _6: ();\n    let mut _7: &mut [T];\n    let mut _8: &mut vec::Vec<T>;\n    let mut _9: vec::into_iter::IntoIter<T>;\n    let mut _10: vec::Vec<T>;\n    debug iter => _1;\n    debug inputs => _2;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = <I as core::iter::IntoIterator>::into_iter(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = <<I as core::iter::IntoIterator>::IntoIter as core::iter::Iterator>::collect::<vec::Vec<T>>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_2;\n        _4 = vec::Vec::<T>::is_empty(move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _4) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_5);\n        _0 = collections::btree::set::BTreeSet::<T>::new() -> [return: bb10, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_8);\n        _8 = &mut _2;\n        _7 = <vec::Vec<T> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        _6 = slice::<impl [T]>::sort(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = move _2;\n        _9 = <vec::Vec<T> as core::iter::IntoIterator>::into_iter(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        _0 = collections::btree::set::BTreeSet::<T>::from_sorted_iter::<vec::into_iter::IntoIter<T>>(move _9, alloc::Global) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageDead(_2);\n        goto -> bb12;\n    }\n    bb10: {\n        StorageDead(_4);\n        drop(_2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_2);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}