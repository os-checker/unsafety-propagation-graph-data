{
  "name": "alloc::exchange_malloc",
  "safe": false,
  "callees": {
    "core::alloc::Layout::from_size_align_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout, bypassing all checks.\n\n # Safety\n\n This function is unsafe as it does not verify the preconditions from\n [`Layout::from_size_align`].\n",
      "adt": {}
    },
    "core::alloc::Allocator::allocate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to allocate a block of memory.\n\n On success, returns a [`NonNull<[u8]>`][NonNull] meeting the size and alignment guarantees of `layout`.\n\n The returned block may have a larger size than specified by `layout.size()`, and may or may\n not have its contents initialized.\n\n The returned block of memory remains valid as long as it is [*currently allocated*] and the shorter of:\n   - the borrow-checker lifetime of the allocator type itself.\n   - as long as the allocator and all its clones have not been dropped.\n\n [*currently allocated*]: #currently-allocated-memory\n\n # Errors\n\n Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n allocator's size or alignment constraints.\n\n Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an allocation error are encouraged to\n call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "alloc::handle_alloc_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Signals a memory allocation error.\n\n Callers of memory allocation APIs wishing to cease execution\n in response to an allocation error are encouraged to call this function,\n rather than directly invoking [`panic!`] or similar.\n\n This function is guaranteed to diverge (not return normally with a value), but depending on\n global configuration, it may either panic (resulting in unwinding or aborting as per\n configuration for all panics), or abort the process (with no unwinding).\n\n The default behavior is:\n\n  * If the binary links against `std` (typically the case), then\n   print a message to standard error and abort the process.\n   This behavior can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n   Future versions of Rust may panic by default instead.\n\n * If the binary does not link against `std` (all of its crates are marked\n   [`#![no_std]`][no_std]), then call [`panic!`] with a message.\n   [The panic handler] applies as to any panic.\n\n [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n [The panic handler]: https://doc.rust-lang.org/reference/runtime.html#the-panic_handler-attribute\n [no_std]: https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute\n",
      "adt": {}
    },
    "core::ptr::NonNull::<[T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n # Examples\n\n ```rust\n #![feature(slice_ptr_get)]\n use std::ptr::NonNull;\n\n let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n assert_eq!(slice.as_mut_ptr(), NonNull::<i8>::dangling().as_ptr());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain"
    ],
    "alloc::Global": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 188, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 195, kind: RigidTy(Slice(Ty { id: 93, kind: RigidTy(Uint(U8)) })) })]))) })])"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::alloc::exchange_malloc"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/alloc.rs:350:1: 356:2",
  "src": "unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n    let layout = unsafe { Layout::from_size_align_unchecked(size, align) };\n    match Global.allocate(layout) {\n        Ok(ptr) => ptr.as_mut_ptr(),\n        Err(_) => handle_alloc_error(layout),\n    }\n}",
  "mir": "fn alloc::exchange_malloc(_1: usize, _2: usize) -> *mut u8 {\n    let mut _0: *mut u8;\n    let  _3: core::alloc::Layout;\n    let mut _4: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _5: &alloc::Global;\n    let mut _6: isize;\n    let  _7: core::ptr::NonNull<[u8]>;\n    let mut _8: !;\n    debug size => _1;\n    debug align => _2;\n    debug layout => _3;\n    debug ptr => _7;\n    bb0: {\n        _3 = core::alloc::Layout::from_size_align_unchecked(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = alloc::exchange_malloc::promoted[0];\n        _4 = <alloc::Global as core::alloc::Allocator>::allocate(move _5, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _8 = alloc::handle_alloc_error(_3) -> unwind unreachable;\n    }\n    bb5: {\n        _7 = ((_4 as variant#0).0: core::ptr::NonNull<[u8]>);\n        _0 = core::ptr::NonNull::<[u8]>::as_mut_ptr(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " The allocator for `Box`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}