{
  "name": "collections::vec_deque::VecDeque::<T, A>::try_reserve_exact",
  "safe": true,
  "callees": {
    "core::num::<impl usize>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::ok_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err)`].\n\n Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n result of a function call, it is recommended to use [`ok_or_else`], which is\n lazily evaluated.\n\n [`Ok(v)`]: Ok\n [`Err(err)`]: Err\n [`Some(v)`]: Some\n [`ok_or_else`]: Option::ok_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.ok_or(0), Ok(\"foo\"));\n\n let x: Option<&str> = None;\n assert_eq!(x.ok_or(0), Err(0));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "raw_vec::RawVec::<T, A>::try_reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "raw_vec::RawVec": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::handle_capacity_increase": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Frobs the head and tail sections around to handle the fact that we\n just reallocated. Unsafe because it trusts old_capacity.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "collections::TryReserveErrorKind": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 251, kind: RigidTy(Adt(AdtDef(DefId { id: 2596, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 234, kind: RigidTy(Adt(AdtDef(DefId { id: 2685, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 191, kind: RigidTy(Adt(AdtDef(DefId { id: 2652, name: \"collections::TryReserveErrorKind\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 232, kind: RigidTy(Adt(AdtDef(DefId { id: 2596, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 234, kind: RigidTy(Adt(AdtDef(DefId { id: 2685, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 35, kind: RigidTy(Adt(AdtDef(DefId { id: 2595, name: \"collections::TryReserveError\" }), GenericArgs([]))) })]))) })])"
    ],
    "raw_vec::RawVec": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve_exact"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1093:5: 1105:6",
  "src": "pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {\n        let new_cap =\n            self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;\n        let old_cap = self.capacity();\n\n        if new_cap > old_cap {\n            self.buf.try_reserve_exact(self.len, additional)?;\n            unsafe {\n                self.handle_capacity_increase(old_cap);\n            }\n        }\n        Ok(())\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::try_reserve_exact(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize) -> core::result::Result<(), collections::TryReserveError> {\n    let mut _0: core::result::Result<(), collections::TryReserveError>;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, collections::TryReserveErrorKind>, usize>;\n    let mut _4: core::result::Result<usize, collections::TryReserveErrorKind>;\n    let mut _5: core::option::Option<usize>;\n    let mut _6: usize;\n    let mut _7: collections::TryReserveErrorKind;\n    let mut _8: isize;\n    let  _9: core::result::Result<core::convert::Infallible, collections::TryReserveErrorKind>;\n    let  _10: usize;\n    let  _11: usize;\n    let mut _12: &collections::vec_deque::VecDeque<T, A>;\n    let mut _13: bool;\n    let mut _14: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, collections::TryReserveError>>;\n    let mut _15: core::result::Result<(), collections::TryReserveError>;\n    let mut _16: &mut raw_vec::RawVec<T, A>;\n    let mut _17: usize;\n    let mut _18: isize;\n    let  _19: core::result::Result<core::convert::Infallible, collections::TryReserveError>;\n    let  _20: ();\n    debug self => _1;\n    debug additional => _2;\n    debug new_cap => _10;\n    debug residual => _9;\n    debug val => _10;\n    debug old_cap => _11;\n    debug residual => _19;\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = ((*_1).1: usize);\n        _5 = core::num::<impl usize>::checked_add(move _6, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = collections::TryReserveErrorKind::CapacityOverflow;\n        _4 = core::option::Option::<usize>::ok_or::<collections::TryReserveErrorKind>(move _5, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageDead(_5);\n        _3 = <core::result::Result<usize, collections::TryReserveErrorKind> as core::ops::Try>::branch(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _8 = discriminant(_3);\n        switchInt(move _8) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _10 = ((_3 as variant#0).0: usize);\n        StorageDead(_3);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = collections::vec_deque::VecDeque::<T, A>::capacity(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _9 = move ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, collections::TryReserveErrorKind>);\n        _0 = <core::result::Result<(), collections::TryReserveError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, collections::TryReserveErrorKind>>>::from_residual(_9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_3);\n        goto -> bb18;\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageLive(_13);\n        _13 = Gt(_10, _11);\n        switchInt(move _13) -> [0: bb16, otherwise: bb9];\n    }\n    bb9: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut ((*_1).2: raw_vec::RawVec<T, A>);\n        StorageLive(_17);\n        _17 = ((*_1).1: usize);\n        _15 = raw_vec::RawVec::<T, A>::try_reserve_exact(move _16, move _17, _2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _14 = <core::result::Result<(), collections::TryReserveError> as core::ops::Try>::branch(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _18 = discriminant(_14);\n        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb4];\n    }\n    bb12: {\n        StorageDead(_14);\n        _20 = collections::vec_deque::VecDeque::<T, A>::handle_capacity_increase(_1, _11) -> [return: bb15, unwind unreachable];\n    }\n    bb13: {\n        _19 = move ((_14 as variant#1).0: core::result::Result<core::convert::Infallible, collections::TryReserveError>);\n        _0 = <core::result::Result<(), collections::TryReserveError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, collections::TryReserveError>>>::from_residual(_19) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb18;\n    }\n    bb15: {\n        goto -> bb17;\n    }\n    bb16: {\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_13);\n        _0 = core::result::Result::Ok(());\n        goto -> bb19;\n    }\n    bb18: {\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": " Tries to reserve the minimum capacity for at least `additional` more elements to\n be inserted in the given deque. After calling `try_reserve_exact`,\n capacity will be greater than or equal to `self.len() + additional` if\n it returns `Ok(())`. Does nothing if the capacity is already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`try_reserve`] if future insertions are expected.\n\n [`try_reserve`]: VecDeque::try_reserve\n\n # Errors\n\n If the capacity overflows `usize`, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n use std::collections::VecDeque;\n\n fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     let mut output = VecDeque::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve_exact(data.len())?;\n\n     // Now we know this can't OOM(Out-Of-Memory) in the middle of our complex work\n     output.extend(data.iter().map(|&val| {\n         val * 2 + 5 // very complicated\n     }));\n\n     Ok(output)\n }\n # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}