{
  "name": "<collections::vec_deque::VecDeque<T, A> as core::convert::From<vec::Vec<T, A>>>::from",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::into_raw_parts_with_alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Decomposes a `Vec<T>` into its raw components: `(pointer, length, capacity, allocator)`.\n\n Returns the raw pointer to the underlying data, the length of the vector (in elements),\n the allocated capacity of the data (in elements), and the allocator. These are the same\n arguments in the same order as the arguments to [`from_raw_parts_in`].\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Vec`. The only way to do\n this is to convert the raw pointer, length, and capacity back\n into a `Vec` with the [`from_raw_parts_in`] function, allowing\n the destructor to perform the cleanup.\n\n [`from_raw_parts_in`]: Vec::from_raw_parts_in\n\n # Examples\n\n ```\n #![feature(allocator_api)]\n\n use std::alloc::System;\n\n let mut v: Vec<i32, System> = Vec::new_in(System);\n v.push(-1);\n v.push(0);\n v.push(1);\n\n let (ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();\n\n let rebuilt = unsafe {\n     // We can now make changes to the components, such as\n     // transmuting the raw pointer to a compatible type.\n     let ptr = ptr as *mut u32;\n\n     Vec::from_raw_parts_in(ptr, len, cap, alloc)\n };\n assert_eq!(rebuilt, [4294967295, 0, 1]);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "raw_vec::RawVec::<T, A>::from_raw_parts_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n\n # Safety\n\n The `ptr` must be allocated (via the given allocator `alloc`), and with the given\n `capacity`.\n The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n systems). For ZSTs capacity is ignored.\n If the `ptr` and `capacity` come from a `RawVec` created via `alloc`, then this is\n guaranteed.\n",
      "adt": {
        "raw_vec::RawVec": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Plain"
    ],
    "raw_vec::RawVec": [
      "Plain"
    ],
    "collections::vec_deque::VecDeque": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::vec_deque::VecDeque<T, A> as core::convert::From<vec::Vec<T, A>>>::from"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3684:5: 3687:6",
  "src": "fn from(other: Vec<T, A>) -> Self {\n        let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();\n        Self { head: 0, len, buf: unsafe { RawVec::from_raw_parts_in(ptr, cap, alloc) } }\n    }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as core::convert::From<vec::Vec<T, A>>>::from(_1: vec::Vec<T, A>) -> collections::vec_deque::VecDeque<T, A> {\n    let mut _0: collections::vec_deque::VecDeque<T, A>;\n    let  _2: *mut T;\n    let  _3: usize;\n    let  _4: usize;\n    let  _5: A;\n    let mut _6: (*mut T, usize, usize, A);\n    let mut _7: raw_vec::RawVec<T, A>;\n    debug other => _1;\n    debug ptr => _2;\n    debug len => _3;\n    debug cap => _4;\n    debug alloc => _5;\n    bb0: {\n        StorageLive(_6);\n        _6 = vec::Vec::<T, A>::into_raw_parts_with_alloc(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = (_6.0: *mut T);\n        _3 = (_6.1: usize);\n        _4 = (_6.2: usize);\n        _5 = move (_6.3: A);\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = raw_vec::RawVec::<T, A>::from_raw_parts_in(_2, _4, _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = VecDeque(0_usize, _3, move _7);\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": " Turn a [`Vec<T>`] into a [`VecDeque<T>`].\n\n [`Vec<T>`]: crate::vec::Vec\n [`VecDeque<T>`]: crate::collections::VecDeque\n\n This conversion is guaranteed to run in *O*(1) time\n and to not re-allocate the `Vec`'s buffer or allocate\n any additional memory.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}