{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::last_entry",
  "safe": true,
  "callees": {
    "collections::btree::borrow::DormantMutRef::<'a, T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Capture a unique borrow, and immediately reborrow it. For the compiler,\n the lifetime of the new reference is the same as the lifetime of the\n original reference, but you promise to use it for a shorter period.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "Constructor"
      }
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the rightmost leaf edge in or underneath a node - in other words, the edge\n you need last when navigating forward (or first when navigating backward).\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, NodeType>, collections::btree::node::marker::Edge>::left_kv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::forget_node_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::btree::map::BTreeMap": [
      "MutRef",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "Plain",
      "Unknown([Field(0, Ty { id: 2800, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2802, kind: RigidTy(Adt(AdtDef(DefId { id: 3598, name: \"collections::btree::map::BTreeMap\" }), GenericArgs([Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 881, kind: Param(ParamTy { index: 2, name: \"A\" }) })]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 3116, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2802, kind: RigidTy(Adt(AdtDef(DefId { id: 3598, name: \"collections::btree::map::BTreeMap\" }), GenericArgs([Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 881, kind: Param(ParamTy { index: 2, name: \"A\" }) })]))) })]))) })])"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2378, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3124, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2412, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2548, kind: RigidTy(Adt(AdtDef(DefId { id: 3539, name: \"collections::btree::node::marker::KV\" }), GenericArgs([]))) })]))) })])"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "Ref"
    ],
    "collections::btree::map::entry::OccupiedEntry": [
      "Plain"
    ]
  },
  "path": 617,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:922:5: 935:6",
  "src": "pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V, A>>\n    where\n        K: Ord,\n    {\n        let (map, dormant_map) = DormantMutRef::new(self);\n        let root_node = map.root.as_mut()?.borrow_mut();\n        let kv = root_node.last_leaf_edge().left_kv().ok()?;\n        Some(OccupiedEntry {\n            handle: kv.forget_node_type(),\n            dormant_map,\n            alloc: (*map.alloc).clone(),\n            _marker: PhantomData,\n        })\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::last_entry(_1: &mut collections::btree::map::BTreeMap<K, V, A>) -> core::option::Option<collections::btree::map::entry::OccupiedEntry<'_, K, V, A>> {\n    let mut _0: core::option::Option<collections::btree::map::entry::OccupiedEntry<'_, K, V, A>>;\n    let  _2: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let  _3: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _4: (&mut collections::btree::map::BTreeMap<K, V, A>, collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n    let  _5: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _6: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _7: core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _8: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _9: isize;\n    let  _10: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _11: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>>;\n    let mut _12: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>>;\n    let mut _13: core::result::Result<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _14: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _15: isize;\n    let  _16: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _17: collections::btree::map::entry::OccupiedEntry<'_, K, V, A>;\n    let mut _18: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _19: A;\n    let  _20: &A;\n    let mut _21: &core::mem::ManuallyDrop<A>;\n    debug self => _1;\n    debug map => _2;\n    debug dormant_map => _3;\n    debug root_node => _5;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _10;\n    debug kv => _16;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _16;\n    bb0: {\n        StorageLive(_4);\n        _4 = collections::btree::borrow::DormantMutRef::<'_, collections::btree::map::BTreeMap<K, V, A>>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        _2 = move (_4.0: &mut collections::btree::map::BTreeMap<K, V, A>);\n        _3 = move (_4.1: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &mut ((*_2).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _7 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::as_mut(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _6 = <core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>> as core::ops::Try>::branch(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _9 = discriminant(_6);\n        switchInt(move _9) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _10 = move ((_6 as variant#0).0: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        _5 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_10) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = <core::option::Option<collections::btree::map::entry::OccupiedEntry<'_, K, V, A>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_6);\n        goto -> bb19;\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::last_leaf_edge(_5) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _13 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::left_kv(move _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        _12 = core::result::Result::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>, collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>::ok(move _13) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        _11 = <core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>> as core::ops::Try>::branch(move _12) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_12);\n        _15 = discriminant(_11);\n        switchInt(move _15) -> [0: bb13, 1: bb14, otherwise: bb4];\n    }\n    bb13: {\n        _16 = move ((_11 as variant#0).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>);\n        StorageDead(_11);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::forget_node_type(_16) -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        _0 = <core::option::Option<collections::btree::map::entry::OccupiedEntry<'_, K, V, A>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_11);\n        goto -> bb19;\n    }\n    bb16: {\n        StorageLive(_19);\n        StorageLive(_21);\n        _21 = &((*_2).2: core::mem::ManuallyDrop<A>);\n        _20 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _21) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_21);\n        _19 = <A as core::clone::Clone>::clone(_20) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _17 = OccupiedEntry(move _18, _3, move _19, ZeroSized: core::marker::PhantomData<&mut (K, V)>);\n        StorageDead(_19);\n        StorageDead(_18);\n        _0 = core::option::Option::Some(move _17);\n        StorageDead(_17);\n        StorageDead(_2);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_2);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": " Returns the last entry in the map for in-place manipulation.\n The key of this entry is the maximum key in the map.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n map.insert(2, \"b\");\n if let Some(mut entry) = map.last_entry() {\n     if *entry.key() > 0 {\n         entry.insert(\"last\");\n     }\n }\n assert_eq!(*map.get(&1).unwrap(), \"a\");\n assert_eq!(*map.get(&2).unwrap(), \"last\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}