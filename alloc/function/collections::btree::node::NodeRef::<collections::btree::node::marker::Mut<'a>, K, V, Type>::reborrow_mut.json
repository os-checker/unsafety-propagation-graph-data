{
  "name": "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut",
  "safe": false,
  "callees": {},
  "adts": {
    "collections::btree::node::NodeRef": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Plain",
      "MutRef"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:436:5: 438:6",
  "src": "unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n        NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n    }",
  "mir": "fn collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut(_1: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, Type>) -> collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, Type> {\n    let mut _0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, Type>;\n    let mut _2: usize;\n    let mut _3: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = ((*_1).0: usize);\n        StorageLive(_3);\n        _3 = ((*_1).1: core::ptr::NonNull<collections::btree::node::LeafNode<K, V>>);\n        _0 = NodeRef(move _2, move _3, ZeroSized: core::marker::PhantomData<(collections::btree::node::marker::Mut<'_>, Type)>);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}