{
  "name": "vec::in_place_collect::from_iter_in_place",
  "safe": true,
  "callees": {
    "core::iter::SourceIter::as_inner": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Retrieve the source of an iterator pipeline.\n\n # Safety\n\n Implementations must return the same mutable reference for their lifetime, unless\n replaced by a caller.\n\n Callers may only replace the reference when they stopped iteration and drop the\n iterator pipeline after extracting the source.\n\n This means iterator adapters can rely on the source not changing during\n iteration but they cannot rely on it in their Drop implementations.\n\n Implementing this method means adapters relinquish private-only access to their\n source and can only rely on guarantees made based on method receiver types.\n The lack of restricted access also requires that adapters must uphold the source's\n public API even when they have access to its internals.\n\n Callers in turn must expect the source to be in any state that is consistent with\n its public API since adapters sitting between it and the source have the same\n access. In particular an adapter may have consumed more elements than strictly necessary.\n\n The overall goal of these requirements is to let the consumer of a pipeline use\n * whatever remains in the source after iteration has stopped\n * the memory that has become unused by advancing a consuming iterator\n\n [`next()`]: Iterator::next()\n",
      "adt": {}
    },
    "vec::in_place_collect::AsVecIntoIter::as_into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "core::num::<impl usize>::unchecked_mul": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur.\n\n Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n\n If you're just trying to avoid the panic in debug mode, then **do not**\n use this.  Instead, you're looking for [`wrapping_mul`].\n\n # Safety\n\n This results in undefined behavior when\n i.e. when [`checked_mul`] would return `None`.\n\n [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "vec::in_place_collect::SpecInPlaceCollect::collect_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Collects an iterator (`self`) into the destination buffer (`dst`) and returns the number of items\n collected. `end` is the last writable element of the allocation and used for bounds checks.\n\n This method is specialized and one of its implementations makes use of\n `Iterator::__iterator_get_unchecked` calls with a `TrustedRandomAccessNoCoerce` bound\n on `I` which means the caller of this method must take the safety conditions\n of that trait into consideration.\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an offset to a pointer (convenience for `.offset(count as isize)`).\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let s: &str = \"123\";\n let ptr: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap();\n\n unsafe {\n     println!(\"{}\", ptr.add(1).read() as char);\n     println!(\"{}\", ptr.add(2).read() as char);\n }\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "vec::into_iter::IntoIter::<T, A>::forget_allocation_drop_remaining": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Drops remaining elements and relinquishes the backing allocation.\n\n This method guarantees it won't panic before relinquishing the backing\n allocation.\n\n This is roughly equivalent to the following, but more efficient\n\n ```\n # let mut vec = Vec::<u8>::with_capacity(10);\n # let ptr = vec.as_mut_ptr();\n # let mut into_iter = vec.into_iter();\n let mut into_iter = std::mem::replace(&mut into_iter, Vec::new().into_iter());\n (&mut into_iter).for_each(drop);\n std::mem::forget(into_iter);\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # drop(unsafe { Vec::<u8>::from_raw_parts(ptr, 0, 10) });\n ```\n\n This method is used by in-place iteration, refer to the vec::in_place_collect\n documentation for an overview.\n",
      "adt": {
        "vec::into_iter::IntoIter": "MutableAsArgument"
      }
    },
    "vec::in_place_collect::needs_realloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::from_size_align_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout, bypassing all checks.\n\n # Safety\n\n This function is unsafe as it does not verify the preconditions from\n [`Layout::from_size_align`].\n",
      "adt": {}
    },
    "core::alloc::Allocator::shrink": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to shrink the memory block.\n\n Returns a new [`NonNull<[u8]>`][NonNull] containing a pointer and the actual size of the allocated\n memory. The pointer is suitable for holding data described by `new_layout`. To accomplish\n this, the allocator may shrink the allocation referenced by `ptr` to fit the new layout.\n\n If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n transferred to this allocator. Any access to the old `ptr` is Undefined Behavior, even if the\n allocation was shrunk in-place. The newly returned pointer is the only valid pointer\n for accessing this memory now.\n\n If this method returns `Err`, then ownership of the memory block has not been transferred to\n this allocator, and the contents of the memory block are unaltered.\n\n # Safety\n\n * `ptr` must denote a block of memory [*currently allocated*] via this allocator.\n * `old_layout` must [*fit*] that block of memory (The `new_layout` argument need not fit it.).\n * `new_layout.size()` must be smaller than or equal to `old_layout.size()`.\n\n Note that `new_layout.align()` need not be the same as `old_layout.align()`.\n\n [*currently allocated*]: #currently-allocated-memory\n [*fit*]: #memory-fitting\n\n # Errors\n\n Returns `Err` if the new layout does not meet the allocator's size and alignment\n constraints of the allocator, or if shrinking otherwise fails.\n\n Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement\n this trait atop an underlying native allocation library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an allocation error are encouraged to\n call the [`handle_alloc_error`] function, rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "alloc::handle_alloc_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Signals a memory allocation error.\n\n Callers of memory allocation APIs wishing to cease execution\n in response to an allocation error are encouraged to call this function,\n rather than directly invoking [`panic!`] or similar.\n\n This function is guaranteed to diverge (not return normally with a value), but depending on\n global configuration, it may either panic (resulting in unwinding or aborting as per\n configuration for all panics), or abort the process (with no unwinding).\n\n The default behavior is:\n\n  * If the binary links against `std` (typically the case), then\n   print a message to standard error and abort the process.\n   This behavior can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n   Future versions of Rust may panic by default instead.\n\n * If the binary does not link against `std` (all of its crates are marked\n   [`#![no_std]`][no_std]), then call [`panic!`] with a message.\n   [The panic handler] applies as to any panic.\n\n [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n [The panic handler]: https://doc.rust-lang.org/reference/runtime.html#the-panic_handler-attribute\n [no_std]: https://doc.rust-lang.org/reference/names/preludes.html#the-no_std-attribute\n",
      "adt": {}
    },
    "core::mem::forget": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes ownership and \"forgets\" about the value **without running its destructor**.\n\n Any resources the value manages, such as heap memory or a file handle, will linger\n forever in an unreachable state. However, it does not guarantee that pointers\n to this memory will remain valid.\n\n * If you want to leak memory, see [`Box::leak`].\n * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n * If you want to dispose of a value properly, running its destructor, see\n   [`mem::drop`].\n\n # Safety\n\n `forget` is not marked as `unsafe`, because Rust's safety guarantees\n do not include a guarantee that destructors will always run. For example,\n a program can create a reference cycle using [`Rc`][rc], or call\n [`process::exit`][exit] to exit without running destructors. Thus, allowing\n `mem::forget` from safe code does not fundamentally change Rust's safety\n guarantees.\n\n That said, leaking resources such as memory or I/O objects is usually undesirable.\n The need comes up in some specialized use cases for FFI or unsafe code, but even\n then, [`ManuallyDrop`] is typically preferred.\n\n Because forgetting a value is allowed, any `unsafe` code you write must\n allow for this possibility. You cannot return a value and expect that the\n caller will necessarily run the value's destructor.\n\n [rc]: ../../std/rc/struct.Rc.html\n [exit]: ../../std/process/fn.exit.html\n\n # Examples\n\n The canonical safe use of `mem::forget` is to circumvent a value's destructor\n implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n the space taken by the variable but never close the underlying system resource:\n\n ```no_run\n use std::mem;\n use std::fs::File;\n\n let file = File::open(\"foo.txt\").unwrap();\n mem::forget(file);\n ```\n\n This is useful when the ownership of the underlying resource was previously\n transferred to code outside of Rust, for example by transmitting the raw\n file descriptor to C code.\n\n # Relationship with `ManuallyDrop`\n\n While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n\n ```\n use std::mem;\n\n let mut v = vec![65, 122];\n // Build a `String` using the contents of `v`\n let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n // leak `v` because its memory is now managed by `s`\n mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n There are two issues with the above example:\n\n * If more code were added between the construction of `String` and the invocation of\n   `mem::forget()`, a panic within it would cause a double free because the same memory\n   is handled by both `v` and `s`.\n * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n   inspect it), some types have strict requirements on their values that\n   make them invalid when dangling or no longer owned. Using invalid values in any\n   way, including passing them to or returning them from functions, constitutes\n   undefined behavior and may break the assumptions made by the compiler.\n\n Switching to `ManuallyDrop` avoids both issues:\n\n ```\n use std::mem::ManuallyDrop;\n\n let v = vec![65, 122];\n // Before we disassemble `v` into its raw parts, make sure it\n // does not get dropped!\n let mut v = ManuallyDrop::new(v);\n // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n // Finally, build a `String`.\n let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n argument, forcing us to call it only after extracting anything we need from `v`. Even\n if a panic were introduced between construction of `ManuallyDrop` and building the\n string (which cannot happen in the code as shown), it would result in a leak and not a\n double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n erring on the side of (double-)dropping.\n\n Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n ownership to `s` — the final step of interacting with `v` to dispose of it without\n running its destructor is entirely avoided.\n\n [`Box`]: ../../std/boxed/struct.Box.html\n [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n [`mem::drop`]: drop\n [ub]: ../../reference/behavior-considered-undefined.html\n",
      "adt": {}
    },
    "vec::Vec::<T>::from_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a `Vec<T>` directly from a `NonNull` pointer, a length, and a capacity.\n\n # Safety\n\n This is highly unsafe, due to the number of invariants that aren't\n checked:\n\n * `ptr` must have been allocated using the global allocator, such as via\n   the [`alloc::alloc`] function.\n * `T` needs to have the same alignment as what `ptr` was allocated with.\n   (`T` having a less strict alignment is not sufficient, the alignment really\n   needs to be equal to satisfy the [`dealloc`] requirement that memory must be\n   allocated and deallocated with the same layout.)\n * The size of `T` times the `capacity` (ie. the allocated size in bytes) needs\n   to be the same size as the pointer was allocated with. (Because similar to\n   alignment, [`dealloc`] must be called with the same layout `size`.)\n * `length` needs to be less than or equal to `capacity`.\n * The first `length` values must be properly initialized values of type `T`.\n * `capacity` needs to be the capacity that the pointer was allocated with.\n * The allocated size in bytes must be no larger than `isize::MAX`.\n   See the safety documentation of [`pointer::offset`].\n\n These requirements are always upheld by any `ptr` that has been allocated\n via `Vec<T>`. Other allocation sources are allowed if the invariants are\n upheld.\n\n Violating these may cause problems like corrupting the allocator's\n internal data structures. For example it is normally **not** safe\n to build a `Vec<u8>` from a pointer to a C `char` array with length\n `size_t`, doing so is only safe if the array was initially allocated by\n a `Vec` or `String`.\n It's also not safe to build one from a `Vec<u16>` and its length, because\n the allocator cares about the alignment, and these two types have different\n alignments. The buffer was allocated with alignment 2 (for `u16`), but after\n turning it into a `Vec<u8>` it'll be deallocated with alignment 1. To avoid\n these issues, it is often preferable to do casting/transmuting using\n [`NonNull::slice_from_raw_parts`] instead.\n\n The ownership of `ptr` is effectively transferred to the\n `Vec<T>` which may then deallocate, reallocate or change the\n contents of memory pointed to by the pointer at will. Ensure\n that nothing else uses the pointer after calling this\n function.\n\n [`String`]: crate::string::String\n [`alloc::alloc`]: crate::alloc::alloc\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n\n # Examples\n\n ```\n #![feature(box_vec_non_null)]\n\n let v = vec![1, 2, 3];\n\n // Deconstruct the vector into parts.\n let (p, len, cap) = v.into_parts();\n\n unsafe {\n     // Overwrite memory with 4, 5, 6\n     for i in 0..len {\n         p.add(i).write(4 + i);\n     }\n\n     // Put everything back together into a Vec\n     let rebuilt = Vec::from_parts(p, len, cap);\n     assert_eq!(rebuilt, [4, 5, 6]);\n }\n ```\n\n Using memory that was allocated elsewhere:\n\n ```rust\n #![feature(box_vec_non_null)]\n\n use std::alloc::{alloc, Layout};\n use std::ptr::NonNull;\n\n fn main() {\n     let layout = Layout::array::<u32>(16).expect(\"overflow cannot happen\");\n\n     let vec = unsafe {\n         let Some(mem) = NonNull::new(alloc(layout).cast::<u32>()) else {\n             return;\n         };\n\n         mem.write(1_000_000);\n\n         Vec::from_parts(mem, 1, 16)\n     };\n\n     assert_eq!(vec, &[1_000_000]);\n     assert_eq!(vec.capacity(), 16);\n }\n ```\n",
      "adt": {
        "alloc::Global": "Constructor",
        "vec::Vec": "Constructor"
      }
    }
  },
  "adts": {
    "vec::into_iter::IntoIter": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))"
    ],
    "core::ptr::NonNull": [
      "Plain",
      "Unknown([Field(0, Ty { id: 10435, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 10463, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 5987, name: \"vec::in_place_collect::AsVecIntoIter::Item\" }), args: GenericArgs([Type(Ty { id: 10462, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 5979, name: \"core::iter::SourceIter::Source\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })]) }) })]))) })])",
      "Unknown([Field(1, Ty { id: 10435, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 10463, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 5987, name: \"vec::in_place_collect::AsVecIntoIter::Item\" }), args: GenericArgs([Type(Ty { id: 10462, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 5979, name: \"core::iter::SourceIter::Source\" }), args: GenericArgs([Type(Ty { id: 767, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })]) }) })]))) })])",
      "Unknown([Field(2, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(3, Ty { id: 118, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 110, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])",
      "Unknown([Field(4, Ty { id: 1044, kind: RigidTy(RawPtr(Ty { id: 110, kind: Param(ParamTy { index: 1, name: \"T\" }) }, Not)) })])",
      "Unknown([Field(5, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "vec::in_place_drop::InPlaceDstDataSrcBufDrop": [
      "Plain"
    ],
    "core::alloc::Layout": [
      "Plain"
    ],
    "alloc::Global": [
      "Ref",
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 188, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 195, kind: RigidTy(Slice(Ty { id: 93, kind: RigidTy(Uint(U8)) })) })]))) })])"
    ],
    "vec::Vec": [
      "Plain"
    ]
  },
  "path": 2216,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/in_place_collect.rs:249:1: 334:2",
  "src": "fn from_iter_in_place<I, T>(mut iterator: I) -> Vec<T>\nwhere\n    I: Iterator<Item = T> + InPlaceCollect,\n    <I as SourceIter>::Source: AsVecIntoIter,\n{\n    let (src_buf, src_ptr, src_cap, mut dst_buf, dst_end, dst_cap) = unsafe {\n        let inner = iterator.as_inner().as_into_iter();\n        (\n            inner.buf,\n            inner.ptr,\n            inner.cap,\n            inner.buf.cast::<T>(),\n            inner.end as *const T,\n            // SAFETY: the multiplication can not overflow, since `inner.cap * size_of::<I::SRC>()` is the size of the allocation.\n            inner.cap.unchecked_mul(size_of::<I::Src>()) / size_of::<T>(),\n        )\n    };\n\n    // SAFETY: `dst_buf` and `dst_end` are the start and end of the buffer.\n    let len = unsafe {\n        SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf.as_ptr() as *mut T, dst_end)\n    };\n\n    let src = unsafe { iterator.as_inner().as_into_iter() };\n    // check if SourceIter contract was upheld\n    // caveat: if they weren't we might not even make it to this point\n    debug_assert_eq!(src_buf, src.buf);\n    // check InPlaceIterable contract. This is only possible if the iterator advanced the\n    // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n    // then the source pointer will stay in its initial position and we can't use it as reference\n    if src.ptr != src_ptr {\n        debug_assert!(\n            unsafe { dst_buf.add(len).cast() } <= src.ptr,\n            \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n        );\n    }\n\n    // The ownership of the source allocation and the new `T` values is temporarily moved into `dst_guard`.\n    // This is safe because\n    // * `forget_allocation_drop_remaining` immediately forgets the allocation\n    // before any panic can occur in order to avoid any double free, and then proceeds to drop\n    // any remaining values at the tail of the source.\n    // * the shrink either panics without invalidating the allocation, aborts or\n    //   succeeds. In the last case we disarm the guard.\n    //\n    // Note: This access to the source wouldn't be allowed by the TrustedRandomIteratorNoCoerce\n    // contract (used by SpecInPlaceCollect below). But see the \"O(1) collect\" section in the\n    // module documentation why this is ok anyway.\n    let dst_guard =\n        InPlaceDstDataSrcBufDrop { ptr: dst_buf, len, src_cap, src: PhantomData::<I::Src> };\n    src.forget_allocation_drop_remaining();\n\n    // Adjust the allocation if the source had a capacity in bytes that wasn't a multiple\n    // of the destination type size.\n    // Since the discrepancy should generally be small this should only result in some\n    // bookkeeping updates and no memmove.\n    if needs_realloc::<I::Src, T>(src_cap, dst_cap) {\n        let alloc = Global;\n        debug_assert_ne!(src_cap, 0);\n        debug_assert_ne!(dst_cap, 0);\n        unsafe {\n            // The old allocation exists, therefore it must have a valid layout.\n            let src_align = align_of::<I::Src>();\n            let src_size = size_of::<I::Src>().unchecked_mul(src_cap);\n            let old_layout = Layout::from_size_align_unchecked(src_size, src_align);\n\n            // The allocation must be equal or smaller for in-place iteration to be possible\n            // therefore the new layout must be ≤ the old one and therefore valid.\n            let dst_align = align_of::<T>();\n            let dst_size = size_of::<T>().unchecked_mul(dst_cap);\n            let new_layout = Layout::from_size_align_unchecked(dst_size, dst_align);\n\n            let result = alloc.shrink(dst_buf.cast(), old_layout, new_layout);\n            let Ok(reallocated) = result else { handle_alloc_error(new_layout) };\n            dst_buf = reallocated.cast::<T>();\n        }\n    } else {\n        debug_assert_eq!(src_cap * size_of::<I::Src>(), dst_cap * size_of::<T>());\n    }\n\n    mem::forget(dst_guard);\n\n    let vec = unsafe { Vec::from_parts(dst_buf, len, dst_cap) };\n\n    vec\n}",
  "mir": "fn vec::in_place_collect::from_iter_in_place(_1: I) -> vec::Vec<T> {\n    let mut _0: vec::Vec<T>;\n    let  _2: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let  _3: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let  _4: usize;\n    let mut _5: core::ptr::NonNull<T>;\n    let  _6: *const T;\n    let  _7: usize;\n    let mut _8: (core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>, core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>, usize, core::ptr::NonNull<T>, *const T, usize);\n    let  _9: &mut vec::into_iter::IntoIter<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _10: &mut <I as core::iter::SourceIter>::Source;\n    let mut _11: &mut I;\n    let mut _12: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _13: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _14: usize;\n    let mut _15: core::ptr::NonNull<T>;\n    let mut _16: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _17: *const T;\n    let mut _18: *const <<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: bool;\n    let  _25: usize;\n    let mut _26: &mut I;\n    let mut _27: *mut T;\n    let mut _28: core::ptr::NonNull<T>;\n    let mut _29: &mut vec::into_iter::IntoIter<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _30: &mut <I as core::iter::SourceIter>::Source;\n    let mut _31: &mut I;\n    let mut _32: (&core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>, &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n    let mut _33: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _34: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let  _35: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let  _36: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _37: bool;\n    let  _38: core::panicking::AssertKind;\n    let  _39: !;\n    let mut _40: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _41: bool;\n    let mut _42: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _43: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _44: bool;\n    let mut _45: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let  _46: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let mut _47: core::ptr::NonNull<T>;\n    let mut _48: core::ptr::NonNull<T>;\n    let mut _49: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>;\n    let  _50: !;\n    let mut _51: core::fmt::Arguments<'_>;\n    let  _52: vec::in_place_drop::InPlaceDstDataSrcBufDrop<<I as vec::in_place_collect::InPlaceCollect>::Src, T>;\n    let mut _53: core::ptr::NonNull<T>;\n    let  _54: ();\n    let mut _55: bool;\n    let  _56: alloc::Global;\n    let mut _57: (&usize, &usize);\n    let mut _58: &usize;\n    let mut _59: &usize;\n    let  _60: &usize;\n    let  _61: &usize;\n    let mut _62: bool;\n    let mut _63: usize;\n    let mut _64: usize;\n    let  _65: core::panicking::AssertKind;\n    let  _66: !;\n    let mut _67: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _68: (&usize, &usize);\n    let mut _69: &usize;\n    let mut _70: &usize;\n    let  _71: &usize;\n    let  _72: &usize;\n    let mut _73: bool;\n    let mut _74: usize;\n    let mut _75: usize;\n    let  _76: core::panicking::AssertKind;\n    let  _77: !;\n    let mut _78: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _79: usize;\n    let  _80: usize;\n    let mut _81: usize;\n    let  _82: core::alloc::Layout;\n    let  _83: usize;\n    let  _84: usize;\n    let mut _85: usize;\n    let  _86: core::alloc::Layout;\n    let  _87: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _88: &alloc::Global;\n    let mut _89: core::ptr::NonNull<u8>;\n    let mut _90: core::ptr::NonNull<T>;\n    let mut _91: !;\n    let  _92: core::ptr::NonNull<[u8]>;\n    let mut _93: isize;\n    let mut _94: core::ptr::NonNull<T>;\n    let mut _95: (&usize, &usize);\n    let mut _96: &usize;\n    let  _97: usize;\n    let mut _98: usize;\n    let mut _99: (usize, bool);\n    let mut _100: &usize;\n    let  _101: usize;\n    let mut _102: usize;\n    let mut _103: (usize, bool);\n    let  _104: &usize;\n    let  _105: &usize;\n    let mut _106: bool;\n    let mut _107: usize;\n    let mut _108: usize;\n    let  _109: core::panicking::AssertKind;\n    let  _110: !;\n    let mut _111: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _112: ();\n    let mut _113: core::ptr::NonNull<T>;\n    debug iterator => _1;\n    debug src_buf => _2;\n    debug src_ptr => _3;\n    debug src_cap => _4;\n    debug dst_buf => _5;\n    debug dst_end => _6;\n    debug dst_cap => _7;\n    debug inner => _9;\n    debug len => _25;\n    debug src => _29;\n    debug left_val => _35;\n    debug right_val => _36;\n    debug kind => _38;\n    debug dst_guard => _52;\n    debug alloc => alloc::Global;\n    debug left_val => _60;\n    debug right_val => _61;\n    debug kind => _65;\n    debug left_val => _71;\n    debug right_val => _72;\n    debug kind => _76;\n    debug src_align => _79;\n    debug src_size => _80;\n    debug old_layout => _82;\n    debug dst_align => _83;\n    debug dst_size => _84;\n    debug new_layout => _86;\n    debug result => _87;\n    debug reallocated => _92;\n    debug left_val => _104;\n    debug right_val => _105;\n    debug kind => _109;\n    debug vec => _0;\n    bb0: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_11);\n        _11 = &mut _1;\n        _10 = <I as core::iter::SourceIter>::as_inner(move _11) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_11);\n        _9 = <<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::as_into_iter(_10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_12);\n        _12 = ((*_9).0: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        StorageLive(_13);\n        _13 = ((*_9).4: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        StorageLive(_14);\n        _14 = ((*_9).2: usize);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = ((*_9).0: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        _15 = core::ptr::NonNull::<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>::cast::<T>(move _16) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = ((*_9).5: *const <<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item);\n        _17 = move _18 as *const T;\n        StorageDead(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = ((*_9).2: usize);\n        StorageLive(_22);\n        _22 = core::mem::size_of::<<I as vec::in_place_collect::InPlaceCollect>::Src>() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _20 = core::num::<impl usize>::unchecked_mul(move _21, move _22) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_23);\n        _23 = core::mem::size_of::<T>() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _24 = Eq(_23, 0_usize);\n        assert(!move _24, \"attempt to divide `{}` by zero\", _20) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _19 = Div(move _20, move _23);\n        StorageDead(_23);\n        StorageDead(_20);\n        _8 = (move _12, move _13, move _14, move _15, move _17, move _19);\n        StorageDead(_19);\n        StorageDead(_17);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageLive(_2);\n        _2 = (_8.0: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        StorageLive(_3);\n        _3 = (_8.1: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        _4 = (_8.2: usize);\n        StorageLive(_5);\n        _5 = (_8.3: core::ptr::NonNull<T>);\n        _6 = (_8.4: *const T);\n        _7 = (_8.5: usize);\n        StorageDead(_8);\n        _26 = &mut _1;\n        StorageLive(_28);\n        _28 = _5;\n        _27 = core::ptr::NonNull::<T>::as_ptr(move _28) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_28);\n        _25 = <I as vec::in_place_collect::SpecInPlaceCollect<T, I>>::collect_in_place(_26, _27, _6) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_31);\n        _31 = &mut _1;\n        _30 = <I as core::iter::SourceIter>::as_inner(move _31) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_31);\n        _29 = <<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::as_into_iter(_30) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_2;\n        StorageLive(_34);\n        _34 = &((*_29).0: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        _32 = (move _33, move _34);\n        StorageDead(_34);\n        StorageDead(_33);\n        _35 = (_32.0: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        _36 = (_32.1: &core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        StorageLive(_37);\n        _37 = <core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item> as core::cmp::PartialEq>::eq(_35, _36) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _37) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_37);\n        StorageDead(_32);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &((*_29).4: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        StorageLive(_43);\n        _43 = &_3;\n        _41 = <core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item> as core::cmp::PartialEq>::ne(move _42, move _43) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        _38 = core::panicking::AssertKind::Eq;\n        StorageLive(_40);\n        _40 = core::option::Option::None;\n        _39 = core::panicking::assert_failed::<core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>, core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>>(_38, _35, _36, move _40) -> unwind unreachable;\n    }\n    bb15: {\n        switchInt(move _41) -> [0: bb23, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _5;\n        _47 = core::ptr::NonNull::<T>::add(move _48, _25) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_48);\n        _46 = core::ptr::NonNull::<T>::cast::<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>(move _47) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_47);\n        _45 = &_46;\n        StorageLive(_49);\n        _49 = &((*_29).4: core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>);\n        _44 = <core::ptr::NonNull<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item> as core::cmp::PartialOrd>::le(move _45, move _49) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        switchInt(move _44) -> [0: bb21, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_49);\n        StorageDead(_45);\n        StorageDead(_46);\n        StorageDead(_44);\n        goto -> bb24;\n    }\n    bb21: {\n        StorageDead(_49);\n        StorageDead(_45);\n        StorageDead(_46);\n        StorageLive(_51);\n        _51 = core::fmt::Arguments::<'_>::from_str(\"InPlaceIterable contract violation, write pointer advanced beyond read pointer\") -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _50 = core::panicking::panic_fmt(move _51) -> unwind unreachable;\n    }\n    bb23: {\n        StorageDead(_43);\n        StorageDead(_42);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_41);\n        StorageLive(_53);\n        _53 = _5;\n        _52 = InPlaceDstDataSrcBufDrop(move _53, _25, _4, ZeroSized: core::marker::PhantomData<<I as vec::in_place_collect::InPlaceCollect>::Src>);\n        StorageDead(_53);\n        _54 = vec::into_iter::IntoIter::<<<I as core::iter::SourceIter>::Source as vec::in_place_collect::AsVecIntoIter>::Item>::forget_allocation_drop_remaining(_29) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageLive(_55);\n        _55 = vec::in_place_collect::needs_realloc::<<I as vec::in_place_collect::InPlaceCollect>::Src, T>(_4, _7) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _55) -> [0: bb45, otherwise: bb27];\n    }\n    bb27: {\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = &_4;\n        StorageLive(_59);\n        _59 = vec::in_place_collect::from_iter_in_place::<I, T>::promoted[1];\n        _57 = (move _58, move _59);\n        StorageDead(_59);\n        StorageDead(_58);\n        _60 = (_57.0: &usize);\n        _61 = (_57.1: &usize);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = (*_60);\n        StorageLive(_64);\n        _64 = (*_61);\n        _62 = Eq(move _63, move _64);\n        switchInt(move _62) -> [0: bb29, otherwise: bb28];\n    }\n    bb28: {\n        StorageDead(_64);\n        StorageDead(_63);\n        _65 = core::panicking::AssertKind::Ne;\n        StorageLive(_67);\n        _67 = core::option::Option::None;\n        _66 = core::panicking::assert_failed::<usize, usize>(_65, _60, _61, move _67) -> unwind unreachable;\n    }\n    bb29: {\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageDead(_57);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = &_7;\n        StorageLive(_70);\n        _70 = vec::in_place_collect::from_iter_in_place::<I, T>::promoted[0];\n        _68 = (move _69, move _70);\n        StorageDead(_70);\n        StorageDead(_69);\n        _71 = (_68.0: &usize);\n        _72 = (_68.1: &usize);\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = (*_71);\n        StorageLive(_75);\n        _75 = (*_72);\n        _73 = Eq(move _74, move _75);\n        switchInt(move _73) -> [0: bb31, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_75);\n        StorageDead(_74);\n        _76 = core::panicking::AssertKind::Ne;\n        StorageLive(_78);\n        _78 = core::option::Option::None;\n        _77 = core::panicking::assert_failed::<usize, usize>(_76, _71, _72, move _78) -> unwind unreachable;\n    }\n    bb31: {\n        StorageDead(_75);\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageDead(_68);\n        _79 = core::mem::align_of::<<I as vec::in_place_collect::InPlaceCollect>::Src>() -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_81);\n        _81 = core::mem::size_of::<<I as vec::in_place_collect::InPlaceCollect>::Src>() -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        _80 = core::num::<impl usize>::unchecked_mul(move _81, _4) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_81);\n        _82 = core::alloc::Layout::from_size_align_unchecked(_80, _79) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _83 = core::mem::align_of::<T>() -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageLive(_85);\n        _85 = core::mem::size_of::<T>() -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _84 = core::num::<impl usize>::unchecked_mul(move _85, _7) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_85);\n        _86 = core::alloc::Layout::from_size_align_unchecked(_84, _83) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = &_56;\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = _5;\n        _89 = core::ptr::NonNull::<T>::cast::<u8>(move _90) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_90);\n        _87 = <alloc::Global as core::alloc::Allocator>::shrink(move _88, move _89, _82, _86) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_89);\n        StorageDead(_88);\n        _93 = discriminant(_87);\n        switchInt(move _93) -> [0: bb43, 1: bb42, otherwise: bb56];\n    }\n    bb42: {\n        _91 = alloc::handle_alloc_error(_86) -> unwind unreachable;\n    }\n    bb43: {\n        _92 = ((_87 as variant#0).0: core::ptr::NonNull<[u8]>);\n        StorageLive(_94);\n        _94 = core::ptr::NonNull::<[u8]>::cast::<T>(_92) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _5 = move _94;\n        StorageDead(_94);\n        StorageDead(_87);\n        goto -> bb52;\n    }\n    bb45: {\n        StorageLive(_95);\n        StorageLive(_96);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = core::mem::size_of::<<I as vec::in_place_collect::InPlaceCollect>::Src>() -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _99 = CheckedMul(_4, _98);\n        assert(!move (_99.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _4, move _98) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _97 = move (_99.0: usize);\n        StorageDead(_98);\n        _96 = &_97;\n        StorageLive(_100);\n        StorageLive(_101);\n        StorageLive(_102);\n        _102 = core::mem::size_of::<T>() -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        _103 = CheckedMul(_7, _102);\n        assert(!move (_103.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _7, move _102) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _101 = move (_103.0: usize);\n        StorageDead(_102);\n        _100 = &_101;\n        _95 = (move _96, move _100);\n        StorageDead(_100);\n        StorageDead(_96);\n        _104 = (_95.0: &usize);\n        _105 = (_95.1: &usize);\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = (*_104);\n        StorageLive(_108);\n        _108 = (*_105);\n        _106 = Eq(move _107, move _108);\n        switchInt(move _106) -> [0: bb51, otherwise: bb50];\n    }\n    bb50: {\n        StorageDead(_108);\n        StorageDead(_107);\n        StorageDead(_106);\n        StorageDead(_101);\n        StorageDead(_97);\n        StorageDead(_95);\n        goto -> bb52;\n    }\n    bb51: {\n        StorageDead(_108);\n        StorageDead(_107);\n        _109 = core::panicking::AssertKind::Eq;\n        StorageLive(_111);\n        _111 = core::option::Option::None;\n        _110 = core::panicking::assert_failed::<usize, usize>(_109, _104, _105, move _111) -> unwind unreachable;\n    }\n    bb52: {\n        StorageDead(_55);\n        _112 = core::mem::forget::<vec::in_place_drop::InPlaceDstDataSrcBufDrop<<I as vec::in_place_collect::InPlaceCollect>::Src, T>>(_52) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageLive(_113);\n        _113 = _5;\n        _0 = vec::Vec::<T>::from_parts(move _113, _25, _7) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_113);\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageDead(_2);\n        drop(_1) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        return;\n    }\n    bb56: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}