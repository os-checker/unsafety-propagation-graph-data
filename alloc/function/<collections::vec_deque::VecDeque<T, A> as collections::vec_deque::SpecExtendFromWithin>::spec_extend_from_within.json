{
  "name": "<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::SpecExtendFromWithin>::spec_extend_from_within",
  "safe": false,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n assert_eq!(deque.len(), 0);\n deque.push_back(1);\n assert_eq!(deque.len(), 1);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::nonoverlapping_ranges": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Get source, destination and count (like the arguments to [`ptr::copy_nonoverlapping`])\n for copying `count` values from index `src` to index `dst`.\n One of the ranges can wrap around the physical buffer, for this reason 2 triples are returned.\n\n Use of the word \"ranges\" specifically refers to `src..src + count` and `dst..dst + count`.\n\n # Safety\n\n - Ranges must not overlap: `src.abs_diff(dst) >= count`.\n - Ranges must be in bounds of the logical buffer: `src + count <= self.capacity()` and `dst + count <= self.capacity()`.\n - `head` must be in bounds: `head < self.capacity()`.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::ops::Range": [
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Plain"
    ],
    "core::array::IntoIter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6781, kind: RigidTy(Tuple([Ty { id: 87, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) }, Ty { id: 69, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(0, Ty { id: 87, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6781, kind: RigidTy(Tuple([Ty { id: 87, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) }, Ty { id: 69, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(1, Ty { id: 69, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6781, kind: RigidTy(Tuple([Ty { id: 87, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) }, Ty { id: 69, kind: RigidTy(RawPtr(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(2, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::SpecExtendFromWithin>::spec_extend_from_within"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:3426:5: 3444:6",
  "src": "unsafe fn spec_extend_from_within(&mut self, src: Range<usize>) {\n        let dst = self.len();\n        let count = src.end - src.start;\n        let src = src.start;\n\n        unsafe {\n            // SAFETY:\n            // - Ranges do not overlap: src entirely spans initialized values, dst entirely spans uninitialized values.\n            // - Ranges are in bounds: guaranteed by the caller.\n            let ranges = self.nonoverlapping_ranges(src, dst, count, self.head);\n            for (src, dst, count) in ranges {\n                ptr::copy_nonoverlapping(src, dst, count);\n            }\n        }\n\n        // SAFETY:\n        // - The elements were just initialized by `copy_nonoverlapping`\n        self.len += count;\n    }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as collections::vec_deque::SpecExtendFromWithin>::spec_extend_from_within(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: core::ops::Range<usize>) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &collections::vec_deque::VecDeque<T, A>;\n    let  _5: usize;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: (usize, bool);\n    let  _9: usize;\n    let  _10: [(*const T, *mut T, usize); 2];\n    let mut _11: usize;\n    let mut _12: core::array::IntoIter<(*const T, *mut T, usize), 2>;\n    let mut _13: core::array::IntoIter<(*const T, *mut T, usize), 2>;\n    let mut _14: core::option::Option<(*const T, *mut T, usize)>;\n    let mut _15: &mut core::array::IntoIter<(*const T, *mut T, usize), 2>;\n    let mut _16: isize;\n    let  _17: *const T;\n    let  _18: *mut T;\n    let  _19: usize;\n    let  _20: ();\n    let mut _21: (usize, bool);\n    debug self => _1;\n    debug src => _2;\n    debug dst => _3;\n    debug count => _5;\n    debug src => _9;\n    debug ranges => _10;\n    debug iter => _13;\n    debug src => _17;\n    debug dst => _18;\n    debug count => _19;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = collections::vec_deque::VecDeque::<T, A>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = (_2.1: usize);\n        StorageLive(_7);\n        _7 = (_2.0: usize);\n        _8 = CheckedSub(_6, _7);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _6, move _7) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = move (_8.0: usize);\n        StorageDead(_7);\n        StorageDead(_6);\n        _9 = (_2.0: usize);\n        StorageLive(_11);\n        _11 = ((*_1).0: usize);\n        _10 = collections::vec_deque::VecDeque::<T, A>::nonoverlapping_ranges(_1, _9, _3, _5, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        StorageLive(_12);\n        _12 = <[(*const T, *mut T, usize); 2] as core::iter::IntoIterator>::into_iter(_10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_13);\n        _13 = move _12;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_14);\n        _15 = &mut _13;\n        _14 = <core::array::IntoIter<(*const T, *mut T, usize), 2> as core::iter::Iterator>::next(_15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _16 = discriminant(_14);\n        switchInt(move _16) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _17 = (((_14 as variant#1).0: (*const T, *mut T, usize)).0: *const T);\n        _18 = (((_14 as variant#1).0: (*const T, *mut T, usize)).1: *mut T);\n        _19 = (((_14 as variant#1).0: (*const T, *mut T, usize)).2: usize);\n        _20 = core::ptr::copy_nonoverlapping::<T>(_17, _18, _19) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        drop(_13) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        goto -> bb5;\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _21 = CheckedAdd(((*_1).1: usize), _5);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).1: usize), _5) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        ((*_1).1: usize) = move (_21.0: usize);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}