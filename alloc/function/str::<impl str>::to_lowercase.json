{
  "name": "str::<impl str>::to_lowercase",
  "safe": true,
  "callees": {
    "core::num::<impl u8>::to_ascii_lowercase": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a copy of the value in its ASCII lower case equivalent.\n\n ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n but non-ASCII letters are unchanged.\n\n To lowercase the value in-place, use [`make_ascii_lowercase`].\n\n # Examples\n\n ```\n let uppercase_a = 65u8;\n\n assert_eq!(97, uppercase_a.to_ascii_lowercase());\n ```\n\n [`make_ascii_lowercase`]: Self::make_ascii_lowercase\n",
      "adt": {}
    },
    "str::convert_while_ascii": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Converts leading ascii bytes in `s` by calling the `convert` function.\n\n For better average performance, this happens in chunks of `2*size_of::<usize>()`.\n\n Returns a tuple of the converted prefix and the remainder starting from\n the first non-ascii character.\n\n This function is only public so that it can be verified in a codegen test,\n see `issue-123712-str-to-lower-autovectorization.rs`.\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "string::String::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of this `String`, in bytes, not [`char`]s or\n graphemes. In other words, it might not be what a human considers the\n length of the string.\n\n # Examples\n\n ```\n let a = String::from(\"foo\");\n assert_eq!(a.len(), 3);\n\n let fancy_f = String::from(\"ƒoo\");\n assert_eq!(fancy_f.len(), 4);\n assert_eq!(fancy_f.chars().count(), 3);\n ```\n",
      "adt": {
        "string::String": "ImmutableAsArgument"
      }
    },
    "core::str::<impl str>::char_indices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice, and their\n positions.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns an iterator of both\n these [`char`]s, as well as their byte positions.\n\n The iterator yields tuples. The position is first, the [`char`] is\n second.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.char_indices().count();\n assert_eq!(7, count);\n\n let mut char_indices = word.char_indices();\n\n assert_eq!(Some((0, 'g')), char_indices.next());\n assert_eq!(Some((1, 'o')), char_indices.next());\n assert_eq!(Some((2, 'o')), char_indices.next());\n assert_eq!(Some((3, 'd')), char_indices.next());\n assert_eq!(Some((4, 'b')), char_indices.next());\n assert_eq!(Some((5, 'y')), char_indices.next());\n assert_eq!(Some((6, 'e')), char_indices.next());\n\n assert_eq!(None, char_indices.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let yes = \"y̆es\";\n\n let mut char_indices = yes.char_indices();\n\n assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')\n assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n // note the 3 here - the previous character took up two bytes\n assert_eq!(Some((3, 'e')), char_indices.next());\n assert_eq!(Some((4, 's')), char_indices.next());\n\n assert_eq!(None, char_indices.next());\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "str::<impl str>::to_lowercase::map_uppercase_sigma": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "string::String::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends the given [`char`] to the end of this `String`.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::from(\"abc\");\n\n s.push('1');\n s.push('2');\n s.push('3');\n\n assert_eq!(\"abc123\", s);\n ```\n",
      "adt": {
        "string::String": "MutableAsArgument"
      }
    },
    "core::unicode::conversions::to_lower": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "string::String": [
      "Plain",
      "Unknown([Field(0, Ty { id: 557, kind: RigidTy(Adt(AdtDef(DefId { id: 2811, name: \"string::String\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) })])",
      "Ref",
      "MutRef"
    ],
    "core::str::CharIndices": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8614, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 904, kind: RigidTy(Char) }])) }), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8614, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 904, kind: RigidTy(Char) }])) }), Field(1, Ty { id: 904, kind: RigidTy(Char) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::str::<impl str>::to_lowercase"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:380:5: 426:6",
  "src": "pub fn to_lowercase(&self) -> String {\n        let (mut s, rest) = convert_while_ascii(self, u8::to_ascii_lowercase);\n\n        let prefix_len = s.len();\n\n        for (i, c) in rest.char_indices() {\n            if c == 'Σ' {\n                // Σ maps to σ, except at the end of a word where it maps to ς.\n                // This is the only conditional (contextual) but language-independent mapping\n                // in `SpecialCasing.txt`,\n                // so hard-code it rather than have a generic \"condition\" mechanism.\n                // See https://github.com/rust-lang/rust/issues/26035\n                let sigma_lowercase = map_uppercase_sigma(self, prefix_len + i);\n                s.push(sigma_lowercase);\n            } else {\n                match conversions::to_lower(c) {\n                    [a, '\\0', _] => s.push(a),\n                    [a, b, '\\0'] => {\n                        s.push(a);\n                        s.push(b);\n                    }\n                    [a, b, c] => {\n                        s.push(a);\n                        s.push(b);\n                        s.push(c);\n                    }\n                }\n            }\n        }\n        return s;\n\n        fn map_uppercase_sigma(from: &str, i: usize) -> char {\n            // See https://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n            // for the definition of `Final_Sigma`.\n            debug_assert!('Σ'.len_utf8() == 2);\n            let is_word_final = case_ignorable_then_cased(from[..i].chars().rev())\n                && !case_ignorable_then_cased(from[i + 2..].chars());\n            if is_word_final { 'ς' } else { 'σ' }\n        }\n\n        fn case_ignorable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n            match iter.skip_while(|&c| c.is_case_ignorable()).next() {\n                Some(c) => c.is_cased(),\n                None => false,\n            }\n        }\n    }",
  "mir": "fn str::<impl str>::to_lowercase(_1: &str) -> string::String {\n    let mut _0: string::String;\n    let mut _2: string::String;\n    let  _3: &str;\n    let mut _4: (string::String, &str);\n    let mut _5: for<'a> fn(&'a u8) -> u8;\n    let  _6: usize;\n    let mut _7: &string::String;\n    let mut _8: core::str::CharIndices<'_>;\n    let mut _9: core::str::CharIndices<'_>;\n    let mut _10: core::str::CharIndices<'_>;\n    let  _11: ();\n    let mut _12: core::option::Option<(usize, char)>;\n    let mut _13: &mut core::str::CharIndices<'_>;\n    let mut _14: isize;\n    let  _15: usize;\n    let  _16: char;\n    let  _17: char;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: ();\n    let mut _21: &mut string::String;\n    let mut _22: [char; 3];\n    let  _23: char;\n    let mut _24: &mut string::String;\n    let  _25: char;\n    let  _26: char;\n    let  _27: ();\n    let mut _28: &mut string::String;\n    let  _29: ();\n    let mut _30: &mut string::String;\n    let  _31: char;\n    let  _32: char;\n    let  _33: char;\n    let  _34: ();\n    let mut _35: &mut string::String;\n    let  _36: ();\n    let mut _37: &mut string::String;\n    let  _38: ();\n    let mut _39: &mut string::String;\n    debug self => _1;\n    debug s => _2;\n    debug rest => _3;\n    debug prefix_len => _6;\n    debug iter => _10;\n    debug i => _15;\n    debug c => _16;\n    debug sigma_lowercase => _17;\n    debug a => _23;\n    debug a => _25;\n    debug b => _26;\n    debug a => _31;\n    debug b => _32;\n    debug c => _33;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = core::num::<impl u8>::to_ascii_lowercase as for<'a> fn(&'a u8) -> u8;\n        _4 = str::convert_while_ascii(_1, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_2);\n        _2 = move (_4.0: string::String);\n        _3 = (_4.1: &str);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = &_2;\n        _6 = string::String::len(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::str::<impl str>::char_indices(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = <core::str::CharIndices<'_> as core::iter::IntoIterator>::into_iter(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_10);\n        _10 = move _8;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_12);\n        _13 = &mut _10;\n        _12 = <core::str::CharIndices<'_> as core::iter::Iterator>::next(_13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _14 = discriminant(_12);\n        switchInt(move _14) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _15 = (((_12 as variant#1).0: (usize, char)).0: usize);\n        _16 = (((_12 as variant#1).0: (usize, char)).1: char);\n        switchInt(_16) -> [931: bb10, otherwise: bb14];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_10);\n        StorageDead(_8);\n        _0 = move _2;\n        StorageDead(_2);\n        return;\n    }\n    bb10: {\n        StorageLive(_18);\n        _19 = CheckedAdd(_6, _15);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, _15) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = move (_19.0: usize);\n        _17 = str::<impl str>::to_lowercase::map_uppercase_sigma(_1, move _18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageLive(_21);\n        _21 = &mut _2;\n        _20 = string::String::push(move _21, _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        goto -> bb27;\n    }\n    bb14: {\n        StorageLive(_22);\n        _22 = core::unicode::conversions::to_lower(_16) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(_22[1 of 3]) -> [0: bb19, otherwise: bb16];\n    }\n    bb16: {\n        switchInt(_22[2 of 3]) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        _31 = _22[0 of 3];\n        _32 = _22[1 of 3];\n        _33 = _22[2 of 3];\n        StorageLive(_35);\n        _35 = &mut _2;\n        _34 = string::String::push(move _35, _31) -> [return: bb23, unwind unreachable];\n    }\n    bb18: {\n        _25 = _22[0 of 3];\n        _26 = _22[1 of 3];\n        StorageLive(_28);\n        _28 = &mut _2;\n        _27 = string::String::push(move _28, _25) -> [return: bb21, unwind unreachable];\n    }\n    bb19: {\n        _23 = _22[0 of 3];\n        StorageLive(_24);\n        _24 = &mut _2;\n        _11 = string::String::push(move _24, _23) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_24);\n        goto -> bb26;\n    }\n    bb21: {\n        StorageDead(_28);\n        StorageLive(_30);\n        _30 = &mut _2;\n        _29 = string::String::push(move _30, _26) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        goto -> bb26;\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageLive(_37);\n        _37 = &mut _2;\n        _36 = string::String::push(move _37, _32) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_37);\n        StorageLive(_39);\n        _39 = &mut _2;\n        _38 = string::String::push(move _39, _33) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_39);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_22);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_12);\n        goto -> bb5;\n    }\n}\n",
  "doc": " Returns the lowercase equivalent of this string slice, as a new [`String`].\n\n 'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n `Lowercase`.\n\n Since some characters can expand into multiple characters when changing\n the case, this function returns a [`String`] instead of modifying the\n parameter in-place.\n\n # Examples\n\n Basic usage:\n\n ```\n let s = \"HELLO\";\n\n assert_eq!(\"hello\", s.to_lowercase());\n ```\n\n A tricky example, with sigma:\n\n ```\n let sigma = \"Σ\";\n\n assert_eq!(\"σ\", sigma.to_lowercase());\n\n // but at the end of a word, it's ς, not σ:\n let odysseus = \"ὈΔΥΣΣΕΎΣ\";\n\n assert_eq!(\"ὀδυσσεύς\", odysseus.to_lowercase());\n ```\n\n Languages without case are not changed:\n\n ```\n let new_year = \"农历新年\";\n\n assert_eq!(new_year, new_year.to_lowercase());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}