{
  "name": "collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "collections::btree::borrow::DormantMutRef::<'a, T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Capture a unique borrow, and immediately reborrow it. For the compiler,\n the lifetime of the new reference is the same as the lifetime of the\n original reference, but you promise to use it for a shorter period.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::ops::RangeBounds::start_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Start index bound.\n\n Returns the start value as a `Bound`.\n\n # Examples\n\n ```\n use std::ops::Bound::*;\n use std::ops::RangeBounds;\n\n assert_eq!((..10).start_bound(), Unbounded);\n assert_eq!((3..10).start_bound(), Included(&3));\n ```\n",
      "adt": {}
    },
    "collections::btree::search::SearchBound::<T>::from_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::search::SearchBound": "Constructor"
      }
    },
    "collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::lower_bound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the leaf edge corresponding to the first point at which the\n given bound is true.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "collections::btree::node::Handle": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2378, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }, Mut)) })])"
    ],
    "collections::btree::map::BTreeMap": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "MutRef",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Plain"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "Plain",
      "Unknown([Field(0, Ty { id: 2378, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 3275, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2381, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2382, kind: RigidTy(Adt(AdtDef(DefId { id: 3625, name: \"collections::btree::node::marker::Owned\" }), GenericArgs([]))) }), Type(Ty { id: 2376, kind: Param(ParamTy { index: 0, name: \"K\" }) }), Type(Ty { id: 2377, kind: Param(ParamTy { index: 1, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })]))) })])"
    ],
    "core::ops::Bound": [
      "Plain"
    ],
    "collections::btree::search::SearchBound": [
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "collections::btree::map::ExtractIfInner": [
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:1476:5: 1504:6",
  "src": "pub(super) fn extract_if_inner<R>(&mut self, range: R) -> (ExtractIfInner<'_, K, V, R>, A)\n    where\n        K: Ord,\n        R: RangeBounds<K>,\n    {\n        if let Some(root) = self.root.as_mut() {\n            let (root, dormant_root) = DormantMutRef::new(root);\n            let first = root.borrow_mut().lower_bound(SearchBound::from_range(range.start_bound()));\n            (\n                ExtractIfInner {\n                    length: &mut self.length,\n                    dormant_root: Some(dormant_root),\n                    cur_leaf_edge: Some(first),\n                    range,\n                },\n                (*self.alloc).clone(),\n            )\n        } else {\n            (\n                ExtractIfInner {\n                    length: &mut self.length,\n                    dormant_root: None,\n                    cur_leaf_edge: None,\n                    range,\n                },\n                (*self.alloc).clone(),\n            )\n        }\n    }",
  "mir": "fn collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner(_1: &mut collections::btree::map::BTreeMap<K, V, A>, _2: R) -> (collections::btree::map::ExtractIfInner<'_, K, V, R>, A) {\n    let mut _0: (collections::btree::map::ExtractIfInner<'_, K, V, R>, A);\n    let mut _3: core::option::Option<&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _4: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _5: isize;\n    let  _6: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _7: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let  _8: collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _9: (&mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n    let  _10: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _11: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _12: collections::btree::search::SearchBound<&K>;\n    let mut _13: core::ops::Bound<&K>;\n    let mut _14: &R;\n    let mut _15: collections::btree::map::ExtractIfInner<'_, K, V, R>;\n    let mut _16: &mut usize;\n    let mut _17: core::option::Option<collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _18: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _19: R;\n    let mut _20: A;\n    let  _21: &A;\n    let mut _22: &core::mem::ManuallyDrop<A>;\n    let mut _23: collections::btree::map::ExtractIfInner<'_, K, V, R>;\n    let mut _24: &mut usize;\n    let mut _25: core::option::Option<collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>>;\n    let mut _26: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>;\n    let mut _27: R;\n    let mut _28: A;\n    let  _29: &A;\n    let mut _30: &core::mem::ManuallyDrop<A>;\n    debug self => _1;\n    debug range => _2;\n    debug root => _6;\n    debug root => _7;\n    debug dormant_root => _8;\n    debug first => _10;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        _3 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::as_mut(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [1: bb2, 0: bb10, otherwise: bb14];\n    }\n    bb2: {\n        _6 = move ((_3 as variant#1).0: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_9);\n        _9 = collections::btree::borrow::DormantMutRef::<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::new(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = move (_9.0: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>);\n        _8 = move (_9.1: collections::btree::borrow::DormantMutRef<'_, collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_2;\n        _13 = <R as core::ops::RangeBounds<K>>::start_bound(move _14) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        _12 = collections::btree::search::SearchBound::<&K>::from_range(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _10 = collections::btree::navigate::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>::lower_bound::<K>(move _11, move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        _16 = &mut ((*_1).1: usize);\n        StorageLive(_17);\n        _17 = core::option::Option::Some(_8);\n        StorageLive(_18);\n        _18 = core::option::Option::Some(_10);\n        StorageLive(_19);\n        _19 = move _2;\n        _15 = ExtractIfInner(_16, move _17, move _18, move _19);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_20);\n        StorageLive(_22);\n        _22 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _21 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _22) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_22);\n        _20 = <A as core::clone::Clone>::clone(_21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _0 = (move _15, move _20);\n        StorageDead(_20);\n        StorageDead(_15);\n        StorageDead(_3);\n        goto -> bb13;\n    }\n    bb10: {\n        StorageDead(_3);\n        StorageLive(_23);\n        _24 = &mut ((*_1).1: usize);\n        StorageLive(_25);\n        _25 = core::option::Option::None;\n        StorageLive(_26);\n        _26 = core::option::Option::None;\n        StorageLive(_27);\n        _27 = move _2;\n        _23 = ExtractIfInner(_24, move _25, move _26, move _27);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_28);\n        StorageLive(_30);\n        _30 = &((*_1).2: core::mem::ManuallyDrop<A>);\n        _29 = <core::mem::ManuallyDrop<A> as core::ops::Deref>::deref(move _30) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_30);\n        _28 = <A as core::clone::Clone>::clone(_29) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _0 = (move _23, move _28);\n        StorageDead(_28);\n        StorageDead(_23);\n        goto -> bb13;\n    }\n    bb13: {\n        return;\n    }\n    bb14: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}