{
  "name": "vec::Vec::<T, A>::into_boxed_slice",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::shrink_to_fit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shrinks the capacity of the vector as much as possible.\n\n The behavior of this method depends on the allocator, which may either shrink the vector\n in-place or reallocate. The resulting vector might still have some excess capacity, just as\n is the case for [`with_capacity`]. See [`Allocator::shrink`] for more details.\n\n [`with_capacity`]: Vec::with_capacity\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n vec.extend([1, 2, 3]);\n assert!(vec.capacity() >= 10);\n vec.shrink_to_fit();\n assert!(vec.capacity() >= 3);\n ```\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::ptr::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads.\n\n * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n   case.\n\n * `src` must point to a properly initialized value of type `T`.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n # Examples\n\n Basic usage:\n\n ```\n let x = 12;\n let y = &x as *const i32;\n\n unsafe {\n     assert_eq!(std::ptr::read(y), 12);\n }\n ```\n\n Manually implement [`mem::swap`]:\n\n ```\n use std::ptr;\n\n fn swap<T>(a: &mut T, b: &mut T) {\n     unsafe {\n         // Create a bitwise copy of the value at `a` in `tmp`.\n         let tmp = ptr::read(a);\n\n         // Exiting at this point (either by explicitly returning or by\n         // calling a function which panics) would cause the value in `tmp` to\n         // be dropped while the same value is still referenced by `a`. This\n         // could trigger undefined behavior if `T` is not `Copy`.\n\n         // Create a bitwise copy of the value at `b` in `a`.\n         // This is safe because mutable references cannot alias.\n         ptr::copy_nonoverlapping(b, a, 1);\n\n         // As above, exiting here could trigger undefined behavior because\n         // the same value is referenced by `a` and `b`.\n\n         // Move `tmp` into `b`.\n         ptr::write(b, tmp);\n\n         // `tmp` has been moved (`write` takes ownership of its second argument),\n         // so nothing is dropped implicitly here.\n     }\n }\n\n let mut foo = \"foo\".to_owned();\n let mut bar = \"bar\".to_owned();\n\n swap(&mut foo, &mut bar);\n\n assert_eq!(foo, \"bar\");\n assert_eq!(bar, \"foo\");\n ```\n\n ## Ownership of the Returned Value\n\n `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n If `T` is not [`Copy`], using both the returned value and the value at\n `*src` can violate memory safety. Note that assigning to `*src` counts as a\n use because it will attempt to drop the value at `*src`.\n\n [`write()`] can be used to overwrite data without causing it to be dropped.\n\n ```\n use std::ptr;\n\n let mut s = String::from(\"foo\");\n unsafe {\n     // `s2` now points to the same underlying memory as `s`.\n     let mut s2: String = ptr::read(&s);\n\n     assert_eq!(s2, \"foo\");\n\n     // Assigning to `s2` causes its original value to be dropped. Beyond\n     // this point, `s` must no longer be used, as the underlying memory has\n     // been freed.\n     s2 = String::default();\n     assert_eq!(s2, \"\");\n\n     // Assigning to `s` would cause the old value to be dropped again,\n     // resulting in undefined behavior.\n     // s = String::from(\"bar\"); // ERROR\n\n     // `ptr::write` can be used to overwrite a value without dropping it.\n     ptr::write(&mut s, String::from(\"bar\"));\n }\n\n assert_eq!(s, \"bar\");\n ```\n\n [valid]: self#safety\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "raw_vec::RawVec::<T, A>::into_box": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n\n Note that this will correctly reconstitute any `cap` changes\n that may have been performed. (See description of type for details.)\n\n # Safety\n\n * `len` must be greater than or equal to the most recently requested capacity, and\n * `len` must be less than or equal to `self.capacity()`.\n\n Note, that the requested capacity and `self.capacity()` could differ, as\n an allocator could overallocate and return a greater memory block than requested.\n",
      "adt": {
        "raw_vec::RawVec": "ImmutableAsArgument",
        "boxed::Box": "Constructor"
      }
    },
    "boxed::Box::<[core::mem::MaybeUninit<T>], A>::assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to `Box<[T], A>`.\n\n # Safety\n\n As with [`MaybeUninit::assume_init`],\n it is up to the caller to guarantee that the values\n really are in an initialized state.\n Calling this when the content is not yet fully initialized\n causes immediate undefined behavior.\n\n [`MaybeUninit::assume_init`]: mem::MaybeUninit::assume_init\n\n # Examples\n\n ```\n let mut values = Box::<[u32]>::new_uninit_slice(3);\n // Deferred initialization:\n values[0].write(1);\n values[1].write(2);\n values[2].write(3);\n let values = unsafe { values.assume_init() };\n\n assert_eq!(*values, [1, 2, 3])\n ```\n",
      "adt": {
        "boxed::Box": "Constructor"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "MutRef",
      "Plain",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::mem::ManuallyDrop": [
      "Plain",
      "Ref"
    ],
    "raw_vec::RawVec": [
      "Ref",
      "Deref",
      "Plain"
    ],
    "boxed::Box": [
      "Plain"
    ]
  },
  "path": 2365,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1495:5: 1503:6",
  "src": "pub fn into_boxed_slice(mut self) -> Box<[T], A> {\n        unsafe {\n            self.shrink_to_fit();\n            let me = ManuallyDrop::new(self);\n            let buf = ptr::read(&me.buf);\n            let len = me.len();\n            buf.into_box(len).assume_init()\n        }\n    }",
  "mir": "fn vec::Vec::<T, A>::into_boxed_slice(_1: vec::Vec<T, A>) -> boxed::Box<[T], A> {\n    let mut _0: boxed::Box<[T], A>;\n    let  _2: ();\n    let mut _3: &mut vec::Vec<T, A>;\n    let  _4: core::mem::ManuallyDrop<vec::Vec<T, A>>;\n    let mut _5: vec::Vec<T, A>;\n    let  _6: raw_vec::RawVec<T, A>;\n    let mut _7: *const raw_vec::RawVec<T, A>;\n    let  _8: &raw_vec::RawVec<T, A>;\n    let  _9: &vec::Vec<T, A>;\n    let mut _10: &core::mem::ManuallyDrop<vec::Vec<T, A>>;\n    let  _11: usize;\n    let  _12: &vec::Vec<T, A>;\n    let mut _13: &core::mem::ManuallyDrop<vec::Vec<T, A>>;\n    let mut _14: boxed::Box<[core::mem::MaybeUninit<T>], A>;\n    debug self => _1;\n    debug me => _4;\n    debug buf => _6;\n    debug len => _11;\n    bb0: {\n        StorageLive(_3);\n        _3 = &mut _1;\n        _2 = vec::Vec::<T, A>::shrink_to_fit(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = move _1;\n        _4 = core::mem::ManuallyDrop::<vec::Vec<T, A>>::new(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_4;\n        _9 = <core::mem::ManuallyDrop<vec::Vec<T, A>> as core::ops::Deref>::deref(move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_10);\n        _8 = &((*_9).0: raw_vec::RawVec<T, A>);\n        _7 = &raw const (*_8);\n        _6 = core::ptr::read::<raw_vec::RawVec<T, A>>(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_13);\n        _13 = &_4;\n        _12 = <core::mem::ManuallyDrop<vec::Vec<T, A>> as core::ops::Deref>::deref(move _13) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        _11 = vec::Vec::<T, A>::len(_12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_14);\n        _14 = raw_vec::RawVec::<T, A>::into_box(_6, _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _0 = boxed::Box::<[core::mem::MaybeUninit<T>], A>::assume_init(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Converts the vector into [`Box<[T]>`][owned slice].\n\n Before doing the conversion, this method discards excess capacity like [`shrink_to_fit`].\n\n [owned slice]: Box\n [`shrink_to_fit`]: Vec::shrink_to_fit\n\n # Examples\n\n ```\n let v = vec![1, 2, 3];\n\n let slice = v.into_boxed_slice();\n ```\n\n Any excess capacity is removed:\n\n ```\n let mut vec = Vec::with_capacity(10);\n vec.extend([1, 2, 3]);\n\n assert!(vec.capacity() >= 10);\n let slice = vec.into_boxed_slice();\n assert_eq!(slice.into_vec().capacity(), 3);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}