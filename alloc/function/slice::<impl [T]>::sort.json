{
  "name": "slice::<impl [T]>::sort",
  "safe": true,
  "callees": {
    "slice::stable_sort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "alloc::slice::<impl [T]>::sort"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:131:5: 136:6",
  "src": "pub fn sort(&mut self)\n    where\n        T: Ord,\n    {\n        stable_sort(self, T::lt);\n    }",
  "mir": "fn slice::<impl [T]>::sort(_1: &mut [T]) -> () {\n    let mut _0: ();\n    let  _2: ();\n    debug self => _1;\n    bb0: {\n        _2 = slice::stable_sort::<T, for<'a, 'b> fn(&'a T, &'b T) -> bool {<T as core::cmp::PartialOrd>::lt}>(_1, <T as core::cmp::PartialOrd>::lt) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Sorts the slice in ascending order, preserving initial order of equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*))\n worst-case.\n\n If the implementation of [`Ord`] for `T` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n When applicable, unstable sorting is preferred because it is generally faster than stable\n sorting and it doesn't allocate auxiliary memory. See\n [`sort_unstable`](slice::sort_unstable). The exception are partially sorted slices, which\n may be better served with `slice::sort`.\n\n Sorting types that only implement [`PartialOrd`] such as [`f32`] and [`f64`] require\n additional precautions. For example, `f32::NAN != f32::NAN`, which doesn't fulfill the\n reflexivity requirement of [`Ord`]. By using an alternative comparison function with\n `slice::sort_by` such as [`f32::total_cmp`] or [`f64::total_cmp`] that defines a [total\n order] users can sort slices containing floating-point values. Alternatively, if all values\n in the slice are guaranteed to be in a subset for which [`PartialOrd::partial_cmp`] forms a\n [total order], it's possible to sort the slice with `sort_by(|a, b|\n a.partial_cmp(b).unwrap())`.\n\n # Current implementation\n\n The current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\n combines the fast average case of quicksort with the fast worst case and partial run\n detection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\n with k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n The auxiliary memory allocation behavior depends on the input length. Short slices are\n handled without allocation, medium sized slices allocate `self.len()` and beyond that it\n clamps at `self.len() / 2`.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `T` does not implement a [total order], or if\n the [`Ord`] implementation itself panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n\n v.sort();\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n ```\n\n [driftsort]: https://github.com/Voultapher/driftsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}