{
  "name": "collections::btree::map::entry::VacantEntry::<'a, K, V, A>::insert_entry",
  "safe": true,
  "callees": {
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows a new mutable reference from the unique borrow initially captured.\n\n # Safety\n\n The reborrow must have ended, i.e., the reference returned by `new` and\n all pointers and references derived from it, must not be used anymore.\n",
      "adt": {
        "collections::btree::borrow::DormantMutRef": "MutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::new_leaf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<BorrowType, K, V, collections::btree::node::marker::Leaf>::forget_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes any static information asserting that this node is a `Leaf` node.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "core::option::Option::<T>::insert": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts `value` into the option, then returns a mutable reference to it.\n\n If the option already contains a value, the old value is dropped.\n\n See also [`Option::get_or_insert`], which doesn't update the value if\n the option already contains [`Some`].\n\n # Example\n\n ```\n let mut opt = None;\n let val = opt.insert(1);\n assert_eq!(*val, 1);\n assert_eq!(opt.unwrap(), 1);\n let val = opt.insert(2);\n assert_eq!(*val, 2);\n *val = 3;\n assert_eq!(opt.unwrap(), 3);\n ```\n",
      "adt": {}
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, Type>::borrow_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably borrows the owned root node. Unlike `reborrow_mut`, this is safe\n because the return value cannot be used to destroy the root, and there\n cannot be other references to the tree.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_leaf_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unsafely asserts to the compiler the static information that this node is a `Leaf`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>::push_with_handle": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a key-value pair to the end of the node, and returns\n a handle to the inserted value.\n\n # Safety\n\n The returned handle has an unbound lifetime.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a new key-value pair between the key-value pairs to the right and left of\n this edge. This method splits the node if there isn't enough room, and tries to\n insert the split off portion into the parent node recursively, until the root is reached.\n\n If the returned result is some `SplitResult`, the `left` field will be the root node.\n The returned pointer points to the inserted value, which in the case of `SplitResult`\n is in the `left` or `right` tree.\n",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::forget_node_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::btree::node::Handle": "Constructor",
        "collections::btree::node::NodeRef": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::map::entry::VacantEntry": [
      "Unknown([Field(1, Ty { id: 2717, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 2717, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2718, kind: RigidTy(Adt(AdtDef(DefId { id: 3487, name: \"collections::btree::node::Handle\" }), GenericArgs([Type(Ty { id: 2738, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2427, kind: RigidTy(Adt(AdtDef(DefId { id: 3605, name: \"collections::btree::node::marker::Leaf\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 2426, kind: RigidTy(Adt(AdtDef(DefId { id: 3500, name: \"collections::btree::node::marker::Edge\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(0, Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) })])",
      "Unknown([Field(3, Ty { id: 2326, kind: Param(ParamTy { index: 3, name: \"A\" }) })])",
      "Unknown([Field(2, Ty { id: 2720, kind: RigidTy(Adt(AdtDef(DefId { id: 3504, name: \"collections::btree::borrow::DormantMutRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2741, kind: RigidTy(Adt(AdtDef(DefId { id: 3598, name: \"collections::btree::map::BTreeMap\" }), GenericArgs([Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2326, kind: Param(ParamTy { index: 3, name: \"A\" }) })]))) })]))) })])",
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "Plain"
    ],
    "collections::btree::borrow::DormantMutRef": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::map::BTreeMap": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::option::Option": [
      "MutRef"
    ],
    "collections::btree::node::NodeRef": [
      "Plain",
      "MutRef"
    ],
    "collections::btree::map::entry::OccupiedEntry": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::btree::map::entry::VacantEntry::<'a, K, V, A>::insert_entry"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:398:5: 430:6",
  "src": "pub fn insert_entry(mut self, value: V) -> OccupiedEntry<'a, K, V, A> {\n        let handle = match self.handle {\n            None => {\n                // SAFETY: There is no tree yet so no reference to it exists.\n                let map = unsafe { self.dormant_map.reborrow() };\n                let root = map.root.insert(NodeRef::new_leaf(self.alloc.clone()).forget_type());\n                // SAFETY: We *just* created the root as a leaf, and we're\n                // stacking the new handle on the original borrow lifetime.\n                unsafe {\n                    let mut leaf = root.borrow_mut().cast_to_leaf_unchecked();\n                    leaf.push_with_handle(self.key, value)\n                }\n            }\n            Some(handle) => handle.insert_recursing(self.key, value, self.alloc.clone(), |ins| {\n                drop(ins.left);\n                // SAFETY: Pushing a new root node doesn't invalidate\n                // handles to existing nodes.\n                let map = unsafe { self.dormant_map.reborrow() };\n                let root = map.root.as_mut().unwrap(); // same as ins.left\n                root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n            }),\n        };\n\n        // SAFETY: modifying the length doesn't invalidate handles to existing nodes.\n        unsafe { self.dormant_map.reborrow().length += 1 };\n\n        OccupiedEntry {\n            handle: handle.forget_node_type(),\n            dormant_map: self.dormant_map,\n            alloc: self.alloc,\n            _marker: PhantomData,\n        }\n    }",
  "mir": "fn collections::btree::map::entry::VacantEntry::<'a, K, V, A>::insert_entry(_1: collections::btree::map::entry::VacantEntry<'_, K, V, A>, _2: V) -> collections::btree::map::entry::OccupiedEntry<'_, K, V, A> {\n    let mut _0: collections::btree::map::entry::OccupiedEntry<'_, K, V, A>;\n    let  _3: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _4: isize;\n    let mut _5: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let mut _6: &mut collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let  _7: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _8: &mut core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _9: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _10: collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>;\n    let mut _11: A;\n    let mut _12: &A;\n    let mut _13: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _14: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _15: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>;\n    let mut _16: K;\n    let  _17: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>;\n    let mut _18: K;\n    let mut _19: A;\n    let mut _20: &A;\n    let mut _21: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:411:90: 411:95};\n    let mut _22: &mut collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _23: &A;\n    let mut _24: &mut collections::btree::map::BTreeMap<K, V, A>;\n    let mut _25: &mut collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _26: (usize, bool);\n    let mut _27: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::KV>;\n    let mut _28: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>;\n    let mut _29: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>;\n    let mut _30: A;\n    debug self => _1;\n    debug value => _2;\n    debug handle => _3;\n    debug map => _5;\n    debug root => _7;\n    debug leaf => _13;\n    debug handle => _17;\n    bb0: {\n        StorageLive(_3);\n        _4 = discriminant((_1.1: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>));\n        switchInt(move _4) -> [0: bb3, 1: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _17 = move (((_1.1: core::option::Option<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>>) as variant#1).0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>);\n        StorageLive(_18);\n        _18 = move (_1.0: K);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &(_1.3: A);\n        _19 = <A as core::clone::Clone>::clone(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_6);\n        _6 = &mut (_1.2: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        _5 = collections::btree::borrow::DormantMutRef::<'_, collections::btree::map::BTreeMap<K, V, A>>::reborrow(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = &mut ((*_5).0: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(_1.3: A);\n        _11 = <A as core::clone::Clone>::clone(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _10 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::new_leaf::<A>(move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _9 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Leaf>::forget_type(move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_10);\n        _7 = core::option::Option::<collections::btree::node::NodeRef<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>>::insert(move _8, move _9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::borrow_mut(_7) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _13 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::cast_to_leaf_unchecked(move _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageLive(_15);\n        _15 = &mut _13;\n        StorageLive(_16);\n        _16 = move (_1.0: K);\n        _3 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>::push_with_handle::<'_>(move _15, move _16, _2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_13);\n        goto -> bb14;\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &mut (_1.2: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        StorageLive(_23);\n        _23 = &(_1.3: A);\n        _21 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:411:90: 411:95}(move _22, move _23);\n        StorageDead(_23);\n        StorageDead(_22);\n        _3 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_recursing::<A, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map/entry.rs:411:90: 411:95}>(_17, move _18, _2, move _19, move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &mut (_1.2: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        _24 = collections::btree::borrow::DormantMutRef::<'_, collections::btree::map::BTreeMap<K, V, A>>::reborrow(move _25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        _26 = CheckedAdd(((*_24).1: usize), 1_usize);\n        assert(!move (_26.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_24).1: usize), 1_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        ((*_24).1: usize) = move (_26.0: usize);\n        StorageDead(_24);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = move _3;\n        _27 = collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::forget_node_type(move _28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_28);\n        StorageLive(_29);\n        _29 = move (_1.2: collections::btree::borrow::DormantMutRef<'_, collections::btree::map::BTreeMap<K, V, A>>);\n        StorageLive(_30);\n        _30 = move (_1.3: A);\n        _0 = OccupiedEntry(move _27, move _29, move _30, ZeroSized: core::marker::PhantomData<&mut (K, V)>);\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Sets the value of the entry with the `VacantEntry`'s key,\n and returns an `OccupiedEntry`.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n use std::collections::btree_map::Entry;\n\n let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n\n if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n     let entry = o.insert_entry(37);\n     assert_eq!(entry.get(), &37);\n }\n assert_eq!(map[\"poneyland\"], 37);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}