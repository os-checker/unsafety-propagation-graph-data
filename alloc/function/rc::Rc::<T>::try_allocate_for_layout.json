{
  "name": "rc::Rc::<T>::try_allocate_for_layout",
  "safe": false,
  "callees": {
    "rc::rc_inner_layout_for_value_layout": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculate layout for `RcInner<T>` using the inner value's layout\n",
      "adt": {
        "core::alloc::Layout": "Constructor"
      }
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<[T]>::as_non_null_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a non-null pointer to the slice's buffer.\n\n # Examples\n\n ```rust\n #![feature(slice_ptr_get)]\n use std::ptr::NonNull;\n\n let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n assert_eq!(slice.as_non_null_ptr(), NonNull::<i8>::dangling());\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::for_value_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Produces layout describing a record that could be used to\n allocate backing structure for `T` (which could be a trait\n or other unsized type like a slice).\n\n # Safety\n\n This function is only safe to call if the following conditions hold:\n\n - If `T` is `Sized`, this function is always safe to call.\n - If the unsized tail of `T` is:\n     - a [slice], then the length of the slice tail must be an initialized\n       integer, and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n       For the special case where the dynamic tail length is 0, this function\n       is safe to call.\n     - a [trait object], then the vtable part of the pointer must point\n       to a valid vtable for the type `T` acquired by an unsizing coercion,\n       and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n     - an (unstable) [extern type], then this function is always safe to\n       call, but may panic or otherwise return the wrong value, as the\n       extern type's layout is not known. This is the same behavior as\n       [`Layout::for_value`] on a reference to an extern type tail.\n     - otherwise, it is conservatively not allowed to call this function.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n [extern type]: ../../unstable-book/language-features/extern-types.html\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::cell::Cell::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `Cell` containing the given value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::write": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Overwrites a memory location with the given value without reading or\n dropping the old value.\n\n See [`ptr::write`] for safety concerns and examples.\n\n [`ptr::write`]: crate::ptr::write()\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 188, kind: RigidTy(Adt(AdtDef(DefId { id: 2619, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 195, kind: RigidTy(Slice(Ty { id: 93, kind: RigidTy(Uint(U8)) })) })]))) })])"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "core::cell::Cell": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 1779,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:2235:5: 2255:6",
  "src": "unsafe fn try_allocate_for_layout(\n        value_layout: Layout,\n        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,\n        mem_to_rc_inner: impl FnOnce(*mut u8) -> *mut RcInner<T>,\n    ) -> Result<*mut RcInner<T>, AllocError> {\n        let layout = rc_inner_layout_for_value_layout(value_layout);\n\n        // Allocate for the layout.\n        let ptr = allocate(layout)?;\n\n        // Initialize the RcInner\n        let inner = mem_to_rc_inner(ptr.as_non_null_ptr().as_ptr());\n        unsafe {\n            debug_assert_eq!(Layout::for_value_raw(inner), layout);\n\n            (&raw mut (*inner).strong).write(Cell::new(1));\n            (&raw mut (*inner).weak).write(Cell::new(1));\n        }\n\n        Ok(inner)\n    }",
  "mir": "fn rc::Rc::<T>::try_allocate_for_layout(_1: core::alloc::Layout, _2: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>, _3: impl FnOnce(*mut u8) -> *mut RcInner<T>) -> core::result::Result<*mut rc::RcInner<T>, core::alloc::AllocError> {\n    let mut _0: core::result::Result<*mut rc::RcInner<T>, core::alloc::AllocError>;\n    let  _4: core::alloc::Layout;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::alloc::AllocError>, core::ptr::NonNull<[u8]>>;\n    let mut _6: core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError>;\n    let mut _7: (core::alloc::Layout,);\n    let mut _8: isize;\n    let  _9: core::ptr::NonNull<[u8]>;\n    let  _10: *mut rc::RcInner<T>;\n    let mut _11: impl FnOnce(*mut u8) -> *mut RcInner<T>;\n    let mut _12: (*mut u8,);\n    let mut _13: *mut u8;\n    let mut _14: core::ptr::NonNull<u8>;\n    let mut _15: (&core::alloc::Layout, &core::alloc::Layout);\n    let mut _16: &core::alloc::Layout;\n    let  _17: core::alloc::Layout;\n    let mut _18: *const rc::RcInner<T>;\n    let mut _19: &core::alloc::Layout;\n    let  _20: &core::alloc::Layout;\n    let  _21: &core::alloc::Layout;\n    let mut _22: bool;\n    let  _23: core::panicking::AssertKind;\n    let  _24: !;\n    let mut _25: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _26: ();\n    let mut _27: *mut core::cell::Cell<usize>;\n    let mut _28: core::cell::Cell<usize>;\n    let  _29: ();\n    let mut _30: *mut core::cell::Cell<usize>;\n    let mut _31: core::cell::Cell<usize>;\n    debug value_layout => _1;\n    debug allocate => _2;\n    debug mem_to_rc_inner => _3;\n    debug layout => _4;\n    debug ptr => _9;\n    debug residual => core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError);\n    debug val => _9;\n    debug inner => _10;\n    debug left_val => _20;\n    debug right_val => _21;\n    debug kind => _23;\n    bb0: {\n        _4 = rc::rc_inner_layout_for_value_layout(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = (_4);\n        _6 = <impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError> as core::ops::FnOnce<(core::alloc::Layout,)>>::call_once(_2, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = <core::result::Result<core::ptr::NonNull<[u8]>, core::alloc::AllocError> as core::ops::Try>::branch(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _9 = ((_5 as variant#0).0: core::ptr::NonNull<[u8]>);\n        StorageDead(_5);\n        StorageLive(_11);\n        _11 = move _3;\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = core::ptr::NonNull::<[u8]>::as_non_null_ptr(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = <core::result::Result<*mut rc::RcInner<T>, core::alloc::AllocError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::alloc::AllocError>>>::from_residual(core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError)) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_5);\n        drop(_3) -> [return: bb19, unwind unreachable];\n    }\n    bb8: {\n        _13 = core::ptr::NonNull::<u8>::as_ptr(move _14) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        _12 = (move _13);\n        _10 = <impl FnOnce(*mut u8) -> *mut RcInner<T> as core::ops::FnOnce<(*mut u8,)>>::call_once(move _11, move _12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _10 as *const rc::RcInner<T>;\n        _17 = core::alloc::Layout::for_value_raw::<rc::RcInner<T>>(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_18);\n        _16 = &_17;\n        StorageLive(_19);\n        _19 = &_4;\n        _15 = (move _16, move _19);\n        StorageDead(_19);\n        StorageDead(_16);\n        _20 = (_15.0: &core::alloc::Layout);\n        _21 = (_15.1: &core::alloc::Layout);\n        StorageLive(_22);\n        _22 = <core::alloc::Layout as core::cmp::PartialEq>::eq(_20, _21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _22) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_22);\n        StorageDead(_17);\n        StorageDead(_15);\n        StorageLive(_27);\n        _27 = &raw mut ((*_10).0: core::cell::Cell<usize>);\n        StorageLive(_28);\n        _28 = core::cell::Cell::<usize>::new(1_usize) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        _23 = core::panicking::AssertKind::Eq;\n        StorageLive(_25);\n        _25 = core::option::Option::None;\n        _24 = core::panicking::assert_failed::<core::alloc::Layout, core::alloc::Layout>(_23, _20, _21, move _25) -> unwind unreachable;\n    }\n    bb15: {\n        _26 = core::ptr::mut_ptr::<impl *mut core::cell::Cell<usize>>::write(move _27, move _28) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageLive(_30);\n        _30 = &raw mut ((*_10).1: core::cell::Cell<usize>);\n        StorageLive(_31);\n        _31 = core::cell::Cell::<usize>::new(1_usize) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _29 = core::ptr::mut_ptr::<impl *mut core::cell::Cell<usize>>::write(move _30, move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        StorageDead(_30);\n        _0 = core::result::Result::Ok(_10);\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": " Allocates an `RcInner<T>` with sufficient space for\n a possibly-unsized inner value where the value has the layout provided,\n returning an error if allocation fails.\n\n The function `mem_to_rc_inner` is called with the data pointer\n and must return back a (potentially fat)-pointer for the `RcInner<T>`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}