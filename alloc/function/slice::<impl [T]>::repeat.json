{
  "name": "slice::<impl [T]>::repeat",
  "safe": true,
  "callees": {
    "vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "core::num::<impl usize>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {
        "vec::Vec": "Constructor"
      }
    },
    "core::iter::Extend::extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends a collection with the contents of an iterator.\n\n As this is the only required method for this trait, the [trait-level] docs\n contain more details.\n\n [trait-level]: Extend\n\n # Examples\n\n ```\n // You can extend a String with some chars:\n let mut message = String::from(\"abc\");\n\n message.extend(['d', 'e', 'f'].iter());\n\n assert_eq!(\"abcdef\", &message);\n ```\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the vector's buffer, or a dangling raw pointer\n valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize mutable references to the slice,\n or mutable references to specific elements you are planning on accessing through this pointer,\n as well as writing to those elements, may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n\n # Examples\n\n ```\n let x = vec![1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(*x_ptr.add(i), 1 << i);\n     }\n }\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0, 1, 2];\n     let ptr1 = v.as_ptr();\n     let _ = ptr1.read();\n     let ptr2 = v.as_mut_ptr().offset(2);\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`\n     // because it mutated a different element:\n     let _ = ptr1.read();\n }\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 123,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/slice.rs:507:5: 563:6",
  "src": "pub fn repeat(&self, n: usize) -> Vec<T>\n    where\n        T: Copy,\n    {\n        if n == 0 {\n            return Vec::new();\n        }\n\n        // If `n` is larger than zero, it can be split as\n        // `n = 2^expn + rem (2^expn > rem, expn >= 0, rem >= 0)`.\n        // `2^expn` is the number represented by the leftmost '1' bit of `n`,\n        // and `rem` is the remaining part of `n`.\n\n        // Using `Vec` to access `set_len()`.\n        let capacity = self.len().checked_mul(n).expect(\"capacity overflow\");\n        let mut buf = Vec::with_capacity(capacity);\n\n        // `2^expn` repetition is done by doubling `buf` `expn`-times.\n        buf.extend(self);\n        {\n            let mut m = n >> 1;\n            // If `m > 0`, there are remaining bits up to the leftmost '1'.\n            while m > 0 {\n                // `buf.extend(buf)`:\n                unsafe {\n                    ptr::copy_nonoverlapping::<T>(\n                        buf.as_ptr(),\n                        (buf.as_mut_ptr()).add(buf.len()),\n                        buf.len(),\n                    );\n                    // `buf` has capacity of `self.len() * n`.\n                    let buf_len = buf.len();\n                    buf.set_len(buf_len * 2);\n                }\n\n                m >>= 1;\n            }\n        }\n\n        // `rem` (`= n - 2^expn`) repetition is done by copying\n        // first `rem` repetitions from `buf` itself.\n        let rem_len = capacity - buf.len(); // `self.len() * rem`\n        if rem_len > 0 {\n            // `buf.extend(buf[0 .. rem_len])`:\n            unsafe {\n                // This is non-overlapping since `2^expn > rem`.\n                ptr::copy_nonoverlapping::<T>(\n                    buf.as_ptr(),\n                    (buf.as_mut_ptr()).add(buf.len()),\n                    rem_len,\n                );\n                // `buf.len() + rem_len` equals to `buf.capacity()` (`= self.len() * n`).\n                buf.set_len(capacity);\n            }\n        }\n        buf\n    }",
  "mir": "fn slice::<impl [T]>::repeat(_1: &[T], _2: usize) -> vec::Vec<T> {\n    let mut _0: vec::Vec<T>;\n    let  _3: usize;\n    let mut _4: core::option::Option<usize>;\n    let mut _5: usize;\n    let mut _6: &str;\n    let mut _7: vec::Vec<T>;\n    let  _8: ();\n    let mut _9: &mut vec::Vec<T>;\n    let mut _10: usize;\n    let mut _11: u32;\n    let mut _12: bool;\n    let mut _13: bool;\n    let mut _14: usize;\n    let  _15: ();\n    let mut _16: *const T;\n    let mut _17: &vec::Vec<T>;\n    let mut _18: *mut T;\n    let mut _19: *mut T;\n    let mut _20: &mut vec::Vec<T>;\n    let mut _21: usize;\n    let mut _22: &vec::Vec<T>;\n    let mut _23: usize;\n    let mut _24: &vec::Vec<T>;\n    let  _25: usize;\n    let mut _26: &vec::Vec<T>;\n    let  _27: ();\n    let mut _28: &mut vec::Vec<T>;\n    let mut _29: usize;\n    let mut _30: (usize, bool);\n    let mut _31: u32;\n    let mut _32: bool;\n    let  _33: usize;\n    let mut _34: usize;\n    let mut _35: &vec::Vec<T>;\n    let mut _36: (usize, bool);\n    let mut _37: bool;\n    let  _38: ();\n    let mut _39: *const T;\n    let mut _40: &vec::Vec<T>;\n    let mut _41: *mut T;\n    let mut _42: *mut T;\n    let mut _43: &mut vec::Vec<T>;\n    let mut _44: usize;\n    let mut _45: &vec::Vec<T>;\n    let  _46: ();\n    let mut _47: &mut vec::Vec<T>;\n    debug self => _1;\n    debug n => _2;\n    debug capacity => _3;\n    debug buf => _7;\n    debug m => _10;\n    debug buf_len => _25;\n    debug rem_len => _33;\n    bb0: {\n        switchInt(_2) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        _0 = vec::Vec::<T>::new() -> [return: bb32, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = PtrMetadata(_1);\n        _4 = core::num::<impl usize>::checked_mul(move _5, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = \"capacity overflow\";\n        _3 = core::option::Option::<usize>::expect(move _4, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = vec::Vec::<T>::with_capacity(_3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_9);\n        _9 = &mut _7;\n        _8 = <vec::Vec<T> as core::iter::Extend<&T>>::extend::<&[T]>(move _9, _1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_10);\n        _11 = 1_i32 as u32;\n        _12 = Lt(move _11, 64_u32);\n        assert(move _12, \"attempt to shift right by `{}`, which would overflow\", 1_i32) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = Shr(_2, 1_i32);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _10;\n        _13 = Gt(move _14, 0_usize);\n        switchInt(move _13) -> [0: bb20, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_7;\n        _16 = vec::Vec::<T>::as_ptr(move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &mut _7;\n        _19 = vec::Vec::<T>::as_mut_ptr(move _20) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_7;\n        _21 = vec::Vec::<T>::len(move _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        _18 = core::ptr::mut_ptr::<impl *mut T>::add(move _19, move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_7;\n        _23 = vec::Vec::<T>::len(move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        _15 = core::ptr::copy_nonoverlapping::<T>(move _16, move _18, move _23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageLive(_26);\n        _26 = &_7;\n        _25 = vec::Vec::<T>::len(move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        StorageLive(_28);\n        _28 = &mut _7;\n        StorageLive(_29);\n        _30 = CheckedMul(_25, 2_usize);\n        assert(!move (_30.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _25, 2_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _29 = move (_30.0: usize);\n        _27 = vec::Vec::<T>::set_len(move _28, move _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        StorageDead(_28);\n        _31 = 1_i32 as u32;\n        _32 = Lt(move _31, 64_u32);\n        assert(move _32, \"attempt to shift right by `{}`, which would overflow\", 1_i32) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _10 = Shr(_10, 1_i32);\n        StorageDead(_13);\n        goto -> bb8;\n    }\n    bb20: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_10);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_7;\n        _34 = vec::Vec::<T>::len(move _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_35);\n        _36 = CheckedSub(_3, _34);\n        assert(!move (_36.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _34) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _33 = move (_36.0: usize);\n        StorageDead(_34);\n        StorageLive(_37);\n        _37 = Gt(_33, 0_usize);\n        switchInt(move _37) -> [0: bb30, otherwise: bb23];\n    }\n    bb23: {\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_7;\n        _39 = vec::Vec::<T>::as_ptr(move _40) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &mut _7;\n        _42 = vec::Vec::<T>::as_mut_ptr(move _43) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &_7;\n        _44 = vec::Vec::<T>::len(move _45) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_45);\n        _41 = core::ptr::mut_ptr::<impl *mut T>::add(move _42, move _44) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_44);\n        StorageDead(_42);\n        _38 = core::ptr::copy_nonoverlapping::<T>(move _39, move _41, _33) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_41);\n        StorageDead(_39);\n        StorageLive(_47);\n        _47 = &mut _7;\n        _46 = vec::Vec::<T>::set_len(move _47, _3) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_47);\n        goto -> bb31;\n    }\n    bb30: {\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_37);\n        _0 = move _7;\n        StorageDead(_7);\n        goto -> bb33;\n    }\n    bb32: {\n        goto -> bb33;\n    }\n    bb33: {\n        return;\n    }\n}\n",
  "doc": " Creates a vector by copying a slice `n` times.\n\n # Panics\n\n This function will panic if the capacity would overflow.\n\n # Examples\n\n ```\n assert_eq!([1, 2].repeat(3), vec![1, 2, 1, 2, 1, 2]);\n ```\n\n A panic upon overflow:\n\n ```should_panic\n // this will panic at runtime\n b\"0123456789abcdef\".repeat(usize::MAX);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}