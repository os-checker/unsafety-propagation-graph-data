{
  "name": "collections::vec_deque::VecDeque::<T, A>::iter",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::iter::Iter::<'a, T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::iter::Iter": "Constructor"
      }
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "collections::vec_deque::iter::Iter": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::vec_deque::VecDeque::<T, A>::iter"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1492:5: 1495:6",
  "src": "pub fn iter(&self) -> Iter<'_, T> {\n        let (a, b) = self.as_slices();\n        Iter::new(a.iter(), b.iter())\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::iter(_1: &collections::vec_deque::VecDeque<T, A>) -> collections::vec_deque::iter::Iter<'_, T> {\n    let mut _0: collections::vec_deque::iter::Iter<'_, T>;\n    let  _2: &[T];\n    let  _3: &[T];\n    let mut _4: (&[T], &[T]);\n    let mut _5: core::slice::Iter<'_, T>;\n    let mut _6: core::slice::Iter<'_, T>;\n    debug self => _1;\n    debug a => _2;\n    debug b => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = collections::vec_deque::VecDeque::<T, A>::as_slices(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = (_4.0: &[T]);\n        _3 = (_4.1: &[T]);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = core::slice::<impl [T]>::iter(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = core::slice::<impl [T]>::iter(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = collections::vec_deque::iter::Iter::<'_, T>::new(move _5, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Returns a front-to-back iterator.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::new();\n buf.push_back(5);\n buf.push_back(3);\n buf.push_back(4);\n let b: &[_] = &[&5, &3, &4];\n let c: Vec<&i32> = buf.iter().collect();\n assert_eq!(&c[..], b);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}