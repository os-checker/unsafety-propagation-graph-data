{
  "name": "rc::Rc::<T, A>::get_mut_unchecked",
  "safe": false,
  "callees": {
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ptr::NonNull": [
      "Plain"
    ],
    "rc::Rc": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 1751,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:1983:5: 1987:6",
  "src": "pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n        // We are careful to *not* create a reference covering the \"count\" fields, as\n        // this would conflict with accesses to the reference counts (e.g. by `Weak`).\n        unsafe { &mut (*this.ptr.as_ptr()).value }\n    }",
  "mir": "fn rc::Rc::<T, A>::get_mut_unchecked(_1: &mut rc::Rc<T, A>) -> &mut T {\n    let mut _0: &mut T;\n    let mut _2: *mut rc::RcInner<T>;\n    let mut _3: core::ptr::NonNull<rc::RcInner<T>>;\n    debug this => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).0: core::ptr::NonNull<rc::RcInner<T>>);\n        _2 = core::ptr::NonNull::<rc::RcInner<T>>::as_ptr(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = &mut ((*_2).2: T);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a mutable reference into the given `Rc`,\n without any check.\n\n See also [`get_mut`], which is safe and does appropriate checks.\n\n [`get_mut`]: Rc::get_mut\n\n # Safety\n\n If any other `Rc` or [`Weak`] pointers to the same allocation exist, then\n they must not be dereferenced or have active borrows for the duration\n of the returned borrow, and their inner type must be exactly the same as the\n inner type of this Rc (including lifetimes). This is trivially the case if no\n such pointers exist, for example immediately after `Rc::new`.\n\n # Examples\n\n ```\n #![feature(get_mut_unchecked)]\n\n use std::rc::Rc;\n\n let mut x = Rc::new(String::new());\n unsafe {\n     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n }\n assert_eq!(*x, \"foo\");\n ```\n Other `Rc` pointers to the same allocation must be to the same type.\n ```no_run\n #![feature(get_mut_unchecked)]\n\n use std::rc::Rc;\n\n let x: Rc<str> = Rc::from(\"Hello, world!\");\n let mut y: Rc<[u8]> = x.clone().into();\n unsafe {\n     // this is Undefined Behavior, because x's inner type is str, not [u8]\n     Rc::get_mut_unchecked(&mut y).fill(0xff); // 0xff is invalid in UTF-8\n }\n println!(\"{}\", &*x); // Invalid UTF-8 in a str\n ```\n Other `Rc` pointers to the same allocation must be to the exact same type, including lifetimes.\n ```no_run\n #![feature(get_mut_unchecked)]\n\n use std::rc::Rc;\n\n let x: Rc<&str> = Rc::new(\"Hello, world!\");\n {\n     let s = String::from(\"Oh, no!\");\n     let mut y: Rc<&str> = x.clone();\n     unsafe {\n         // this is Undefined Behavior, because x's inner type\n         // is &'long str, not &'short str\n         *Rc::get_mut_unchecked(&mut y) = &s;\n     }\n }\n println!(\"{}\", &*x); // Use-after-free\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}