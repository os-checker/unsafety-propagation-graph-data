{
  "name": "collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after",
  "safe": true,
  "callees": {
    "collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_prev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the key and value of the previous element\n without moving the cursor.\n\n If the cursor is at the start of the map then `None` is returned.\n",
      "adt": {
        "collections::btree::map::CursorMutKey": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the key and value of the next element without\n moving the cursor.\n\n If the cursor is at the end of the map then `None` is returned.\n",
      "adt": {
        "collections::btree::map::CursorMutKey": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::cmp::PartialOrd::ge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests greater than or equal to (for `self` and `other`) and is used by\n the `>=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 >= 1.0, true);\n assert_eq!(1.0 >= 2.0, false);\n assert_eq!(2.0 >= 1.0, true);\n ```\n",
      "adt": {}
    },
    "collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a new key-value pair into the map in the gap that the\n cursor is currently pointing to.\n\n After the insertion the cursor will be pointing at the gap before the\n newly inserted element.\n\n # Safety\n\n You must ensure that the `BTreeMap` invariants are maintained.\n Specifically:\n\n * The key of the newly inserted element must be unique in the tree.\n * All keys in the tree must remain in sorted order.\n",
      "adt": {
        "collections::btree::map::CursorMutKey": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::map::CursorMutKey": [
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2762, kind: RigidTy(Tuple([Ty { id: 2761, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Mut)) }, Ty { id: 2687, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }, Mut)) }])) }), Field(0, Ty { id: 2761, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }, Mut)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 662,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/map.rs:3365:5: 3380:6",
  "src": "pub fn insert_after(&mut self, key: K, value: V) -> Result<(), UnorderedKeyError> {\n        if let Some((prev, _)) = self.peek_prev() {\n            if &key <= prev {\n                return Err(UnorderedKeyError {});\n            }\n        }\n        if let Some((next, _)) = self.peek_next() {\n            if &key >= next {\n                return Err(UnorderedKeyError {});\n            }\n        }\n        unsafe {\n            self.insert_after_unchecked(key, value);\n        }\n        Ok(())\n    }",
  "mir": "fn collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after(_1: &mut collections::btree::map::CursorMutKey<'_, K, V, A>, _2: K, _3: V) -> core::result::Result<(), collections::btree::map::UnorderedKeyError> {\n    let mut _0: core::result::Result<(), collections::btree::map::UnorderedKeyError>;\n    let mut _4: core::option::Option<(&mut K, &mut V)>;\n    let mut _5: isize;\n    let  _6: &mut K;\n    let mut _7: bool;\n    let mut _8: &&K;\n    let  _9: &K;\n    let mut _10: &&K;\n    let  _11: &K;\n    let mut _12: core::option::Option<(&mut K, &mut V)>;\n    let mut _13: isize;\n    let  _14: &mut K;\n    let mut _15: bool;\n    let mut _16: &&K;\n    let  _17: &K;\n    let mut _18: &&K;\n    let  _19: &K;\n    let  _20: ();\n    let mut _21: K;\n    let mut _22: V;\n    debug self => _1;\n    debug key => _2;\n    debug value => _3;\n    debug prev => _6;\n    debug next => _14;\n    bb0: {\n        StorageLive(_4);\n        _4 = collections::btree::map::CursorMutKey::<'_, K, V, A>::peek_prev(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = discriminant(_4);\n        switchInt(move _5) -> [1: bb2, 0: bb6, otherwise: bb19];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = move (((_4 as variant#1).0: (&mut K, &mut V)).0: &mut K);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_2;\n        _8 = &_9;\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(*_6);\n        _10 = &_11;\n        _7 = <&K as core::cmp::PartialOrd>::le(move _8, move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _7) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        _0 = core::result::Result::Err(collections::btree::map::UnorderedKeyError {{  }});\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb16;\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_4);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_12);\n        _12 = collections::btree::map::CursorMutKey::<'_, K, V, A>::peek_next(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _13 = discriminant(_12);\n        switchInt(move _13) -> [1: bb9, 0: bb13, otherwise: bb19];\n    }\n    bb9: {\n        StorageLive(_14);\n        _14 = move (((_12 as variant#1).0: (&mut K, &mut V)).0: &mut K);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_2;\n        _16 = &_17;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &(*_14);\n        _18 = &_19;\n        _15 = <&K as core::cmp::PartialOrd>::ge(move _16, move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _15) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        _0 = core::result::Result::Err(collections::btree::map::UnorderedKeyError {{  }});\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_12);\n        goto -> bb16;\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_12);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_12);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_21);\n        _21 = move _2;\n        StorageLive(_22);\n        _22 = move _3;\n        _20 = collections::btree::map::CursorMutKey::<'_, K, V, A>::insert_after_unchecked(_1, move _21, move _22) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _0 = core::result::Result::Ok(());\n        goto -> bb18;\n    }\n    bb16: {\n        drop(_3) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        drop(_2) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        return;\n    }\n    bb19: {\n        unreachable;\n    }\n}\n",
  "doc": " Inserts a new key-value pair into the map in the gap that the\n cursor is currently pointing to.\n\n After the insertion the cursor will be pointing at the gap before the\n newly inserted element.\n\n If the inserted key is not greater than the key before the cursor\n (if any), or if it not less than the key after the cursor (if any),\n then an [`UnorderedKeyError`] is returned since this would\n invalidate the [`Ord`] invariant between the keys of the map.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}