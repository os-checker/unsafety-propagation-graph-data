{
  "name": "<vec::extract_if::ExtractIf<'_, T, F, A> as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the vector's buffer, or a dangling raw pointer\n valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize mutable references to the slice,\n or mutable references to specific elements you are planning on accessing through this pointer,\n as well as writing to those elements, may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n\n # Examples\n\n ```\n let x = vec![1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(*x_ptr.add(i), 1 << i);\n     }\n }\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0, 1, 2];\n     let ptr1 = v.as_ptr();\n     let _ = ptr1.read();\n     let ptr2 = v.as_mut_ptr().offset(2);\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`\n     // because it mutated a different element:\n     let _ = ptr1.read();\n }\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n",
      "adt": {
        "vec::Vec": "ImmutableAsArgument"
      }
    },
    "core::ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish_non_exhaustive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marks the struct as non-exhaustive, indicating to the reader that there are some other\n fields that are not shown in the debug representation.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     hidden: f32,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .finish_non_exhaustive() // Show that some other field(s) exist.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n     \"Bar { bar: 10, .. }\",\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "vec::extract_if::ExtractIf": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "vec::Vec": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ],
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<vec::extract_if::ExtractIf<'_, T, F, A> as core::fmt::Debug>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/extract_if.rs:132:5: 148:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let peek = if self.idx < self.end {\n            // This has to use pointer arithmetic as `self.vec[self.idx]` or\n            // `self.vec.get_unchecked(self.idx)` wouldn't work since we\n            // temporarily set the length of `self.vec` to zero.\n            //\n            // SAFETY:\n            // Since `self.idx` is smaller than `self.end` and `self.end` is\n            // smaller than `self.old_len`, `idx` is valid for indexing the\n            // buffer. Also, per the invariant of `self.idx`, this element\n            // has not been inspected/moved out yet.\n            Some(unsafe { &*self.vec.as_ptr().add(self.idx) })\n        } else {\n            None\n        };\n        f.debug_struct(\"ExtractIf\").field(\"peek\", &peek).finish_non_exhaustive()\n    }",
  "mir": "fn <vec::extract_if::ExtractIf<'_, T, F, A> as core::fmt::Debug>::fmt(_1: &vec::extract_if::ExtractIf<'_, T, F, A>, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let  _3: core::option::Option<&T>;\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: &T;\n    let  _8: *const T;\n    let mut _9: *const T;\n    let mut _10: &vec::Vec<T, A>;\n    let mut _11: usize;\n    let mut _12: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _13: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _14: core::fmt::DebugStruct<'_, '_>;\n    let mut _15: &str;\n    let mut _16: &str;\n    let mut _17: &dyn core::fmt::Debug;\n    let  _18: &core::option::Option<&T>;\n    let mut _19: &mut vec::Vec<T, A>;\n    debug self => _1;\n    debug f => _2;\n    debug peek => _3;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).1: usize);\n        StorageLive(_6);\n        _6 = ((*_1).2: usize);\n        _4 = Lt(move _5, move _6);\n        switchInt(move _4) -> [0: bb4, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _19 = ((*_1).0: &mut vec::Vec<T, A>);\n        _10 = &(*_19);\n        _9 = vec::Vec::<T, A>::as_ptr(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = ((*_1).1: usize);\n        _8 = core::ptr::const_ptr::<impl *const T>::add(move _9, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        StorageDead(_9);\n        _7 = &(*_8);\n        _3 = core::option::Option::Some(move _7);\n        StorageDead(_7);\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _3 = core::option::Option::None;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_4);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = \"ExtractIf\";\n        _14 = core::fmt::Formatter::<'_>::debug_struct(_2, move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = &mut _14;\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = \"peek\";\n        StorageLive(_17);\n        _18 = &_3;\n        _17 = _18 as &dyn core::fmt::Debug;\n        _12 = core::fmt::DebugStruct::<'_, '_>::field(move _13, move _16, move _17) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_13);\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish_non_exhaustive(_12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_8);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}