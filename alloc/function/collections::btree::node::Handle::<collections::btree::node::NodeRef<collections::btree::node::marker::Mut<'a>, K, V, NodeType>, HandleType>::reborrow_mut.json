{
  "name": "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, HandleType>::reborrow_mut",
  "safe": false,
  "callees": {
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, Type>::reborrow_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Temporarily takes out another mutable reference to the same node. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n Because mutable pointers can roam anywhere around the tree, the returned\n pointer can easily be used to make the original pointer dangling, out of\n bounds, or invalid under stacked borrow rules.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "MutRef",
      "Plain"
    ],
    "collections::btree::node::Handle": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Plain",
      "MutRef"
    ]
  },
  "path": 911,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/node.rs:843:5: 848:6",
  "src": "pub(super) unsafe fn reborrow_mut(\n        &mut self,\n    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n        // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n        Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }\n    }",
  "mir": "fn collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, HandleType>::reborrow_mut(_1: &mut collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, NodeType>, HandleType>) -> collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, NodeType>, HandleType> {\n    let mut _0: collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, NodeType>, HandleType>;\n    let mut _2: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, NodeType>;\n    let mut _3: &mut collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, NodeType>;\n    let mut _4: usize;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, NodeType>);\n        _2 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, NodeType>::reborrow_mut(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = ((*_1).1: usize);\n        _0 = Handle(move _2, move _4, ZeroSized: core::marker::PhantomData<HandleType>);\n        StorageDead(_4);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Temporarily takes out another mutable handle on the same location. Beware, as\n this method is very dangerous, doubly so since it might not immediately appear\n dangerous.\n\n For details, see `NodeRef::reborrow_mut`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}