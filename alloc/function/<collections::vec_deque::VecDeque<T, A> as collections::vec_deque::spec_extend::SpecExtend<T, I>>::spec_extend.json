{
  "name": "<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtend<T, I>>::spec_extend",
  "safe": true,
  "callees": {
    "core::iter::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves capacity for at least `additional` more elements to be inserted in the given\n deque. The collection may reserve more space to speculatively avoid frequent reallocations.\n\n # Panics\n\n Panics if the new capacity overflows `usize`.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf: VecDeque<i32> = [1].into();\n buf.reserve(10);\n assert!(buf.capacity() >= 11);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::to_physical_idx": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::write_iter_wrapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes all values from `iter` to `dst`, wrapping\n at the end of the buffer and returns the number\n of written values.\n\n # Safety\n\n Assumes that `iter` yields at most `len` items.\n Assumes capacity is sufficient.\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 257, kind: RigidTy(Adt(AdtDef(DefId { id: 2671, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 14, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "collections::vec_deque::VecDeque": [
      "MutRef",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtend<T, I>>::spec_extend"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/spec_extend.rs:48:5: 76:6",
  "src": "default fn spec_extend(&mut self, iter: I) {\n        // This is the case for a TrustedLen iterator.\n        let (low, high) = iter.size_hint();\n        if let Some(additional) = high {\n            debug_assert_eq!(\n                low,\n                additional,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n            self.reserve(additional);\n\n            let written = unsafe {\n                self.write_iter_wrapping(self.to_physical_idx(self.len), iter, additional)\n            };\n\n            debug_assert_eq!(\n                additional, written,\n                \"The number of items written to VecDeque doesn't match the TrustedLen size hint\"\n            );\n        } else {\n            // Per TrustedLen contract a `None` upper bound means that the iterator length\n            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n            // This avoids additional codegen for a fallback code path which would eventually\n            // panic anyway.\n            panic!(\"capacity overflow\");\n        }\n    }",
  "mir": "fn <collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtend<T, I>>::spec_extend(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: I) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let  _4: core::option::Option<usize>;\n    let mut _5: (usize, core::option::Option<usize>);\n    let mut _6: &I;\n    let mut _7: isize;\n    let  _8: usize;\n    let mut _9: (&usize, &usize);\n    let mut _10: &usize;\n    let mut _11: &usize;\n    let  _12: &usize;\n    let  _13: &usize;\n    let mut _14: bool;\n    let mut _15: usize;\n    let mut _16: usize;\n    let  _17: core::panicking::AssertKind;\n    let  _18: !;\n    let mut _19: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _20: core::fmt::Arguments<'_>;\n    let  _21: (&(usize, core::option::Option<usize>),);\n    let mut _22: &(usize, core::option::Option<usize>);\n    let  _23: (usize, core::option::Option<usize>);\n    let  _24: [core::fmt::rt::Argument<'_>; 1];\n    let mut _25: core::fmt::rt::Argument<'_>;\n    let mut _26: &[u8; 49];\n    let  _27: &[core::fmt::rt::Argument<'_>; 1];\n    let  _28: ();\n    let  _29: usize;\n    let mut _30: usize;\n    let mut _31: &collections::vec_deque::VecDeque<T, A>;\n    let mut _32: usize;\n    let mut _33: I;\n    let mut _34: (&usize, &usize);\n    let mut _35: &usize;\n    let mut _36: &usize;\n    let  _37: &usize;\n    let  _38: &usize;\n    let mut _39: bool;\n    let mut _40: usize;\n    let mut _41: usize;\n    let  _42: core::panicking::AssertKind;\n    let  _43: !;\n    let mut _44: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _45: core::fmt::Arguments<'_>;\n    let  _46: !;\n    let mut _47: core::fmt::Arguments<'_>;\n    let mut _48: &(usize, core::option::Option<usize>);\n    debug self => _1;\n    debug iter => _2;\n    debug low => _3;\n    debug high => _4;\n    debug additional => _8;\n    debug left_val => _12;\n    debug right_val => _13;\n    debug kind => _17;\n    debug args => _21;\n    debug args => _24;\n    debug written => _29;\n    debug left_val => _37;\n    debug right_val => _38;\n    debug kind => _42;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = <I as core::iter::Iterator>::size_hint(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _3 = (_5.0: usize);\n        _4 = (_5.1: core::option::Option<usize>);\n        StorageDead(_5);\n        _7 = discriminant(_4);\n        switchInt(move _7) -> [1: bb2, 0: bb13, otherwise: bb15];\n    }\n    bb2: {\n        _8 = ((_4 as variant#1).0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_3;\n        StorageLive(_11);\n        _11 = &_8;\n        _9 = (move _10, move _11);\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = (_9.0: &usize);\n        _13 = (_9.1: &usize);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (*_12);\n        StorageLive(_16);\n        _16 = (*_13);\n        _14 = Eq(move _15, move _16);\n        switchInt(move _14) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_9);\n        _28 = collections::vec_deque::VecDeque::<T, A>::reserve(_1, _8) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_16);\n        StorageDead(_15);\n        _17 = core::panicking::AssertKind::Eq;\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = (_3, _4);\n        _22 = &_23;\n        _21 = (move _22);\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _48 = (_21.0: &(usize, core::option::Option<usize>));\n        _25 = core::fmt::rt::Argument::<'_>::new_debug::<(usize, core::option::Option<usize>)>(_48) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _24 = [move _25];\n        StorageDead(_25);\n        StorageLive(_26);\n        _26 = b\".TrustedLen iterator\\'s size hint is not exact: \\xc0\\x00\";\n        _27 = &_24;\n        _20 = core::fmt::Arguments::<'_>::new::<49, 1>(move _26, _27) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_26);\n        _19 = core::option::Option::Some(move _20);\n        StorageDead(_20);\n        _18 = core::panicking::assert_failed::<usize, usize>(_17, _12, _13, move _19) -> unwind unreachable;\n    }\n    bb7: {\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &(*_1);\n        StorageLive(_32);\n        _32 = ((*_1).1: usize);\n        _30 = collections::vec_deque::VecDeque::<T, A>::to_physical_idx(move _31, move _32) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_33);\n        _33 = move _2;\n        _29 = collections::vec_deque::VecDeque::<T, A>::write_iter_wrapping::<I>(_1, move _30, move _33, _8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_33);\n        StorageDead(_30);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_8;\n        StorageLive(_36);\n        _36 = &_29;\n        _34 = (move _35, move _36);\n        StorageDead(_36);\n        StorageDead(_35);\n        _37 = (_34.0: &usize);\n        _38 = (_34.1: &usize);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = (*_37);\n        StorageLive(_41);\n        _41 = (*_38);\n        _39 = Eq(move _40, move _41);\n        switchInt(move _39) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_34);\n        StorageDead(_29);\n        return;\n    }\n    bb11: {\n        StorageDead(_41);\n        StorageDead(_40);\n        _42 = core::panicking::AssertKind::Eq;\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = core::fmt::Arguments::<'_>::from_str(\"The number of items written to VecDeque doesn't match the TrustedLen size hint\") -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _44 = core::option::Option::Some(move _45);\n        StorageDead(_45);\n        _43 = core::panicking::assert_failed::<usize, usize>(_42, _37, _38, move _44) -> unwind unreachable;\n    }\n    bb13: {\n        StorageLive(_47);\n        _47 = core::fmt::Arguments::<'_>::from_str(\"capacity overflow\") -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _46 = core::panicking::panic_fmt(move _47) -> unwind unreachable;\n    }\n    bb15: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}