{
  "name": "collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_node_through_parent",
  "safe": true,
  "callees": {
    "collections::btree::node::NodeRef::<BorrowType, K, V, Type>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the length of the node. This is the number of keys or values.\n The number of edges is `len() + 1`.\n Note that, despite being safe, calling this function can have the side effect\n of invalidating mutable references that unsafe code has created.\n",
      "adt": {
        "collections::btree::node::NodeRef": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::choose_parent_kv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Chooses a balancing context involving the node as a child, thus between\n the KV immediately to the left or to the right in the parent node.\n Returns an `Err` if there is no parent.\n Panics if the parent is empty.\n\n Prefers the left side, to be optimal if the given node is somehow\n underfull, meaning here only that it has fewer elements than its left\n sibling and than its right sibling, if they exist. In that case,\n merging with the left sibling is faster, since we only need to move\n the node's N elements, instead of shifting them to the right and moving\n more than N elements in front. Stealing from the left sibling is also\n typically faster, since we only need to shift the node's N elements to\n the right, instead of shifting at least N of the sibling's elements to\n the left.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor",
        "core::result::Result": "Constructor",
        "collections::btree::node::BalancingContext": "Constructor"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::can_merge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether merging is possible, i.e., whether there is enough room\n in a node to combine the central KV with both adjacent child nodes.\n",
      "adt": {
        "collections::btree::node::BalancingContext": "ImmutableAsArgument"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::merge_tracking_parent": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Merges the parent's key-value pair and both adjacent child nodes into\n the left child node and returns the shrunk parent node.\n\n Panics unless we `.can_merge()`.\n",
      "adt": {
        "collections::btree::node::NodeRef": "Constructor"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_left": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This does stealing similar to `steal_left` but steals multiple elements at once.\n",
      "adt": {
        "collections::btree::node::BalancingContext": "MutableAsArgument"
      }
    },
    "collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The symmetric clone of `bulk_steal_left`.\n",
      "adt": {
        "collections::btree::node::BalancingContext": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "collections::btree::node::NodeRef": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2514, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2512, kind: RigidTy(Adt(AdtDef(DefId { id: 3478, name: \"collections::btree::node::NodeRef\" }), GenericArgs([Type(Ty { id: 2425, kind: RigidTy(Adt(AdtDef(DefId { id: 3498, name: \"collections::btree::node::marker::Mut\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) }), Type(Ty { id: 2383, kind: RigidTy(Adt(AdtDef(DefId { id: 3525, name: \"collections::btree::node::marker::LeafOrInternal\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2514, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2514, kind: RigidTy(Adt(AdtDef(DefId { id: 3519, name: \"collections::btree::node::LeftOrRight\" }), GenericArgs([Type(Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2516, kind: RigidTy(Adt(AdtDef(DefId { id: 3520, name: \"collections::btree::node::BalancingContext\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 2435, kind: Param(ParamTy { index: 1, name: \"K\" }) }), Type(Ty { id: 2436, kind: Param(ParamTy { index: 2, name: \"V\" }) })]))) })])"
    ],
    "collections::btree::node::BalancingContext": [
      "Plain",
      "Ref",
      "MutRef"
    ]
  },
  "path": 962,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/fix.rs:13:5: 49:6",
  "src": "fn fix_node_through_parent<A: Allocator + Clone>(\n        self,\n        alloc: A,\n    ) -> Result<Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>>, Self> {\n        let len = self.len();\n        if len >= MIN_LEN {\n            Ok(None)\n        } else {\n            match self.choose_parent_kv() {\n                Ok(Left(mut left_parent_kv)) => {\n                    if left_parent_kv.can_merge() {\n                        let parent = left_parent_kv.merge_tracking_parent(alloc);\n                        Ok(Some(parent))\n                    } else {\n                        left_parent_kv.bulk_steal_left(MIN_LEN - len);\n                        Ok(None)\n                    }\n                }\n                Ok(Right(mut right_parent_kv)) => {\n                    if right_parent_kv.can_merge() {\n                        let parent = right_parent_kv.merge_tracking_parent(alloc);\n                        Ok(Some(parent))\n                    } else {\n                        right_parent_kv.bulk_steal_right(MIN_LEN - len);\n                        Ok(None)\n                    }\n                }\n                Err(root) => {\n                    if len > 0 {\n                        Ok(None)\n                    } else {\n                        Err(root)\n                    }\n                }\n            }\n        }\n    }",
  "mir": "fn collections::btree::fix::<impl collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>>::fix_node_through_parent(_1: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>, _2: A) -> core::result::Result<core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>> {\n    let mut _0: core::result::Result<core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let  _3: usize;\n    let mut _4: &collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _5: bool;\n    let mut _6: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let mut _7: core::result::Result<collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>, collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>>;\n    let mut _8: isize;\n    let mut _9: isize;\n    let mut _10: collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _11: bool;\n    let mut _12: &collections::btree::node::BalancingContext<'_, K, V>;\n    let  _13: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _14: collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _15: A;\n    let mut _16: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let  _17: ();\n    let mut _18: &mut collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _19: usize;\n    let mut _20: (usize, bool);\n    let mut _21: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let mut _22: collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _23: bool;\n    let mut _24: &collections::btree::node::BalancingContext<'_, K, V>;\n    let  _25: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>;\n    let mut _26: collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _27: A;\n    let mut _28: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let  _29: ();\n    let mut _30: &mut collections::btree::node::BalancingContext<'_, K, V>;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    let mut _33: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let  _34: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>;\n    let mut _35: bool;\n    let mut _36: core::option::Option<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::Internal>>;\n    let mut _37: bool;\n    debug self => _1;\n    debug alloc => _2;\n    debug len => _3;\n    debug left_parent_kv => _10;\n    debug parent => _13;\n    debug right_parent_kv => _22;\n    debug parent => _25;\n    debug root => _34;\n    bb0: {\n        _37 = false;\n        _37 = true;\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = Ge(_3, collections::btree::map::MIN_LEN);\n        switchInt(move _5) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _6);\n        StorageDead(_6);\n        goto -> bb28;\n    }\n    bb3: {\n        StorageLive(_7);\n        _7 = collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>::choose_parent_kv(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _8 = discriminant(((_7 as variant#0).0: collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>));\n        switchInt(move _8) -> [0: bb9, 1: bb8, otherwise: bb5];\n    }\n    bb7: {\n        _34 = move ((_7 as variant#1).0: collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'_>, K, V, collections::btree::node::marker::LeafOrInternal>);\n        StorageLive(_35);\n        _35 = Gt(_3, 0_usize);\n        switchInt(move _35) -> [0: bb25, otherwise: bb24];\n    }\n    bb8: {\n        StorageLive(_22);\n        _22 = move ((((_7 as variant#0).0: collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>) as variant#1).0: collections::btree::node::BalancingContext<'_, K, V>);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_22;\n        _23 = collections::btree::node::BalancingContext::<'_, K, V>::can_merge(move _24) -> [return: bb17, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_10);\n        _10 = move ((((_7 as variant#0).0: collections::btree::node::LeftOrRight<collections::btree::node::BalancingContext<'_, K, V>>) as variant#0).0: collections::btree::node::BalancingContext<'_, K, V>);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_10;\n        _11 = collections::btree::node::BalancingContext::<'_, K, V>::can_merge(move _12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _11) -> [0: bb13, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_12);\n        StorageLive(_14);\n        _14 = move _10;\n        StorageLive(_15);\n        _37 = false;\n        _15 = move _2;\n        _13 = collections::btree::node::BalancingContext::<'_, K, V>::merge_tracking_parent::<A>(move _14, move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = core::option::Option::Some(_13);\n        _0 = core::result::Result::Ok(move _16);\n        StorageDead(_16);\n        goto -> bb16;\n    }\n    bb13: {\n        StorageDead(_12);\n        StorageLive(_18);\n        _18 = &mut _10;\n        StorageLive(_19);\n        _20 = CheckedSub(collections::btree::map::MIN_LEN, _3);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", collections::btree::map::MIN_LEN, _3) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _19 = move (_20.0: usize);\n        _17 = collections::btree::node::BalancingContext::<'_, K, V>::bulk_steal_left(move _18, move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_21);\n        _21 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _21);\n        StorageDead(_21);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb27;\n    }\n    bb17: {\n        switchInt(move _23) -> [0: bb20, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_24);\n        StorageLive(_26);\n        _26 = move _22;\n        StorageLive(_27);\n        _37 = false;\n        _27 = move _2;\n        _25 = collections::btree::node::BalancingContext::<'_, K, V>::merge_tracking_parent::<A>(move _26, move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_28);\n        _28 = core::option::Option::Some(_25);\n        _0 = core::result::Result::Ok(move _28);\n        StorageDead(_28);\n        goto -> bb23;\n    }\n    bb20: {\n        StorageDead(_24);\n        StorageLive(_30);\n        _30 = &mut _22;\n        StorageLive(_31);\n        _32 = CheckedSub(collections::btree::map::MIN_LEN, _3);\n        assert(!move (_32.1: bool), \"attempt to compute `{} - {}`, which would overflow\", collections::btree::map::MIN_LEN, _3) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _31 = move (_32.0: usize);\n        _29 = collections::btree::node::BalancingContext::<'_, K, V>::bulk_steal_right(move _30, move _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_33);\n        _33 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _33);\n        StorageDead(_33);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb27;\n    }\n    bb24: {\n        StorageLive(_36);\n        _36 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _36);\n        StorageDead(_36);\n        goto -> bb26;\n    }\n    bb25: {\n        _0 = core::result::Result::Err(_34);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_35);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_7);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_5);\n        switchInt(_37) -> [0: bb29, otherwise: bb30];\n    }\n    bb29: {\n        return;\n    }\n    bb30: {\n        drop(_2) -> [return: bb29, unwind unreachable];\n    }\n}\n",
  "doc": " Stocks up a possibly underfull node by merging with or stealing from a\n sibling. If successful but at the cost of shrinking the parent node,\n returns that shrunk parent node. Returns an `Err` if the node is\n an empty root.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}