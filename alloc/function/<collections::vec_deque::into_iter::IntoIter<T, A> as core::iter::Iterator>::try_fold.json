{
  "name": "<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
  "safe": true,
  "callees": {
    "collections::vec_deque::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::try_fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that applies a function as long as it returns\n successfully, producing a single, final value.\n\n `try_fold()` takes two arguments: an initial value, and a closure with\n two arguments: an 'accumulator', and an element. The closure either\n returns successfully, with the value that the accumulator should have\n for the next iteration, or it returns failure, with an error value that\n is propagated back to the caller immediately (short-circuiting).\n\n The initial value is the value the accumulator will have on the first\n call. If applying the closure succeeded against every element of the\n iterator, `try_fold()` returns the final accumulator as success.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `try_fold()` on the internal parts\n from which this iterator is composed. If multiple calls are needed,\n the `?` operator may be convenient for chaining the accumulator value\n along, but beware any invariants that need to be upheld before those\n early returns. This is a `&mut self` method, so iteration needs to be\n resumable after hitting an error here.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the checked sum of all of the elements of the array\n let sum = a.into_iter().try_fold(0i8, |acc, x| acc.checked_add(x));\n\n assert_eq!(sum, Some(6));\n ```\n\n Short-circuiting:\n\n ```\n let a = [10, 20, 30, 100, 40, 50];\n let mut iter = a.into_iter();\n\n // This sum overflows when adding the 100 element\n let sum = iter.try_fold(0i8, |acc, x| acc.checked_add(x));\n assert_eq!(sum, None);\n\n // Because it short-circuited, the remaining elements are still\n // available through the iterator.\n assert_eq!(iter.len(), 2);\n assert_eq!(iter.next(), Some(40));\n ```\n\n While you cannot `break` from a closure, the [`ControlFlow`] type allows\n a similar idea:\n\n ```\n use std::ops::ControlFlow;\n\n let triangular = (1..30).try_fold(0_i8, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Break(120));\n\n let triangular = (1..30).try_fold(0_u64, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Continue(435));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "collections::vec_deque::into_iter::IntoIter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold::Guard": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6349, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 6351, kind: RigidTy(Adt(AdtDef(DefId { id: 4596, name: \"collections::vec_deque::VecDeque\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }), Type(Ty { id: 21, kind: Param(ParamTy { index: 1, name: \"A\" }) })]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 482, kind: Param(ParamTy { index: 2, name: \"B\" }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6448, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 2990, name: \"core::ops::Try::Residual\" }), args: GenericArgs([Type(Ty { id: 3210, kind: Param(ParamTy { index: 4, name: \"R\" }) })]) }) })])"
    ]
  },
  "path": 1360,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:75:5: 115:6",
  "src": "fn try_fold<B, F, R>(&mut self, mut init: B, mut f: F) -> R\n    where\n        F: FnMut(B, Self::Item) -> R,\n        R: Try<Output = B>,\n    {\n        struct Guard<'a, T, A: Allocator> {\n            deque: &'a mut VecDeque<T, A>,\n            // `consumed <= deque.len` always holds.\n            consumed: usize,\n        }\n\n        impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {\n            fn drop(&mut self) {\n                self.deque.len -= self.consumed;\n                self.deque.head = self.deque.to_physical_idx(self.consumed);\n            }\n        }\n\n        let mut guard = Guard { deque: &mut self.inner, consumed: 0 };\n\n        let (head, tail) = guard.deque.as_slices();\n\n        init = head\n            .iter()\n            .map(|elem| {\n                guard.consumed += 1;\n                // SAFETY: Because we incremented `guard.consumed`, the\n                // deque effectively forgot the element, so we can take\n                // ownership\n                unsafe { ptr::read(elem) }\n            })\n            .try_fold(init, &mut f)?;\n\n        tail.iter()\n            .map(|elem| {\n                guard.consumed += 1;\n                // SAFETY: Same as above.\n                unsafe { ptr::read(elem) }\n            })\n            .try_fold(init, &mut f)\n    }",
  "mir": "fn <collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold(_1: &mut collections::vec_deque::into_iter::IntoIter<T, A>, _2: B, _3: F) -> R {\n    let mut _0: R;\n    let mut _4: <collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold::Guard<'_, T, A>;\n    let mut _5: &mut collections::vec_deque::VecDeque<T, A>;\n    let  _6: &[T];\n    let  _7: &[T];\n    let mut _8: (&[T], &[T]);\n    let mut _9: &collections::vec_deque::VecDeque<T, A>;\n    let mut _10: core::ops::ControlFlow<<R as core::ops::Try>::Residual, B>;\n    let mut _11: R;\n    let mut _12: &mut core::iter::Map<core::slice::Iter<'_, T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:99:18: 99:24}>;\n    let mut _13: core::iter::Map<core::slice::Iter<'_, T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:99:18: 99:24}>;\n    let mut _14: core::slice::Iter<'_, T>;\n    let mut _15: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:99:18: 99:24};\n    let mut _16: &mut usize;\n    let mut _17: B;\n    let mut _18: &mut F;\n    let mut _19: isize;\n    let  _20: <R as core::ops::Try>::Residual;\n    let  _21: B;\n    let mut _22: &mut core::iter::Map<core::slice::Iter<'_, T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:109:18: 109:24}>;\n    let mut _23: core::iter::Map<core::slice::Iter<'_, T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:109:18: 109:24}>;\n    let mut _24: core::slice::Iter<'_, T>;\n    let mut _25: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:109:18: 109:24};\n    let mut _26: &mut usize;\n    let mut _27: B;\n    let mut _28: &mut F;\n    let mut _29: &mut collections::vec_deque::VecDeque<T, A>;\n    debug self => _1;\n    debug init => _2;\n    debug f => _3;\n    debug guard => _4;\n    debug head => _6;\n    debug tail => _7;\n    debug residual => _20;\n    debug val => _21;\n    bb0: {\n        StorageLive(_4);\n        _5 = &mut ((*_1).0: collections::vec_deque::VecDeque<T, A>);\n        _4 = Guard(_5, 0_usize);\n        StorageLive(_8);\n        StorageLive(_9);\n        _29 = (_4.0: &mut collections::vec_deque::VecDeque<T, A>);\n        _9 = &(*_29);\n        _8 = collections::vec_deque::VecDeque::<T, A>::as_slices(move _9) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_9);\n        _6 = (_8.0: &[T]);\n        _7 = (_8.1: &[T]);\n        StorageDead(_8);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = core::slice::<impl [T]>::iter(_6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut (_4.1: usize);\n        _15 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:99:18: 99:24}(move _16);\n        StorageDead(_16);\n        _13 = <core::slice::Iter<'_, T> as core::iter::Iterator>::map::<T, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:99:18: 99:24}>(move _14, move _15) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _12 = &mut _13;\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_17);\n        _17 = move _2;\n        StorageLive(_18);\n        _18 = &mut _3;\n        _11 = <core::iter::Map<core::slice::Iter<'_, T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:99:18: 99:24}> as core::iter::Iterator>::try_fold::<B, &mut F, R>(move _12, move _17, move _18) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_12);\n        _10 = <R as core::ops::Try>::branch(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        _19 = discriminant(_10);\n        switchInt(move _19) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _21 = move ((_10 as variant#0).0: B);\n        _2 = _21;\n        StorageDead(_13);\n        StorageDead(_10);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = core::slice::<impl [T]>::iter(_7) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _20 = move ((_10 as variant#1).0: <R as core::ops::Try>::Residual);\n        _0 = <R as core::ops::FromResidual>::from_residual(_20) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageDead(_10);\n        drop(_4) -> [return: bb14, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &mut (_4.1: usize);\n        _25 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:109:18: 109:24}(move _26);\n        StorageDead(_26);\n        _23 = <core::slice::Iter<'_, T> as core::iter::Iterator>::map::<T, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:109:18: 109:24}>(move _24, move _25) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _22 = &mut _23;\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_27);\n        _27 = move _2;\n        StorageLive(_28);\n        _28 = &mut _3;\n        _0 = <core::iter::Map<core::slice::Iter<'_, T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/into_iter.rs:109:18: 109:24}> as core::iter::Iterator>::try_fold::<B, &mut F, R>(move _22, move _27, move _28) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_23);\n        StorageDead(_22);\n        drop(_4) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_4);\n        drop(_3) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_4);\n        drop(_3) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}