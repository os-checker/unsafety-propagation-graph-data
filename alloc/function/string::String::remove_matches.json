{
  "name": "string::String::remove_matches",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::str::pattern::Pattern::into_searcher": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the associated searcher from\n `self` and the `haystack` to search in.\n",
      "adt": {}
    },
    "core::iter::from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator with the provided closure\n `F: FnMut() -> Option<T>` as its [`next`](Iterator::next) method.\n\n The iterator will yield the `T`s returned from the closure.\n\n This allows creating a custom iterator with any behavior\n without using the more verbose syntax of creating a dedicated type\n and implementing the [`Iterator`] trait for it.\n\n Note that the `FromFn` iterator doesnâ€™t make assumptions about the behavior of the closure,\n and therefore conservatively does not implement [`FusedIterator`],\n or override [`Iterator::size_hint()`] from its default `(0, None)`.\n\n The closure can use captures and its environment to track state across iterations. Depending on\n how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n\n [`move`]: ../../std/keyword.move.html\n [`FusedIterator`]: crate::iter::FusedIterator\n\n # Examples\n\n Letâ€™s re-implement the counter iterator from [module-level documentation]:\n\n [module-level documentation]: crate::iter\n\n ```\n let mut count = 0;\n let counter = std::iter::from_fn(move || {\n     // Increment our count. This is why we started at zero.\n     count += 1;\n\n     // Check to see if we've finished counting or not.\n     if count < 6 {\n         Some(count)\n     } else {\n         None\n     }\n });\n assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "string::String::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of this `String`, in bytes, not [`char`]s or\n graphemes. In other words, it might not be what a human considers the\n length of the string.\n\n # Examples\n\n ```\n let a = String::from(\"foo\");\n assert_eq!(a.len(), 3);\n\n let fancy_f = String::from(\"Æ’oo\");\n assert_eq!(fancy_f.len(), 4);\n assert_eq!(fancy_f.chars().count(), 3);\n ```\n",
      "adt": {
        "string::String": "ImmutableAsArgument"
      }
    },
    "core::iter::once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that yields an element exactly once.\n\n This is commonly used to adapt a single value into a [`chain()`] of other\n kinds of iteration. Maybe you have an iterator that covers almost\n everything, but you need an extra special case. Maybe you have a function\n which works on iterators, but you only need to process one value.\n\n [`chain()`]: Iterator::chain\n\n # Examples\n\n Basic usage:\n\n ```\n use std::iter;\n\n // one is the loneliest number\n let mut one = iter::once(1);\n\n assert_eq!(Some(1), one.next());\n\n // just one, that's all we get\n assert_eq!(None, one.next());\n ```\n\n Chaining together with another iterator. Let's say that we want to iterate\n over each file of the `.foo` directory, but also a configuration file,\n `.foorc`:\n\n ```no_run\n use std::iter;\n use std::fs;\n use std::path::PathBuf;\n\n let dirs = fs::read_dir(\".foo\")?;\n\n // we need to convert from an iterator of DirEntry-s to an iterator of\n // PathBufs, so we use map\n let dirs = dirs.map(|file| file.unwrap().path());\n\n // now, our iterator just for our config file\n let config = iter::once(PathBuf::from(\".foorc\"));\n\n // chain the two iterators together into one big iterator\n let files = dirs.chain(config);\n\n // this will give us all of the files in .foo as well as .foorc\n for f in files {\n     println!(\"{f:?}\");\n }\n # std::io::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::chain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes two iterators and creates a new iterator over both in sequence.\n\n `chain()` will return a new iterator which will first iterate over\n values from the first iterator and then over values from the second\n iterator.\n\n In other words, it links two iterators together, in a chain. ðŸ”—\n\n [`once`] is commonly used to adapt a single value into a chain of\n other kinds of iteration.\n\n # Examples\n\n Basic usage:\n\n ```\n let s1 = \"abc\".chars();\n let s2 = \"def\".chars();\n\n let mut iter = s1.chain(s2);\n\n assert_eq!(iter.next(), Some('a'));\n assert_eq!(iter.next(), Some('b'));\n assert_eq!(iter.next(), Some('c'));\n assert_eq!(iter.next(), Some('d'));\n assert_eq!(iter.next(), Some('e'));\n assert_eq!(iter.next(), Some('f'));\n assert_eq!(iter.next(), None);\n ```\n\n Since the argument to `chain()` uses [`IntoIterator`], we can pass\n anything that can be converted into an [`Iterator`], not just an\n [`Iterator`] itself. For example, arrays (`[T]`) implement\n [`IntoIterator`], and so can be passed to `chain()` directly:\n\n ```\n let a1 = [1, 2, 3];\n let a2 = [4, 5, 6];\n\n let mut iter = a1.into_iter().chain(a2);\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(5));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you work with Windows API, you may wish to convert [`OsStr`] to `Vec<u16>`:\n\n ```\n #[cfg(windows)]\n fn os_str_to_utf16(s: &std::ffi::OsStr) -> Vec<u16> {\n     use std::os::windows::ffi::OsStrExt;\n     s.encode_wide().chain(std::iter::once(0)).collect()\n }\n ```\n\n [`once`]: crate::iter::once\n [`OsStr`]: ../../std/ffi/struct.OsStr.html\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n\n If the source and destination will *never* overlap,\n [`copy_nonoverlapping`] can be used instead.\n\n `copy` is semantically equivalent to C's [`memmove`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n Copying takes place as if the bytes were copied from `src`\n to a temporary array and then copied from the array to `dst`.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\n   when `src` is read for `count * size_of::<T>()` bytes. (This means if the memory ranges\n   overlap, the `dst` pointer must not be invalidated by `src` reads.)\n\n * Both `src` and `dst` must be properly aligned.\n\n Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Efficiently create a Rust vector from an unsafe buffer:\n\n ```\n use std::ptr;\n\n /// # Safety\n ///\n /// * `ptr` must be correctly aligned for its type and non-zero.\n /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n /// * Those elements must not be used after calling this function unless `T: Copy`.\n # #[allow(dead_code)]\n unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     let mut dst = Vec::with_capacity(elts);\n\n     // SAFETY: Our precondition ensures the source is aligned and valid,\n     // and `Vec::with_capacity` ensures that we have usable space to write them.\n     unsafe { ptr::copy(ptr, dst.as_mut_ptr(), elts); }\n\n     // SAFETY: We created it with this much capacity earlier,\n     // and the previous `copy` has initialized these elements.\n     unsafe { dst.set_len(elts); }\n     dst\n }\n ```\n",
      "adt": {}
    },
    "vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "string::String": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::iter::FromFn": [
      "Plain"
    ],
    "vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "vec::into_iter::IntoIter": [
      "Plain"
    ],
    "core::iter::Once": [
      "Plain"
    ],
    "core::iter::Chain": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3255, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(0, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3255, kind: RigidTy(Tuple([Ty { id: 14, kind: RigidTy(Uint(Usize)) }, Ty { id: 14, kind: RigidTy(Uint(Usize)) }])) }), Field(1, Ty { id: 14, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": 1984,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1553:5: 1600:6",
  "src": "pub fn remove_matches<P: Pattern>(&mut self, pat: P) {\n        use core::str::pattern::Searcher;\n\n        let rejections = {\n            let mut searcher = pat.into_searcher(self);\n            // Per Searcher::next:\n            //\n            // A Match result needs to contain the whole matched pattern,\n            // however Reject results may be split up into arbitrary many\n            // adjacent fragments. Both ranges may have zero length.\n            //\n            // In practice the implementation of Searcher::next_match tends to\n            // be more efficient, so we use it here and do some work to invert\n            // matches into rejections since that's what we want to copy below.\n            let mut front = 0;\n            let rejections: Vec<_> = from_fn(|| {\n                let (start, end) = searcher.next_match()?;\n                let prev_front = front;\n                front = end;\n                Some((prev_front, start))\n            })\n            .collect();\n            rejections.into_iter().chain(core::iter::once((front, self.len())))\n        };\n\n        let mut len = 0;\n        let ptr = self.vec.as_mut_ptr();\n\n        for (start, end) in rejections {\n            let count = end - start;\n            if start != len {\n                // SAFETY: per Searcher::next:\n                //\n                // The stream of Match and Reject values up to a Done will\n                // contain index ranges that are adjacent, non-overlapping,\n                // covering the whole haystack, and laying on utf8\n                // boundaries.\n                unsafe {\n                    ptr::copy(ptr.add(start), ptr.add(len), count);\n                }\n            }\n            len += count;\n        }\n\n        unsafe {\n            self.vec.set_len(len);\n        }\n    }",
  "mir": "fn string::String::remove_matches(_1: &mut string::String, _2: P) -> () {\n    let mut _0: ();\n    let  _3: core::iter::Chain<vec::into_iter::IntoIter<(usize, usize)>, core::iter::Once<(usize, usize)>>;\n    let mut _4: <P as core::str::pattern::Pattern>::Searcher<'_>;\n    let  _5: &str;\n    let mut _6: &string::String;\n    let mut _7: usize;\n    let  _8: vec::Vec<(usize, usize)>;\n    let mut _9: core::iter::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1568:46: 1568:48}>;\n    let mut _10: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1568:46: 1568:48};\n    let mut _11: &mut <P as core::str::pattern::Pattern>::Searcher<'_>;\n    let mut _12: &mut usize;\n    let mut _13: vec::into_iter::IntoIter<(usize, usize)>;\n    let mut _14: core::iter::Once<(usize, usize)>;\n    let mut _15: (usize, usize);\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: &string::String;\n    let mut _19: usize;\n    let  _20: *mut u8;\n    let mut _21: &mut vec::Vec<u8>;\n    let mut _22: core::iter::Chain<vec::into_iter::IntoIter<(usize, usize)>, core::iter::Once<(usize, usize)>>;\n    let mut _23: core::iter::Chain<vec::into_iter::IntoIter<(usize, usize)>, core::iter::Once<(usize, usize)>>;\n    let mut _24: core::option::Option<(usize, usize)>;\n    let mut _25: &mut core::iter::Chain<vec::into_iter::IntoIter<(usize, usize)>, core::iter::Once<(usize, usize)>>;\n    let mut _26: isize;\n    let  _27: usize;\n    let  _28: usize;\n    let  _29: usize;\n    let mut _30: (usize, bool);\n    let mut _31: bool;\n    let mut _32: usize;\n    let  _33: ();\n    let mut _34: *const u8;\n    let mut _35: *mut u8;\n    let mut _36: *mut u8;\n    let mut _37: usize;\n    let mut _38: (usize, bool);\n    let  _39: ();\n    let mut _40: &mut vec::Vec<u8>;\n    let mut _41: usize;\n    debug self => _1;\n    debug pat => _2;\n    debug rejections => _3;\n    debug searcher => _4;\n    debug front => _7;\n    debug rejections => _8;\n    debug len => _19;\n    debug ptr => _20;\n    debug iter => _23;\n    debug start => _27;\n    debug end => _28;\n    debug count => _29;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = <string::String as core::ops::Deref>::deref(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _4 = <P as core::str::pattern::Pattern>::into_searcher(_2, _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = 0_usize;\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &mut _4;\n        StorageLive(_12);\n        _12 = &mut _7;\n        _10 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1568:46: 1568:48}(move _11, move _12);\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = core::iter::from_fn::<(usize, usize), {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1568:46: 1568:48}>(move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_10);\n        _8 = <core::iter::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:1568:46: 1568:48}> as core::iter::Iterator>::collect::<vec::Vec<(usize, usize)>>(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_13);\n        _13 = <vec::Vec<(usize, usize)> as core::iter::IntoIterator>::into_iter(_8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _7;\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &(*_1);\n        _17 = string::String::len(move _18) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_18);\n        _15 = (move _16, move _17);\n        StorageDead(_17);\n        StorageDead(_16);\n        _14 = core::iter::once::<(usize, usize)>(move _15) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_15);\n        _3 = <vec::into_iter::IntoIter<(usize, usize)> as core::iter::Iterator>::chain::<core::iter::Once<(usize, usize)>>(move _13, move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_7);\n        drop(_4) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_4);\n        StorageLive(_19);\n        _19 = 0_usize;\n        StorageLive(_21);\n        _21 = &mut ((*_1).0: vec::Vec<u8>);\n        _20 = vec::Vec::<u8>::as_mut_ptr(move _21) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_21);\n        StorageLive(_22);\n        _22 = <core::iter::Chain<vec::into_iter::IntoIter<(usize, usize)>, core::iter::Once<(usize, usize)>> as core::iter::IntoIterator>::into_iter(_3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_23);\n        _23 = move _22;\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_24);\n        _25 = &mut _23;\n        _24 = <core::iter::Chain<vec::into_iter::IntoIter<(usize, usize)>, core::iter::Once<(usize, usize)>> as core::iter::Iterator>::next(_25) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _26 = discriminant(_24);\n        switchInt(move _26) -> [0: bb16, 1: bb15, otherwise: bb14];\n    }\n    bb14: {\n        unreachable;\n    }\n    bb15: {\n        _27 = (((_24 as variant#1).0: (usize, usize)).0: usize);\n        _28 = (((_24 as variant#1).0: (usize, usize)).1: usize);\n        _30 = CheckedSub(_28, _27);\n        assert(!move (_30.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _28, _27) -> [success: bb17, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_24);\n        drop(_23) -> [return: bb25, unwind unreachable];\n    }\n    bb17: {\n        _29 = move (_30.0: usize);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _19;\n        _31 = Ne(_27, move _32);\n        switchInt(move _31) -> [0: bb22, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_32);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = core::ptr::mut_ptr::<impl *mut u8>::add(_20, _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _34 = move _35 as *const u8;\n        StorageDead(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = _19;\n        _36 = core::ptr::mut_ptr::<impl *mut u8>::add(_20, move _37) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_37);\n        _33 = core::ptr::copy::<u8>(move _34, move _36, _29) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_36);\n        StorageDead(_34);\n        goto -> bb23;\n    }\n    bb22: {\n        StorageDead(_32);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_31);\n        _38 = CheckedAdd(_19, _29);\n        assert(!move (_38.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _19, _29) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _19 = move (_38.0: usize);\n        StorageDead(_24);\n        goto -> bb12;\n    }\n    bb25: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_40);\n        _40 = &mut ((*_1).0: vec::Vec<u8>);\n        StorageLive(_41);\n        _41 = _19;\n        _39 = vec::Vec::<u8>::set_len(move _40, move _41) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_19);\n        return;\n    }\n}\n",
  "doc": " Remove all matches of pattern `pat` in the `String`.\n\n # Examples\n\n ```\n #![feature(string_remove_matches)]\n let mut s = String::from(\"Trees are not green, the sky is not blue.\");\n s.remove_matches(\"not \");\n assert_eq!(\"Trees are green, the sky is blue.\", s);\n ```\n\n Matches will be detected and removed iteratively, so in cases where\n patterns overlap, only the first pattern will be removed:\n\n ```\n #![feature(string_remove_matches)]\n let mut s = String::from(\"banana\");\n s.remove_matches(\"ana\");\n assert_eq!(\"bna\", s);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}