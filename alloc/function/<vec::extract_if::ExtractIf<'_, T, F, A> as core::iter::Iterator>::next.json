{
  "name": "<vec::extract_if::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next",
  "safe": true,
  "callees": {
    "vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {
        "vec::Vec": "MutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ptr::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads.\n\n * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n   case.\n\n * `src` must point to a properly initialized value of type `T`.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n # Examples\n\n Basic usage:\n\n ```\n let x = 12;\n let y = &x as *const i32;\n\n unsafe {\n     assert_eq!(std::ptr::read(y), 12);\n }\n ```\n\n Manually implement [`mem::swap`]:\n\n ```\n use std::ptr;\n\n fn swap<T>(a: &mut T, b: &mut T) {\n     unsafe {\n         // Create a bitwise copy of the value at `a` in `tmp`.\n         let tmp = ptr::read(a);\n\n         // Exiting at this point (either by explicitly returning or by\n         // calling a function which panics) would cause the value in `tmp` to\n         // be dropped while the same value is still referenced by `a`. This\n         // could trigger undefined behavior if `T` is not `Copy`.\n\n         // Create a bitwise copy of the value at `b` in `a`.\n         // This is safe because mutable references cannot alias.\n         ptr::copy_nonoverlapping(b, a, 1);\n\n         // As above, exiting here could trigger undefined behavior because\n         // the same value is referenced by `a` and `b`.\n\n         // Move `tmp` into `b`.\n         ptr::write(b, tmp);\n\n         // `tmp` has been moved (`write` takes ownership of its second argument),\n         // so nothing is dropped implicitly here.\n     }\n }\n\n let mut foo = \"foo\".to_owned();\n let mut bar = \"bar\".to_owned();\n\n swap(&mut foo, &mut bar);\n\n assert_eq!(foo, \"bar\");\n assert_eq!(bar, \"foo\");\n ```\n\n ## Ownership of the Returned Value\n\n `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n If `T` is not [`Copy`], using both the returned value and the value at\n `*src` can violate memory safety. Note that assigning to `*src` counts as a\n use because it will attempt to drop the value at `*src`.\n\n [`write()`] can be used to overwrite data without causing it to be dropped.\n\n ```\n use std::ptr;\n\n let mut s = String::from(\"foo\");\n unsafe {\n     // `s2` now points to the same underlying memory as `s`.\n     let mut s2: String = ptr::read(&s);\n\n     assert_eq!(s2, \"foo\");\n\n     // Assigning to `s2` causes its original value to be dropped. Beyond\n     // this point, `s` must no longer be used, as the underlying memory has\n     // been freed.\n     s2 = String::default();\n     assert_eq!(s2, \"\");\n\n     // Assigning to `s` would cause the old value to be dropped again,\n     // resulting in undefined behavior.\n     // s = String::from(\"bar\"); // ERROR\n\n     // `ptr::write` can be used to overwrite a value without dropping it.\n     ptr::write(&mut s, String::from(\"bar\"));\n }\n\n assert_eq!(s, \"bar\");\n ```\n\n [valid]: self#safety\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "vec::extract_if::ExtractIf": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "MutRef"
    ],
    "vec::Vec": [
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2210,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/extract_if.rs:67:5: 99:6",
  "src": "fn next(&mut self) -> Option<T> {\n        while self.idx < self.end {\n            let i = self.idx;\n            // SAFETY:\n            //  We know that `i < self.end` from the if guard and that `self.end <= self.old_len` from\n            //  the validity of `Self`. Therefore `i` points to an element within `vec`.\n            //\n            //  Additionally, the i-th element is valid because each element is visited at most once\n            //  and it is the first time we access vec[i].\n            //\n            //  Note: we can't use `vec.get_unchecked_mut(i)` here since the precondition for that\n            //  function is that i < vec.len(), but we've set vec's length to zero.\n            let cur = unsafe { &mut *self.vec.as_mut_ptr().add(i) };\n            let drained = (self.pred)(cur);\n            // Update the index *after* the predicate is called. If the index\n            // is updated prior and the predicate panics, the element at this\n            // index would be leaked.\n            self.idx += 1;\n            if drained {\n                self.del += 1;\n                // SAFETY: We never touch this element again after returning it.\n                return Some(unsafe { ptr::read(cur) });\n            } else if self.del > 0 {\n                // SAFETY: `self.del` > 0, so the hole slot must not overlap with current element.\n                // We use copy for move, and never touch this element again.\n                unsafe {\n                    let hole_slot = self.vec.as_mut_ptr().add(i - self.del);\n                    ptr::copy_nonoverlapping(cur, hole_slot, 1);\n                }\n            }\n        }\n        None\n    }",
  "mir": "fn <vec::extract_if::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next(_1: &mut vec::extract_if::ExtractIf<'_, T, F, A>) -> core::option::Option<T> {\n    let mut _0: core::option::Option<T>;\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: usize;\n    let  _5: usize;\n    let mut _6: &mut T;\n    let mut _7: *mut T;\n    let mut _8: *mut T;\n    let  _9: bool;\n    let mut _10: &mut F;\n    let mut _11: (&mut T,);\n    let mut _12: (usize, bool);\n    let mut _13: (usize, bool);\n    let mut _14: T;\n    let mut _15: *const T;\n    let mut _16: bool;\n    let mut _17: usize;\n    let  _18: *mut T;\n    let mut _19: *mut T;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: (usize, bool);\n    let  _23: ();\n    let mut _24: *const T;\n    let mut _25: &mut vec::Vec<T, A>;\n    let mut _26: &mut vec::Vec<T, A>;\n    debug self => _1;\n    debug i => _5;\n    debug cur => _6;\n    debug drained => _9;\n    debug hole_slot => _18;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).1: usize);\n        StorageLive(_4);\n        _4 = ((*_1).2: usize);\n        _2 = Lt(move _3, move _4);\n        switchInt(move _2) -> [0: bb18, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        _5 = ((*_1).1: usize);\n        StorageLive(_7);\n        StorageLive(_8);\n        _25 = ((*_1).0: &mut vec::Vec<T, A>);\n        _8 = vec::Vec::<T, A>::as_mut_ptr(_25) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = core::ptr::mut_ptr::<impl *mut T>::add(move _8, _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _6 = &mut (*_7);\n        StorageLive(_10);\n        _10 = &mut ((*_1).5: F);\n        StorageLive(_11);\n        _11 = (_6);\n        _9 = <F as core::ops::FnMut<(&mut T,)>>::call_mut(move _10, move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = CheckedAdd(((*_1).1: usize), 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).1: usize), 1_usize) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        ((*_1).1: usize) = move (_12.0: usize);\n        switchInt(_9) -> [0: bb10, otherwise: bb7];\n    }\n    bb7: {\n        _13 = CheckedAdd(((*_1).3: usize), 1_usize);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).3: usize), 1_usize) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        ((*_1).3: usize) = move (_13.0: usize);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &raw const (*_6);\n        _14 = core::ptr::read::<T>(move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        _0 = core::option::Option::Some(move _14);\n        StorageDead(_14);\n        StorageDead(_7);\n        StorageDead(_2);\n        goto -> bb19;\n    }\n    bb10: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = ((*_1).3: usize);\n        _16 = Gt(move _17, 0_usize);\n        switchInt(move _16) -> [0: bb16, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageLive(_19);\n        _26 = ((*_1).0: &mut vec::Vec<T, A>);\n        _19 = vec::Vec::<T, A>::as_mut_ptr(_26) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = ((*_1).3: usize);\n        _22 = CheckedSub(_5, _21);\n        assert(!move (_22.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, move _21) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_22.0: usize);\n        StorageDead(_21);\n        _18 = core::ptr::mut_ptr::<impl *mut T>::add(move _19, move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_24);\n        _24 = &raw const (*_6);\n        _23 = core::ptr::copy_nonoverlapping::<T>(move _24, _18, 1_usize) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_24);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_17);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_16);\n        StorageDead(_7);\n        StorageDead(_2);\n        goto -> bb1;\n    }\n    bb18: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        _0 = core::option::Option::None;\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}