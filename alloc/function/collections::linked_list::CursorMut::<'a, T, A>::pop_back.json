{
  "name": "collections::linked_list::CursorMut::<'a, T, A>::pop_back",
  "safe": true,
  "callees": {
    "collections::linked_list::LinkedList::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the `LinkedList` is empty.\n\n This operation should compute in *O*(1) time.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut dl = LinkedList::new();\n assert!(dl.is_empty());\n\n dl.push_front(\"foo\");\n assert!(!dl.is_empty());\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {}
    },
    "collections::linked_list::LinkedList::<T, A>::pop_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the last element from a list and returns it, or `None` if\n it is empty.\n\n This operation should compute in *O*(1) time.\n\n # Examples\n\n ```\n use std::collections::LinkedList;\n\n let mut d = LinkedList::new();\n assert_eq!(d.pop_back(), None);\n d.push_back(1);\n d.push_back(3);\n assert_eq!(d.pop_back(), Some(3));\n ```\n",
      "adt": {
        "collections::linked_list::LinkedList": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "collections::linked_list::LinkedList": [
      "MutRef",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "collections::linked_list::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::collections::linked_list::CursorMut::<'a, T, A>::pop_back"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/linked_list.rs:1874:5: 1888:6",
  "src": "pub fn pop_back(&mut self) -> Option<T> {\n        if self.list.is_empty() {\n            None\n        } else {\n            if self.list.tail == self.current {\n                // The index now reflects the length of the list. It was the\n                // length of the list minus 1, but now the list is 1 smaller. No\n                // change is needed for `index`.\n                self.current = None;\n            } else if self.current.is_none() {\n                self.index = self.list.len - 1;\n            }\n            self.list.pop_back()\n        }\n    }",
  "mir": "fn collections::linked_list::CursorMut::<'a, T, A>::pop_back(_1: &mut collections::linked_list::CursorMut<'_, T, A>) -> core::option::Option<T> {\n    let mut _0: core::option::Option<T>;\n    let mut _2: bool;\n    let mut _3: &collections::linked_list::LinkedList<T, A>;\n    let mut _4: bool;\n    let mut _5: &core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let mut _6: &core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let mut _7: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let mut _8: bool;\n    let mut _9: &core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let mut _12: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _13: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _14: &mut collections::linked_list::LinkedList<T, A>;\n    let mut _15: &mut collections::linked_list::LinkedList<T, A>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _12 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _3 = &(*_12);\n        _2 = collections::linked_list::LinkedList::<T, A>::is_empty(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        goto -> bb14;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _13 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _5 = &((*_13).1: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>);\n        StorageLive(_6);\n        _6 = &((*_1).1: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>);\n        _4 = <core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>> as core::cmp::PartialEq>::eq(move _5, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _4) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_7);\n        _7 = core::option::Option::None;\n        ((*_1).1: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>) = move _7;\n        StorageDead(_7);\n        goto -> bb12;\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &((*_1).1: core::option::Option<core::ptr::NonNull<collections::linked_list::Node<T>>>);\n        _8 = core::option::Option::<core::ptr::NonNull<collections::linked_list::Node<T>>>::is_none(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _8) -> [0: bb10, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageLive(_10);\n        _14 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _10 = ((*_14).2: usize);\n        _11 = CheckedSub(_10, 1_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _10, 1_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        ((*_1).0: usize) = move (_11.0: usize);\n        StorageDead(_10);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_9);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_8);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_4);\n        _15 = ((*_1).2: &mut collections::linked_list::LinkedList<T, A>);\n        _0 = collections::linked_list::LinkedList::<T, A>::pop_back(_15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Removes the last element from the cursor's parent list and returns it,\n or None if the list is empty. The element the cursor points to remains\n unchanged, unless it was pointing to the back element. In that case, it\n points to the \"ghost\" element.\n\n This operation should compute in *O*(1) time.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}