{
  "name": "str::<impl str>::to_uppercase",
  "safe": true,
  "callees": {
    "core::num::<impl u8>::to_ascii_uppercase": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a copy of the value in its ASCII upper case equivalent.\n\n ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n but non-ASCII letters are unchanged.\n\n To uppercase the value in-place, use [`make_ascii_uppercase`].\n\n # Examples\n\n ```\n let lowercase_a = 97u8;\n\n assert_eq!(65, lowercase_a.to_ascii_uppercase());\n ```\n\n [`make_ascii_uppercase`]: Self::make_ascii_uppercase\n",
      "adt": {}
    },
    "str::convert_while_ascii": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Converts leading ascii bytes in `s` by calling the `convert` function.\n\n For better average performance, this happens in chunks of `2*size_of::<usize>()`.\n\n Returns a tuple of the converted prefix and the remainder starting from\n the first non-ascii character.\n\n This function is only public so that it can be verified in a codegen test,\n see `issue-123712-str-to-lower-autovectorization.rs`.\n",
      "adt": {
        "string::String": "Constructor"
      }
    },
    "core::str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"y̆\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'y̆'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::unicode::conversions::to_upper": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "string::String::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends the given [`char`] to the end of this `String`.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut s = String::from(\"abc\");\n\n s.push('1');\n s.push('2');\n s.push('3');\n\n assert_eq!(\"abc123\", s);\n ```\n",
      "adt": {
        "string::String": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "string::String": [
      "Plain",
      "Unknown([Field(0, Ty { id: 557, kind: RigidTy(Adt(AdtDef(DefId { id: 2811, name: \"string::String\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 1, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 5, kind: RigidTy(Str) }, Not)) })])",
      "MutRef"
    ],
    "core::str::Chars": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 904, kind: RigidTy(Char) })])"
    ]
  },
  "path": 168,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:466:5: 484:6",
  "src": "pub fn to_uppercase(&self) -> String {\n        let (mut s, rest) = convert_while_ascii(self, u8::to_ascii_uppercase);\n\n        for c in rest.chars() {\n            match conversions::to_upper(c) {\n                [a, '\\0', _] => s.push(a),\n                [a, b, '\\0'] => {\n                    s.push(a);\n                    s.push(b);\n                }\n                [a, b, c] => {\n                    s.push(a);\n                    s.push(b);\n                    s.push(c);\n                }\n            }\n        }\n        s\n    }",
  "mir": "fn str::<impl str>::to_uppercase(_1: &str) -> string::String {\n    let mut _0: string::String;\n    let mut _2: string::String;\n    let  _3: &str;\n    let mut _4: (string::String, &str);\n    let mut _5: for<'a> fn(&'a u8) -> u8;\n    let mut _6: core::str::Chars<'_>;\n    let mut _7: core::str::Chars<'_>;\n    let mut _8: core::str::Chars<'_>;\n    let  _9: ();\n    let mut _10: core::option::Option<char>;\n    let mut _11: &mut core::str::Chars<'_>;\n    let mut _12: isize;\n    let  _13: char;\n    let mut _14: [char; 3];\n    let  _15: char;\n    let mut _16: &mut string::String;\n    let  _17: char;\n    let  _18: char;\n    let  _19: ();\n    let mut _20: &mut string::String;\n    let  _21: ();\n    let mut _22: &mut string::String;\n    let  _23: char;\n    let  _24: char;\n    let  _25: char;\n    let  _26: ();\n    let mut _27: &mut string::String;\n    let  _28: ();\n    let mut _29: &mut string::String;\n    let  _30: ();\n    let mut _31: &mut string::String;\n    debug self => _1;\n    debug s => _2;\n    debug rest => _3;\n    debug iter => _8;\n    debug c => _13;\n    debug a => _15;\n    debug a => _17;\n    debug b => _18;\n    debug a => _23;\n    debug b => _24;\n    debug c => _25;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = core::num::<impl u8>::to_ascii_uppercase as for<'a> fn(&'a u8) -> u8;\n        _4 = str::convert_while_ascii(_1, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_2);\n        _2 = move (_4.0: string::String);\n        _3 = (_4.1: &str);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::str::<impl str>::chars(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = <core::str::Chars<'_> as core::iter::IntoIterator>::into_iter(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = move _6;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_10);\n        _11 = &mut _8;\n        _10 = <core::str::Chars<'_> as core::iter::Iterator>::next(_11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _13 = ((_10 as variant#1).0: char);\n        StorageLive(_14);\n        _14 = core::unicode::conversions::to_upper(_13) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageDead(_6);\n        _0 = move _2;\n        StorageDead(_2);\n        return;\n    }\n    bb9: {\n        switchInt(_14[1 of 3]) -> [0: bb13, otherwise: bb10];\n    }\n    bb10: {\n        switchInt(_14[2 of 3]) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        _23 = _14[0 of 3];\n        _24 = _14[1 of 3];\n        _25 = _14[2 of 3];\n        StorageLive(_27);\n        _27 = &mut _2;\n        _26 = string::String::push(move _27, _23) -> [return: bb17, unwind unreachable];\n    }\n    bb12: {\n        _17 = _14[0 of 3];\n        _18 = _14[1 of 3];\n        StorageLive(_20);\n        _20 = &mut _2;\n        _19 = string::String::push(move _20, _17) -> [return: bb15, unwind unreachable];\n    }\n    bb13: {\n        _15 = _14[0 of 3];\n        StorageLive(_16);\n        _16 = &mut _2;\n        _9 = string::String::push(move _16, _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_16);\n        goto -> bb20;\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = &mut _2;\n        _21 = string::String::push(move _22, _18) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        goto -> bb20;\n    }\n    bb17: {\n        StorageDead(_27);\n        StorageLive(_29);\n        _29 = &mut _2;\n        _28 = string::String::push(move _29, _24) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_29);\n        StorageLive(_31);\n        _31 = &mut _2;\n        _30 = string::String::push(move _31, _25) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_31);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_14);\n        StorageDead(_10);\n        goto -> bb4;\n    }\n}\n",
  "doc": " Returns the uppercase equivalent of this string slice, as a new [`String`].\n\n 'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n `Uppercase`.\n\n Since some characters can expand into multiple characters when changing\n the case, this function returns a [`String`] instead of modifying the\n parameter in-place.\n\n # Examples\n\n Basic usage:\n\n ```\n let s = \"hello\";\n\n assert_eq!(\"HELLO\", s.to_uppercase());\n ```\n\n Scripts without case are not changed:\n\n ```\n let new_year = \"农历新年\";\n\n assert_eq!(new_year, new_year.to_uppercase());\n ```\n\n One character can become multiple:\n ```\n let s = \"tschüß\";\n\n assert_eq!(\"TSCHÜSS\", s.to_uppercase());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}