{
  "name": "<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "core::mem::needs_drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if dropping values of type `T` matters.\n\n This is purely an optimization hint, and may be implemented conservatively:\n it may return `true` for types that don't actually need to be dropped.\n As such always returning `true` would be a valid implementation of\n this function. However if this function actually returns `false`, then you\n can be certain dropping `T` has no side effect.\n\n Low level implementations of things like collections, which need to manually\n drop their data, should use this function to avoid unnecessarily\n trying to drop all their contents when they are destroyed. This might not\n make a difference in release builds (where a loop that has no side-effects\n is easily detected and eliminated), but is often a big win for debug builds.\n\n Note that [`drop_in_place`] already performs this check, so if your workload\n can be reduced to some small number of [`drop_in_place`] calls, using this is\n unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n will do a single needs_drop check for all the values.\n\n Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n values one at a time and should use this API.\n\n [`drop_in_place`]: crate::ptr::drop_in_place\n [`HashMap`]: ../../std/collections/struct.HashMap.html\n\n # Examples\n\n Here's an example of how a collection might make use of `needs_drop`:\n\n ```\n use std::{mem, ptr};\n\n pub struct MyCollection<T> {\n #   data: [T; 1],\n     /* ... */\n }\n # impl<T> MyCollection<T> {\n #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n #   fn free_buffer(&mut self) {}\n # }\n\n impl<T> Drop for MyCollection<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // drop the data\n             if mem::needs_drop::<T>() {\n                 for x in self.iter_mut() {\n                     ptr::drop_in_place(x);\n                 }\n             }\n             self.free_buffer();\n         }\n     }\n }\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::drain::Drain::<'a, T, A>::as_slices": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::drain::Drain": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut [T]>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of a raw slice.\n\n The returned value is the number of **elements**, not the number of bytes.\n\n This function is safe, even when the raw slice cannot be cast to a slice\n reference because the pointer is null or unaligned.\n\n # Examples\n\n ```rust\n use std::ptr;\n\n let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n assert_eq!(slice.len(), 3);\n ```\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "<collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6314, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 6288, kind: RigidTy(Adt(AdtDef(DefId { id: 4595, name: \"collections::vec_deque::drain::Drain\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 110, kind: Param(ParamTy { index: 1, name: \"T\" }) }), Type(Ty { id: 881, kind: Param(ParamTy { index: 2, name: \"A\" }) })]))) }, Mut)) })])"
    ],
    "collections::vec_deque::drain::Drain": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ]
  },
  "path": 1325,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/drain.rs:94:5: 232:6",
  "src": "fn drop(&mut self) {\n        struct DropGuard<'r, 'a, T, A: Allocator>(&'r mut Drain<'a, T, A>);\n\n        let guard = DropGuard(self);\n\n        if mem::needs_drop::<T>() && guard.0.remaining != 0 {\n            unsafe {\n                // SAFETY: We just checked that `self.remaining != 0`.\n                let (front, back) = guard.0.as_slices();\n                // since idx is a logical index, we don't need to worry about wrapping.\n                guard.0.idx += front.len();\n                guard.0.remaining -= front.len();\n                ptr::drop_in_place(front);\n                guard.0.remaining = 0;\n                ptr::drop_in_place(back);\n            }\n        }\n\n        // Dropping `guard` handles moving the remaining elements into place.\n        impl<'r, 'a, T, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {\n            #[inline]\n            fn drop(&mut self) {\n                if mem::needs_drop::<T>() && self.0.remaining != 0 {\n                    unsafe {\n                        // SAFETY: We just checked that `self.remaining != 0`.\n                        let (front, back) = self.0.as_slices();\n                        ptr::drop_in_place(front);\n                        ptr::drop_in_place(back);\n                    }\n                }\n\n                let source_deque = unsafe { self.0.deque.as_mut() };\n\n                let drain_len = self.0.drain_len;\n                let new_len = self.0.new_len;\n\n                if T::IS_ZST {\n                    // no need to copy around any memory if T is a ZST\n                    source_deque.len = new_len;\n                    return;\n                }\n\n                let head_len = source_deque.len; // #elements in front of the drain\n                let tail_len = new_len - head_len; // #elements behind the drain\n\n                // Next, we will fill the hole left by the drain with as few writes as possible.\n                // The code below handles the following control flow and reduces the amount of\n                // branches under the assumption that `head_len == 0 || tail_len == 0`, i.e.\n                // draining at the front or at the back of the dequeue is especially common.\n                //\n                // H = \"head index\" = `deque.head`\n                // h = elements in front of the drain\n                // d = elements in the drain\n                // t = elements behind the drain\n                //\n                // Note that the buffer may wrap at any point and the wrapping is handled by\n                // `wrap_copy` and `to_physical_idx`.\n                //\n                // Case 1: if `head_len == 0 && tail_len == 0`\n                // Everything was drained, reset the head index back to 0.\n                //             H\n                // [ . . . . . d d d d . . . . . ]\n                //   H\n                // [ . . . . . . . . . . . . . . ]\n                //\n                // Case 2: else if `tail_len == 0`\n                // Don't move data or the head index.\n                //         H\n                // [ . . . h h h h d d d d . . . ]\n                //         H\n                // [ . . . h h h h . . . . . . . ]\n                //\n                // Case 3: else if `head_len == 0`\n                // Don't move data, but move the head index.\n                //         H\n                // [ . . . d d d d t t t t . . . ]\n                //                 H\n                // [ . . . . . . . t t t t . . . ]\n                //\n                // Case 4: else if `tail_len <= head_len`\n                // Move data, but not the head index.\n                //       H\n                // [ . . h h h h d d d d t t . . ]\n                //       H\n                // [ . . h h h h t t . . . . . . ]\n                //\n                // Case 5: else\n                // Move data and the head index.\n                //       H\n                // [ . . h h d d d d t t t t . . ]\n                //               H\n                // [ . . . . . . h h t t t t . . ]\n\n                // When draining at the front (`.drain(..n)`) or at the back (`.drain(n..)`),\n                // we don't need to copy any data. The number of elements copied would be 0.\n                if head_len != 0 && tail_len != 0 {\n                    join_head_and_tail_wrapping(source_deque, drain_len, head_len, tail_len);\n                    // Marking this function as cold helps LLVM to eliminate it entirely if\n                    // this branch is never taken.\n                    // We use `#[cold]` instead of `#[inline(never)]`, because inlining this\n                    // function into the general case (`.drain(n..m)`) is fine.\n                    // See `tests/codegen-llvm/vecdeque-drain.rs` for a test.\n                    #[cold]\n                    fn join_head_and_tail_wrapping<T, A: Allocator>(\n                        source_deque: &mut VecDeque<T, A>,\n                        drain_len: usize,\n                        head_len: usize,\n                        tail_len: usize,\n                    ) {\n                        // Pick whether to move the head or the tail here.\n                        let (src, dst, len);\n                        if head_len < tail_len {\n                            src = source_deque.head;\n                            dst = source_deque.to_physical_idx(drain_len);\n                            len = head_len;\n                        } else {\n                            src = source_deque.to_physical_idx(head_len + drain_len);\n                            dst = source_deque.to_physical_idx(head_len);\n                            len = tail_len;\n                        };\n\n                        unsafe {\n                            source_deque.wrap_copy(src, dst, len);\n                        }\n                    }\n                }\n\n                if new_len == 0 {\n                    // Special case: If the entire dequeue was drained, reset the head back to 0,\n                    // like `.clear()` does.\n                    source_deque.head = 0;\n                } else if head_len < tail_len {\n                    // If we moved the head above, then we need to adjust the head index here.\n                    source_deque.head = source_deque.to_physical_idx(drain_len);\n                }\n                source_deque.len = new_len;\n            }\n        }\n    }",
  "mir": "fn <collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop(_1: &mut collections::vec_deque::drain::Drain<'_, T, A>) -> () {\n    let mut _0: ();\n    let  _2: <collections::vec_deque::drain::Drain<'_, T, A> as core::ops::Drop>::drop::DropGuard<'_, '_, T, A>;\n    let mut _3: bool;\n    let mut _4: usize;\n    let  _5: *mut [T];\n    let  _6: *mut [T];\n    let mut _7: (*mut [T], *mut [T]);\n    let mut _8: &collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _9: usize;\n    let mut _10: (usize, bool);\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let  _13: ();\n    let  _14: ();\n    let mut _15: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _16: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _17: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _18: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _19: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _20: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _21: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _22: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    let mut _23: &mut collections::vec_deque::drain::Drain<'_, T, A>;\n    debug self => _1;\n    debug guard => _2;\n    debug front => _5;\n    debug back => _6;\n    bb0: {\n        StorageLive(_2);\n        _2 = DropGuard(_1);\n        StorageLive(_3);\n        _3 = core::mem::needs_drop::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb12, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_4);\n        _15 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _4 = ((*_15).4: usize);\n        switchInt(move _4) -> [0: bb11, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _16 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _8 = &(*_16);\n        _7 = collections::vec_deque::drain::Drain::<'_, T, A>::as_slices(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _5 = (_7.0: *mut [T]);\n        _6 = (_7.1: *mut [T]);\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = core::ptr::mut_ptr::<impl *mut [T]>::len(_5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _17 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _10 = CheckedAdd(((*_17).2: usize), _9);\n        _18 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_18).2: usize), move _9) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _19 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        ((*_19).2: usize) = move (_10.0: usize);\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = core::ptr::mut_ptr::<impl *mut [T]>::len(_5) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _20 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        _12 = CheckedSub(((*_20).4: usize), _11);\n        _21 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_21).4: usize), move _11) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _22 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        ((*_22).4: usize) = move (_12.0: usize);\n        StorageDead(_11);\n        _13 = core::ptr::drop_in_place::<[T]>(_5) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _23 = (_2.0: &mut collections::vec_deque::drain::Drain<'_, T, A>);\n        ((*_23).4: usize) = 0_usize;\n        _14 = core::ptr::drop_in_place::<[T]>(_6) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_4);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}