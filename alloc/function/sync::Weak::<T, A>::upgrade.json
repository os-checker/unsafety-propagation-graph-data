{
  "name": "sync::Weak::<T, A>::upgrade",
  "safe": true,
  "callees": {
    "sync::Weak::<T, A>::inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `None` when the pointer is dangling and there is no allocated `ArcInner`,\n (i.e., when this `Weak` was created by `Weak::new`).\n",
      "adt": {
        "sync::Weak": "ImmutableAsArgument",
        "core::option::Option": "Constructor",
        "sync::WeakInner": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicUsize::fetch_update": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fetches the value, and applies a function to it that returns an optional\n new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n `Err(previous_value)`.\n\n Note: This may call the function multiple times if the value has been changed from other threads in\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n only once to the stored value.\n\n `fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n The first describes the required ordering for when the operation finally succeeds while the second\n describes the required ordering for loads. These correspond to the success and failure orderings of\n respectively.\n\n Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Considerations\n\n This method is not magic; it is not provided by the hardware, and does not act like a\n critical section or mutex.\n\n It is implemented on top of an atomic [compare-and-swap operation], and thus is subject to\n the usual drawbacks of CAS operations. In particular, be careful of the [ABA problem]\n if this atomic integer is an index or more generally if knowledge of only the *bitwise value*\n of the atomic is not in and of itself sufficient to ensure any required preconditions.\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n\n # Examples\n\n ```rust\n\n assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n assert_eq!(x.load(Ordering::SeqCst), 9);\n ```\n",
      "adt": {}
    },
    "sync::Weak::<T, A>::upgrade::checked_increment": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::is_ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Ok`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_ok(), true);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_ok(), false);\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "sync::Arc::<T, A>::from_inner_in": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::Arc": "Constructor"
      }
    }
  },
  "adts": {
    "sync::Weak": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 9740, kind: RigidTy(Adt(AdtDef(DefId { id: 5759, name: \"sync::WeakInner\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])"
    ],
    "sync::WeakInner": [
      "Plain",
      "Unknown([Field(1, Ty { id: 9469, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 9365, kind: RigidTy(Adt(AdtDef(DefId { id: 5675, name: \"core::sync::atomic::AtomicUsize\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Ref"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "sync::Arc": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "alloc::sync::Weak::<T, A>::upgrade"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/sync.rs:3250:5: 3279:6",
  "src": "pub fn upgrade(&self) -> Option<Arc<T, A>>\n    where\n        A: Clone,\n    {\n        #[inline]\n        fn checked_increment(n: usize) -> Option<usize> {\n            // Any write of 0 we can observe leaves the field in permanently zero state.\n            if n == 0 {\n                return None;\n            }\n            // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n            assert!(n <= MAX_REFCOUNT, \"{}\", INTERNAL_OVERFLOW_ERROR);\n            Some(n + 1)\n        }\n\n        // We use a CAS loop to increment the strong count instead of a\n        // fetch_add as this function should never take the reference count\n        // from zero to one.\n        //\n        // Relaxed is fine for the failure case because we don't have any expectations about the new state.\n        // Acquire is necessary for the success case to synchronise with `Arc::new_cyclic`, when the inner\n        // value can be initialized after `Weak` references have already been created. In that case, we\n        // expect to observe the fully initialized value.\n        if self.inner()?.strong.fetch_update(Acquire, Relaxed, checked_increment).is_ok() {\n            // SAFETY: pointer is not null, verified in checked_increment\n            unsafe { Some(Arc::from_inner_in(self.ptr, self.alloc.clone())) }\n        } else {\n            None\n        }\n    }",
  "mir": "fn sync::Weak::<T, A>::upgrade(_1: &sync::Weak<T, A>) -> core::option::Option<sync::Arc<T, A>> {\n    let mut _0: core::option::Option<sync::Arc<T, A>>;\n    let mut _2: bool;\n    let mut _3: &core::result::Result<usize, usize>;\n    let  _4: core::result::Result<usize, usize>;\n    let mut _5: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, sync::WeakInner<'_>>;\n    let mut _6: core::option::Option<sync::WeakInner<'_>>;\n    let mut _7: isize;\n    let  _8: sync::WeakInner<'_>;\n    let mut _9: core::sync::atomic::Ordering;\n    let mut _10: core::sync::atomic::Ordering;\n    let mut _11: sync::Arc<T, A>;\n    let mut _12: core::ptr::NonNull<sync::ArcInner<T>>;\n    let mut _13: A;\n    let mut _14: &A;\n    let mut _15: &core::sync::atomic::AtomicUsize;\n    debug self => _1;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _8;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = sync::Weak::<T, A>::inner(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = <core::option::Option<sync::WeakInner<'_>> as core::ops::Try>::branch(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _8 = move ((_5 as variant#0).0: sync::WeakInner<'_>);\n        _15 = (_8.1: &core::sync::atomic::AtomicUsize);\n        StorageLive(_9);\n        _9 = core::sync::atomic::Ordering::Acquire;\n        StorageLive(_10);\n        _10 = core::sync::atomic::Ordering::Relaxed;\n        _4 = core::sync::atomic::AtomicUsize::fetch_update::<fn(usize) -> core::option::Option<usize> {sync::Weak::<T, A>::upgrade::checked_increment}>(_15, move _9, move _10, sync::Weak::<T, A>::upgrade::checked_increment) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::option::Option<sync::Arc<T, A>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb14;\n    }\n    bb7: {\n        _3 = &_4;\n        StorageDead(_10);\n        StorageDead(_9);\n        _2 = core::result::Result::<usize, usize>::is_ok(move _3) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _2) -> [0: bb12, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = ((*_1).0: core::ptr::NonNull<sync::ArcInner<T>>);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &((*_1).1: A);\n        _13 = <A as core::clone::Clone>::clone(move _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        _11 = sync::Arc::<T, A>::from_inner_in(move _12, move _13) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _0 = core::option::Option::Some(move _11);\n        StorageDead(_11);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_2);\n        goto -> bb14;\n    }\n    bb14: {\n        return;\n    }\n}\n",
  "doc": " Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n dropping of the inner value if successful.\n\n Returns [`None`] if the inner value has since been dropped.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n\n let weak_five = Arc::downgrade(&five);\n\n let strong_five: Option<Arc<_>> = weak_five.upgrade();\n assert!(strong_five.is_some());\n\n // Destroy all strong pointers.\n drop(strong_five);\n drop(five);\n\n assert!(weak_five.upgrade().is_none());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}