{
  "name": "collections::vec_deque::VecDeque::<T, A>::shrink_to",
  "safe": true,
  "callees": {
    "core::cmp::Ord::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the maximum of two values.\n\n Returns the second argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.max(2), 2);\n assert_eq!(2.max(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").max(Equal(\"other\")).0, \"other\");\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements the deque can hold without\n reallocating.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let buf: VecDeque<i32> = VecDeque::with_capacity(10);\n assert!(buf.capacity() >= 10);\n ```\n",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "core::ops::RangeInclusive::<Idx>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new inclusive range. Equivalent to writing `start..=end`.\n\n # Examples\n\n ```\n use std::ops::RangeInclusive;\n\n assert_eq!(3..=5, RangeInclusive::new(3, 5));\n ```\n",
      "adt": {}
    },
    "core::ops::RangeInclusive::<Idx>::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `item` is contained in the range.\n\n # Examples\n\n ```\n assert!(!(3..=5).contains(&2));\n assert!( (3..=5).contains(&3));\n assert!( (3..=5).contains(&4));\n assert!( (3..=5).contains(&5));\n assert!(!(3..=5).contains(&6));\n\n assert!( (3..=3).contains(&3));\n assert!(!(3..=2).contains(&3));\n\n assert!( (0.0..=1.0).contains(&1.0));\n assert!(!(0.0..=1.0).contains(&f32::NAN));\n assert!(!(0.0..=f32::NAN).contains(&0.0));\n assert!(!(f32::NAN..=1.0).contains(&1.0));\n ```\n\n This method always returns `false` after iteration has finished:\n\n ```\n let mut r = 3..=5;\n assert!(r.contains(&3) && r.contains(&5));\n for _ in r.by_ref() {}\n // Precise field values are unspecified here\n assert!(!r.contains(&3) && !r.contains(&5));\n ```\n",
      "adt": {}
    },
    "collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies a contiguous block of memory len long from src to dst\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::is_contiguous": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "collections::vec_deque::VecDeque": "ImmutableAsArgument"
      }
    },
    "collections::vec_deque::VecDeque::<T, A>::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies a contiguous block of memory len long from src to dst\n",
      "adt": {
        "collections::vec_deque::VecDeque": "MutableAsArgument"
      }
    },
    "raw_vec::RawVec::<T, A>::shrink_to_fit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shrinks the buffer down to the specified capacity. If the given amount\n is 0, actually completely deallocates.\n\n # Panics\n\n Panics if the given amount is *larger* than the current capacity.\n\n # Aborts\n\n Aborts on OOM.\n",
      "adt": {
        "raw_vec::RawVec": "MutableAsArgument"
      }
    },
    "core::mem::forget": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes ownership and \"forgets\" about the value **without running its destructor**.\n\n Any resources the value manages, such as heap memory or a file handle, will linger\n forever in an unreachable state. However, it does not guarantee that pointers\n to this memory will remain valid.\n\n * If you want to leak memory, see [`Box::leak`].\n * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n * If you want to dispose of a value properly, running its destructor, see\n   [`mem::drop`].\n\n # Safety\n\n `forget` is not marked as `unsafe`, because Rust's safety guarantees\n do not include a guarantee that destructors will always run. For example,\n a program can create a reference cycle using [`Rc`][rc], or call\n [`process::exit`][exit] to exit without running destructors. Thus, allowing\n `mem::forget` from safe code does not fundamentally change Rust's safety\n guarantees.\n\n That said, leaking resources such as memory or I/O objects is usually undesirable.\n The need comes up in some specialized use cases for FFI or unsafe code, but even\n then, [`ManuallyDrop`] is typically preferred.\n\n Because forgetting a value is allowed, any `unsafe` code you write must\n allow for this possibility. You cannot return a value and expect that the\n caller will necessarily run the value's destructor.\n\n [rc]: ../../std/rc/struct.Rc.html\n [exit]: ../../std/process/fn.exit.html\n\n # Examples\n\n The canonical safe use of `mem::forget` is to circumvent a value's destructor\n implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n the space taken by the variable but never close the underlying system resource:\n\n ```no_run\n use std::mem;\n use std::fs::File;\n\n let file = File::open(\"foo.txt\").unwrap();\n mem::forget(file);\n ```\n\n This is useful when the ownership of the underlying resource was previously\n transferred to code outside of Rust, for example by transmitting the raw\n file descriptor to C code.\n\n # Relationship with `ManuallyDrop`\n\n While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n\n ```\n use std::mem;\n\n let mut v = vec![65, 122];\n // Build a `String` using the contents of `v`\n let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n // leak `v` because its memory is now managed by `s`\n mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n There are two issues with the above example:\n\n * If more code were added between the construction of `String` and the invocation of\n   `mem::forget()`, a panic within it would cause a double free because the same memory\n   is handled by both `v` and `s`.\n * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n   inspect it), some types have strict requirements on their values that\n   make them invalid when dangling or no longer owned. Using invalid values in any\n   way, including passing them to or returning them from functions, constitutes\n   undefined behavior and may break the assumptions made by the compiler.\n\n Switching to `ManuallyDrop` avoids both issues:\n\n ```\n use std::mem::ManuallyDrop;\n\n let v = vec![65, 122];\n // Before we disassemble `v` into its raw parts, make sure it\n // does not get dropped!\n let mut v = ManuallyDrop::new(v);\n // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n // Finally, build a `String`.\n let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n argument, forcing us to call it only after extracting anything we need from `v`. Even\n if a panic were introduced between construction of `ManuallyDrop` and building the\n string (which cannot happen in the code as shown), it would result in a leak and not a\n double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n erring on the side of (double-)dropping.\n\n Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n ownership to `s` â€” the final step of interacting with `v` to dispose of it without\n running its destructor is entirely avoided.\n\n [`Box`]: ../../std/boxed/struct.Box.html\n [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n [`mem::drop`]: drop\n [ub]: ../../reference/behavior-considered-undefined.html\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "collections::vec_deque::VecDeque": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::ops::RangeInclusive": [
      "Plain",
      "Ref"
    ],
    "collections::vec_deque::VecDeque<T, A>::shrink_to::Guard": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6349, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 6351, kind: RigidTy(Adt(AdtDef(DefId { id: 4596, name: \"collections::vec_deque::VecDeque\" }), GenericArgs([Type(Ty { id: 10, kind: Param(ParamTy { index: 0, name: \"T\" }) }), Type(Ty { id: 21, kind: Param(ParamTy { index: 1, name: \"A\" }) })]))) }, Mut)) })])"
    ],
    "raw_vec::RawVec": [
      "MutRef"
    ]
  },
  "path": 1522,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/vec_deque/mod.rs:1197:5: 1296:6",
  "src": "pub fn shrink_to(&mut self, min_capacity: usize) {\n        let target_cap = min_capacity.max(self.len);\n\n        // never shrink ZSTs\n        if T::IS_ZST || self.capacity() <= target_cap {\n            return;\n        }\n\n        // There are three cases of interest:\n        //   All elements are out of desired bounds\n        //   Elements are contiguous, and tail is out of desired bounds\n        //   Elements are discontiguous\n        //\n        // At all other times, element positions are unaffected.\n\n        // `head` and `len` are at most `isize::MAX` and `target_cap < self.capacity()`, so nothing can\n        // overflow.\n        let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n        // Used in the drop guard below.\n        let old_head = self.head;\n\n        if self.len == 0 {\n            self.head = 0;\n        } else if self.head >= target_cap && tail_outside {\n            // Head and tail are both out of bounds, so copy all of them to the front.\n            //\n            //  H := head\n            //  L := last element\n            //                    H           L\n            //   [. . . . . . . . o o o o o o o . ]\n            //    H           L\n            //   [o o o o o o o . ]\n            unsafe {\n                // nonoverlapping because `self.head >= target_cap >= self.len`.\n                self.copy_nonoverlapping(self.head, 0, self.len);\n            }\n            self.head = 0;\n        } else if self.head < target_cap && tail_outside {\n            // Head is in bounds, tail is out of bounds.\n            // Copy the overflowing part to the beginning of the\n            // buffer. This won't overlap because `target_cap >= self.len`.\n            //\n            //  H := head\n            //  L := last element\n            //          H           L\n            //   [. . . o o o o o o o . . . . . . ]\n            //      L   H\n            //   [o o . o o o o o ]\n            let len = self.head + self.len - target_cap;\n            unsafe {\n                self.copy_nonoverlapping(target_cap, 0, len);\n            }\n        } else if !self.is_contiguous() {\n            // The head slice is at least partially out of bounds, tail is in bounds.\n            // Copy the head backwards so it lines up with the target capacity.\n            // This won't overlap because `target_cap >= self.len`.\n            //\n            //  H := head\n            //  L := last element\n            //            L                   H\n            //   [o o o o o . . . . . . . . . o o ]\n            //            L   H\n            //   [o o o o o . o o ]\n            let head_len = self.capacity() - self.head;\n            let new_head = target_cap - head_len;\n            unsafe {\n                // can't use `copy_nonoverlapping()` here because the new and old\n                // regions for the head might overlap.\n                self.copy(self.head, new_head, head_len);\n            }\n            self.head = new_head;\n        }\n\n        struct Guard<'a, T, A: Allocator> {\n            deque: &'a mut VecDeque<T, A>,\n            old_head: usize,\n            target_cap: usize,\n        }\n\n        impl<T, A: Allocator> Drop for Guard<'_, T, A> {\n            #[cold]\n            fn drop(&mut self) {\n                unsafe {\n                    // SAFETY: This is only called if `buf.shrink_to_fit` unwinds,\n                    // which is the only time it's safe to call `abort_shrink`.\n                    self.deque.abort_shrink(self.old_head, self.target_cap)\n                }\n            }\n        }\n\n        let guard = Guard { deque: self, old_head, target_cap };\n\n        guard.deque.buf.shrink_to_fit(target_cap);\n\n        // Don't drop the guard if we didn't unwind.\n        mem::forget(guard);\n\n        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n        debug_assert!(self.len <= self.capacity());\n    }",
  "mir": "fn collections::vec_deque::VecDeque::<T, A>::shrink_to(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: &collections::vec_deque::VecDeque<T, A>;\n    let  _8: bool;\n    let mut _9: &core::ops::RangeInclusive<usize>;\n    let  _10: core::ops::RangeInclusive<usize>;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let mut _13: usize;\n    let mut _14: &collections::vec_deque::VecDeque<T, A>;\n    let  _15: &usize;\n    let  _16: usize;\n    let mut _17: usize;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: usize;\n    let mut _21: usize;\n    let mut _22: bool;\n    let mut _23: usize;\n    let  _24: ();\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: bool;\n    let mut _28: usize;\n    let  _29: usize;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: usize;\n    let mut _33: (usize, bool);\n    let mut _34: (usize, bool);\n    let  _35: ();\n    let mut _36: bool;\n    let mut _37: &collections::vec_deque::VecDeque<T, A>;\n    let  _38: usize;\n    let mut _39: usize;\n    let mut _40: &collections::vec_deque::VecDeque<T, A>;\n    let mut _41: usize;\n    let mut _42: (usize, bool);\n    let  _43: usize;\n    let mut _44: (usize, bool);\n    let  _45: ();\n    let mut _46: usize;\n    let  _47: collections::vec_deque::VecDeque<T, A>::shrink_to::Guard<'_, T, A>;\n    let  _48: ();\n    let mut _49: &mut raw_vec::RawVec<T, A>;\n    let  _50: ();\n    let mut _51: bool;\n    let mut _52: usize;\n    let mut _53: usize;\n    let mut _54: &collections::vec_deque::VecDeque<T, A>;\n    let mut _55: usize;\n    let mut _56: &collections::vec_deque::VecDeque<T, A>;\n    let mut _57: !;\n    let mut _58: bool;\n    let mut _59: usize;\n    let mut _60: usize;\n    let mut _61: &collections::vec_deque::VecDeque<T, A>;\n    let mut _62: !;\n    let mut _63: &mut collections::vec_deque::VecDeque<T, A>;\n    debug self => _1;\n    debug min_capacity => _2;\n    debug target_cap => _3;\n    debug tail_outside => _8;\n    debug old_head => _20;\n    debug len => _29;\n    debug head_len => _38;\n    debug new_head => _43;\n    debug guard => _47;\n    bb0: {\n        StorageLive(_4);\n        _4 = ((*_1).1: usize);\n        _3 = <usize as core::cmp::Ord>::max(_2, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb2, otherwise: bb5];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = collections::vec_deque::VecDeque::<T, A>::capacity(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _5 = Le(move _6, _3);\n        switchInt(move _5) -> [0: bb6, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_6);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_5);\n        goto -> bb49;\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _12 = CheckedAdd(_3, 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = move (_12.0: usize);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_1);\n        _13 = collections::vec_deque::VecDeque::<T, A>::capacity(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        _10 = core::ops::RangeInclusive::<usize>::new(move _11, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _9 = &_10;\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = ((*_1).0: usize);\n        StorageLive(_18);\n        _18 = ((*_1).1: usize);\n        _19 = CheckedAdd(_17, _18);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _17, move _18) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _16 = move (_19.0: usize);\n        StorageDead(_18);\n        StorageDead(_17);\n        _15 = &_16;\n        _8 = core::ops::RangeInclusive::<usize>::contains::<usize>(move _9, _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_9);\n        StorageDead(_16);\n        StorageDead(_10);\n        _20 = ((*_1).0: usize);\n        StorageLive(_21);\n        _21 = ((*_1).1: usize);\n        switchInt(move _21) -> [0: bb12, otherwise: bb13];\n    }\n    bb12: {\n        StorageDead(_21);\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb36;\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = ((*_1).0: usize);\n        _22 = Ge(move _23, _3);\n        switchInt(move _22) -> [0: bb17, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_23);\n        switchInt(_8) -> [0: bb18, otherwise: bb15];\n    }\n    bb15: {\n        StorageLive(_25);\n        _25 = ((*_1).0: usize);\n        StorageLive(_26);\n        _26 = ((*_1).1: usize);\n        _24 = collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1, move _25, 0_usize, move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        StorageDead(_25);\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb35;\n    }\n    bb17: {\n        StorageDead(_23);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = ((*_1).0: usize);\n        _27 = Lt(move _28, _3);\n        switchInt(move _27) -> [0: bb24, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_28);\n        switchInt(_8) -> [0: bb25, otherwise: bb20];\n    }\n    bb20: {\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = ((*_1).0: usize);\n        StorageLive(_32);\n        _32 = ((*_1).1: usize);\n        _33 = CheckedAdd(_31, _32);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _31, move _32) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _30 = move (_33.0: usize);\n        StorageDead(_32);\n        StorageDead(_31);\n        _34 = CheckedSub(_30, _3);\n        assert(!move (_34.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _30, _3) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _29 = move (_34.0: usize);\n        StorageDead(_30);\n        _35 = collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1, _3, 0_usize, _29) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        goto -> bb34;\n    }\n    bb24: {\n        StorageDead(_28);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &(*_1);\n        _36 = collections::vec_deque::VecDeque::<T, A>::is_contiguous(move _37) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _36) -> [0: bb28, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_37);\n        goto -> bb33;\n    }\n    bb28: {\n        StorageDead(_37);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &(*_1);\n        _39 = collections::vec_deque::VecDeque::<T, A>::capacity(move _40) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_40);\n        StorageLive(_41);\n        _41 = ((*_1).0: usize);\n        _42 = CheckedSub(_39, _41);\n        assert(!move (_42.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _39, move _41) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _38 = move (_42.0: usize);\n        StorageDead(_41);\n        StorageDead(_39);\n        _44 = CheckedSub(_3, _38);\n        assert(!move (_44.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _38) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _43 = move (_44.0: usize);\n        StorageLive(_46);\n        _46 = ((*_1).0: usize);\n        _45 = collections::vec_deque::VecDeque::<T, A>::copy(_1, move _46, _43, _38) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_46);\n        ((*_1).0: usize) = _43;\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_36);\n        goto -> bb34;\n    }\n    bb34: {\n        StorageDead(_27);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_22);\n        goto -> bb36;\n    }\n    bb36: {\n        _47 = Guard(_1, _20, _3);\n        StorageLive(_49);\n        _63 = (_47.0: &mut collections::vec_deque::VecDeque<T, A>);\n        _49 = &mut ((*_63).2: raw_vec::RawVec<T, A>);\n        _48 = raw_vec::RawVec::<T, A>::shrink_to_fit(move _49, _3) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_49);\n        _50 = core::mem::forget::<collections::vec_deque::VecDeque<T, A>::shrink_to::Guard<'_, T, A>>(_47) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = ((*_1).0: usize);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &(*_1);\n        _53 = collections::vec_deque::VecDeque::<T, A>::capacity(move _54) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_54);\n        _51 = Lt(move _52, move _53);\n        switchInt(move _51) -> [0: bb41, otherwise: bb40];\n    }\n    bb40: {\n        StorageDead(_53);\n        StorageDead(_52);\n        goto -> bb45;\n    }\n    bb41: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = &(*_1);\n        _55 = collections::vec_deque::VecDeque::<T, A>::capacity(move _56) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_56);\n        switchInt(move _55) -> [0: bb43, otherwise: bb44];\n    }\n    bb43: {\n        StorageDead(_55);\n        goto -> bb45;\n    }\n    bb44: {\n        StorageDead(_55);\n        _57 = core::panicking::panic(\"assertion failed: self.head < self.capacity() || self.capacity() == 0\") -> unwind unreachable;\n    }\n    bb45: {\n        StorageDead(_51);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = ((*_1).1: usize);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &(*_1);\n        _60 = collections::vec_deque::VecDeque::<T, A>::capacity(move _61) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_61);\n        _58 = Le(move _59, move _60);\n        switchInt(move _58) -> [0: bb48, otherwise: bb47];\n    }\n    bb47: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_58);\n        goto -> bb49;\n    }\n    bb48: {\n        StorageDead(_60);\n        StorageDead(_59);\n        _62 = core::panicking::panic(\"assertion failed: self.len <= self.capacity()\") -> unwind unreachable;\n    }\n    bb49: {\n        return;\n    }\n}\n",
  "doc": " Shrinks the capacity of the deque with a lower bound.\n\n The capacity will remain at least as large as both the length\n and the supplied value.\n\n If the current capacity is less than the lower limit, this is a no-op.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::with_capacity(15);\n buf.extend(0..4);\n assert_eq!(buf.capacity(), 15);\n buf.shrink_to(6);\n assert!(buf.capacity() >= 6);\n buf.shrink_to(0);\n assert!(buf.capacity() >= 4);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}