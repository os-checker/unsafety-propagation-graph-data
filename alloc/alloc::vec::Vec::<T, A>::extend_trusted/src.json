{
  "name": "alloc::vec::Vec::<T, A>::extend_trusted",
  "span": "$library/alloc/src/vec/mod.rs:3847:5: 3847:76",
  "src": "fn extend_trusted(&mut self, iterator: impl iter::TrustedLen<Item = T>) {\n        let (low, high) = iterator.size_hint();\n        if let Some(additional) = high {\n            debug_assert_eq!(\n                low,\n                additional,\n                \"TrustedLen iterator's size hint is not exact: {:?}\",\n                (low, high)\n            );\n            self.reserve(additional);\n            unsafe {\n                let ptr = self.as_mut_ptr();\n                let mut local_len = SetLenOnDrop::new(&mut self.len);\n                iterator.for_each(move |element| {\n                    ptr::write(ptr.add(local_len.current_len()), element);\n                    // Since the loop executes user code which can panic we have to update\n                    // the length every step to correctly drop what we've written.\n                    // NB can't overflow since we would have had to alloc the address space\n                    local_len.increment_len(1);\n                });\n            }\n        } else {\n            // Per TrustedLen contract a `None` upper bound means that the iterator length\n            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n            // This avoids additional codegen for a fallback code path which would eventually\n            // panic anyway.\n            panic!(\"capacity overflow\");\n        }\n    }"
}