{
  "name": "alloc::str::join_generic_copy",
  "span": "$library/alloc/src/str.rs:130:1: 134:18",
  "src": "fn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\nwhere\n    T: Copy,\n    B: AsRef<[T]> + ?Sized,\n    S: Borrow<B>,\n{\n    let sep_len = sep.len();\n    let mut iter = slice.iter();\n\n    // the first slice is the only one without a separator preceding it\n    let first = match iter.next() {\n        Some(first) => first,\n        None => return vec![],\n    };\n\n    // compute the exact total length of the joined Vec\n    // if the `len` calculation overflows, we'll panic\n    // we would have run out of memory anyway and the rest of the function requires\n    // the entire Vec pre-allocated for safety\n    let reserved_len = sep_len\n        .checked_mul(iter.len())\n        .and_then(|n| {\n            slice.iter().map(|s| s.borrow().as_ref().len()).try_fold(n, usize::checked_add)\n        })\n        .expect(\"attempt to join into collection with len > usize::MAX\");\n\n    // prepare an uninitialized buffer\n    let mut result = Vec::with_capacity(reserved_len);\n    debug_assert!(result.capacity() >= reserved_len);\n\n    result.extend_from_slice(first.borrow().as_ref());\n\n    unsafe {\n        let pos = result.len();\n        let target = result.spare_capacity_mut().get_unchecked_mut(..reserved_len - pos);\n\n        // Convert the separator and slices to slices of MaybeUninit\n        // to simplify implementation in specialize_for_lengths\n        let sep_uninit = core::slice::from_raw_parts(sep.as_ptr().cast(), sep.len());\n        let iter_uninit = iter.map(|it| {\n            let it = it.borrow().as_ref();\n            core::slice::from_raw_parts(it.as_ptr().cast(), it.len())\n        });\n\n        // copy separator and slices over without bounds checks\n        // generate loops with hardcoded offsets for small separators\n        // massive improvements possible (~ x2)\n        let remain = specialize_for_lengths!(sep_uninit, target, iter_uninit; 0, 1, 2, 3, 4);\n\n        // A weird borrow implementation may return different\n        // slices for the length calculation and the actual copy.\n        // Make sure we don't expose uninitialized bytes to the caller.\n        let result_len = reserved_len - remain.len();\n        result.set_len(result_len);\n    }\n    result\n}"
}