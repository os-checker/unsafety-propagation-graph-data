{
  "name": "alloc::task::raw_waker",
  "span": "$library/alloc/src/task.rs:137:1: 137:73",
  "src": "fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n    // Increment the reference count of the arc to clone it.\n    //\n    // The #[inline(always)] is to ensure that raw_waker and clone_waker are\n    // always generated in the same code generation unit as one another, and\n    // therefore that the structurally identical const-promoted RawWakerVTable\n    // within both functions is deduplicated at LLVM IR code generation time.\n    // This allows optimizing Waker::will_wake to a single pointer comparison of\n    // the vtable pointers, rather than comparing all four function pointers\n    // within the vtables.\n    #[inline(always)]\n    unsafe fn clone_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) -> RawWaker {\n        unsafe { Arc::increment_strong_count(waker as *const W) };\n        RawWaker::new(\n            waker,\n            &RawWakerVTable::new(clone_waker::<W>, wake::<W>, wake_by_ref::<W>, drop_waker::<W>),\n        )\n    }\n\n    // Wake by value, moving the Arc into the Wake::wake function\n    unsafe fn wake<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n        let waker = unsafe { Arc::from_raw(waker as *const W) };\n        <W as Wake>::wake(waker);\n    }\n\n    // Wake by reference, wrap the waker in ManuallyDrop to avoid dropping it\n    unsafe fn wake_by_ref<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n        let waker = unsafe { ManuallyDrop::new(Arc::from_raw(waker as *const W)) };\n        <W as Wake>::wake_by_ref(&waker);\n    }\n\n    // Decrement the reference count of the Arc on drop\n    unsafe fn drop_waker<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n        unsafe { Arc::decrement_strong_count(waker as *const W) };\n    }\n\n    RawWaker::new(\n        Arc::into_raw(waker) as *const (),\n        &RawWakerVTable::new(clone_waker::<W>, wake::<W>, wake_by_ref::<W>, drop_waker::<W>),\n    )\n}"
}