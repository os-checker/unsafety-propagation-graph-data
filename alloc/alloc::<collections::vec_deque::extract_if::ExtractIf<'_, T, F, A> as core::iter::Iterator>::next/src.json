{
  "name": "alloc::<collections::vec_deque::extract_if::ExtractIf<'_, T, F, A> as core::iter::Iterator>::next",
  "span": "$library/alloc/src/collections/vec_deque/extract_if.rs:74:5: 74:36",
  "src": "fn next(&mut self) -> Option<T> {\n        while self.idx < self.end {\n            let i = self.idx;\n            // SAFETY:\n            //  We know that `i < self.end` from the if guard and that `self.end <= self.old_len` from\n            //  the validity of `Self`. Therefore `i` points to an element within `vec`.\n            //\n            //  Additionally, the i-th element is valid because each element is visited at most once\n            //  and it is the first time we access vec[i].\n            //\n            //  Note: we can't use `vec.get_mut(i).unwrap()` here since the precondition for that\n            //  function is that i < vec.len, but we've set vec's length to zero.\n            let idx = self.vec.to_physical_idx(i);\n            let cur = unsafe { &mut *self.vec.ptr().add(idx) };\n            let drained = (self.pred)(cur);\n            // Update the index *after* the predicate is called. If the index\n            // is updated prior and the predicate panics, the element at this\n            // index would be leaked.\n            self.idx += 1;\n            if drained {\n                self.del += 1;\n                // SAFETY: We never touch this element again after returning it.\n                return Some(unsafe { ptr::read(cur) });\n            } else if self.del > 0 {\n                let hole_slot = self.vec.to_physical_idx(i - self.del);\n                // SAFETY: `self.del` > 0, so the hole slot must not overlap with current element.\n                // We use copy for move, and never touch this element again.\n                unsafe { self.vec.wrap_copy(idx, hole_slot, 1) };\n            }\n        }\n        None\n    }"
}