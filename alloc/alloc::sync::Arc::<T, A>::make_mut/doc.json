{
  "name": "alloc::sync::Arc::<T, A>::make_mut",
  "span": "$library/alloc/src/sync.rs:2492:5: 2492:47",
  "doc": " Makes a mutable reference into the given `Arc`.\n\n If there are other `Arc` pointers to the same allocation, then `make_mut` will\n [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n referred to as clone-on-write.\n\n However, if there are no other `Arc` pointers to this allocation, but some [`Weak`]\n pointers, then the [`Weak`] pointers will be dissociated and the inner value will not\n be cloned.\n\n See also [`get_mut`], which will fail rather than cloning the inner value\n or dissociating [`Weak`] pointers.\n\n [`clone`]: Clone::clone\n [`get_mut`]: Arc::get_mut\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let mut data = Arc::new(5);\n\n *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n let mut other_data = Arc::clone(&data); // Won't clone inner data\n *Arc::make_mut(&mut data) += 1;         // Clones inner data\n *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n\n // Now `data` and `other_data` point to different allocations.\n assert_eq!(*data, 8);\n assert_eq!(*other_data, 12);\n ```\n\n [`Weak`] pointers will be dissociated:\n\n ```\n use std::sync::Arc;\n\n let mut data = Arc::new(75);\n let weak = Arc::downgrade(&data);\n\n assert!(75 == *data);\n assert!(75 == *weak.upgrade().unwrap());\n\n *Arc::make_mut(&mut data) += 1;\n\n assert!(76 == *data);\n assert!(weak.upgrade().is_none());\n ```\n"
}