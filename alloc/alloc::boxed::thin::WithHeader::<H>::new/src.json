{
  "name": "alloc::boxed::thin::WithHeader::<H>::new",
  "span": "$library/alloc/src/boxed/thin.rs:228:5: 228:52",
  "src": "fn new<T>(header: H, value: T) -> WithHeader<H> {\n        let value_layout = Layout::new::<T>();\n        let Ok((layout, value_offset)) = Self::alloc_layout(value_layout) else {\n            // We pass an empty layout here because we do not know which layout caused the\n            // arithmetic overflow in `Layout::extend` and `handle_alloc_error` takes `Layout` as\n            // its argument rather than `Result<Layout, LayoutError>`, also this function has been\n            // stable since 1.28 ._.\n            //\n            // On the other hand, look at this gorgeous turbofish!\n            alloc::handle_alloc_error(Layout::new::<()>());\n        };\n\n        unsafe {\n            // Note: It's UB to pass a layout with a zero size to `alloc::alloc`, so\n            // we use `layout.dangling()` for this case, which should have a valid\n            // alignment for both `T` and `H`.\n            let ptr = if layout.size() == 0 {\n                // Some paranoia checking, mostly so that the ThinBox tests are\n                // more able to catch issues.\n                debug_assert!(value_offset == 0 && T::IS_ZST && H::IS_ZST);\n                layout.dangling()\n            } else {\n                let ptr = alloc::alloc(layout);\n                if ptr.is_null() {\n                    alloc::handle_alloc_error(layout);\n                }\n                // Safety:\n                // - The size is at least `aligned_header_size`.\n                let ptr = ptr.add(value_offset) as *mut _;\n\n                NonNull::new_unchecked(ptr)\n            };\n\n            let result = WithHeader(ptr, PhantomData);\n            ptr::write(result.header(), header);\n            ptr::write(result.value().cast(), value);\n\n            result\n        }\n    }"
}