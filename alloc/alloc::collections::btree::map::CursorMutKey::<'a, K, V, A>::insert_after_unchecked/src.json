{
  "name": "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
  "span": "$library/alloc/src/collections/btree/map.rs:3279:5: 3279:70",
  "src": "pub unsafe fn insert_after_unchecked(&mut self, key: K, value: V) {\n        let edge = match self.current.take() {\n            None => {\n                // Tree is empty, allocate a new root.\n                // SAFETY: We have no other reference to the tree.\n                let root = unsafe { self.root.reborrow() };\n                debug_assert!(root.is_none());\n                let mut node = NodeRef::new_leaf(self.alloc.clone());\n                // SAFETY: We don't touch the root while the handle is alive.\n                let handle = unsafe { node.borrow_mut().push_with_handle(key, value) };\n                *root = Some(node.forget_type());\n                *self.length += 1;\n                self.current = Some(handle.left_edge());\n                return;\n            }\n            Some(current) => current,\n        };\n\n        let handle = edge.insert_recursing(key, value, self.alloc.clone(), |ins| {\n            drop(ins.left);\n            // SAFETY: The handle to the newly inserted value is always on a\n            // leaf node, so adding a new root node doesn't invalidate it.\n            let root = unsafe { self.root.reborrow().as_mut().unwrap() };\n            root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)\n        });\n        self.current = Some(handle.left_edge());\n        *self.length += 1;\n    }"
}