{
  "name": "alloc::collections::btree::set::BTreeSet::<T, A>::is_subset",
  "span": "$library/alloc/src/collections/btree/set.rs:682:5: 684:16",
  "src": "pub fn is_subset(&self, other: &BTreeSet<T, A>) -> bool\n    where\n        T: Ord,\n    {\n        // Same result as self.difference(other).next().is_none()\n        // but the code below is faster (hugely in some cases).\n        if self.len() > other.len() {\n            return false; // self has more elements than other\n        }\n        let (Some(self_min), Some(self_max)) = (self.first(), self.last()) else {\n            return true; // self is empty\n        };\n        let (Some(other_min), Some(other_max)) = (other.first(), other.last()) else {\n            return false; // other is empty\n        };\n        let mut self_iter = self.iter();\n        match self_min.cmp(other_min) {\n            Less => return false, // other does not contain self_min\n            Equal => {\n                self_iter.next(); // self_min is contained in other, so remove it from consideration\n                // other_min is now not in self_iter (used below)\n            }\n            Greater => {} // other_min is not in self_iter (used below)\n        };\n\n        match self_max.cmp(other_max) {\n            Greater => return false, // other does not contain self_max\n            Equal => {\n                self_iter.next_back(); // self_max is contained in other, so remove it from consideration\n                // other_max is now not in self_iter (used below)\n            }\n            Less => {} // other_max is not in self_iter (used below)\n        };\n        if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n            self_iter.all(|e| other.contains(e))\n        } else {\n            let mut other_iter = other.iter();\n            {\n                // remove other_min and other_max as they are not in self_iter (see above)\n                other_iter.next();\n                other_iter.next_back();\n            }\n            // custom `self_iter.all(|e| other.contains(e))`\n            self_iter.all(|self1| {\n                while let Some(other1) = other_iter.next() {\n                    match other1.cmp(self1) {\n                        // happens up to `ITER_PERFORMANCE_TIPPING_SIZE_DIFF * self.len() - 1` times\n                        Less => continue, // skip over elements that are smaller\n                        // happens `self.len()` times\n                        Equal => return true, // self1 is in other\n                        // happens only once\n                        Greater => return false, // self1 is not in other\n                    }\n                }\n                false\n            })\n        }\n    }"
}