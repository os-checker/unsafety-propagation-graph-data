{
  "name": "alloc::<I as vec::in_place_collect::SpecInPlaceCollect<T, I>>::collect_in_place",
  "span": "$library/alloc/src/vec/in_place_collect.rs:389:5: 389:83",
  "src": "unsafe fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n        let len = self.size();\n        let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n        for i in 0..len {\n            // Safety: InplaceIterable contract guarantees that for every element we read\n            // one slot in the underlying storage will have been freed up and we can immediately\n            // write back the result.\n            unsafe {\n                let dst = dst_buf.add(i);\n                debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n                ptr::write(dst, self.__iterator_get_unchecked(i));\n                // Since this executes user code which can panic we have to bump the pointer\n                // after each step.\n                drop_guard.dst = dst.add(1);\n            }\n        }\n        mem::forget(drop_guard);\n        len\n    }"
}