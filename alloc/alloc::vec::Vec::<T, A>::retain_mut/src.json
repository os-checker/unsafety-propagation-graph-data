{
  "name": "alloc::vec::Vec::<T, A>::retain_mut",
  "span": "$library/alloc/src/vec/mod.rs:2231:5: 2233:34",
  "src": "pub fn retain_mut<F>(&mut self, mut f: F)\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        let original_len = self.len();\n\n        if original_len == 0 {\n            // Empty case: explicit return allows better optimization, vs letting compiler infer it\n            return;\n        }\n\n        // Avoid double drop if the drop guard is not executed,\n        // since we may make some holes during the process.\n        unsafe { self.set_len(0) };\n\n        // Vec: [Kept, Kept, Hole, Hole, Hole, Hole, Unchecked, Unchecked]\n        //      |<-              processed len   ->| ^- next to check\n        //                  |<-  deleted cnt     ->|\n        //      |<-              original_len                          ->|\n        // Kept: Elements which predicate returns true on.\n        // Hole: Moved or dropped element slot.\n        // Unchecked: Unchecked valid elements.\n        //\n        // This drop guard will be invoked when predicate or `drop` of element panicked.\n        // It shifts unchecked elements to cover holes and `set_len` to the correct length.\n        // In cases when predicate and `drop` never panick, it will be optimized out.\n        struct BackshiftOnDrop<'a, T, A: Allocator> {\n            v: &'a mut Vec<T, A>,\n            processed_len: usize,\n            deleted_cnt: usize,\n            original_len: usize,\n        }\n\n        impl<T, A: Allocator> Drop for BackshiftOnDrop<'_, T, A> {\n            fn drop(&mut self) {\n                if self.deleted_cnt > 0 {\n                    // SAFETY: Trailing unchecked items must be valid since we never touch them.\n                    unsafe {\n                        ptr::copy(\n                            self.v.as_ptr().add(self.processed_len),\n                            self.v.as_mut_ptr().add(self.processed_len - self.deleted_cnt),\n                            self.original_len - self.processed_len,\n                        );\n                    }\n                }\n                // SAFETY: After filling holes, all items are in contiguous memory.\n                unsafe {\n                    self.v.set_len(self.original_len - self.deleted_cnt);\n                }\n            }\n        }\n\n        let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };\n\n        fn process_loop<F, T, A: Allocator, const DELETED: bool>(\n            original_len: usize,\n            f: &mut F,\n            g: &mut BackshiftOnDrop<'_, T, A>,\n        ) where\n            F: FnMut(&mut T) -> bool,\n        {\n            while g.processed_len != original_len {\n                // SAFETY: Unchecked element must be valid.\n                let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n                if !f(cur) {\n                    // Advance early to avoid double drop if `drop_in_place` panicked.\n                    g.processed_len += 1;\n                    g.deleted_cnt += 1;\n                    // SAFETY: We never touch this element again after dropped.\n                    unsafe { ptr::drop_in_place(cur) };\n                    // We already advanced the counter.\n                    if DELETED {\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n                if DELETED {\n                    // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n                    // We use copy for move, and never touch this element again.\n                    unsafe {\n                        let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n                        ptr::copy_nonoverlapping(cur, hole_slot, 1);\n                    }\n                }\n                g.processed_len += 1;\n            }\n        }\n\n        // Stage 1: Nothing was deleted.\n        process_loop::<F, T, A, false>(original_len, &mut f, &mut g);\n\n        // Stage 2: Some elements were deleted.\n        process_loop::<F, T, A, true>(original_len, &mut f, &mut g);\n\n        // All item are processed. This can be optimized to `set_len` by LLVM.\n        drop(g);\n    }"
}