{
  "name": "core::ops::ControlFlow",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "alloc::raw_vec::RawVecInner::<A>::try_reserve",
      "alloc::raw_vec::RawVecInner::<A>::try_reserve_exact",
      "alloc::raw_vec::RawVecInner::<A>::grow_amortized",
      "alloc::raw_vec::RawVecInner::<A>::grow_exact",
      "alloc::raw_vec::RawVecInner::<A>::finish_grow",
      "alloc::raw_vec::RawVecInner::<A>::shrink_unchecked",
      "alloc::alloc::Global::alloc_impl",
      "alloc::alloc::Global::grow_impl",
      "alloc::<alloc::Global as core::alloc::Allocator>::shrink",
      "alloc::boxed::Box::<T>::try_map",
      "alloc::boxed::Box::<T, A>::try_new_in",
      "alloc::boxed::Box::<T, A>::try_new_uninit_in",
      "alloc::boxed::Box::<T, A>::try_new_zeroed_in",
      "alloc::boxed::Box::<T, A>::try_clone_from_ref_in",
      "alloc::boxed::Box::<[T]>::try_new_uninit_slice",
      "alloc::boxed::Box::<[T]>::try_new_zeroed_slice",
      "alloc::boxed::Box::<[T], A>::try_new_uninit_slice_in",
      "alloc::boxed::Box::<[T], A>::try_new_zeroed_slice_in",
      "alloc::bstr::<impl core::convert::TryFrom<&'a core::bstr::ByteStr> for string::String>::try_from",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::get",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::get_key_value",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::first_key_value",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::last_key_value",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::get_mut",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::remove_entry",
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::peek",
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next",
      "alloc::collections::btree::map::Cursor::<'a, K, V>::next",
      "alloc::collections::btree::map::Cursor::<'a, K, V>::prev",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::prev",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev",
      "alloc::collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::take_front",
      "alloc::<collections::btree::set::Difference<'a, T, A> as core::iter::Iterator>::next",
      "alloc::<collections::btree::set::Intersection<'a, T, A> as core::iter::Iterator>::next",
      "alloc::collections::linked_list::Cursor::<'a, T, A>::index",
      "alloc::collections::linked_list::CursorMut::<'a, T, A>::index",
      "alloc::collections::linked_list::CursorMut::<'a, T, A>::remove_current",
      "alloc::collections::linked_list::CursorMut::<'a, T, A>::remove_current_as_list",
      "alloc::<collections::vec_deque::iter_mut::IterMut<'a, T> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter_mut::IterMut<'a, T> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<collections::vec_deque::iter::Iter<'a, T> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter::Iter<'a, T> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::collections::vec_deque::VecDeque::<T>::try_with_capacity",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve_exact",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve",
      "alloc::collections::vec_deque::VecDeque::<T, A>::pop_front_if",
      "alloc::collections::vec_deque::VecDeque::<T, A>::pop_back_if",
      "alloc::<collections::TryReserveError as core::fmt::Display>::fmt",
      "alloc::rc::Rc::<T>::try_new",
      "alloc::rc::Rc::<T>::try_new_uninit",
      "alloc::rc::Rc::<T>::try_new_zeroed",
      "alloc::rc::Rc::<T>::try_map",
      "alloc::rc::Rc::<T, A>::try_new_in",
      "alloc::rc::Rc::<T, A>::try_new_uninit_in",
      "alloc::rc::Rc::<T, A>::try_new_zeroed_in",
      "alloc::rc::Rc::<T, A>::try_clone_from_ref_in",
      "alloc::rc::Rc::<T>::try_allocate_for_layout",
      "alloc::rc::Weak::<T, A>::upgrade",
      "alloc::rc::UniqueRc::<T>::try_map",
      "alloc::rc::UniqueRcUninit::<T, A>::try_new",
      "alloc::string::String::try_with_capacity",
      "alloc::string::String::pop",
      "alloc::sync::Arc::<T>::try_pin",
      "alloc::sync::Arc::<T>::try_new",
      "alloc::sync::Arc::<T>::try_new_uninit",
      "alloc::sync::Arc::<T>::try_new_zeroed",
      "alloc::sync::Arc::<T>::try_map",
      "alloc::sync::Arc::<T, A>::try_pin_in",
      "alloc::sync::Arc::<T, A>::try_new_in",
      "alloc::sync::Arc::<T, A>::try_new_uninit_in",
      "alloc::sync::Arc::<T, A>::try_new_zeroed_in",
      "alloc::sync::Arc::<T, A>::try_clone_from_ref_in",
      "alloc::sync::Arc::<T>::try_allocate_for_layout",
      "alloc::sync::Weak::<T, A>::upgrade",
      "alloc::sync::UniqueArcUninit::<T, A>::try_new",
      "alloc::sync::UniqueArc::<T>::try_map",
      "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::vec::Vec::<T, A>::try_with_capacity_in",
      "alloc::vec::Vec::<T, A>::pop_if",
      "alloc::raw_vec::RawVecInner::<A>::try_reserve",
      "alloc::raw_vec::RawVecInner::<A>::try_reserve_exact",
      "alloc::raw_vec::RawVecInner::<A>::grow_amortized",
      "alloc::raw_vec::RawVecInner::<A>::grow_exact",
      "alloc::raw_vec::RawVecInner::<A>::finish_grow",
      "alloc::collections::vec_deque::VecDeque::<T>::try_with_capacity",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve_exact",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve",
      "alloc::string::String::try_with_capacity",
      "alloc::vec::Vec::<T, A>::try_with_capacity_in",
      "alloc::raw_vec::RawVecInner::<A>::grow_amortized",
      "alloc::raw_vec::RawVecInner::<A>::grow_exact",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve_exact",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve",
      "alloc::raw_vec::RawVecInner::<A>::grow_amortized",
      "alloc::raw_vec::RawVecInner::<A>::grow_exact",
      "alloc::raw_vec::RawVecInner::<A>::shrink_unchecked",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve_exact",
      "alloc::collections::vec_deque::VecDeque::<T, A>::try_reserve",
      "alloc::raw_vec::RawVecInner::<A>::grow_amortized",
      "alloc::raw_vec::RawVecInner::<A>::grow_exact",
      "alloc::raw_vec::RawVecInner::<A>::shrink_unchecked",
      "alloc::alloc::Global::grow_impl",
      "alloc::<alloc::Global as core::alloc::Allocator>::shrink",
      "alloc::boxed::Box::<T, A>::try_new_uninit_in",
      "alloc::boxed::Box::<T, A>::try_new_zeroed_in",
      "alloc::boxed::Box::<T, A>::try_clone_from_ref_in",
      "alloc::boxed::Box::<[T]>::try_new_uninit_slice",
      "alloc::boxed::Box::<[T]>::try_new_zeroed_slice",
      "alloc::boxed::Box::<[T], A>::try_new_uninit_slice_in",
      "alloc::boxed::Box::<[T], A>::try_new_zeroed_slice_in",
      "alloc::rc::Rc::<T>::try_allocate_for_layout",
      "alloc::sync::Arc::<T>::try_allocate_for_layout",
      "alloc::raw_vec::RawVecInner::<A>::finish_grow",
      "alloc::alloc::Global::alloc_impl",
      "alloc::alloc::Global::grow_impl",
      "alloc::<alloc::Global as core::alloc::Allocator>::shrink",
      "alloc::boxed::Box::<T>::try_map",
      "alloc::rc::Rc::<T>::try_map",
      "alloc::rc::UniqueRc::<T>::try_map",
      "alloc::sync::Arc::<T>::try_map",
      "alloc::sync::UniqueArc::<T>::try_map",
      "alloc::boxed::Box::<T>::try_map",
      "alloc::rc::Rc::<T>::try_map",
      "alloc::rc::UniqueRc::<T>::try_map",
      "alloc::sync::Arc::<T>::try_map",
      "alloc::sync::UniqueArc::<T>::try_map",
      "alloc::boxed::Box::<T, A>::try_new_in",
      "alloc::bstr::<impl core::convert::TryFrom<&'a core::bstr::ByteStr> for string::String>::try_from",
      "alloc::bstr::<impl core::convert::TryFrom<&'a core::bstr::ByteStr> for string::String>::try_from",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::get",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::get_key_value",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::first_key_value",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::last_key_value",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::get_mut",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::remove_entry",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::peek",
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev",
      "alloc::collections::btree::map::Cursor::<'a, K, V>::next",
      "alloc::collections::btree::map::Cursor::<'a, K, V>::prev",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::prev",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev",
      "alloc::collections::btree::navigate::LazyLeafRange::<collections::btree::node::marker::Dying, K, V>::take_front",
      "alloc::<collections::btree::set::Difference<'a, T, A> as core::iter::Iterator>::next",
      "alloc::<collections::btree::set::Intersection<'a, T, A> as core::iter::Iterator>::next",
      "alloc::collections::linked_list::Cursor::<'a, T, A>::index",
      "alloc::collections::linked_list::CursorMut::<'a, T, A>::index",
      "alloc::collections::linked_list::CursorMut::<'a, T, A>::remove_current",
      "alloc::collections::linked_list::CursorMut::<'a, T, A>::remove_current_as_list",
      "alloc::<collections::vec_deque::iter_mut::IterMut<'a, T> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter_mut::IterMut<'a, T> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<collections::vec_deque::iter::Iter<'a, T> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter::Iter<'a, T> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter_mut::IterMut<'a, T> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter_mut::IterMut<'a, T> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<collections::vec_deque::iter::Iter<'a, T> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::iter::Iter<'a, T> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::collections::vec_deque::VecDeque::<T>::try_with_capacity",
      "alloc::collections::vec_deque::VecDeque::<T, A>::pop_front_if",
      "alloc::collections::vec_deque::VecDeque::<T, A>::pop_back_if",
      "alloc::vec::Vec::<T, A>::pop_if",
      "alloc::rc::Rc::<T>::try_new",
      "alloc::rc::Rc::<T>::try_new_uninit",
      "alloc::rc::Rc::<T>::try_new_zeroed",
      "alloc::rc::Rc::<T, A>::try_new_uninit_in",
      "alloc::rc::Rc::<T, A>::try_new_zeroed_in",
      "alloc::rc::Rc::<T, A>::try_new_in",
      "alloc::rc::Rc::<T, A>::try_clone_from_ref_in",
      "alloc::rc::Weak::<T, A>::upgrade",
      "alloc::rc::UniqueRcUninit::<T, A>::try_new",
      "alloc::string::String::try_with_capacity",
      "alloc::string::String::pop",
      "alloc::sync::Arc::<T>::try_pin",
      "alloc::sync::Arc::<T>::try_new",
      "alloc::sync::Arc::<T>::try_new_uninit",
      "alloc::sync::Arc::<T>::try_new_zeroed",
      "alloc::sync::Arc::<T, A>::try_new_uninit_in",
      "alloc::sync::Arc::<T, A>::try_new_zeroed_in",
      "alloc::sync::Arc::<T, A>::try_pin_in",
      "alloc::sync::Arc::<T, A>::try_new_in",
      "alloc::sync::Arc::<T, A>::try_clone_from_ref_in",
      "alloc::sync::Weak::<T, A>::upgrade",
      "alloc::sync::UniqueArcUninit::<T, A>::try_new",
      "alloc::vec::Vec::<T, A>::try_with_capacity_in"
    ]
  },
  "access_field": [],
  "span": "$library/core/src/ops/control_flow.rs:89:1: 89:32",
  "src": "pub enum ControlFlow<B, C = ()>",
  "kind": "Enum",
  "doc_adt": " Used to tell an operation whether it should exit early or go on as usual.\n\n This is used when exposing things (like graph traversals or visitors) where\n you want the user to be able to choose whether to exit early.\n Having the enum makes it clearer -- no more wondering \"wait, what did `false`\n mean again?\" -- and allows including a value.\n\n Similar to [`Option`] and [`Result`], this enum can be used with the `?` operator\n to return immediately if the [`Break`] variant is present or otherwise continue normally\n with the value inside the [`Continue`] variant.\n\n # Examples\n\n Early-exiting from [`Iterator::try_for_each`]:\n ```\n use std::ops::ControlFlow;\n\n let r = (2..100).try_for_each(|x| {\n     if 403 % x == 0 {\n         return ControlFlow::Break(x)\n     }\n\n     ControlFlow::Continue(())\n });\n assert_eq!(r, ControlFlow::Break(13));\n ```\n\n A basic tree traversal:\n ```\n use std::ops::ControlFlow;\n\n pub struct TreeNode<T> {\n     value: T,\n     left: Option<Box<TreeNode<T>>>,\n     right: Option<Box<TreeNode<T>>>,\n }\n\n impl<T> TreeNode<T> {\n     pub fn traverse_inorder<B>(&self, f: &mut impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {\n         if let Some(left) = &self.left {\n             left.traverse_inorder(f)?;\n         }\n         f(&self.value)?;\n         if let Some(right) = &self.right {\n             right.traverse_inorder(f)?;\n         }\n         ControlFlow::Continue(())\n     }\n     fn leaf(value: T) -> Option<Box<TreeNode<T>>> {\n         Some(Box::new(Self { value, left: None, right: None }))\n     }\n }\n\n let node = TreeNode {\n     value: 0,\n     left: TreeNode::leaf(1),\n     right: Some(Box::new(TreeNode {\n         value: -1,\n         left: TreeNode::leaf(5),\n         right: TreeNode::leaf(2),\n     }))\n };\n let mut sum = 0;\n\n let res = node.traverse_inorder(&mut |val| {\n     if *val < 0 {\n         ControlFlow::Break(*val)\n     } else {\n         sum += *val;\n         ControlFlow::Continue(())\n     }\n });\n assert_eq!(res, ControlFlow::Break(-1));\n assert_eq!(sum, 6);\n ```\n\n [`Break`]: ControlFlow::Break\n [`Continue`]: ControlFlow::Continue\n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "Continue",
      "doc": " Move on to the next phase of the operation as normal.\n"
    },
    "VariantIdx(Some(0))-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "Break",
      "doc": " Exit the operation without running subsequent phases.\n"
    },
    "VariantIdx(Some(1))-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}