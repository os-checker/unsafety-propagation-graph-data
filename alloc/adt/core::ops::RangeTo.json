{
  "name": "core::ops::RangeTo",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "<bstr::ByteString as core::ops::Index<core::ops::RangeTo<usize>>>::index",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "collections::btree::node::NodeRef::<collections::btree::node::marker::Immut<'a>, K, V, Type>::keys",
      "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::Edge>::insert_fit",
      "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::insert_fit",
      "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::split_leaf_data",
      "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>, collections::btree::node::marker::KV>::remove",
      "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::KV>::split",
      "collections::btree::node::BalancingContext::<'a, K, V>::do_merge",
      "collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_left",
      "collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right",
      "collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>, collections::btree::node::marker::Edge>::move_suffix",
      "collections::vec_deque::extract_if::ExtractIf::<'a, T, F, A>::new",
      "<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::advance_by",
      "collections::vec_deque::VecDeque::<T, A>::truncate_front",
      "collections::vec_deque::VecDeque::<T, A>::slice_ranges",
      "collections::vec_deque::VecDeque::<T, A>::drain",
      "collections::vec_deque::VecDeque::<T, A>::extend_from_within",
      "collections::vec_deque::VecDeque::<T, A>::prepend_from_within",
      "ffi::c_str::CString::as_bytes",
      "str::join_generic_copy",
      "str::<impl str>::to_lowercase::map_uppercase_sigma",
      "str::convert_while_ascii",
      "string::String::extend_from_within",
      "string::String::drain",
      "string::FromUtf8Error::into_utf8_lossy",
      "vec::extract_if::ExtractIf::<'a, T, F, A>::new",
      "vec::Vec::<T, A>::drain",
      "vec::Vec::<T, A>::extend_from_within",
      "wtf8::to_string_lossy"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ops/range.rs:281:1: 281:24",
  "src": "pub struct RangeTo<Idx>",
  "kind": "Struct",
  "doc_adt": " A range only bounded exclusively above (`..end`).\n\n The `RangeTo` `..end` contains all values with `x < end`.\n It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n\n # Examples\n\n The `..end` syntax is a `RangeTo`:\n\n ```\n assert_eq!((..5), std::ops::RangeTo { end: 5 });\n ```\n\n It does not have an [`IntoIterator`] implementation, so you can't use it in\n a `for` loop directly. This won't compile:\n\n ```compile_fail,E0277\n // error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:\n // std::iter::Iterator` is not satisfied\n for i in ..5 {\n     // ...\n }\n ```\n\n When used as a [slicing index], `RangeTo` produces a slice of all array\n elements before the index indicated by `end`.\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n assert_eq!(arr[ .. 3], [0, 1, 2      ]); // This is a `RangeTo`\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n ```\n\n [slicing index]: crate::slice::SliceIndex\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "end",
      "doc": " The upper bound of the range (exclusive).\n"
    }
  }
}