{
  "name": "sync::UniqueArc",
  "constructors": [
    "sync::UniqueArc::<T>::new",
    "sync::UniqueArc::<T>::map",
    "sync::UniqueArc::<T>::from_raw",
    "sync::UniqueArc::<T, A>::new_in",
    "sync::UniqueArc::<T, A>::from_inner_in",
    "sync::UniqueArc::<core::mem::MaybeUninit<T>, A>::assume_init"
  ],
  "access_self_as_arg": {
    "read": [
      "<sync::UniqueArc<T, A> as core::fmt::Display>::fmt",
      "<sync::UniqueArc<T, A> as core::fmt::Debug>::fmt",
      "<sync::UniqueArc<T, A> as core::fmt::Pointer>::fmt",
      "<sync::UniqueArc<T, A> as core::borrow::Borrow<T>>::borrow",
      "<sync::UniqueArc<T, A> as core::convert::AsRef<T>>::as_ref",
      "<sync::UniqueArc<T, A> as core::cmp::PartialEq>::eq",
      "<sync::UniqueArc<T, A> as core::cmp::PartialOrd>::partial_cmp",
      "<sync::UniqueArc<T, A> as core::cmp::PartialOrd>::lt",
      "<sync::UniqueArc<T, A> as core::cmp::PartialOrd>::le",
      "<sync::UniqueArc<T, A> as core::cmp::PartialOrd>::gt",
      "<sync::UniqueArc<T, A> as core::cmp::PartialOrd>::ge",
      "<sync::UniqueArc<T, A> as core::cmp::Ord>::cmp",
      "<sync::UniqueArc<T, A> as core::hash::Hash>::hash",
      "sync::UniqueArc::<T>::map",
      "sync::UniqueArc::<T>::try_map",
      "sync::UniqueArc::<T>::unwrap",
      "sync::UniqueArc::<T>::into_raw",
      "sync::UniqueArc::<T, A>::into_arc",
      "sync::UniqueArc::<T, A>::weak_count",
      "sync::UniqueArc::<T, A>::inner",
      "sync::UniqueArc::<T, A>::as_ptr",
      "sync::UniqueArc::<T, A>::into_inner_with_allocator",
      "sync::UniqueArc::<T, A>::downgrade",
      "<sync::UniqueArc<T, A> as core::ops::Deref>::deref"
    ],
    "write": [
      "<sync::UniqueArc<T, A> as core::borrow::BorrowMut<T>>::borrow_mut",
      "<sync::UniqueArc<T, A> as core::convert::AsMut<T>>::as_mut",
      "sync::UniqueArc::<T>::map",
      "sync::UniqueArc::<T>::try_map",
      "<sync::UniqueArc<T, A> as core::ops::DerefMut>::deref_mut",
      "<sync::UniqueArc<T, A> as core::ops::Drop>::drop"
    ],
    "other": [
      "sync::UniqueArc::<T>::map",
      "sync::UniqueArc::<T>::try_map",
      "sync::UniqueArc::<T>::unwrap",
      "sync::UniqueArc::<T>::into_raw",
      "sync::UniqueArc::<T, A>::into_arc",
      "sync::UniqueArc::<T, A>::into_inner_with_allocator",
      "sync::UniqueArc::<core::mem::MaybeUninit<T>, A>::assume_init"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "sync::UniqueArc::<T>::new",
      "sync::UniqueArc::<T>::from_raw",
      "sync::UniqueArc::<T, A>::new_in",
      "sync::UniqueArc::<T, A>::from_inner_in"
    ]
  },
  "access_field": [
    {
      "read": [
        "sync::UniqueArc::<T>::unwrap",
        "sync::UniqueArc::<T, A>::into_arc",
        "sync::UniqueArc::<T, A>::inner",
        "sync::UniqueArc::<T, A>::as_ptr",
        "sync::UniqueArc::<T, A>::into_inner_with_allocator",
        "sync::UniqueArc::<T, A>::downgrade",
        "<sync::UniqueArc<T, A> as core::ops::Deref>::deref"
      ],
      "write": [
        "<sync::UniqueArc<T, A> as core::ops::DerefMut>::deref_mut",
        "<sync::UniqueArc<T, A> as core::ops::Drop>::drop"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [
        "sync::UniqueArc::<T, A>::into_arc",
        "sync::UniqueArc::<T, A>::into_inner_with_allocator",
        "sync::UniqueArc::<T, A>::downgrade"
      ],
      "write": [
        "<sync::UniqueArc<T, A> as core::ops::Drop>::drop"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/sync.rs:4348:1: 4351:2",
  "src": "pub struct UniqueArc<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n>",
  "kind": "Struct",
  "doc_adt": " A uniquely owned [`Arc`].\n\n This represents an `Arc` that is known to be uniquely owned -- that is, have exactly one strong\n reference. Multiple weak pointers can be created, but attempts to upgrade those to strong\n references will fail unless the `UniqueArc` they point to has been converted into a regular `Arc`.\n\n Because it is uniquely owned, the contents of a `UniqueArc` can be freely mutated. A common\n use case is to have an object be mutable during its initialization phase but then have it become\n immutable and converted to a normal `Arc`.\n\n This can be used as a flexible way to create cyclic data structures, as in the example below.\n\n ```\n #![feature(unique_rc_arc)]\n use std::sync::{Arc, Weak, UniqueArc};\n\n struct Gadget {\n     me: Weak<Gadget>,\n }\n\n fn create_gadget() -> Option<Arc<Gadget>> {\n     let mut rc = UniqueArc::new(Gadget {\n         me: Weak::new(),\n     });\n     rc.me = UniqueArc::downgrade(&rc);\n     Some(UniqueArc::into_arc(rc))\n }\n\n create_gadget().unwrap();\n ```\n\n An advantage of using `UniqueArc` over [`Arc::new_cyclic`] to build cyclic data structures is that\n [`Arc::new_cyclic`]'s `data_fn` parameter cannot be async or return a [`Result`]. As shown in the\n previous example, `UniqueArc` allows for more flexibility in the construction of cyclic data,\n including fallible or async constructors.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "ptr",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "_marker2",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "alloc",
      "doc": ""
    }
  }
}