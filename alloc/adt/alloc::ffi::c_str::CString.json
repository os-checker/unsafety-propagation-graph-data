{
  "name": "alloc::ffi::c_str::CString",
  "constructors": [
    "alloc::<&[u8] as ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl",
    "alloc::<&mut [u8] as ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl",
    "alloc::<&str as ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl",
    "alloc::<T as ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl",
    "alloc::<ffi::c_str::CString as core::clone::Clone>::clone",
    "alloc::<ffi::c_str::CString as core::convert::From<&core::ffi::CStr>>::from",
    "alloc::<ffi::c_str::CString as core::convert::From<borrow::Cow<'a, core::ffi::CStr>>>::from",
    "alloc::<ffi::c_str::CString as core::convert::From<boxed::Box<core::ffi::CStr>>>::from",
    "alloc::<ffi::c_str::CString as core::convert::From<vec::Vec<core::num::NonZero<u8>>>>::from",
    "alloc::<ffi::c_str::CString as core::default::Default>::default",
    "alloc::<ffi::c_str::CString as core::str::FromStr>::from_str",
    "alloc::ffi::c_str::<impl borrow::ToOwned for core::ffi::CStr>::to_owned",
    "alloc::ffi::c_str::<impl core::ffi::CStr>::into_c_string",
    "alloc::ffi::c_str::CString::_from_vec_unchecked",
    "alloc::ffi::c_str::CString::_from_vec_with_nul_unchecked",
    "alloc::ffi::c_str::CString::from_raw",
    "alloc::ffi::c_str::CString::from_vec_unchecked",
    "alloc::ffi::c_str::CString::from_vec_with_nul",
    "alloc::ffi::c_str::CString::from_vec_with_nul_unchecked",
    "alloc::ffi::c_str::CString::new",
    "alloc::ffi::c_str::CString::new::spec_new_impl_bytes",
    "alloc::ffi::c_str::IntoStringError::into_cstring"
  ],
  "access_self_as_arg": {
    "read": [
      "alloc::<ffi::c_str::CString as core::borrow::Borrow<core::ffi::CStr>>::borrow",
      "alloc::<ffi::c_str::CString as core::clone::Clone>::clone",
      "alloc::<ffi::c_str::CString as core::cmp::Eq>::assert_receiver_is_total_eq",
      "alloc::<ffi::c_str::CString as core::cmp::Ord>::cmp",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq<&core::ffi::CStr>>::eq",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq<&core::ffi::CStr>>::ne",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq<borrow::Cow<'_, core::ffi::CStr>>>::eq",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq<borrow::Cow<'_, core::ffi::CStr>>>::ne",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq<core::ffi::CStr>>::eq",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq<core::ffi::CStr>>::ne",
      "alloc::<ffi::c_str::CString as core::cmp::PartialEq>::eq",
      "alloc::<ffi::c_str::CString as core::cmp::PartialOrd>::partial_cmp",
      "alloc::<ffi::c_str::CString as core::convert::AsRef<core::ffi::CStr>>::as_ref",
      "alloc::<ffi::c_str::CString as core::fmt::Debug>::fmt",
      "alloc::<ffi::c_str::CString as core::hash::Hash>::hash",
      "alloc::<ffi::c_str::CString as core::ops::Deref>::deref",
      "alloc::<ffi::c_str::CString as core::ops::Index<core::ops::RangeFull>>::index",
      "alloc::ffi::c_str::<impl core::cmp::PartialEq<ffi::c_str::CString> for borrow::Cow<'_, core::ffi::CStr>>::eq",
      "alloc::ffi::c_str::<impl core::cmp::PartialEq<ffi::c_str::CString> for borrow::Cow<'_, core::ffi::CStr>>::ne",
      "alloc::ffi::c_str::<impl core::cmp::PartialEq<ffi::c_str::CString> for core::ffi::CStr>::eq",
      "alloc::ffi::c_str::<impl core::cmp::PartialEq<ffi::c_str::CString> for core::ffi::CStr>::ne",
      "alloc::ffi::c_str::<impl core::convert::From<&'a ffi::c_str::CString> for borrow::Cow<'a, core::ffi::CStr>>::from",
      "alloc::ffi::c_str::CString::as_bytes",
      "alloc::ffi::c_str::CString::as_bytes_with_nul",
      "alloc::ffi::c_str::CString::as_c_str",
      "alloc::ffi::c_str::CString::into_inner"
    ],
    "write": [
      "alloc::<ffi::c_str::CString as core::ops::Drop>::drop",
      "alloc::ffi::c_str::<impl borrow::ToOwned for core::ffi::CStr>::clone_into"
    ],
    "other": [
      "alloc::<ffi::c_str::CString as core::clone::Clone>::clone",
      "alloc::ffi::c_str::<impl core::convert::From<ffi::c_str::CString> for borrow::Cow<'a, core::ffi::CStr>>::from",
      "alloc::ffi::c_str::<impl core::convert::From<ffi::c_str::CString> for boxed::Box<core::ffi::CStr>>::from",
      "alloc::ffi::c_str::<impl core::convert::From<ffi::c_str::CString> for rc::Rc<core::ffi::CStr>>::from",
      "alloc::ffi::c_str::<impl core::convert::From<ffi::c_str::CString> for sync::Arc<core::ffi::CStr>>::from",
      "alloc::ffi::c_str::<impl core::convert::From<ffi::c_str::CString> for vec::Vec<u8>>::from",
      "alloc::ffi::c_str::<impl core::convert::TryFrom<ffi::c_str::CString> for string::String>::try_from",
      "alloc::ffi::c_str::CString::into_boxed_c_str",
      "alloc::ffi::c_str::CString::into_bytes",
      "alloc::ffi::c_str::CString::into_bytes_with_nul",
      "alloc::ffi::c_str::CString::into_inner",
      "alloc::ffi::c_str::CString::into_raw",
      "alloc::ffi::c_str::CString::into_string"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "alloc::<ffi::c_str::IntoStringError as core::clone::Clone>::clone",
      "alloc::<ffi::c_str::IntoStringError as core::cmp::PartialEq>::eq",
      "alloc::<ffi::c_str::IntoStringError as core::fmt::Debug>::fmt"
    ],
    "write": [],
    "other": [
      "alloc::<T as ffi::c_str::CString::new::SpecNewImpl>::spec_new_impl",
      "alloc::<ffi::c_str::CString as core::convert::From<&core::ffi::CStr>>::from",
      "alloc::<ffi::c_str::CString as core::convert::From<borrow::Cow<'a, core::ffi::CStr>>>::from",
      "alloc::<ffi::c_str::CString as core::convert::From<boxed::Box<core::ffi::CStr>>>::from",
      "alloc::<ffi::c_str::CString as core::convert::From<vec::Vec<core::num::NonZero<u8>>>>::from",
      "alloc::<ffi::c_str::CString as core::default::Default>::default",
      "alloc::<ffi::c_str::IntoStringError as core::clone::Clone>::clone",
      "alloc::ffi::c_str::<impl borrow::ToOwned for core::ffi::CStr>::to_owned",
      "alloc::ffi::c_str::<impl core::convert::From<borrow::Cow<'_, core::ffi::CStr>> for boxed::Box<core::ffi::CStr>>::from",
      "alloc::ffi::c_str::<impl core::ffi::CStr>::into_c_string",
      "alloc::ffi::c_str::CString::_from_vec_unchecked",
      "alloc::ffi::c_str::CString::_from_vec_with_nul_unchecked",
      "alloc::ffi::c_str::CString::from_raw",
      "alloc::ffi::c_str::CString::from_vec_unchecked",
      "alloc::ffi::c_str::CString::from_vec_with_nul",
      "alloc::ffi::c_str::CString::from_vec_with_nul_unchecked",
      "alloc::ffi::c_str::CString::new::spec_new_impl_bytes",
      "alloc::ffi::c_str::IntoStringError::into_cstring"
    ]
  },
  "access_field": [
    {
      "read": [
        "alloc::<ffi::c_str::CString as core::clone::Clone>::clone",
        "alloc::<ffi::c_str::CString as core::cmp::Ord>::cmp",
        "alloc::<ffi::c_str::CString as core::cmp::PartialEq>::eq",
        "alloc::<ffi::c_str::CString as core::cmp::PartialOrd>::partial_cmp",
        "alloc::<ffi::c_str::CString as core::hash::Hash>::hash",
        "alloc::ffi::c_str::CString::as_bytes",
        "alloc::ffi::c_str::CString::as_bytes_with_nul",
        "alloc::ffi::c_str::CString::into_inner"
      ],
      "write": [
        "alloc::<ffi::c_str::CString as core::ops::Drop>::drop",
        "alloc::ffi::c_str::<impl borrow::ToOwned for core::ffi::CStr>::clone_into"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/ffi/c_str.rs:107:1: 107:19",
  "src": "pub struct CString",
  "kind": "Struct",
  "doc_adt": " A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n middle.\n\n This type serves the purpose of being able to safely generate a\n C-compatible string from a Rust byte slice or vector. An instance of this\n type is a static guarantee that the underlying bytes contain no interior 0\n bytes (\"nul characters\") and that the final byte is 0 (\"nul terminator\").\n\n `CString` is to <code>&[CStr]</code> as [`String`] is to <code>&[str]</code>: the former\n in each pair are owned strings; the latter are borrowed\n references.\n\n # Creating a `CString`\n\n A `CString` is created from either a byte slice or a byte vector,\n or anything that implements <code>[Into]<[Vec]<[u8]>></code> (for\n example, you can build a `CString` straight out of a [`String`] or\n a <code>&[str]</code>, since both implement that trait).\n You can create a `CString` from a literal with `CString::from(c\"Text\")`.\n\n The [`CString::new`] method will actually check that the provided <code>&[[u8]]</code>\n does not have 0 bytes in the middle, and return an error if it\n finds one.\n\n # Extracting a raw pointer to the whole C string\n\n `CString` implements an [`as_ptr`][`CStr::as_ptr`] method through the [`Deref`]\n trait. This method will give you a `*const c_char` which you can\n feed directly to extern functions that expect a nul-terminated\n string, like C's `strdup()`. Notice that [`as_ptr`][`CStr::as_ptr`] returns a\n read-only pointer; if the C code writes to it, that causes\n undefined behavior.\n\n # Extracting a slice of the whole C string\n\n Alternatively, you can obtain a <code>&[[u8]]</code> slice from a\n `CString` with the [`CString::as_bytes`] method. Slices produced in this\n way do *not* contain the trailing nul terminator. This is useful\n when you will be calling an extern function that takes a `*const\n u8` argument which is not necessarily nul-terminated, plus another\n argument with the length of the string â€” like C's `strndup()`.\n You can of course get the slice's length with its\n [`len`][slice::len] method.\n\n If you need a <code>&[[u8]]</code> slice *with* the nul terminator, you\n can use [`CString::as_bytes_with_nul`] instead.\n\n Once you have the kind of slice you need (with or without a nul\n terminator), you can call the slice's own\n [`as_ptr`][slice::as_ptr] method to get a read-only raw pointer to pass to\n extern functions. See the documentation for that function for a\n discussion on ensuring the lifetime of the raw pointer.\n\n [str]: prim@str \"str\"\n [`Deref`]: ops::Deref\n\n # Examples\n\n ```ignore (extern-declaration)\n # fn main() {\n use std::ffi::CString;\n use std::os::raw::c_char;\n\n extern \"C\" {\n     fn my_printer(s: *const c_char);\n }\n\n // We are certain that our string doesn't have 0 bytes in the middle,\n // so we can .expect()\n let c_to_print = CString::new(\"Hello, world!\").expect(\"CString::new failed\");\n unsafe {\n     my_printer(c_to_print.as_ptr());\n }\n # }\n ```\n\n # Safety\n\n `CString` is intended for working with traditional C-style strings\n (a sequence of non-nul bytes terminated by a single nul byte); the\n primary use case for these kinds of strings is interoperating with C-like\n code. Often you will need to transfer ownership to/from that external\n code. It is strongly recommended that you thoroughly read through the\n documentation of `CString` before use, as improper ownership management\n of `CString` instances can lead to invalid memory accesses, memory leaks,\n and other memory errors.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}