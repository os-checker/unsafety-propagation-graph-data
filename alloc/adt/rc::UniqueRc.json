{
  "name": "rc::UniqueRc",
  "constructors": [
    "rc::UniqueRc::<T>::new",
    "rc::UniqueRc::<T>::map",
    "rc::UniqueRc::<T>::from_raw",
    "rc::UniqueRc::<T, A>::new_in",
    "rc::UniqueRc::<T, A>::from_inner_in",
    "rc::UniqueRc::<core::mem::MaybeUninit<T>, A>::assume_init"
  ],
  "access_self_as_arg": {
    "read": [
      "<rc::UniqueRc<T, A> as core::fmt::Display>::fmt",
      "<rc::UniqueRc<T, A> as core::fmt::Debug>::fmt",
      "<rc::UniqueRc<T, A> as core::fmt::Pointer>::fmt",
      "<rc::UniqueRc<T, A> as core::borrow::Borrow<T>>::borrow",
      "<rc::UniqueRc<T, A> as core::convert::AsRef<T>>::as_ref",
      "<rc::UniqueRc<T, A> as core::cmp::PartialEq>::eq",
      "<rc::UniqueRc<T, A> as core::cmp::PartialEq>::ne",
      "<rc::UniqueRc<T, A> as core::cmp::PartialOrd>::partial_cmp",
      "<rc::UniqueRc<T, A> as core::cmp::PartialOrd>::lt",
      "<rc::UniqueRc<T, A> as core::cmp::PartialOrd>::le",
      "<rc::UniqueRc<T, A> as core::cmp::PartialOrd>::gt",
      "<rc::UniqueRc<T, A> as core::cmp::PartialOrd>::ge",
      "<rc::UniqueRc<T, A> as core::cmp::Ord>::cmp",
      "<rc::UniqueRc<T, A> as core::hash::Hash>::hash",
      "rc::UniqueRc::<T>::map",
      "rc::UniqueRc::<T>::try_map",
      "rc::UniqueRc::<T>::unwrap",
      "rc::UniqueRc::<T>::into_raw",
      "rc::UniqueRc::<T, A>::into_rc",
      "rc::UniqueRc::<T, A>::weak_count",
      "rc::UniqueRc::<T, A>::inner",
      "rc::UniqueRc::<T, A>::as_ptr",
      "rc::UniqueRc::<T, A>::into_inner_with_allocator",
      "rc::UniqueRc::<T, A>::downgrade",
      "<rc::UniqueRc<T, A> as core::ops::Deref>::deref"
    ],
    "write": [
      "<rc::UniqueRc<T, A> as core::borrow::BorrowMut<T>>::borrow_mut",
      "<rc::UniqueRc<T, A> as core::convert::AsMut<T>>::as_mut",
      "rc::UniqueRc::<T>::map",
      "rc::UniqueRc::<T>::try_map",
      "rc::UniqueRc::<T, A>::into_rc",
      "<rc::UniqueRc<T, A> as core::ops::DerefMut>::deref_mut",
      "<rc::UniqueRc<T, A> as core::ops::Drop>::drop"
    ],
    "other": [
      "rc::UniqueRc::<T>::map",
      "rc::UniqueRc::<T>::try_map",
      "rc::UniqueRc::<T>::unwrap",
      "rc::UniqueRc::<T>::into_raw",
      "rc::UniqueRc::<T, A>::into_rc",
      "rc::UniqueRc::<T, A>::into_inner_with_allocator",
      "rc::UniqueRc::<core::mem::MaybeUninit<T>, A>::assume_init"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "rc::UniqueRc::<T>::new",
      "rc::UniqueRc::<T>::from_raw",
      "rc::UniqueRc::<T, A>::new_in",
      "rc::UniqueRc::<T, A>::from_inner_in"
    ]
  },
  "access_field": [
    {
      "read": [
        "rc::UniqueRc::<T>::unwrap",
        "rc::UniqueRc::<T, A>::into_rc",
        "rc::UniqueRc::<T, A>::inner",
        "rc::UniqueRc::<T, A>::as_ptr",
        "rc::UniqueRc::<T, A>::into_inner_with_allocator",
        "rc::UniqueRc::<T, A>::downgrade",
        "<rc::UniqueRc<T, A> as core::ops::Deref>::deref"
      ],
      "write": [
        "rc::UniqueRc::<T, A>::into_rc",
        "<rc::UniqueRc<T, A> as core::ops::DerefMut>::deref_mut",
        "<rc::UniqueRc<T, A> as core::ops::Drop>::drop"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [
        "rc::UniqueRc::<T, A>::into_rc",
        "rc::UniqueRc::<T, A>::into_inner_with_allocator",
        "rc::UniqueRc::<T, A>::downgrade"
      ],
      "write": [
        "<rc::UniqueRc<T, A> as core::ops::Drop>::drop"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/rc.rs:3896:1: 3899:2",
  "src": "pub struct UniqueRc<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n>",
  "kind": "Struct",
  "doc_adt": " A uniquely owned [`Rc`].\n\n This represents an `Rc` that is known to be uniquely owned -- that is, have exactly one strong\n reference. Multiple weak pointers can be created, but attempts to upgrade those to strong\n references will fail unless the `UniqueRc` they point to has been converted into a regular `Rc`.\n\n Because they are uniquely owned, the contents of a `UniqueRc` can be freely mutated. A common\n use case is to have an object be mutable during its initialization phase but then have it become\n immutable and converted to a normal `Rc`.\n\n This can be used as a flexible way to create cyclic data structures, as in the example below.\n\n ```\n #![feature(unique_rc_arc)]\n use std::rc::{Rc, Weak, UniqueRc};\n\n struct Gadget {\n     #[allow(dead_code)]\n     me: Weak<Gadget>,\n }\n\n fn create_gadget() -> Option<Rc<Gadget>> {\n     let mut rc = UniqueRc::new(Gadget {\n         me: Weak::new(),\n     });\n     rc.me = UniqueRc::downgrade(&rc);\n     Some(UniqueRc::into_rc(rc))\n }\n\n create_gadget().unwrap();\n ```\n\n An advantage of using `UniqueRc` over [`Rc::new_cyclic`] to build cyclic data structures is that\n [`Rc::new_cyclic`]'s `data_fn` parameter cannot be async or return a [`Result`]. As shown in the\n previous example, `UniqueRc` allows for more flexibility in the construction of cyclic data,\n including fallible or async constructors.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "ptr",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "_marker2",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "alloc",
      "doc": ""
    }
  }
}