{
  "name": "core::ops::RangeInclusive",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "alloc::<bstr::ByteString as core::ops::Index<core::ops::RangeInclusive<usize>>>::index",
      "alloc::<bstr::ByteString as core::ops::IndexMut<core::ops::RangeInclusive<usize>>>::index_mut"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "alloc::collections::vec_deque::VecDeque::<T, A>::shrink_to"
    ],
    "write": [],
    "other": [
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::correct_all_childrens_parent_links",
      "alloc::collections::vec_deque::VecDeque::<T, A>::shrink_to"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ops/range.rs:357:1: 357:31",
  "src": "pub struct RangeInclusive<Idx>",
  "kind": "Struct",
  "doc_adt": " A range bounded inclusively below and above (`start..=end`).\n\n The `RangeInclusive` `start..=end` contains all values with `x >= start`\n and `x <= end`. It is empty unless `start <= end`.\n\n This iterator is [fused], but the specific values of `start` and `end` after\n iteration has finished are **unspecified** other than that [`.is_empty()`]\n will return `true` once no more values will be produced.\n\n [fused]: crate::iter::FusedIterator\n [`.is_empty()`]: RangeInclusive::is_empty\n\n # Examples\n\n The `start..=end` syntax is a `RangeInclusive`:\n\n ```\n assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n assert_eq!(3 + 4 + 5, (3..=5).sum());\n ```\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]); // This is a `RangeInclusive`\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "start",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "end",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "exhausted",
      "doc": ""
    }
  }
}