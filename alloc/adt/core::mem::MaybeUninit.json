{
  "name": "core::mem::MaybeUninit",
  "constructors": [
    "alloc::boxed::Box::<T>::new_uninit",
    "alloc::boxed::Box::<T>::new_zeroed",
    "alloc::boxed::Box::<T>::try_new_uninit",
    "alloc::boxed::Box::<T>::try_new_zeroed",
    "alloc::boxed::Box::<T, A>::new_uninit_in",
    "alloc::boxed::Box::<T, A>::try_new_uninit_in",
    "alloc::boxed::Box::<T, A>::new_zeroed_in",
    "alloc::boxed::Box::<T, A>::try_new_zeroed_in",
    "alloc::boxed::Box::<T, A>::take",
    "alloc::rc::Rc::<T>::new_uninit",
    "alloc::rc::Rc::<T>::new_zeroed",
    "alloc::rc::Rc::<T>::try_new_uninit",
    "alloc::rc::Rc::<T>::try_new_zeroed",
    "alloc::rc::Rc::<T, A>::new_uninit_in",
    "alloc::rc::Rc::<T, A>::new_zeroed_in",
    "alloc::rc::Rc::<T, A>::try_new_uninit_in",
    "alloc::rc::Rc::<T, A>::try_new_zeroed_in",
    "alloc::sync::Arc::<T>::new_uninit",
    "alloc::sync::Arc::<T>::new_zeroed",
    "alloc::sync::Arc::<T>::try_new_uninit",
    "alloc::sync::Arc::<T>::try_new_zeroed",
    "alloc::sync::Arc::<T, A>::new_uninit_in",
    "alloc::sync::Arc::<T, A>::new_zeroed_in",
    "alloc::sync::Arc::<T, A>::try_new_uninit_in",
    "alloc::sync::Arc::<T, A>::try_new_zeroed_in"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::ValMut<'a>, K, V, Type>::into_key_val_mut_at",
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::LeafOrInternal>::pop_internal_level",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::Internal>, collections::btree::node::marker::Edge>::descend",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Immut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::into_kv",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, NodeType>, collections::btree::node::marker::KV>::into_key_val",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::split_leaf_data",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_left",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right",
      "alloc::collections::btree::node::slice_remove"
    ],
    "write": [
      "alloc::boxed::Box::<T, A>::new_in",
      "alloc::boxed::Box::<T, A>::try_new_in",
      "alloc::boxed::Box::<core::mem::MaybeUninit<T>, A>::write",
      "alloc::<boxed::Box<T, A> as core::clone::Clone>::clone",
      "alloc::collections::btree::node::LeafNode::<K, V>::new",
      "alloc::collections::btree::node::InternalNode::<K, V>::new",
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Owned, K, V, collections::btree::node::marker::Internal>::new_internal",
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::ValMut<'a>, K, V, Type>::into_key_val_mut_at",
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::set_parent_link",
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Leaf>::push_with_handle",
      "alloc::collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::Internal>::push",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::key_mut",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::into_val_mut",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::into_kv_mut",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::kv_mut",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, NodeType>, collections::btree::node::marker::KV>::into_key_val",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, NodeType>, collections::btree::node::marker::KV>::drop_key_val",
      "alloc::<collections::btree::node::Handle<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, NodeType>, collections::btree::node::marker::KV>::drop_key_val::Dropper<'_, T> as core::ops::Drop>::drop",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::split_leaf_data",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::do_merge",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_left",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right",
      "alloc::collections::btree::node::slice_insert",
      "alloc::rc::Rc::<T>::map",
      "alloc::rc::Rc::<T>::try_map",
      "alloc::rc::UniqueRc::<T>::map",
      "alloc::rc::UniqueRc::<T>::try_map",
      "alloc::<T as slice::<impl [T]>::to_vec_in::ConvertVec>::to_vec",
      "alloc::str::convert_while_ascii",
      "alloc::sync::Arc::<T>::map",
      "alloc::sync::Arc::<T>::try_map",
      "alloc::sync::UniqueArc::<T>::map",
      "alloc::sync::UniqueArc::<T>::try_map",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Dying, K, V, NodeType>, collections::btree::node::marker::KV>::into_key_val",
      "alloc::collections::btree::node::Handle::<collections::btree::node::NodeRef<collections::btree::node::marker::Mut<'a>, K, V, NodeType>, collections::btree::node::marker::KV>::split_leaf_data",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_left",
      "alloc::collections::btree::node::BalancingContext::<'a, K, V>::bulk_steal_right",
      "alloc::str::convert_while_ascii"
    ],
    "other": [
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk",
      "alloc::rc::Rc::<T, A>::new_cyclic_in",
      "alloc::str::convert_while_ascii",
      "alloc::sync::Arc::<T, A>::new_cyclic_in",
      "alloc::<vec::into_iter::IntoIter<T, A> as core::iter::Iterator>::next_chunk",
      "alloc::<i8 as string::SpecToString>::spec_to_string",
      "alloc::<u8 as string::SpecToString>::spec_to_string",
      "alloc::<i16 as string::SpecToString>::spec_to_string",
      "alloc::<u16 as string::SpecToString>::spec_to_string",
      "alloc::<i32 as string::SpecToString>::spec_to_string",
      "alloc::<u32 as string::SpecToString>::spec_to_string",
      "alloc::<i64 as string::SpecToString>::spec_to_string",
      "alloc::<u64 as string::SpecToString>::spec_to_string",
      "alloc::<isize as string::SpecToString>::spec_to_string",
      "alloc::<usize as string::SpecToString>::spec_to_string",
      "alloc::<i128 as string::SpecToString>::spec_to_string",
      "alloc::<u128 as string::SpecToString>::spec_to_string"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/mem/maybe_uninit.rs:346:1: 346:25",
  "src": "pub union MaybeUninit<T>",
  "kind": "Union",
  "doc_adt": " A wrapper type to construct uninitialized instances of `T`.\n\n # Initialization invariant\n\n The compiler, in general, assumes that a variable is properly initialized\n according to the requirements of the variable's type. For example, a variable of\n reference type must be aligned and non-null. This is an invariant that must\n *always* be upheld, even in unsafe code. As a consequence, zero-initializing a\n variable of reference type causes instantaneous [undefined behavior][ub],\n no matter whether that reference ever gets used to access memory:\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem::{self, MaybeUninit};\n\n let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior! ⚠️\n // The equivalent code with `MaybeUninit<&i32>`:\n let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior! ⚠️\n ```\n\n This is exploited by the compiler for various optimizations, such as eliding\n run-time checks and optimizing `enum` layout.\n\n Similarly, entirely uninitialized memory may have any content, while a `bool` must\n always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem::{self, MaybeUninit};\n\n let b: bool = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️\n // The equivalent code with `MaybeUninit<bool>`:\n let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! ⚠️\n ```\n\n Moreover, uninitialized memory is special in that it does not have a fixed value (\"fixed\"\n meaning \"it won't change without being written to\"). Reading the same uninitialized byte\n multiple times can give different results. This makes it undefined behavior to have\n uninitialized data in a variable even if that variable has an integer type, which otherwise can\n hold any *fixed* bit pattern:\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem::{self, MaybeUninit};\n\n let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior! ⚠️\n // The equivalent code with `MaybeUninit<i32>`:\n let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior! ⚠️\n ```\n On top of that, remember that most types have additional invariants beyond merely\n being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n is considered initialized (under the current implementation; this does not constitute\n a stable guarantee) because the only requirement the compiler knows about it\n is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n *immediate* undefined behavior, but will cause undefined behavior with most\n safe operations (including dropping it).\n\n [`Vec<T>`]: ../../std/vec/struct.Vec.html\n\n # Examples\n\n `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n It is a signal to the compiler indicating that the data here might *not*\n be initialized:\n\n ```rust\n use std::mem::MaybeUninit;\n\n // Create an explicitly uninitialized reference. The compiler knows that data inside\n // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n let mut x = MaybeUninit::<&i32>::uninit();\n // Set it to a valid value.\n x.write(&0);\n // Extract the initialized data -- this is only allowed *after* properly\n // initializing `x`!\n let x = unsafe { x.assume_init() };\n ```\n\n The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n\n You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n any of the run-time tracking and without any of the safety checks.\n\n ## out-pointers\n\n You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n from a function, pass it a pointer to some (uninitialized) memory to put the\n result into. This can be useful when it is important for the caller to control\n how the memory the result is stored in gets allocated, and you want to avoid\n unnecessary moves.\n\n ```\n use std::mem::MaybeUninit;\n\n unsafe fn make_vec(out: *mut Vec<i32>) {\n     // `write` does not drop the old contents, which is important.\n     unsafe { out.write(vec![1, 2, 3]); }\n }\n\n let mut v = MaybeUninit::uninit();\n unsafe { make_vec(v.as_mut_ptr()); }\n // Now we know `v` is initialized! This also makes sure the vector gets\n // properly dropped.\n let v = unsafe { v.assume_init() };\n assert_eq!(&v, &[1, 2, 3]);\n ```\n\n ## Initializing an array element-by-element\n\n `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n\n ```\n use std::mem::{self, MaybeUninit};\n\n let data = {\n     // Create an uninitialized array of `MaybeUninit`.\n     let mut data: [MaybeUninit<Vec<u32>>; 1000] = [const { MaybeUninit::uninit() }; 1000];\n\n     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n     // we have a memory leak, but there is no memory safety issue.\n     for elem in &mut data[..] {\n         elem.write(vec![42]);\n     }\n\n     // Everything is initialized. Transmute the array to the\n     // initialized type.\n     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n };\n\n assert_eq!(&data[0], &[42]);\n ```\n\n You can also work with partially initialized arrays, which could\n be found in low-level datastructures.\n\n ```\n use std::mem::MaybeUninit;\n\n // Create an uninitialized array of `MaybeUninit`.\n let mut data: [MaybeUninit<String>; 1000] = [const { MaybeUninit::uninit() }; 1000];\n // Count the number of elements we have assigned.\n let mut data_len: usize = 0;\n\n for elem in &mut data[0..500] {\n     elem.write(String::from(\"hello\"));\n     data_len += 1;\n }\n\n // For each item in the array, drop if we allocated it.\n for elem in &mut data[0..data_len] {\n     unsafe { elem.assume_init_drop(); }\n }\n ```\n\n ## Initializing a struct field-by-field\n\n You can use `MaybeUninit<T>`, and the [`std::ptr::addr_of_mut`] macro, to initialize structs field by field:\n\n ```rust\n use std::mem::MaybeUninit;\n use std::ptr::addr_of_mut;\n\n #[derive(Debug, PartialEq)]\n pub struct Foo {\n     name: String,\n     list: Vec<u8>,\n }\n\n let foo = {\n     let mut uninit: MaybeUninit<Foo> = MaybeUninit::uninit();\n     let ptr = uninit.as_mut_ptr();\n\n     // Initializing the `name` field\n     // Using `write` instead of assignment via `=` to not call `drop` on the\n     // old, uninitialized value.\n     unsafe { addr_of_mut!((*ptr).name).write(\"Bob\".to_string()); }\n\n     // Initializing the `list` field\n     // If there is a panic here, then the `String` in the `name` field leaks.\n     unsafe { addr_of_mut!((*ptr).list).write(vec![0, 1, 2]); }\n\n     // All the fields are initialized, so we call `assume_init` to get an initialized Foo.\n     unsafe { uninit.assume_init() }\n };\n\n assert_eq!(\n     foo,\n     Foo {\n         name: \"Bob\".to_string(),\n         list: vec![0, 1, 2]\n     }\n );\n ```\n [`std::ptr::addr_of_mut`]: crate::ptr::addr_of_mut\n [ub]: ../../reference/behavior-considered-undefined.html\n\n # Layout\n\n `MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\n\n ```rust\n use std::mem::MaybeUninit;\n assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n ```\n\n However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n optimizations, potentially resulting in a larger size:\n\n ```rust\n # use std::mem::MaybeUninit;\n assert_eq!(size_of::<Option<bool>>(), 1);\n assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n ```\n\n If `T` is FFI-safe, then so is `MaybeUninit<T>`.\n\n While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size,\n alignment, and ABI as `T`), this does *not* change any of the previous caveats. `Option<T>` and\n `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type\n `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.\n `MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the\n tracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact\n guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not\n remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\n the same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\n guarantee may evolve.\n\n Note that even though `T` and `MaybeUninit<T>` are ABI compatible it is still unsound to\n transmute `&mut T` to `&mut MaybeUninit<T>` and expose that to safe code because it would allow\n safe code to access uninitialized memory:\n\n ```rust,no_run\n use core::mem::MaybeUninit;\n\n fn unsound_transmute<T>(val: &mut T) -> &mut MaybeUninit<T> {\n     unsafe { core::mem::transmute(val) }\n }\n\n fn main() {\n     let mut code = 0;\n     let code = &mut code;\n     let code2 = unsound_transmute(code);\n     *code2 = MaybeUninit::uninit();\n     std::process::exit(*code); // UB! Accessing uninitialized memory.\n }\n ```\n\n # Validity\n\n `MaybeUninit<T>` has no validity requirements –- any sequence of [bytes] of\n the appropriate length, initialized or uninitialized, are a valid\n representation.\n\n Moving or copying a value of type `MaybeUninit<T>` (i.e., performing a\n \"typed copy\") will exactly preserve the contents, including the\n [provenance], of all non-padding bytes of type `T` in the value's\n representation.\n\n Therefore `MaybeUninit` can be used to perform a round trip of a value from\n type `T` to type `MaybeUninit<U>` then back to type `T`, while preserving\n the original value, if two conditions are met. One, type `U` must have the\n same size as type `T`. Two, for all byte offsets where type `U` has padding,\n the corresponding bytes in the representation of the value must be\n uninitialized.\n\n For example, due to the fact that the type `[u8; size_of::<T>]` has no\n padding, the following is sound for any type `T` and will return the\n original value:\n\n ```rust,no_run\n # use core::mem::{MaybeUninit, transmute};\n # struct T;\n fn identity(t: T) -> T {\n     unsafe {\n         let u: MaybeUninit<[u8; size_of::<T>()]> = transmute(t);\n         transmute(u) // OK.\n     }\n }\n ```\n\n Note: Copying a value that contains references may implicitly reborrow them\n causing the provenance of the returned value to differ from that of the\n original. This applies equally to the trivial identity function:\n\n ```rust,no_run\n fn trivial_identity<T>(t: T) -> T { t }\n ```\n\n Note: Moving or copying a value whose representation has initialized bytes\n at byte offsets where the type has padding may lose the value of those\n bytes, so while the original value will be preserved, the original\n *representation* of that value as bytes may not be. Again, this applies\n equally to `trivial_identity`.\n\n Note: Performing this round trip when type `U` has padding at byte offsets\n where the representation of the original value has initialized bytes may\n produce undefined behavior or a different value. For example, the following\n is unsound since `T` requires all bytes to be initialized:\n\n ```rust,no_run\n # use core::mem::{MaybeUninit, transmute};\n #[repr(C)] struct T([u8; 4]);\n #[repr(C)] struct U(u8, u16);\n fn unsound_identity(t: T) -> T {\n     unsafe {\n         let u: MaybeUninit<U> = transmute(t);\n         transmute(u) // UB.\n     }\n }\n ```\n\n Conversely, the following is sound since `T` allows uninitialized bytes in\n the representation of a value, but the round trip may alter the value:\n\n ```rust,no_run\n # use core::mem::{MaybeUninit, transmute};\n #[repr(C)] struct T(MaybeUninit<[u8; 4]>);\n #[repr(C)] struct U(u8, u16);\n fn non_identity(t: T) -> T {\n     unsafe {\n         // May lose an initialized byte.\n         let u: MaybeUninit<U> = transmute(t);\n         transmute(u)\n     }\n }\n ```\n\n [bytes]: ../../reference/memory-model.html#bytes\n [provenance]: crate::ptr#provenance\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "uninit",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "value",
      "doc": ""
    }
  }
}