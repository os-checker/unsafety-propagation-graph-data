{
  "name": "core::ops::RangeFrom",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "<bstr::ByteString as core::ops::Index<core::ops::RangeFrom<usize>>>::index",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, Type>>::find_key_index",
      "collections::vec_deque::VecDeque::<T, A>::truncate",
      "str::<impl str>::to_lowercase::map_uppercase_sigma",
      "str::convert_while_ascii",
      "string::String::remove",
      "string::FromUtf8Error::into_utf8_lossy",
      "wtf8::Wtf8Buf::push_wtf8",
      "wtf8::to_string_lossy"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ops/range.rs:197:1: 197:26",
  "src": "pub struct RangeFrom<Idx>",
  "kind": "Struct",
  "doc_adt": " A range only bounded inclusively below (`start..`).\n\n The `RangeFrom` `start..` contains all values with `x >= start`.\n\n *Note*: Overflow in the [`Iterator`] implementation (when the contained\n data type reaches its numerical limit) is allowed to panic, wrap, or\n saturate. This behavior is defined by the implementation of the [`Step`]\n trait. For primitive integers, this follows the normal rules, and respects\n the overflow checks profile (panic in debug, wrap in release). Note also\n that overflow happens earlier than you might assume: the overflow happens\n in the call to `next` that yields the maximum value, as the range must be\n set to a state to yield the next value.\n\n [`Step`]: crate::iter::Step\n\n # Examples\n\n The `start..` syntax is a `RangeFrom`:\n\n ```\n assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n ```\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]); // This is a `RangeFrom`\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "start",
      "doc": " The lower bound of the range (inclusive).\n"
    }
  }
}