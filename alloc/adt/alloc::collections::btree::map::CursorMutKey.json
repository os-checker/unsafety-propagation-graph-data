{
  "name": "alloc::collections::btree::map::CursorMutKey",
  "constructors": [
    "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::with_mutable_key"
  ],
  "access_self_as_arg": {
    "read": [
      "alloc::<collections::btree::map::CursorMutKey<'_, K, V, A> as core::fmt::Debug>::fmt",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::as_cursor"
    ],
    "write": [
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::prev",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
      "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::as_cursor",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::as_cursor"
    ],
    "write": [
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::insert_after",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::insert_after_unchecked",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::insert_before",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::insert_before_unchecked",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::peek_next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::peek_prev",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::prev",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::remove_next",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::remove_prev",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::insert_after",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::insert_after_unchecked",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::insert_before",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::insert_before_unchecked",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::next",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::peek_next",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::peek_prev",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::prev",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::remove_next",
      "alloc::collections::btree::set::CursorMutKey::<'a, T, A>::remove_prev"
    ],
    "other": [
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::lower_bound_mut",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut",
      "alloc::collections::btree::map::CursorMut::<'a, K, V, A>::with_mutable_key",
      "alloc::collections::btree::set::CursorMut::<'a, T, A>::with_mutable_key"
    ]
  },
  "access_field": [
    {
      "read": [
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::as_cursor"
      ],
      "write": [
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::next",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_next",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::peek_prev",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::prev",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev"
      ],
      "other": []
    },
    {
      "read": [
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::as_cursor"
      ],
      "write": [
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
        "alloc::collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/collections/btree/map.rs:3020:1: 3025:2",
  "src": "pub struct CursorMutKey<\n    'a,\n    K: 'a,\n    V: 'a,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A = Global,\n>",
  "kind": "Struct",
  "doc_adt": " A cursor over a `BTreeMap` with editing operations, and which allows\n mutating the key of elements.\n\n A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n safely mutate the map during iteration. This is because the lifetime of its yielded\n references is tied to its own lifetime, instead of just the underlying map. This means\n cursors cannot yield multiple elements at once.\n\n Cursors always point to a gap between two elements in the map, and can\n operate on the two immediately adjacent elements.\n\n A `CursorMutKey` is created from a [`CursorMut`] with the\n [`CursorMut::with_mutable_key`] method.\n\n # Safety\n\n Since this cursor allows mutating keys, you must ensure that the `BTreeMap`\n invariants are maintained. Specifically:\n\n * The key of the newly inserted element must be unique in the tree.\n * All keys in the tree must remain in sorted order.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "current",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "root",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "length",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "alloc",
      "doc": ""
    }
  }
}