{
  "name": "raw_vec::RawVec",
  "constructors": [
    "raw_vec::RawVec::<T>::new",
    "raw_vec::RawVec::<T>::with_capacity",
    "raw_vec::RawVec::<T>::with_capacity_zeroed",
    "raw_vec::RawVec::<T, A>::new_in",
    "raw_vec::RawVec::<T, A>::with_capacity_in",
    "raw_vec::RawVec::<T, A>::try_with_capacity_in",
    "raw_vec::RawVec::<T, A>::with_capacity_zeroed_in",
    "raw_vec::RawVec::<T, A>::from_raw_parts_in",
    "raw_vec::RawVec::<T, A>::from_nonnull_in"
  ],
  "access_self_as_arg": {
    "read": [
      "raw_vec::RawVec::<T, A>::into_box",
      "raw_vec::RawVec::<T, A>::ptr",
      "raw_vec::RawVec::<T, A>::non_null",
      "raw_vec::RawVec::<T, A>::capacity",
      "raw_vec::RawVec::<T, A>::allocator"
    ],
    "write": [
      "raw_vec::RawVec::<T, A>::reserve",
      "raw_vec::RawVec::<T, A>::grow_one",
      "raw_vec::RawVec::<T, A>::try_reserve",
      "raw_vec::RawVec::<T, A>::reserve_exact",
      "raw_vec::RawVec::<T, A>::try_reserve_exact",
      "raw_vec::RawVec::<T, A>::shrink_to_fit",
      "<raw_vec::RawVec<T, A> as core::ops::Drop>::drop"
    ],
    "other": [
      "raw_vec::RawVec::<T, A>::into_box"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "collections::vec_deque::VecDeque::<T, A>::ptr",
      "collections::vec_deque::VecDeque::<T, A>::capacity",
      "collections::vec_deque::VecDeque::<T, A>::allocator",
      "collections::vec_deque::<impl core::convert::From<collections::vec_deque::VecDeque<T, A>> for vec::Vec<T, A>>::from",
      "vec::into_iter::IntoIter::<T, A>::forget_allocation_drop_remaining",
      "vec::Vec::<T, A>::capacity",
      "vec::Vec::<T, A>::into_boxed_slice",
      "vec::Vec::<T, A>::as_ptr",
      "vec::Vec::<T, A>::as_mut_ptr",
      "vec::Vec::<T, A>::as_non_null",
      "vec::Vec::<T, A>::allocator",
      "vec::Vec::<T, A>::insert_mut",
      "vec::Vec::<T, A>::push_within_capacity",
      "vec::Vec::<T, A>::push_mut",
      "vec::Vec::<T, A>::spare_capacity_mut",
      "vec::Vec::<T, A>::split_at_spare_mut_with_len",
      "<vec::Vec<T, A> as core::iter::IntoIterator>::into_iter"
    ],
    "write": [
      "collections::vec_deque::VecDeque::<T, A>::reserve_exact",
      "collections::vec_deque::VecDeque::<T, A>::reserve",
      "collections::vec_deque::VecDeque::<T, A>::try_reserve_exact",
      "collections::vec_deque::VecDeque::<T, A>::try_reserve",
      "collections::vec_deque::VecDeque::<T, A>::shrink_to",
      "collections::vec_deque::VecDeque::<T, A>::grow",
      "vec::splice::<impl vec::drain::Drain<'_, T, A>>::move_tail",
      "vec::Vec::<T, A>::reserve",
      "vec::Vec::<T, A>::reserve_exact",
      "vec::Vec::<T, A>::try_reserve",
      "vec::Vec::<T, A>::try_reserve_exact",
      "vec::Vec::<T, A>::shrink_to_fit",
      "vec::Vec::<T, A>::shrink_to",
      "vec::Vec::<T, A>::insert_mut",
      "vec::Vec::<T, A>::push_mut",
      "vec::Vec::<T, A>::into_chunks",
      "vec::Vec::<T, A>::into_boxed_slice"
    ],
    "other": [
      "raw_vec::RawVec::<T>::new",
      "raw_vec::RawVec::<T>::with_capacity",
      "raw_vec::RawVec::<T>::with_capacity_zeroed",
      "raw_vec::RawVec::<T, A>::new_in",
      "raw_vec::RawVec::<T, A>::with_capacity_in",
      "raw_vec::RawVec::<T, A>::try_with_capacity_in",
      "raw_vec::RawVec::<T, A>::with_capacity_zeroed_in",
      "raw_vec::RawVec::<T, A>::from_raw_parts_in",
      "raw_vec::RawVec::<T, A>::from_nonnull_in",
      "boxed::Box::<[T]>::new_uninit_slice",
      "boxed::Box::<[T]>::new_zeroed_slice",
      "boxed::Box::<[T]>::try_new_uninit_slice",
      "boxed::Box::<[T]>::try_new_zeroed_slice",
      "boxed::Box::<[T], A>::new_uninit_slice_in",
      "boxed::Box::<[T], A>::new_zeroed_slice_in",
      "boxed::Box::<[T], A>::try_new_uninit_slice_in",
      "boxed::Box::<[T], A>::try_new_zeroed_slice_in",
      "collections::vec_deque::VecDeque::<T>::new",
      "collections::vec_deque::VecDeque::<T>::try_with_capacity",
      "collections::vec_deque::VecDeque::<T, A>::new_in",
      "collections::vec_deque::VecDeque::<T, A>::with_capacity_in",
      "collections::vec_deque::VecDeque::<T, A>::from_contiguous_raw_parts_in",
      "<collections::vec_deque::VecDeque<T, A> as core::convert::From<vec::Vec<T, A>>>::from",
      "vec::into_iter::IntoIter::<T, A>::forget_allocation_drop_remaining",
      "<<vec::into_iter::IntoIter<T, A> as core::ops::Drop>::drop::DropGuard<'_, T, A> as core::ops::Drop>::drop",
      "<T as vec::spec_from_elem::SpecFromElem>::from_elem",
      "<i8 as vec::spec_from_elem::SpecFromElem>::from_elem",
      "<u8 as vec::spec_from_elem::SpecFromElem>::from_elem",
      "<vec::in_place_drop::InPlaceDstDataSrcBufDrop<Src, Dest> as core::ops::Drop>::drop",
      "vec::Vec::<T>::new",
      "vec::Vec::<T, A>::new_in",
      "vec::Vec::<T, A>::with_capacity_in",
      "vec::Vec::<T, A>::try_with_capacity_in",
      "vec::Vec::<T, A>::from_raw_parts_in",
      "vec::Vec::<T, A>::from_parts_in",
      "vec::Vec::<T, A>::into_boxed_slice"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "raw_vec::RawVec::<T, A>::into_box",
        "raw_vec::RawVec::<T, A>::ptr",
        "raw_vec::RawVec::<T, A>::non_null",
        "raw_vec::RawVec::<T, A>::capacity",
        "raw_vec::RawVec::<T, A>::allocator",
        "raw_vec::RawVec::<T, A>::reserve",
        "raw_vec::RawVec::<T, A>::grow_one",
        "raw_vec::RawVec::<T, A>::try_reserve",
        "raw_vec::RawVec::<T, A>::reserve_exact",
        "raw_vec::RawVec::<T, A>::try_reserve_exact",
        "raw_vec::RawVec::<T, A>::shrink_to_fit",
        "<raw_vec::RawVec<T, A> as core::ops::Drop>::drop"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/alloc/src/raw_vec/mod.rs:73:1: 73:51",
  "src": "pub(crate) struct RawVec<T, A: Allocator = Global>",
  "kind": "Struct",
  "doc_adt": " A low-level utility for more ergonomically allocating, reallocating, and deallocating\n a buffer of memory on the heap without having to worry about all the corner cases\n involved. This type is excellent for building your own data structures like Vec and VecDeque.\n In particular:\n\n * Produces `Unique::dangling()` on zero-sized types.\n * Produces `Unique::dangling()` on zero-length allocations.\n * Avoids freeing `Unique::dangling()`.\n * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n * Guards against 32-bit systems allocating more than `isize::MAX` bytes.\n * Guards against overflowing your length.\n * Calls `handle_alloc_error` for fallible allocations.\n * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n * Uses the excess returned from the allocator to use the largest available capacity.\n\n This type does not in anyway inspect the memory that it manages. When dropped it *will*\n free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n to handle the actual things *stored* inside of a `RawVec`.\n\n Note that the excess of a zero-sized types is always infinite, so `capacity()` always returns\n `usize::MAX`. This means that you need to be careful when round-tripping this type with a\n `Box<[T]>`, since `capacity()` won't yield the length.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    }
  }
}