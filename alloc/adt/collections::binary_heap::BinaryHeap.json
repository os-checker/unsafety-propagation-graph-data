{
  "name": "collections::binary_heap::BinaryHeap",
  "constructors": [
    "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone",
    "<collections::binary_heap::BinaryHeap<T> as core::default::Default>::default",
    "collections::binary_heap::BinaryHeap::<T>::new",
    "collections::binary_heap::BinaryHeap::<T>::with_capacity",
    "collections::binary_heap::BinaryHeap::<T, A>::new_in",
    "collections::binary_heap::BinaryHeap::<T, A>::with_capacity_in",
    "<collections::binary_heap::BinaryHeap<T, A> as core::convert::From<vec::Vec<T, A>>>::from",
    "<collections::binary_heap::BinaryHeap<T> as core::convert::From<[T; N]>>::from",
    "<collections::binary_heap::BinaryHeap<T> as core::iter::FromIterator<T>>::from_iter"
  ],
  "access_self_as_arg": {
    "read": [
      "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone",
      "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone_from",
      "<collections::binary_heap::BinaryHeap<T, A> as core::fmt::Debug>::fmt",
      "collections::binary_heap::BinaryHeap::<T, A>::peek_mut",
      "collections::binary_heap::BinaryHeap::<T, A>::push",
      "collections::binary_heap::BinaryHeap::<T, A>::into_sorted_vec",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down_to_bottom",
      "collections::binary_heap::BinaryHeap::<T, A>::rebuild_tail",
      "collections::binary_heap::BinaryHeap::<T, A>::rebuild",
      "collections::binary_heap::BinaryHeap::<T, A>::append",
      "collections::binary_heap::BinaryHeap::<T, A>::retain",
      "collections::binary_heap::BinaryHeap::<T, A>::iter",
      "collections::binary_heap::BinaryHeap::<T, A>::peek",
      "collections::binary_heap::BinaryHeap::<T, A>::capacity",
      "collections::binary_heap::BinaryHeap::<T, A>::as_slice",
      "collections::binary_heap::BinaryHeap::<T, A>::allocator",
      "collections::binary_heap::BinaryHeap::<T, A>::len",
      "collections::binary_heap::BinaryHeap::<T, A>::is_empty",
      "<&'a collections::binary_heap::BinaryHeap<T, A> as core::iter::IntoIterator>::into_iter",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<T>>::extend"
    ],
    "write": [
      "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone_from",
      "collections::binary_heap::BinaryHeap::<T, A>::peek_mut",
      "collections::binary_heap::BinaryHeap::<T, A>::pop",
      "collections::binary_heap::BinaryHeap::<T, A>::push",
      "collections::binary_heap::BinaryHeap::<T, A>::into_sorted_vec",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_up",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down_range",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down_to_bottom",
      "collections::binary_heap::BinaryHeap::<T, A>::rebuild_tail",
      "collections::binary_heap::BinaryHeap::<T, A>::rebuild",
      "collections::binary_heap::BinaryHeap::<T, A>::append",
      "collections::binary_heap::BinaryHeap::<T, A>::drain_sorted",
      "collections::binary_heap::BinaryHeap::<T, A>::retain",
      "collections::binary_heap::BinaryHeap::<T, A>::reserve_exact",
      "collections::binary_heap::BinaryHeap::<T, A>::reserve",
      "collections::binary_heap::BinaryHeap::<T, A>::try_reserve_exact",
      "collections::binary_heap::BinaryHeap::<T, A>::try_reserve",
      "collections::binary_heap::BinaryHeap::<T, A>::shrink_to_fit",
      "collections::binary_heap::BinaryHeap::<T, A>::shrink_to",
      "collections::binary_heap::BinaryHeap::<T, A>::drain",
      "collections::binary_heap::BinaryHeap::<T, A>::clear",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<T>>::extend",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<T>>::extend_one",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<T>>::extend_reserve",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<&'a T>>::extend",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<&'a T>>::extend_one",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<&'a T>>::extend_reserve",
      "collections::binary_heap::BinaryHeap::<T, A>::peek_mut",
      "collections::binary_heap::BinaryHeap::<T, A>::push",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down",
      "collections::binary_heap::BinaryHeap::<T, A>::sift_down_to_bottom",
      "collections::binary_heap::BinaryHeap::<T, A>::rebuild_tail",
      "collections::binary_heap::BinaryHeap::<T, A>::rebuild",
      "collections::binary_heap::BinaryHeap::<T, A>::append",
      "collections::binary_heap::BinaryHeap::<T, A>::retain",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<T>>::extend"
    ],
    "other": [
      "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone",
      "collections::binary_heap::BinaryHeap::<T, A>::into_sorted_vec",
      "collections::binary_heap::BinaryHeap::<T, A>::into_iter_sorted",
      "collections::binary_heap::BinaryHeap::<T, A>::into_vec",
      "collections::binary_heap::<impl core::convert::From<collections::binary_heap::BinaryHeap<T, A>> for vec::Vec<T, A>>::from",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::IntoIterator>::into_iter",
      "collections::binary_heap::BinaryHeap::<T, A>::into_sorted_vec",
      "collections::binary_heap::<impl core::convert::From<collections::binary_heap::BinaryHeap<T, A>> for vec::Vec<T, A>>::from",
      "<collections::binary_heap::BinaryHeap<T, A> as core::iter::IntoIterator>::into_iter"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::Deref>::deref",
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::DerefMut>::deref_mut",
      "collections::binary_heap::IntoIterSorted::<T, A>::allocator",
      "<collections::binary_heap::IntoIterSorted<T, A> as core::iter::Iterator>::size_hint",
      "collections::binary_heap::DrainSorted::<'a, T, A>::allocator",
      "<collections::binary_heap::DrainSorted<'_, T, A> as core::iter::Iterator>::size_hint",
      "<collections::binary_heap::IntoIterSorted<T, A> as core::clone::Clone>::clone",
      "<collections::binary_heap::IntoIterSorted<T, A> as core::fmt::Debug>::fmt"
    ],
    "write": [
      "<collections::binary_heap::PeekMut<'_, T, A> as core::fmt::Debug>::fmt",
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::Drop>::drop",
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::Deref>::deref",
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::DerefMut>::deref_mut",
      "collections::binary_heap::PeekMut::<'a, T, A>::refresh",
      "collections::binary_heap::PeekMut::<'a, T, A>::pop",
      "<collections::binary_heap::RebuildOnDrop<'_, T, A> as core::ops::Drop>::drop",
      "<collections::binary_heap::IntoIterSorted<T, A> as core::iter::Iterator>::next",
      "collections::binary_heap::DrainSorted::<'a, T, A>::allocator",
      "<collections::binary_heap::DrainSorted<'a, T, A> as core::ops::Drop>::drop",
      "<<collections::binary_heap::DrainSorted<'a, T, A> as core::ops::Drop>::drop::DropGuard<'r, 'a, T, A> as core::ops::Drop>::drop",
      "<collections::binary_heap::DrainSorted<'_, T, A> as core::iter::Iterator>::next",
      "<collections::binary_heap::DrainSorted<'_, T, A> as core::iter::Iterator>::size_hint",
      "<collections::binary_heap::BinaryHeap<T, A> as core::convert::From<vec::Vec<T, A>>>::from",
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::Deref>::deref",
      "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::DerefMut>::deref_mut",
      "collections::binary_heap::DrainSorted::<'a, T, A>::allocator",
      "<collections::binary_heap::DrainSorted<'_, T, A> as core::iter::Iterator>::size_hint"
    ],
    "other": [
      "<collections::binary_heap::BinaryHeap<T> as core::default::Default>::default",
      "collections::binary_heap::BinaryHeap::<T>::new",
      "collections::binary_heap::BinaryHeap::<T>::with_capacity",
      "collections::binary_heap::BinaryHeap::<T, A>::new_in",
      "collections::binary_heap::BinaryHeap::<T, A>::with_capacity_in",
      "<collections::binary_heap::BinaryHeap<T, A> as core::convert::From<vec::Vec<T, A>>>::from",
      "<collections::binary_heap::BinaryHeap<T> as core::convert::From<[T; N]>>::from",
      "<collections::binary_heap::BinaryHeap<T> as core::iter::FromIterator<T>>::from_iter",
      "<collections::binary_heap::IntoIterSorted<T, A> as core::clone::Clone>::clone"
    ]
  },
  "access_field": [
    {
      "read": [
        "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone",
        "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone_from",
        "collections::binary_heap::BinaryHeap::<T, A>::iter",
        "collections::binary_heap::BinaryHeap::<T, A>::peek",
        "collections::binary_heap::BinaryHeap::<T, A>::capacity",
        "collections::binary_heap::BinaryHeap::<T, A>::as_slice",
        "collections::binary_heap::BinaryHeap::<T, A>::allocator",
        "collections::binary_heap::BinaryHeap::<T, A>::len"
      ],
      "write": [
        "<collections::binary_heap::PeekMut<'_, T, A> as core::fmt::Debug>::fmt",
        "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::Drop>::drop",
        "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::Deref>::deref",
        "<collections::binary_heap::PeekMut<'_, T, A> as core::ops::DerefMut>::deref_mut",
        "collections::binary_heap::PeekMut::<'a, T, A>::refresh",
        "collections::binary_heap::PeekMut::<'a, T, A>::pop",
        "<collections::binary_heap::BinaryHeap<T, A> as core::clone::Clone>::clone_from",
        "collections::binary_heap::BinaryHeap::<T, A>::pop",
        "collections::binary_heap::BinaryHeap::<T, A>::push",
        "collections::binary_heap::BinaryHeap::<T, A>::sift_up",
        "collections::binary_heap::BinaryHeap::<T, A>::sift_down_range",
        "collections::binary_heap::BinaryHeap::<T, A>::sift_down_to_bottom",
        "collections::binary_heap::BinaryHeap::<T, A>::append",
        "collections::binary_heap::BinaryHeap::<T, A>::retain",
        "collections::binary_heap::BinaryHeap::<T, A>::reserve_exact",
        "collections::binary_heap::BinaryHeap::<T, A>::reserve",
        "collections::binary_heap::BinaryHeap::<T, A>::try_reserve_exact",
        "collections::binary_heap::BinaryHeap::<T, A>::try_reserve",
        "collections::binary_heap::BinaryHeap::<T, A>::shrink_to_fit",
        "collections::binary_heap::BinaryHeap::<T, A>::shrink_to",
        "collections::binary_heap::BinaryHeap::<T, A>::drain",
        "<collections::binary_heap::BinaryHeap<T, A> as core::iter::Extend<T>>::extend"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/collections/binary_heap/mod.rs:274:1: 277:2",
  "src": "pub struct BinaryHeap<\n    T,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n>",
  "kind": "Struct",
  "doc_adt": " A priority queue implemented with a binary heap.\n\n This will be a max-heap.\n\n It is a logic error for an item to be modified in such a way that the\n item's ordering relative to any other item, as determined by the [`Ord`]\n trait, changes while it is in the heap. This is normally only possible\n through interior mutability, global state, I/O, or unsafe code. The\n behavior resulting from such a logic error is not specified, but will\n be encapsulated to the `BinaryHeap` that observed the logic error and not\n result in undefined behavior. This could include panics, incorrect results,\n aborts, memory leaks, and non-termination.\n\n As long as no elements change their relative order while being in the heap\n as described above, the API of `BinaryHeap` guarantees that the heap\n invariant remains intact i.e. its methods all behave as documented. For\n example if a method is documented as iterating in sorted order, that's\n guaranteed to work as long as elements in the heap have not changed order,\n even in the presence of closures getting unwinded out of, iterators getting\n leaked, and similar foolishness.\n\n # Examples\n\n ```\n use std::collections::BinaryHeap;\n\n // Type inference lets us omit an explicit type signature (which\n // would be `BinaryHeap<i32>` in this example).\n let mut heap = BinaryHeap::new();\n\n // We can use peek to look at the next item in the heap. In this case,\n // there's no items in there yet so we get None.\n assert_eq!(heap.peek(), None);\n\n // Let's add some scores...\n heap.push(1);\n heap.push(5);\n heap.push(2);\n\n // Now peek shows the most important item in the heap.\n assert_eq!(heap.peek(), Some(&5));\n\n // We can check the length of a heap.\n assert_eq!(heap.len(), 3);\n\n // We can iterate over the items in the heap, although they are returned in\n // a random order.\n for x in &heap {\n     println!(\"{x}\");\n }\n\n // If we instead pop these scores, they should come back in order.\n assert_eq!(heap.pop(), Some(5));\n assert_eq!(heap.pop(), Some(2));\n assert_eq!(heap.pop(), Some(1));\n assert_eq!(heap.pop(), None);\n\n // We can clear the heap of any remaining items.\n heap.clear();\n\n // The heap should now be empty.\n assert!(heap.is_empty())\n ```\n\n A `BinaryHeap` with a known list of items can be initialized from an array:\n\n ```\n use std::collections::BinaryHeap;\n\n let heap = BinaryHeap::from([1, 5, 2]);\n ```\n\n ## Min-heap\n\n Either [`core::cmp::Reverse`] or a custom [`Ord`] implementation can be used to\n make `BinaryHeap` a min-heap. This makes `heap.pop()` return the smallest\n value instead of the greatest one.\n\n ```\n use std::collections::BinaryHeap;\n use std::cmp::Reverse;\n\n let mut heap = BinaryHeap::new();\n\n // Wrap values in `Reverse`\n heap.push(Reverse(1));\n heap.push(Reverse(5));\n heap.push(Reverse(2));\n\n // If we pop these scores now, they should come back in the reverse order.\n assert_eq!(heap.pop(), Some(Reverse(1)));\n assert_eq!(heap.pop(), Some(Reverse(2)));\n assert_eq!(heap.pop(), Some(Reverse(5)));\n assert_eq!(heap.pop(), None);\n ```\n\n # Time complexity\n\n | [push]  | [pop]         | [peek]/[peek\\_mut] |\n |---------|---------------|--------------------|\n | *O*(1)~ | *O*(log(*n*)) | *O*(1)             |\n\n The value for `push` is an expected cost; the method documentation gives a\n more detailed analysis.\n\n [`core::cmp::Reverse`]: core::cmp::Reverse\n [`Cell`]: core::cell::Cell\n [`RefCell`]: core::cell::RefCell\n [push]: BinaryHeap::push\n [pop]: BinaryHeap::pop\n [peek]: BinaryHeap::peek\n [peek\\_mut]: BinaryHeap::peek_mut\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "data",
      "doc": ""
    }
  }
}