{
  "name": "core::fmt::Arguments",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "fmt::format",
      "fmt::format::format_inner",
      "<core::fmt::Arguments<'_> as string::SpecToString>::spec_to_string"
    ],
    "write": [
      "<core::fmt::Arguments<'_> as string::SpecToString>::spec_to_string"
    ],
    "other": [
      "fmt::format",
      "fmt::format::format_inner",
      "<core::fmt::Arguments<'_> as string::SpecToString>::spec_to_string"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "raw_vec::capacity_overflow",
      "raw_vec::RawVec::<T, A>::into_box",
      "raw_vec::RawVecInner::<A>::shrink",
      "alloc::Global::grow_impl",
      "<alloc::Global as core::alloc::Allocator>::shrink",
      "alloc::handle_alloc_error::ct_error",
      "alloc::__alloc_error_handler::__rdl_alloc_error_handler",
      "<collections::btree::map::entry::OccupiedError<'a, K, V, A> as core::fmt::Display>::fmt",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::get_or_insert_with",
      "<collections::btree::map::UnorderedKeyError as core::fmt::Display>::fmt",
      "collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::find_leaf_edges_spanning_range",
      "collections::btree::node::NodeRef::<collections::btree::node::marker::Mut<'a>, K, V, collections::btree::node::marker::LeafOrInternal>::choose_parent_kv",
      "collections::btree::search::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::search_tree_for_bifurcation",
      "collections::linked_list::LinkedList::<T, A>::split_off",
      "collections::linked_list::LinkedList::<T, A>::remove",
      "<collections::vec_deque::VecDeque<T, A> as collections::vec_deque::spec_extend::SpecExtend<T, I>>::spec_extend",
      "collections::vec_deque::VecDeque::<T, A>::nonoverlapping_ranges",
      "collections::vec_deque::VecDeque::<T, A>::copy",
      "collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping",
      "collections::vec_deque::VecDeque::<T, A>::wrap_copy",
      "collections::vec_deque::VecDeque::<T, A>::insert_mut",
      "collections::vec_deque::VecDeque::<T, A>::split_off",
      "<ffi::c_str::NulError as core::fmt::Display>::fmt",
      "<ffi::c_str::FromVecWithNulError as core::fmt::Display>::fmt",
      "rc::Rc::<T, A>::new_cyclic_in",
      "<I as rc::ToRcSlice<T>>::to_rc_slice",
      "<rc::Weak<T, A> as core::fmt::Debug>::fmt",
      "string::String::remove",
      "<sync::Weak<T, A> as core::fmt::Debug>::fmt",
      "sync::Arc::<T, A>::new_cyclic_in",
      "<sync::Arc<T, A> as core::ops::Drop>::drop",
      "<sync::Weak<T, A> as core::ops::Drop>::drop",
      "<I as sync::ToArcSlice<T>>::to_arc_slice",
      "vec::in_place_collect::needs_realloc",
      "vec::in_place_collect::from_iter_in_place",
      "<I as vec::in_place_collect::SpecInPlaceCollect<T, I>>::collect_in_place",
      "<vec::Vec<T> as vec::spec_from_iter_nested::SpecFromIterNested<T, I>>::from_iter",
      "vec::Vec::<T, A>::swap_remove::assert_failed",
      "vec::Vec::<T, A>::insert_mut::assert_failed",
      "vec::Vec::<T, A>::remove::assert_failed",
      "vec::Vec::<T, A>::split_off::assert_failed",
      "vec::Vec::<T, A>::extend_trusted",
      "vec::Vec::<T, A>::from_raw_parts_in::precondition_check",
      "vec::Vec::<T, A>::from_parts_in::precondition_check",
      "vec::Vec::<T, A>::set_len::precondition_check"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:716:1: 716:25",
  "src": "pub struct Arguments<'a>",
  "kind": "Struct",
  "doc_adt": " This structure represents a safely precompiled version of a format string\n and its arguments. This cannot be generated at runtime because it cannot\n safely be done, so no constructors are given and the fields are private\n to prevent modification.\n\n The [`format_args!`] macro will safely create an instance of this structure.\n The macro validates the format string at compile-time so usage of the\n [`write()`] and [`format()`] functions can be safely performed.\n\n You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n and `Display` contexts as seen below. The example also shows that `Debug`\n and `Display` format to the same thing: the interpolated format string\n in `format_args!`.\n\n ```rust\n let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n assert_eq!(\"1 foo 2\", display);\n assert_eq!(display, debug);\n ```\n\n [`format()`]: ../../std/fmt/fn.format.html\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "template",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "args",
      "doc": ""
    }
  }
}