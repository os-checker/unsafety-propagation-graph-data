{
  "name": "core::cell::Cell",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "rc::Rc::<T, A>::new_cyclic_in",
      "rc::Weak::<T, A>::inner",
      "rc::RcInnerPtr::strong",
      "rc::RcInnerPtr::inc_strong",
      "rc::RcInnerPtr::dec_strong",
      "rc::RcInnerPtr::weak",
      "rc::RcInnerPtr::inc_weak",
      "rc::RcInnerPtr::dec_weak",
      "<rc::RcInner<T> as rc::RcInnerPtr>::weak_ref",
      "<rc::RcInner<T> as rc::RcInnerPtr>::strong_ref",
      "<rc::WeakInner<'a> as rc::RcInnerPtr>::weak_ref",
      "<rc::WeakInner<'a> as rc::RcInnerPtr>::strong_ref",
      "rc::UniqueRc::<T, A>::into_rc"
    ],
    "write": [],
    "other": [
      "rc::Rc::<T>::new",
      "rc::Rc::<T>::try_new",
      "rc::Rc::<T, A>::new_cyclic_in",
      "rc::Rc::<T, A>::try_new_in",
      "rc::Rc::<T>::try_allocate_for_layout",
      "<rc::Rc<T> as core::default::Default>::default",
      "rc::UniqueRc::<T, A>::new_in"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:313:1: 313:27",
  "src": "pub struct Cell<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A mutable memory location.\n\n # Memory layout\n\n `Cell<T>` has the same [memory layout and caveats as\n `UnsafeCell<T>`](UnsafeCell#memory-layout). In particular, this means that\n `Cell<T>` has the same in-memory representation as its inner type `T`.\n\n # Examples\n\n In this example, you can see that `Cell<T>` enables mutation inside an\n immutable struct. In other words, it enables \"interior mutability\".\n\n ```\n use std::cell::Cell;\n\n struct SomeStruct {\n     regular_field: u8,\n     special_field: Cell<u8>,\n }\n\n let my_struct = SomeStruct {\n     regular_field: 0,\n     special_field: Cell::new(1),\n };\n\n let new_value = 100;\n\n // ERROR: `my_struct` is immutable\n // my_struct.regular_field = new_value;\n\n // WORKS: although `my_struct` is immutable, `special_field` is a `Cell`,\n // which can always be mutated\n my_struct.special_field.set(new_value);\n assert_eq!(my_struct.special_field.get(), new_value);\n ```\n\n See the [module-level documentation](self) for more.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}