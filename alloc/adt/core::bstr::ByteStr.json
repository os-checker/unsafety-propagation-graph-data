{
  "name": "core::bstr::ByteStr",
  "constructors": [
    "bstr::<impl core::convert::From<bstr::ByteString> for borrow::Cow<'a, core::bstr::ByteStr>>::from",
    "bstr::<impl core::convert::From<&'a bstr::ByteString> for borrow::Cow<'a, core::bstr::ByteStr>>::from",
    "bstr::<impl core::clone::Clone for boxed::Box<core::bstr::ByteStr>>::clone",
    "bstr::<impl core::convert::From<&'a core::bstr::ByteStr> for borrow::Cow<'a, core::bstr::ByteStr>>::from",
    "bstr::<impl core::convert::From<boxed::Box<[u8]>> for boxed::Box<core::bstr::ByteStr>>::from",
    "bstr::<impl core::convert::From<rc::Rc<[u8]>> for rc::Rc<core::bstr::ByteStr>>::from",
    "bstr::<impl core::convert::From<sync::Arc<[u8]>> for sync::Arc<core::bstr::ByteStr>>::from"
  ],
  "access_self_as_arg": {
    "read": [
      "<bstr::ByteString as core::convert::From<&'a core::bstr::ByteStr>>::from",
      "bstr::<impl borrow::ToOwned for core::bstr::ByteStr>::to_owned",
      "bstr::<impl core::convert::From<&'a core::bstr::ByteStr> for borrow::Cow<'a, core::bstr::ByteStr>>::from",
      "bstr::<impl core::convert::TryFrom<&'a core::bstr::ByteStr> for string::String>::try_from",
      "<bstr::ByteString as core::cmp::PartialOrd<core::bstr::ByteStr>>::partial_cmp",
      "bstr::<impl core::cmp::PartialOrd<bstr::ByteString> for core::bstr::ByteStr>::partial_cmp",
      "<bstr::ByteString as core::cmp::PartialEq<core::bstr::ByteStr>>::eq",
      "bstr::<impl core::cmp::PartialEq<bstr::ByteString> for core::bstr::ByteStr>::eq",
      "bstr::<impl core::cmp::PartialEq<vec::Vec<u8>> for core::bstr::ByteStr>::eq",
      "bstr::<impl core::cmp::PartialEq<core::bstr::ByteStr> for vec::Vec<u8>>::eq",
      "bstr::<impl core::cmp::PartialEq<string::String> for core::bstr::ByteStr>::eq",
      "bstr::<impl core::cmp::PartialEq<core::bstr::ByteStr> for string::String>::eq"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "bstr::ByteString::as_bytestr",
      "<bstr::ByteString as core::fmt::Debug>::fmt",
      "<bstr::ByteString as core::fmt::Display>::fmt",
      "<bstr::ByteString as core::convert::AsRef<core::bstr::ByteStr>>::as_ref",
      "<bstr::ByteString as core::borrow::Borrow<core::bstr::ByteStr>>::borrow",
      "bstr::<impl core::convert::From<&'a bstr::ByteString> for borrow::Cow<'a, core::bstr::ByteStr>>::from",
      "<bstr::ByteString as core::iter::FromIterator<&'a core::bstr::ByteStr>>::from_iter",
      "<bstr::ByteString as core::ops::Index<core::ops::RangeFull>>::index",
      "<bstr::ByteString as core::ops::Index<core::ops::Range<usize>>>::index",
      "<bstr::ByteString as core::ops::Index<core::ops::RangeInclusive<usize>>>::index",
      "<bstr::ByteString as core::ops::Index<core::ops::RangeFrom<usize>>>::index",
      "<bstr::ByteString as core::ops::Index<core::ops::RangeTo<usize>>>::index",
      "<bstr::ByteString as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index",
      "<bstr::ByteString as core::cmp::PartialEq<borrow::Cow<'_, core::bstr::ByteStr>>>::eq",
      "bstr::<impl core::cmp::PartialEq<bstr::ByteString> for borrow::Cow<'_, core::bstr::ByteStr>>::eq",
      "<bstr::ByteString as core::cmp::PartialOrd<borrow::Cow<'_, core::bstr::ByteStr>>>::partial_cmp",
      "bstr::<impl core::cmp::PartialOrd<bstr::ByteString> for borrow::Cow<'_, core::bstr::ByteStr>>::partial_cmp",
      "bstr::<impl core::cmp::PartialEq<borrow::Cow<'a, core::bstr::ByteStr>> for &'a core::bstr::ByteStr>::eq",
      "bstr::<impl core::cmp::PartialEq<&'a core::bstr::ByteStr> for borrow::Cow<'a, core::bstr::ByteStr>>::eq",
      "bstr::<impl core::cmp::PartialOrd<borrow::Cow<'a, core::bstr::ByteStr>> for &'a core::bstr::ByteStr>::partial_cmp",
      "bstr::<impl core::cmp::PartialOrd<&'a core::bstr::ByteStr> for borrow::Cow<'a, core::bstr::ByteStr>>::partial_cmp",
      "bstr::<impl core::cmp::PartialEq<borrow::Cow<'a, str>> for &'a core::bstr::ByteStr>::eq",
      "bstr::<impl core::cmp::PartialEq<&'a core::bstr::ByteStr> for borrow::Cow<'a, str>>::eq",
      "bstr::<impl core::cmp::PartialOrd<borrow::Cow<'a, str>> for &'a core::bstr::ByteStr>::partial_cmp",
      "bstr::<impl core::cmp::PartialOrd<&'a core::bstr::ByteStr> for borrow::Cow<'a, str>>::partial_cmp",
      "bstr::<impl core::cmp::PartialEq<borrow::Cow<'a, [u8]>> for &'a core::bstr::ByteStr>::eq",
      "bstr::<impl core::cmp::PartialEq<&'a core::bstr::ByteStr> for borrow::Cow<'a, [u8]>>::eq",
      "bstr::<impl core::cmp::PartialOrd<borrow::Cow<'a, [u8]>> for &'a core::bstr::ByteStr>::partial_cmp",
      "bstr::<impl core::cmp::PartialOrd<&'a core::bstr::ByteStr> for borrow::Cow<'a, [u8]>>::partial_cmp"
    ],
    "write": [
      "bstr::ByteString::as_mut_bytestr",
      "<bstr::ByteString as core::convert::AsMut<core::bstr::ByteStr>>::as_mut",
      "<bstr::ByteString as core::borrow::BorrowMut<core::bstr::ByteStr>>::borrow_mut",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeFull>>::index_mut",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeInclusive<usize>>>::index_mut",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeFrom<usize>>>::index_mut",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeTo<usize>>>::index_mut",
      "<bstr::ByteString as core::ops::IndexMut<core::ops::RangeToInclusive<usize>>>::index_mut"
    ],
    "other": []
  },
  "access_field": [
    {
      "read": [
        "<bstr::ByteString as core::convert::From<&'a core::bstr::ByteStr>>::from",
        "<bstr::ByteString as core::iter::FromIterator<&'a core::bstr::ByteStr>>::from_iter",
        "bstr::<impl borrow::ToOwned for core::bstr::ByteStr>::to_owned",
        "bstr::<impl core::convert::TryFrom<&'a core::bstr::ByteStr> for string::String>::try_from"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/bstr/mod.rs:43:1: 43:19",
  "src": "pub struct ByteStr",
  "kind": "Struct",
  "doc_adt": " A wrapper for `&[u8]` representing a human-readable string that's conventionally, but not\n always, UTF-8.\n\n Unlike `&str`, this type permits non-UTF-8 contents, making it suitable for user input,\n non-native filenames (as `Path` only supports native filenames), and other applications that\n need to round-trip whatever data the user provides.\n\n For an owned, growable byte string buffer, use\n [`ByteString`](../../std/bstr/struct.ByteString.html).\n\n `ByteStr` implements `Deref` to `[u8]`, so all methods available on `[u8]` are available on\n `ByteStr`.\n\n # Representation\n\n A `&ByteStr` has the same representation as a `&str`. That is, a `&ByteStr` is a wide pointer\n which includes a pointer to some bytes and a length.\n\n # Trait implementations\n\n The `ByteStr` type has a number of trait implementations, and in particular, defines equality\n and comparisons between `&ByteStr`, `&str`, and `&[u8]`, for convenience.\n\n The `Debug` implementation for `ByteStr` shows its bytes as a normal string, with invalid UTF-8\n presented as hex escape sequences.\n\n The `Display` implementation behaves as if the `ByteStr` were first lossily converted to a\n `str`, with invalid UTF-8 presented as the Unicode replacement character (ï¿½).\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}