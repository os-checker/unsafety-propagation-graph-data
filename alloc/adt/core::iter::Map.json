{
  "name": "core::iter::Map",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::str::join_generic_copy"
    ],
    "other": [
      "alloc::<collections::btree::map::ValuesMut<'_, K, V> as core::fmt::Debug>::fmt",
      "alloc::<collections::btree::map::IntoKeys<K, V, A> as core::fmt::Debug>::fmt",
      "alloc::<collections::btree::map::IntoValues<K, V, A> as core::fmt::Debug>::fmt",
      "alloc::<collections::btree::map::BTreeMap<K, V, A> as core::iter::Extend<(&'a K, &'a V)>>::extend",
      "alloc::collections::btree::set::BTreeSet::<T, A>::from_sorted_iter",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::Iterator>::try_fold",
      "alloc::<collections::vec_deque::into_iter::IntoIter<T, A> as core::iter::DoubleEndedIterator>::try_rfold",
      "alloc::slice::<impl [T]>::sort_by_cached_key",
      "alloc::<[V] as slice::Concat<T>>::concat",
      "alloc::<[V] as slice::Join<&T>>::join",
      "alloc::<[V] as slice::Join<&[T]>>::join",
      "alloc::str::join_generic_copy",
      "alloc::str::convert_while_ascii",
      "alloc::str::replace_ascii",
      "alloc::string::String::from_utf16_lossy",
      "alloc::string::String::from_utf16le",
      "alloc::string::String::from_utf16le_lossy",
      "alloc::string::String::from_utf16be",
      "alloc::string::String::from_utf16be_lossy",
      "alloc::<string::String as core::iter::FromIterator<core::ascii::Char>>::from_iter",
      "alloc::<string::String as core::iter::FromIterator<&'a core::ascii::Char>>::from_iter",
      "alloc::<string::String as core::iter::Extend<core::ascii::Char>>::extend",
      "alloc::<vec::Vec<T, A> as vec::ExtendFromWithinSpec>::spec_extend_from_within"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/iter/adapters/map.rs:61:1: 61:21",
  "src": "pub struct Map<I, F>",
  "kind": "Struct",
  "doc_adt": " An iterator that maps the values of `iter` with `f`.\n\n This `struct` is created by the [`map`] method on [`Iterator`]. See its\n documentation for more.\n\n [`map`]: Iterator::map\n [`Iterator`]: trait.Iterator.html\n\n # Notes about side effects\n\n The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n you can also [`map`] backwards:\n\n ```rust\n let v: Vec<i32> = [1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n\n assert_eq!(v, [4, 3, 2]);\n ```\n\n [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n\n But if your closure has state, iterating backwards may act in a way you do\n not expect. Let's go through an example. First, in the forward direction:\n\n ```rust\n let mut c = 0;\n\n for pair in ['a', 'b', 'c'].into_iter()\n                                .map(|letter| { c += 1; (letter, c) }) {\n     println!(\"{pair:?}\");\n }\n ```\n\n This will print `('a', 1), ('b', 2), ('c', 3)`.\n\n Now consider this twist where we add a call to `rev`. This version will\n print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n but the values of the counter still go in order. This is because `map()` is\n still being called lazily on each item, but we are popping items off the\n back of the vector now, instead of shifting them from the front.\n\n ```rust\n let mut c = 0;\n\n for pair in ['a', 'b', 'c'].into_iter()\n                                .map(|letter| { c += 1; (letter, c) })\n                                .rev() {\n     println!(\"{pair:?}\");\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "iter",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "f",
      "doc": ""
    }
  }
}