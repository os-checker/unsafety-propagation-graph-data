{
  "name": "core::mem::ManuallyDrop",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "raw_vec::RawVec::<T, A>::into_box",
      "boxed::Box::<T, A>::into_raw_with_allocator",
      "collections::binary_heap::Hole::<'a, T>::element",
      "<collections::binary_heap::Hole<'_, T> as core::ops::Drop>::drop",
      "<collections::btree::map::BTreeMap<K, V, A> as core::clone::Clone>::clone",
      "<collections::btree::map::BTreeMap<K, V, A> as core::clone::Clone>::clone::clone_subtree",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::replace",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::get_or_insert_with",
      "collections::btree::map::BTreeMap::<K, V, A>::clear",
      "collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::remove_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::append",
      "collections::btree::map::BTreeMap::<K, V, A>::entry",
      "collections::btree::map::BTreeMap::<K, V, A>::split_off",
      "collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner",
      "<collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::Sub<&collections::btree::set::BTreeSet<T, A>>>::sub",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitXor<&collections::btree::set::BTreeSet<T, A>>>::bitxor",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitAnd<&collections::btree::set::BTreeSet<T, A>>>::bitand",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitOr<&collections::btree::set::BTreeSet<T, A>>>::bitor",
      "<collections::linked_list::Iter<'_, T> as core::fmt::Debug>::fmt",
      "<collections::linked_list::IterMut<'_, T> as core::fmt::Debug>::fmt",
      "collections::vec_deque::<impl core::convert::From<collections::vec_deque::VecDeque<T, A>> for vec::Vec<T, A>>::from",
      "<collections::vec_deque::VecDeque<T> as core::convert::From<[T; N]>>::from",
      "ffi::c_str::CString::into_inner",
      "rc::Rc::<T, A>::into_inner_with_allocator",
      "rc::Rc::<T, A>::try_unwrap",
      "rc::Rc::<T>::into_raw",
      "rc::Rc::<T, A>::into_raw_with_allocator",
      "rc::Rc::<T, A>::increment_strong_count_in",
      "rc::Weak::<T>::into_raw",
      "rc::Weak::<T, A>::into_raw_with_allocator",
      "rc::UniqueRc::<T>::unwrap",
      "rc::UniqueRc::<T>::into_raw",
      "rc::UniqueRc::<T, A>::into_rc",
      "rc::UniqueRc::<T, A>::into_inner_with_allocator",
      "rc::UniqueRcUninit::<T, A>::into_rc",
      "sync::Arc::<T, A>::into_inner_with_allocator",
      "sync::Arc::<T, A>::try_unwrap",
      "sync::Arc::<T, A>::into_inner",
      "sync::Arc::<T>::into_raw",
      "sync::Arc::<T, A>::into_raw_with_allocator",
      "sync::Arc::<T, A>::increment_strong_count_in",
      "sync::Weak::<T>::into_raw",
      "sync::Weak::<T, A>::into_raw_with_allocator",
      "<sync::Arc<core::ffi::CStr> as core::default::Default>::default",
      "<sync::Arc<[T]> as core::default::Default>::default",
      "sync::UniqueArcUninit::<T, A>::into_arc",
      "sync::UniqueArc::<T>::unwrap",
      "sync::UniqueArc::<T>::into_raw",
      "sync::UniqueArc::<T, A>::into_arc",
      "sync::UniqueArc::<T, A>::into_inner_with_allocator",
      "task::raw_waker::wake_by_ref",
      "task::local_raw_waker::wake_by_ref",
      "vec::drain::Drain::<'a, T, A>::keep_rest",
      "vec::into_iter::IntoIter::<T, A>::allocator",
      "vec::into_iter::IntoIter::<T, A>::into_vecdeque",
      "<vec::into_iter::IntoIter<T, A> as core::clone::Clone>::clone",
      "<I as vec::in_place_collect::SpecInPlaceCollect<T, I>>::collect_in_place",
      "<vec::Vec<T> as vec::spec_from_iter::SpecFromIter<T, vec::into_iter::IntoIter<T>>>::from_iter",
      "vec::Vec::<T>::into_raw_parts",
      "vec::Vec::<T, A>::into_raw_parts_with_alloc",
      "vec::Vec::<T, A>::into_boxed_slice",
      "vec::Vec::<T, A>::leak",
      "<vec::Vec<T, A> as core::iter::IntoIterator>::into_iter"
    ],
    "write": [
      "boxed::Box::<T>::into_raw",
      "boxed::Box::<T, A>::into_raw_with_allocator",
      "<collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter",
      "collections::btree::map::BTreeMap::<K, V, A>::lower_bound_mut",
      "collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut",
      "rc::UniqueRc::<T, A>::into_rc",
      "rc::UniqueRcUninit::<T, A>::into_rc",
      "sync::Arc::<T, A>::into_inner",
      "sync::UniqueArcUninit::<T, A>::into_arc",
      "vec::drain::Drain::<'a, T, A>::keep_rest",
      "vec::into_iter::IntoIter::<T, A>::into_vecdeque",
      "<<vec::into_iter::IntoIter<T, A> as core::ops::Drop>::drop::DropGuard<'_, T, A> as core::ops::Drop>::drop",
      "vec::Vec::<T>::into_raw_parts",
      "vec::Vec::<T, A>::into_raw_parts_with_alloc",
      "vec::Vec::<T, A>::leak"
    ],
    "other": [
      "raw_vec::RawVec::<T, A>::into_box",
      "boxed::Box::<T>::into_raw",
      "boxed::Box::<T, A>::into_raw_with_allocator",
      "collections::binary_heap::Hole::<'a, T>::new",
      "<collections::btree::map::BTreeMap<K, V, A> as core::clone::Clone>::clone::clone_subtree",
      "collections::btree::map::BTreeMap::<K, V>::new",
      "collections::btree::map::BTreeMap::<K, V, A>::clear",
      "collections::btree::map::BTreeMap::<K, V, A>::new_in",
      "collections::btree::map::BTreeMap::<K, V, A>::split_off",
      "collections::btree::map::BTreeMap::<K, V, A>::bulk_build_from_sorted_iter",
      "<collections::btree::map::BTreeMap<K, V, A> as core::iter::IntoIterator>::into_iter",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::Sub<&collections::btree::set::BTreeSet<T, A>>>::sub",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitXor<&collections::btree::set::BTreeSet<T, A>>>::bitxor",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitAnd<&collections::btree::set::BTreeSet<T, A>>>::bitand",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitOr<&collections::btree::set::BTreeSet<T, A>>>::bitor",
      "<collections::linked_list::Iter<'_, T> as core::fmt::Debug>::fmt",
      "<collections::linked_list::IterMut<'_, T> as core::fmt::Debug>::fmt",
      "collections::vec_deque::<impl core::convert::From<collections::vec_deque::VecDeque<T, A>> for vec::Vec<T, A>>::from",
      "<collections::vec_deque::VecDeque<T> as core::convert::From<[T; N]>>::from",
      "ffi::c_str::CString::into_inner",
      "rc::Rc::<T, A>::into_inner_with_allocator",
      "rc::Rc::<T, A>::try_unwrap",
      "rc::Rc::<T>::into_raw",
      "rc::Rc::<T, A>::into_raw_with_allocator",
      "rc::Rc::<T, A>::increment_strong_count_in",
      "rc::Weak::<T>::into_raw",
      "rc::Weak::<T, A>::into_raw_with_allocator",
      "rc::UniqueRc::<T>::unwrap",
      "rc::UniqueRc::<T>::into_raw",
      "rc::UniqueRc::<T, A>::into_rc",
      "rc::UniqueRc::<T, A>::into_inner_with_allocator",
      "rc::UniqueRcUninit::<T, A>::into_rc",
      "sync::Arc::<T, A>::into_inner_with_allocator",
      "sync::Arc::<T, A>::try_unwrap",
      "sync::Arc::<T, A>::into_inner",
      "sync::Arc::<T>::into_raw",
      "sync::Arc::<T, A>::into_raw_with_allocator",
      "sync::Arc::<T, A>::increment_strong_count_in",
      "sync::Weak::<T>::into_raw",
      "sync::Weak::<T, A>::into_raw_with_allocator",
      "<sync::Arc<core::ffi::CStr> as core::default::Default>::default",
      "<sync::Arc<[T]> as core::default::Default>::default",
      "sync::UniqueArcUninit::<T, A>::into_arc",
      "sync::UniqueArc::<T>::unwrap",
      "sync::UniqueArc::<T>::into_raw",
      "sync::UniqueArc::<T, A>::into_arc",
      "sync::UniqueArc::<T, A>::into_inner_with_allocator",
      "task::raw_waker::wake_by_ref",
      "task::local_raw_waker::wake_by_ref",
      "vec::drain::Drain::<'a, T, A>::keep_rest",
      "vec::into_iter::IntoIter::<T, A>::into_vecdeque",
      "<I as vec::in_place_collect::SpecInPlaceCollect<T, I>>::collect_in_place",
      "<vec::Vec<T> as vec::spec_from_iter::SpecFromIter<T, vec::into_iter::IntoIter<T>>>::from_iter",
      "vec::Vec::<T>::into_raw_parts",
      "vec::Vec::<T, A>::into_raw_parts_with_alloc",
      "vec::Vec::<T, A>::into_boxed_slice",
      "vec::Vec::<T, A>::leak",
      "<vec::Vec<T, A> as core::iter::IntoIterator>::into_iter"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/mem/manually_drop.rs:158:1: 158:35",
  "src": "pub struct ManuallyDrop<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A wrapper to inhibit the compiler from automatically calling `T`â€™s\n destructor. This wrapper is 0-cost.\n\n `ManuallyDrop<T>` is guaranteed to have the same layout and bit validity as\n `T`, and is subject to the same layout optimizations as `T`. As a\n consequence, it has *no effect* on the assumptions that the compiler makes\n about its contents. For example, initializing a `ManuallyDrop<&mut T>` with\n [`mem::zeroed`] is undefined behavior. If you need to handle uninitialized\n data, use [`MaybeUninit<T>`] instead.\n\n Note that accessing the value inside a `ManuallyDrop<T>` is safe. This means\n that a `ManuallyDrop<T>` whose content has been dropped must not be exposed\n through a public safe API. Correspondingly, `ManuallyDrop::drop` is unsafe.\n\n # `ManuallyDrop` and drop order\n\n Rust has a well-defined [drop order] of values. To make sure that fields or\n locals are dropped in a specific order, reorder the declarations such that\n the implicit drop order is the correct one.\n\n It is possible to use `ManuallyDrop` to control the drop order, but this\n requires unsafe code and is hard to do correctly in the presence of\n unwinding.\n\n For example, if you want to make sure that a specific field is dropped after\n the others, make it the last field of a struct:\n\n ```\n struct Context;\n\n struct Widget {\n     children: Vec<Widget>,\n     // `context` will be dropped after `children`.\n     // Rust guarantees that fields are dropped in the order of declaration.\n     context: Context,\n }\n ```\n\n # Interaction with `Box`\n\n Currently, if you have a `ManuallyDrop<T>`, where the type `T` is a `Box` or\n contains a `Box` inside, then dropping the `T` followed by moving the\n `ManuallyDrop<T>` is [considered to be undefined\n behavior](https://github.com/rust-lang/unsafe-code-guidelines/issues/245).\n That is, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n let mut x = ManuallyDrop::new(Box::new(42));\n unsafe {\n     ManuallyDrop::drop(&mut x);\n }\n let y = x; // Undefined behavior!\n ```\n\n This is [likely to change in the\n future](https://rust-lang.github.io/rfcs/3336-maybe-dangling.html). In the\n meantime, consider using [`MaybeUninit`] instead.\n\n # Safety hazards when storing `ManuallyDrop` in a struct or an enum.\n\n Special care is needed when all of the conditions below are met:\n * A struct or enum contains a `ManuallyDrop`.\n * The `ManuallyDrop` is not inside a `union`.\n * The struct or enum is part of public API, or is stored in a struct or an\n   enum that is part of public API.\n * There is code that drops the contents of the `ManuallyDrop` field, and\n   this code is outside the struct or enum's `Drop` implementation.\n\n In particular, the following hazards may occur:\n\n #### Storing generic types\n\n If the `ManuallyDrop` contains a client-supplied generic type, the client\n might provide a `Box` as that type. This would cause undefined behavior when\n the struct or enum is later moved, as mentioned in the previous section. For\n example, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n pub struct BadOption<T> {\n     // Invariant: Has been dropped if `is_some` is false.\n     value: ManuallyDrop<T>,\n     is_some: bool,\n }\n impl<T> BadOption<T> {\n     pub fn new(value: T) -> Self {\n         Self { value: ManuallyDrop::new(value), is_some: true }\n     }\n     pub fn change_to_none(&mut self) {\n         if self.is_some {\n             self.is_some = false;\n             unsafe {\n                 // SAFETY: `value` hasn't been dropped yet, as per the invariant\n                 // (This is actually unsound!)\n                 ManuallyDrop::drop(&mut self.value);\n             }\n         }\n     }\n }\n\n // In another crate:\n\n let mut option = BadOption::new(Box::new(42));\n option.change_to_none();\n let option2 = option; // Undefined behavior!\n ```\n\n #### Deriving traits\n\n Deriving `Debug`, `Clone`, `PartialEq`, `PartialOrd`, `Ord`, or `Hash` on\n the struct or enum could be unsound, since the derived implementations of\n these traits would access the `ManuallyDrop` field. For example, the\n following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n // This derive is unsound in combination with the `ManuallyDrop::drop` call.\n #[derive(Debug)]\n pub struct Foo {\n     value: ManuallyDrop<String>,\n }\n impl Foo {\n     pub fn new() -> Self {\n         let mut temp = Self {\n             value: ManuallyDrop::new(String::from(\"Unsafe rust is hard.\"))\n         };\n         unsafe {\n             // SAFETY: `value` hasn't been dropped yet.\n             ManuallyDrop::drop(&mut temp.value);\n         }\n         temp\n     }\n }\n\n // In another crate:\n\n let foo = Foo::new();\n println!(\"{:?}\", foo); // Undefined behavior!\n ```\n\n [drop order]: https://doc.rust-lang.org/reference/destructors.html\n [`mem::zeroed`]: crate::mem::zeroed\n [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n [`MaybeUninit`]: crate::mem::MaybeUninit\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}