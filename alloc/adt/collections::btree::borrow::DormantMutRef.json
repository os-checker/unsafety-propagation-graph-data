{
  "name": "collections::btree::borrow::DormantMutRef",
  "constructors": [
    "collections::btree::borrow::DormantMutRef::<'a, T>::new"
  ],
  "access_self_as_arg": {
    "read": [
      "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow_shared"
    ],
    "write": [
      "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow"
    ],
    "other": [
      "collections::btree::borrow::DormantMutRef::<'a, T>::awaken",
      "collections::btree::borrow::DormantMutRef::<'a, T>::awaken"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "collections::btree::map::CursorMutKey::<'a, K, V, A>::as_cursor"
    ],
    "write": [
      "collections::btree::map::entry::VacantEntry::<'a, K, V, A>::insert_entry",
      "collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_after_unchecked",
      "collections::btree::map::CursorMutKey::<'a, K, V, A>::insert_before_unchecked",
      "collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_next",
      "collections::btree::map::CursorMutKey::<'a, K, V, A>::remove_prev"
    ],
    "other": [
      "collections::btree::borrow::DormantMutRef::<'a, T>::new",
      "collections::btree::map::entry::VacantEntry::<'a, K, V, A>::insert_entry",
      "collections::btree::map::entry::OccupiedEntry::<'a, K, V, A>::remove_kv",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::replace",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::get_or_insert_with",
      "collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::remove_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::entry",
      "collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner",
      "collections::btree::map::BTreeMap::<K, V, A>::lower_bound_mut",
      "collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::replace",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::get_or_insert_with",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::replace",
      "collections::btree::map::BTreeMap::<K, collections::btree::set_val::SetValZST, A>::get_or_insert_with",
      "collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::remove_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::entry",
      "collections::btree::map::BTreeMap::<K, V, A>::first_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::last_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::remove_entry",
      "collections::btree::map::BTreeMap::<K, V, A>::entry",
      "collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner",
      "collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner",
      "collections::btree::map::BTreeMap::<K, V, A>::lower_bound_mut",
      "collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut",
      "collections::btree::map::BTreeMap::<K, V, A>::lower_bound_mut",
      "collections::btree::map::BTreeMap::<K, V, A>::upper_bound_mut"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow",
        "collections::btree::borrow::DormantMutRef::<'a, T>::reborrow_shared"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/collections/btree/borrow.rs:14:1: 14:39",
  "src": "pub(super) struct DormantMutRef<'a, T>",
  "kind": "Struct",
  "doc_adt": " Models a reborrow of some unique reference, when you know that the reborrow\n and all its descendants (i.e., all pointers and references derived from it)\n will not be used any more at some point, after which you want to use the\n original unique reference again.\n\n The borrow checker usually handles this stacking of borrows for you, but\n some control flows that accomplish this stacking are too complicated for\n the compiler to follow. A `DormantMutRef` allows you to check borrowing\n yourself, while still expressing its stacked nature, and encapsulating\n the raw pointer code needed to do this without undefined behavior.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "ptr",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    }
  }
}