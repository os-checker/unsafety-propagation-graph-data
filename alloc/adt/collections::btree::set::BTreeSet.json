{
  "name": "collections::btree::set::BTreeSet",
  "constructors": [
    "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone",
    "collections::btree::set::BTreeSet::<T>::new",
    "collections::btree::set::BTreeSet::<T, A>::new_in",
    "collections::btree::set::BTreeSet::<T, A>::split_off",
    "<collections::btree::set::BTreeSet<T> as core::iter::FromIterator<T>>::from_iter",
    "collections::btree::set::BTreeSet::<T, A>::from_sorted_iter",
    "<collections::btree::set::BTreeSet<T> as core::convert::From<[T; N]>>::from",
    "<collections::btree::set::BTreeSet<T> as core::default::Default>::default",
    "<&collections::btree::set::BTreeSet<T, A> as core::ops::Sub<&collections::btree::set::BTreeSet<T, A>>>::sub",
    "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitXor<&collections::btree::set::BTreeSet<T, A>>>::bitxor",
    "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitAnd<&collections::btree::set::BTreeSet<T, A>>>::bitand",
    "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitOr<&collections::btree::set::BTreeSet<T, A>>>::bitor"
  ],
  "access_self_as_arg": {
    "read": [
      "<collections::btree::set::BTreeSet<T, A> as core::hash::Hash>::hash",
      "<collections::btree::set::BTreeSet<T, A> as core::cmp::PartialEq>::eq",
      "<collections::btree::set::BTreeSet<T, A> as core::cmp::PartialOrd>::partial_cmp",
      "<collections::btree::set::BTreeSet<T, A> as core::cmp::Ord>::cmp",
      "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone",
      "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone_from",
      "collections::btree::set::BTreeSet::<T, A>::range",
      "collections::btree::set::BTreeSet::<T, A>::difference",
      "collections::btree::set::BTreeSet::<T, A>::symmetric_difference",
      "collections::btree::set::BTreeSet::<T, A>::intersection",
      "collections::btree::set::BTreeSet::<T, A>::union",
      "collections::btree::set::BTreeSet::<T, A>::contains",
      "collections::btree::set::BTreeSet::<T, A>::get",
      "collections::btree::set::BTreeSet::<T, A>::is_disjoint",
      "collections::btree::set::BTreeSet::<T, A>::is_subset",
      "collections::btree::set::BTreeSet::<T, A>::is_superset",
      "collections::btree::set::BTreeSet::<T, A>::first",
      "collections::btree::set::BTreeSet::<T, A>::last",
      "collections::btree::set::BTreeSet::<T, A>::iter",
      "collections::btree::set::BTreeSet::<T, A>::len",
      "collections::btree::set::BTreeSet::<T, A>::is_empty",
      "collections::btree::set::BTreeSet::<T, A>::lower_bound",
      "collections::btree::set::BTreeSet::<T, A>::upper_bound",
      "<&'a collections::btree::set::BTreeSet<T, A> as core::iter::IntoIterator>::into_iter",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::Sub<&collections::btree::set::BTreeSet<T, A>>>::sub",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitXor<&collections::btree::set::BTreeSet<T, A>>>::bitxor",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitAnd<&collections::btree::set::BTreeSet<T, A>>>::bitand",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitOr<&collections::btree::set::BTreeSet<T, A>>>::bitor",
      "<collections::btree::set::BTreeSet<T, A> as core::fmt::Debug>::fmt"
    ],
    "write": [
      "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone_from",
      "collections::btree::set::BTreeSet::<T, A>::clear",
      "collections::btree::set::BTreeSet::<T, A>::pop_first",
      "collections::btree::set::BTreeSet::<T, A>::pop_last",
      "collections::btree::set::BTreeSet::<T, A>::insert",
      "collections::btree::set::BTreeSet::<T, A>::replace",
      "collections::btree::set::BTreeSet::<T, A>::get_or_insert",
      "collections::btree::set::BTreeSet::<T, A>::get_or_insert_with",
      "collections::btree::set::BTreeSet::<T, A>::entry",
      "collections::btree::set::BTreeSet::<T, A>::remove",
      "collections::btree::set::BTreeSet::<T, A>::take",
      "collections::btree::set::BTreeSet::<T, A>::retain",
      "collections::btree::set::BTreeSet::<T, A>::append",
      "collections::btree::set::BTreeSet::<T, A>::split_off",
      "collections::btree::set::BTreeSet::<T, A>::extract_if",
      "collections::btree::set::BTreeSet::<T, A>::lower_bound_mut",
      "collections::btree::set::BTreeSet::<T, A>::upper_bound_mut",
      "<collections::btree::set::BTreeSet<T, A> as core::iter::Extend<T>>::extend",
      "<collections::btree::set::BTreeSet<T, A> as core::iter::Extend<T>>::extend_one",
      "<collections::btree::set::BTreeSet<T, A> as core::iter::Extend<&'a T>>::extend",
      "<collections::btree::set::BTreeSet<T, A> as core::iter::Extend<&'a T>>::extend_one"
    ],
    "other": [
      "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone",
      "collections::btree::set::BTreeSet::<T, A>::split_off",
      "<collections::btree::set::BTreeSet<T, A> as core::iter::IntoIterator>::into_iter",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::Sub<&collections::btree::set::BTreeSet<T, A>>>::sub",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitXor<&collections::btree::set::BTreeSet<T, A>>>::bitxor",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitAnd<&collections::btree::set::BTreeSet<T, A>>>::bitand",
      "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitOr<&collections::btree::set::BTreeSet<T, A>>>::bitor",
      "<collections::btree::set::BTreeSet<T, A> as core::iter::IntoIterator>::into_iter"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<collections::btree::set::Difference<'_, T, A> as core::clone::Clone>::clone",
      "<collections::btree::set::Difference<'a, T, A> as core::iter::Iterator>::next",
      "<collections::btree::set::Difference<'a, T, A> as core::iter::Iterator>::size_hint",
      "<collections::btree::set::Intersection<'_, T, A> as core::clone::Clone>::clone",
      "<collections::btree::set::Intersection<'a, T, A> as core::iter::Iterator>::next"
    ],
    "write": [],
    "other": [
      "collections::btree::set::BTreeSet::<T>::new",
      "collections::btree::set::BTreeSet::<T, A>::new_in",
      "<collections::btree::set::BTreeSet<T> as core::iter::FromIterator<T>>::from_iter",
      "collections::btree::set::BTreeSet::<T, A>::from_sorted_iter",
      "<collections::btree::set::BTreeSet<T> as core::convert::From<[T; N]>>::from",
      "<collections::btree::set::BTreeSet<T> as core::default::Default>::default"
    ]
  },
  "access_field": [
    {
      "read": [
        "<collections::btree::set::BTreeSet<T, A> as core::hash::Hash>::hash",
        "<collections::btree::set::BTreeSet<T, A> as core::cmp::PartialEq>::eq",
        "<collections::btree::set::BTreeSet<T, A> as core::cmp::PartialOrd>::partial_cmp",
        "<collections::btree::set::BTreeSet<T, A> as core::cmp::Ord>::cmp",
        "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone",
        "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone_from",
        "collections::btree::set::BTreeSet::<T, A>::range",
        "collections::btree::set::BTreeSet::<T, A>::contains",
        "collections::btree::set::BTreeSet::<T, A>::get",
        "collections::btree::set::BTreeSet::<T, A>::first",
        "collections::btree::set::BTreeSet::<T, A>::last",
        "collections::btree::set::BTreeSet::<T, A>::iter",
        "collections::btree::set::BTreeSet::<T, A>::len",
        "collections::btree::set::BTreeSet::<T, A>::lower_bound",
        "collections::btree::set::BTreeSet::<T, A>::upper_bound",
        "<&collections::btree::set::BTreeSet<T, A> as core::ops::Sub<&collections::btree::set::BTreeSet<T, A>>>::sub",
        "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitXor<&collections::btree::set::BTreeSet<T, A>>>::bitxor",
        "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitAnd<&collections::btree::set::BTreeSet<T, A>>>::bitand",
        "<&collections::btree::set::BTreeSet<T, A> as core::ops::BitOr<&collections::btree::set::BTreeSet<T, A>>>::bitor"
      ],
      "write": [
        "<collections::btree::set::BTreeSet<T, A> as core::clone::Clone>::clone_from",
        "collections::btree::set::BTreeSet::<T, A>::clear",
        "collections::btree::set::BTreeSet::<T, A>::pop_first",
        "collections::btree::set::BTreeSet::<T, A>::pop_last",
        "collections::btree::set::BTreeSet::<T, A>::insert",
        "collections::btree::set::BTreeSet::<T, A>::replace",
        "collections::btree::set::BTreeSet::<T, A>::get_or_insert",
        "collections::btree::set::BTreeSet::<T, A>::get_or_insert_with",
        "collections::btree::set::BTreeSet::<T, A>::entry",
        "collections::btree::set::BTreeSet::<T, A>::remove",
        "collections::btree::set::BTreeSet::<T, A>::take",
        "collections::btree::set::BTreeSet::<T, A>::append",
        "collections::btree::set::BTreeSet::<T, A>::split_off",
        "collections::btree::set::BTreeSet::<T, A>::extract_if",
        "collections::btree::set::BTreeSet::<T, A>::lower_bound_mut",
        "collections::btree::set::BTreeSet::<T, A>::upper_bound_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/collections/btree/set.rs:78:1: 81:2",
  "src": "pub struct BTreeSet<\n    T,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator + Clone = Global,\n>",
  "kind": "Struct",
  "doc_adt": " An ordered set based on a B-Tree.\n\n See [`BTreeMap`]'s documentation for a detailed discussion of this collection's performance\n benefits and drawbacks.\n\n It is a logic error for an item to be modified in such a way that the item's ordering relative\n to any other item, as determined by the [`Ord`] trait, changes while it is in the set. This is\n normally only possible through [`Cell`], [`RefCell`], global state, I/O, or unsafe code.\n The behavior resulting from such a logic error is not specified, but will be encapsulated to the\n `BTreeSet` that observed the logic error and not result in undefined behavior. This could\n include panics, incorrect results, aborts, memory leaks, and non-termination.\n\n Iterators returned by [`BTreeSet::iter`] and [`BTreeSet::into_iter`] produce their items in order, and take worst-case\n logarithmic and amortized constant time per item returned.\n\n [`Cell`]: core::cell::Cell\n [`RefCell`]: core::cell::RefCell\n\n # Examples\n\n ```\n use std::collections::BTreeSet;\n\n // Type inference lets us omit an explicit type signature (which\n // would be `BTreeSet<&str>` in this example).\n let mut books = BTreeSet::new();\n\n // Add some books.\n books.insert(\"A Dance With Dragons\");\n books.insert(\"To Kill a Mockingbird\");\n books.insert(\"The Odyssey\");\n books.insert(\"The Great Gatsby\");\n\n // Check for a specific one.\n if !books.contains(\"The Winds of Winter\") {\n     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n              books.len());\n }\n\n // Remove a book.\n books.remove(\"The Odyssey\");\n\n // Iterate over everything.\n for book in &books {\n     println!(\"{book}\");\n }\n ```\n\n A `BTreeSet` with a known list of items can be initialized from an array:\n\n ```\n use std::collections::BTreeSet;\n\n let set = BTreeSet::from([1, 2, 3]);\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "map",
      "doc": ""
    }
  }
}