{
  "name": "alloc::collections::btree::map::ExtractIfInner",
  "constructors": [
    "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner"
  ],
  "access_self_as_arg": {
    "read": [
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::peek",
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::size_hint"
    ],
    "write": [
      "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "alloc::<collections::btree::map::ExtractIf<'_, K, V, R, F, A> as core::fmt::Debug>::fmt",
      "alloc::<collections::btree::map::ExtractIf<'_, K, V, R, F, A> as core::iter::Iterator>::size_hint",
      "alloc::<collections::btree::set::ExtractIf<'_, T, R, F, A> as core::fmt::Debug>::fmt",
      "alloc::<collections::btree::set::ExtractIf<'_, T, R, F, A> as core::iter::Iterator>::size_hint"
    ],
    "write": [
      "alloc::<collections::btree::map::ExtractIf<'_, K, V, R, F, A> as core::iter::Iterator>::next",
      "alloc::<collections::btree::set::ExtractIf<'_, T, R, F, A> as core::iter::Iterator>::next"
    ],
    "other": [
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if_inner",
      "alloc::collections::btree::set::BTreeSet::<T, A>::extract_if",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if",
      "alloc::collections::btree::map::BTreeMap::<K, V, A>::extract_if",
      "alloc::collections::btree::set::BTreeSet::<T, A>::extract_if",
      "alloc::collections::btree::set::BTreeSet::<T, A>::extract_if"
    ]
  },
  "access_field": [
    {
      "read": [
        "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::size_hint"
      ],
      "write": [
        "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next"
      ],
      "other": []
    },
    {
      "read": [
        "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::peek"
      ],
      "write": [
        "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "alloc::collections::btree::map::ExtractIfInner::<'a, K, V, R>::next"
      ],
      "other": []
    }
  ],
  "span": "$library/alloc/src/collections/btree/map.rs:1986:1: 1986:46",
  "src": "pub(super) struct ExtractIfInner<'a, K, V, R>",
  "kind": "Struct",
  "doc_adt": " Most of the implementation of ExtractIf are generic over the type\n of the predicate, thus also serving for BTreeSet::ExtractIf.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "length",
      "doc": " Reference to the length field in the borrowed map, updated live.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "dormant_root",
      "doc": " Buried reference to the root field in the borrowed map.\n Wrapped in `Option` to allow drop handler to `take` it.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "cur_leaf_edge",
      "doc": " Contains a leaf edge preceding the next element to be returned, or the last leaf edge.\n Empty if the map has no root, if iteration went beyond the last leaf edge,\n or if a panic occurred in the predicate.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(3))": {
      "name": "range",
      "doc": " Range over which iteration was requested.  We don't need the left side, but we\n can't extract the right side without requiring K: Clone.\n"
    }
  }
}