{
  "name": "alloc::sync::Arc::<T, A>::downgrade",
  "span": "$library/alloc/src/sync.rs:1913:5: 1915:18",
  "src": "pub fn downgrade(this: &Self) -> Weak<T, A>\n    where\n        A: Clone,\n    {\n        // This Relaxed is OK because we're checking the value in the CAS\n        // below.\n        let mut cur = this.inner().weak.load(Relaxed);\n\n        loop {\n            // check if the weak counter is currently \"locked\"; if so, spin.\n            if cur == usize::MAX {\n                hint::spin_loop();\n                cur = this.inner().weak.load(Relaxed);\n                continue;\n            }\n\n            // We can't allow the refcount to increase much past `MAX_REFCOUNT`.\n            assert!(cur <= MAX_REFCOUNT, \"{}\", INTERNAL_OVERFLOW_ERROR);\n\n            // NOTE: this code currently ignores the possibility of overflow\n            // into usize::MAX; in general both Rc and Arc need to be adjusted\n            // to deal with overflow.\n\n            // Unlike with Clone(), we need this to be an Acquire read to\n            // synchronize with the write coming from `is_unique`, so that the\n            // events prior to that write happen before this read.\n            match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n                Ok(_) => {\n                    // Make sure we do not create a dangling Weak\n                    debug_assert!(!is_dangling(this.ptr.as_ptr()));\n                    return Weak { ptr: this.ptr, alloc: this.alloc.clone() };\n                }\n                Err(old) => cur = old,\n            }\n        }\n    }"
}