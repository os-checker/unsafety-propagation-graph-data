{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::shrink_to",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1197:5: 1197:53",
  "mir": "fn alloc::collections::vec_deque::VecDeque::<T, A>::shrink_to(_1: &mut collections::vec_deque::VecDeque<T, A>, _2: usize) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: &collections::vec_deque::VecDeque<T, A>;\n    let  _8: bool;\n    let mut _9: &core::ops::RangeInclusive<usize>;\n    let  _10: core::ops::RangeInclusive<usize>;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let mut _13: usize;\n    let mut _14: &collections::vec_deque::VecDeque<T, A>;\n    let  _15: &usize;\n    let  _16: usize;\n    let mut _17: usize;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: usize;\n    let mut _21: usize;\n    let mut _22: bool;\n    let mut _23: usize;\n    let  _24: ();\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: bool;\n    let mut _28: usize;\n    let  _29: usize;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: usize;\n    let mut _33: (usize, bool);\n    let mut _34: (usize, bool);\n    let  _35: ();\n    let mut _36: bool;\n    let mut _37: &collections::vec_deque::VecDeque<T, A>;\n    let  _38: usize;\n    let mut _39: usize;\n    let mut _40: &collections::vec_deque::VecDeque<T, A>;\n    let mut _41: usize;\n    let mut _42: (usize, bool);\n    let  _43: usize;\n    let mut _44: (usize, bool);\n    let  _45: ();\n    let mut _46: usize;\n    let  _47: collections::vec_deque::VecDeque<T, A>::shrink_to::Guard<'_, T, A>;\n    let  _48: ();\n    let mut _49: &mut raw_vec::RawVec<T, A>;\n    let  _50: ();\n    let mut _51: bool;\n    let mut _52: usize;\n    let mut _53: usize;\n    let mut _54: &collections::vec_deque::VecDeque<T, A>;\n    let mut _55: usize;\n    let mut _56: &collections::vec_deque::VecDeque<T, A>;\n    let mut _57: !;\n    let mut _58: bool;\n    let mut _59: usize;\n    let mut _60: usize;\n    let mut _61: &collections::vec_deque::VecDeque<T, A>;\n    let mut _62: !;\n    let mut _63: &mut collections::vec_deque::VecDeque<T, A>;\n    debug self => _1;\n    debug min_capacity => _2;\n    debug target_cap => _3;\n    debug tail_outside => _8;\n    debug old_head => _20;\n    debug len => _29;\n    debug head_len => _38;\n    debug new_head => _43;\n    debug guard => _47;\n    bb0: {\n        StorageLive(_4);\n        _4 = ((*_1).1: usize);\n        _3 = <usize as core::cmp::Ord>::max(_2, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        switchInt(<T as core::mem::SizedTypeProperties>::IS_ZST) -> [0: bb2, otherwise: bb5];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = collections::vec_deque::VecDeque::<T, A>::capacity(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _5 = Le(move _6, _3);\n        switchInt(move _5) -> [0: bb6, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_6);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_5);\n        goto -> bb49;\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _12 = CheckedAdd(_3, 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = move (_12.0: usize);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_1);\n        _13 = collections::vec_deque::VecDeque::<T, A>::capacity(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        _10 = core::ops::RangeInclusive::<usize>::new(move _11, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _9 = &_10;\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = ((*_1).0: usize);\n        StorageLive(_18);\n        _18 = ((*_1).1: usize);\n        _19 = CheckedAdd(_17, _18);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _17, move _18) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _16 = move (_19.0: usize);\n        StorageDead(_18);\n        StorageDead(_17);\n        _15 = &_16;\n        _8 = core::ops::RangeInclusive::<usize>::contains::<usize>(move _9, _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_9);\n        StorageDead(_16);\n        StorageDead(_10);\n        _20 = ((*_1).0: usize);\n        StorageLive(_21);\n        _21 = ((*_1).1: usize);\n        switchInt(move _21) -> [0: bb12, otherwise: bb13];\n    }\n    bb12: {\n        StorageDead(_21);\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb36;\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = ((*_1).0: usize);\n        _22 = Ge(move _23, _3);\n        switchInt(move _22) -> [0: bb17, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_23);\n        switchInt(_8) -> [0: bb18, otherwise: bb15];\n    }\n    bb15: {\n        StorageLive(_25);\n        _25 = ((*_1).0: usize);\n        StorageLive(_26);\n        _26 = ((*_1).1: usize);\n        _24 = collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1, move _25, 0_usize, move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        StorageDead(_25);\n        ((*_1).0: usize) = 0_usize;\n        goto -> bb35;\n    }\n    bb17: {\n        StorageDead(_23);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = ((*_1).0: usize);\n        _27 = Lt(move _28, _3);\n        switchInt(move _27) -> [0: bb24, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_28);\n        switchInt(_8) -> [0: bb25, otherwise: bb20];\n    }\n    bb20: {\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = ((*_1).0: usize);\n        StorageLive(_32);\n        _32 = ((*_1).1: usize);\n        _33 = CheckedAdd(_31, _32);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _31, move _32) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _30 = move (_33.0: usize);\n        StorageDead(_32);\n        StorageDead(_31);\n        _34 = CheckedSub(_30, _3);\n        assert(!move (_34.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _30, _3) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _29 = move (_34.0: usize);\n        StorageDead(_30);\n        _35 = collections::vec_deque::VecDeque::<T, A>::copy_nonoverlapping(_1, _3, 0_usize, _29) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        goto -> bb34;\n    }\n    bb24: {\n        StorageDead(_28);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &(*_1);\n        _36 = collections::vec_deque::VecDeque::<T, A>::is_contiguous(move _37) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _36) -> [0: bb28, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_37);\n        goto -> bb33;\n    }\n    bb28: {\n        StorageDead(_37);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &(*_1);\n        _39 = collections::vec_deque::VecDeque::<T, A>::capacity(move _40) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_40);\n        StorageLive(_41);\n        _41 = ((*_1).0: usize);\n        _42 = CheckedSub(_39, _41);\n        assert(!move (_42.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _39, move _41) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _38 = move (_42.0: usize);\n        StorageDead(_41);\n        StorageDead(_39);\n        _44 = CheckedSub(_3, _38);\n        assert(!move (_44.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _38) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _43 = move (_44.0: usize);\n        StorageLive(_46);\n        _46 = ((*_1).0: usize);\n        _45 = collections::vec_deque::VecDeque::<T, A>::copy(_1, move _46, _43, _38) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_46);\n        ((*_1).0: usize) = _43;\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_36);\n        goto -> bb34;\n    }\n    bb34: {\n        StorageDead(_27);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_22);\n        goto -> bb36;\n    }\n    bb36: {\n        _47 = Guard(_1, _20, _3);\n        StorageLive(_49);\n        _63 = (_47.0: &mut collections::vec_deque::VecDeque<T, A>);\n        _49 = &mut ((*_63).2: raw_vec::RawVec<T, A>);\n        _48 = raw_vec::RawVec::<T, A>::shrink_to_fit(move _49, _3) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_49);\n        _50 = core::mem::forget::<collections::vec_deque::VecDeque<T, A>::shrink_to::Guard<'_, T, A>>(_47) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = ((*_1).0: usize);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &(*_1);\n        _53 = collections::vec_deque::VecDeque::<T, A>::capacity(move _54) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_54);\n        _51 = Lt(move _52, move _53);\n        switchInt(move _51) -> [0: bb41, otherwise: bb40];\n    }\n    bb40: {\n        StorageDead(_53);\n        StorageDead(_52);\n        goto -> bb45;\n    }\n    bb41: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = &(*_1);\n        _55 = collections::vec_deque::VecDeque::<T, A>::capacity(move _56) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_56);\n        switchInt(move _55) -> [0: bb43, otherwise: bb44];\n    }\n    bb43: {\n        StorageDead(_55);\n        goto -> bb45;\n    }\n    bb44: {\n        StorageDead(_55);\n        _57 = core::panicking::panic(\"assertion failed: self.head < self.capacity() || self.capacity() == 0\") -> unwind unreachable;\n    }\n    bb45: {\n        StorageDead(_51);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = ((*_1).1: usize);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &(*_1);\n        _60 = collections::vec_deque::VecDeque::<T, A>::capacity(move _61) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_61);\n        _58 = Le(move _59, move _60);\n        switchInt(move _58) -> [0: bb48, otherwise: bb47];\n    }\n    bb47: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_58);\n        goto -> bb49;\n    }\n    bb48: {\n        StorageDead(_60);\n        StorageDead(_59);\n        _62 = core::panicking::panic(\"assertion failed: self.len <= self.capacity()\") -> unwind unreachable;\n    }\n    bb49: {\n        return;\n    }\n}\n"
}