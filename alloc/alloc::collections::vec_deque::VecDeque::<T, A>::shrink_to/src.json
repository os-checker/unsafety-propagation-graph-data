{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::shrink_to",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1197:5: 1197:53",
  "src": "pub fn shrink_to(&mut self, min_capacity: usize) {\n        let target_cap = min_capacity.max(self.len);\n\n        // never shrink ZSTs\n        if T::IS_ZST || self.capacity() <= target_cap {\n            return;\n        }\n\n        // There are three cases of interest:\n        //   All elements are out of desired bounds\n        //   Elements are contiguous, and tail is out of desired bounds\n        //   Elements are discontiguous\n        //\n        // At all other times, element positions are unaffected.\n\n        // `head` and `len` are at most `isize::MAX` and `target_cap < self.capacity()`, so nothing can\n        // overflow.\n        let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n        // Used in the drop guard below.\n        let old_head = self.head;\n\n        if self.len == 0 {\n            self.head = 0;\n        } else if self.head >= target_cap && tail_outside {\n            // Head and tail are both out of bounds, so copy all of them to the front.\n            //\n            //  H := head\n            //  L := last element\n            //                    H           L\n            //   [. . . . . . . . o o o o o o o . ]\n            //    H           L\n            //   [o o o o o o o . ]\n            unsafe {\n                // nonoverlapping because `self.head >= target_cap >= self.len`.\n                self.copy_nonoverlapping(self.head, 0, self.len);\n            }\n            self.head = 0;\n        } else if self.head < target_cap && tail_outside {\n            // Head is in bounds, tail is out of bounds.\n            // Copy the overflowing part to the beginning of the\n            // buffer. This won't overlap because `target_cap >= self.len`.\n            //\n            //  H := head\n            //  L := last element\n            //          H           L\n            //   [. . . o o o o o o o . . . . . . ]\n            //      L   H\n            //   [o o . o o o o o ]\n            let len = self.head + self.len - target_cap;\n            unsafe {\n                self.copy_nonoverlapping(target_cap, 0, len);\n            }\n        } else if !self.is_contiguous() {\n            // The head slice is at least partially out of bounds, tail is in bounds.\n            // Copy the head backwards so it lines up with the target capacity.\n            // This won't overlap because `target_cap >= self.len`.\n            //\n            //  H := head\n            //  L := last element\n            //            L                   H\n            //   [o o o o o . . . . . . . . . o o ]\n            //            L   H\n            //   [o o o o o . o o ]\n            let head_len = self.capacity() - self.head;\n            let new_head = target_cap - head_len;\n            unsafe {\n                // can't use `copy_nonoverlapping()` here because the new and old\n                // regions for the head might overlap.\n                self.copy(self.head, new_head, head_len);\n            }\n            self.head = new_head;\n        }\n\n        struct Guard<'a, T, A: Allocator> {\n            deque: &'a mut VecDeque<T, A>,\n            old_head: usize,\n            target_cap: usize,\n        }\n\n        impl<T, A: Allocator> Drop for Guard<'_, T, A> {\n            #[cold]\n            fn drop(&mut self) {\n                unsafe {\n                    // SAFETY: This is only called if `buf.shrink_to_fit` unwinds,\n                    // which is the only time it's safe to call `abort_shrink`.\n                    self.deque.abort_shrink(self.old_head, self.target_cap)\n                }\n            }\n        }\n\n        let guard = Guard { deque: self, old_head, target_cap };\n\n        guard.deque.buf.shrink_to_fit(target_cap);\n\n        // Don't drop the guard if we didn't unwind.\n        mem::forget(guard);\n\n        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n        debug_assert!(self.len <= self.capacity());\n    }"
}