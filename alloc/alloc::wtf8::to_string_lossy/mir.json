{
  "name": "alloc::wtf8::to_string_lossy",
  "span": "$library/alloc/src/wtf8/mod.rs:465:1: 465:60",
  "mir": "fn alloc::wtf8::to_string_lossy(_1: &core::wtf8::Wtf8) -> borrow::Cow<'_, str> {\n    let mut _0: borrow::Cow<'_, str>;\n    let  _2: &str;\n    let  _3: &[u8];\n    let  _4: usize;\n    let mut _5: core::option::Option<(usize, u16)>;\n    let mut _6: isize;\n    let  _7: &[u8];\n    let mut _8: vec::Vec<u8>;\n    let mut _9: usize;\n    let  _10: ();\n    let mut _11: &mut vec::Vec<u8>;\n    let  _12: &[u8];\n    let mut _13: core::ops::RangeTo<usize>;\n    let  _14: ();\n    let mut _15: &mut vec::Vec<u8>;\n    let  _16: &[u8];\n    let mut _17: &str;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let mut _20: core::option::Option<(usize, u16)>;\n    let mut _21: usize;\n    let mut _22: isize;\n    let  _23: usize;\n    let  _24: ();\n    let mut _25: &mut vec::Vec<u8>;\n    let  _26: &[u8];\n    let mut _27: core::ops::Range<usize>;\n    let mut _28: usize;\n    let  _29: ();\n    let mut _30: &mut vec::Vec<u8>;\n    let  _31: &[u8];\n    let mut _32: &str;\n    let mut _33: (usize, bool);\n    let  _34: ();\n    let mut _35: &mut vec::Vec<u8>;\n    let  _36: &[u8];\n    let mut _37: core::ops::RangeFrom<usize>;\n    let mut _38: usize;\n    let mut _39: string::String;\n    let mut _40: vec::Vec<u8>;\n    debug slice => _1;\n    debug surrogate_pos => _4;\n    debug wtf8_bytes => _7;\n    debug utf8_bytes => _8;\n    debug pos => _18;\n    debug surrogate_pos => _23;\n    bb0: {\n        StorageLive(_5);\n        _5 = core::wtf8::Wtf8::next_surrogate(_1, 0_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::str::from_utf8_unchecked(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = borrow::Cow::Borrowed(_2);\n        goto -> bb27;\n    }\n    bb3: {\n        _6 = discriminant(_5);\n        switchInt(move _6) -> [1: bb4, 0: bb5, otherwise: bb16];\n    }\n    bb4: {\n        _4 = (((_5 as variant#1).0: (usize, u16)).0: usize);\n        StorageDead(_5);\n        _7 = core::wtf8::Wtf8::as_bytes(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        _3 = core::wtf8::Wtf8::as_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::wtf8::Wtf8::len(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _8 = vec::Vec::<u8>::with_capacity(move _9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = &mut _8;\n        StorageLive(_13);\n        _13 = RangeTo(_4);\n        _12 = <[u8] as core::ops::Index<core::ops::RangeTo<usize>>>::index(_7, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _10 = vec::Vec::<u8>::extend_from_slice(move _11, _12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = &mut _8;\n        StorageLive(_17);\n        _17 = \"�\";\n        _16 = core::str::<impl str>::as_bytes(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        _14 = vec::Vec::<u8>::extend_from_slice(move _15, _16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageLive(_18);\n        _19 = CheckedAdd(_4, 3_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, 3_usize) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = move (_19.0: usize);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _18;\n        _20 = core::wtf8::Wtf8::next_surrogate(_1, move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        _22 = discriminant(_20);\n        switchInt(move _22) -> [0: bb17, 1: bb18, otherwise: bb16];\n    }\n    bb16: {\n        unreachable;\n    }\n    bb17: {\n        StorageLive(_35);\n        _35 = &mut _8;\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _18;\n        _37 = RangeFrom(move _38);\n        StorageDead(_38);\n        _36 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_7, move _37) -> [return: bb24, unwind unreachable];\n    }\n    bb18: {\n        _23 = (((_20 as variant#1).0: (usize, u16)).0: usize);\n        StorageLive(_25);\n        _25 = &mut _8;\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _18;\n        _27 = Range(move _28, _23);\n        StorageDead(_28);\n        _26 = <[u8] as core::ops::Index<core::ops::Range<usize>>>::index(_7, move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        _24 = vec::Vec::<u8>::extend_from_slice(move _25, _26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_25);\n        StorageLive(_30);\n        _30 = &mut _8;\n        StorageLive(_32);\n        _32 = \"�\";\n        _31 = core::str::<impl str>::as_bytes(move _32) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_32);\n        _29 = vec::Vec::<u8>::extend_from_slice(move _30, _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        _33 = CheckedAdd(_23, 3_usize);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _23, 3_usize) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _18 = move (_33.0: usize);\n        StorageDead(_20);\n        goto -> bb14;\n    }\n    bb24: {\n        StorageDead(_37);\n        _34 = vec::Vec::<u8>::extend_from_slice(move _35, _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = move _8;\n        _39 = string::String::from_utf8_unchecked(move _40) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_40);\n        _0 = borrow::Cow::Owned(move _39);\n        StorageDead(_39);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_8);\n        goto -> bb27;\n    }\n    bb27: {\n        return;\n    }\n}\n"
}