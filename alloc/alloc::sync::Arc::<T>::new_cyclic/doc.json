{
  "name": "alloc::sync::Arc::<T>::new_cyclic",
  "span": "$library/alloc/src/sync.rs:484:5: 486:34",
  "doc": " Constructs a new `Arc<T>` while giving you a `Weak<T>` to the allocation,\n to allow you to construct a `T` which holds a weak pointer to itself.\n\n Generally, a structure circularly referencing itself, either directly or\n indirectly, should not hold a strong reference to itself to prevent a memory leak.\n Using this function, you get access to the weak pointer during the\n initialization of `T`, before the `Arc<T>` is created, such that you can\n clone and store it inside the `T`.\n\n `new_cyclic` first allocates the managed allocation for the `Arc<T>`,\n then calls your closure, giving it a `Weak<T>` to this allocation,\n and only afterwards completes the construction of the `Arc<T>` by placing\n the `T` returned from your closure into the allocation.\n\n Since the new `Arc<T>` is not fully-constructed until `Arc<T>::new_cyclic`\n returns, calling [`upgrade`] on the weak reference inside your closure will\n fail and result in a `None` value.\n\n # Panics\n\n If `data_fn` panics, the panic is propagated to the caller, and the\n temporary [`Weak<T>`] is dropped normally.\n\n # Example\n\n ```\n # #![allow(dead_code)]\n use std::sync::{Arc, Weak};\n\n struct Gadget {\n     me: Weak<Gadget>,\n }\n\n impl Gadget {\n     /// Constructs a reference counted Gadget.\n     fn new() -> Arc<Self> {\n         // `me` is a `Weak<Gadget>` pointing at the new allocation of the\n         // `Arc` we're constructing.\n         Arc::new_cyclic(|me| {\n             // Create the actual struct here.\n             Gadget { me: me.clone() }\n         })\n     }\n\n     /// Returns a reference counted pointer to Self.\n     fn me(&self) -> Arc<Self> {\n         self.me.upgrade().unwrap()\n     }\n }\n ```\n [`upgrade`]: Weak::upgrade\n"
}