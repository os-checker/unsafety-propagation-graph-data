{
  "name": "alloc::collections::vec_deque::VecDeque::<T, A>::truncate",
  "span": "$library/alloc/src/collections/vec_deque/mod.rs:1357:5: 1357:43",
  "src": "pub fn truncate(&mut self, len: usize) {\n        /// Runs the destructor for all items in the slice when it gets dropped (normally or\n        /// during unwinding).\n        struct Dropper<'a, T>(&'a mut [T]);\n\n        impl<'a, T> Drop for Dropper<'a, T> {\n            fn drop(&mut self) {\n                unsafe {\n                    ptr::drop_in_place(self.0);\n                }\n            }\n        }\n\n        // Safe because:\n        //\n        // * Any slice passed to `drop_in_place` is valid; the second case has\n        //   `len <= front.len()` and returning on `len > self.len()` ensures\n        //   `begin <= back.len()` in the first case\n        // * The head of the VecDeque is moved before calling `drop_in_place`,\n        //   so no value is dropped twice if `drop_in_place` panics\n        unsafe {\n            if len >= self.len {\n                return;\n            }\n\n            let (front, back) = self.as_mut_slices();\n            if len > front.len() {\n                let begin = len - front.len();\n                let drop_back = back.get_unchecked_mut(begin..) as *mut _;\n                self.len = len;\n                ptr::drop_in_place(drop_back);\n            } else {\n                let drop_back = back as *mut _;\n                let drop_front = front.get_unchecked_mut(len..) as *mut _;\n                self.len = len;\n\n                // Make sure the second half is dropped even when a destructor\n                // in the first one panics.\n                let _back_dropper = Dropper(&mut *drop_back);\n                ptr::drop_in_place(drop_front);\n            }\n        }\n    }"
}