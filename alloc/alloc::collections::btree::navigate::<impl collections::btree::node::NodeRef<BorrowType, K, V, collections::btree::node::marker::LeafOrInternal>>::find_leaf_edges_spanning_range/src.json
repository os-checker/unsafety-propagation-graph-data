{
  "name": "alloc::collections::btree::navigate::<impl collections::btree::node::NodeRef<BorrowType, K, V, collections::btree::node::marker::LeafOrInternal>>::find_leaf_edges_spanning_range",
  "span": "$library/alloc/src/collections/btree/navigate.rs:264:5: 271:27",
  "src": "unsafe fn find_leaf_edges_spanning_range<Q: ?Sized, R>(\n        self,\n        range: R,\n    ) -> LeafRange<BorrowType, K, V>\n    where\n        Q: Ord,\n        K: Borrow<Q>,\n        R: RangeBounds<Q>,\n    {\n        match self.search_tree_for_bifurcation(&range) {\n            Err(_) => LeafRange::none(),\n            Ok((\n                node,\n                lower_edge_idx,\n                upper_edge_idx,\n                mut lower_child_bound,\n                mut upper_child_bound,\n            )) => {\n                let mut lower_edge = unsafe { Handle::new_edge(ptr::read(&node), lower_edge_idx) };\n                let mut upper_edge = unsafe { Handle::new_edge(node, upper_edge_idx) };\n                loop {\n                    match (lower_edge.force(), upper_edge.force()) {\n                        (Leaf(f), Leaf(b)) => return LeafRange { front: Some(f), back: Some(b) },\n                        (Internal(f), Internal(b)) => {\n                            (lower_edge, lower_child_bound) =\n                                f.descend().find_lower_bound_edge(lower_child_bound);\n                            (upper_edge, upper_child_bound) =\n                                b.descend().find_upper_bound_edge(upper_child_bound);\n                        }\n                        _ => unreachable!(\"BTreeMap has different depths\"),\n                    }\n                }\n            }\n        }\n    }"
}