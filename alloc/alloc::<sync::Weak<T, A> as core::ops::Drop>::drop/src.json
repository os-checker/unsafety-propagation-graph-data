{
  "name": "alloc::<sync::Weak<T, A> as core::ops::Drop>::drop",
  "span": "$library/alloc/src/sync.rs:3468:5: 3468:23",
  "src": "fn drop(&mut self) {\n        // If we find out that we were the last weak pointer, then its time to\n        // deallocate the data entirely. See the discussion in Arc::drop() about\n        // the memory orderings\n        //\n        // It's not necessary to check for the locked state here, because the\n        // weak count can only be locked if there was precisely one weak ref,\n        // meaning that drop could only subsequently run ON that remaining weak\n        // ref, which can only happen after the lock is released.\n        let inner = if let Some(inner) = self.inner() { inner } else { return };\n\n        if inner.weak.fetch_sub(1, Release) == 1 {\n            acquire!(inner.weak);\n\n            // Make sure we aren't trying to \"deallocate\" the shared static for empty slices\n            // used by Default::default.\n            debug_assert!(\n                !ptr::addr_eq(self.ptr.as_ptr(), &STATIC_INNER_SLICE.inner),\n                \"Arc/Weaks backed by a static should never be deallocated. \\\n                Likely decrement_strong_count or from_raw were called too many times.\",\n            );\n\n            unsafe {\n                self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()))\n            }\n        }\n    }"
}