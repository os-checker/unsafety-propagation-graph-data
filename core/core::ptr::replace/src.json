{
  "name": "core::ptr::replace",
  "span": "$library/core/src/ptr/mod.rs:1540:1: 1540:57",
  "src": "pub const unsafe fn replace<T>(dst: *mut T, src: T) -> T {\n    // SAFETY: the caller must guarantee that `dst` is valid to be\n    // cast to a mutable reference (valid for writes, aligned, initialized),\n    // and cannot overlap `src` since `dst` must point to a distinct\n    // allocation.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::replace requires that the pointer argument is aligned and non-null\",\n            (\n                addr: *const () = dst as *const (),\n                align: usize = align_of::<T>(),\n                is_zst: bool = T::IS_ZST,\n            ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)\n        );\n        mem::replace(&mut *dst, src)\n    }\n}"
}