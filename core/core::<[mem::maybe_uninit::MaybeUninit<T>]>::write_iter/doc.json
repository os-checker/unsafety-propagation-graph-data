{
  "name": "core::<[mem::maybe_uninit::MaybeUninit<T>]>::write_iter",
  "span": "$library/core/src/mem/maybe_uninit.rs:1368:5: 1370:35",
  "doc": " Fills a slice with elements yielded by an iterator until either all elements have been\n initialized or the iterator is empty.\n\n Returns two slices. The first slice contains the initialized portion of the original slice.\n The second slice is the still-uninitialized remainder of the original slice.\n\n # Panics\n\n This function panics if the iterator's `next` function panics.\n\n If such a panic occurs, any elements previously initialized during this operation will be\n dropped.\n\n # Examples\n\n Completely filling the slice:\n\n ```\n #![feature(maybe_uninit_fill)]\n use std::mem::MaybeUninit;\n\n let mut buf = [const { MaybeUninit::uninit() }; 5];\n\n let iter = [1, 2, 3].into_iter().cycle();\n let (initialized, remainder) = buf.write_iter(iter);\n\n assert_eq!(initialized, &mut [1, 2, 3, 1, 2]);\n assert_eq!(remainder.len(), 0);\n ```\n\n Partially filling the slice:\n\n ```\n #![feature(maybe_uninit_fill)]\n use std::mem::MaybeUninit;\n\n let mut buf = [const { MaybeUninit::uninit() }; 5];\n let iter = [1, 2];\n let (initialized, remainder) = buf.write_iter(iter);\n\n assert_eq!(initialized, &mut [1, 2]);\n assert_eq!(remainder.len(), 3);\n ```\n\n Checking an iterator after filling a slice:\n\n ```\n #![feature(maybe_uninit_fill)]\n use std::mem::MaybeUninit;\n\n let mut buf = [const { MaybeUninit::uninit() }; 3];\n let mut iter = [1, 2, 3, 4, 5].into_iter();\n let (initialized, remainder) = buf.write_iter(iter.by_ref());\n\n assert_eq!(initialized, &mut [1, 2, 3]);\n assert_eq!(remainder.len(), 0);\n assert_eq!(iter.as_slice(), &[4, 5]);\n ```\n"
}