{
  "name": "core::num::flt2dec::strategy::dragon::format_exact",
  "span": "$library/core/src/num/flt2dec/strategy/dragon.rs:262:1: 266:40",
  "mir": "fn core::num::flt2dec::strategy::dragon::format_exact(_1: &num::flt2dec::decoder::Decoded, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>], _3: i16) -> (&[u8], i16) {\n    let mut _0: (&[u8], i16);\n    let mut _4: bool;\n    let mut _5: u64;\n    let mut _6: !;\n    let mut _7: bool;\n    let mut _8: u64;\n    let mut _9: !;\n    let mut _10: bool;\n    let mut _11: u64;\n    let mut _12: !;\n    let mut _13: bool;\n    let mut _14: &option::Option<u64>;\n    let  _15: option::Option<u64>;\n    let mut _16: u64;\n    let mut _17: u64;\n    let mut _18: !;\n    let mut _19: bool;\n    let mut _20: &option::Option<u64>;\n    let  _21: option::Option<u64>;\n    let mut _22: u64;\n    let mut _23: u64;\n    let mut _24: !;\n    let mut _25: i16;\n    let mut _26: u64;\n    let mut _27: i16;\n    let mut _28: num::bignum::Big32x40;\n    let mut _29: u64;\n    let mut _30: num::bignum::Big32x40;\n    let mut _31: bool;\n    let mut _32: i16;\n    let  _33: &mut num::bignum::Big32x40;\n    let mut _34: &mut num::bignum::Big32x40;\n    let mut _35: usize;\n    let mut _36: i16;\n    let mut _37: i16;\n    let mut _38: bool;\n    let  _39: &mut num::bignum::Big32x40;\n    let mut _40: &mut num::bignum::Big32x40;\n    let mut _41: usize;\n    let mut _42: i16;\n    let mut _43: bool;\n    let mut _44: i16;\n    let  _45: &mut num::bignum::Big32x40;\n    let mut _46: &mut num::bignum::Big32x40;\n    let mut _47: usize;\n    let mut _48: i16;\n    let  _49: &mut num::bignum::Big32x40;\n    let mut _50: &mut num::bignum::Big32x40;\n    let mut _51: usize;\n    let mut _52: i16;\n    let mut _53: i16;\n    let mut _54: bool;\n    let mut _55: bool;\n    let mut _56: &num::bignum::Big32x40;\n    let  _57: &mut num::bignum::Big32x40;\n    let mut _58: &mut num::bignum::Big32x40;\n    let mut _59: &mut num::bignum::Big32x40;\n    let mut _60: num::bignum::Big32x40;\n    let mut _61: &num::bignum::Big32x40;\n    let mut _62: usize;\n    let mut _63: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let  _64: &num::bignum::Big32x40;\n    let mut _65: &num::bignum::Big32x40;\n    let mut _66: (i16, bool);\n    let  _67: &mut num::bignum::Big32x40;\n    let mut _68: &mut num::bignum::Big32x40;\n    let mut _69: usize;\n    let mut _70: bool;\n    let mut _71: i16;\n    let mut _72: bool;\n    let mut _73: usize;\n    let mut _74: i32;\n    let mut _75: i32;\n    let mut _76: i16;\n    let mut _77: i32;\n    let mut _78: (i32, bool);\n    let mut _79: usize;\n    let mut _80: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _81: i16;\n    let mut _82: i16;\n    let mut _83: (i16, bool);\n    let mut _84: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _85: bool;\n    let mut _86: usize;\n    let mut _87: num::bignum::Big32x40;\n    let mut _88: &num::bignum::Big32x40;\n    let  _89: &mut num::bignum::Big32x40;\n    let mut _90: &mut num::bignum::Big32x40;\n    let mut _91: num::bignum::Big32x40;\n    let mut _92: &num::bignum::Big32x40;\n    let  _93: &mut num::bignum::Big32x40;\n    let mut _94: &mut num::bignum::Big32x40;\n    let mut _95: num::bignum::Big32x40;\n    let mut _96: &num::bignum::Big32x40;\n    let  _97: &mut num::bignum::Big32x40;\n    let mut _98: &mut num::bignum::Big32x40;\n    let mut _99: ops::range::Range<usize>;\n    let mut _100: ops::range::Range<usize>;\n    let mut _101: usize;\n    let mut _102: ops::range::Range<usize>;\n    let mut _103: option::Option<usize>;\n    let mut _104: &mut ops::range::Range<usize>;\n    let mut _105: isize;\n    let  _106: usize;\n    let mut _107: bool;\n    let mut _108: &num::bignum::Big32x40;\n    let mut _109: slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _110: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _111: ops::range::Range<usize>;\n    let mut _112: usize;\n    let mut _113: slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _114: option::Option<&mut mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _115: &mut slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _116: isize;\n    let  _117: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _118: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _119: &[u8];\n    let  _120: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _121: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _122: ops::range::RangeTo<usize>;\n    let mut _123: usize;\n    let mut _124: i16;\n    let mut _125: u8;\n    let mut _126: bool;\n    let mut _127: &num::bignum::Big32x40;\n    let mut _128: &num::bignum::Big32x40;\n    let  _129: &mut num::bignum::Big32x40;\n    let mut _130: &mut num::bignum::Big32x40;\n    let  _131: &num::bignum::Big32x40;\n    let mut _132: (u8, bool);\n    let mut _133: bool;\n    let mut _134: &num::bignum::Big32x40;\n    let mut _135: &num::bignum::Big32x40;\n    let  _136: &mut num::bignum::Big32x40;\n    let mut _137: &mut num::bignum::Big32x40;\n    let  _138: &num::bignum::Big32x40;\n    let mut _139: (u8, bool);\n    let mut _140: bool;\n    let mut _141: &num::bignum::Big32x40;\n    let mut _142: &num::bignum::Big32x40;\n    let  _143: &mut num::bignum::Big32x40;\n    let mut _144: &mut num::bignum::Big32x40;\n    let  _145: &num::bignum::Big32x40;\n    let mut _146: (u8, bool);\n    let mut _147: bool;\n    let mut _148: &num::bignum::Big32x40;\n    let mut _149: &num::bignum::Big32x40;\n    let  _150: &mut num::bignum::Big32x40;\n    let mut _151: &mut num::bignum::Big32x40;\n    let  _152: &num::bignum::Big32x40;\n    let mut _153: (u8, bool);\n    let mut _154: bool;\n    let mut _155: &num::bignum::Big32x40;\n    let mut _156: &num::bignum::Big32x40;\n    let mut _157: !;\n    let mut _158: bool;\n    let mut _159: u8;\n    let mut _160: !;\n    let mut _161: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _162: u8;\n    let mut _163: u8;\n    let mut _164: (u8, bool);\n    let mut _165: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _166: usize;\n    let mut _167: bool;\n    let  _168: &mut num::bignum::Big32x40;\n    let mut _169: &mut num::bignum::Big32x40;\n    let  _170: cmp::Ordering;\n    let mut _171: &num::bignum::Big32x40;\n    let mut _172: &num::bignum::Big32x40;\n    let  _173: &mut num::bignum::Big32x40;\n    let mut _174: &mut num::bignum::Big32x40;\n    let mut _175: bool;\n    let mut _176: &cmp::Ordering;\n    let mut _177: &cmp::Ordering;\n    let mut _178: bool;\n    let mut _179: &cmp::Ordering;\n    let mut _180: &cmp::Ordering;\n    let mut _181: bool;\n    let mut _182: usize;\n    let mut _183: u8;\n    let mut _184: u8;\n    let mut _185: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _186: usize;\n    let mut _187: usize;\n    let mut _188: (usize, bool);\n    let mut _189: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _190: usize;\n    let mut _191: bool;\n    let mut _192: option::Option<u8>;\n    let mut _193: &mut [u8];\n    let mut _194: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _195: ops::range::RangeTo<usize>;\n    let mut _196: usize;\n    let mut _197: isize;\n    let  _198: u8;\n    let mut _199: (i16, bool);\n    let mut _200: bool;\n    let mut _201: i16;\n    let mut _202: bool;\n    let mut _203: usize;\n    let mut _204: usize;\n    let mut _205: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _206: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _207: usize;\n    let mut _208: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _209: usize;\n    let mut _210: bool;\n    let mut _211: (usize, bool);\n    let  _212: &[u8];\n    let  _213: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _214: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _215: ops::range::RangeTo<usize>;\n    let mut _216: usize;\n    let mut _217: i16;\n    debug d => _1;\n    debug buf => _2;\n    debug limit => _3;\n    debug k => _25;\n    debug mant => _28;\n    debug scale => _30;\n    debug len => _69;\n    debug scale2 => _87;\n    debug scale4 => _91;\n    debug scale8 => _95;\n    debug iter => _102;\n    debug i => _106;\n    debug iter => _113;\n    debug c => _117;\n    debug d => _125;\n    debug order => _170;\n    debug c => _198;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).0: u64);\n        _4 = Gt(move _5, 0_u64);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = ((*_1).1: u64);\n        _7 = Gt(move _8, 0_u64);\n        switchInt(move _7) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = panicking::panic(\"assertion failed: d.mant > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = ((*_1).2: u64);\n        _10 = Gt(move _11, 0_u64);\n        switchInt(move _10) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_8);\n        _9 = panicking::panic(\"assertion failed: d.minus > 0\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = ((*_1).0: u64);\n        StorageLive(_17);\n        _17 = ((*_1).2: u64);\n        _15 = num::<impl u64>::checked_add(move _16, move _17) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _12 = panicking::panic(\"assertion failed: d.plus > 0\") -> unwind unreachable;\n    }\n    bb7: {\n        _14 = &_15;\n        StorageDead(_17);\n        StorageDead(_16);\n        _13 = option::Option::<u64>::is_some(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _13) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = ((*_1).0: u64);\n        StorageLive(_23);\n        _23 = ((*_1).1: u64);\n        _21 = num::<impl u64>::checked_sub(move _22, move _23) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageDead(_15);\n        _18 = panicking::panic(\"assertion failed: d.mant.checked_add(d.plus).is_some()\") -> unwind unreachable;\n    }\n    bb11: {\n        _20 = &_21;\n        StorageDead(_23);\n        StorageDead(_22);\n        _19 = option::Option::<u64>::is_some(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _19) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_20);\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = ((*_1).0: u64);\n        StorageLive(_27);\n        _27 = ((*_1).3: i16);\n        _25 = num::flt2dec::estimator::estimate_scaling_factor(move _26, move _27) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_21);\n        _24 = panicking::panic(\"assertion failed: d.mant.checked_sub(d.minus).is_some()\") -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = ((*_1).0: u64);\n        _28 = num::bignum::Big32x40::from_u64(move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        StorageLive(_30);\n        _30 = num::bignum::Big32x40::from_small(1_u32) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = ((*_1).3: i16);\n        _31 = Lt(move _32, 0_i16);\n        switchInt(move _31) -> [0: bb21, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _30;\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = ((*_1).3: i16);\n        _38 = Eq(_37, i16::MIN);\n        assert(!move _38, \"attempt to negate `{}`, which would overflow\", _37) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _36 = Neg(move _37);\n        StorageDead(_37);\n        _35 = move _36 as usize;\n        StorageDead(_36);\n        _33 = num::bignum::Big32x40::mul_pow2(move _34, move _35) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb23;\n    }\n    bb21: {\n        StorageDead(_32);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &mut _28;\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = ((*_1).3: i16);\n        _41 = move _42 as usize;\n        StorageDead(_42);\n        _39 = num::bignum::Big32x40::mul_pow2(move _40, move _41) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_31);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = _25;\n        _43 = Ge(move _44, 0_i16);\n        switchInt(move _43) -> [0: bb26, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_44);\n        StorageLive(_45);\n        _46 = &mut _30;\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _25;\n        _47 = move _48 as usize;\n        StorageDead(_48);\n        _45 = num::flt2dec::strategy::dragon::mul_pow10(_46, move _47) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_47);\n        StorageDead(_45);\n        goto -> bb29;\n    }\n    bb26: {\n        StorageDead(_44);\n        StorageLive(_49);\n        _50 = &mut _28;\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = _25;\n        _54 = Eq(_53, i16::MIN);\n        assert(!move _54, \"attempt to negate `{}`, which would overflow\", _53) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _52 = Neg(move _53);\n        StorageDead(_53);\n        _51 = move _52 as usize;\n        StorageDead(_52);\n        _49 = num::flt2dec::strategy::dragon::mul_pow10(_50, move _51) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_51);\n        StorageDead(_49);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_43);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &_30;\n        _60 = <num::bignum::Big32x40 as clone::Clone>::clone(move _61) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_61);\n        _59 = &mut _60;\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = &(*_2);\n        _62 = PtrMetadata(move _63);\n        StorageDead(_63);\n        _58 = num::flt2dec::strategy::dragon::div_2pow10(_59, move _62) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_62);\n        _64 = &_28;\n        _57 = num::bignum::Big32x40::add(_58, _64) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _56 = &(*_57);\n        StorageLive(_65);\n        _65 = &_30;\n        _55 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _56, move _65) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        switchInt(move _55) -> [0: bb36, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_65);\n        StorageDead(_60);\n        StorageDead(_57);\n        StorageDead(_56);\n        _66 = CheckedAdd(_25, 1_i16);\n        assert(!move (_66.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, 1_i16) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _25 = move (_66.0: i16);\n        goto -> bb38;\n    }\n    bb36: {\n        StorageDead(_65);\n        StorageDead(_60);\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = &mut _28;\n        _67 = num::bignum::Big32x40::mul_small(move _68, 10_u32) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_68);\n        StorageDead(_67);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_55);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = _25;\n        _70 = Lt(move _71, _3);\n        switchInt(move _70) -> [0: bb40, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_71);\n        _69 = 0_usize;\n        goto -> bb46;\n    }\n    bb40: {\n        StorageDead(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = _25;\n        _75 = move _76 as i32;\n        StorageDead(_76);\n        StorageLive(_77);\n        _77 = _3 as i32;\n        _78 = CheckedSub(_75, _77);\n        assert(!move (_78.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _75, move _77) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _74 = move (_78.0: i32);\n        StorageDead(_77);\n        StorageDead(_75);\n        _73 = move _74 as usize;\n        StorageDead(_74);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = &(*_2);\n        _79 = PtrMetadata(move _80);\n        StorageDead(_80);\n        _72 = Lt(move _73, move _79);\n        switchInt(move _72) -> [0: bb44, otherwise: bb42];\n    }\n    bb42: {\n        StorageDead(_79);\n        StorageDead(_73);\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = _25;\n        _83 = CheckedSub(_82, _3);\n        assert(!move (_83.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _82, _3) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _81 = move (_83.0: i16);\n        StorageDead(_82);\n        _69 = move _81 as usize;\n        StorageDead(_81);\n        goto -> bb45;\n    }\n    bb44: {\n        StorageDead(_79);\n        StorageDead(_73);\n        StorageLive(_84);\n        _84 = &(*_2);\n        _69 = PtrMetadata(move _84);\n        StorageDead(_84);\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_72);\n        goto -> bb46;\n    }\n    bb46: {\n        StorageDead(_70);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = _69;\n        _85 = Gt(move _86, 0_usize);\n        switchInt(move _85) -> [0: bb105, otherwise: bb47];\n    }\n    bb47: {\n        StorageDead(_86);\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = &_30;\n        _87 = <num::bignum::Big32x40 as clone::Clone>::clone(move _88) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_88);\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = &mut _87;\n        _89 = num::bignum::Big32x40::mul_pow2(move _90, 1_usize) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_90);\n        StorageDead(_89);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = &_30;\n        _91 = <num::bignum::Big32x40 as clone::Clone>::clone(move _92) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        _94 = &mut _91;\n        _93 = num::bignum::Big32x40::mul_pow2(move _94, 2_usize) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_94);\n        StorageDead(_93);\n        StorageLive(_95);\n        StorageLive(_96);\n        _96 = &_30;\n        _95 = <num::bignum::Big32x40 as clone::Clone>::clone(move _96) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_96);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = &mut _95;\n        _97 = num::bignum::Big32x40::mul_pow2(move _98, 3_usize) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_98);\n        StorageDead(_97);\n        StorageLive(_99);\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = _69;\n        _100 = Range(0_usize, move _101);\n        StorageDead(_101);\n        _99 = <ops::range::Range<usize> as iter::traits::collect::IntoIterator>::into_iter(move _100) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_100);\n        StorageLive(_102);\n        _102 = move _99;\n        goto -> bb55;\n    }\n    bb55: {\n        StorageLive(_103);\n        _104 = &mut _102;\n        _103 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::next(_104) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        _105 = discriminant(_103);\n        switchInt(move _105) -> [0: bb59, 1: bb58, otherwise: bb57];\n    }\n    bb57: {\n        unreachable;\n    }\n    bb58: {\n        _106 = ((_103 as variant#1).0: usize);\n        StorageLive(_107);\n        StorageLive(_108);\n        _108 = &_28;\n        _107 = num::bignum::Big32x40::is_zero(move _108) -> [return: bb60, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_103);\n        StorageDead(_102);\n        StorageDead(_99);\n        StorageDead(_95);\n        StorageDead(_91);\n        StorageDead(_87);\n        goto -> bb106;\n    }\n    bb60: {\n        switchInt(move _107) -> [0: bb71, otherwise: bb61];\n    }\n    bb61: {\n        StorageDead(_108);\n        StorageLive(_109);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = _69;\n        _111 = Range(_106, move _112);\n        StorageDead(_112);\n        _110 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::Range<usize>>>::index_mut(_2, move _111) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_111);\n        _109 = <&mut [mem::maybe_uninit::MaybeUninit<u8>] as iter::traits::collect::IntoIterator>::into_iter(_110) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageLive(_113);\n        _113 = move _109;\n        goto -> bb64;\n    }\n    bb64: {\n        StorageLive(_114);\n        _115 = &mut _113;\n        _114 = <slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>> as iter::traits::iterator::Iterator>::next(_115) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        _116 = discriminant(_114);\n        switchInt(move _116) -> [0: bb67, 1: bb66, otherwise: bb57];\n    }\n    bb66: {\n        StorageLive(_117);\n        _117 = move ((_114 as variant#1).0: &mut mem::maybe_uninit::MaybeUninit<u8>);\n        StorageLive(_118);\n        _118 = mem::maybe_uninit::MaybeUninit::<u8>::new(48_u8) -> [return: bb68, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_114);\n        StorageDead(_113);\n        StorageDead(_109);\n        StorageLive(_121);\n        _121 = &(*_2);\n        StorageLive(_122);\n        StorageLive(_123);\n        _123 = _69;\n        _122 = RangeTo(move _123);\n        StorageDead(_123);\n        _120 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _121, move _122) -> [return: bb69, unwind unreachable];\n    }\n    bb68: {\n        (*_117) = move _118;\n        StorageDead(_118);\n        StorageDead(_117);\n        StorageDead(_114);\n        goto -> bb64;\n    }\n    bb69: {\n        StorageDead(_122);\n        StorageDead(_121);\n        _119 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_120) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageLive(_124);\n        _124 = _25;\n        _0 = (_119, move _124);\n        StorageDead(_124);\n        StorageDead(_107);\n        StorageDead(_103);\n        StorageDead(_102);\n        StorageDead(_99);\n        StorageDead(_95);\n        StorageDead(_91);\n        StorageDead(_87);\n        StorageDead(_85);\n        StorageDead(_69);\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageDead(_25);\n        goto -> bb140;\n    }\n    bb71: {\n        StorageDead(_108);\n        StorageDead(_107);\n        StorageLive(_125);\n        _125 = 0_u8;\n        StorageLive(_126);\n        StorageLive(_127);\n        _127 = &_28;\n        StorageLive(_128);\n        _128 = &_95;\n        _126 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _127, move _128) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        switchInt(move _126) -> [0: bb76, otherwise: bb73];\n    }\n    bb73: {\n        StorageDead(_128);\n        StorageDead(_127);\n        StorageLive(_129);\n        StorageLive(_130);\n        _130 = &mut _28;\n        _131 = &_95;\n        _129 = num::bignum::Big32x40::sub(move _130, _131) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_130);\n        StorageDead(_129);\n        _132 = CheckedAdd(_125, 8_u8);\n        assert(!move (_132.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 8_u8) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _125 = move (_132.0: u8);\n        goto -> bb77;\n    }\n    bb76: {\n        StorageDead(_128);\n        StorageDead(_127);\n        goto -> bb77;\n    }\n    bb77: {\n        StorageDead(_126);\n        StorageLive(_133);\n        StorageLive(_134);\n        _134 = &_28;\n        StorageLive(_135);\n        _135 = &_91;\n        _133 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _134, move _135) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        switchInt(move _133) -> [0: bb82, otherwise: bb79];\n    }\n    bb79: {\n        StorageDead(_135);\n        StorageDead(_134);\n        StorageLive(_136);\n        StorageLive(_137);\n        _137 = &mut _28;\n        _138 = &_91;\n        _136 = num::bignum::Big32x40::sub(move _137, _138) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_137);\n        StorageDead(_136);\n        _139 = CheckedAdd(_125, 4_u8);\n        assert(!move (_139.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 4_u8) -> [success: bb81, unwind unreachable];\n    }\n    bb81: {\n        _125 = move (_139.0: u8);\n        goto -> bb83;\n    }\n    bb82: {\n        StorageDead(_135);\n        StorageDead(_134);\n        goto -> bb83;\n    }\n    bb83: {\n        StorageDead(_133);\n        StorageLive(_140);\n        StorageLive(_141);\n        _141 = &_28;\n        StorageLive(_142);\n        _142 = &_87;\n        _140 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _141, move _142) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        switchInt(move _140) -> [0: bb88, otherwise: bb85];\n    }\n    bb85: {\n        StorageDead(_142);\n        StorageDead(_141);\n        StorageLive(_143);\n        StorageLive(_144);\n        _144 = &mut _28;\n        _145 = &_87;\n        _143 = num::bignum::Big32x40::sub(move _144, _145) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        StorageDead(_144);\n        StorageDead(_143);\n        _146 = CheckedAdd(_125, 2_u8);\n        assert(!move (_146.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 2_u8) -> [success: bb87, unwind unreachable];\n    }\n    bb87: {\n        _125 = move (_146.0: u8);\n        goto -> bb89;\n    }\n    bb88: {\n        StorageDead(_142);\n        StorageDead(_141);\n        goto -> bb89;\n    }\n    bb89: {\n        StorageDead(_140);\n        StorageLive(_147);\n        StorageLive(_148);\n        _148 = &_28;\n        StorageLive(_149);\n        _149 = &_30;\n        _147 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _148, move _149) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        switchInt(move _147) -> [0: bb94, otherwise: bb91];\n    }\n    bb91: {\n        StorageDead(_149);\n        StorageDead(_148);\n        StorageLive(_150);\n        StorageLive(_151);\n        _151 = &mut _28;\n        _152 = &_30;\n        _150 = num::bignum::Big32x40::sub(move _151, _152) -> [return: bb92, unwind unreachable];\n    }\n    bb92: {\n        StorageDead(_151);\n        StorageDead(_150);\n        _153 = CheckedAdd(_125, 1_u8);\n        assert(!move (_153.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 1_u8) -> [success: bb93, unwind unreachable];\n    }\n    bb93: {\n        _125 = move (_153.0: u8);\n        goto -> bb95;\n    }\n    bb94: {\n        StorageDead(_149);\n        StorageDead(_148);\n        goto -> bb95;\n    }\n    bb95: {\n        StorageDead(_147);\n        StorageLive(_154);\n        StorageLive(_155);\n        _155 = &_28;\n        StorageLive(_156);\n        _156 = &_30;\n        _154 = <num::bignum::Big32x40 as cmp::PartialOrd>::lt(move _155, move _156) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        switchInt(move _154) -> [0: bb98, otherwise: bb97];\n    }\n    bb97: {\n        StorageDead(_156);\n        StorageDead(_155);\n        StorageDead(_154);\n        StorageLive(_158);\n        StorageLive(_159);\n        _159 = _125;\n        _158 = Lt(move _159, 10_u8);\n        switchInt(move _158) -> [0: bb100, otherwise: bb99];\n    }\n    bb98: {\n        StorageDead(_156);\n        StorageDead(_155);\n        _157 = panicking::panic(\"assertion failed: mant < scale\") -> unwind unreachable;\n    }\n    bb99: {\n        StorageDead(_159);\n        StorageDead(_158);\n        StorageLive(_161);\n        StorageLive(_162);\n        StorageLive(_163);\n        _163 = _125;\n        _164 = CheckedAdd(48_u8, _163);\n        assert(!move (_164.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _163) -> [success: bb101, unwind unreachable];\n    }\n    bb100: {\n        StorageDead(_159);\n        _160 = panicking::panic(\"assertion failed: d < 10\") -> unwind unreachable;\n    }\n    bb101: {\n        _162 = move (_164.0: u8);\n        StorageDead(_163);\n        _161 = mem::maybe_uninit::MaybeUninit::<u8>::new(move _162) -> [return: bb102, unwind unreachable];\n    }\n    bb102: {\n        StorageDead(_162);\n        _165 = &raw const (fake) (*_2);\n        _166 = PtrMetadata(move _165);\n        _167 = Lt(_106, _166);\n        assert(move _167, \"index out of bounds: the length is {} but the index is {}\", move _166, _106) -> [success: bb103, unwind unreachable];\n    }\n    bb103: {\n        (*_2)[_106] = move _161;\n        StorageDead(_161);\n        StorageLive(_168);\n        StorageLive(_169);\n        _169 = &mut _28;\n        _168 = num::bignum::Big32x40::mul_small(move _169, 10_u32) -> [return: bb104, unwind unreachable];\n    }\n    bb104: {\n        StorageDead(_169);\n        StorageDead(_168);\n        StorageDead(_125);\n        StorageDead(_103);\n        goto -> bb55;\n    }\n    bb105: {\n        StorageDead(_86);\n        goto -> bb106;\n    }\n    bb106: {\n        StorageDead(_85);\n        StorageLive(_170);\n        StorageLive(_171);\n        _171 = &_28;\n        StorageLive(_172);\n        StorageLive(_173);\n        StorageLive(_174);\n        _174 = &mut _30;\n        _173 = num::bignum::Big32x40::mul_small(move _174, 5_u32) -> [return: bb107, unwind unreachable];\n    }\n    bb107: {\n        _172 = &(*_173);\n        StorageDead(_174);\n        _170 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _171, move _172) -> [return: bb108, unwind unreachable];\n    }\n    bb108: {\n        StorageDead(_172);\n        StorageDead(_171);\n        StorageDead(_173);\n        StorageLive(_175);\n        StorageLive(_176);\n        _176 = &_170;\n        StorageLive(_177);\n        _177 = num::flt2dec::strategy::dragon::format_exact::promoted[1];\n        _175 = <cmp::Ordering as cmp::PartialEq>::eq(move _176, move _177) -> [return: bb109, unwind unreachable];\n    }\n    bb109: {\n        switchInt(move _175) -> [0: bb111, otherwise: bb110];\n    }\n    bb110: {\n        StorageDead(_177);\n        StorageDead(_176);\n        goto -> bb119;\n    }\n    bb111: {\n        StorageDead(_177);\n        StorageDead(_176);\n        StorageLive(_178);\n        StorageLive(_179);\n        _179 = &_170;\n        StorageLive(_180);\n        _180 = num::flt2dec::strategy::dragon::format_exact::promoted[0];\n        _178 = <cmp::Ordering as cmp::PartialEq>::eq(move _179, move _180) -> [return: bb112, unwind unreachable];\n    }\n    bb112: {\n        switchInt(move _178) -> [0: bb136, otherwise: bb113];\n    }\n    bb113: {\n        StorageDead(_180);\n        StorageDead(_179);\n        StorageLive(_181);\n        StorageLive(_182);\n        _182 = _69;\n        _181 = Gt(move _182, 0_usize);\n        switchInt(move _181) -> [0: bb135, otherwise: bb114];\n    }\n    bb114: {\n        StorageDead(_182);\n        StorageLive(_183);\n        StorageLive(_184);\n        StorageLive(_185);\n        StorageLive(_186);\n        StorageLive(_187);\n        _187 = _69;\n        _188 = CheckedSub(_187, 1_usize);\n        assert(!move (_188.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _187, 1_usize) -> [success: bb115, unwind unreachable];\n    }\n    bb115: {\n        _186 = move (_188.0: usize);\n        StorageDead(_187);\n        _189 = &raw const (fake) (*_2);\n        _190 = PtrMetadata(move _189);\n        _191 = Lt(_186, _190);\n        assert(move _191, \"index out of bounds: the length is {} but the index is {}\", move _190, _186) -> [success: bb116, unwind unreachable];\n    }\n    bb116: {\n        _185 = (*_2)[_186];\n        _184 = mem::maybe_uninit::MaybeUninit::<u8>::assume_init(move _185) -> [return: bb117, unwind unreachable];\n    }\n    bb117: {\n        StorageDead(_186);\n        StorageDead(_185);\n        _183 = BitAnd(move _184, 1_u8);\n        StorageDead(_184);\n        switchInt(move _183) -> [1: bb118, otherwise: bb134];\n    }\n    bb118: {\n        StorageDead(_183);\n        goto -> bb119;\n    }\n    bb119: {\n        StorageLive(_192);\n        StorageLive(_195);\n        StorageLive(_196);\n        _196 = _69;\n        _195 = RangeTo(move _196);\n        StorageDead(_196);\n        _194 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_2, move _195) -> [return: bb120, unwind unreachable];\n    }\n    bb120: {\n        StorageDead(_195);\n        _193 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_194) -> [return: bb121, unwind unreachable];\n    }\n    bb121: {\n        _192 = num::flt2dec::round_up(_193) -> [return: bb122, unwind unreachable];\n    }\n    bb122: {\n        _197 = discriminant(_192);\n        switchInt(move _197) -> [1: bb123, 0: bb133, otherwise: bb57];\n    }\n    bb123: {\n        _198 = ((_192 as variant#1).0: u8);\n        _199 = CheckedAdd(_25, 1_i16);\n        assert(!move (_199.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, 1_i16) -> [success: bb124, unwind unreachable];\n    }\n    bb124: {\n        _25 = move (_199.0: i16);\n        StorageLive(_200);\n        StorageLive(_201);\n        _201 = _25;\n        _200 = Gt(move _201, _3);\n        switchInt(move _200) -> [0: bb131, otherwise: bb125];\n    }\n    bb125: {\n        StorageDead(_201);\n        StorageLive(_202);\n        StorageLive(_203);\n        _203 = _69;\n        StorageLive(_204);\n        StorageLive(_205);\n        _205 = &(*_2);\n        _204 = PtrMetadata(move _205);\n        StorageDead(_205);\n        _202 = Lt(move _203, move _204);\n        switchInt(move _202) -> [0: bb130, otherwise: bb126];\n    }\n    bb126: {\n        StorageDead(_204);\n        StorageDead(_203);\n        StorageLive(_206);\n        _206 = mem::maybe_uninit::MaybeUninit::<u8>::new(_198) -> [return: bb127, unwind unreachable];\n    }\n    bb127: {\n        StorageLive(_207);\n        _207 = _69;\n        _208 = &raw const (fake) (*_2);\n        _209 = PtrMetadata(move _208);\n        _210 = Lt(_207, _209);\n        assert(move _210, \"index out of bounds: the length is {} but the index is {}\", move _209, _207) -> [success: bb128, unwind unreachable];\n    }\n    bb128: {\n        (*_2)[_207] = move _206;\n        StorageDead(_206);\n        StorageDead(_207);\n        _211 = CheckedAdd(_69, 1_usize);\n        assert(!move (_211.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _69, 1_usize) -> [success: bb129, unwind unreachable];\n    }\n    bb129: {\n        _69 = move (_211.0: usize);\n        goto -> bb132;\n    }\n    bb130: {\n        StorageDead(_204);\n        StorageDead(_203);\n        goto -> bb132;\n    }\n    bb131: {\n        StorageDead(_201);\n        goto -> bb132;\n    }\n    bb132: {\n        StorageDead(_202);\n        StorageDead(_200);\n        StorageDead(_192);\n        goto -> bb137;\n    }\n    bb133: {\n        StorageDead(_192);\n        goto -> bb137;\n    }\n    bb134: {\n        StorageDead(_183);\n        goto -> bb137;\n    }\n    bb135: {\n        StorageDead(_182);\n        goto -> bb137;\n    }\n    bb136: {\n        StorageDead(_180);\n        StorageDead(_179);\n        goto -> bb137;\n    }\n    bb137: {\n        StorageDead(_181);\n        StorageDead(_178);\n        StorageDead(_175);\n        StorageLive(_214);\n        _214 = &(*_2);\n        StorageLive(_215);\n        StorageLive(_216);\n        _216 = _69;\n        _215 = RangeTo(move _216);\n        StorageDead(_216);\n        _213 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _214, move _215) -> [return: bb138, unwind unreachable];\n    }\n    bb138: {\n        StorageDead(_215);\n        StorageDead(_214);\n        _212 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_213) -> [return: bb139, unwind unreachable];\n    }\n    bb139: {\n        StorageLive(_217);\n        _217 = _25;\n        _0 = (_212, move _217);\n        StorageDead(_217);\n        StorageDead(_170);\n        StorageDead(_69);\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageDead(_25);\n        goto -> bb140;\n    }\n    bb140: {\n        return;\n    }\n}\n"
}