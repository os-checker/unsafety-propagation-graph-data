{
  "name": "core::num::flt2dec::strategy::dragon::format_exact",
  "span": "$library/core/src/num/flt2dec/strategy/dragon.rs:262:1: 266:40",
  "src": "pub fn format_exact<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n    limit: i16,\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n\n    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < v <= 10^(k_0+1)`.\n    let mut k = estimate_scaling_factor(d.mant, d.exp);\n\n    // `v = mant / scale`.\n    let mut mant = Big::from_u64(d.mant);\n    let mut scale = Big::from_small(1);\n    if d.exp < 0 {\n        scale.mul_pow2(-d.exp as usize);\n    } else {\n        mant.mul_pow2(d.exp as usize);\n    }\n\n    // divide `mant` by `10^k`. now `scale / 10 < mant <= scale * 10`.\n    if k >= 0 {\n        mul_pow10(&mut scale, k as usize);\n    } else {\n        mul_pow10(&mut mant, -k as usize);\n    }\n\n    // fixup when `mant + plus >= scale`, where `plus / scale = 10^-buf.len() / 2`.\n    // in order to keep the fixed-size bignum, we actually use `mant + floor(plus) >= scale`.\n    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n    // again with the shortest algorithm, `d[0]` can be zero but will be eventually rounded up.\n    if *div_2pow10(&mut scale.clone(), buf.len()).add(&mant) >= scale {\n        // equivalent to scaling `scale` by 10\n        k += 1;\n    } else {\n        mant.mul_small(10);\n    }\n\n    // if we are working with the last-digit limitation, we need to shorten the buffer\n    // before the actual rendering in order to avoid double rounding.\n    // note that we have to enlarge the buffer again when rounding up happens!\n    let mut len = if k < limit {\n        // oops, we cannot even produce *one* digit.\n        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n        // we return an empty buffer, with an exception of the later rounding-up case\n        // which occurs when `k == limit` and has to produce exactly one digit.\n        0\n    } else if ((k as i32 - limit as i32) as usize) < buf.len() {\n        (k - limit) as usize\n    } else {\n        buf.len()\n    };\n\n    if len > 0 {\n        // cache `(2, 4, 8) * scale` for digit generation.\n        // (this can be expensive, so do not calculate them when the buffer is empty.)\n        let mut scale2 = scale.clone();\n        scale2.mul_pow2(1);\n        let mut scale4 = scale.clone();\n        scale4.mul_pow2(2);\n        let mut scale8 = scale.clone();\n        scale8.mul_pow2(3);\n\n        for i in 0..len {\n            if mant.is_zero() {\n                // following digits are all zeroes, we stop here\n                // do *not* try to perform rounding! rather, fill remaining digits.\n                for c in &mut buf[i..len] {\n                    *c = MaybeUninit::new(b'0');\n                }\n                // SAFETY: we initialized that memory above.\n                return (unsafe { buf[..len].assume_init_ref() }, k);\n            }\n\n            let mut d = 0;\n            if mant >= scale8 {\n                mant.sub(&scale8);\n                d += 8;\n            }\n            if mant >= scale4 {\n                mant.sub(&scale4);\n                d += 4;\n            }\n            if mant >= scale2 {\n                mant.sub(&scale2);\n                d += 2;\n            }\n            if mant >= scale {\n                mant.sub(&scale);\n                d += 1;\n            }\n            debug_assert!(mant < scale);\n            debug_assert!(d < 10);\n            buf[i] = MaybeUninit::new(b'0' + d);\n            mant.mul_small(10);\n        }\n    }\n\n    // rounding up if we stop in the middle of digits\n    // if the following digits are exactly 5000..., check the prior digit and try to\n    // round to even (i.e., avoid rounding up when the prior digit is even).\n    let order = mant.cmp(scale.mul_small(5));\n    if order == Ordering::Greater\n        || (order == Ordering::Equal\n            // SAFETY: `buf[len-1]` is initialized.\n            && len > 0 && unsafe { buf[len - 1].assume_init() } & 1 == 1)\n    {\n        // if rounding up changes the length, the exponent should also change.\n        // but we've been requested a fixed number of digits, so do not alter the buffer...\n        // SAFETY: we initialized that memory above.\n        if let Some(c) = round_up(unsafe { buf[..len].assume_init_mut() }) {\n            // ...unless we've been requested the fixed precision instead.\n            // we also need to check that, if the original buffer was empty,\n            // the additional digit can only be added when `k == limit` (edge case).\n            k += 1;\n            if k > limit && len < buf.len() {\n                buf[len] = MaybeUninit::new(c);\n                len += 1;\n            }\n        }\n    }\n\n    // SAFETY: we initialized that memory above.\n    (unsafe { buf[..len].assume_init_ref() }, k)\n}"
}