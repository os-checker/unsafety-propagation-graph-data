{
  "name": "core::core_simd::swizzle::Swizzle::concat_swizzle",
  "span": "$library/core/src/../../portable-simd/crates/core_simd/src/swizzle.rs:122:5: 126:42",
  "src": "fn concat_swizzle<T, const M: usize>(first: Simd<T, M>, second: Simd<T, M>) -> Simd<T, N>\n    where\n        T: SimdElement,\n        LaneCount<N>: SupportedLaneCount,\n        LaneCount<M>: SupportedLaneCount,\n    {\n        // Safety: `first` and `second` are vectors, and the index is a const vector of u32.\n        unsafe {\n            core::intrinsics::simd::simd_shuffle(\n                first,\n                second,\n                const {\n                    let mut output = [0; N];\n                    let mut i = 0;\n                    while i < N {\n                        let index = Self::INDEX[i];\n                        assert!(index as u32 as usize == index);\n                        assert!(\n                            index < 2 * M,\n                            \"source element index exceeds input vector length\"\n                        );\n                        output[i] = index as u32;\n                        i += 1;\n                    }\n\n                    // The index list needs to be returned as a vector.\n                    #[repr(simd)]\n                    struct SimdShuffleIdx<const LEN: usize>([u32; LEN]);\n                    SimdShuffleIdx(output)\n                },\n            )\n        }\n    }"
}