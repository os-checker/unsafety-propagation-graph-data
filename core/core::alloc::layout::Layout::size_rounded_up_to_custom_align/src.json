{
  "name": "core::alloc::layout::Layout::size_rounded_up_to_custom_align",
  "span": "$library/core/src/alloc/layout.rs:284:5: 284:79",
  "src": "const fn size_rounded_up_to_custom_align(&self, align: Alignment) -> usize {\n        // SAFETY:\n        // Rounded up value is:\n        //   size_rounded_up = (size + align - 1) & !(align - 1);\n        //\n        // The arithmetic we do here can never overflow:\n        //\n        // 1. align is guaranteed to be > 0, so align - 1 is always\n        //    valid.\n        //\n        // 2. size is at most `isize::MAX`, so adding `align - 1` (which is at\n        //    most `isize::MAX`) can never overflow a `usize`.\n        //\n        // 3. masking by the alignment can remove at most `align - 1`,\n        //    which is what we just added, thus the value we return is never\n        //    less than the original `size`.\n        //\n        // (Size 0 Align MAX is already aligned, so stays the same, but things like\n        // Size 1 Align MAX or Size isize::MAX Align 2 round up to `isize::MAX + 1`.)\n        unsafe {\n            let align_m1 = unchecked_sub(align.as_usize(), 1);\n            unchecked_add(self.size, align_m1) & !align_m1\n        }\n    }"
}