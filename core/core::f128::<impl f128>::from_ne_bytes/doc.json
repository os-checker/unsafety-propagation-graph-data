{
  "name": "core::f128::<impl f128>::from_ne_bytes",
  "span": "$library/core/src/num/f128.rs:1140:5: 1140:56",
  "doc": " Creates a floating point value from its representation as a byte array in native endian.\n\n As the target platform's native endianness is used, portable code\n likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n appropriate instead.\n\n [`from_be_bytes`]: f128::from_be_bytes\n [`from_le_bytes`]: f128::from_le_bytes\n\n See [`from_bits`](Self::from_bits) for some discussion of the\n portability of this operation (there are almost no issues).\n\n # Examples\n\n ```\n #![feature(f128)]\n # // FIXME(f16_f128): remove when `eqtf2` is available\n # #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] {\n\n let value = f128::from_ne_bytes(if cfg!(target_endian = \"big\") {\n     [0x40, 0x02, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n } else {\n     [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x02, 0x40]\n });\n assert_eq!(value, 12.5);\n # }\n ```\n"
}