{
  "name": "core::<net::socket_addr::SocketAddrV6 as fmt::Display>::fmt",
  "span": "$library/core/src/net/socket_addr.rs:673:5: 673:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // If there are no alignment requirements, write the socket address directly to `f`.\n        // Otherwise, write it to a local buffer and then use `f.pad`.\n        if f.precision().is_none() && f.width().is_none() {\n            match self.scope_id() {\n                0 => write!(f, \"[{}]:{}\", self.ip(), self.port()),\n                scope_id => write!(f, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n            }\n        } else {\n            const LONGEST_IPV6_SOCKET_ADDR: &str =\n                \"[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff%4294967295]:65535\";\n\n            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_SOCKET_ADDR.len() }>::new();\n            match self.scope_id() {\n                0 => write!(buf, \"[{}]:{}\", self.ip(), self.port()),\n                scope_id => write!(buf, \"[{}%{}]:{}\", self.ip(), scope_id, self.port()),\n            }\n            // Buffer is long enough for the longest possible IPv6 socket address, so this should never fail.\n            .unwrap();\n\n            f.pad(buf.as_str())\n        }\n    }"
}