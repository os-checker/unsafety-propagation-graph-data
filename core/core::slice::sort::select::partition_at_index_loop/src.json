{
  "name": "core::slice::sort::select::partition_at_index_loop",
  "span": "$library/core/src/slice/sort/select.rs:66:1: 72:30",
  "src": "fn partition_at_index_loop<'a, T, F>(\n    mut v: &'a mut [T],\n    mut index: usize,\n    mut ancestor_pivot: Option<&'a T>,\n    is_less: &mut F,\n) where\n    F: FnMut(&T, &T) -> bool,\n{\n    // Limit the amount of iterations and fall back to fast deterministic selection to ensure O(n)\n    // worst case running time. This limit needs to be constant, because using `ilog2(len)` like in\n    // `sort` would result in O(n log n) time complexity. The exact value of the limit is chosen\n    // somewhat arbitrarily, but for most inputs bad pivot selections should be relatively rare, so\n    // the limit is reached for sub-slices len / (2^limit or less). Which makes the remaining work\n    // with the fallback minimal in relative terms.\n    let mut limit = 16;\n\n    loop {\n        if v.len() <= INSERTION_SORT_THRESHOLD {\n            if v.len() >= 2 {\n                insertion_sort_shift_left(v, 1, is_less);\n            }\n            return;\n        }\n\n        if limit == 0 {\n            median_of_medians(v, is_less, index);\n            return;\n        }\n\n        limit -= 1;\n\n        // Choose a pivot\n        let pivot_pos = choose_pivot(v, is_less);\n\n        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n        // This case is usually hit when the slice contains many duplicate elements.\n        if let Some(p) = ancestor_pivot {\n            let pivot = &v[pivot_pos];\n\n            if !is_less(p, pivot) {\n                let num_lt = partition(v, pivot_pos, &mut |a, b| !is_less(b, a));\n\n                // Continue sorting elements greater than the pivot. We know that `mid` contains\n                // the pivot. So we can continue after `mid`.\n                let mid = num_lt + 1;\n\n                // If we've passed our index, then we're good.\n                if mid > index {\n                    return;\n                }\n\n                v = &mut v[mid..];\n                index = index - mid;\n                ancestor_pivot = None;\n                continue;\n            }\n        }\n\n        let mid = partition(v, pivot_pos, is_less);\n\n        // Split the slice into `left`, `pivot`, and `right`.\n        let (left, right) = v.split_at_mut(mid);\n        let (pivot, right) = right.split_at_mut(1);\n        let pivot = &pivot[0];\n\n        if mid < index {\n            v = right;\n            index = index - mid - 1;\n            ancestor_pivot = Some(pivot);\n        } else if mid > index {\n            v = left;\n        } else {\n            // If mid == index, then we're done, since partition() guaranteed that all elements\n            // after mid are greater than or equal to mid.\n            return;\n        }\n    }\n}"
}