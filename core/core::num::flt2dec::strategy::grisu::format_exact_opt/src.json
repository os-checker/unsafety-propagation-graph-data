{
  "name": "core::num::flt2dec::strategy::grisu::format_exact_opt",
  "span": "$library/core/src/num/flt2dec/strategy/grisu.rs:471:1: 475:48",
  "src": "pub fn format_exact_opt<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n    limit: i16,\n) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n    assert!(d.mant > 0);\n    assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n    assert!(!buf.is_empty());\n\n    // normalize and scale `v`.\n    let v = Fp { f: d.mant, e: d.exp }.normalize();\n    let (minusk, cached) = cached_power(ALPHA - v.e - 64, GAMMA - v.e - 64);\n    let v = v.mul(cached);\n\n    // divide `v` into integral and fractional parts.\n    let e = -v.e as usize;\n    let vint = (v.f >> e) as u32;\n    let vfrac = v.f & ((1 << e) - 1);\n\n    let requested_digits = buf.len();\n\n    const POW10_UP_TO_9: [u32; 10] =\n        [1, 10, 100, 1000, 10_000, 100_000, 1_000_000, 10_000_000, 100_000_000, 1_000_000_000];\n\n    // We deviate from the original algorithm here and do some early checks to determine if we can satisfy requested_digits.\n    // If we determine that we can't, we exit early and avoid most of the heavy lifting that the algorithm otherwise does.\n    //\n    // When vfrac is zero, we can easily determine if vint can satisfy requested digits:\n    //      If requested_digits >= 11, vint is not able to exhaust the count by itself since 10^(11 -1) > u32 max value >= vint.\n    //      If vint < 10^(requested_digits - 1), vint cannot exhaust the count.\n    //      Otherwise, vint might be able to exhaust the count and we need to execute the rest of the code.\n    if (vfrac == 0) && ((requested_digits >= 11) || (vint < POW10_UP_TO_9[requested_digits - 1])) {\n        return None;\n    }\n\n    // both old `v` and new `v` (scaled by `10^-k`) has an error of < 1 ulp (Theorem 5.1).\n    // as we don't know the error is positive or negative, we use two approximations\n    // spaced equally and have the maximal error of 2 ulps (same to the shortest case).\n    //\n    // the goal is to find the exactly rounded series of digits that are common to\n    // both `v - 1 ulp` and `v + 1 ulp`, so that we are maximally confident.\n    // if this is not possible, we don't know which one is the correct output for `v`,\n    // so we give up and fall back.\n    //\n    // `err` is defined as `1 ulp * 2^e` here (same to the ulp in `vfrac`),\n    // and we will scale it whenever `v` gets scaled.\n    let mut err = 1;\n\n    // calculate the largest `10^max_kappa` no more than `v` (thus `v < 10^(max_kappa+1)`).\n    // this is an upper bound of `kappa` below.\n    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(vint);\n\n    let mut i = 0;\n    let exp = max_kappa as i16 - minusk + 1;\n\n    // if we are working with the last-digit limitation, we need to shorten the buffer\n    // before the actual rendering in order to avoid double rounding.\n    // note that we have to enlarge the buffer again when rounding up happens!\n    let len = if exp <= limit {\n        // oops, we cannot even produce *one* digit.\n        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n        //\n        // in principle we can immediately call `possibly_round` with an empty buffer,\n        // but scaling `max_ten_kappa << e` by 10 can result in overflow.\n        // thus we are being sloppy here and widen the error range by a factor of 10.\n        // this will increase the false negative rate, but only very, *very* slightly;\n        // it can only matter noticeably when the mantissa is bigger than 60 bits.\n        //\n        // SAFETY: `len=0`, so the obligation of having initialized this memory is trivial.\n        return unsafe {\n            possibly_round(buf, 0, exp, limit, v.f / 10, (max_ten_kappa as u64) << e, err << e)\n        };\n    } else if ((exp as i32 - limit as i32) as usize) < buf.len() {\n        (exp - limit) as usize\n    } else {\n        buf.len()\n    };\n    debug_assert!(len > 0);\n\n    // render integral parts.\n    // the error is entirely fractional, so we don't need to check it in this part.\n    let mut kappa = max_kappa as i16;\n    let mut ten_kappa = max_ten_kappa; // 10^kappa\n    let mut remainder = vint; // digits yet to be rendered\n    loop {\n        // we always have at least one digit to render\n        // invariants:\n        // - `remainder < 10^(kappa+1)`\n        // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n        //   (it follows that `remainder = vint % 10^(kappa+1)`)\n\n        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n        let q = remainder / ten_kappa;\n        let r = remainder % ten_kappa;\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        // is the buffer full? run the rounding pass with the remainder.\n        if i == len {\n            let vrem = ((r as u64) << e) + vfrac; // == (v % 10^kappa) * 2^e\n            // SAFETY: we have initialized `len` many bytes.\n            return unsafe {\n                possibly_round(buf, len, exp, limit, vrem, (ten_kappa as u64) << e, err << e)\n            };\n        }\n\n        // break the loop when we have rendered all integral digits.\n        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n        if i > max_kappa as usize {\n            debug_assert_eq!(ten_kappa, 1);\n            debug_assert_eq!(kappa, 0);\n            break;\n        }\n\n        // restore invariants\n        kappa -= 1;\n        ten_kappa /= 10;\n        remainder = r;\n    }\n\n    // render fractional parts.\n    //\n    // in principle we can continue to the last available digit and check for the accuracy.\n    // unfortunately we are working with the finite-sized integers, so we need some criterion\n    // to detect the overflow. V8 uses `remainder > err`, which becomes false when\n    // the first `i` significant digits of `v - 1 ulp` and `v` differ. however this rejects\n    // too many otherwise valid input.\n    //\n    // since the later phase has a correct overflow detection, we instead use tighter criterion:\n    // we continue til `err` exceeds `10^kappa / 2`, so that the range between `v - 1 ulp` and\n    // `v + 1 ulp` definitely contains two or more rounded representations. this is same to\n    // the first two comparisons from `possibly_round`, for the reference.\n    let mut remainder = vfrac;\n    let maxerr = 1 << (e - 1);\n    while err < maxerr {\n        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n        // - `remainder < 2^e`\n        // - `vfrac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n        // - `err = 10^(n-m)`\n\n        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n        err *= 10; // won't overflow, `err * 10 < 2^e * 5 < 2^64`\n\n        // divide `remainder` by `10^kappa`.\n        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n        let q = remainder >> e;\n        let r = remainder & ((1 << e) - 1);\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        // is the buffer full? run the rounding pass with the remainder.\n        if i == len {\n            // SAFETY: we have initialized `len` many bytes.\n            return unsafe { possibly_round(buf, len, exp, limit, r, 1 << e, err) };\n        }\n\n        // restore invariants\n        remainder = r;\n    }\n\n    // further calculation is useless (`possibly_round` definitely fails), so we give up.\n    return None;\n\n    // we've generated all requested digits of `v`, which should be also same to corresponding\n    // digits of `v - 1 ulp`. now we check if there is a unique representation shared by\n    // both `v - 1 ulp` and `v + 1 ulp`; this can be either same to generated digits, or\n    // to the rounded-up version of those digits. if the range contains multiple representations\n    // of the same length, we cannot be sure and should return `None` instead.\n    //\n    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n    // - `remainder = (v % 10^kappa) * k`\n    // - `ten_kappa = 10^kappa * k`\n    // - `ulp = 2^-e * k`\n    //\n    // SAFETY: the first `len` bytes of `buf` must be initialized.\n    unsafe fn possibly_round(\n        buf: &mut [MaybeUninit<u8>],\n        mut len: usize,\n        mut exp: i16,\n        limit: i16,\n        remainder: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        debug_assert!(remainder < ten_kappa);\n\n        //           10^kappa\n        //    :   :   :<->:   :\n        //    :   :   :   :   :\n        //    :|1 ulp|1 ulp|  :\n        //    :|<--->|<--->|  :\n        // ----|-----|-----|----\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // (for the reference, the dotted line indicates the exact value for\n        // possible representations in given number of digits.)\n        //\n        // error is too large that there are at least three possible representations\n        // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n        if ulp >= ten_kappa {\n            return None;\n        }\n\n        //    10^kappa\n        //   :<------->:\n        //   :         :\n        //   : |1 ulp|1 ulp|\n        //   : |<--->|<--->|\n        // ----|-----|-----|----\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // in fact, 1/2 ulp is enough to introduce two possible representations.\n        // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n        // this won't overflow, as `ulp < ten_kappa` from the first check.\n        if ten_kappa - ulp <= ulp {\n            return None;\n        }\n\n        //     remainder\n        //       :<->|                           :\n        //       :   |                           :\n        //       :<--------- 10^kappa ---------->:\n        //     | :   |                           :\n        //     |1 ulp|1 ulp|                     :\n        //     |<--->|<--->|                     :\n        // ----|-----|-----|------------------------\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // if `v + 1 ulp` is closer to the rounded-down representation (which is already in `buf`),\n        // then we can safely return. note that `v - 1 ulp` *can* be less than the current\n        // representation, but as `1 ulp < 10^kappa / 2`, this condition is enough:\n        // the distance between `v - 1 ulp` and the current representation\n        // cannot exceed `10^kappa / 2`.\n        //\n        // the condition equals to `remainder + ulp < 10^kappa / 2`.\n        // since this can easily overflow, first check if `remainder < 10^kappa / 2`.\n        // we've already verified that `ulp < 10^kappa / 2`, so as long as\n        // `10^kappa` did not overflow after all, the second check is fine.\n        if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n            // SAFETY: our caller initialized that memory.\n            return Some((unsafe { buf[..len].assume_init_ref() }, exp));\n        }\n\n        //   :<------- remainder ------>|   :\n        //   :                          |   :\n        //   :<--------- 10^kappa --------->:\n        //   :                    |     |   : |\n        //   :                    |1 ulp|1 ulp|\n        //   :                    |<--->|<--->|\n        // -----------------------|-----|-----|-----\n        //                        |     v     |\n        //                    v - 1 ulp   v + 1 ulp\n        //\n        // on the other hands, if `v - 1 ulp` is closer to the rounded-up representation,\n        // we should round up and return. for the same reason we don't need to check `v + 1 ulp`.\n        //\n        // the condition equals to `remainder - ulp >= 10^kappa / 2`.\n        // again we first check if `remainder > ulp` (note that this is not `remainder >= ulp`,\n        // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n        // so the second check does not overflow.\n        if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n            if let Some(c) =\n                // SAFETY: our caller must have initialized that memory.\n                round_up(unsafe { buf[..len].assume_init_mut() })\n            {\n                // only add an additional digit when we've been requested the fixed precision.\n                // we also need to check that, if the original buffer was empty,\n                // the additional digit can only be added when `exp == limit` (edge case).\n                exp += 1;\n                if exp > limit && len < buf.len() {\n                    buf[len] = MaybeUninit::new(c);\n                    len += 1;\n                }\n            }\n            // SAFETY: we and our caller initialized that memory.\n            return Some((unsafe { buf[..len].assume_init_ref() }, exp));\n        }\n\n        // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are\n        // rounding down and others are rounding up) and give up.\n        None\n    }\n}"
}