{
  "name": "core::fmt::num::<impl fmt::LowerHex for u64>::fmt",
  "span": "$library/core/src/fmt/num.rs:14:13: 14:69",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                // Check macro arguments at compile time.\n                const {\n                    assert!($Unsigned::MIN == 0, \"need unsigned\");\n                    assert!($dig_tab.is_ascii(), \"need single-byte entries\");\n                }\n\n                // ASCII digits in ascending order are used as a lookup table.\n                const DIG_TAB: &[u8] = $dig_tab;\n                const BASE: $Unsigned = DIG_TAB.len() as $Unsigned;\n                const MAX_DIG_N: usize = $Unsigned::MAX.ilog(BASE) as usize + 1;\n\n                // Buffer digits of self with right alignment.\n                let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DIG_N];\n                // Count the number of bytes in buf that are not initialized.\n                let mut offset = buf.len();\n\n                // Accumulate each digit of the number from the least\n                // significant to the most significant figure.\n                let mut remain = *self;\n                loop {\n                    let digit = remain % BASE;\n                    remain /= BASE;\n\n                    offset -= 1;\n                    // SAFETY: `remain` will reach 0 and we will break before `offset` wraps\n                    unsafe { core::hint::assert_unchecked(offset < buf.len()) }\n                    buf[offset].write(DIG_TAB[digit as usize]);\n                    if remain == 0 {\n                        break;\n                    }\n                }\n\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                let digits = unsafe { slice_buffer_to_str(&buf, offset) };\n                f.pad_integral(true, $prefix, digits)\n            }"
}