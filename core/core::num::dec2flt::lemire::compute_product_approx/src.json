{
  "name": "core::num::dec2flt::lemire::compute_product_approx",
  "span": "$library/core/src/num/dec2flt/lemire.rs:135:1: 135:74",
  "src": "fn compute_product_approx(q: i64, w: u64, precision: usize) -> (u64, u64) {\n    debug_assert!(q >= SMALLEST_POWER_OF_FIVE as i64);\n    debug_assert!(q <= LARGEST_POWER_OF_FIVE as i64);\n    debug_assert!(precision <= 64);\n\n    let mask = if precision < 64 {\n        0xFFFF_FFFF_FFFF_FFFF_u64 >> precision\n    } else {\n        0xFFFF_FFFF_FFFF_FFFF_u64\n    };\n\n    // 5^q < 2^64, then the multiplication always provides an exact value.\n    // That means whenever we need to round ties to even, we always have\n    // an exact value.\n    let index = (q - SMALLEST_POWER_OF_FIVE as i64) as usize;\n    let (lo5, hi5) = POWER_OF_FIVE_128[index];\n    // Only need one multiplication as long as there is 1 zero but\n    // in the explicit mantissa bits, +1 for the hidden bit, +1 to\n    // determine the rounding direction, +1 for if the computed\n    // product has a leading zero.\n    let (mut first_lo, mut first_hi) = full_multiplication(w, lo5);\n    if first_hi & mask == mask {\n        // Need to do a second multiplication to get better precision\n        // for the lower product. This will always be exact\n        // where q is < 55, since 5^55 < 2^128. If this wraps,\n        // then we need to round up the hi product.\n        let (_, second_hi) = full_multiplication(w, hi5);\n        first_lo = first_lo.wrapping_add(second_hi);\n        if second_hi > first_lo {\n            first_hi += 1;\n        }\n    }\n    (first_lo, first_hi)\n}"
}