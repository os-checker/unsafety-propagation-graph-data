{
  "name": "core::slice::sort::unstable::heapsort::sift_down",
  "span": "$library/core/src/slice/sort/unstable/heapsort.rs:37:1: 39:30",
  "src": "unsafe fn sift_down<T, F>(v: &mut [T], mut node: usize, is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // SAFETY: See function safety.\n    unsafe {\n        intrinsics::assume(node <= v.len());\n    }\n\n    let len = v.len();\n\n    let v_base = v.as_mut_ptr();\n\n    loop {\n        // Children of `node`.\n        let mut child = 2 * node + 1;\n        if child >= len {\n            break;\n        }\n\n        // SAFETY: The invariants and checks guarantee that both node and child are in-bounds.\n        unsafe {\n            // Choose the greater child.\n            if child + 1 < len {\n                // We need a branch to be sure not to out-of-bounds index,\n                // but it's highly predictable.  The comparison, however,\n                // is better done branchless, especially for primitives.\n                child += is_less(&*v_base.add(child), &*v_base.add(child + 1)) as usize;\n            }\n\n            // Stop if the invariant holds at `node`.\n            if !is_less(&*v_base.add(node), &*v_base.add(child)) {\n                break;\n            }\n\n            ptr::swap_nonoverlapping(v_base.add(node), v_base.add(child), 1);\n        }\n\n        node = child;\n    }\n}"
}