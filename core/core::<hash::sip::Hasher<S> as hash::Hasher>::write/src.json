{
  "name": "core::<hash::sip::Hasher<S> as hash::Hasher>::write",
  "span": "$library/core/src/hash/sip.rs:255:5: 255:36",
  "src": "fn write(&mut self, msg: &[u8]) {\n        let length = msg.len();\n        self.length += length;\n\n        let mut needed = 0;\n\n        if self.ntail != 0 {\n            needed = 8 - self.ntail;\n            // SAFETY: `cmp::min(length, needed)` is guaranteed to not be over `length`\n            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n            if length < needed {\n                self.ntail += length;\n                return;\n            } else {\n                self.state.v3 ^= self.tail;\n                S::c_rounds(&mut self.state);\n                self.state.v0 ^= self.tail;\n                self.ntail = 0;\n            }\n        }\n\n        // Buffered tail is now flushed, process new input.\n        let len = length - needed;\n        let left = len & 0x7; // len % 8\n\n        let mut i = needed;\n        while i < len - left {\n            // SAFETY: because `len - left` is the biggest multiple of 8 under\n            // `len`, and because `i` starts at `needed` where `len` is `length - needed`,\n            // `i + 8` is guaranteed to be less than or equal to `length`.\n            let mi = unsafe { load_int_le!(msg, i, u64) };\n\n            self.state.v3 ^= mi;\n            S::c_rounds(&mut self.state);\n            self.state.v0 ^= mi;\n\n            i += 8;\n        }\n\n        // SAFETY: `i` is now `needed + len.div_euclid(8) * 8`,\n        // so `i + left` = `needed + len` = `length`, which is by\n        // definition equal to `msg.len()`.\n        self.tail = unsafe { u8to64_le(msg, i, left) };\n        self.ntail = left;\n    }"
}