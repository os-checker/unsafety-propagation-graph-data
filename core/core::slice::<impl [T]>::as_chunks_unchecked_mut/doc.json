{
  "name": "core::slice::<impl [T]>::as_chunks_unchecked_mut",
  "span": "$library/core/src/slice/mod.rs:1497:5: 1497:92",
  "doc": " Splits the slice into a slice of `N`-element arrays,\n assuming that there's no remainder.\n\n This is the inverse operation to [`as_flattened_mut`].\n\n [`as_flattened_mut`]: slice::as_flattened_mut\n\n As this is `unsafe`, consider whether you could use [`as_chunks_mut`] or\n [`as_rchunks_mut`] instead, perhaps via something like\n `if let (chunks, []) = slice.as_chunks_mut()` or\n `let (chunks, []) = slice.as_chunks_mut() else { unreachable!() };`.\n\n [`as_chunks_mut`]: slice::as_chunks_mut\n [`as_rchunks_mut`]: slice::as_rchunks_mut\n\n # Safety\n\n This may only be called when\n - The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).\n - `N != 0`.\n\n # Examples\n\n ```\n let slice: &mut [char] = &mut ['l', 'o', 'r', 'e', 'm', '!'];\n let chunks: &mut [[char; 1]] =\n     // SAFETY: 1-element chunks never have remainder\n     unsafe { slice.as_chunks_unchecked_mut() };\n chunks[0] = ['L'];\n assert_eq!(chunks, &[['L'], ['o'], ['r'], ['e'], ['m'], ['!']]);\n let chunks: &mut [[char; 3]] =\n     // SAFETY: The slice length (6) is a multiple of 3\n     unsafe { slice.as_chunks_unchecked_mut() };\n chunks[1] = ['a', 'x', '?'];\n assert_eq!(slice, &['L', 'o', 'r', 'a', 'x', '?']);\n\n // These would be unsound:\n // let chunks: &[[_; 5]] = slice.as_chunks_unchecked_mut() // The slice length is not a multiple of 5\n // let chunks: &[[_; 0]] = slice.as_chunks_unchecked_mut() // Zero-length chunks are never allowed\n ```\n"
}