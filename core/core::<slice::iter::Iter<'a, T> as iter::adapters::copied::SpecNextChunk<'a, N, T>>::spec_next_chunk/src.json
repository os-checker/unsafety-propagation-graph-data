{
  "name": "core::<slice::iter::Iter<'a, T> as iter::adapters::copied::SpecNextChunk<'a, N, T>>::spec_next_chunk",
  "span": "$library/core/src/iter/adapters/copied.rs:208:5: 208:75",
  "src": "fn spec_next_chunk(&mut self) -> Result<[T; N], array::IntoIter<T, N>> {\n        let mut raw_array = [const { MaybeUninit::uninit() }; N];\n\n        let len = self.len();\n\n        if T::IS_ZST {\n            if len < N {\n                let _ = self.advance_by(len);\n                // SAFETY: ZSTs can be conjured ex nihilo; only the amount has to be correct\n                return Err(unsafe { array::IntoIter::new_unchecked(raw_array, 0..len) });\n            }\n\n            let _ = self.advance_by(N);\n            // SAFETY: ditto\n            return Ok(unsafe { MaybeUninit::array_assume_init(raw_array) });\n        }\n\n        if len < N {\n            // SAFETY: `len` indicates that this many elements are available and we just checked that\n            // it fits into the array.\n            unsafe {\n                ptr::copy_nonoverlapping(\n                    self.as_ref().as_ptr(),\n                    raw_array.as_mut_ptr() as *mut T,\n                    len,\n                );\n                let _ = self.advance_by(len);\n                return Err(array::IntoIter::new_unchecked(raw_array, 0..len));\n            }\n        }\n\n        // SAFETY: `len` is larger than the array size. Copy a fixed amount here to fully initialize\n        // the array.\n        unsafe {\n            ptr::copy_nonoverlapping(self.as_ref().as_ptr(), raw_array.as_mut_ptr() as *mut T, N);\n            let _ = self.advance_by(N);\n            Ok(MaybeUninit::array_assume_init(raw_array))\n        }\n    }"
}