{
  "name": "core::<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_nth",
  "span": "$library/core/src/iter/adapters/step_by.rs:253:5: 253:68",
  "src": "default fn spec_nth(&mut self, mut n: usize) -> Option<I::Item> {\n        if self.first_take {\n            self.first_take = false;\n            let first = self.iter.next();\n            if n == 0 {\n                return first;\n            }\n            n -= 1;\n        }\n        // n and self.step_minus_one are indices, we need to add 1 to get the amount of elements\n        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n        let mut step = self.original_step().get();\n        // n + 1 could overflow\n        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n        if n == usize::MAX {\n            self.iter.nth(step - 1);\n        } else {\n            n += 1;\n        }\n\n        // overflow handling\n        loop {\n            let mul = n.checked_mul(step);\n            {\n                if intrinsics::likely(mul.is_some()) {\n                    return self.iter.nth(mul.unwrap() - 1);\n                }\n            }\n            let div_n = usize::MAX / n;\n            let div_step = usize::MAX / step;\n            let nth_n = div_n * n;\n            let nth_step = div_step * step;\n            let nth = if nth_n > nth_step {\n                step -= div_n;\n                nth_n\n            } else {\n                n -= div_step;\n                nth_step\n            };\n            self.iter.nth(nth - 1);\n        }\n    }"
}