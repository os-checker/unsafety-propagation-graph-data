{
  "name": "core::<any::TypeId as hash::Hash>::hash",
  "span": "$library/core/src/any.rs:807:5: 807:51",
  "src": "fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        // We only hash the lower 64 bits of our (128 bit) internal numeric ID,\n        // because:\n        // - The hashing algorithm which backs `TypeId` is expected to be\n        //   unbiased and high quality, meaning further mixing would be somewhat\n        //   redundant compared to choosing (the lower) 64 bits arbitrarily.\n        // - `Hasher::finish` returns a u64 anyway, so the extra entropy we'd\n        //   get from hashing the full value would probably not be useful\n        //   (especially given the previous point about the lower 64 bits being\n        //   high quality on their own).\n        // - It is correct to do so -- only hashing a subset of `self` is still\n        //   compatible with an `Eq` implementation that considers the entire\n        //   value, as ours does.\n        let data =\n        // SAFETY: The `offset` stays in-bounds, it just moves the pointer to the 2nd half of the `TypeId`.\n        // Only the first ptr-sized chunk ever has provenance, so that second half is always\n        // fine to read at integer type.\n            unsafe { crate::ptr::read_unaligned(self.data.as_ptr().cast::<u64>().offset(1)) };\n        data.hash(state);\n    }"
}