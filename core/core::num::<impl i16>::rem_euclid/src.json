{
  "name": "core::num::<impl i16>::rem_euclid",
  "span": "$library/core/src/num/int_macros.rs:3184:9: 3184:57",
  "src": "pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n                // and is clearly equivalent, because `r` is negative.\n                // Otherwise, `rhs` is `Self::MIN`, then we have\n                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n                // `r - Self::MIN`, which is what we wanted (and will not overflow\n                // for negative `r`).\n                r.wrapping_add(rhs.wrapping_abs())\n            } else {\n                r\n            }\n        }"
}