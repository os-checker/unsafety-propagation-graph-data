{
  "name": "core::num::dec2flt::decimal_seq::parse_decimal_seq",
  "span": "$library/core/src/num/dec2flt/decimal_seq.rs:220:1: 220:53",
  "src": "pub fn parse_decimal_seq(mut s: &[u8]) -> DecimalSeq {\n    let mut d = DecimalSeq::default();\n    let start = s;\n\n    while let Some((&b'0', s_next)) = s.split_first() {\n        s = s_next;\n    }\n\n    s = s.parse_digits(|digit| d.try_add_digit(digit));\n\n    if let Some((b'.', s_next)) = s.split_first() {\n        s = s_next;\n        let first = s;\n        // Skip leading zeros.\n        if d.num_digits == 0 {\n            while let Some((&b'0', s_next)) = s.split_first() {\n                s = s_next;\n            }\n        }\n        while s.len() >= 8 && d.num_digits + 8 < DecimalSeq::MAX_DIGITS {\n            let v = s.read_u64();\n            if !is_8digits(v) {\n                break;\n            }\n            d.digits[d.num_digits..].write_u64(v - 0x3030_3030_3030_3030);\n            d.num_digits += 8;\n            s = &s[8..];\n        }\n        s = s.parse_digits(|digit| d.try_add_digit(digit));\n        d.decimal_point = s.len() as i32 - first.len() as i32;\n    }\n\n    if d.num_digits != 0 {\n        // Ignore the trailing zeros if there are any\n        let mut n_trailing_zeros = 0;\n        for &c in start[..(start.len() - s.len())].iter().rev() {\n            if c == b'0' {\n                n_trailing_zeros += 1;\n            } else if c != b'.' {\n                break;\n            }\n        }\n        d.decimal_point += n_trailing_zeros as i32;\n        d.num_digits -= n_trailing_zeros;\n        d.decimal_point += d.num_digits as i32;\n        if d.num_digits > DecimalSeq::MAX_DIGITS {\n            d.truncated = true;\n            d.num_digits = DecimalSeq::MAX_DIGITS;\n        }\n    }\n\n    if let Some((&ch, s_next)) = s.split_first() {\n        if ch == b'e' || ch == b'E' {\n            s = s_next;\n            let mut neg_exp = false;\n            if let Some((&ch, s_next)) = s.split_first() {\n                neg_exp = ch == b'-';\n                if ch == b'-' || ch == b'+' {\n                    s = s_next;\n                }\n            }\n            let mut exp_num = 0_i32;\n\n            s.parse_digits(|digit| {\n                if exp_num < 0x10000 {\n                    exp_num = 10 * exp_num + digit as i32;\n                }\n            });\n\n            d.decimal_point += if neg_exp { -exp_num } else { exp_num };\n        }\n    }\n\n    for i in d.num_digits..DecimalSeq::MAX_DIGITS_WITHOUT_OVERFLOW {\n        d.digits[i] = 0;\n    }\n\n    d\n}"
}