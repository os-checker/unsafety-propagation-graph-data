{
  "name": "core::iter::adapters::peekable::Peekable::<I>::next_if_map",
  "span": "$library/core/src/iter/adapters/peekable.rs:412:5: 412:97",
  "doc": " Consumes the next value of this iterator and applies a function `f` on it,\n returning the result if the closure returns `Ok`.\n\n Otherwise if the closure returns `Err` the value is put back for the next iteration.\n\n The content of the `Err` variant is typically the original value of the closure,\n but this is not required. If a different value is returned,\n the next `peek()` or `next()` call will result in this new value.\n This is similar to modifying the output of `peek_mut()`.\n\n If the closure panics, the next value will always be consumed and dropped\n even if the panic is caught, because the closure never returned an `Err` value to put back.\n\n See also: [`next_if_map_mut`](Self::next_if_map_mut).\n\n # Examples\n\n Parse the leading decimal number from an iterator of characters.\n ```\n #![feature(peekable_next_if_map)]\n let mut iter = \"125 GOTO 10\".chars().peekable();\n let mut line_num = 0_u32;\n while let Some(digit) = iter.next_if_map(|c| c.to_digit(10).ok_or(c)) {\n     line_num = line_num * 10 + digit;\n }\n assert_eq!(line_num, 125);\n assert_eq!(iter.collect::<String>(), \" GOTO 10\");\n ```\n\n Matching custom types.\n ```\n #![feature(peekable_next_if_map)]\n\n #[derive(Debug, PartialEq, Eq)]\n enum Node {\n     Comment(String),\n     Red(String),\n     Green(String),\n     Blue(String),\n }\n\n /// Combines all consecutive `Comment` nodes into a single one.\n fn combine_comments(nodes: Vec<Node>) -> Vec<Node> {\n     let mut result = Vec::with_capacity(nodes.len());\n     let mut iter = nodes.into_iter().peekable();\n     let mut comment_text = None::<String>;\n     loop {\n         // Typically the closure in .next_if_map() matches on the input,\n         //  extracts the desired pattern into an `Ok`,\n         //  and puts the rest into an `Err`.\n         while let Some(text) = iter.next_if_map(|node| match node {\n             Node::Comment(text) => Ok(text),\n             other => Err(other),\n         }) {\n             comment_text.get_or_insert_default().push_str(&text);\n         }\n\n         if let Some(text) = comment_text.take() {\n             result.push(Node::Comment(text));\n         }\n         if let Some(node) = iter.next() {\n             result.push(node);\n         } else {\n             break;\n         }\n     }\n     result\n }\n# assert_eq!( // hiding the test to avoid cluttering the documentation.\n#     combine_comments(vec![\n#         Node::Comment(\"The\".to_owned()),\n#         Node::Comment(\"Quick\".to_owned()),\n#         Node::Comment(\"Brown\".to_owned()),\n#         Node::Red(\"Fox\".to_owned()),\n#         Node::Green(\"Jumped\".to_owned()),\n#         Node::Comment(\"Over\".to_owned()),\n#         Node::Blue(\"The\".to_owned()),\n#         Node::Comment(\"Lazy\".to_owned()),\n#         Node::Comment(\"Dog\".to_owned()),\n#     ]),\n#     vec![\n#         Node::Comment(\"TheQuickBrown\".to_owned()),\n#         Node::Red(\"Fox\".to_owned()),\n#         Node::Green(\"Jumped\".to_owned()),\n#         Node::Comment(\"Over\".to_owned()),\n#         Node::Blue(\"The\".to_owned()),\n#         Node::Comment(\"LazyDog\".to_owned()),\n#     ],\n# )\n ```\n"
}