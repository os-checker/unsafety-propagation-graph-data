{
  "name": "core::fmt::Formatter::<'a>::pad_formatted_parts",
  "span": "$library/core/src/fmt/mod.rs:1980:5: 1980:90",
  "src": "unsafe fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n        if self.options.width == 0 {\n            // this is the common case and we take a shortcut\n            // SAFETY: Per the precondition.\n            unsafe { self.write_formatted_parts(formatted) }\n        } else {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let mut width = self.options.width;\n            let old_options = self.options;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = formatted.sign;\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = \"\";\n                width = width.saturating_sub(sign.len() as u16);\n                self.options.fill('0').align(Some(Alignment::Right));\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if usize::from(width) <= len {\n                // no padding\n                // SAFETY: Per the precondition.\n                unsafe { self.write_formatted_parts(&formatted) }\n            } else {\n                let post_padding = self.padding(width - len as u16, Alignment::Right)?;\n                // SAFETY: Per the precondition.\n                unsafe {\n                    self.write_formatted_parts(&formatted)?;\n                }\n                post_padding.write(self)\n            };\n            self.options = old_options;\n            ret\n        }\n    }"
}