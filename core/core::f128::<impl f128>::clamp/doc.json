{
  "name": "core::f128::<impl f128>::clamp",
  "span": "$library/core/src/num/f128.rs:1276:5: 1276:63",
  "doc": " Restrict a value to a certain interval unless it is NaN.\n\n Returns `max` if `self` is greater than `max`, and `min` if `self` is\n less than `min`. Otherwise this returns `self`.\n\n Note that this function returns NaN if the initial value was NaN as\n well. If the result is zero and among the three inputs `self`, `min`, and `max` there are\n zeros with different sign, either `0.0` or `-0.0` is returned non-deterministically.\n\n # Panics\n\n Panics if `min > max`, `min` is NaN, or `max` is NaN.\n\n # Examples\n\n ```\n #![feature(f128)]\n # // FIXME(f16_f128): remove when `{eq,gt,unord}tf` are available\n # #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] {\n\n assert!((-3.0f128).clamp(-2.0, 1.0) == -2.0);\n assert!((0.0f128).clamp(-2.0, 1.0) == 0.0);\n assert!((2.0f128).clamp(-2.0, 1.0) == 1.0);\n assert!((f128::NAN).clamp(-2.0, 1.0).is_nan());\n\n // These always returns zero, but the sign (which is ignored by `==`) is non-deterministic.\n assert!((0.0f128).clamp(-0.0, -0.0) == 0.0);\n assert!((1.0f128).clamp(-0.0, 0.0) == 0.0);\n // This is definitely a negative zero.\n assert!((-1.0f128).clamp(-0.0, 1.0).is_sign_negative());\n # }\n ```\n"
}