{
  "name": "core::str::<impl str>::rsplitn",
  "span": "$library/core/src/str/mod.rs:1934:5: 1936:54",
  "doc": " Returns an iterator over substrings of this string slice, separated by a\n pattern, starting from the end of the string, restricted to returning at\n most `n` items.\n\n If `n` substrings are returned, the last substring (the `n`th substring)\n will contain the remainder of the string.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Iterator behavior\n\n The returned iterator will not be double ended, because it is not\n efficient to support.\n\n For splitting from the front, the [`splitn`] method can be used.\n\n [`splitn`]: str::splitn\n\n # Examples\n\n Simple patterns:\n\n ```\n let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n\n let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\n assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n\n let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n ```\n\n A more complex pattern, using a closure:\n\n ```\n let v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\n assert_eq!(v, [\"ghi\", \"abc1def\"]);\n ```\n"
}