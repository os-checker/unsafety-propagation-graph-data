{
  "name": "core::<char::decode::DecodeUtf16<I> as iter::traits::iterator::Iterator>::size_hint",
  "span": "$library/core/src/char/decode.rs:76:5: 76:50",
  "src": "fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n\n        let (low_buf, high_buf) = match self.buf {\n            // buf is empty, no additional elements from it.\n            None => (0, 0),\n            // `u` is a non surrogate, so it's always an additional character.\n            Some(u) if !u.is_utf16_surrogate() => (1, 1),\n            // `u` is a leading surrogate (it can never be a trailing surrogate and\n            // it's a surrogate due to the previous branch) and `self.iter` is empty.\n            //\n            // `u` can't be paired, since the `self.iter` is empty,\n            // so it will always become an additional element (error).\n            Some(_u) if high == Some(0) => (1, 1),\n            // `u` is a leading surrogate and `iter` may be non-empty.\n            //\n            // `u` can either pair with a trailing surrogate, in which case no additional elements\n            // are produced, or it can become an error, in which case it's an additional character (error).\n            Some(_u) => (0, 1),\n        };\n\n        // `self.iter` could contain entirely valid surrogates (2 elements per\n        // char), or entirely non-surrogates (1 element per char).\n        //\n        // On odd lower bound, at least one element must stay unpaired\n        // (with other elements from `self.iter`), so we round up.\n        let low = low.div_ceil(2) + low_buf;\n        let high = high.and_then(|h| h.checked_add(high_buf));\n\n        (low, high)\n    }"
}