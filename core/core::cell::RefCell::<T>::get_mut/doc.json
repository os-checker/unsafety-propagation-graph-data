{
  "name": "core::cell::RefCell::<T>::get_mut",
  "span": "$library/core/src/cell.rs:1308:5: 1308:46",
  "doc": " Returns a mutable reference to the underlying data.\n\n Since this method borrows `RefCell` mutably, it is statically guaranteed\n that no borrows to the underlying data exist. The dynamic checks inherent\n in [`borrow_mut`] and most other methods of `RefCell` are therefore\n unnecessary. Note that this method does not reset the borrowing state if borrows were previously leaked\n (e.g., via [`forget()`] on a [`Ref`] or [`RefMut`]). For that purpose,\n consider using the unstable [`undo_leak`] method.\n\n This method can only be called if `RefCell` can be mutably borrowed,\n which in general is only the case directly after the `RefCell` has\n been created. In these situations, skipping the aforementioned dynamic\n borrowing checks may yield better ergonomics and runtime-performance.\n\n In most situations where `RefCell` is used, it can't be borrowed mutably.\n Use [`borrow_mut`] to get mutable access to the underlying data then.\n\n [`borrow_mut`]: RefCell::borrow_mut()\n [`forget()`]: mem::forget\n [`undo_leak`]: RefCell::undo_leak()\n\n # Examples\n\n ```\n use std::cell::RefCell;\n\n let mut c = RefCell::new(5);\n *c.get_mut() += 1;\n\n assert_eq!(c, RefCell::new(6));\n ```\n"
}