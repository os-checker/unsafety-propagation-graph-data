{
  "name": "core::slice::sort::stable::drift::sort",
  "span": "$library/core/src/slice/sort/stable/drift.rs:20:1: 25:2",
  "src": "pub fn sort<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    eager_sort: bool,\n    is_less: &mut F,\n) {\n    let len = v.len();\n    if len < 2 {\n        return; // Removing this length check *increases* code size.\n    }\n    let scale_factor = merge_tree_scale_factor(len);\n\n    // It's important to have a relatively high entry barrier for pre-sorted\n    // runs, as the presence of a single such run will force on average several\n    // merge operations and shrink the maximum quicksort size a lot. For that\n    // reason we use sqrt(len) as our pre-sorted run threshold.\n    const MIN_SQRT_RUN_LEN: usize = 64;\n    let min_good_run_len = if len <= (MIN_SQRT_RUN_LEN * MIN_SQRT_RUN_LEN) {\n        // For small input length `MIN_SQRT_RUN_LEN` would break pattern\n        // detection of full or nearly sorted inputs.\n        cmp::min(len - len / 2, MIN_SQRT_RUN_LEN)\n    } else {\n        sqrt_approx(len)\n    };\n\n    // (stack_len, runs, desired_depths) together form a stack maintaining run\n    // information for the powersort heuristic. desired_depths[i] is the desired\n    // depth of the merge node that merges runs[i] with the run that comes after\n    // it.\n    let mut stack_len = 0;\n    let mut run_storage = MaybeUninit::<[DriftsortRun; 66]>::uninit();\n    let runs: *mut DriftsortRun = run_storage.as_mut_ptr().cast();\n    let mut desired_depth_storage = MaybeUninit::<[u8; 66]>::uninit();\n    let desired_depths: *mut u8 = desired_depth_storage.as_mut_ptr().cast();\n\n    let mut scan_idx = 0;\n    let mut prev_run = DriftsortRun::new_sorted(0); // Initial dummy run.\n    loop {\n        // Compute the next run and the desired depth of the merge node between\n        // prev_run and next_run. On the last iteration we create a dummy run\n        // with root-level desired depth to fully collapse the merge tree.\n        let (next_run, desired_depth);\n        if scan_idx < len {\n            next_run =\n                create_run(&mut v[scan_idx..], scratch, min_good_run_len, eager_sort, is_less);\n            desired_depth = merge_tree_depth(\n                scan_idx - prev_run.len(),\n                scan_idx,\n                scan_idx + next_run.len(),\n                scale_factor,\n            );\n        } else {\n            next_run = DriftsortRun::new_sorted(0);\n            desired_depth = 0;\n        };\n\n        // Process the merge nodes between earlier runs[i] that have a desire to\n        // be deeper in the merge tree than the merge node for the splitpoint\n        // between prev_run and next_run.\n        //\n        // SAFETY: first note that this is the only place we modify stack_len,\n        // runs or desired depths. We maintain the following invariants:\n        //  1. The first stack_len elements of runs/desired_depths are initialized.\n        //  2. For all valid i > 0, desired_depths[i] < desired_depths[i+1].\n        //  3. The sum of all valid runs[i].len() plus prev_run.len() equals\n        //     scan_idx.\n        unsafe {\n            while stack_len > 1 && *desired_depths.add(stack_len - 1) >= desired_depth {\n                // Desired depth greater than the upcoming desired depth, pop\n                // left neighbor run from stack and merge into prev_run.\n                let left = *runs.add(stack_len - 1);\n                let merged_len = left.len() + prev_run.len();\n                let merge_start_idx = scan_idx - merged_len;\n                let merge_slice = v.get_unchecked_mut(merge_start_idx..scan_idx);\n                prev_run = logical_merge(merge_slice, scratch, left, prev_run, is_less);\n                stack_len -= 1;\n            }\n\n            // We now know that desired_depths[stack_len - 1] < desired_depth,\n            // maintaining our invariant. This also guarantees we don't overflow\n            // the stack as merge_tree_depth(..) <= 64 and thus we can only have\n            // 64 distinct values on the stack before pushing, plus our initial\n            // dummy run, while our capacity is 66.\n            *runs.add(stack_len) = prev_run;\n            *desired_depths.add(stack_len) = desired_depth;\n            stack_len += 1;\n        }\n\n        // Break before overriding the last run with our dummy run.\n        if scan_idx >= len {\n            break;\n        }\n\n        scan_idx += next_run.len();\n        prev_run = next_run;\n    }\n\n    if !prev_run.sorted() {\n        stable_quicksort(v, scratch, is_less);\n    }\n}"
}