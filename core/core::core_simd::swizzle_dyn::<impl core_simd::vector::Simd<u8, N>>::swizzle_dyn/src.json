{
  "name": "core::core_simd::swizzle_dyn::<impl core_simd::vector::Simd<u8, N>>::swizzle_dyn",
  "span": "$library/core/src/../../portable-simd/crates/core_simd/src/swizzle_dyn.rs:17:5: 17:56",
  "src": "pub fn swizzle_dyn(self, idxs: Simd<u8, N>) -> Self {\n        #![allow(unused_imports, unused_unsafe)]\n        #[cfg(all(\n            any(target_arch = \"aarch64\", target_arch = \"arm64ec\"),\n            target_endian = \"little\"\n        ))]\n        use core::arch::aarch64::{uint8x8_t, vqtbl1q_u8, vtbl1_u8};\n        #[cfg(all(\n            target_arch = \"arm\",\n            target_feature = \"v7\",\n            target_feature = \"neon\",\n            target_endian = \"little\"\n        ))]\n        use core::arch::arm::{uint8x8_t, vtbl1_u8};\n        #[cfg(target_arch = \"wasm32\")]\n        use core::arch::wasm32 as wasm;\n        #[cfg(target_arch = \"wasm64\")]\n        use core::arch::wasm64 as wasm;\n        #[cfg(target_arch = \"x86\")]\n        use core::arch::x86;\n        #[cfg(target_arch = \"x86_64\")]\n        use core::arch::x86_64 as x86;\n        // SAFETY: Intrinsics covered by cfg\n        unsafe {\n            match N {\n                #[cfg(all(\n                    any(\n                        target_arch = \"aarch64\",\n                        target_arch = \"arm64ec\",\n                        all(target_arch = \"arm\", target_feature = \"v7\")\n                    ),\n                    target_feature = \"neon\",\n                    target_endian = \"little\"\n                ))]\n                8 => transize(vtbl1_u8, self, idxs),\n                #[cfg(target_feature = \"ssse3\")]\n                16 => transize(x86::_mm_shuffle_epi8, self, zeroing_idxs(idxs)),\n                #[cfg(target_feature = \"simd128\")]\n                16 => transize(wasm::i8x16_swizzle, self, idxs),\n                #[cfg(all(\n                    any(target_arch = \"aarch64\", target_arch = \"arm64ec\"),\n                    target_feature = \"neon\",\n                    target_endian = \"little\"\n                ))]\n                16 => transize(vqtbl1q_u8, self, idxs),\n                #[cfg(all(\n                    target_arch = \"arm\",\n                    target_feature = \"v7\",\n                    target_feature = \"neon\",\n                    target_endian = \"little\"\n                ))]\n                16 => transize(armv7_neon_swizzle_u8x16, self, idxs),\n                #[cfg(all(target_feature = \"avx2\", not(target_feature = \"avx512vbmi\")))]\n                32 => transize(avx2_pshufb, self, idxs),\n                #[cfg(all(target_feature = \"avx512vl\", target_feature = \"avx512vbmi\"))]\n                32 => {\n                    // Unlike vpshufb, vpermb doesn't zero out values in the result based on the index high bit\n                    let swizzler = |bytes, idxs| {\n                        let mask = x86::_mm256_cmp_epu8_mask::<{ x86::_MM_CMPINT_LT }>(\n                            idxs,\n                            Simd::<u8, 32>::splat(N as u8).into(),\n                        );\n                        x86::_mm256_maskz_permutexvar_epi8(mask, idxs, bytes)\n                    };\n                    transize(swizzler, self, idxs)\n                }\n                // Notable absence: avx512bw pshufb shuffle\n                #[cfg(all(target_feature = \"avx512vl\", target_feature = \"avx512vbmi\"))]\n                64 => {\n                    // Unlike vpshufb, vpermb doesn't zero out values in the result based on the index high bit\n                    let swizzler = |bytes, idxs| {\n                        let mask = x86::_mm512_cmp_epu8_mask::<{ x86::_MM_CMPINT_LT }>(\n                            idxs,\n                            Simd::<u8, 64>::splat(N as u8).into(),\n                        );\n                        x86::_mm512_maskz_permutexvar_epi8(mask, idxs, bytes)\n                    };\n                    transize(swizzler, self, idxs)\n                }\n                _ => {\n                    let mut array = [0; N];\n                    for (i, k) in idxs.to_array().into_iter().enumerate() {\n                        if (k as usize) < N {\n                            array[i] = self[k as usize];\n                        };\n                    }\n                    array.into()\n                }\n            }\n        }\n    }"
}