{
  "name": "core::<str::pattern::CharSearcher<'a> as str::pattern::Searcher<'a>>::next_match",
  "span": "$library/core/src/str/pattern.rs:432:5: 432:55",
  "src": "fn next_match(&mut self) -> Option<(usize, usize)> {\n        loop {\n            // get the haystack after the last character found\n            let bytes = self.haystack.as_bytes().get(self.finger..self.finger_back)?;\n            // the last byte of the utf8 encoded needle\n            // SAFETY: we have an invariant that `utf8_size < 5`\n            let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size() - 1) };\n            if let Some(index) = memchr::memchr(last_byte, bytes) {\n                // The new finger is the index of the byte we found,\n                // plus one, since we memchr'd for the last byte of the character.\n                //\n                // Note that this doesn't always give us a finger on a UTF8 boundary.\n                // If we *didn't* find our character\n                // we may have indexed to the non-last byte of a 3-byte or 4-byte character.\n                // We can't just skip to the next valid starting byte because a character like\n                // ê (U+A041 YI SYLLABLE PA), utf-8 `EA 81 81` will have us always find\n                // the second byte when searching for the third.\n                //\n                // However, this is totally okay. While we have the invariant that\n                // self.finger is on a UTF8 boundary, this invariant is not relied upon\n                // within this method (it is relied upon in CharSearcher::next()).\n                //\n                // We only exit this method when we reach the end of the string, or if we\n                // find something. When we find something the `finger` will be set\n                // to a UTF8 boundary.\n                self.finger += index + 1;\n                if self.finger >= self.utf8_size() {\n                    let found_char = self.finger - self.utf8_size();\n                    if let Some(slice) = self.haystack.as_bytes().get(found_char..self.finger) {\n                        if slice == &self.utf8_encoded[0..self.utf8_size()] {\n                            return Some((found_char, self.finger));\n                        }\n                    }\n                }\n            } else {\n                // found nothing, exit\n                self.finger = self.finger_back;\n                return None;\n            }\n        }\n    }"
}