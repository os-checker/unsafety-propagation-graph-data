{
  "name": "core::ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_short",
  "span": "$library/core/src/ptr/mod.rs:1454:5: 1454:87",
  "src": "unsafe fn swap_nonoverlapping_short(x: *mut u8, y: *mut u8, bytes: NonZero<usize>) {\n        // Tail handling for auto-vectorized code sometimes has element-at-a-time behaviour,\n        // see <https://github.com/rust-lang/rust/issues/134946>.\n        // By swapping as different sizes, rather than as a loop over bytes,\n        // we make sure not to end up with, say, seven byte-at-a-time copies.\n\n        let bytes = bytes.get();\n        let mut i = 0;\n        macro_rules! swap_prefix {\n            ($($n:literal)+) => {$(\n                if (bytes & $n) != 0 {\n                    // SAFETY: `i` can only have the same bits set as those in bytes,\n                    // so these `add`s are in-bounds of `bytes`.  But the bit for\n                    // `$n` hasn't been set yet, so the `$n` bytes that `swap_chunk`\n                    // will read and write are within the usable range.\n                    unsafe { swap_chunk::<$n>(&mut*x.add(i).cast(), &mut*y.add(i).cast()) };\n                    i |= $n;\n                }\n            )+};\n        }\n        swap_prefix!(4 2 1);\n        debug_assert_eq!(i, bytes);\n    }"
}