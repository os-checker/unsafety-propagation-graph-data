{
  "name": "core::num::flt2dec::to_shortest_exp_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:418:1: 429:70",
  "mir": "fn core::num::flt2dec::to_shortest_exp_str(_1: F, _2: T, _3: num::flt2dec::Sign, _4: (i16, i16), _5: bool, _6: &mut [mem::maybe_uninit::MaybeUninit<u8>], _7: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]) -> num::fmt::Formatted<'_> {\n    let mut _0: num::fmt::Formatted<'_>;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _15: !;\n    let mut _16: bool;\n    let mut _17: i16;\n    let mut _18: i16;\n    let mut _19: !;\n    let  _20: bool;\n    let  _21: num::flt2dec::decoder::FullDecoded;\n    let mut _22: (bool, num::flt2dec::decoder::FullDecoded);\n    let  _23: &str;\n    let  _24: &num::flt2dec::decoder::FullDecoded;\n    let mut _25: isize;\n    let mut _26: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _27: num::fmt::Part<'_>;\n    let mut _28: &[u8];\n    let mut _29: &[u8; 3];\n    let  _30: usize;\n    let mut _31: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _32: usize;\n    let mut _33: bool;\n    let  _34: &[num::fmt::Part<'_>];\n    let  _35: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _36: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _37: ops::range::RangeTo<usize>;\n    let mut _38: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _39: num::fmt::Part<'_>;\n    let mut _40: &[u8];\n    let mut _41: &[u8; 3];\n    let  _42: usize;\n    let mut _43: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _44: usize;\n    let mut _45: bool;\n    let  _46: &[num::fmt::Part<'_>];\n    let  _47: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _48: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _49: ops::range::RangeTo<usize>;\n    let mut _50: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _51: bool;\n    let mut _52: i16;\n    let mut _53: bool;\n    let mut _54: i16;\n    let mut _55: num::fmt::Part<'_>;\n    let mut _56: &[u8];\n    let mut _57: &[u8; 1];\n    let mut _58: num::fmt::Part<'_>;\n    let mut _59: &[u8];\n    let mut _60: &[u8; 3];\n    let mut _61: &[u8; 3];\n    let  _62: usize;\n    let mut _63: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _64: usize;\n    let mut _65: bool;\n    let  _66: &[num::fmt::Part<'_>];\n    let  _67: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _68: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _69: ops::range::RangeTo<usize>;\n    let  _70: &num::flt2dec::decoder::Decoded;\n    let  _71: &[u8];\n    let  _72: i16;\n    let mut _73: (&[u8], i16);\n    let mut _74: &mut F;\n    let mut _75: (&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>]);\n    let  _76: i32;\n    let mut _77: i32;\n    let mut _78: (i32, bool);\n    let  _79: &[num::fmt::Part<'_>];\n    let mut _80: bool;\n    let mut _81: i32;\n    let mut _82: i16;\n    let mut _83: bool;\n    let mut _84: i32;\n    let mut _85: i16;\n    let  _86: &[num::fmt::Part<'_>];\n    let mut _87: &[num::fmt::Part<'_>];\n    debug format_shortest => _1;\n    debug v => _2;\n    debug sign => _3;\n    debug dec_bounds => _4;\n    debug upper => _5;\n    debug buf => _6;\n    debug parts => _7;\n    debug negative => _20;\n    debug full_decoded => _21;\n    debug sign => _23;\n    debug decoded => _70;\n    debug buf => _71;\n    debug exp => _72;\n    debug vis_exp => _76;\n    debug parts => _79;\n    bb0: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_7);\n        _9 = PtrMetadata(move _10);\n        StorageDead(_10);\n        _8 = Ge(move _9, 6_usize);\n        switchInt(move _8) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_6);\n        _13 = PtrMetadata(move _14);\n        StorageDead(_14);\n        _12 = Ge(move _13, num::flt2dec::MAX_SIG_DIGITS);\n        switchInt(move _12) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_9);\n        _11 = panicking::panic(\"assertion failed: parts.len() >= 6\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (_4.0: i16);\n        StorageLive(_18);\n        _18 = (_4.1: i16);\n        _16 = Le(move _17, move _18);\n        switchInt(move _16) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_13);\n        _15 = panicking::panic(\"assertion failed: buf.len() >= MAX_SIG_DIGITS\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_22);\n        _22 = num::flt2dec::decoder::decode::<T>(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _19 = panicking::panic(\"assertion failed: dec_bounds.0 <= dec_bounds.1\") -> unwind unreachable;\n    }\n    bb7: {\n        _20 = (_22.0: bool);\n        StorageLive(_21);\n        _21 = (_22.1: num::flt2dec::decoder::FullDecoded);\n        StorageDead(_22);\n        _24 = &_21;\n        _23 = num::flt2dec::determine_sign(_3, _24, _20) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _25 = discriminant(_21);\n        switchInt(move _25) -> [0: bb13, 1: bb12, 2: bb11, 3: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        _70 = &((_21 as variant#3).0: num::flt2dec::decoder::Decoded);\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = &mut _1;\n        StorageLive(_75);\n        _75 = (_70, _6);\n        _73 = <F as ops::function::FnMut<(&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>])>>::call_mut(move _74, move _75) -> [return: bb36, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = (_4.0: i16);\n        _51 = Le(move _52, 0_i16);\n        switchInt(move _51) -> [0: bb26, otherwise: bb22];\n    }\n    bb12: {\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = b\"inf\";\n        _40 = move _41 as &[u8];\n        StorageDead(_41);\n        _39 = num::fmt::Part::Copy(move _40);\n        StorageDead(_40);\n        _38 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _39) -> [return: bb18, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = b\"NaN\";\n        _28 = move _29 as &[u8];\n        StorageDead(_29);\n        _27 = num::fmt::Part::Copy(move _28);\n        StorageDead(_28);\n        _26 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _27) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        StorageLive(_30);\n        _30 = 0_usize;\n        _31 = &raw const (fake) (*_7);\n        _32 = PtrMetadata(move _31);\n        _33 = Lt(_30, _32);\n        assert(move _33, \"index out of bounds: the length is {} but the index is {}\", move _32, _30) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        (*_7)[_30] = move _26;\n        StorageDead(_26);\n        StorageDead(_30);\n        StorageLive(_36);\n        _36 = &(*_7);\n        StorageLive(_37);\n        _37 = RangeTo(1_usize);\n        _35 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _36, move _37) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_37);\n        StorageDead(_36);\n        _34 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_35) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _0 = Formatted(_23, _34);\n        goto -> bb46;\n    }\n    bb18: {\n        StorageDead(_39);\n        StorageLive(_42);\n        _42 = 0_usize;\n        _43 = &raw const (fake) (*_7);\n        _44 = PtrMetadata(move _43);\n        _45 = Lt(_42, _44);\n        assert(move _45, \"index out of bounds: the length is {} but the index is {}\", move _44, _42) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        (*_7)[_42] = move _38;\n        StorageDead(_38);\n        StorageDead(_42);\n        StorageLive(_48);\n        _48 = &(*_7);\n        StorageLive(_49);\n        _49 = RangeTo(1_usize);\n        _47 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _48, move _49) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_49);\n        StorageDead(_48);\n        _46 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_47) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _0 = Formatted(_23, _46);\n        goto -> bb46;\n    }\n    bb22: {\n        StorageDead(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = (_4.1: i16);\n        _53 = Lt(0_i16, move _54);\n        switchInt(move _53) -> [0: bb25, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = b\"0\";\n        _56 = move _57 as &[u8];\n        StorageDead(_57);\n        _55 = num::fmt::Part::Copy(move _56);\n        StorageDead(_56);\n        _50 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _55) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_55);\n        goto -> bb32;\n    }\n    bb25: {\n        StorageDead(_54);\n        goto -> bb27;\n    }\n    bb26: {\n        StorageDead(_52);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageLive(_58);\n        StorageLive(_59);\n        switchInt(_5) -> [0: bb29, otherwise: bb28];\n    }\n    bb28: {\n        StorageLive(_60);\n        _60 = b\"0E0\";\n        _59 = move _60 as &[u8];\n        StorageDead(_60);\n        goto -> bb30;\n    }\n    bb29: {\n        StorageLive(_61);\n        _61 = b\"0e0\";\n        _59 = move _61 as &[u8];\n        StorageDead(_61);\n        goto -> bb30;\n    }\n    bb30: {\n        _58 = num::fmt::Part::Copy(move _59);\n        StorageDead(_59);\n        _50 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _58) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_58);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_53);\n        StorageDead(_51);\n        StorageLive(_62);\n        _62 = 0_usize;\n        _63 = &raw const (fake) (*_7);\n        _64 = PtrMetadata(move _63);\n        _65 = Lt(_62, _64);\n        assert(move _65, \"index out of bounds: the length is {} but the index is {}\", move _64, _62) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        (*_7)[_62] = move _50;\n        StorageDead(_50);\n        StorageDead(_62);\n        StorageLive(_68);\n        _68 = &(*_7);\n        StorageLive(_69);\n        _69 = RangeTo(1_usize);\n        _67 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _68, move _69) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_69);\n        StorageDead(_68);\n        _66 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_67) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _0 = Formatted(_23, _66);\n        goto -> bb46;\n    }\n    bb36: {\n        StorageDead(_75);\n        StorageDead(_74);\n        _71 = (_73.0: &[u8]);\n        _72 = (_73.1: i16);\n        StorageDead(_73);\n        StorageLive(_77);\n        _77 = _72 as i32;\n        _78 = CheckedSub(_77, 1_i32);\n        assert(!move (_78.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _77, 1_i32) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _76 = move (_78.0: i32);\n        StorageDead(_77);\n        StorageLive(_79);\n        StorageLive(_80);\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = (_4.0: i16);\n        _81 = move _82 as i32;\n        StorageDead(_82);\n        _80 = Le(move _81, _76);\n        switchInt(move _80) -> [0: bb42, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_81);\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = (_4.1: i16);\n        _84 = move _85 as i32;\n        StorageDead(_85);\n        _83 = Lt(_76, move _84);\n        switchInt(move _83) -> [0: bb41, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_84);\n        _79 = num::flt2dec::digits_to_dec_str(_71, _72, 0_usize, _7) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        goto -> bb45;\n    }\n    bb41: {\n        StorageDead(_84);\n        goto -> bb43;\n    }\n    bb42: {\n        StorageDead(_81);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageLive(_86);\n        _86 = num::flt2dec::digits_to_exp_str(_71, _72, 0_usize, _5, _7) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _79 = _86;\n        StorageDead(_86);\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_83);\n        StorageDead(_80);\n        StorageLive(_87);\n        _87 = _79;\n        _0 = Formatted(_23, move _87);\n        StorageDead(_87);\n        StorageDead(_79);\n        goto -> bb46;\n    }\n    bb46: {\n        StorageDead(_21);\n        drop(_1) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        return;\n    }\n}\n"
}