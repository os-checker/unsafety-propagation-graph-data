{
  "name": "core::num::flt2dec::to_shortest_exp_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:418:1: 429:70",
  "src": "pub fn to_shortest_exp_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    dec_bounds: (i16, i16),\n    upper: bool,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 6);\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n    assert!(dec_bounds.0 <= dec_bounds.1);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n                MaybeUninit::new(Part::Copy(b\"0\"))\n            } else {\n                MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }))\n            };\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let (buf, exp) = format_shortest(decoded, buf);\n            let vis_exp = exp as i32 - 1;\n            let parts = if dec_bounds.0 as i32 <= vis_exp && vis_exp < dec_bounds.1 as i32 {\n                digits_to_dec_str(buf, exp, 0, parts)\n            } else {\n                digits_to_exp_str(buf, exp, 0, upper, parts)\n            };\n            Formatted { sign, parts }\n        }\n    }\n}"
}