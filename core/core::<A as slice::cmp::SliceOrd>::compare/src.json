{
  "name": "core::<A as slice::cmp::SliceOrd>::compare",
  "span": "$library/core/src/slice/cmp.rs:309:5: 309:58",
  "src": "fn compare(left: &[Self], right: &[Self]) -> Ordering {\n        // Since the length of a slice is always less than or equal to\n        // isize::MAX, this never underflows.\n        let diff = left.len() as isize - right.len() as isize;\n        // This comparison gets optimized away (on x86_64 and ARM) because the\n        // subtraction updates flags.\n        let len = if left.len() < right.len() { left.len() } else { right.len() };\n        let left = left.as_ptr().cast();\n        let right = right.as_ptr().cast();\n        // SAFETY: `left` and `right` are references and are thus guaranteed to\n        // be valid. `UnsignedBytewiseOrd` is only implemented for types that\n        // are valid u8s and can be compared the same way. We use the minimum\n        // of both lengths which guarantees that both regions are valid for\n        // reads in that interval.\n        let mut order = unsafe { compare_bytes(left, right, len) as isize };\n        if order == 0 {\n            order = diff;\n        }\n        order.cmp(&0)\n    }"
}