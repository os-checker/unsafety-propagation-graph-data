{
  "name": "core::option::Option::<T>::as_slice",
  "span": "$library/core/src/option.rs:844:5: 844:41",
  "src": "pub const fn as_slice(&self) -> &[T] {\n        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n        // to the payload, with a length of 1, so this is equivalent to\n        // `slice::from_ref`, and thus is safe.\n        // When the `Option` is `None`, the length used is 0, so to be safe it\n        // just needs to be aligned, which it is because `&self` is aligned and\n        // the offset used is a multiple of alignment.\n        //\n        // Here we assume that `offset_of!` always returns an offset to an\n        // in-bounds and correctly aligned position for a `T` (even if in the\n        // `None` case it's just padding).\n        unsafe {\n            slice::from_raw_parts(\n                (self as *const Self).byte_add(core::mem::offset_of!(Self, Some.0)).cast(),\n                self.len(),\n            )\n        }\n    }"
}