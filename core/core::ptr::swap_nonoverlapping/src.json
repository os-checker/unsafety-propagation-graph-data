{
  "name": "core::ptr::swap_nonoverlapping",
  "span": "$library/core/src/ptr/mod.rs:1361:1: 1361:79",
  "src": "pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n    ub_checks::assert_unsafe_precondition!(\n        check_library_ub,\n        \"ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null \\\n        and the specified memory ranges do not overlap\",\n        (\n            x: *mut () = x as *mut (),\n            y: *mut () = y as *mut (),\n            size: usize = size_of::<T>(),\n            align: usize = align_of::<T>(),\n            count: usize = count,\n        ) => {\n            let zero_size = size == 0 || count == 0;\n            ub_checks::maybe_is_aligned_and_not_null(x, align, zero_size)\n                && ub_checks::maybe_is_aligned_and_not_null(y, align, zero_size)\n                && ub_checks::maybe_is_nonoverlapping(x, y, size, count)\n        }\n    );\n\n    const_eval_select!(\n        @capture[T] { x: *mut T, y: *mut T, count: usize }:\n        if const {\n            // At compile-time we don't need all the special code below.\n            // SAFETY: Same preconditions as this function\n            unsafe { swap_nonoverlapping_const(x, y, count) }\n        } else {\n            // Going though a slice here helps codegen know the size fits in `isize`\n            let slice = slice_from_raw_parts_mut(x, count);\n            // SAFETY: This is all readable from the pointer, meaning it's one\n            // allocation, and thus cannot be more than isize::MAX bytes.\n            let bytes = unsafe { mem::size_of_val_raw::<[T]>(slice) };\n            if let Some(bytes) = NonZero::new(bytes) {\n                // SAFETY: These are the same ranges, just expressed in a different\n                // type, so they're still non-overlapping.\n                unsafe { swap_nonoverlapping_bytes(x.cast(), y.cast(), bytes) };\n            }\n        }\n    )\n}"
}