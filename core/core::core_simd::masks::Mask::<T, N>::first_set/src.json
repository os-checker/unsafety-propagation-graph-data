{
  "name": "core::core_simd::masks::Mask::<T, N>::first_set",
  "span": "$library/core/src/../../portable-simd/crates/core_simd/src/masks.rs:326:5: 326:44",
  "src": "pub fn first_set(self) -> Option<usize> {\n        // If bitmasks are efficient, using them is better\n        if cfg!(target_feature = \"sse\") && N <= 64 {\n            let tz = self.to_bitmask().trailing_zeros();\n            return if tz == 64 { None } else { Some(tz as usize) };\n        }\n\n        // To find the first set index:\n        // * create a vector 0..N\n        // * replace unset mask elements in that vector with -1\n        // * perform _unsigned_ reduce-min\n        // * check if the result is -1 or an index\n\n        let index = Simd::from_array(\n            const {\n                let mut index = [0; N];\n                let mut i = 0;\n                while i < N {\n                    index[i] = i;\n                    i += 1;\n                }\n                index\n            },\n        );\n\n        // Safety: the input and output are integer vectors\n        let index: Simd<T, N> = unsafe { core::intrinsics::simd::simd_cast(index) };\n\n        let masked_index = self.select(index, Self::splat(true).to_int());\n\n        // Safety: the input and output are integer vectors\n        let masked_index: Simd<T::Unsigned, N> =\n            unsafe { core::intrinsics::simd::simd_cast(masked_index) };\n\n        // Safety: the input is an integer vector\n        let min_index: T::Unsigned =\n            unsafe { core::intrinsics::simd::simd_reduce_min(masked_index) };\n\n        // Safety: the return value is the unsigned version of T\n        let min_index: T = unsafe { core::mem::transmute_copy(&min_index) };\n\n        if min_index.eq(T::TRUE) {\n            None\n        } else {\n            Some(min_index.to_usize())\n        }\n    }"
}