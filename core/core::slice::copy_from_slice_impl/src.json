{
  "name": "core::slice::copy_from_slice_impl",
  "span": "$library/core/src/slice/mod.rs:5110:1: 5110:74",
  "src": "const unsafe fn copy_from_slice_impl<T: Clone>(dest: &mut [T], src: &[T]) {\n    // The panic code path was put into a cold function to not bloat the\n    // call site.\n    #[cfg_attr(not(panic = \"immediate-abort\"), inline(never), cold)]\n    #[cfg_attr(panic = \"immediate-abort\", inline)]\n    #[track_caller]\n    const fn len_mismatch_fail(dst_len: usize, src_len: usize) -> ! {\n        const_panic!(\n            \"copy_from_slice: source slice length does not match destination slice length\",\n            \"copy_from_slice: source slice length ({src_len}) does not match destination slice length ({dst_len})\",\n            src_len: usize,\n            dst_len: usize,\n        )\n    }\n\n    if dest.len() != src.len() {\n        len_mismatch_fail(dest.len(), src.len());\n    }\n\n    // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n    // checked to have the same length. The slices cannot overlap because\n    // mutable references are exclusive.\n    unsafe {\n        ptr::copy_nonoverlapping(src.as_ptr(), dest.as_mut_ptr(), dest.len());\n    }\n}"
}