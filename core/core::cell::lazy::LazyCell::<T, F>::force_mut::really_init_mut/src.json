{
  "name": "core::cell::lazy::LazyCell::<T, F>::force_mut::really_init_mut",
  "span": "$library/core/src/cell/lazy.rs:184:9: 184:90",
  "src": "unsafe fn really_init_mut<T, F: FnOnce() -> T>(state: &mut State<T, F>) -> &mut T {\n            // INVARIANT: Always valid, but the value may not be dropped.\n            struct PoisonOnPanic<T, F>(*mut State<T, F>);\n            impl<T, F> Drop for PoisonOnPanic<T, F> {\n                #[inline]\n                fn drop(&mut self) {\n                    // SAFETY: Invariant states it is valid, and we don't drop the old value.\n                    unsafe {\n                        self.0.write(State::Poisoned);\n                    }\n                }\n            }\n\n            let State::Uninit(f) = state else {\n                // `unreachable!()` here won't optimize out because the function is cold.\n                // SAFETY: Precondition.\n                unsafe { unreachable_unchecked() };\n            };\n            // SAFETY: We never drop the state after we read `f`, and we write a valid value back\n            // in any case, panic or success. `f` can't access the `LazyCell` because it is mutably\n            // borrowed.\n            let f = unsafe { core::ptr::read(f) };\n            // INVARIANT: Initiated from mutable reference, don't drop because we read it.\n            let guard = PoisonOnPanic(state);\n            let data = f();\n            // SAFETY: `PoisonOnPanic` invariant, and we don't drop the old value.\n            unsafe {\n                core::ptr::write(guard.0, State::Init(data));\n            }\n            core::mem::forget(guard);\n            let State::Init(data) = state else { unreachable!() };\n            data\n        }"
}