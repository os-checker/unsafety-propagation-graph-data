{
  "name": "core::cell::Cell::<T>::swap",
  "span": "$library/core/src/cell.rs:466:5: 466:37",
  "src": "pub fn swap(&self, other: &Self) {\n        // This function documents that it *will* panic, and intrinsics::is_nonoverlapping doesn't\n        // do the check in const, so trying to use it here would be inviting unnecessary fragility.\n        fn is_nonoverlapping<T>(src: *const T, dst: *const T) -> bool {\n            let src_usize = src.addr();\n            let dst_usize = dst.addr();\n            let diff = src_usize.abs_diff(dst_usize);\n            diff >= size_of::<T>()\n        }\n\n        if ptr::eq(self, other) {\n            // Swapping wouldn't change anything.\n            return;\n        }\n        if !is_nonoverlapping(self, other) {\n            // See <https://github.com/rust-lang/rust/issues/80778> for why we need to stop here.\n            panic!(\"`Cell::swap` on overlapping non-identical `Cell`s\");\n        }\n        // SAFETY: This can be risky if called from separate threads, but `Cell`\n        // is `!Sync` so this won't happen. This also won't invalidate any\n        // pointers since `Cell` makes sure nothing else will be pointing into\n        // either of these `Cell`s. We also excluded shenanigans like partially overlapping `Cell`s,\n        // so `swap` will just properly copy two full values of type `T` back and forth.\n        unsafe {\n            mem::swap(&mut *self.value.get(), &mut *other.value.get());\n        }\n    }"
}