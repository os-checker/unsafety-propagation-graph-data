{
  "name": "core::num::dec2flt::decimal_seq::DecimalSeq::left_shift",
  "span": "$library/core/src/num/dec2flt/decimal_seq.rs:124:5: 124:54",
  "src": "pub(super) fn left_shift(&mut self, shift: usize) {\n        if self.num_digits == 0 {\n            return;\n        }\n        let num_new_digits = number_of_digits_decimal_left_shift(self, shift);\n        let mut read_index = self.num_digits;\n        let mut write_index = self.num_digits + num_new_digits;\n        let mut n = 0_u64;\n\n        while read_index != 0 {\n            read_index -= 1;\n            write_index -= 1;\n            n += (self.digits[read_index] as u64) << shift;\n            let quotient = n / 10;\n            let remainder = n - (10 * quotient);\n            if write_index < Self::MAX_DIGITS {\n                self.digits[write_index] = remainder as u8;\n            } else if remainder > 0 {\n                self.truncated = true;\n            }\n            n = quotient;\n        }\n\n        while n > 0 {\n            write_index -= 1;\n            let quotient = n / 10;\n            let remainder = n - (10 * quotient);\n            if write_index < Self::MAX_DIGITS {\n                self.digits[write_index] = remainder as u8;\n            } else if remainder > 0 {\n                self.truncated = true;\n            }\n            n = quotient;\n        }\n\n        self.num_digits += num_new_digits;\n\n        if self.num_digits > Self::MAX_DIGITS {\n            self.num_digits = Self::MAX_DIGITS;\n        }\n\n        self.decimal_point += num_new_digits as i32;\n        self.trim();\n    }"
}