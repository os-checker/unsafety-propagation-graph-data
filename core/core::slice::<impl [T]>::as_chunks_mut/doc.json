{
  "name": "core::slice::<impl [T]>::as_chunks_mut",
  "span": "$library/core/src/slice/mod.rs:1551:5: 1551:87",
  "doc": " Splits the slice into a slice of `N`-element arrays,\n starting at the beginning of the slice,\n and a remainder slice with length strictly less than `N`.\n\n The remainder is meaningful in the division sense.  Given\n `let (chunks, remainder) = slice.as_chunks_mut()`, then:\n - `chunks.len()` equals `slice.len() / N`,\n - `remainder.len()` equals `slice.len() % N`, and\n - `slice.len()` equals `chunks.len() * N + remainder.len()`.\n\n You can flatten the chunks back into a slice-of-`T` with [`as_flattened_mut`].\n\n [`as_flattened_mut`]: slice::as_flattened_mut\n\n # Panics\n\n Panics if `N` is zero.\n\n Note that this check is against a const generic parameter, not a runtime\n value, and thus a particular monomorphization will either always panic\n or it will never panic.\n\n # Examples\n\n ```\n let v = &mut [0, 0, 0, 0, 0];\n let mut count = 1;\n\n let (chunks, remainder) = v.as_chunks_mut();\n remainder[0] = 9;\n for chunk in chunks {\n     *chunk = [count; 2];\n     count += 1;\n }\n assert_eq!(v, &[1, 1, 2, 2, 9]);\n ```\n"
}