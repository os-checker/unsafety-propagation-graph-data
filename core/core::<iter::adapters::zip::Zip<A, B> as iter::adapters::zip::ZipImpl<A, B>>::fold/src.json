{
  "name": "core::<iter::adapters::zip::Zip<A, B> as iter::adapters::zip::ZipImpl<A, B>>::fold",
  "span": "$library/core/src/iter/adapters/zip.rs:275:5: 277:42",
  "src": "fn fold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n        let mut accum = init;\n        let len = ZipImpl::size_hint(&self).0;\n        for i in 0..len {\n            // SAFETY: since Self: TrustedRandomAccessNoCoerce we can trust the size-hint to\n            // calculate the length and then use that to do unchecked iteration.\n            // fold consumes the iterator so we don't need to fixup any state.\n            unsafe {\n                accum = f(accum, self.get_unchecked(i));\n            }\n        }\n        accum\n    }"
}