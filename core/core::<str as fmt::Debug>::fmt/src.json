{
  "name": "core::<str as fmt::Debug>::fmt",
  "span": "$library/core/src/fmt/mod.rs:2910:5: 2910:51",
  "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.write_char('\"')?;\n\n        // substring we know is printable\n        let mut printable_range = 0..0;\n\n        fn needs_escape(b: u8) -> bool {\n            b > 0x7E || b < 0x20 || b == b'\\\\' || b == b'\"'\n        }\n\n        // the loop here first skips over runs of printable ASCII as a fast path.\n        // other chars (unicode, or ASCII that needs escaping) are then handled per-`char`.\n        let mut rest = self;\n        while rest.len() > 0 {\n            let Some(non_printable_start) = rest.as_bytes().iter().position(|&b| needs_escape(b))\n            else {\n                printable_range.end += rest.len();\n                break;\n            };\n\n            printable_range.end += non_printable_start;\n            // SAFETY: the position was derived from an iterator, so is known to be within bounds, and at a char boundary\n            rest = unsafe { rest.get_unchecked(non_printable_start..) };\n\n            let mut chars = rest.chars();\n            if let Some(c) = chars.next() {\n                let esc = c.escape_debug_ext(EscapeDebugExtArgs {\n                    escape_grapheme_extended: true,\n                    escape_single_quote: false,\n                    escape_double_quote: true,\n                });\n                if esc.len() != 1 {\n                    f.write_str(&self[printable_range.clone()])?;\n                    Display::fmt(&esc, f)?;\n                    printable_range.start = printable_range.end + c.len_utf8();\n                }\n                printable_range.end += c.len_utf8();\n            }\n            rest = chars.as_str();\n        }\n\n        f.write_str(&self[printable_range])?;\n\n        f.write_char('\"')\n    }"
}