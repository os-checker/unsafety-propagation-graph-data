{
  "name": "core::num::dec2flt::decimal_seq::DecimalSeq::right_shift",
  "span": "$library/core/src/num/dec2flt/decimal_seq.rs:170:5: 170:55",
  "src": "pub(super) fn right_shift(&mut self, shift: usize) {\n        let mut read_index = 0;\n        let mut write_index = 0;\n        let mut n = 0_u64;\n        while (n >> shift) == 0 {\n            if read_index < self.num_digits {\n                n = (10 * n) + self.digits[read_index] as u64;\n                read_index += 1;\n            } else if n == 0 {\n                return;\n            } else {\n                while (n >> shift) == 0 {\n                    n *= 10;\n                    read_index += 1;\n                }\n                break;\n            }\n        }\n        self.decimal_point -= read_index as i32 - 1;\n        if self.decimal_point < -Self::DECIMAL_POINT_RANGE {\n            // `self = Self::Default()`, but without the overhead of clearing `digits`.\n            self.num_digits = 0;\n            self.decimal_point = 0;\n            self.truncated = false;\n            return;\n        }\n        let mask = (1_u64 << shift) - 1;\n        while read_index < self.num_digits {\n            let new_digit = (n >> shift) as u8;\n            n = (10 * (n & mask)) + self.digits[read_index] as u64;\n            read_index += 1;\n            self.digits[write_index] = new_digit;\n            write_index += 1;\n        }\n        while n > 0 {\n            let new_digit = (n >> shift) as u8;\n            n = 10 * (n & mask);\n            if write_index < Self::MAX_DIGITS {\n                self.digits[write_index] = new_digit;\n                write_index += 1;\n            } else if new_digit > 0 {\n                self.truncated = true;\n            }\n        }\n        self.num_digits = write_index;\n        self.trim();\n    }"
}