{
  "name": "core::<slice::iter::SplitInclusiveMut<'a, T, P> as iter::traits::double_ended::DoubleEndedIterator>::next_back",
  "span": "$library/core/src/slice/iter.rs:884:5: 884:51",
  "src": "fn next_back(&mut self) -> Option<&'a mut [T]> {\n        if self.finished {\n            return None;\n        }\n\n        let idx_opt = if self.v.is_empty() {\n            None\n        } else {\n            // work around borrowck limitations\n            let pred = &mut self.pred;\n\n            // The last index of self.v is already checked and found to match\n            // by the last iteration, so we start searching a new match\n            // one index to the left.\n            let remainder = &self.v[..(self.v.len() - 1)];\n            remainder.iter().rposition(|x| (*pred)(x))\n        };\n        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);\n        if idx == 0 {\n            self.finished = true;\n        }\n        let tmp = mem::take(&mut self.v);\n        let (head, tail) = tmp.split_at_mut(idx);\n        self.v = head;\n        Some(tail)\n    }"
}