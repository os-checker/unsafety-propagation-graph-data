{
  "name": "core::str::<impl str>::char_indices",
  "span": "$library/core/src/str/mod.rs:1107:5: 1107:50",
  "doc": " Returns an iterator over the [`char`]s of a string slice, and their\n positions.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns an iterator of both\n these [`char`]s, as well as their byte positions.\n\n The iterator yields tuples. The position is first, the [`char`] is\n second.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.char_indices().count();\n assert_eq!(7, count);\n\n let mut char_indices = word.char_indices();\n\n assert_eq!(Some((0, 'g')), char_indices.next());\n assert_eq!(Some((1, 'o')), char_indices.next());\n assert_eq!(Some((2, 'o')), char_indices.next());\n assert_eq!(Some((3, 'd')), char_indices.next());\n assert_eq!(Some((4, 'b')), char_indices.next());\n assert_eq!(Some((5, 'y')), char_indices.next());\n assert_eq!(Some((6, 'e')), char_indices.next());\n\n assert_eq!(None, char_indices.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let yes = \"y̆es\";\n\n let mut char_indices = yes.char_indices();\n\n assert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y̆')\n assert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n // note the 3 here - the previous character took up two bytes\n assert_eq!(Some((3, 'e')), char_indices.next());\n assert_eq!(Some((4, 's')), char_indices.next());\n\n assert_eq!(None, char_indices.next());\n ```\n"
}