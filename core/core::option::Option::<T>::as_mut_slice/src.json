{
  "name": "core::option::Option::<T>::as_mut_slice",
  "span": "$library/core/src/option.rs:899:5: 899:53",
  "src": "pub const fn as_mut_slice(&mut self) -> &mut [T] {\n        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n        // to the payload, with a length of 1, so this is equivalent to\n        // `slice::from_mut`, and thus is safe.\n        // When the `Option` is `None`, the length used is 0, so to be safe it\n        // just needs to be aligned, which it is because `&self` is aligned and\n        // the offset used is a multiple of alignment.\n        //\n        // In the new version, the intrinsic creates a `*const T` from a\n        // mutable reference  so it is safe to cast back to a mutable pointer\n        // here. As with `as_slice`, the intrinsic always returns a pointer to\n        // an in-bounds and correctly aligned position for a `T` (even if in\n        // the `None` case it's just padding).\n        unsafe {\n            slice::from_raw_parts_mut(\n                (self as *mut Self).byte_add(core::mem::offset_of!(Self, Some.0)).cast(),\n                self.len(),\n            )\n        }\n    }"
}