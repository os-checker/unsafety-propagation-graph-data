{
  "name": "core::slice::<impl [T]>::reverse",
  "span": "$library/core/src/slice/mod.rs:977:5: 977:36",
  "src": "pub const fn reverse(&mut self) {\n        let half_len = self.len() / 2;\n        let Range { start, end } = self.as_mut_ptr_range();\n\n        // These slices will skip the middle item for an odd length,\n        // since that one doesn't need to move.\n        let (front_half, back_half) =\n            // SAFETY: Both are subparts of the original slice, so the memory\n            // range is valid, and they don't overlap because they're each only\n            // half (or less) of the original slice.\n            unsafe {\n                (\n                    slice::from_raw_parts_mut(start, half_len),\n                    slice::from_raw_parts_mut(end.sub(half_len), half_len),\n                )\n            };\n\n        // Introducing a function boundary here means that the two halves\n        // get `noalias` markers, allowing better optimization as LLVM\n        // knows that they're disjoint, unlike in the original slice.\n        revswap(front_half, back_half, half_len);\n\n        #[inline]\n        const fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n            debug_assert!(a.len() == n);\n            debug_assert!(b.len() == n);\n\n            // Because this function is first compiled in isolation,\n            // this check tells LLVM that the indexing below is\n            // in-bounds. Then after inlining -- once the actual\n            // lengths of the slices are known -- it's removed.\n            // FIXME(const_trait_impl) replace with let (a, b) = (&mut a[..n], &mut b[..n]);\n            let (a, _) = a.split_at_mut(n);\n            let (b, _) = b.split_at_mut(n);\n\n            let mut i = 0;\n            while i < n {\n                mem::swap(&mut a[i], &mut b[n - 1 - i]);\n                i += 1;\n            }\n        }\n    }"
}