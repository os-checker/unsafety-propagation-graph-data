{
  "name": "core::<str::pattern::StrSearcher<'a, 'b> as str::pattern::Searcher<'a>>::next",
  "span": "$library/core/src/str/pattern.rs:1118:5: 1118:37",
  "src": "fn next(&mut self) -> SearchStep {\n        match self.searcher {\n            StrSearcherImpl::Empty(ref mut searcher) => {\n                if searcher.is_finished {\n                    return SearchStep::Done;\n                }\n                // empty needle rejects every char and matches every empty string between them\n                let is_match = searcher.is_match_fw;\n                searcher.is_match_fw = !searcher.is_match_fw;\n                let pos = searcher.position;\n                match self.haystack[pos..].chars().next() {\n                    _ if is_match => SearchStep::Match(pos, pos),\n                    None => {\n                        searcher.is_finished = true;\n                        SearchStep::Done\n                    }\n                    Some(ch) => {\n                        searcher.position += ch.len_utf8();\n                        SearchStep::Reject(pos, searcher.position)\n                    }\n                }\n            }\n            StrSearcherImpl::TwoWay(ref mut searcher) => {\n                // TwoWaySearcher produces valid *Match* indices that split at char boundaries\n                // as long as it does correct matching and that haystack and needle are\n                // valid UTF-8\n                // *Rejects* from the algorithm can fall on any indices, but we will walk them\n                // manually to the next character boundary, so that they are utf-8 safe.\n                if searcher.position == self.haystack.len() {\n                    return SearchStep::Done;\n                }\n                let is_long = searcher.memory == usize::MAX;\n                match searcher.next::<RejectAndMatch>(\n                    self.haystack.as_bytes(),\n                    self.needle.as_bytes(),\n                    is_long,\n                ) {\n                    SearchStep::Reject(a, mut b) => {\n                        // skip to next char boundary\n                        while !self.haystack.is_char_boundary(b) {\n                            b += 1;\n                        }\n                        searcher.position = cmp::max(b, searcher.position);\n                        SearchStep::Reject(a, b)\n                    }\n                    otherwise => otherwise,\n                }\n            }\n        }\n    }"
}