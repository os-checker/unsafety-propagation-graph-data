{
  "name": "core::intrinsics::raw_eq",
  "span": "$library/core/src/intrinsics/mod.rs:2295:1: 2295:53",
  "doc": " Determines whether the raw bytes of the two values are equal.\n\n This is particularly handy for arrays, since it allows things like just\n comparing `i96`s instead of forcing `alloca`s for `[6 x i16]`.\n\n Above some backend-decided threshold this will emit calls to `memcmp`,\n like slice equality does, instead of causing massive code size.\n\n Since this works by comparing the underlying bytes, the actual `T` is\n not particularly important.  It will be used for its size and alignment,\n but any validity restrictions will be ignored, not enforced.\n\n # Safety\n\n It's UB to call this if any of the *bytes* in `*a` or `*b` are uninitialized.\n Note that this is a stricter criterion than just the *values* being\n fully-initialized: if `T` has padding, it's UB to call this intrinsic.\n\n At compile-time, it is furthermore UB to call this if any of the bytes\n in `*a` or `*b` have provenance.\n\n (The implementation is allowed to branch on the results of comparisons,\n which is UB if any of their inputs are `undef`.)\n"
}