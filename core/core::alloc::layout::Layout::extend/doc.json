{
  "name": "core::alloc::layout::Layout::extend",
  "span": "$library/core/src/alloc/layout.rs:416:5: 416:81",
  "doc": " Creates a layout describing the record for `self` followed by\n `next`, including any necessary padding to ensure that `next`\n will be properly aligned, but *no trailing padding*.\n\n In order to match C representation layout `repr(C)`, you should\n call `pad_to_align` after extending the layout with all fields.\n (There is no way to match the default Rust representation\n layout `repr(Rust)`, as it is unspecified.)\n\n Note that the alignment of the resulting layout will be the maximum of\n those of `self` and `next`, in order to ensure alignment of both parts.\n\n Returns `Ok((k, offset))`, where `k` is layout of the concatenated\n record and `offset` is the relative location, in bytes, of the\n start of the `next` embedded within the concatenated record\n (assuming that the record itself starts at offset 0).\n\n On arithmetic overflow, returns `LayoutError`.\n\n # Examples\n\n To calculate the layout of a `#[repr(C)]` structure and the offsets of\n the fields from its fields' layouts:\n\n ```rust\n # use std::alloc::{Layout, LayoutError};\n pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutError> {\n     let mut offsets = Vec::new();\n     let mut layout = Layout::from_size_align(0, 1)?;\n     for &field in fields {\n         let (new_layout, offset) = layout.extend(field)?;\n         layout = new_layout;\n         offsets.push(offset);\n     }\n     // Remember to finalize with `pad_to_align`!\n     Ok((layout.pad_to_align(), offsets))\n }\n # // test that it works\n # #[repr(C)] struct S { a: u64, b: u32, c: u16, d: u32 }\n # let s = Layout::new::<S>();\n # let u16 = Layout::new::<u16>();\n # let u32 = Layout::new::<u32>();\n # let u64 = Layout::new::<u64>();\n # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n ```\n"
}