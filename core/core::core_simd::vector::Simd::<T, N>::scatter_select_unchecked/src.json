{
  "name": "core::core_simd::vector::Simd::<T, N>::scatter_select_unchecked",
  "span": "$library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:822:5: 827:6",
  "src": "pub unsafe fn scatter_select_unchecked(\n        self,\n        slice: &mut [T],\n        enable: Mask<isize, N>,\n        idxs: Simd<usize, N>,\n    ) {\n        // Safety: This block works with *mut T derived from &mut 'a [T],\n        // which means it is delicate in Rust's borrowing model, circa 2021:\n        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n        // Even though this block is largely safe methods, it must be exactly this way\n        // to prevent invalidating the raw ptrs while they're live.\n        // Thus, entering this block requires all values to use being already ready:\n        // 0. idxs we want to write to, which are used to construct the mask.\n        // 1. enable, which depends on an initial &'a [T] and the idxs.\n        // 2. actual values to scatter (self).\n        // 3. &mut [T] which will become our base ptr.\n        unsafe {\n            // Now Entering ☢️ *mut T Zone\n            let base_ptr = Simd::<*mut T, N>::splat(slice.as_mut_ptr());\n            // Ferris forgive me, I have done pointer arithmetic here.\n            let ptrs = base_ptr.wrapping_add(idxs);\n            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n            self.scatter_select_ptr(ptrs, enable);\n            // Cleared ☢️ *mut T Zone\n        }\n    }"
}