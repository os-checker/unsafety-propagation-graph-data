{
  "name": "core::<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk",
  "span": "$library/core/src/iter/adapters/filter_map.rs:68:5: 70:65",
  "src": "fn next_chunk<const N: usize>(\n        &mut self,\n    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n        let mut array: [MaybeUninit<Self::Item>; N] = [const { MaybeUninit::uninit() }; N];\n\n        struct Guard<'a, T> {\n            array: &'a mut [MaybeUninit<T>],\n            initialized: usize,\n        }\n\n        impl<T> Drop for Guard<'_, T> {\n            #[inline]\n            fn drop(&mut self) {\n                if const { crate::mem::needs_drop::<T>() } {\n                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n                    unsafe {\n                        self.array.get_unchecked_mut(..self.initialized).assume_init_drop();\n                    }\n                }\n            }\n        }\n\n        let mut guard = Guard { array: &mut array, initialized: 0 };\n\n        let result = self.iter.try_for_each(|element| {\n            let idx = guard.initialized;\n            let val = (self.f)(element);\n            guard.initialized = idx + val.is_some() as usize;\n\n            // SAFETY: Loop conditions ensure the index is in bounds.\n\n            unsafe {\n                let opt_payload_at: *const MaybeUninit<B> =\n                    (&raw const val).byte_add(core::mem::offset_of!(Option<B>, Some.0)).cast();\n                let dst = guard.array.as_mut_ptr().add(idx);\n                crate::ptr::copy_nonoverlapping(opt_payload_at, dst, 1);\n                crate::mem::forget(val);\n            };\n\n            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n        });\n\n        let guard = ManuallyDrop::new(guard);\n\n        match result {\n            ControlFlow::Break(()) => {\n                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n            }\n            ControlFlow::Continue(()) => {\n                let initialized = guard.initialized;\n                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n            }\n        }\n    }"
}