{
  "name": "core::time::Duration::try_from_secs_f64",
  "span": "$library/core/src/time.rs:1720:5: 1720:83",
  "doc": " The checked version of [`from_secs_f64`].\n\n [`from_secs_f64`]: Duration::from_secs_f64\n\n This constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n\n # Examples\n ```\n use std::time::Duration;\n\n let res = Duration::try_from_secs_f64(0.0);\n assert_eq!(res, Ok(Duration::new(0, 0)));\n let res = Duration::try_from_secs_f64(1e-20);\n assert_eq!(res, Ok(Duration::new(0, 0)));\n let res = Duration::try_from_secs_f64(4.2e-7);\n assert_eq!(res, Ok(Duration::new(0, 420)));\n let res = Duration::try_from_secs_f64(2.7);\n assert_eq!(res, Ok(Duration::new(2, 700_000_000)));\n let res = Duration::try_from_secs_f64(3e10);\n assert_eq!(res, Ok(Duration::new(30_000_000_000, 0)));\n // subnormal float\n let res = Duration::try_from_secs_f64(f64::from_bits(1));\n assert_eq!(res, Ok(Duration::new(0, 0)));\n\n let res = Duration::try_from_secs_f64(-5.0);\n assert!(res.is_err());\n let res = Duration::try_from_secs_f64(f64::NAN);\n assert!(res.is_err());\n let res = Duration::try_from_secs_f64(2e19);\n assert!(res.is_err());\n\n // the conversion uses rounding with tie resolution to even\n let res = Duration::try_from_secs_f64(0.999e-9);\n assert_eq!(res, Ok(Duration::new(0, 1)));\n let res = Duration::try_from_secs_f64(0.999_999_999_499);\n assert_eq!(res, Ok(Duration::new(0, 999_999_999)));\n let res = Duration::try_from_secs_f64(0.999_999_999_501);\n assert_eq!(res, Ok(Duration::new(1, 0)));\n let res = Duration::try_from_secs_f64(42.999_999_999_499);\n assert_eq!(res, Ok(Duration::new(42, 999_999_999)));\n let res = Duration::try_from_secs_f64(42.999_999_999_501);\n assert_eq!(res, Ok(Duration::new(43, 0)));\n\n // this float represents exactly 976562.5e-9\n let val = f64::from_bits(0x3F50_0000_0000_0000);\n let res = Duration::try_from_secs_f64(val);\n assert_eq!(res, Ok(Duration::new(0, 976_562)));\n\n // this float represents exactly 2929687.5e-9\n let val = f64::from_bits(0x3F68_0000_0000_0000);\n let res = Duration::try_from_secs_f64(val);\n assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n\n // this float represents exactly 1.000_976_562_5\n let val = f64::from_bits(0x3FF0_0400_0000_0000);\n let res = Duration::try_from_secs_f64(val);\n assert_eq!(res, Ok(Duration::new(1, 976_562)));\n\n // this float represents exactly 1.002_929_687_5\n let val = f64::from_bits(0x3_FF00_C000_0000_000);\n let res = Duration::try_from_secs_f64(val);\n assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n ```\n"
}