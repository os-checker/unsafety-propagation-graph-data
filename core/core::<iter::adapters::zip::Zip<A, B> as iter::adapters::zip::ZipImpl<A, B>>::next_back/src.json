{
  "name": "core::<iter::adapters::zip::Zip<A, B> as iter::adapters::zip::ZipImpl<A, B>>::next_back",
  "span": "$library/core/src/iter/adapters/zip.rs:176:9: 179:56",
  "src": "default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n        where\n            A: DoubleEndedIterator + ExactSizeIterator,\n            B: DoubleEndedIterator + ExactSizeIterator,\n        {\n            // The function body below only uses `self.a/b.len()` and `self.a/b.next_back()`\n            // and doesnâ€™t call `next_back` too often, so this implementation is safe in\n            // the `TrustedRandomAccessNoCoerce` specialization\n\n            let a_sz = self.a.len();\n            let b_sz = self.b.len();\n            if a_sz != b_sz {\n                // Adjust a, b to equal length\n                if a_sz > b_sz {\n                    for _ in 0..a_sz - b_sz {\n                        self.a.next_back();\n                    }\n                } else {\n                    for _ in 0..b_sz - a_sz {\n                        self.b.next_back();\n                    }\n                }\n            }\n            match (self.a.next_back(), self.b.next_back()) {\n                (Some(x), Some(y)) => Some((x, y)),\n                (None, None) => None,\n                _ => unreachable!(),\n            }\n        }"
}