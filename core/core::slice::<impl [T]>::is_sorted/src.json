{
  "name": "core::slice::<impl [T]>::is_sorted",
  "span": "$library/core/src/slice/mod.rs:4300:5: 4302:23",
  "src": "pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,\n    {\n        // This odd number works the best. 32 + 1 extra due to overlapping chunk boundaries.\n        const CHUNK_SIZE: usize = 33;\n        if self.len() < CHUNK_SIZE {\n            return self.windows(2).all(|w| w[0] <= w[1]);\n        }\n        let mut i = 0;\n        // Check in chunks for autovectorization.\n        while i < self.len() - CHUNK_SIZE {\n            let chunk = &self[i..i + CHUNK_SIZE];\n            if !chunk.windows(2).fold(true, |acc, w| acc & (w[0] <= w[1])) {\n                return false;\n            }\n            // We need to ensure that chunk boundaries are also sorted.\n            // Overlap the next chunk with the last element of our last chunk.\n            i += CHUNK_SIZE - 1;\n        }\n        self[i..].windows(2).all(|w| w[0] <= w[1])\n    }"
}