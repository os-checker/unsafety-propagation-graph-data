{
  "name": "core::num::bignum::Big32x40::mul_pow2",
  "span": "$library/core/src/num/bignum.rs:214:13: 214:66",
  "src": "pub fn mul_pow2(&mut self, bits: usize) -> &mut $name {\n                let digitbits = <$ty>::BITS as usize;\n                let digits = bits / digitbits;\n                let bits = bits % digitbits;\n\n                assert!(digits < $n);\n                debug_assert!(self.base[$n - digits..].iter().all(|&v| v == 0));\n                debug_assert!(bits == 0 || (self.base[$n - digits - 1] >> (digitbits - bits)) == 0);\n\n                // shift by `digits * digitbits` bits\n                for i in (0..self.size).rev() {\n                    self.base[i + digits] = self.base[i];\n                }\n                for i in 0..digits {\n                    self.base[i] = 0;\n                }\n\n                // shift by `bits` bits\n                let mut sz = self.size + digits;\n                if bits > 0 {\n                    let last = sz;\n                    let overflow = self.base[last - 1] >> (digitbits - bits);\n                    if overflow > 0 {\n                        self.base[last] = overflow;\n                        sz += 1;\n                    }\n                    for i in (digits + 1..last).rev() {\n                        self.base[i] =\n                            (self.base[i] << bits) | (self.base[i - 1] >> (digitbits - bits));\n                    }\n                    self.base[digits] <<= bits;\n                    // self.base[..digits] is zero, no need to shift\n                }\n\n                self.size = sz;\n                self\n            }"
}