{
  "name": "core::alloc::Allocator::grow",
  "span": "$library/core/src/alloc/mod.rs:205:5: 210:43",
  "src": "unsafe fn grow(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        debug_assert!(\n            new_layout.size() >= old_layout.size(),\n            \"`new_layout.size()` must be greater than or equal to `old_layout.size()`\"\n        );\n\n        let new_ptr = self.allocate(new_layout)?;\n\n        // SAFETY: because `new_layout.size()` must be greater than or equal to\n        // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n        // writes for `old_layout.size()` bytes. Also, because the old allocation wasn't yet\n        // deallocated, it cannot overlap `new_ptr`. Thus, the call to `copy_nonoverlapping` is\n        // safe. The safety contract for `dealloc` must be upheld by the caller.\n        unsafe {\n            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), old_layout.size());\n            self.deallocate(ptr, old_layout);\n        }\n\n        Ok(new_ptr)\n    }"
}