{
  "name": "core::slice::sort::stable::drift::create_run",
  "span": "$library/core/src/slice/sort/stable/drift.rs:226:1: 232:18",
  "src": "fn create_run<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    min_good_run_len: usize,\n    eager_sort: bool,\n    is_less: &mut F,\n) -> DriftsortRun {\n    let len = v.len();\n    if len >= min_good_run_len {\n        let (run_len, was_reversed) = find_existing_run(v, is_less);\n\n        // SAFETY: find_existing_run promises to return a valid run_len.\n        unsafe { intrinsics::assume(run_len <= len) };\n\n        if run_len >= min_good_run_len {\n            if was_reversed {\n                v[..run_len].reverse();\n            }\n\n            return DriftsortRun::new_sorted(run_len);\n        }\n    }\n\n    if eager_sort {\n        // We call quicksort with a len that will immediately call small-sort.\n        // By not calling the small-sort directly here it can always be inlined into\n        // the quicksort itself, making the recursive base case faster and is generally\n        // more binary-size efficient.\n        let eager_run_len = cmp::min(T::small_sort_threshold(), len);\n        quicksort(&mut v[..eager_run_len], scratch, 0, None, is_less);\n        DriftsortRun::new_sorted(eager_run_len)\n    } else {\n        DriftsortRun::new_unsorted(cmp::min(min_good_run_len, len))\n    }\n}"
}