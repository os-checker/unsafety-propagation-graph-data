{
  "name": "core::<ffi::c_str::CStr as ops::index::Index<ops::range::RangeFrom<usize>>>::index",
  "span": "$library/core/src/ffi/c_str.rs:690:5: 690:59",
  "src": "fn index(&self, index: ops::RangeFrom<usize>) -> &CStr {\n        let bytes = self.to_bytes_with_nul();\n        // we need to manually check the starting index to account for the null\n        // byte, since otherwise we could get an empty string that doesn't end\n        // in a null.\n        if index.start < bytes.len() {\n            // SAFETY: Non-empty tail of a valid `CStr` is still a valid `CStr`.\n            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n        } else {\n            panic!(\n                \"index out of bounds: the len is {} but the index is {}\",\n                bytes.len(),\n                index.start\n            );\n        }\n    }"
}