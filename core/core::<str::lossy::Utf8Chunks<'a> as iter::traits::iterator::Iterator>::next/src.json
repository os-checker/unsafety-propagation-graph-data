{
  "name": "core::<str::lossy::Utf8Chunks<'a> as iter::traits::iterator::Iterator>::next",
  "span": "$library/core/src/str/lossy.rs:202:5: 202:48",
  "src": "fn next(&mut self) -> Option<Utf8Chunk<'a>> {\n        if self.source.is_empty() {\n            return None;\n        }\n\n        const TAG_CONT_U8: u8 = 128;\n        fn safe_get(xs: &[u8], i: usize) -> u8 {\n            *xs.get(i).unwrap_or(&0)\n        }\n\n        let mut i = 0;\n        let mut valid_up_to = 0;\n        while i < self.source.len() {\n            // SAFETY: `i < self.source.len()` per previous line.\n            // For some reason the following are both significantly slower:\n            // while let Some(&byte) = self.source.get(i) {\n            // while let Some(byte) = self.source.get(i).copied() {\n            let byte = unsafe { *self.source.get_unchecked(i) };\n            i += 1;\n\n            if byte < 128 {\n                // This could be a `1 => ...` case in the match below, but for\n                // the common case of all-ASCII inputs, we bypass loading the\n                // sizeable UTF8_CHAR_WIDTH table into cache.\n            } else {\n                let w = utf8_char_width(byte);\n\n                match w {\n                    2 => {\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    3 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xE0, 0xA0..=0xBF) => (),\n                            (0xE1..=0xEC, 0x80..=0xBF) => (),\n                            (0xED, 0x80..=0x9F) => (),\n                            (0xEE..=0xEF, 0x80..=0xBF) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    4 => {\n                        match (byte, safe_get(self.source, i)) {\n                            (0xF0, 0x90..=0xBF) => (),\n                            (0xF1..=0xF3, 0x80..=0xBF) => (),\n                            (0xF4, 0x80..=0x8F) => (),\n                            _ => break,\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                        if safe_get(self.source, i) & 192 != TAG_CONT_U8 {\n                            break;\n                        }\n                        i += 1;\n                    }\n                    _ => break,\n                }\n            }\n\n            valid_up_to = i;\n        }\n\n        // SAFETY: `i <= self.source.len()` because it is only ever incremented\n        // via `i += 1` and in between every single one of those increments, `i`\n        // is compared against `self.source.len()`. That happens either\n        // literally by `i < self.source.len()` in the while-loop's condition,\n        // or indirectly by `safe_get(self.source, i) & 192 != TAG_CONT_U8`. The\n        // loop is terminated as soon as the latest `i += 1` has made `i` no\n        // longer less than `self.source.len()`, which means it'll be at most\n        // equal to `self.source.len()`.\n        let (inspected, remaining) = unsafe { self.source.split_at_unchecked(i) };\n        self.source = remaining;\n\n        // SAFETY: `valid_up_to <= i` because it is only ever assigned via\n        // `valid_up_to = i` and `i` only increases.\n        let (valid, invalid) = unsafe { inspected.split_at_unchecked(valid_up_to) };\n\n        Some(Utf8Chunk {\n            // SAFETY: All bytes up to `valid_up_to` are valid UTF-8.\n            valid: unsafe { from_utf8_unchecked(valid) },\n            invalid,\n        })\n    }"
}