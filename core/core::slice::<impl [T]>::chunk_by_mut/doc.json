{
  "name": "core::slice::<impl [T]>::chunk_by_mut",
  "span": "$library/core/src/slice/mod.rs:1903:5: 1905:34",
  "doc": " Returns an iterator over the slice producing non-overlapping mutable\n runs of elements using the predicate to separate them.\n\n The predicate is called for every pair of consecutive elements,\n meaning that it is called on `slice[0]` and `slice[1]`,\n followed by `slice[1]` and `slice[2]`, and so on.\n\n # Examples\n\n ```\n let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2];\n\n let mut iter = slice.chunk_by_mut(|a, b| a == b);\n\n assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n assert_eq!(iter.next(), None);\n ```\n\n This method can be used to extract the sorted subslices:\n\n ```\n let slice = &mut [1, 1, 2, 3, 2, 3, 2, 3, 4];\n\n let mut iter = slice.chunk_by_mut(|a, b| a <= b);\n\n assert_eq!(iter.next(), Some(&mut [1, 1, 2, 3][..]));\n assert_eq!(iter.next(), Some(&mut [2, 3][..]));\n assert_eq!(iter.next(), Some(&mut [2, 3, 4][..]));\n assert_eq!(iter.next(), None);\n ```\n"
}