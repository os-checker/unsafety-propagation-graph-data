{
  "name": "core::slice::sort::select::median_of_medians",
  "span": "$library/core/src/slice/sort/select.rs:168:1: 168:98",
  "src": "fn median_of_medians<T, F: FnMut(&T, &T) -> bool>(mut v: &mut [T], is_less: &mut F, mut k: usize) {\n    // Since this function isn't public, it should never be called with an out-of-bounds index.\n    debug_assert!(k < v.len());\n\n    // If T is as ZST, `partition_at_index` will already return early.\n    debug_assert!(!T::IS_ZST);\n\n    // We now know that `k < v.len() <= isize::MAX`\n    loop {\n        if v.len() <= INSERTION_SORT_THRESHOLD {\n            if v.len() >= 2 {\n                insertion_sort_shift_left(v, 1, is_less);\n            }\n\n            return;\n        }\n\n        // `median_of_{minima,maxima}` can't handle the extreme cases of the first/last element,\n        // so we catch them here and just do a linear search.\n        if k == v.len() - 1 {\n            // Find max element and place it in the last position of the array. We're free to use\n            // `unwrap()` here because we know v must not be empty.\n            let max_idx = max_index(v, is_less).unwrap();\n            v.swap(max_idx, k);\n            return;\n        } else if k == 0 {\n            // Find min element and place it in the first position of the array. We're free to use\n            // `unwrap()` here because we know v must not be empty.\n            let min_idx = min_index(v, is_less).unwrap();\n            v.swap(min_idx, k);\n            return;\n        }\n\n        let p = median_of_ninthers(v, is_less);\n\n        if p == k {\n            return;\n        } else if p > k {\n            v = &mut v[..p];\n        } else {\n            // Since `p < k < v.len()`, `p + 1` doesn't overflow and is\n            // a valid index into the slice.\n            v = &mut v[p + 1..];\n            k -= p + 1;\n        }\n    }\n}"
}