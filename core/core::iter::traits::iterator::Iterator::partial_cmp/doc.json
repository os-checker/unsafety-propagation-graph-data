{
  "name": "core::iter::traits::iterator::Iterator::partial_cmp",
  "span": "$library/core/src/iter/traits/iterator.rs:3712:5: 3716:21",
  "doc": " [Lexicographically](Ord#lexicographical-comparison) compares the [`PartialOrd`] elements of\n this [`Iterator`] with those of another. The comparison works like short-circuit\n evaluation, returning a result without comparing the remaining elements.\n As soon as an order can be determined, the evaluation stops and a result is returned.\n\n # Examples\n\n ```\n use std::cmp::Ordering;\n\n assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n ```\n\n For floating-point numbers, NaN does not have a total order and will result\n in `None` when compared:\n\n ```\n assert_eq!([f64::NAN].iter().partial_cmp([1.].iter()), None);\n ```\n\n The results are determined by the order of evaluation.\n\n ```\n use std::cmp::Ordering;\n\n assert_eq!([1.0, f64::NAN].iter().partial_cmp([2.0, f64::NAN].iter()), Some(Ordering::Less));\n assert_eq!([2.0, f64::NAN].iter().partial_cmp([1.0, f64::NAN].iter()), Some(Ordering::Greater));\n assert_eq!([f64::NAN, 1.0].iter().partial_cmp([f64::NAN, 2.0].iter()), None);\n ```\n\n"
}