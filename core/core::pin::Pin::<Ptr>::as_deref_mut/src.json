{
  "name": "core::pin::Pin::<Ptr>::as_deref_mut",
  "span": "$library/core/src/pin.rs:1430:5: 1432:31",
  "src": "pub const fn as_deref_mut(self: Pin<&mut Self>) -> Pin<&mut Ptr::Target>\n    where\n        Ptr: [const] DerefMut,\n    {\n        // SAFETY: What we're asserting here is that going from\n        //\n        //     Pin<&mut Pin<Ptr>>\n        //\n        // to\n        //\n        //     Pin<&mut Ptr::Target>\n        //\n        // is safe.\n        //\n        // We need to ensure that two things hold for that to be the case:\n        //\n        // 1) Once we give out a `Pin<&mut Ptr::Target>`, a `&mut Ptr::Target` will not be given out.\n        // 2) By giving out a `Pin<&mut Ptr::Target>`, we do not risk violating\n        // `Pin<&mut Pin<Ptr>>`\n        //\n        // The existence of `Pin<Ptr>` is sufficient to guarantee #1: since we already have a\n        // `Pin<Ptr>`, it must already uphold the pinning guarantees, which must mean that\n        // `Pin<&mut Ptr::Target>` does as well, since `Pin::as_mut` is safe. We do not have to rely\n        // on the fact that `Ptr` is _also_ pinned.\n        //\n        // For #2, we need to ensure that code given a `Pin<&mut Ptr::Target>` cannot cause the\n        // `Pin<Ptr>` to move? That is not possible, since `Pin<&mut Ptr::Target>` no longer retains\n        // any access to the `Ptr` itself, much less the `Pin<Ptr>`.\n        unsafe { self.get_unchecked_mut() }.as_mut()\n    }"
}