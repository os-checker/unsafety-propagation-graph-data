{
  "name": "core::slice::<impl [T]>::split_off",
  "span": "$library/core/src/slice/mod.rs:4478:5: 4481:26",
  "doc": " Removes the subslice corresponding to the given range\n and returns a reference to it.\n\n Returns `None` and does not modify the slice if the given\n range is out of bounds.\n\n Note that this method only accepts one-sided ranges such as\n `2..` or `..6`, but not `2..6`.\n\n # Examples\n\n Splitting off the first three elements of a slice:\n\n ```\n let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n let mut first_three = slice.split_off(..3).unwrap();\n\n assert_eq!(slice, &['d']);\n assert_eq!(first_three, &['a', 'b', 'c']);\n ```\n\n Splitting off a slice starting with the third element:\n\n ```\n let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n let mut tail = slice.split_off(2..).unwrap();\n\n assert_eq!(slice, &['a', 'b']);\n assert_eq!(tail, &['c', 'd']);\n ```\n\n Getting `None` when `range` is out of bounds:\n\n ```\n let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n\n assert_eq!(None, slice.split_off(5..));\n assert_eq!(None, slice.split_off(..5));\n assert_eq!(None, slice.split_off(..=4));\n let expected: &[char] = &['a', 'b', 'c', 'd'];\n assert_eq!(Some(expected), slice.split_off(..4));\n ```\n"
}