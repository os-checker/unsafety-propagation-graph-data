{
  "name": "core::<slice::iter::Iter<'a, T> as iter::traits::iterator::Iterator>::fold",
  "span": "$library/core/src/slice/iter/macros.rs:259:13: 261:50",
  "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }"
}