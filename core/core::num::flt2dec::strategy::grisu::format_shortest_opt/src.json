{
  "name": "core::num::flt2dec::strategy::grisu::format_shortest_opt",
  "span": "$library/core/src/num/flt2dec/strategy/grisu.rs:165:1: 168:48",
  "src": "pub fn format_shortest_opt<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n    assert!(d.mant + d.plus < (1 << 61)); // we need at least three bits of additional precision\n\n    // start with the normalized values with the shared exponent\n    let plus = Fp { f: d.mant + d.plus, e: d.exp }.normalize();\n    let minus = Fp { f: d.mant - d.minus, e: d.exp }.normalize_to(plus.e);\n    let v = Fp { f: d.mant, e: d.exp }.normalize_to(plus.e);\n\n    // find any `cached = 10^minusk` such that `ALPHA <= minusk + plus.e + 64 <= GAMMA`.\n    // since `plus` is normalized, this means `2^(62 + ALPHA) <= plus * cached < 2^(64 + GAMMA)`;\n    // given our choices of `ALPHA` and `GAMMA`, this puts `plus * cached` into `[4, 2^32)`.\n    //\n    // it is obviously desirable to maximize `GAMMA - ALPHA`,\n    // so that we don't need many cached powers of 10, but there are some considerations:\n    //\n    // 1. we want to keep `floor(plus * cached)` within `u32` since it needs a costly division.\n    //    (this is not really avoidable, remainder is required for accuracy estimation.)\n    // 2. the remainder of `floor(plus * cached)` repeatedly gets multiplied by 10,\n    //    and it should not overflow.\n    //\n    // the first gives `64 + GAMMA <= 32`, while the second gives `10 * 2^-ALPHA <= 2^64`;\n    // -60 and -32 is the maximal range with this constraint, and V8 also uses them.\n    let (minusk, cached) = cached_power(ALPHA - plus.e - 64, GAMMA - plus.e - 64);\n\n    // scale fps. this gives the maximal error of 1 ulp (proved from Theorem 5.1).\n    let plus = plus.mul(cached);\n    let minus = minus.mul(cached);\n    let v = v.mul(cached);\n    debug_assert_eq!(plus.e, minus.e);\n    debug_assert_eq!(plus.e, v.e);\n\n    //         +- actual range of minus\n    //   | <---|---------------------- unsafe region --------------------------> |\n    //   |     |                                                                 |\n    //   |  |<--->|  | <--------------- safe region ---------------> |           |\n    //   |  |     |  |                                               |           |\n    //   |1 ulp|1 ulp|                 |1 ulp|1 ulp|                 |1 ulp|1 ulp|\n    //   |<--->|<--->|                 |<--->|<--->|                 |<--->|<--->|\n    //   |-----|-----|-------...-------|-----|-----|-------...-------|-----|-----|\n    //   |   minus   |                 |     v     |                 |   plus    |\n    // minus1     minus0           v - 1 ulp   v + 1 ulp           plus0       plus1\n    //\n    // above `minus`, `v` and `plus` are *quantized* approximations (error < 1 ulp).\n    // as we don't know the error is positive or negative, we use two approximations spaced equally\n    // and have the maximal error of 2 ulps.\n    //\n    // the \"unsafe region\" is a liberal interval which we initially generate.\n    // the \"safe region\" is a conservative interval which we only accept.\n    // we start with the correct repr within the unsafe region, and try to find the closest repr\n    // to `v` which is also within the safe region. if we can't, we give up.\n    let plus1 = plus.f + 1;\n    //  let plus0 = plus.f - 1; // only for explanation\n    //  let minus0 = minus.f + 1; // only for explanation\n    let minus1 = minus.f - 1;\n    let e = -plus.e as usize; // shared exponent\n\n    // divide `plus1` into integral and fractional parts.\n    // integral parts are guaranteed to fit in u32, since cached power guarantees `plus < 2^32`\n    // and normalized `plus.f` is always less than `2^64 - 2^4` due to the precision requirement.\n    let plus1int = (plus1 >> e) as u32;\n    let plus1frac = plus1 & ((1 << e) - 1);\n\n    // calculate the largest `10^max_kappa` no more than `plus1` (thus `plus1 < 10^(max_kappa+1)`).\n    // this is an upper bound of `kappa` below.\n    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(plus1int);\n\n    let mut i = 0;\n    let exp = max_kappa as i16 - minusk + 1;\n\n    // Theorem 6.2: if `k` is the greatest integer s.t. `0 <= y mod 10^k <= y - x`,\n    //              then `V = floor(y / 10^k) * 10^k` is in `[x, y]` and one of the shortest\n    //              representations (with the minimal number of significant digits) in that range.\n    //\n    // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n    // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n    // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n    // the algorithm relies on the later verification phase to exclude `y`.\n    let delta1 = plus1 - minus1;\n    //  let delta1int = (delta1 >> e) as usize; // only for explanation\n    let delta1frac = delta1 & ((1 << e) - 1);\n\n    // render integral parts, while checking for the accuracy at each step.\n    let mut ten_kappa = max_ten_kappa; // 10^kappa\n    let mut remainder = plus1int; // digits yet to be rendered\n    loop {\n        // we always have at least one digit to render, as `plus1 >= 10^kappa`\n        // invariants:\n        // - `delta1int <= remainder < 10^(kappa+1)`\n        // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n        //   (it follows that `remainder = plus1int % 10^(kappa+1)`)\n\n        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n        let q = remainder / ten_kappa;\n        let r = remainder % ten_kappa;\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        let plus1rem = ((r as u64) << e) + plus1frac; // == (plus1 % 10^kappa) * 2^e\n        if plus1rem < delta1 {\n            // `plus1 % 10^kappa < delta1 = plus1 - minus1`; we've found the correct `kappa`.\n            let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n            return round_and_weed(\n                // SAFETY: we initialized that memory above.\n                unsafe { buf[..i].assume_init_mut() },\n                exp,\n                plus1rem,\n                delta1,\n                plus1 - v.f,\n                ten_kappa,\n                1,\n            );\n        }\n\n        // break the loop when we have rendered all integral digits.\n        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n        if i > max_kappa as usize {\n            debug_assert_eq!(ten_kappa, 1);\n            break;\n        }\n\n        // restore invariants\n        ten_kappa /= 10;\n        remainder = r;\n    }\n\n    // render fractional parts, while checking for the accuracy at each step.\n    // this time we rely on repeated multiplications, as division will lose the precision.\n    let mut remainder = plus1frac;\n    let mut threshold = delta1frac;\n    let mut ulp = 1;\n    loop {\n        // the next digit should be significant as we've tested that before breaking out\n        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n        // - `remainder < 2^e`\n        // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n\n        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n        threshold *= 10;\n        ulp *= 10;\n\n        // divide `remainder` by `10^kappa`.\n        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n        let q = remainder >> e;\n        let r = remainder & ((1 << e) - 1);\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        if r < threshold {\n            let ten_kappa = 1 << e; // implicit divisor\n            return round_and_weed(\n                // SAFETY: we initialized that memory above.\n                unsafe { buf[..i].assume_init_mut() },\n                exp,\n                r,\n                threshold,\n                (plus1 - v.f) * ulp,\n                ten_kappa,\n                ulp,\n            );\n        }\n\n        // restore invariants\n        remainder = r;\n    }\n\n    // we've generated all significant digits of `plus1`, but not sure if it's the optimal one.\n    // for example, if `minus1` is 3.14153... and `plus1` is 3.14158..., there are 5 different\n    // shortest representation from 3.14154 to 3.14158 but we only have the greatest one.\n    // we have to successively decrease the last digit and check if this is the optimal repr.\n    // there are at most 9 candidates (..1 to ..9), so this is fairly quick. (\"rounding\" phase)\n    //\n    // the function checks if this \"optimal\" repr is actually within the ulp ranges,\n    // and also, it is possible that the \"second-to-optimal\" repr can actually be optimal\n    // due to the rounding error. in either cases this returns `None`. (\"weeding\" phase)\n    //\n    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n    // - `remainder = (plus1 % 10^kappa) * k`\n    // - `threshold = (plus1 - minus1) * k` (and also, `remainder < threshold`)\n    // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n    // - `ten_kappa = 10^kappa * k`\n    // - `ulp = 2^-e * k`\n    fn round_and_weed(\n        buf: &mut [u8],\n        exp: i16,\n        remainder: u64,\n        threshold: u64,\n        plus1v: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        assert!(!buf.is_empty());\n\n        // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n        // the resulting representation should be the closest representation to both.\n        //\n        // here `plus1 - v` is used since calculations are done with respect to `plus1`\n        // in order to avoid overflow/underflow (hence the seemingly swapped names).\n        let plus1v_down = plus1v + ulp; // plus1 - (v - 1 ulp)\n        let plus1v_up = plus1v - ulp; // plus1 - (v + 1 ulp)\n\n        // decrease the last digit and stop at the closest representation to `v + 1 ulp`.\n        let mut plus1w = remainder; // plus1w(n) = plus1 - w(n)\n        {\n            let last = buf.last_mut().unwrap();\n\n            // we work with the approximated digits `w(n)`, which is initially equal to `plus1 -\n            // plus1 % 10^kappa`. after running the loop body `n` times, `w(n) = plus1 -\n            // plus1 % 10^kappa - n * 10^kappa`. we set `plus1w(n) = plus1 - w(n) =\n            // plus1 % 10^kappa + n * 10^kappa` (thus `remainder = plus1w(0)`) to simplify checks.\n            // note that `plus1w(n)` is always increasing.\n            //\n            // we have three conditions to terminate. any of them will make the loop unable to\n            // proceed, but we then have at least one valid representation known to be closest to\n            // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n            //\n            // TC1: `w(n) <= v + 1 ulp`, i.e., this is the last repr that can be the closest one.\n            // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n            // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n            // overflow on the calculation of `plus1w(n)`.\n            //\n            // TC2: `w(n+1) < minus1`, i.e., the next repr definitely does not round to `v`.\n            // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n            // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n            // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n            // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n            // `threshold - plus1w(n) < 10^kappa` instead.\n            //\n            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e., the next repr is\n            // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n            // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n            // `z(n) > 0`. we have two cases to consider:\n            //\n            // - when `z(n+1) >= 0`: TC3 becomes `z(n) <= z(n+1)`. as `plus1w(n)` is increasing,\n            //   `z(n)` should be decreasing and this is clearly false.\n            // - when `z(n+1) < 0`:\n            //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n            //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e., `plus1v_up - plus1w(n) >=\n            //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n            //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n            //     combined with TC3a.\n            //\n            // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n            // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n            while plus1w < plus1v_up\n                && threshold - plus1w >= ten_kappa\n                && (plus1w + ten_kappa < plus1v_up\n                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n            {\n                *last -= 1;\n                debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                plus1w += ten_kappa;\n            }\n        }\n\n        // check if this representation is also the closest representation to `v - 1 ulp`.\n        //\n        // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n        // replaced by `plus1v_down` instead. overflow analysis equally holds.\n        if plus1w < plus1v_down\n            && threshold - plus1w >= ten_kappa\n            && (plus1w + ten_kappa < plus1v_down\n                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n        {\n            return None;\n        }\n\n        // now we have the closest representation to `v` between `plus1` and `minus1`.\n        // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n        // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n        // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp { Some((buf, exp)) } else { None }\n    }\n}"
}