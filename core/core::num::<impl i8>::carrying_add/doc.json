{
  "name": "core::num::<impl i8>::carrying_add",
  "span": "$library/core/src/num/int_macros.rs:2517:9: 2517:80",
  "doc": " Calculates `self` + `rhs` + `carry` and checks for overflow.\n\n Performs \"ternary addition\" of two integer operands and a carry-in\n bit, and returns a tuple of the sum along with a boolean indicating\n whether an arithmetic overflow would occur. On overflow, the wrapped\n value is returned.\n\n This allows chaining together multiple additions to create a wider\n addition, and can be useful for bignum addition. This method should\n only be used for the most significant word; for the less significant\n words the unsigned method\n should be used.\n\n The output boolean returned by this method is *not* a carry flag,\n and should *not* be added to a more significant word.\n\n If the input carry is false, this method is equivalent to\n [`overflowing_add`](Self::overflowing_add).\n\n # Examples\n\n ```\n #![feature(bigint_helper_methods)]\n // Only the most significant word is signed.\n //\n // ---------\n\n let carry0 = false;\n\n let (sum0, carry1) = a0.carrying_add(b0, carry0);\n assert_eq!(carry1, true);\n\n let (sum1, overflow) = a1.carrying_add(b1, carry1);\n assert_eq!(overflow, false);\n\n assert_eq!((sum1, sum0), (6, 8));\n ```\n"
}