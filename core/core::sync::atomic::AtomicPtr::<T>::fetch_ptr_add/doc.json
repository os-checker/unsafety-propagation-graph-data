{
  "name": "core::sync::atomic::AtomicPtr::<T>::fetch_ptr_add",
  "span": "$library/core/src/sync/atomic.rs:2242:5: 2242:71",
  "doc": " Offsets the pointer's address by adding `val` (in units of `T`),\n returning the previous pointer.\n\n This is equivalent to using [`wrapping_add`] to atomically perform the\n equivalent of `ptr = ptr.wrapping_add(val);`.\n\n This method operates in units of `T`, which means that it cannot be used\n to offset the pointer by an amount which is not a multiple of\n `size_of::<T>()`. This can sometimes be inconvenient, as you may want to\n work with a deliberately misaligned pointer. In such cases, you may use\n the [`fetch_byte_add`](Self::fetch_byte_add) method instead.\n\n `fetch_ptr_add` takes an [`Ordering`] argument which describes the\n memory ordering of this operation. All ordering modes are possible. Note\n that using [`Acquire`] makes the store part of this operation\n [`Relaxed`], and using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic\n operations on [`AtomicPtr`].\n\n [`wrapping_add`]: pointer::wrapping_add\n\n # Examples\n\n ```\n use core::sync::atomic::{AtomicPtr, Ordering};\n\n let atom = AtomicPtr::<i64>::new(core::ptr::null_mut());\n assert_eq!(atom.fetch_ptr_add(1, Ordering::Relaxed).addr(), 0);\n // Note: units of `size_of::<i64>()`.\n assert_eq!(atom.load(Ordering::Relaxed).addr(), 8);\n ```\n"
}