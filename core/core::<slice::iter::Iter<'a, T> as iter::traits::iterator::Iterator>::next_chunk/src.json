{
  "name": "core::<slice::iter::Iter<'a, T> as iter::traits::iterator::Iterator>::next_chunk",
  "span": "$library/core/src/slice/iter/macros.rs:194:13: 194:108",
  "src": "fn next_chunk<const N:usize>(&mut self) -> Result<[$elem; N], crate::array::IntoIter<$elem, N>> {\n                if T::IS_ZST {\n                    return crate::array::iter_next_chunk(self);\n                }\n                let len = len!(self);\n                if len >= N {\n                    // SAFETY: we are just getting an array of [T; N] and moving the pointer over a little\n                    let r = unsafe { self.post_inc_start(N).cast_array().$into_ref() }\n                        .$array_ref(); // must convert &[T; N] to [&T; N]\n                    Ok(r)\n                } else {\n                    // cant use $array_ref because theres no builtin for &mut [MU<T>; N] -> [&mut MU<T>; N]\n                    // cant use copy_nonoverlapping as the $elem is of type &{mut} T instead of T\n                    let mut a = [const { crate::mem::MaybeUninit::<$elem>::uninit() }; N];\n                    for into in (&mut a).into_iter().take(len) {\n                        // SAFETY: take(n) limits to remainder (slice produces worse codegen)\n                        into.write(unsafe { self.post_inc_start(1).$into_ref() });\n                    }\n                    // SAFETY: we just initialized elements 0..len\n                    unsafe { Err(crate::array::IntoIter::new_unchecked(a, 0..len)) }\n                }\n            }"
}