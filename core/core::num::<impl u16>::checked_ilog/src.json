{
  "name": "core::num::<impl u16>::checked_ilog",
  "span": "$library/core/src/num/uint_macros.rs:1646:9: 1646:67",
  "src": "pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            // Inform compiler of optimizations when the base is known at\n            // compile time and there's a cheaper method available.\n            //\n            // Note: Like all optimizations, this is not guaranteed to be\n            // applied by the compiler. If you want those specific bases,\n            // use `.checked_ilog2()` or `.checked_ilog10()` directly.\n            if core::intrinsics::is_val_statically_known(base) {\n                if base == 2 {\n                    return self.checked_ilog2();\n                } else if base == 10 {\n                    return self.checked_ilog10();\n                }\n            }\n\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for ⌊log(base,self)⌋ because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                ≥ ⌊log(2,self)⌋ / (⌊log(2,base)⌋ + 1)\n                    //\n                    // hence\n                    //\n                    // ⌊log(base,self)⌋ ≥ ⌊ ⌊log(2,self)⌋ / (⌊log(2,base)⌋ + 1) ⌋ .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }"
}