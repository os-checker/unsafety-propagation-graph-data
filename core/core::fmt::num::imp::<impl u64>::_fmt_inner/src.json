{
  "name": "core::fmt::num::imp::<impl u64>::_fmt_inner",
  "span": "$library/core/src/fmt/num.rs:190:13: 190:79",
  "src": "unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit::<u8>]) -> usize {\n                // Count the number of bytes in buf that are not initialized.\n                let mut offset = buf.len();\n                // Consume the least-significant decimals from a working copy.\n                let mut remain = self;\n\n                // Format per four digits from the lookup table.\n                // Four digits need a 16-bit $Unsigned or wider.\n                while size_of::<Self>() > 1 && remain > 999.try_into().expect(\"branch is not hit for types that cannot fit 999 (u8)\") {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the while condition ensures at least 4 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 4) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 4;\n\n                    // pull two pairs\n                    let scale: Self = 1_00_00.try_into().expect(\"branch is not hit for types that cannot fit 1E4 (u8)\");\n                    let quad = remain % scale;\n                    remain /= scale;\n                    let pair1 = (quad / 100) as usize;\n                    let pair2 = (quad % 100) as usize;\n                    buf[offset + 0].write(DECIMAL_PAIRS[pair1 * 2 + 0]);\n                    buf[offset + 1].write(DECIMAL_PAIRS[pair1 * 2 + 1]);\n                    buf[offset + 2].write(DECIMAL_PAIRS[pair2 * 2 + 0]);\n                    buf[offset + 3].write(DECIMAL_PAIRS[pair2 * 2 + 1]);\n                }\n\n                // Format per two digits from the lookup table.\n                if remain > 9 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures at least 2 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 2) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 2;\n\n                    let pair = (remain % 100) as usize;\n                    remain /= 100;\n                    buf[offset + 0].write(DECIMAL_PAIRS[pair * 2 + 0]);\n                    buf[offset + 1].write(DECIMAL_PAIRS[pair * 2 + 1]);\n                }\n\n                // Format the last remaining digit, if any.\n                if remain != 0 || self == 0 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures (at least) 1 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 1) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 1;\n\n                    // Either the compiler sees that remain < 10, or it prevents\n                    // a boundary check up next.\n                    let last = (remain & 15) as usize;\n                    buf[offset].write(DECIMAL_PAIRS[last * 2 + 1]);\n                    // not used: remain = 0;\n                }\n\n                offset\n            }"
}