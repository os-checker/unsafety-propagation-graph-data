{
  "name": "core::slice::sort::select::partition_at_index",
  "span": "$library/core/src/slice/sort/select.rs:17:1: 23:30",
  "src": "pub(crate) fn partition_at_index<T, F>(\n    v: &mut [T],\n    index: usize,\n    mut is_less: F,\n) -> (&mut [T], &mut T, &mut [T])\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let len = v.len();\n\n    // Puts a lower limit of 1 on `len`.\n    if index >= len {\n        panic!(\"partition_at_index index {} greater than length of slice {}\", index, len);\n    }\n\n    if T::IS_ZST {\n        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n    } else if index == len - 1 {\n        // Find max element and place it in the last position of the array. We're free to use\n        // `unwrap()` here because we checked that `v` is not empty.\n        let max_idx = max_index(v, &mut is_less).unwrap();\n        v.swap(max_idx, index);\n    } else if index == 0 {\n        // Find min element and place it in the first position of the array. We're free to use\n        // `unwrap()` here because we checked that `v` is not empty.\n        let min_idx = min_index(v, &mut is_less).unwrap();\n        v.swap(min_idx, index);\n    } else {\n        cfg_select! {\n            feature = \"optimize_for_size\" => {\n                median_of_medians(v, &mut is_less, index);\n            }\n            _ => {\n                partition_at_index_loop(v, index, None, &mut is_less);\n            }\n        }\n    }\n\n    let (left, right) = v.split_at_mut(index);\n    let (pivot, right) = right.split_at_mut(1);\n    let pivot = &mut pivot[0];\n    (left, pivot, right)\n}"
}