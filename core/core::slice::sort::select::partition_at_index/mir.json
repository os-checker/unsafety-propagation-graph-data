{
  "name": "core::slice::sort::select::partition_at_index",
  "span": "$library/core/src/slice/sort/select.rs:17:1: 23:30",
  "mir": "fn core::slice::sort::select::partition_at_index(_1: &mut [T], _2: usize, _3: F) -> (&mut [T], &mut T, &mut [T]) {\n    let mut _0: (&mut [T], &mut T, &mut [T]);\n    let  _4: usize;\n    let mut _5: &[T];\n    let mut _6: bool;\n    let  _7: !;\n    let mut _8: fmt::Arguments<'_>;\n    let  _9: (&usize, &usize);\n    let mut _10: &usize;\n    let mut _11: &usize;\n    let  _12: [fmt::rt::Argument<'_>; 2];\n    let mut _13: fmt::rt::Argument<'_>;\n    let mut _14: fmt::rt::Argument<'_>;\n    let mut _15: &[u8; 60];\n    let  _16: &[fmt::rt::Argument<'_>; 2];\n    let mut _17: bool;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: usize;\n    let mut _21: option::Option<usize>;\n    let mut _22: &[T];\n    let mut _23: &mut F;\n    let  _24: ();\n    let  _25: usize;\n    let mut _26: option::Option<usize>;\n    let mut _27: &[T];\n    let mut _28: &mut F;\n    let  _29: ();\n    let  _30: ();\n    let mut _31: option::Option<&T>;\n    let mut _32: &mut F;\n    let  _33: &mut [T];\n    let  _34: &mut [T];\n    let mut _35: (&mut [T], &mut [T]);\n    let  _36: &mut [T];\n    let  _37: &mut [T];\n    let mut _38: (&mut [T], &mut [T]);\n    let  _39: &mut T;\n    let  _40: usize;\n    let mut _41: *const [T];\n    let mut _42: usize;\n    let mut _43: bool;\n    let mut _44: &usize;\n    let mut _45: &usize;\n    debug v => _1;\n    debug index => _2;\n    debug is_less => _3;\n    debug len => _4;\n    debug args => _9;\n    debug args => _12;\n    debug max_idx => _20;\n    debug min_idx => _25;\n    debug left => _33;\n    debug right => _34;\n    debug pivot => _36;\n    debug right => _37;\n    debug pivot => _39;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = Ge(_2, _4);\n        switchInt(move _6) -> [0: bb5, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        StorageLive(_11);\n        _11 = &_4;\n        _9 = (move _10, move _11);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        _44 = (_9.0: &usize);\n        _13 = fmt::rt::Argument::<'_>::new_display::<usize>(_44) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_14);\n        _45 = (_9.1: &usize);\n        _14 = fmt::rt::Argument::<'_>::new_display::<usize>(_45) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _12 = [move _13, move _14];\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = b\"\\x19partition_at_index index \\xc0\\x1e greater than length of slice \\xc0\\x00\";\n        _16 = &_12;\n        _8 = fmt::Arguments::<'_>::new::<60, 2>(move _15, _16) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_15);\n        _7 = panicking::panic_fmt(move _8) -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_6);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb6, otherwise: bb21];\n    }\n    bb6: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _19 = CheckedSub(_4, 1_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _18 = move (_19.0: usize);\n        _17 = Eq(_2, move _18);\n        switchInt(move _17) -> [0: bb12, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_18);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _23 = &mut _3;\n        _21 = slice::sort::select::max_index::<T, F>(move _22, _23) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_22);\n        _20 = option::Option::<usize>::unwrap(move _21) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_21);\n        _24 = slice::<impl [T]>::swap(_1, _20, _2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        goto -> bb20;\n    }\n    bb12: {\n        StorageDead(_18);\n        switchInt(_2) -> [0: bb13, otherwise: bb17];\n    }\n    bb13: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &(*_1);\n        _28 = &mut _3;\n        _26 = slice::sort::select::min_index::<T, F>(move _27, _28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        _25 = option::Option::<usize>::unwrap(move _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_26);\n        _29 = slice::<impl [T]>::swap(_1, _25, _2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        goto -> bb19;\n    }\n    bb17: {\n        StorageLive(_31);\n        _31 = option::Option::None;\n        _32 = &mut _3;\n        _30 = slice::sort::select::partition_at_index_loop::<T, F>(_1, _2, move _31, _32) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        goto -> bb19;\n    }\n    bb19: {\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_17);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_35);\n        _35 = slice::<impl [T]>::split_at_mut(_1, _2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _33 = move (_35.0: &mut [T]);\n        _34 = move (_35.1: &mut [T]);\n        StorageDead(_35);\n        StorageLive(_38);\n        _38 = slice::<impl [T]>::split_at_mut(_34, 1_usize) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_36);\n        _36 = move (_38.0: &mut [T]);\n        _37 = move (_38.1: &mut [T]);\n        StorageDead(_38);\n        StorageLive(_40);\n        _40 = 0_usize;\n        _41 = &raw const (fake) (*_36);\n        _42 = PtrMetadata(move _41);\n        _43 = Lt(_40, _42);\n        assert(move _43, \"index out of bounds: the length is {} but the index is {}\", move _42, _40) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _39 = &mut (*_36)[_40];\n        StorageDead(_40);\n        _0 = (_33, _39, _37);\n        StorageDead(_36);\n        drop(_3) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        return;\n    }\n}\n"
}