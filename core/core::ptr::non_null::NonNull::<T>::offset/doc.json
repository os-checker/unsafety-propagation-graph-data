{
  "name": "core::ptr::non_null::NonNull::<T>::offset",
  "span": "$library/core/src/ptr/non_null.rs:576:5: 578:18",
  "doc": " Adds an offset to a pointer.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut s = [1, 2, 3];\n let ptr: NonNull<u32> = NonNull::new(s.as_mut_ptr()).unwrap();\n\n unsafe {\n     println!(\"{}\", ptr.offset(1).read());\n     println!(\"{}\", ptr.offset(2).read());\n }\n ```\n"
}