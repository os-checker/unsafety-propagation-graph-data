{
  "name": "core::unicode::unicode_data::skip_search",
  "span": "$library/core/src/unicode/unicode_data.rs:88:1: 92:10",
  "src": "unsafe fn skip_search<const SOR: usize, const OFFSETS: usize>(\n    needle: char,\n    short_offset_runs: &[ShortOffsetRunHeader; SOR],\n    offsets: &[u8; OFFSETS],\n) -> bool {\n    let needle = needle as u32;\n\n    let last_idx =\n        match short_offset_runs.binary_search_by_key(&(needle << 11), |header| header.0 << 11) {\n            Ok(idx) => idx + 1,\n            Err(idx) => idx,\n        };\n    // SAFETY: `last_idx` *cannot* be past the end of the array, as the last\n    // element is greater than `std::char::MAX` (the largest possible needle)\n    // as guaranteed by the caller.\n    //\n    // So, we cannot have found it (i.e. `Ok(idx) => idx + 1 != length`) and the\n    // correct location cannot be past it, so `Err(idx) => idx != length` either.\n    //\n    // This means that we can avoid bounds checking for the accesses below, too.\n    //\n    // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n    // in `hint::assert_unchecked` may not be optimized out.\n    unsafe { crate::intrinsics::assume(last_idx < SOR) };\n\n    let mut offset_idx = short_offset_runs[last_idx].start_index();\n    let length = if let Some(next) = short_offset_runs.get(last_idx + 1) {\n        (*next).start_index() - offset_idx\n    } else {\n        offsets.len() - offset_idx\n    };\n\n    let prev =\n        last_idx.checked_sub(1).map(|prev| short_offset_runs[prev].prefix_sum()).unwrap_or(0);\n\n    let total = needle - prev;\n    let mut prefix_sum = 0;\n    for _ in 0..(length - 1) {\n        // SAFETY: It is guaranteed that `length <= OFFSETS - offset_idx`,\n        // so it follows that `length - 1 + offset_idx < OFFSETS`, therefore\n        // `offset_idx < OFFSETS` is always true in this loop.\n        //\n        // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n        // in `hint::assert_unchecked` may not be optimized out.\n        unsafe { crate::intrinsics::assume(offset_idx < OFFSETS) };\n        let offset = offsets[offset_idx];\n        prefix_sum += offset as u32;\n        if prefix_sum > total {\n            break;\n        }\n        offset_idx += 1;\n    }\n    offset_idx % 2 == 1\n}"
}