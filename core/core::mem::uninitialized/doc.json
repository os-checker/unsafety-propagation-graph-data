{
  "name": "core::mem::uninitialized",
  "span": "$library/core/src/mem/mod.rs:710:1: 710:38",
  "doc": " Bypasses Rust's normal memory-initialization checks by pretending to\n produce a value of type `T`, while doing nothing at all.\n\n **This function is deprecated.** Use [`MaybeUninit<T>`] instead.\n It also might be slower than using `MaybeUninit<T>` due to mitigations that were put in place to\n limit the potential harm caused by incorrect use of this function in legacy code.\n\n The reason for deprecation is that the function basically cannot be used\n correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].\n As the [`assume_init` documentation][assume_init] explains,\n [the Rust compiler assumes][inv] that values are properly initialized.\n\n Truly uninitialized memory like what gets returned here\n is special in that the compiler knows that it does not have a fixed value.\n This makes it undefined behavior to have uninitialized data in a variable even\n if that variable has an integer type.\n\n Therefore, it is immediate undefined behavior to call this function on nearly all types,\n including integer types and arrays of integer types, and even if the result is unused.\n\n [uninit]: MaybeUninit::uninit\n [assume_init]: MaybeUninit::assume_init\n [inv]: MaybeUninit#initialization-invariant\n"
}