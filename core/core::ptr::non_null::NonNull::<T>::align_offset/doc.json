{
  "name": "core::ptr::non_null::NonNull::<T>::align_offset",
  "span": "$library/core/src/ptr/non_null.rs:1293:5: 1295:18",
  "doc": " Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.\n\n If it is not possible to align the pointer, the implementation returns\n `usize::MAX`.\n\n The offset is expressed in number of `T` elements, and not bytes.\n\n There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n beyond the allocation that the pointer points into. It is up to the caller to ensure that\n the returned offset is correct in all terms other than alignment.\n\n When this is called during compile-time evaluation (which is unstable), the implementation\n may return `usize::MAX` in cases where that can never happen at runtime. This is because the\n actual alignment of pointers is not known yet during compile-time, so an offset with\n guaranteed alignment can sometimes not be computed. For example, a buffer declared as `[u8;\n N]` might be allocated at an odd or an even address, but at compile-time this is not yet\n known, so the execution has to be correct for either choice. It is therefore impossible to\n find an offset that is guaranteed to be 2-aligned. (This behavior is subject to change, as usual\n for unstable APIs.)\n\n # Panics\n\n The function panics if `align` is not a power-of-two.\n\n # Examples\n\n Accessing adjacent `u8` as `u16`\n\n ```\n use std::ptr::NonNull;\n\n # unsafe {\n let x = [5_u8, 6, 7, 8, 9];\n let ptr = NonNull::new(x.as_ptr() as *mut u8).unwrap();\n let offset = ptr.align_offset(align_of::<u16>());\n\n if offset < x.len() - 1 {\n     let u16_ptr = ptr.add(offset).cast::<u16>();\n     assert!(u16_ptr.read() == u16::from_ne_bytes([5, 6]) || u16_ptr.read() == u16::from_ne_bytes([6, 7]));\n } else {\n     // while the pointer can be aligned via `offset`, it would point\n     // outside the allocation\n }\n # }\n ```\n"
}