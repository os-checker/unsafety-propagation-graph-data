{
  "name": "core::num::dec2flt::dec2flt",
  "span": "$library/core/src/num/dec2flt/mod.rs:256:1: 256:67",
  "src": "pub fn dec2flt<F: RawFloat>(s: &str) -> Result<F, ParseFloatError> {\n    let mut s = s.as_bytes();\n    let c = if let Some(&c) = s.first() {\n        c\n    } else {\n        return Err(pfe_empty());\n    };\n    let negative = c == b'-';\n    if c == b'-' || c == b'+' {\n        s = &s[1..];\n    }\n    if s.is_empty() {\n        return Err(pfe_invalid());\n    }\n\n    let mut num = match parse_number(s) {\n        Some(r) => r,\n        None if let Some(value) = parse_inf_nan(s, negative) => return Ok(value),\n        None => return Err(pfe_invalid()),\n    };\n    num.negative = negative;\n    if !cfg!(feature = \"optimize_for_size\") {\n        if let Some(value) = num.try_fast_path::<F>() {\n            return Ok(value);\n        }\n    }\n\n    // If significant digits were truncated, then we can have rounding error\n    // only if `mantissa + 1` produces a different result. We also avoid\n    // redundantly using the Eisel-Lemire algorithm if it was unable to\n    // correctly round on the first pass.\n    let mut fp = compute_float::<F>(num.exponent, num.mantissa);\n    if num.many_digits\n        && fp.p_biased >= 0\n        && fp != compute_float::<F>(num.exponent, num.mantissa + 1)\n    {\n        fp.p_biased = -1;\n    }\n    // Unable to correctly round the float using the Eisel-Lemire algorithm.\n    // Fallback to a slower, but always correct algorithm.\n    if fp.p_biased < 0 {\n        fp = parse_long_mantissa::<F>(s);\n    }\n\n    let mut float = biased_fp_to_float::<F>(fp);\n    if num.negative {\n        float = -float;\n    }\n    Ok(float)\n}"
}