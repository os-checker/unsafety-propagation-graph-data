{
  "name": "core::num::<impl u16>::unchecked_sub",
  "span": "$library/core/src/num/uint_macros.rs:966:9: 966:67",
  "doc": " Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n cannot occur.\n\n Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n\n If you're just trying to avoid the panic in debug mode, then **do not**\n use this.  Instead, you're looking for [`wrapping_sub`].\n\n If you find yourself writing code like this:\n\n ```\n # let foo = 30_u32;\n # let bar = 20;\n if foo >= bar {\n     // SAFETY: just checked it will not overflow\n     let diff = unsafe { foo.unchecked_sub(bar) };\n     // ... use diff ...\n }\n ```\n\n Consider changing it to\n\n ```\n # let foo = 30_u32;\n # let bar = 20;\n if let Some(diff) = foo.checked_sub(bar) {\n     // ... use diff ...\n }\n ```\n\n As that does exactly the same thing -- including telling the optimizer\n that the subtraction cannot overflow -- but avoids needing `unsafe`.\n\n # Safety\n\n This results in undefined behavior when\n i.e. when [`checked_sub`] would return `None`.\n\n [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n"
}