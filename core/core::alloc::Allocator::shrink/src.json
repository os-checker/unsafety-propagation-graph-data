{
  "name": "core::alloc::Allocator::shrink",
  "span": "$library/core/src/alloc/mod.rs:332:5: 337:43",
  "src": "unsafe fn shrink(\n        &self,\n        ptr: NonNull<u8>,\n        old_layout: Layout,\n        new_layout: Layout,\n    ) -> Result<NonNull<[u8]>, AllocError> {\n        debug_assert!(\n            new_layout.size() <= old_layout.size(),\n            \"`new_layout.size()` must be smaller than or equal to `old_layout.size()`\"\n        );\n\n        let new_ptr = self.allocate(new_layout)?;\n\n        // SAFETY: because `new_layout.size()` must be lower than or equal to\n        // `old_layout.size()`, both the old and new memory allocation are valid for reads and\n        // writes for `new_layout.size()` bytes. Also, because the old allocation wasn't yet\n        // deallocated, it cannot overlap `new_ptr`. Thus, the call to `copy_nonoverlapping` is\n        // safe. The safety contract for `dealloc` must be upheld by the caller.\n        unsafe {\n            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_mut_ptr(), new_layout.size());\n            self.deallocate(ptr, old_layout);\n        }\n\n        Ok(new_ptr)\n    }"
}