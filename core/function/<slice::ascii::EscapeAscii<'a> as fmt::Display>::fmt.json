{
  "name": "<slice::ascii::EscapeAscii<'a> as fmt::Display>::fmt",
  "safe": true,
  "callees": {
    "clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "iter::adapters::flatten::FlatMap::<I, U, F>::into_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ascii::EscapeDefault::empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ascii::EscapeDefault": "Constructor"
      }
    },
    "option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::unwrap_or_default": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a default.\n\n Consumes the `self` argument then, if [`Some`], returns the contained\n value, otherwise if [`None`], returns the [default value] for that\n type.\n\n # Examples\n\n ```\n let x: Option<u32> = None;\n let y: Option<u32> = Some(12);\n\n assert_eq!(x.unwrap_or_default(), 0);\n assert_eq!(y.unwrap_or_default(), 12);\n ```\n\n [default value]: Default::default\n [`parse`]: str::parse\n [`FromStr`]: crate::str::FromStr\n",
      "adt": {}
    },
    "slice::iter::Iter::<'a, T>::as_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Views the underlying data as a subslice of the original data.\n\n # Examples\n\n Basic usage:\n\n ```\n // First, we need a slice to call the `iter` method on:\n let slice = &[1, 2, 3];\n\n // Then we call `iter` on the slice to get the `Iter` iterator:\n let mut iter = slice.iter();\n // Here `as_slice` still returns the whole slice, so this prints \"[1, 2, 3]\":\n println!(\"{:?}\", iter.as_slice());\n\n // Now, we call the `next` method to remove the first element from the iterator:\n iter.next();\n // Here the iterator does not contain the first element of the slice any more,\n // so `as_slice` only returns the last two elements of the slice,\n // and so this prints \"[2, 3]\":\n println!(\"{:?}\", iter.as_slice());\n\n // The underlying slice has not been modified and still contains three elements,\n // so this prints \"[1, 2, 3]\":\n println!(\"{:?}\", slice);\n ```\n",
      "adt": {
        "slice::iter::Iter": "ImmutableAsArgument"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "fmt::Write::write_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {
        "slice::iter::Iter": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::take_while": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that yields elements based on a predicate.\n\n `take_while()` takes a closure as an argument. It will call this\n closure on each element of the iterator, and yield elements\n while it returns `true`.\n\n After `false` is returned, `take_while()`'s job is over, and the\n rest of the elements are ignored.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [-1i32, 0, 1];\n\n let mut iter = a.into_iter().take_while(|x| x.is_negative());\n\n assert_eq!(iter.next(), Some(-1));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `take_while()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[-1, 0, 1];\n\n let mut iter = s.iter().take_while(|x| **x < 0); // need two *s!\n\n assert_eq!(iter.next(), Some(&-1));\n assert_eq!(iter.next(), None);\n ```\n\n Stopping after an initial `false`:\n\n ```\n let a = [-1, 0, 1, -2];\n\n let mut iter = a.into_iter().take_while(|&x| x < 0);\n\n assert_eq!(iter.next(), Some(-1));\n\n // We have more elements that are less than zero, but since we already\n // got a false, take_while() ignores the remaining elements.\n assert_eq!(iter.next(), None);\n ```\n\n Because `take_while()` needs to look at the value in order to see if it\n should be included or not, consuming iterators will see that it is\n removed:\n\n ```\n let a = [1, 2, 3, 4];\n let mut iter = a.into_iter();\n\n let result: Vec<i32> = iter.by_ref().take_while(|&n| n != 3).collect();\n\n assert_eq!(result, [1, 2]);\n\n let result: Vec<i32> = iter.collect();\n\n assert_eq!(result, [4]);\n ```\n\n The `3` is no longer there, because it was consumed in order to see if\n the iteration should stop, but wasn't placed back into the iterator.\n",
      "adt": {
        "iter::adapters::take_while::TakeWhile": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the iterator, counting the number of iterations and returning it.\n\n This method will call [`next`] repeatedly until [`None`] is encountered,\n returning the number of times it saw [`Some`]. Note that [`next`] has to be\n called at least once even if the iterator does not have any elements.\n\n [`next`]: Iterator::next\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so counting elements of\n an iterator with more than [`usize::MAX`] elements either produces the\n wrong result or panics. If overflow checks are enabled, a panic is\n guaranteed.\n\n # Panics\n\n This function might panic if the iterator has more than [`usize::MAX`]\n elements.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().count(), 3);\n\n let a = [1, 2, 3, 4, 5];\n assert_eq!(a.iter().count(), 5);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::split_at_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index, without doing bounds checking.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n For a safe alternative see [`split_at`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used. The caller has to ensure that\n `0 <= mid <= self.len()`.\n\n [`split_at`]: slice::split_at\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n unsafe {\n    let (left, right) = v.split_at_unchecked(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n unsafe {\n     let (left, right) = v.split_at_unchecked(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n unsafe {\n     let (left, right) = v.split_at_unchecked(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "str::converts::from_utf8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.\n\n This is an alias to [`str::from_utf8_unchecked`].\n\n See the safe version, [`from_utf8`], for more information.\n\n # Safety\n\n The bytes passed in must be valid UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = unsafe {\n     str::from_utf8_unchecked(&sparkle_heart)\n };\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data to the underlying buffer contained within this\n formatter.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_str(\"Foo\")\n         // This is equivalent to:\n         // write!(formatter, \"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo}\"), \"Foo\");\n assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    },
    "slice::<impl [T]>::first": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the first element of the slice, or `None` if it is empty.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&10), v.first());\n\n let w: &[i32] = &[];\n assert_eq!(None, w.first());\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ascii::escape_default": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that produces an escaped version of a `u8`.\n\n The default is chosen with a bias toward producing literals that are\n legal in a variety of languages, including C++11 and similar C-family\n languages. The exact rules are:\n\n * Tab is escaped as `\\t`.\n * Carriage return is escaped as `\\r`.\n * Line feed is escaped as `\\n`.\n * Single quote is escaped as `\\'`.\n * Double quote is escaped as `\\\"`.\n * Backslash is escaped as `\\\\`.\n * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n   inclusive is not escaped.\n * Any other chars are given hex escapes of the form '\\xNN'.\n * Unicode escapes are never generated by this function.\n\n # Examples\n\n ```\n use std::ascii;\n\n let escaped = ascii::escape_default(b'0').next().unwrap();\n assert_eq!(b'0', escaped);\n\n let mut escaped = ascii::escape_default(b'\\t');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b't', escaped.next().unwrap());\n\n let mut escaped = ascii::escape_default(b'\\r');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b'r', escaped.next().unwrap());\n\n let mut escaped = ascii::escape_default(b'\\n');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b'n', escaped.next().unwrap());\n\n let mut escaped = ascii::escape_default(b'\\'');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b'\\'', escaped.next().unwrap());\n\n let mut escaped = ascii::escape_default(b'\"');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b'\"', escaped.next().unwrap());\n\n let mut escaped = ascii::escape_default(b'\\\\');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b'\\\\', escaped.next().unwrap());\n\n let mut escaped = ascii::escape_default(b'\\x9d');\n\n assert_eq!(b'\\\\', escaped.next().unwrap());\n assert_eq!(b'x', escaped.next().unwrap());\n assert_eq!(b'9', escaped.next().unwrap());\n assert_eq!(b'd', escaped.next().unwrap());\n ```\n",
      "adt": {
        "ascii::EscapeDefault": "Constructor"
      }
    },
    "fmt::Display::fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n use std::fmt;\n\n struct Position {\n     longitude: f32,\n     latitude: f32,\n }\n\n impl fmt::Display for Position {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"({}, {})\", self.longitude, self.latitude)\n     }\n }\n\n assert_eq!(\n     \"(1.987, 2.983)\",\n     format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }),\n );\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::ascii::EscapeAscii": [
      "Ref",
      "Plain",
      "Unknown([Field(0, Ty { id: 12535, kind: RigidTy(Adt(AdtDef(DefId { id: 26525, name: \"iter::adapters::flatten::FlatMap\" }), GenericArgs([Type(Ty { id: 554, kind: RigidTy(Adt(AdtDef(DefId { id: 24578, name: \"slice::iter::Iter\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 46, kind: RigidTy(Uint(U8)) })]))) }), Type(Ty { id: 1314, kind: RigidTy(Adt(AdtDef(DefId { id: 24951, name: \"ascii::EscapeDefault\" }), GenericArgs([]))) }), Type(Ty { id: 12534, kind: RigidTy(Adt(AdtDef(DefId { id: 28476, name: \"slice::ascii::EscapeByte\" }), GenericArgs([]))) })]))) })])"
    ],
    "iter::adapters::flatten::FlatMap": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Field(0, Ty { id: 12563, kind: RigidTy(Adt(AdtDef(DefId { id: 24532, name: \"option::Option\" }), GenericArgs([Type(Ty { id: 1314, kind: RigidTy(Adt(AdtDef(DefId { id: 24951, name: \"ascii::EscapeDefault\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 12564, kind: RigidTy(Adt(AdtDef(DefId { id: 24532, name: \"option::Option\" }), GenericArgs([Type(Ty { id: 554, kind: RigidTy(Adt(AdtDef(DefId { id: 24578, name: \"slice::iter::Iter\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 46, kind: RigidTy(Uint(U8)) })]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 12563, kind: RigidTy(Adt(AdtDef(DefId { id: 24532, name: \"option::Option\" }), GenericArgs([Type(Ty { id: 1314, kind: RigidTy(Adt(AdtDef(DefId { id: 24951, name: \"ascii::EscapeDefault\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 46, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) })])"
    ],
    "ascii::EscapeDefault": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "slice::iter::Iter": [
      "Plain",
      "Ref"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ],
    "iter::adapters::take_while::TakeWhile": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ]
  },
  "path": 16312,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/ascii.rs:286:5: 326:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // disassemble iterator, including front/back parts of flatmap in case it has been partially consumed\n        let (front, slice, back) = self.clone().inner.into_parts();\n        let front = front.unwrap_or(EscapeDefault::empty());\n        let mut bytes = slice.unwrap_or_default().as_slice();\n        let back = back.unwrap_or(EscapeDefault::empty());\n\n        // usually empty, so the formatter won't have to do any work\n        for byte in front {\n            f.write_char(byte as char)?;\n        }\n\n        fn needs_escape(b: u8) -> bool {\n            b > 0x7E || b < 0x20 || b == b'\\\\' || b == b'\\'' || b == b'\"'\n        }\n\n        while bytes.len() > 0 {\n            // fast path for the printable, non-escaped subset of ascii\n            let prefix = bytes.iter().take_while(|&&b| !needs_escape(b)).count();\n            // SAFETY: prefix length was derived by counting bytes in the same splice, so it's in-bounds\n            let (prefix, remainder) = unsafe { bytes.split_at_unchecked(prefix) };\n            // SAFETY: prefix is a valid utf8 sequence, as it's a subset of ASCII\n            let prefix = unsafe { crate::str::from_utf8_unchecked(prefix) };\n\n            f.write_str(prefix)?; // the fast part\n\n            bytes = remainder;\n\n            if let Some(&b) = bytes.first() {\n                // guaranteed to be non-empty, better to write it as a str\n                fmt::Display::fmt(&ascii::escape_default(b), f)?;\n                bytes = &bytes[1..];\n            }\n        }\n\n        // also usually empty\n        for byte in back {\n            f.write_char(byte as char)?;\n        }\n        Ok(())\n    }",
  "mir": "fn <slice::ascii::EscapeAscii<'a> as fmt::Display>::fmt(_1: &slice::ascii::EscapeAscii<'_>, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let  _3: option::Option<ascii::EscapeDefault>;\n    let  _4: option::Option<slice::iter::Iter<'_, u8>>;\n    let  _5: option::Option<ascii::EscapeDefault>;\n    let mut _6: (option::Option<ascii::EscapeDefault>, option::Option<slice::iter::Iter<'_, u8>>, option::Option<ascii::EscapeDefault>);\n    let mut _7: iter::adapters::flatten::FlatMap<slice::iter::Iter<'_, u8>, ascii::EscapeDefault, slice::ascii::EscapeByte>;\n    let mut _8: slice::ascii::EscapeAscii<'_>;\n    let  _9: ascii::EscapeDefault;\n    let mut _10: ascii::EscapeDefault;\n    let mut _11: &[u8];\n    let mut _12: &slice::iter::Iter<'_, u8>;\n    let  _13: slice::iter::Iter<'_, u8>;\n    let  _14: ascii::EscapeDefault;\n    let mut _15: ascii::EscapeDefault;\n    let mut _16: ascii::EscapeDefault;\n    let mut _17: ascii::EscapeDefault;\n    let mut _18: option::Option<u8>;\n    let mut _19: &mut ascii::EscapeDefault;\n    let mut _20: isize;\n    let  _21: u8;\n    let mut _22: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _23: result::Result<(), fmt::Error>;\n    let mut _24: char;\n    let mut _25: isize;\n    let mut _26: bool;\n    let mut _27: usize;\n    let mut _28: &[u8];\n    let  _29: usize;\n    let mut _30: iter::adapters::take_while::TakeWhile<slice::iter::Iter<'_, u8>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/ascii.rs:304:50: 304:55}>;\n    let mut _31: slice::iter::Iter<'_, u8>;\n    let mut _32: &[u8];\n    let  _33: &[u8];\n    let  _34: &[u8];\n    let mut _35: (&[u8], &[u8]);\n    let mut _36: &[u8];\n    let  _37: &str;\n    let mut _38: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _39: result::Result<(), fmt::Error>;\n    let mut _40: isize;\n    let mut _41: option::Option<&u8>;\n    let mut _42: &[u8];\n    let mut _43: isize;\n    let  _44: u8;\n    let mut _45: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _46: result::Result<(), fmt::Error>;\n    let  _47: &ascii::EscapeDefault;\n    let  _48: ascii::EscapeDefault;\n    let mut _49: isize;\n    let  _50: &[u8];\n    let mut _51: &[u8];\n    let mut _52: ops::range::RangeFrom<usize>;\n    let mut _53: ascii::EscapeDefault;\n    let mut _54: ascii::EscapeDefault;\n    let mut _55: option::Option<u8>;\n    let mut _56: &mut ascii::EscapeDefault;\n    let mut _57: isize;\n    let  _58: u8;\n    let mut _59: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _60: result::Result<(), fmt::Error>;\n    let mut _61: char;\n    let mut _62: isize;\n    let mut _63: &u8;\n    debug self => _1;\n    debug f => _2;\n    debug front => _3;\n    debug slice => _4;\n    debug back => _5;\n    debug front => _9;\n    debug bytes => _11;\n    debug back => _14;\n    debug iter => _17;\n    debug byte => _21;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug prefix => _29;\n    debug prefix => _33;\n    debug remainder => _34;\n    debug prefix => _37;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug b => _44;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug iter => _54;\n    debug byte => _58;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = <slice::ascii::EscapeAscii<'_> as clone::Clone>::clone(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = move (_8.0: iter::adapters::flatten::FlatMap<slice::iter::Iter<'_, u8>, ascii::EscapeDefault, slice::ascii::EscapeByte>);\n        _6 = iter::adapters::flatten::FlatMap::<slice::iter::Iter<'_, u8>, ascii::EscapeDefault, slice::ascii::EscapeByte>::into_parts(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _3 = move (_6.0: option::Option<ascii::EscapeDefault>);\n        _4 = move (_6.1: option::Option<slice::iter::Iter<'_, u8>>);\n        _5 = move (_6.2: option::Option<ascii::EscapeDefault>);\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = ascii::EscapeDefault::empty() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = option::Option::<ascii::EscapeDefault>::unwrap_or(_3, move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = option::Option::<slice::iter::Iter<'_, u8>>::unwrap_or_default(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = &_13;\n        _11 = slice::iter::Iter::<'_, u8>::as_slice(move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = ascii::EscapeDefault::empty() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = option::Option::<ascii::EscapeDefault>::unwrap_or(_5, move _15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = <ascii::EscapeDefault as iter::traits::collect::IntoIterator>::into_iter(_9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_17);\n        _17 = move _16;\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_18);\n        _19 = &mut _17;\n        _18 = <ascii::EscapeDefault as iter::traits::iterator::Iterator>::next(_19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _20 = discriminant(_18);\n        switchInt(move _20) -> [0: bb14, 1: bb13, otherwise: bb12];\n    }\n    bb12: {\n        unreachable;\n    }\n    bb13: {\n        _21 = ((_18 as variant#1).0: u8);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = _21 as char;\n        _23 = <fmt::Formatter<'_> as fmt::Write>::write_char(_2, move _24) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb20;\n    }\n    bb15: {\n        StorageDead(_24);\n        _22 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _23) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        _25 = discriminant(_22);\n        switchInt(move _25) -> [0: bb17, 1: bb18, otherwise: bb12];\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageDead(_18);\n        goto -> bb10;\n    }\n    bb18: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb55;\n    }\n    bb20: {\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _11;\n        _27 = PtrMetadata(move _28);\n        StorageDead(_28);\n        _26 = Gt(move _27, 0_usize);\n        switchInt(move _26) -> [0: bb43, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_27);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _11;\n        _31 = slice::<impl [u8]>::iter(move _32) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_32);\n        _30 = <slice::iter::Iter<'_, u8> as iter::traits::iterator::Iterator>::take_while::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/ascii.rs:304:50: 304:55}>(move _31, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/ascii.rs:304:50: 304:55}) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_31);\n        _29 = <iter::adapters::take_while::TakeWhile<slice::iter::Iter<'_, u8>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/ascii.rs:304:50: 304:55}> as iter::traits::iterator::Iterator>::count(move _30) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_30);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = _11;\n        _35 = slice::<impl [u8]>::split_at_unchecked(move _36, _29) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        _33 = (_35.0: &[u8]);\n        _34 = (_35.1: &[u8]);\n        StorageDead(_35);\n        _37 = str::converts::from_utf8_unchecked(_33) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = fmt::Formatter::<'_>::write_str(_2, _37) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _38 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _39) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_39);\n        _40 = discriminant(_38);\n        switchInt(move _40) -> [0: bb29, 1: bb30, otherwise: bb12];\n    }\n    bb29: {\n        StorageDead(_38);\n        _11 = _34;\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = _11;\n        _41 = slice::<impl [u8]>::first(move _42) -> [return: bb32, unwind unreachable];\n    }\n    bb30: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_38);\n        goto -> bb54;\n    }\n    bb32: {\n        StorageDead(_42);\n        _43 = discriminant(_41);\n        switchInt(move _43) -> [1: bb33, 0: bb41, otherwise: bb12];\n    }\n    bb33: {\n        _63 = ((_41 as variant#1).0: &u8);\n        _44 = (*_63);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_48);\n        _48 = ascii::escape_default(_44) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _47 = &_48;\n        _46 = <ascii::EscapeDefault as fmt::Display>::fmt(_47, _2) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _45 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _46) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_46);\n        _49 = discriminant(_45);\n        switchInt(move _49) -> [0: bb37, 1: bb38, otherwise: bb12];\n    }\n    bb37: {\n        StorageDead(_48);\n        StorageDead(_45);\n        StorageLive(_51);\n        _51 = _11;\n        StorageLive(_52);\n        _52 = RangeFrom(1_usize);\n        _50 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(move _51, move _52) -> [return: bb40, unwind unreachable];\n    }\n    bb38: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_48);\n        StorageDead(_45);\n        StorageDead(_41);\n        goto -> bb54;\n    }\n    bb40: {\n        StorageDead(_52);\n        StorageDead(_51);\n        _11 = _50;\n        StorageDead(_41);\n        goto -> bb42;\n    }\n    bb41: {\n        StorageDead(_41);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageDead(_26);\n        goto -> bb20;\n    }\n    bb43: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_53);\n        _53 = <ascii::EscapeDefault as iter::traits::collect::IntoIterator>::into_iter(_14) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageLive(_54);\n        _54 = move _53;\n        goto -> bb45;\n    }\n    bb45: {\n        StorageLive(_55);\n        _56 = &mut _54;\n        _55 = <ascii::EscapeDefault as iter::traits::iterator::Iterator>::next(_56) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _57 = discriminant(_55);\n        switchInt(move _57) -> [0: bb48, 1: bb47, otherwise: bb12];\n    }\n    bb47: {\n        _58 = ((_55 as variant#1).0: u8);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = _58 as char;\n        _60 = <fmt::Formatter<'_> as fmt::Write>::write_char(_2, move _61) -> [return: bb49, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_53);\n        _0 = result::Result::Ok(());\n        StorageDead(_11);\n        goto -> bb56;\n    }\n    bb49: {\n        StorageDead(_61);\n        _59 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _60) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_60);\n        _62 = discriminant(_59);\n        switchInt(move _62) -> [0: bb51, 1: bb52, otherwise: bb12];\n    }\n    bb51: {\n        StorageDead(_59);\n        StorageDead(_55);\n        goto -> bb45;\n    }\n    bb52: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_59);\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_53);\n        goto -> bb55;\n    }\n    bb54: {\n        StorageDead(_26);\n        goto -> bb55;\n    }\n    bb55: {\n        StorageDead(_11);\n        goto -> bb56;\n    }\n    bb56: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}