{
  "name": "str::count::do_count_chars",
  "safe": true,
  "callees": {
    "str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::align_to": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transmutes the slice to a slice of another type, ensuring alignment of the types is\n maintained.\n\n This method splits the slice into three distinct slices: prefix, correctly aligned middle\n slice of a new type, and the suffix slice. The middle part will be as big as possible under\n the given alignment constraint and element size.\n\n This method has no purpose when either input element `T` or output element `U` are\n zero-sized and will return the original slice without splitting anything.\n\n # Safety\n\n This method is essentially a `transmute` with respect to the elements in the returned\n middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n\n # Examples\n\n Basic usage:\n\n ```\n unsafe {\n     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n     // less_efficient_algorithm_for_bytes(prefix);\n     // more_efficient_algorithm_for_aligned_shorts(shorts);\n     // less_efficient_algorithm_for_bytes(suffix);\n }\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "intrinsics::unlikely": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Hints to the compiler that branch condition is likely to be false.\n Returns the value passed to it.\n\n Any use other than with `if` statements will probably not have an effect.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n This intrinsic does not have a stable counterpart.\n",
      "adt": {}
    },
    "str::count::char_count_general_case": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "slice::<impl [T]>::chunks": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.\n\n The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n slice, then the last chunk will not have length `chunk_size`.\n\n See [`chunks_exact`] for a variant of this iterator that returns chunks of always exactly\n `chunk_size` elements, and [`rchunks`] for the same iterator but starting at the end of the\n slice.\n\n If your `chunk_size` is a constant, consider using [`as_chunks`] instead, which will\n give references to arrays of exactly that length, rather than slices.\n\n # Panics\n\n Panics if `chunk_size` is zero.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let mut iter = slice.chunks(2);\n assert_eq!(iter.next().unwrap(), &['l', 'o']);\n assert_eq!(iter.next().unwrap(), &['r', 'e']);\n assert_eq!(iter.next().unwrap(), &['m']);\n assert!(iter.next().is_none());\n ```\n\n [`chunks_exact`]: slice::chunks_exact\n [`rchunks`]: slice::rchunks\n [`as_chunks`]: slice::as_chunks\n",
      "adt": {
        "slice::iter::Chunks": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_chunks": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the slice into a slice of `N`-element arrays,\n starting at the beginning of the slice,\n and a remainder slice with length strictly less than `N`.\n\n The remainder is meaningful in the division sense.  Given\n `let (chunks, remainder) = slice.as_chunks()`, then:\n - `chunks.len()` equals `slice.len() / N`,\n - `remainder.len()` equals `slice.len() % N`, and\n - `slice.len()` equals `chunks.len() * N + remainder.len()`.\n\n You can flatten the chunks back into a slice-of-`T` with [`as_flattened`].\n\n [`as_flattened`]: slice::as_flattened\n\n # Panics\n\n Panics if `N` is zero.\n\n Note that this check is against a const generic parameter, not a runtime\n value, and thus a particular monomorphization will either always panic\n or it will never panic.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let (chunks, remainder) = slice.as_chunks();\n assert_eq!(chunks, &[['l', 'o'], ['r', 'e']]);\n assert_eq!(remainder, &['m']);\n ```\n\n If you expect the slice to be an exact multiple, you can combine\n `let`-`else` with an empty slice pattern:\n ```\n let slice = ['R', 'u', 's', 't'];\n let (chunks, []) = slice.as_chunks::<2>() else {\n     panic!(\"slice didn't have even length\")\n };\n assert_eq!(chunks, &[['R', 'u'], ['s', 't']]);\n ```\n",
      "adt": {}
    },
    "str::count::sum_bytes_in_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "str::count::contains_non_continuation_byte": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "slice::iter::Chunks": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14210, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 14235, kind: RigidTy(Slice(Ty { id: 47, kind: RigidTy(Uint(Usize)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14219, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 13608, kind: RigidTy(Array(Ty { id: 47, kind: RigidTy(Uint(Usize)) }, TyConst { kind: Value(Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(4), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(2, ThreadLocalIndex) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 976, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Not)) })])"
    ],
    "slice::iter::Iter": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::str::count::do_count_chars"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/count.rs:39:1: 108:2",
  "src": "fn do_count_chars(s: &str) -> usize {\n    // For correctness, `CHUNK_SIZE` must be:\n    //\n    // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n    // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n    //   `body.chunks(CHUNK_SIZE)` loop is incorrect.\n    //\n    // For performance, `CHUNK_SIZE` should be:\n    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n    // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n    //   too often.\n    const CHUNK_SIZE: usize = 192;\n\n    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n    // for correctness.\n    const _: () = assert!(CHUNK_SIZE < 256);\n    const _: () = assert!(CHUNK_SIZE.is_multiple_of(UNROLL_INNER));\n\n    // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n    // differences which are handled by `align_to`.\n    let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n\n    // This should be quite rare, and basically exists to handle the degenerate\n    // cases where align_to fails (as well as miri under symbolic alignment\n    // mode).\n    //\n    // The `unlikely` helps discourage LLVM from inlining the body, which is\n    // nice, as we would rather not mark the `char_count_general_case` function\n    // as cold.\n    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n        return char_count_general_case(s.as_bytes());\n    }\n\n    let mut total = char_count_general_case(head) + char_count_general_case(tail);\n    // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n    // we call `sum_bytes_in_usize`.\n    for chunk in body.chunks(CHUNK_SIZE) {\n        // We accumulate intermediate sums in `counts`, where each byte contains\n        // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n        let mut counts = 0;\n\n        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n        for unrolled in unrolled_chunks {\n            for &word in unrolled {\n                // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n                // count in any of the bytes to overflow into a subsequent byte.\n                counts += contains_non_continuation_byte(word);\n            }\n        }\n\n        // Sum the values in `counts` (which, again, is conceptually a `[u8;\n        // size_of::<usize>()]`), and accumulate the result into `total`.\n        total += sum_bytes_in_usize(counts);\n\n        // If there's any data in `remainder`, then handle it. This will only\n        // happen for the last `chunk` in `body.chunks()` (because `CHUNK_SIZE`\n        // is divisible by `UNROLL_INNER`), so we explicitly break at the end\n        // (which seems to help LLVM out).\n        if !remainder.is_empty() {\n            // Accumulate all the data in the remainder.\n            let mut counts = 0;\n            for &word in remainder {\n                counts += contains_non_continuation_byte(word);\n            }\n            total += sum_bytes_in_usize(counts);\n            break;\n        }\n    }\n    total\n}",
  "mir": "fn str::count::do_count_chars(_1: &str) -> usize {\n    let mut _0: usize;\n    let  _2: &[u8];\n    let  _3: &[usize];\n    let  _4: &[u8];\n    let mut _5: (&[u8], &[usize], &[u8]);\n    let  _6: &[u8];\n    let mut _7: bool;\n    let mut _8: bool;\n    let mut _9: bool;\n    let mut _10: bool;\n    let mut _11: usize;\n    let mut _12: usize;\n    let  _13: &[u8];\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: slice::iter::Chunks<'_, usize>;\n    let mut _19: slice::iter::Chunks<'_, usize>;\n    let mut _20: slice::iter::Chunks<'_, usize>;\n    let mut _21: option::Option<&[usize]>;\n    let mut _22: &mut slice::iter::Chunks<'_, usize>;\n    let mut _23: isize;\n    let  _24: &[usize];\n    let mut _25: usize;\n    let  _26: &[[usize; 4]];\n    let  _27: &[usize];\n    let mut _28: (&[[usize; 4]], &[usize]);\n    let mut _29: slice::iter::Iter<'_, [usize; 4]>;\n    let mut _30: slice::iter::Iter<'_, [usize; 4]>;\n    let mut _31: option::Option<&[usize; 4]>;\n    let mut _32: &mut slice::iter::Iter<'_, [usize; 4]>;\n    let mut _33: isize;\n    let  _34: &[usize; 4];\n    let mut _35: slice::iter::Iter<'_, usize>;\n    let mut _36: slice::iter::Iter<'_, usize>;\n    let mut _37: option::Option<&usize>;\n    let mut _38: &mut slice::iter::Iter<'_, usize>;\n    let mut _39: isize;\n    let  _40: usize;\n    let mut _41: usize;\n    let mut _42: (usize, bool);\n    let mut _43: usize;\n    let mut _44: usize;\n    let mut _45: (usize, bool);\n    let mut _46: bool;\n    let mut _47: usize;\n    let mut _48: slice::iter::Iter<'_, usize>;\n    let mut _49: slice::iter::Iter<'_, usize>;\n    let mut _50: option::Option<&usize>;\n    let mut _51: &mut slice::iter::Iter<'_, usize>;\n    let mut _52: isize;\n    let  _53: usize;\n    let mut _54: usize;\n    let mut _55: (usize, bool);\n    let mut _56: usize;\n    let mut _57: usize;\n    let mut _58: (usize, bool);\n    let mut _59: &usize;\n    let mut _60: &usize;\n    debug s => _1;\n    debug head => _2;\n    debug body => _3;\n    debug tail => _4;\n    debug total => _14;\n    debug iter => _20;\n    debug chunk => _24;\n    debug counts => _25;\n    debug unrolled_chunks => _26;\n    debug remainder => _27;\n    debug iter => _30;\n    debug unrolled => _34;\n    debug iter => _36;\n    debug word => _40;\n    debug counts => _47;\n    debug iter => _49;\n    debug word => _53;\n    bb0: {\n        StorageLive(_5);\n        _6 = str::<impl str>::as_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = slice::<impl [u8]>::align_to::<usize>(_6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _2 = (_5.0: &[u8]);\n        _3 = (_5.1: &[usize]);\n        _4 = (_5.2: &[u8]);\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = slice::<impl [usize]>::is_empty(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _9) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        goto -> bb7;\n    }\n    bb5: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = PtrMetadata(_2);\n        _10 = Gt(move _11, str::count::USIZE_SIZE);\n        switchInt(move _10) -> [0: bb8, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_11);\n        goto -> bb7;\n    }\n    bb7: {\n        _8 = true;\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageLive(_12);\n        _12 = PtrMetadata(_4);\n        _8 = Gt(move _12, str::count::USIZE_SIZE);\n        StorageDead(_12);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageDead(_9);\n        _7 = intrinsics::unlikely(move _8) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _7) -> [0: bb14, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_8);\n        _13 = str::<impl str>::as_bytes(_1) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _0 = str::count::char_count_general_case(_13) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_7);\n        goto -> bb52;\n    }\n    bb14: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = str::count::char_count_general_case(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_16);\n        _16 = str::count::char_count_general_case(_4) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _17 = CheckedAdd(_15, _16);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _15, move _16) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _14 = move (_17.0: usize);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = slice::<impl [usize]>::chunks(_3, str::count::do_count_chars::CHUNK_SIZE) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _18 = <slice::iter::Chunks<'_, usize> as iter::traits::collect::IntoIterator>::into_iter(move _19) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = move _18;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_21);\n        _22 = &mut _20;\n        _21 = <slice::iter::Chunks<'_, usize> as iter::traits::iterator::Iterator>::next(_22) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _23 = discriminant(_21);\n        switchInt(move _23) -> [0: bb51, 1: bb23, otherwise: bb22];\n    }\n    bb22: {\n        unreachable;\n    }\n    bb23: {\n        _24 = ((_21 as variant#1).0: &[usize]);\n        StorageLive(_25);\n        _25 = 0_usize;\n        StorageLive(_28);\n        _28 = slice::<impl [usize]>::as_chunks::<4>(_24) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _26 = (_28.0: &[[usize; 4]]);\n        _27 = (_28.1: &[usize]);\n        StorageDead(_28);\n        StorageLive(_29);\n        _29 = <&[[usize; 4]] as iter::traits::collect::IntoIterator>::into_iter(_26) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageLive(_30);\n        _30 = move _29;\n        goto -> bb26;\n    }\n    bb26: {\n        StorageLive(_31);\n        _32 = &mut _30;\n        _31 = <slice::iter::Iter<'_, [usize; 4]> as iter::traits::iterator::Iterator>::next(_32) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _33 = discriminant(_31);\n        switchInt(move _33) -> [0: bb29, 1: bb28, otherwise: bb22];\n    }\n    bb28: {\n        _34 = ((_31 as variant#1).0: &[usize; 4]);\n        StorageLive(_35);\n        _35 = <&[usize; 4] as iter::traits::collect::IntoIterator>::into_iter(_34) -> [return: bb30, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = _25;\n        _43 = str::count::sum_bytes_in_usize(move _44) -> [return: bb37, unwind unreachable];\n    }\n    bb30: {\n        StorageLive(_36);\n        _36 = move _35;\n        goto -> bb31;\n    }\n    bb31: {\n        StorageLive(_37);\n        _38 = &mut _36;\n        _37 = <slice::iter::Iter<'_, usize> as iter::traits::iterator::Iterator>::next(_38) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _39 = discriminant(_37);\n        switchInt(move _39) -> [0: bb34, 1: bb33, otherwise: bb22];\n    }\n    bb33: {\n        _59 = ((_37 as variant#1).0: &usize);\n        _40 = (*_59);\n        StorageLive(_41);\n        _41 = str::count::contains_non_continuation_byte(_40) -> [return: bb35, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_31);\n        goto -> bb26;\n    }\n    bb35: {\n        _42 = CheckedAdd(_25, _41);\n        assert(!move (_42.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, move _41) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _25 = move (_42.0: usize);\n        StorageDead(_41);\n        StorageDead(_37);\n        goto -> bb31;\n    }\n    bb37: {\n        StorageDead(_44);\n        _45 = CheckedAdd(_14, _43);\n        assert(!move (_45.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, move _43) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        _14 = move (_45.0: usize);\n        StorageDead(_43);\n        StorageLive(_46);\n        _46 = slice::<impl [usize]>::is_empty(_27) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        switchInt(move _46) -> [0: bb41, otherwise: bb40];\n    }\n    bb40: {\n        StorageDead(_46);\n        StorageDead(_25);\n        StorageDead(_21);\n        goto -> bb20;\n    }\n    bb41: {\n        StorageLive(_47);\n        _47 = 0_usize;\n        StorageLive(_48);\n        _48 = <&[usize] as iter::traits::collect::IntoIterator>::into_iter(_27) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageLive(_49);\n        _49 = move _48;\n        goto -> bb43;\n    }\n    bb43: {\n        StorageLive(_50);\n        _51 = &mut _49;\n        _50 = <slice::iter::Iter<'_, usize> as iter::traits::iterator::Iterator>::next(_51) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _52 = discriminant(_50);\n        switchInt(move _52) -> [0: bb46, 1: bb45, otherwise: bb22];\n    }\n    bb45: {\n        _60 = ((_50 as variant#1).0: &usize);\n        _53 = (*_60);\n        StorageLive(_54);\n        _54 = str::count::contains_non_continuation_byte(_53) -> [return: bb47, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_50);\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = _47;\n        _56 = str::count::sum_bytes_in_usize(move _57) -> [return: bb49, unwind unreachable];\n    }\n    bb47: {\n        _55 = CheckedAdd(_47, _54);\n        assert(!move (_55.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _47, move _54) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _47 = move (_55.0: usize);\n        StorageDead(_54);\n        StorageDead(_50);\n        goto -> bb43;\n    }\n    bb49: {\n        StorageDead(_57);\n        _58 = CheckedAdd(_14, _56);\n        assert(!move (_58.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, move _56) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _14 = move (_58.0: usize);\n        StorageDead(_56);\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageDead(_25);\n        goto -> bb51;\n    }\n    bb51: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_18);\n        _0 = _14;\n        StorageDead(_14);\n        goto -> bb52;\n    }\n    bb52: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}