{
  "name": "slice::sort::select::ninther",
  "safe": true,
  "callees": {
    "slice::sort::select::median_idx": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " returns the index pointing to the median of the 3\n elements `v[a]`, `v[b]` and `v[c]`\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "mem::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps the values at two mutable locations, without deinitializing either one.\n\n * If you want to swap with a default or dummy value, see [`take`].\n * If you want to swap with a passed value, returning the old value, see [`replace`].\n\n # Examples\n\n ```\n use std::mem;\n\n let mut x = 5;\n let mut y = 42;\n\n mem::swap(&mut x, &mut y);\n\n assert_eq!(42, x);\n assert_eq!(5, y);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps two elements in the slice.\n\n If `a` equals to `b`, it's guaranteed that elements won't change value.\n\n # Arguments\n\n * a - The index of the first element\n * b - The index of the second element\n\n # Panics\n\n Panics if `a` or `b` are out of bounds.\n\n # Examples\n\n ```\n let mut v = [\"a\", \"b\", \"c\", \"d\", \"e\"];\n v.swap(2, 4);\n assert!(v == [\"a\", \"b\", \"e\", \"d\", \"c\"]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::sort::select::ninther"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/select.rs:249:1: 289:2",
  "src": "fn ninther<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    is_less: &mut F,\n    a: usize,\n    mut b: usize,\n    c: usize,\n    mut d: usize,\n    e: usize,\n    mut f: usize,\n    g: usize,\n    mut h: usize,\n    i: usize,\n) {\n    b = median_idx(v, is_less, a, b, c);\n    h = median_idx(v, is_less, g, h, i);\n    if is_less(&v[h], &v[b]) {\n        mem::swap(&mut b, &mut h);\n    }\n    if is_less(&v[f], &v[d]) {\n        mem::swap(&mut d, &mut f);\n    }\n    if is_less(&v[e], &v[d]) {\n        // do nothing\n    } else if is_less(&v[f], &v[e]) {\n        d = f;\n    } else {\n        if is_less(&v[e], &v[b]) {\n            v.swap(e, b);\n        } else if is_less(&v[h], &v[e]) {\n            v.swap(e, h);\n        }\n        return;\n    }\n    if is_less(&v[d], &v[b]) {\n        d = b;\n    } else if is_less(&v[h], &v[d]) {\n        d = h;\n    }\n\n    v.swap(d, e);\n}",
  "mir": "fn slice::sort::select::ninther(_1: &mut [T], _2: &mut F, _3: usize, _4: usize, _5: usize, _6: usize, _7: usize, _8: usize, _9: usize, _10: usize, _11: usize) -> () {\n    let mut _0: ();\n    let mut _12: usize;\n    let mut _13: &[T];\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: &[T];\n    let mut _17: usize;\n    let mut _18: bool;\n    let mut _19: (&T, &T);\n    let  _20: &T;\n    let  _21: usize;\n    let mut _22: *const [T];\n    let mut _23: usize;\n    let mut _24: bool;\n    let  _25: &T;\n    let  _26: usize;\n    let mut _27: *const [T];\n    let mut _28: usize;\n    let mut _29: bool;\n    let  _30: ();\n    let mut _31: &mut usize;\n    let mut _32: &mut usize;\n    let mut _33: bool;\n    let mut _34: (&T, &T);\n    let  _35: &T;\n    let  _36: usize;\n    let mut _37: *const [T];\n    let mut _38: usize;\n    let mut _39: bool;\n    let  _40: &T;\n    let  _41: usize;\n    let mut _42: *const [T];\n    let mut _43: usize;\n    let mut _44: bool;\n    let  _45: ();\n    let mut _46: &mut usize;\n    let mut _47: &mut usize;\n    let mut _48: bool;\n    let mut _49: (&T, &T);\n    let  _50: &T;\n    let mut _51: *const [T];\n    let mut _52: usize;\n    let mut _53: bool;\n    let  _54: &T;\n    let  _55: usize;\n    let mut _56: *const [T];\n    let mut _57: usize;\n    let mut _58: bool;\n    let mut _59: bool;\n    let mut _60: (&T, &T);\n    let  _61: &T;\n    let  _62: usize;\n    let mut _63: *const [T];\n    let mut _64: usize;\n    let mut _65: bool;\n    let  _66: &T;\n    let mut _67: *const [T];\n    let mut _68: usize;\n    let mut _69: bool;\n    let mut _70: usize;\n    let mut _71: bool;\n    let mut _72: (&T, &T);\n    let  _73: &T;\n    let mut _74: *const [T];\n    let mut _75: usize;\n    let mut _76: bool;\n    let  _77: &T;\n    let  _78: usize;\n    let mut _79: *const [T];\n    let mut _80: usize;\n    let mut _81: bool;\n    let  _82: ();\n    let mut _83: usize;\n    let mut _84: bool;\n    let mut _85: (&T, &T);\n    let  _86: &T;\n    let  _87: usize;\n    let mut _88: *const [T];\n    let mut _89: usize;\n    let mut _90: bool;\n    let  _91: &T;\n    let mut _92: *const [T];\n    let mut _93: usize;\n    let mut _94: bool;\n    let  _95: ();\n    let mut _96: usize;\n    let mut _97: bool;\n    let mut _98: (&T, &T);\n    let  _99: &T;\n    let  _100: usize;\n    let mut _101: *const [T];\n    let mut _102: usize;\n    let mut _103: bool;\n    let  _104: &T;\n    let  _105: usize;\n    let mut _106: *const [T];\n    let mut _107: usize;\n    let mut _108: bool;\n    let mut _109: usize;\n    let mut _110: bool;\n    let mut _111: (&T, &T);\n    let  _112: &T;\n    let  _113: usize;\n    let mut _114: *const [T];\n    let mut _115: usize;\n    let mut _116: bool;\n    let  _117: &T;\n    let  _118: usize;\n    let mut _119: *const [T];\n    let mut _120: usize;\n    let mut _121: bool;\n    let mut _122: usize;\n    let  _123: ();\n    let mut _124: usize;\n    debug v => _1;\n    debug is_less => _2;\n    debug a => _3;\n    debug b => _4;\n    debug c => _5;\n    debug d => _6;\n    debug e => _7;\n    debug f => _8;\n    debug g => _9;\n    debug h => _10;\n    debug i => _11;\n    bb0: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &(*_1);\n        StorageLive(_14);\n        _14 = _4;\n        _12 = slice::sort::select::median_idx::<T, F>(move _13, _2, _3, move _14, _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _4 = move _12;\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &(*_1);\n        StorageLive(_17);\n        _17 = _10;\n        _15 = slice::sort::select::median_idx::<T, F>(move _16, _2, _9, move _17, _11) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _10 = move _15;\n        StorageDead(_15);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_21);\n        _21 = _10;\n        _22 = &raw const (fake) (*_1);\n        _23 = PtrMetadata(move _22);\n        _24 = Lt(_21, _23);\n        assert(move _24, \"index out of bounds: the length is {} but the index is {}\", move _23, _21) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _20 = &(*_1)[_21];\n        StorageLive(_26);\n        _26 = _4;\n        _27 = &raw const (fake) (*_1);\n        _28 = PtrMetadata(move _27);\n        _29 = Lt(_26, _28);\n        assert(move _29, \"index out of bounds: the length is {} but the index is {}\", move _28, _26) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _25 = &(*_1)[_26];\n        _19 = (_20, _25);\n        _18 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _19) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _18) -> [0: bb8, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_26);\n        StorageDead(_21);\n        StorageDead(_19);\n        _31 = &mut _4;\n        _32 = &mut _10;\n        _30 = mem::swap::<usize>(_31, _32) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_26);\n        StorageDead(_21);\n        StorageDead(_19);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_36);\n        _36 = _8;\n        _37 = &raw const (fake) (*_1);\n        _38 = PtrMetadata(move _37);\n        _39 = Lt(_36, _38);\n        assert(move _39, \"index out of bounds: the length is {} but the index is {}\", move _38, _36) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _35 = &(*_1)[_36];\n        StorageLive(_41);\n        _41 = _6;\n        _42 = &raw const (fake) (*_1);\n        _43 = PtrMetadata(move _42);\n        _44 = Lt(_41, _43);\n        assert(move _44, \"index out of bounds: the length is {} but the index is {}\", move _43, _41) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _40 = &(*_1)[_41];\n        _34 = (_35, _40);\n        _33 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _34) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _33) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_41);\n        StorageDead(_36);\n        StorageDead(_34);\n        _46 = &mut _6;\n        _47 = &mut _8;\n        _45 = mem::swap::<usize>(_46, _47) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        goto -> bb16;\n    }\n    bb15: {\n        StorageDead(_41);\n        StorageDead(_36);\n        StorageDead(_34);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_33);\n        StorageLive(_48);\n        StorageLive(_49);\n        _51 = &raw const (fake) (*_1);\n        _52 = PtrMetadata(move _51);\n        _53 = Lt(_7, _52);\n        assert(move _53, \"index out of bounds: the length is {} but the index is {}\", move _52, _7) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _50 = &(*_1)[_7];\n        StorageLive(_55);\n        _55 = _6;\n        _56 = &raw const (fake) (*_1);\n        _57 = PtrMetadata(move _56);\n        _58 = Lt(_55, _57);\n        assert(move _58, \"index out of bounds: the length is {} but the index is {}\", move _57, _55) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _54 = &(*_1)[_55];\n        _49 = (_50, _54);\n        _48 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _49) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        switchInt(move _48) -> [0: bb21, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_55);\n        StorageDead(_49);\n        goto -> bb41;\n    }\n    bb21: {\n        StorageDead(_55);\n        StorageDead(_49);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_62);\n        _62 = _8;\n        _63 = &raw const (fake) (*_1);\n        _64 = PtrMetadata(move _63);\n        _65 = Lt(_62, _64);\n        assert(move _65, \"index out of bounds: the length is {} but the index is {}\", move _64, _62) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _61 = &(*_1)[_62];\n        _67 = &raw const (fake) (*_1);\n        _68 = PtrMetadata(move _67);\n        _69 = Lt(_7, _68);\n        assert(move _69, \"index out of bounds: the length is {} but the index is {}\", move _68, _7) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _66 = &(*_1)[_7];\n        _60 = (_61, _66);\n        _59 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _60) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        switchInt(move _59) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_62);\n        StorageDead(_60);\n        StorageLive(_70);\n        _70 = _8;\n        _6 = move _70;\n        StorageDead(_70);\n        StorageDead(_59);\n        goto -> bb41;\n    }\n    bb26: {\n        StorageDead(_62);\n        StorageDead(_60);\n        StorageLive(_71);\n        StorageLive(_72);\n        _74 = &raw const (fake) (*_1);\n        _75 = PtrMetadata(move _74);\n        _76 = Lt(_7, _75);\n        assert(move _76, \"index out of bounds: the length is {} but the index is {}\", move _75, _7) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _73 = &(*_1)[_7];\n        StorageLive(_78);\n        _78 = _4;\n        _79 = &raw const (fake) (*_1);\n        _80 = PtrMetadata(move _79);\n        _81 = Lt(_78, _80);\n        assert(move _81, \"index out of bounds: the length is {} but the index is {}\", move _80, _78) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _77 = &(*_1)[_78];\n        _72 = (_73, _77);\n        _71 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _72) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        switchInt(move _71) -> [0: bb32, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_78);\n        StorageDead(_72);\n        StorageLive(_83);\n        _83 = _4;\n        _82 = slice::<impl [T]>::swap(_1, _7, move _83) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_83);\n        goto -> bb40;\n    }\n    bb32: {\n        StorageDead(_78);\n        StorageDead(_72);\n        StorageLive(_84);\n        StorageLive(_85);\n        StorageLive(_87);\n        _87 = _10;\n        _88 = &raw const (fake) (*_1);\n        _89 = PtrMetadata(move _88);\n        _90 = Lt(_87, _89);\n        assert(move _90, \"index out of bounds: the length is {} but the index is {}\", move _89, _87) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _86 = &(*_1)[_87];\n        _92 = &raw const (fake) (*_1);\n        _93 = PtrMetadata(move _92);\n        _94 = Lt(_7, _93);\n        assert(move _94, \"index out of bounds: the length is {} but the index is {}\", move _93, _7) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _91 = &(*_1)[_7];\n        _85 = (_86, _91);\n        _84 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _85) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        switchInt(move _84) -> [0: bb38, otherwise: bb36];\n    }\n    bb36: {\n        StorageDead(_87);\n        StorageDead(_85);\n        StorageLive(_96);\n        _96 = _10;\n        _95 = slice::<impl [T]>::swap(_1, _7, move _96) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_96);\n        goto -> bb39;\n    }\n    bb38: {\n        StorageDead(_87);\n        StorageDead(_85);\n        goto -> bb39;\n    }\n    bb39: {\n        StorageDead(_84);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageDead(_71);\n        StorageDead(_59);\n        StorageDead(_48);\n        goto -> bb55;\n    }\n    bb41: {\n        StorageDead(_48);\n        StorageLive(_97);\n        StorageLive(_98);\n        StorageLive(_100);\n        _100 = _6;\n        _101 = &raw const (fake) (*_1);\n        _102 = PtrMetadata(move _101);\n        _103 = Lt(_100, _102);\n        assert(move _103, \"index out of bounds: the length is {} but the index is {}\", move _102, _100) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _99 = &(*_1)[_100];\n        StorageLive(_105);\n        _105 = _4;\n        _106 = &raw const (fake) (*_1);\n        _107 = PtrMetadata(move _106);\n        _108 = Lt(_105, _107);\n        assert(move _108, \"index out of bounds: the length is {} but the index is {}\", move _107, _105) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _104 = &(*_1)[_105];\n        _98 = (_99, _104);\n        _97 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _98) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        switchInt(move _97) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_105);\n        StorageDead(_100);\n        StorageDead(_98);\n        StorageLive(_109);\n        _109 = _4;\n        _6 = move _109;\n        StorageDead(_109);\n        goto -> bb53;\n    }\n    bb46: {\n        StorageDead(_105);\n        StorageDead(_100);\n        StorageDead(_98);\n        StorageLive(_110);\n        StorageLive(_111);\n        StorageLive(_113);\n        _113 = _10;\n        _114 = &raw const (fake) (*_1);\n        _115 = PtrMetadata(move _114);\n        _116 = Lt(_113, _115);\n        assert(move _116, \"index out of bounds: the length is {} but the index is {}\", move _115, _113) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _112 = &(*_1)[_113];\n        StorageLive(_118);\n        _118 = _6;\n        _119 = &raw const (fake) (*_1);\n        _120 = PtrMetadata(move _119);\n        _121 = Lt(_118, _120);\n        assert(move _121, \"index out of bounds: the length is {} but the index is {}\", move _120, _118) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _117 = &(*_1)[_118];\n        _111 = (_112, _117);\n        _110 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_2, move _111) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        switchInt(move _110) -> [0: bb51, otherwise: bb50];\n    }\n    bb50: {\n        StorageDead(_118);\n        StorageDead(_113);\n        StorageDead(_111);\n        StorageLive(_122);\n        _122 = _10;\n        _6 = move _122;\n        StorageDead(_122);\n        goto -> bb52;\n    }\n    bb51: {\n        StorageDead(_118);\n        StorageDead(_113);\n        StorageDead(_111);\n        goto -> bb52;\n    }\n    bb52: {\n        StorageDead(_110);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_97);\n        StorageLive(_124);\n        _124 = _6;\n        _123 = slice::<impl [T]>::swap(_1, move _124, _7) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_124);\n        goto -> bb55;\n    }\n    bb55: {\n        return;\n    }\n}\n",
  "doc": " Moves around the 9 elements at the indices a..i, such that\n `v[d]` contains the median of the 9 elements and the other\n elements are partitioned around it.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}