{
  "name": "slice::<impl [T]>::as_mut_array",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a pointer-to-`T` to a pointer-to-`[T; N]`.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::as_mut_array"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:868:5: 878:6",
  "src": "pub const fn as_mut_array<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n        if self.len() == N {\n            let ptr = self.as_mut_ptr().cast_array();\n\n            // SAFETY: The underlying array of a slice can be reinterpreted as an actual array `[T; N]` if `N` is not greater than the slice's length.\n            let me = unsafe { &mut *ptr };\n            Some(me)\n        } else {\n            None\n        }\n    }",
  "mir": "fn slice::<impl [T]>::as_mut_array(_1: &mut [T]) -> option::Option<&mut [T; N]> {\n    let mut _0: option::Option<&mut [T; N]>;\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: &[T];\n    let  _5: *mut [T; N];\n    let mut _6: *mut T;\n    let mut _7: &mut [T; N];\n    debug self => _1;\n    debug ptr => _5;\n    debug me => _7;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        _2 = Eq(move _3, N);\n        switchInt(move _2) -> [0: bb4, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = ptr::mut_ptr::<impl *mut T>::cast_array::<N>(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _7 = &mut (*_5);\n        _0 = option::Option::Some(_7);\n        StorageDead(_5);\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = option::Option::None;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Gets a mutable reference to the slice's underlying array.\n\n If `N` is not exactly equal to the length of `self`, then this method returns `None`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}