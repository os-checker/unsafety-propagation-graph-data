{
  "name": "core_arch::x86::avx512fp16::_mm_storeu_ph",
  "safe": false,
  "callees": {
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::write_unaligned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Overwrites a memory location with the given value without reading or\n dropping the old value.\n\n Unlike [`write()`], the pointer may be unaligned.\n\n `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n could leak allocations or resources, so care should be taken not to overwrite\n an object that should be dropped.\n\n Additionally, it does not drop `src`. Semantically, `src` is moved into the\n location pointed to by `dst`.\n\n This is appropriate for initializing uninitialized memory, or overwriting\n memory that has previously been read with [`read_unaligned`].\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be [valid] for writes.\n\n [valid]: self#safety\n\n ## On `packed` structs\n\n Attempting to create a raw pointer to an `unaligned` struct field with\n an expression such as `&packed.unaligned as *const FieldType` creates an\n intermediate unaligned reference before converting that to a raw pointer.\n That this reference is temporary and immediately cast is inconsequential\n as the compiler always expects references to be properly aligned.\n As a result, using `&packed.unaligned as *const FieldType` causes immediate\n *undefined behavior* in your program.\n\n Instead, you must use the `&raw mut` syntax to create the pointer.\n You may use that constructed pointer together with this function.\n\n An example of how to do it and how this relates to `write_unaligned` is:\n\n ```\n #[repr(packed, C)]\n struct Packed {\n     _padding: u8,\n     unaligned: u32,\n }\n\n let mut packed: Packed = unsafe { std::mem::zeroed() };\n\n // Take the address of a 32-bit integer which is not aligned.\n // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.\n let unaligned = &raw mut packed.unaligned;\n\n unsafe { std::ptr::write_unaligned(unaligned, 42) };\n\n assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.\n ```\n\n Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however\n (as can be seen in the `assert_eq!` above).\n\n # Examples\n\n Write a `usize` value to a byte buffer:\n\n ```\n fn write_usize(x: &mut [u8], val: usize) {\n     assert!(x.len() >= size_of::<usize>());\n\n     let ptr = x.as_mut_ptr() as *mut usize;\n\n     unsafe { ptr.write_unaligned(val) }\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128h": [
      "Plain"
    ]
  },
  "path": 11080,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:1310:1: 1312:2",
  "src": "pub unsafe fn _mm_storeu_ph(mem_addr: *mut f16, a: __m128h) {\n    ptr::write_unaligned(mem_addr.cast(), a);\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm_storeu_ph(_1: *mut f16, _2: core_arch::x86::__m128h) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: *mut core_arch::x86::__m128h;\n    debug mem_addr => _1;\n    debug a => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = ptr::mut_ptr::<impl *mut f16>::cast::<core_arch::x86::__m128h>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = ptr::write_unaligned::<core_arch::x86::__m128h>(move _4, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Store 128-bits (composed of 8 packed half-precision (16-bit) floating-point elements) from a into memory.\n The address does not need to be aligned to any particular boundary.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_ph)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}