{
  "name": "core_simd::vector::Simd::<T, N>::from_slice",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::load": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a vector from an array of `T`.\n\n This function is necessary since `repr(simd)` has padding for non-power-of-2 vectors (at the time of writing).\n With padding, `read_unaligned` will read past the end of an array of N elements.\n\n # Safety\n Reading `ptr` must be safe, as if by `<*const [T; N]>::read`.\n",
      "adt": {
        "core_simd::vector::Simd": "Constructor"
      }
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ],
    "core_simd::vector::Simd": [
      "Plain"
    ]
  },
  "path": 12667,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:297:5: 305:6",
  "src": "pub const fn from_slice(slice: &[T]) -> Self {\n        assert!(\n            slice.len() >= Self::LEN,\n            \"slice length must be at least the number of elements\"\n        );\n        // SAFETY: We just checked that the slice contains\n        // at least `N` elements.\n        unsafe { Self::load(slice.as_ptr().cast()) }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::from_slice(_1: &[T]) -> core_simd::vector::Simd<T, N> {\n    let mut _0: core_simd::vector::Simd<T, N>;\n    let mut _2: bool;\n    let mut _3: usize;\n    let  _4: !;\n    let mut _5: fmt::Arguments<'_>;\n    let mut _6: *const [T; N];\n    let mut _7: *const T;\n    debug slice => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        _2 = Ge(move _3, core_simd::vector::Simd::<T, N>::LEN);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = slice::<impl [T]>::as_ptr(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = fmt::Arguments::<'_>::from_str(\"slice length must be at least the number of elements\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = panicking::panic_fmt(move _5) -> unwind unreachable;\n    }\n    bb4: {\n        _6 = ptr::const_ptr::<impl *const T>::cast::<[T; N]>(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _0 = core_simd::vector::Simd::<T, N>::load(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Converts a slice to a SIMD vector containing `slice[..N]`.\n\n # Panics\n\n Panics if the slice's length is less than the vector's `Simd::N`.\n Use `load_or_default` for an alternative that does not panic.\n\n # Example\n\n ```\n # #![feature(portable_simd)]\n # use core::simd::u32x4;\n let source = vec![1, 2, 3, 4, 5, 6];\n let v = u32x4::from_slice(&source);\n assert_eq!(v.as_array(), &[1, 2, 3, 4]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}