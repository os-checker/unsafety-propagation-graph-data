{
  "name": "num::<impl usize>::wrapping_rem_euclid",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": 4424,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:2561:9: 2563:10",
  "src": "pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }",
  "mir": "fn num::<impl usize>::wrapping_rem_euclid(_1: usize, _2: usize) -> usize {\n    let mut _0: usize;\n    let mut _3: bool;\n    debug self => _1;\n    debug rhs => _2;\n    bb0: {\n        _3 = Eq(_2, 0_usize);\n        assert(!move _3, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Rem(_1, _2);\n        return;\n    }\n}\n",
  "doc": " Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n\n Wrapped modulo calculation on unsigned types is just the regular\n remainder calculation. There's no way wrapping could ever happen.\n This function exists so that all operations are accounted for in the\n wrapping operations. Since, for the positive integers, all common\n definitions of division are equal, this is exactly equal to\n `self.wrapping_rem(rhs)`.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}