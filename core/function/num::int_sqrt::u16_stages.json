{
  "name": "num::int_sqrt::u16_stages",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "num::<impl u16>::overflowing_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the multiplication of `self` and `rhs`.\n\n Returns a tuple of the multiplication along with a boolean\n indicating whether an arithmetic overflow would occur. If an\n overflow would have occurred then the wrapped value is returned.\n\n If you want the *value* of the overflow, rather than just *whether*\n an overflow occurred, see [`Self::carrying_mul`].\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u32` is used.\n\n ```\n assert_eq!(5u32.overflowing_mul(2), (10, false));\n assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 14924,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_sqrt.rs:258:1: 261:2",
  "src": "const fn u16_stages(n: u16) -> u16 {\n    let (s, r) = first_stage!(16, n);\n    last_stage!(u16, n, s, r)\n}",
  "mir": "fn num::int_sqrt::u16_stages(_1: u16) -> u16 {\n    let mut _0: u16;\n    let  _2: u8;\n    let  _3: u8;\n    let mut _4: (u8, u8);\n    let  _5: !;\n    let mut _6: fmt::Arguments<'_>;\n    let  _7: u16;\n    let mut _8: bool;\n    let  _9: u8;\n    let  _10: u8;\n    let mut _11: [(u8, u8); 256];\n    let  _12: usize;\n    let mut _13: bool;\n    let  _14: ();\n    let mut _15: bool;\n    let  _16: !;\n    let mut _17: fmt::Arguments<'_>;\n    let  _18: u16;\n    let  _19: u16;\n    let mut _20: u16;\n    let mut _21: u16;\n    let mut _22: bool;\n    let mut _23: u16;\n    let mut _24: bool;\n    let  _25: u16;\n    let mut _26: u16;\n    let mut _27: u32;\n    let mut _28: bool;\n    let  _29: u16;\n    let mut _30: bool;\n    let mut _31: u16;\n    let mut _32: u16;\n    let mut _33: u8;\n    let mut _34: bool;\n    let mut _35: (u16, bool);\n    let  _36: u16;\n    let  _37: bool;\n    let mut _38: (u16, bool);\n    let mut _39: u16;\n    let mut _40: u16;\n    let mut _41: bool;\n    let mut _42: (u16, bool);\n    debug n => _1;\n    debug s => _2;\n    debug r => _3;\n    debug n => _7;\n    debug s => _9;\n    debug r => _10;\n    debug lo => _18;\n    debug numerator => _19;\n    debug denominator => _25;\n    debug q => _29;\n    debug s => _31;\n    debug s_squared => _36;\n    debug overflow => _37;\n    bb0: {\n        StorageLive(_4);\n        switchInt(_1) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _8 = Lt(num::int_sqrt::u16_stages::N_SHIFT, 16_u32);\n        assert(move _8, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u16_stages::N_SHIFT) -> [success: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = fmt::Arguments::<'_>::from_str(\"`$n` is  zero in `first_stage!`.\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n    bb4: {\n        _7 = Shr(_1, num::int_sqrt::u16_stages::N_SHIFT);\n        StorageLive(_11);\n        _11 = num::int_sqrt::U8_ISQRT_WITH_REMAINDER;\n        StorageLive(_12);\n        _12 = _7 as usize;\n        _13 = Lt(_12, 256_usize);\n        assert(move _13, \"index out of bounds: the length is {} but the index is {}\", 256_usize, _12) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = (_11[_12].0: u8);\n        _10 = (_11[_12].1: u8);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = Ne(_9, 0_u8);\n        _14 = hint::assert_unchecked(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _4 = (_9, _10);\n        _2 = (_4.0: u8);\n        _3 = (_4.1: u8);\n        StorageDead(_4);\n        switchInt(_2) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        _18 = BitAnd(_1, num::int_sqrt::u16_stages::LOWER_HALF_1_BITS);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _3 as u16;\n        _22 = Lt(num::int_sqrt::u16_stages::QUARTER_BITS, 16_u32);\n        assert(move _22, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u16_stages::QUARTER_BITS) -> [success: bb10, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_17);\n        _17 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `last_stage!`.\") -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _16 = panicking::panic_fmt(move _17) -> unwind unreachable;\n    }\n    bb10: {\n        _20 = Shl(move _21, num::int_sqrt::u16_stages::QUARTER_BITS);\n        StorageDead(_21);\n        StorageLive(_23);\n        _24 = Lt(num::int_sqrt::u16_stages::QUARTER_BITS, 16_u32);\n        assert(move _24, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u16_stages::QUARTER_BITS) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _23 = Shr(_18, num::int_sqrt::u16_stages::QUARTER_BITS);\n        _19 = BitOr(move _20, move _23);\n        StorageDead(_23);\n        StorageDead(_20);\n        StorageLive(_26);\n        _26 = _2 as u16;\n        _27 = 1_i32 as u32;\n        _28 = Lt(move _27, 16_u32);\n        assert(move _28, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _25 = Shl(move _26, 1_i32);\n        StorageDead(_26);\n        _30 = Eq(_25, 0_u16);\n        assert(!move _30, \"attempt to divide `{}` by zero\", _19) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _29 = Div(_19, _25);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _34 = Lt(num::int_sqrt::u16_stages::QUARTER_BITS, 8_u32);\n        assert(move _34, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u16_stages::QUARTER_BITS) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _33 = Shl(_2, num::int_sqrt::u16_stages::QUARTER_BITS);\n        _32 = move _33 as u16;\n        StorageDead(_33);\n        _35 = CheckedAdd(_32, _29);\n        assert(!move (_35.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _32, _29) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _31 = move (_35.0: u16);\n        StorageDead(_32);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = _31;\n        StorageLive(_40);\n        _40 = _31;\n        _38 = num::<impl u16>::overflowing_mul(move _39, move _40) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_40);\n        StorageDead(_39);\n        _36 = (_38.0: u16);\n        _37 = (_38.1: bool);\n        StorageDead(_38);\n        switchInt(_37) -> [0: bb17, otherwise: bb19];\n    }\n    bb17: {\n        StorageLive(_41);\n        _41 = Gt(_36, _1);\n        switchInt(move _41) -> [0: bb21, otherwise: bb18];\n    }\n    bb18: {\n        goto -> bb19;\n    }\n    bb19: {\n        _42 = CheckedSub(_31, 1_u16);\n        assert(!move (_42.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _31, 1_u16) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _31 = move (_42.0: u16);\n        goto -> bb22;\n    }\n    bb21: {\n        goto -> bb22;\n    }\n    bb22: {\n        StorageDead(_41);\n        _0 = _31;\n        StorageDead(_31);\n        return;\n    }\n}\n",
  "doc": " Takes the normalized [`u16`](prim@u16) input and gets its normalized\n [integer square root](https://en.wikipedia.org/wiki/Integer_square_root).\n\n # Safety\n\n `n` must be nonzero.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}