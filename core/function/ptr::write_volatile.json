{
  "name": "ptr::write_volatile",
  "safe": false,
  "callees": {
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "ptr::write_volatile::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "intrinsics::volatile_store": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile store to the `dst` pointer.\n\n The stabilized version of this intrinsic is [`core::ptr::write_volatile`].\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::ptr::write_volatile"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:2158:1: 2171:2",
  "src": "pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n    // SAFETY: the caller must uphold the safety contract for `volatile_store`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::write_volatile requires that the pointer argument is aligned\",\n            (\n                addr: *mut () = dst as *mut (),\n                align: usize = align_of::<T>(),\n            ) => ub_checks::maybe_is_aligned(addr, align)\n        );\n        intrinsics::volatile_store(dst, src);\n    }\n}",
  "mir": "fn ptr::write_volatile(_1: *mut T, _2: T) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let  _4: ();\n    let mut _5: *mut ();\n    let mut _6: usize;\n    let  _7: ();\n    debug dst => _1;\n    debug src => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = ub_checks::check_language_ub() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = _1 as *mut ();\n        StorageLive(_6);\n        _6 = mem::align_of::<T>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = ptr::write_volatile::precondition_check(move _5, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_3);\n        _7 = intrinsics::volatile_store::<T>(_1, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Performs a volatile write of a memory location with the given value without reading or dropping\n the old value.\n\n Volatile operations are intended to act on I/O memory. As such, they are considered externally\n observable events (just like syscalls), and are guaranteed to not be elided or reordered by the\n compiler across other externally observable events. With this in mind, there are two cases of\n usage that need to be distinguished:\n\n - When a volatile operation is used for memory inside an [allocation], it behaves exactly like\n   [`write`][write()], except for the additional guarantee that it won't be elided or reordered\n   (see above). This implies that the operation will actually access memory and not e.g. be\n   lowered to a register access. Other than that, all the usual rules for memory accesses apply\n   (including provenance). In particular, just like in C, whether an operation is volatile has no\n   bearing whatsoever on questions involving concurrent access from multiple threads. Volatile\n   accesses behave exactly like non-atomic accesses in that regard.\n\n - Volatile operations, however, may also be used to access memory that is _outside_ of any Rust\n   allocation. In this use-case, the pointer does *not* have to be [valid] for writes. This is\n   typically used for CPU and peripheral registers that must be accessed via an I/O memory\n   mapping, most commonly at fixed addresses reserved by the hardware. These often have special\n   semantics associated to their manipulation, and cannot be used as general purpose memory.\n   Here, any address value is possible, including 0 and [`usize::MAX`], so long as the semantics\n   of such a write are well-defined by the target hardware. The provenance of the pointer is\n   irrelevant, and it can be created with [`without_provenance`]. The access must not trap. It\n   can cause side-effects, but those must not affect Rust-allocated memory in any way. This\n   access is still not considered [atomic], and as such it cannot be used for inter-thread\n   synchronization.\n\n Note that volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed\n to `write_volatile`) are noops and may be ignored.\n\n `write_volatile` does not drop the contents of `dst`. This is safe, but it could leak\n allocations or resources, so care should be taken not to overwrite an object that should be\n dropped when operating on Rust memory. Additionally, it does not drop `src`. Semantically, `src`\n is moved into the location pointed to by `dst`.\n\n [allocation]: crate::ptr#allocated-object\n [atomic]: crate::sync::atomic#memory-model-for-atomic-accesses\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be either [valid] for writes, or it must point to memory outside of all Rust\n   allocations and writing to that memory must:\n   - not trap, and\n   - not cause any memory inside a Rust allocation to be modified.\n\n * `dst` must be properly aligned.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n [valid]: self#safety\n\n # Examples\n\n Basic usage:\n\n ```\n let mut x = 0;\n let y = &mut x as *mut i32;\n let z = 12;\n\n unsafe {\n     std::ptr::write_volatile(y, z);\n     assert_eq!(std::ptr::read_volatile(y), 12);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}