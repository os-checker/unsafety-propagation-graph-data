{
  "name": "ptr::non_null::NonNull::<T>::new_unchecked",
  "safe": false,
  "callees": {
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "ptr::non_null::NonNull::<T>::new_unchecked::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "ptr::non_null::NonNull": [
      "Plain"
    ]
  },
  "path": 16027,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:234:5: 244:6",
  "src": "pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n        // SAFETY: the caller must guarantee that `ptr` is non-null.\n        unsafe {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                \"NonNull::new_unchecked requires that the pointer is non-null\",\n                (ptr: *mut () = ptr as *mut ()) => !ptr.is_null()\n            );\n            NonNull { pointer: ptr as _ }\n        }\n    }",
  "mir": "fn ptr::non_null::NonNull::<T>::new_unchecked(_1: *mut T) -> ptr::non_null::NonNull<T> {\n    let mut _0: ptr::non_null::NonNull<T>;\n    let mut _2: bool;\n    let  _3: ();\n    let mut _4: *mut ();\n    let mut _5: *const T;\n    debug ptr => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = ub_checks::check_language_ub() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = _1 as *mut ();\n        _3 = ptr::non_null::NonNull::<T>::new_unchecked::precondition_check(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_2);\n        _5 = _1 as *const T;\n        _0 = NonNull(_5);\n        return;\n    }\n}\n",
  "doc": " Creates a new `NonNull`.\n\n # Safety\n\n `ptr` must be non-null.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = unsafe { NonNull::new_unchecked(&mut x as *mut _) };\n ```\n\n *Incorrect* usage of this function:\n\n ```rust,no_run\n use std::ptr::NonNull;\n\n // NEVER DO THAT!!! This is undefined behavior. ⚠️\n let ptr = unsafe { NonNull::<u32>::new_unchecked(std::ptr::null_mut()) };\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}