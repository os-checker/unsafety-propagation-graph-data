{
  "name": "<num::wrapping::Wrapping<u64> as ops::arith::Rem>::rem",
  "safe": true,
  "callees": {
    "num::<impl u64>::wrapping_rem": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) remainder. Computes `self % rhs`.\n\n Wrapped remainder calculation on unsigned types is just the regular\n remainder calculation. There's no way wrapping could ever happen.\n This function exists so that all operations are accounted for in the\n wrapping operations.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "num::wrapping::Wrapping": [
      "Unknown([Field(0, Ty { id: 325, kind: RigidTy(Uint(U64)) })])",
      "Plain"
    ]
  },
  "path": 15323,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/wrapping.rs:390:13: 392:14",
  "src": "fn rem(self, other: Wrapping<$t>) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_rem(other.0))\n            }",
  "mir": "fn <num::wrapping::Wrapping<u64> as ops::arith::Rem>::rem(_1: num::wrapping::Wrapping<u64>, _2: num::wrapping::Wrapping<u64>) -> num::wrapping::Wrapping<u64> {\n    let mut _0: num::wrapping::Wrapping<u64>;\n    let mut _3: u64;\n    let mut _4: u64;\n    let mut _5: u64;\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = (_1.0: u64);\n        StorageLive(_5);\n        _5 = (_2.0: u64);\n        _3 = num::<impl u64>::wrapping_rem(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = Wrapping(move _3);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}