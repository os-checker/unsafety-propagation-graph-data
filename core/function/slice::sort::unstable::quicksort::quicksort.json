{
  "name": "slice::sort::unstable::quicksort::quicksort",
  "safe": true,
  "callees": {
    "slice::sort::shared::smallsort::UnstableSmallSortTypeImpl::small_sort_threshold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " For which input length <= return value of this function, is it valid to call `small_sort`.\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::UnstableSmallSortTypeImpl::small_sort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts `v` using strategies optimized for small sizes.\n",
      "adt": {}
    },
    "slice::sort::unstable::heapsort::heapsort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts `v` using heapsort, which guarantees *O*(*n* \\* log(*n*)) worst-case.\n\n Never inline this, it sits the main hot-loop in `recurse` and is meant as unlikely algorithmic\n fallback.\n",
      "adt": {}
    },
    "slice::sort::shared::pivot::choose_pivot": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Selects a pivot from `v`. Algorithm taken from glidesort by Orson Peters.\n\n This chooses a pivot by sampling an adaptive amount of points, approximating\n the quality of a median of sqrt(n) elements.\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "slice::sort::unstable::quicksort::partition": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the input slice `v` and re-arranges elements such that when the call returns normally\n all elements that compare true for `is_less(elem, pivot)` where `pivot == v[pivot_pos]` are\n on the left side of `v` followed by the other elements, notionally considered greater or\n equal to `pivot`.\n\n Returns the number of elements that are compared true for `is_less(elem, pivot)`.\n\n If `is_less` does not implement a total order the resulting order and return value are\n unspecified. All original elements will remain in `v` and any possible modifications via\n interior mutability will be observable. Same is true if `is_less` panics or `v.len()`\n exceeds `scratch.len()`.\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::<impl [T]>::split_at_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_mut_checked`](slice::split_at_mut_checked).\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n let (left, right) = v.split_at_mut(2);\n assert_eq!(left, [1, 0]);\n assert_eq!(right, [3, 0, 5, 6]);\n left[1] = 2;\n right[1] = 4;\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
      "adt": {}
    },
    "slice::sort::unstable::quicksort::quicksort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts `v` recursively.\n\n If the slice had a predecessor in the original array, it is specified as `ancestor_pivot`.\n\n `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n this function will immediately switch to heapsort.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1094, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) })])"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ]
  },
  "path": 16736,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/unstable/quicksort.rs:21:1: 80:2",
  "src": "pub(crate) fn quicksort<'a, T, F>(\n    mut v: &'a mut [T],\n    mut ancestor_pivot: Option<&'a T>,\n    mut limit: u32,\n    is_less: &mut F,\n) where\n    F: FnMut(&T, &T) -> bool,\n{\n    loop {\n        if v.len() <= T::small_sort_threshold() {\n            T::small_sort(v, is_less);\n            return;\n        }\n\n        // If too many bad pivot choices were made, simply fall back to heapsort in order to\n        // guarantee `O(N x log(N))` worst-case.\n        if limit == 0 {\n            heapsort::heapsort(v, is_less);\n            return;\n        }\n\n        limit -= 1;\n\n        // Choose a pivot and try guessing whether the slice is already sorted.\n        let pivot_pos = choose_pivot(v, is_less);\n\n        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n        // This case is usually hit when the slice contains many duplicate elements.\n        if let Some(p) = ancestor_pivot {\n            if !is_less(p, &v[pivot_pos]) {\n                let num_lt = partition(v, pivot_pos, &mut |a, b| !is_less(b, a));\n\n                // Continue sorting elements greater than the pivot. We know that `num_lt` contains\n                // the pivot. So we can continue after `num_lt`.\n                v = &mut v[(num_lt + 1)..];\n                ancestor_pivot = None;\n                continue;\n            }\n        }\n\n        // Partition the slice.\n        let num_lt = partition(v, pivot_pos, is_less);\n        // SAFETY: partition ensures that `num_lt` will be in-bounds.\n        unsafe { intrinsics::assume(num_lt < v.len()) };\n\n        // Split the slice into `left`, `pivot`, and `right`.\n        let (left, right) = v.split_at_mut(num_lt);\n        let (pivot, right) = right.split_at_mut(1);\n        let pivot = &pivot[0];\n\n        // Recurse into the left side. We have a fixed recursion limit, testing shows no real\n        // benefit for recursing into the shorter side.\n        quicksort(left, ancestor_pivot, limit, is_less);\n\n        // Continue with the right side.\n        v = right;\n        ancestor_pivot = Some(pivot);\n    }\n}",
  "mir": "fn slice::sort::unstable::quicksort::quicksort(_1: &mut [T], _2: option::Option<&T>, _3: u32, _4: &mut F) -> () {\n    let mut _0: ();\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: &[T];\n    let mut _8: usize;\n    let  _9: ();\n    let mut _10: &mut [T];\n    let mut _11: u32;\n    let  _12: ();\n    let mut _13: &mut [T];\n    let mut _14: (u32, bool);\n    let  _15: usize;\n    let mut _16: &[T];\n    let mut _17: isize;\n    let  _18: &T;\n    let mut _19: bool;\n    let mut _20: (&T, &T);\n    let  _21: &T;\n    let mut _22: *const [T];\n    let mut _23: usize;\n    let mut _24: bool;\n    let  _25: usize;\n    let mut _26: &mut [T];\n    let mut _27: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65};\n    let mut _28: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65};\n    let mut _29: &mut [T];\n    let mut _30: &mut [T];\n    let mut _31: ops::range::RangeFrom<usize>;\n    let mut _32: usize;\n    let mut _33: (usize, bool);\n    let mut _34: option::Option<&T>;\n    let  _35: usize;\n    let mut _36: &mut [T];\n    let mut _37: bool;\n    let mut _38: usize;\n    let mut _39: &[T];\n    let  _40: &mut [T];\n    let  _41: &mut [T];\n    let mut _42: (&mut [T], &mut [T]);\n    let mut _43: &mut [T];\n    let  _44: &mut [T];\n    let  _45: &mut [T];\n    let mut _46: (&mut [T], &mut [T]);\n    let  _47: &T;\n    let  _48: usize;\n    let mut _49: *const [T];\n    let mut _50: usize;\n    let mut _51: bool;\n    let  _52: ();\n    let mut _53: option::Option<&T>;\n    let mut _54: u32;\n    let mut _55: option::Option<&T>;\n    debug v => _1;\n    debug ancestor_pivot => _2;\n    debug limit => _3;\n    debug is_less => _4;\n    debug pivot_pos => _15;\n    debug p => _18;\n    debug num_lt => _25;\n    debug num_lt => _35;\n    debug left => _40;\n    debug right => _41;\n    debug pivot => _44;\n    debug right => _45;\n    debug pivot => _47;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = <T as slice::sort::shared::smallsort::UnstableSmallSortTypeImpl>::small_sort_threshold() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = Le(move _6, move _8);\n        switchInt(move _5) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = _1;\n        _9 = <T as slice::sort::shared::smallsort::UnstableSmallSortTypeImpl>::small_sort::<F>(move _10, _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageDead(_5);\n        goto -> bb25;\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_11);\n        _11 = _3;\n        switchInt(move _11) -> [0: bb6, otherwise: bb7];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageLive(_13);\n        _13 = _1;\n        _12 = slice::sort::unstable::heapsort::heapsort::<T, F>(move _13, _4) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _14 = CheckedSub(_3, 1_u32);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 1_u32) -> [success: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        goto -> bb25;\n    }\n    bb9: {\n        _3 = move (_14.0: u32);\n        StorageLive(_16);\n        _16 = &(*_1);\n        _15 = slice::sort::shared::pivot::choose_pivot::<T, F>(move _16, _4) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        _17 = discriminant(_2);\n        switchInt(move _17) -> [1: bb11, 0: bb19, otherwise: bb26];\n    }\n    bb11: {\n        _18 = ((_2 as variant#1).0: &T);\n        StorageLive(_19);\n        StorageLive(_20);\n        _22 = &raw const (fake) (*_1);\n        _23 = PtrMetadata(move _22);\n        _24 = Lt(_15, _23);\n        assert(move _24, \"index out of bounds: the length is {} but the index is {}\", move _23, _15) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _21 = &(*_1)[_15];\n        _20 = (_18, _21);\n        _19 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_4, move _20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _19) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb19;\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageLive(_26);\n        _26 = _1;\n        StorageLive(_28);\n        _28 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65}(_4);\n        _27 = &mut _28;\n        _25 = slice::sort::unstable::quicksort::partition::<T, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65}>(move _26, _15, _27) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        StorageDead(_28);\n        StorageLive(_30);\n        _30 = _1;\n        StorageLive(_31);\n        StorageLive(_32);\n        _33 = CheckedAdd(_25, 1_usize);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, 1_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _32 = move (_33.0: usize);\n        _31 = RangeFrom(move _32);\n        StorageDead(_32);\n        _29 = <[T] as ops::index::IndexMut<ops::range::RangeFrom<usize>>>::index_mut(move _30, move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        StorageDead(_30);\n        _1 = _29;\n        StorageLive(_34);\n        _34 = option::Option::None;\n        _2 = move _34;\n        StorageDead(_34);\n        StorageDead(_19);\n        goto -> bb1;\n    }\n    bb19: {\n        StorageLive(_36);\n        _36 = _1;\n        _35 = slice::sort::unstable::quicksort::partition::<T, F>(move _36, _15, _4) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &(*_1);\n        _38 = PtrMetadata(move _39);\n        StorageDead(_39);\n        _37 = Lt(_35, move _38);\n        StorageDead(_38);\n        Intrinsic(Assume(Move(_37)));\n        StorageDead(_37);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = _1;\n        _42 = slice::<impl [T]>::split_at_mut(move _43, _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_43);\n        _40 = move (_42.0: &mut [T]);\n        _41 = move (_42.1: &mut [T]);\n        StorageDead(_42);\n        StorageLive(_46);\n        _46 = slice::<impl [T]>::split_at_mut(_41, 1_usize) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_44);\n        _44 = move (_46.0: &mut [T]);\n        _45 = move (_46.1: &mut [T]);\n        StorageDead(_46);\n        StorageLive(_48);\n        _48 = 0_usize;\n        _49 = &raw const (fake) (*_44);\n        _50 = PtrMetadata(move _49);\n        _51 = Lt(_48, _50);\n        assert(move _51, \"index out of bounds: the length is {} but the index is {}\", move _50, _48) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _47 = &(*_44)[_48];\n        StorageDead(_48);\n        StorageLive(_53);\n        _53 = _2;\n        StorageLive(_54);\n        _54 = _3;\n        _52 = slice::sort::unstable::quicksort::quicksort::<T, F>(_40, move _53, move _54, _4) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_54);\n        StorageDead(_53);\n        _1 = _45;\n        StorageLive(_55);\n        _55 = option::Option::Some(_47);\n        _2 = move _55;\n        StorageDead(_55);\n        StorageDead(_44);\n        goto -> bb1;\n    }\n    bb25: {\n        return;\n    }\n    bb26: {\n        unreachable;\n    }\n}\n",
  "doc": " Sorts `v` recursively.\n\n If the slice had a predecessor in the original array, it is specified as `ancestor_pivot`.\n\n `limit` is the number of allowed imbalanced partitions before switching to `heapsort`. If zero,\n this function will immediately switch to heapsort.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}