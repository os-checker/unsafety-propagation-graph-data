{
  "name": "slice::sort::shared::smallsort::small_sort_general_with_scratch",
  "safe": true,
  "callees": {
    "intrinsics::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the execution of the process.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n as its behavior is more user-friendly and more stable.\n\n The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n on most platforms.\n On Unix, the\n process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n `SIGBUS`.  The precise behavior is not guaranteed and not stable.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::sort8_stable": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " SAFETY: The caller MUST guarantee that `v_base` is valid for 8 reads and\n writes, `scratch_base` and `dst` MUST be valid for 8 writes. The result will\n be stored in `dst[0..8]`.\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::sort4_stable": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " SAFETY: The caller MUST guarantee that `v_base` is valid for 4 reads and\n `dst` is valid for 4 writes. The result will be stored in `dst[0..4]`.\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::insert_tail": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts range [begin, tail] assuming [begin, tail) is already sorted.\n\n # Safety\n begin < tail and p must be valid and initialized for all begin <= p <= tail.\n",
      "adt": {}
    },
    "ptr::slice_from_raw_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a raw slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n\n [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n\n # Examples\n\n ```rust\n use std::ptr;\n\n // create a slice pointer when starting out with a pointer to the first element\n let x = [5, 6, 7];\n let raw_pointer = x.as_ptr();\n let slice = ptr::slice_from_raw_parts(raw_pointer, 3);\n assert_eq!(unsafe { &*slice }[2], 7);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *const [u8] = ptr::slice_from_raw_parts(ptr::null(), 0);\n unsafe {\n     danger.as_ref().expect(\"references must not be null\");\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::bidirectional_merge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Merge v assuming v[..len / 2] and v[len / 2..] are sorted.\n\n Original idea for bi-directional merging by Igor van den Hoven (quadsort),\n adapted to only use merge up and down. In contrast to the original\n parity_merge function, it performs 2 writes instead of 4 per iteration.\n\n # Safety\n The caller must guarantee that `dst` is valid for v.len() writes.\n Also `v.as_ptr()` and `dst` must not alias and v.len() must be >= 2.\n\n Note that T must be Freeze, the comparison function is evaluated on outdated\n temporary 'copies' that may not end up in the final array.\n",
      "adt": {}
    },
    "mem::forget": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes ownership and \"forgets\" about the value **without running its destructor**.\n\n Any resources the value manages, such as heap memory or a file handle, will linger\n forever in an unreachable state. However, it does not guarantee that pointers\n to this memory will remain valid.\n\n * If you want to leak memory, see [`Box::leak`].\n * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n * If you want to dispose of a value properly, running its destructor, see\n   [`mem::drop`].\n\n # Safety\n\n `forget` is not marked as `unsafe`, because Rust's safety guarantees\n do not include a guarantee that destructors will always run. For example,\n a program can create a reference cycle using [`Rc`][rc], or call\n [`process::exit`][exit] to exit without running destructors. Thus, allowing\n `mem::forget` from safe code does not fundamentally change Rust's safety\n guarantees.\n\n That said, leaking resources such as memory or I/O objects is usually undesirable.\n The need comes up in some specialized use cases for FFI or unsafe code, but even\n then, [`ManuallyDrop`] is typically preferred.\n\n Because forgetting a value is allowed, any `unsafe` code you write must\n allow for this possibility. You cannot return a value and expect that the\n caller will necessarily run the value's destructor.\n\n [rc]: ../../std/rc/struct.Rc.html\n [exit]: ../../std/process/fn.exit.html\n\n # Examples\n\n The canonical safe use of `mem::forget` is to circumvent a value's destructor\n implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n the space taken by the variable but never close the underlying system resource:\n\n ```no_run\n use std::mem;\n use std::fs::File;\n\n let file = File::open(\"foo.txt\").unwrap();\n mem::forget(file);\n ```\n\n This is useful when the ownership of the underlying resource was previously\n transferred to code outside of Rust, for example by transmitting the raw\n file descriptor to C code.\n\n # Relationship with `ManuallyDrop`\n\n While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n\n ```\n use std::mem;\n\n let mut v = vec![65, 122];\n // Build a `String` using the contents of `v`\n let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n // leak `v` because its memory is now managed by `s`\n mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n There are two issues with the above example:\n\n * If more code were added between the construction of `String` and the invocation of\n   `mem::forget()`, a panic within it would cause a double free because the same memory\n   is handled by both `v` and `s`.\n * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n   inspect it), some types have strict requirements on their values that\n   make them invalid when dangling or no longer owned. Using invalid values in any\n   way, including passing them to or returning them from functions, constitutes\n   undefined behavior and may break the assumptions made by the compiler.\n\n Switching to `ManuallyDrop` avoids both issues:\n\n ```\n use std::mem::ManuallyDrop;\n\n let v = vec![65, 122];\n // Before we disassemble `v` into its raw parts, make sure it\n // does not get dropped!\n let mut v = ManuallyDrop::new(v);\n // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n // Finally, build a `String`.\n let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n argument, forcing us to call it only after extracting anything we need from `v`. Even\n if a panic were introduced between construction of `ManuallyDrop` and building the\n string (which cannot happen in the code as shown), it would result in a leak and not a\n double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n erring on the side of (double-)dropping.\n\n Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n ownership to `s` â€” the final step of interacting with `v` to dispose of it without\n running its destructor is entirely avoided.\n\n [`Box`]: ../../std/boxed/struct.Box.html\n [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n [`mem::drop`]: drop\n [ub]: ../../reference/behavior-considered-undefined.html\n",
      "adt": {}
    }
  },
  "adts": {
    "array::iter::IntoIter": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::Range": [
      "Plain",
      "MutRef"
    ],
    "slice::sort::shared::smallsort::CopyOnDrop": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1378, kind: RigidTy(RawPtr(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) })])",
      "Unknown([Field(2, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 1181, kind: RigidTy(RawPtr(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])"
    ]
  },
  "path": 16677,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:220:1: 293:2",
  "src": "fn small_sort_general_with_scratch<T: FreezeMarker, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    is_less: &mut F,\n) {\n    let len = v.len();\n    if len < 2 {\n        return;\n    }\n\n    if scratch.len() < len + 16 {\n        intrinsics::abort();\n    }\n\n    let v_base = v.as_mut_ptr();\n    let len_div_2 = len / 2;\n\n    // SAFETY: See individual comments.\n    unsafe {\n        let scratch_base = scratch.as_mut_ptr() as *mut T;\n\n        let presorted_len = if const { size_of::<T>() <= 16 } && len >= 16 {\n            // SAFETY: scratch_base is valid and has enough space.\n            sort8_stable(v_base, scratch_base, scratch_base.add(len), is_less);\n            sort8_stable(\n                v_base.add(len_div_2),\n                scratch_base.add(len_div_2),\n                scratch_base.add(len + 8),\n                is_less,\n            );\n\n            8\n        } else if len >= 8 {\n            // SAFETY: scratch_base is valid and has enough space.\n            sort4_stable(v_base, scratch_base, is_less);\n            sort4_stable(v_base.add(len_div_2), scratch_base.add(len_div_2), is_less);\n\n            4\n        } else {\n            ptr::copy_nonoverlapping(v_base, scratch_base, 1);\n            ptr::copy_nonoverlapping(v_base.add(len_div_2), scratch_base.add(len_div_2), 1);\n\n            1\n        };\n\n        for offset in [0, len_div_2] {\n            // SAFETY: at this point dst is initialized with presorted_len elements.\n            // We extend this to desired_len, src is valid for desired_len elements.\n            let src = v_base.add(offset);\n            let dst = scratch_base.add(offset);\n            let desired_len = if offset == 0 { len_div_2 } else { len - len_div_2 };\n\n            for i in presorted_len..desired_len {\n                ptr::copy_nonoverlapping(src.add(i), dst.add(i), 1);\n                insert_tail(dst, dst.add(i), is_less);\n            }\n        }\n\n        // SAFETY: see comment in `CopyOnDrop::drop`.\n        let drop_guard = CopyOnDrop { src: scratch_base, dst: v_base, len };\n\n        // SAFETY: at this point scratch_base is fully initialized, allowing us\n        // to use it as the source of our merge back into the original array.\n        // If a panic occurs we ensure the original array is restored to a valid\n        // permutation of the input through drop_guard. This technique is similar\n        // to ping-pong merging.\n        bidirectional_merge(\n            &*ptr::slice_from_raw_parts(drop_guard.src, drop_guard.len),\n            drop_guard.dst,\n            is_less,\n        );\n        mem::forget(drop_guard);\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::small_sort_general_with_scratch(_1: &mut [T], _2: &mut [mem::maybe_uninit::MaybeUninit<T>], _3: &mut F) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let mut _5: &[T];\n    let mut _6: bool;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: &[mem::maybe_uninit::MaybeUninit<T>];\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let  _12: !;\n    let  _13: *mut T;\n    let  _14: usize;\n    let mut _15: bool;\n    let  _16: *mut T;\n    let mut _17: *mut mem::maybe_uninit::MaybeUninit<T>;\n    let  _18: usize;\n    let mut _19: bool;\n    let  _20: ();\n    let mut _21: *mut T;\n    let  _22: ();\n    let mut _23: *mut T;\n    let mut _24: *mut T;\n    let mut _25: *mut T;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let mut _28: bool;\n    let  _29: ();\n    let mut _30: *const T;\n    let  _31: ();\n    let mut _32: *const T;\n    let mut _33: *mut T;\n    let mut _34: *mut T;\n    let  _35: ();\n    let mut _36: *const T;\n    let  _37: ();\n    let mut _38: *const T;\n    let mut _39: *mut T;\n    let mut _40: *mut T;\n    let mut _41: array::iter::IntoIter<usize, 2>;\n    let mut _42: [usize; 2];\n    let mut _43: array::iter::IntoIter<usize, 2>;\n    let mut _44: option::Option<usize>;\n    let mut _45: &mut array::iter::IntoIter<usize, 2>;\n    let mut _46: isize;\n    let  _47: usize;\n    let  _48: *mut T;\n    let  _49: *mut T;\n    let  _50: usize;\n    let mut _51: (usize, bool);\n    let mut _52: ops::range::Range<usize>;\n    let mut _53: ops::range::Range<usize>;\n    let mut _54: usize;\n    let mut _55: usize;\n    let mut _56: ops::range::Range<usize>;\n    let mut _57: option::Option<usize>;\n    let mut _58: &mut ops::range::Range<usize>;\n    let mut _59: isize;\n    let  _60: usize;\n    let  _61: ();\n    let mut _62: *const T;\n    let mut _63: *mut T;\n    let mut _64: *mut T;\n    let  _65: ();\n    let mut _66: *mut T;\n    let  _67: slice::sort::shared::smallsort::CopyOnDrop<T>;\n    let mut _68: *const T;\n    let  _69: ();\n    let  _70: &[T];\n    let  _71: *const [T];\n    let mut _72: *const T;\n    let mut _73: usize;\n    let mut _74: *mut T;\n    let  _75: ();\n    debug v => _1;\n    debug scratch => _2;\n    debug is_less => _3;\n    debug len => _4;\n    debug v_base => _13;\n    debug len_div_2 => _14;\n    debug scratch_base => _16;\n    debug presorted_len => _18;\n    debug iter => _43;\n    debug offset => _47;\n    debug src => _48;\n    debug dst => _49;\n    debug desired_len => _50;\n    debug iter => _56;\n    debug i => _60;\n    debug drop_guard => _67;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = Lt(_4, 2_usize);\n        switchInt(move _6) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_6);\n        goto -> bb58;\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_2);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        StorageLive(_10);\n        _11 = CheckedAdd(_4, 16_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, 16_usize) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _10 = move (_11.0: usize);\n        _7 = Lt(move _8, move _10);\n        switchInt(move _7) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageDead(_8);\n        _12 = intrinsics::abort() -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageDead(_7);\n        _13 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _15 = Eq(2_usize, 0_usize);\n        assert(!move _15, \"attempt to divide `{}` by zero\", _4) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = Div(_4, 2_usize);\n        StorageLive(_17);\n        _17 = slice::<impl [mem::maybe_uninit::MaybeUninit<T>]>::as_mut_ptr(_2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _16 = move _17 as *mut T;\n        StorageDead(_17);\n        StorageLive(_18);\n        switchInt(slice::sort::shared::smallsort::small_sort_general_with_scratch::<T, F>::{constant#0}) -> [0: bb19, otherwise: bb9];\n    }\n    bb9: {\n        StorageLive(_19);\n        _19 = Ge(_4, 16_usize);\n        switchInt(move _19) -> [0: bb18, otherwise: bb10];\n    }\n    bb10: {\n        StorageLive(_21);\n        _21 = ptr::mut_ptr::<impl *mut T>::add(_16, _4) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _20 = slice::sort::shared::smallsort::sort8_stable::<T, F>(_13, _16, move _21, _3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_21);\n        StorageLive(_23);\n        _23 = ptr::mut_ptr::<impl *mut T>::add(_13, _14) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_24);\n        _24 = ptr::mut_ptr::<impl *mut T>::add(_16, _14) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_25);\n        StorageLive(_26);\n        _27 = CheckedAdd(_4, 8_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, 8_usize) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _26 = move (_27.0: usize);\n        _25 = ptr::mut_ptr::<impl *mut T>::add(_16, move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _22 = slice::sort::shared::smallsort::sort8_stable::<T, F>(move _23, move _24, move _25, _3) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        _18 = 8_usize;\n        goto -> bb31;\n    }\n    bb18: {\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_28);\n        _28 = Ge(_4, 8_usize);\n        switchInt(move _28) -> [0: bb25, otherwise: bb20];\n    }\n    bb20: {\n        StorageLive(_30);\n        _30 = _13 as *const T;\n        _29 = slice::sort::shared::smallsort::sort4_stable::<T, F>(move _30, _16, _3) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_30);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = ptr::mut_ptr::<impl *mut T>::add(_13, _14) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _32 = move _33 as *const T;\n        StorageDead(_33);\n        StorageLive(_34);\n        _34 = ptr::mut_ptr::<impl *mut T>::add(_16, _14) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _31 = slice::sort::shared::smallsort::sort4_stable::<T, F>(move _32, move _34, _3) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_34);\n        StorageDead(_32);\n        _18 = 4_usize;\n        goto -> bb30;\n    }\n    bb25: {\n        StorageLive(_36);\n        _36 = _13 as *const T;\n        _35 = ptr::copy_nonoverlapping::<T>(move _36, _16, 1_usize) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = ptr::mut_ptr::<impl *mut T>::add(_13, _14) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _38 = move _39 as *const T;\n        StorageDead(_39);\n        StorageLive(_40);\n        _40 = ptr::mut_ptr::<impl *mut T>::add(_16, _14) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _37 = ptr::copy_nonoverlapping::<T>(move _38, move _40, 1_usize) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_40);\n        StorageDead(_38);\n        _18 = 1_usize;\n        goto -> bb30;\n    }\n    bb30: {\n        StorageDead(_28);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_19);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = [0_usize, _14];\n        _41 = <[usize; 2] as iter::traits::collect::IntoIterator>::into_iter(move _42) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_42);\n        StorageLive(_43);\n        _43 = move _41;\n        goto -> bb33;\n    }\n    bb33: {\n        StorageLive(_44);\n        _45 = &mut _43;\n        _44 = <array::iter::IntoIter<usize, 2> as iter::traits::iterator::Iterator>::next(_45) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _46 = discriminant(_44);\n        switchInt(move _46) -> [0: bb37, 1: bb36, otherwise: bb35];\n    }\n    bb35: {\n        unreachable;\n    }\n    bb36: {\n        _47 = ((_44 as variant#1).0: usize);\n        _48 = ptr::mut_ptr::<impl *mut T>::add(_13, _47) -> [return: bb38, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_44);\n        drop(_43) -> [return: bb54, unwind unreachable];\n    }\n    bb38: {\n        _49 = ptr::mut_ptr::<impl *mut T>::add(_16, _47) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageLive(_50);\n        switchInt(_47) -> [0: bb40, otherwise: bb41];\n    }\n    bb40: {\n        _50 = _14;\n        goto -> bb43;\n    }\n    bb41: {\n        _51 = CheckedSub(_4, _14);\n        assert(!move (_51.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _14) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _50 = move (_51.0: usize);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = _18;\n        StorageLive(_55);\n        _55 = _50;\n        _53 = Range(move _54, move _55);\n        StorageDead(_55);\n        StorageDead(_54);\n        _52 = <ops::range::Range<usize> as iter::traits::collect::IntoIterator>::into_iter(move _53) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_53);\n        StorageLive(_56);\n        _56 = move _52;\n        goto -> bb45;\n    }\n    bb45: {\n        StorageLive(_57);\n        _58 = &mut _56;\n        _57 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::next(_58) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _59 = discriminant(_57);\n        switchInt(move _59) -> [0: bb48, 1: bb47, otherwise: bb35];\n    }\n    bb47: {\n        _60 = ((_57 as variant#1).0: usize);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = ptr::mut_ptr::<impl *mut T>::add(_48, _60) -> [return: bb49, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_52);\n        StorageDead(_50);\n        StorageDead(_44);\n        goto -> bb33;\n    }\n    bb49: {\n        _62 = move _63 as *const T;\n        StorageDead(_63);\n        StorageLive(_64);\n        _64 = ptr::mut_ptr::<impl *mut T>::add(_49, _60) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _61 = ptr::copy_nonoverlapping::<T>(move _62, move _64, 1_usize) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_64);\n        StorageDead(_62);\n        StorageLive(_66);\n        _66 = ptr::mut_ptr::<impl *mut T>::add(_49, _60) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        _65 = slice::sort::shared::smallsort::insert_tail::<T, F>(_49, move _66, _3) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_66);\n        StorageDead(_57);\n        goto -> bb45;\n    }\n    bb54: {\n        StorageDead(_43);\n        StorageDead(_41);\n        StorageLive(_68);\n        _68 = _16 as *const T;\n        _67 = CopyOnDrop(move _68, _13, _4);\n        StorageDead(_68);\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = (_67.0: *const T);\n        StorageLive(_73);\n        _73 = (_67.2: usize);\n        _71 = ptr::slice_from_raw_parts::<T>(move _72, move _73) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_73);\n        StorageDead(_72);\n        _70 = &(*_71);\n        StorageLive(_74);\n        _74 = (_67.1: *mut T);\n        _69 = slice::sort::shared::smallsort::bidirectional_merge::<T, F>(_70, move _74, _3) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_74);\n        StorageDead(_71);\n        _75 = mem::forget::<slice::sort::shared::smallsort::CopyOnDrop<T>>(_67) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_18);\n        goto -> bb58;\n    }\n    bb58: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}