{
  "name": "num::<impl i128>::borrowing_sub",
  "safe": true,
  "callees": {
    "num::<impl i128>::overflowing_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates `self` - `rhs`.\n\n Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n would occur. If an overflow would have occurred then the wrapped value is returned.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl i128>::borrowing_sub"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:2620:9: 2626:10",
  "src": "pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_sub(rhs);\n            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n            (c, b != d)\n        }",
  "mir": "fn num::<impl i128>::borrowing_sub(_1: i128, _2: i128, _3: bool) -> (i128, bool) {\n    let mut _0: (i128, bool);\n    let  _4: i128;\n    let  _5: bool;\n    let mut _6: (i128, bool);\n    let  _7: i128;\n    let  _8: bool;\n    let mut _9: (i128, bool);\n    let mut _10: i128;\n    let mut _11: bool;\n    debug self => _1;\n    debug rhs => _2;\n    debug borrow => _3;\n    debug a => _4;\n    debug b => _5;\n    debug c => _7;\n    debug d => _8;\n    bb0: {\n        StorageLive(_6);\n        _6 = num::<impl i128>::overflowing_sub(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = (_6.0: i128);\n        _5 = (_6.1: bool);\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _3 as i128;\n        _9 = num::<impl i128>::overflowing_sub(_4, move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        _7 = (_9.0: i128);\n        _8 = (_9.1: bool);\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = Ne(_5, _8);\n        _0 = (_7, move _11);\n        StorageDead(_11);\n        return;\n    }\n}\n",
  "doc": " Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n overflow.\n\n Performs \"ternary subtraction\" by subtracting both an integer\n operand and a borrow-in bit from `self`, and returns a tuple of the\n difference along with a boolean indicating whether an arithmetic\n overflow would occur. On overflow, the wrapped value is returned.\n\n This allows chaining together multiple subtractions to create a\n wider subtraction, and can be useful for bignum subtraction. This\n method should only be used for the most significant word; for the\n less significant words the unsigned method\n should be used.\n\n The output boolean returned by this method is *not* a borrow flag,\n and should *not* be subtracted from a more significant word.\n\n If the input borrow is false, this method is equivalent to\n [`overflowing_sub`](Self::overflowing_sub).\n\n # Examples\n\n ```\n #![feature(bigint_helper_methods)]\n // Only the most significant word is signed.\n //\n // ---------\n\n let borrow0 = false;\n\n let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n assert_eq!(borrow1, true);\n\n let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n assert_eq!(overflow, false);\n\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}