{
  "name": "core_arch::simd::debug_simd_finish",
  "safe": true,
  "callees": {
    "array::from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an array where each element is produced by calling `f` with\n that element's index while walking forward through the array.\n\n This is essentially the same as writing\n ```text\n [f(0), f(1), f(2), â€¦, f(N - 2), f(N - 1)]\n ```\n and is similar to `(0..i).map(f)`, just for arrays not iterators.\n\n If `N == 0`, this produces an empty array without ever calling `f`.\n\n # Example\n\n ```rust\n // type inference is helping us here, the way `from_fn` knows how many\n // elements to produce is the length of array down there: only arrays of\n // equal lengths can be compared, so the const generic parameter `N` is\n // inferred to be 5, thus creating array of 5 elements.\n\n let array = core::array::from_fn(|i| i);\n // indexes are:    0  1  2  3  4\n assert_eq!(array, [0, 1, 2, 3, 4]);\n\n let array2: [usize; 8] = core::array::from_fn(|i| i * 2);\n // indexes are:     0  1  2  3  4  5   6   7\n assert_eq!(array2, [0, 2, 4, 6, 8, 10, 12, 14]);\n\n let bool_arr = core::array::from_fn::<_, 5, _>(|i| i % 2 == 0);\n // indexes are:       0     1      2     3      4\n assert_eq!(bool_arr, [true, false, true, false, true]);\n ```\n\n You can also capture things, for example to create an array full of clones\n where you can't just use `[item; N]` because it's not `Copy`:\n ```\n # // TBH `array::repeat` would be better for this, but it's not stable yet.\n let my_string = String::from(\"Hello\");\n let clones: [String; 42] = std::array::from_fn(|_| my_string.clone());\n assert!(clones.iter().all(|x| *x == my_string));\n ```\n\n The array is generated in ascending index order, starting from the front\n and going towards the back, so you can use closures with mutable state:\n ```\n let mut state = 1;\n let a = std::array::from_fn(|_| { let x = state; state *= 2; x });\n assert_eq!(a, [1, 2, 4, 8, 16, 32]);\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::debug_tuple_fields_finish": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Shrinks `derive(Debug)` code, for faster compilation and smaller\n binaries. For the cases not covered by `debug_tuple_field[12345]_finish`.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": 5248,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/simd.rs:1011:1: 1021:2",
  "src": "pub(crate) fn debug_simd_finish<T: crate::fmt::Debug, const N: usize>(\n    formatter: &mut crate::fmt::Formatter<'_>,\n    type_name: &str,\n    array: &[T; N],\n) -> crate::fmt::Result {\n    crate::fmt::Formatter::debug_tuple_fields_finish(\n        formatter,\n        type_name,\n        &crate::array::from_fn::<&dyn crate::fmt::Debug, N, _>(|i| &array[i]),\n    )\n}",
  "mir": "fn core_arch::simd::debug_simd_finish(_1: &mut fmt::Formatter<'_>, _2: &str, _3: &[T; N]) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _4: &[&dyn fmt::Debug];\n    let  _5: &[&dyn fmt::Debug; N];\n    let  _6: [&dyn fmt::Debug; N];\n    let mut _7: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/simd.rs:1019:64: 1019:67};\n    debug formatter => _1;\n    debug type_name => _2;\n    debug array => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/simd.rs:1019:64: 1019:67}(_3);\n        _6 = array::from_fn::<&dyn fmt::Debug, N, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/simd.rs:1019:64: 1019:67}>(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _5 = &_6;\n        _4 = _5 as &[&dyn fmt::Debug];\n        _0 = fmt::Formatter::<'_>::debug_tuple_fields_finish(_1, _2, move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Used to continue `Debug`ging SIMD types as `MySimd(1, 2, 3, 4)`, as they\n were before moving to array-based simd.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}