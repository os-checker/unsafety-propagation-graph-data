{
  "name": "core_arch::x86::sse42::_mm_cmpistri",
  "safe": false,
  "callees": {
    "core_arch::x86::__m128i::as_i8x16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_arch::simd::i8x16": "Constructor"
      }
    },
    "core_arch::x86::sse42::pcmpistri128": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128i": [
      "Plain"
    ],
    "core_arch::simd::i8x16": [
      "Plain"
    ]
  },
  "path": 11964,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/sse42.rs:264:1: 267:2",
  "src": "pub fn _mm_cmpistri<const IMM8: i32>(a: __m128i, b: __m128i) -> i32 {\n    static_assert_uimm_bits!(IMM8, 8);\n    unsafe { pcmpistri128(a.as_i8x16(), b.as_i8x16(), IMM8 as i8) }\n}",
  "mir": "fn core_arch::x86::sse42::_mm_cmpistri(_1: core_arch::x86::__m128i, _2: core_arch::x86::__m128i) -> i32 {\n    let mut _0: i32;\n    let mut _3: core_arch::simd::i8x16;\n    let mut _4: core_arch::simd::i8x16;\n    let mut _5: i8;\n    debug a => _1;\n    debug b => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = core_arch::x86::__m128i::as_i8x16(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = core_arch::x86::__m128i::as_i8x16(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = IMM8 as i8;\n        _0 = core_arch::x86::sse42::pcmpistri128(move _3, move _4, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Compares packed strings with implicit lengths in `a` and `b` using the\n control in `IMM8` and return the generated index. Similar to\n [`_mm_cmpestri`] with the exception that [`_mm_cmpestri`] requires the\n lengths of `a` and `b` to be explicitly specified.\n\n # Control modes\n\n The control specified by `IMM8` may be one or more of the following.\n\n ## Data size and signedness\n\n  - [`_SIDD_UBYTE_OPS`] - Default\n  - [`_SIDD_UWORD_OPS`]\n  - [`_SIDD_SBYTE_OPS`]\n  - [`_SIDD_SWORD_OPS`]\n\n ## Comparison options\n  - [`_SIDD_CMP_EQUAL_ANY`] - Default\n  - [`_SIDD_CMP_RANGES`]\n  - [`_SIDD_CMP_EQUAL_EACH`]\n  - [`_SIDD_CMP_EQUAL_ORDERED`]\n\n ## Result polarity\n  - [`_SIDD_POSITIVE_POLARITY`] - Default\n  - [`_SIDD_NEGATIVE_POLARITY`]\n\n ## Bit returned\n  - [`_SIDD_LEAST_SIGNIFICANT`] - Default\n  - [`_SIDD_MOST_SIGNIFICANT`]\n\n # Examples\n\n Finds a substring using [`_SIDD_CMP_EQUAL_ORDERED`]\n\n ```\n #[cfg(target_arch = \"x86\")]\n use std::arch::x86::*;\n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;\n\n # fn main() {\n #     if is_x86_feature_detected!(\"sse4.2\") {\n #         #[target_feature(enable = \"sse4.2\")]\n #         unsafe fn worker() {\n let haystack = b\"This is a long string of text data\\r\\n\\tthat extends\n multiple lines\";\n let needle = b\"\\r\\n\\t\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n let a = unsafe { _mm_loadu_si128(needle.as_ptr() as *const _) };\n let hop = 16;\n let mut indexes = Vec::new();\n\n // Chunk the haystack into 16 byte chunks and find\n // the first \"\\r\\n\\t\" in the chunk.\n for (i, chunk) in haystack.chunks(hop).enumerate() {\n     let b = unsafe { _mm_loadu_si128(chunk.as_ptr() as *const _) };\n     let idx = _mm_cmpistri(a, b, _SIDD_CMP_EQUAL_ORDERED);\n     if idx != 16 {\n         indexes.push((idx as usize) + (i * hop));\n     }\n }\n assert_eq!(indexes, vec![34]);\n #         }\n #         unsafe { worker(); }\n #     }\n # }\n ```\n\n The `_mm_cmpistri` intrinsic may also be used to find the existence of\n one or more of a given set of characters in the haystack.\n\n ```\n #[cfg(target_arch = \"x86\")]\n use std::arch::x86::*;\n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;\n\n # fn main() {\n #     if is_x86_feature_detected!(\"sse4.2\") {\n #         #[target_feature(enable = \"sse4.2\")]\n #         unsafe fn worker() {\n // Ensure your input is 16 byte aligned\n let password = b\"hunter2\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n let special_chars = b\"!@#$%^&*()[]:;<>\";\n\n // Load the input\n let a = unsafe { _mm_loadu_si128(special_chars.as_ptr() as *const _) };\n let b = unsafe { _mm_loadu_si128(password.as_ptr() as *const _) };\n\n // Use _SIDD_CMP_EQUAL_ANY to find the index of any bytes in b\n let idx = _mm_cmpistri(a.into(), b.into(), _SIDD_CMP_EQUAL_ANY);\n\n if idx < 16 {\n     println!(\"Congrats! Your password contains a special character\");\n     # panic!(\"{:?} does not contain a special character\", password);\n } else {\n     println!(\"Your password should contain a special character\");\n }\n #         }\n #         unsafe { worker(); }\n #     }\n # }\n ```\n\n Finds the index of the first character in the haystack that is within a\n range of characters.\n\n ```\n #[cfg(target_arch = \"x86\")]\n use std::arch::x86::*;\n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;\n\n # fn main() {\n #     if is_x86_feature_detected!(\"sse4.2\") {\n #         #[target_feature(enable = \"sse4.2\")]\n #         unsafe fn worker() {\n # let b = b\":;<=>?@[\\\\]^_`abc\";\n # let b = unsafe { _mm_loadu_si128(b.as_ptr() as *const _) };\n\n // Specify the ranges of values to be searched for [A-Za-z0-9].\n let a = b\"AZaz09\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n let a = unsafe { _mm_loadu_si128(a.as_ptr() as *const _) };\n\n // Use _SIDD_CMP_RANGES to find the index of first byte in ranges.\n // Which in this case will be the first alpha numeric byte found\n // in the string.\n let idx = _mm_cmpistri(a, b, _SIDD_CMP_RANGES);\n\n if idx < 16 {\n     println!(\"Found an alpha numeric character\");\n     # assert_eq!(idx, 13);\n } else {\n     println!(\"Did not find an alpha numeric character\");\n }\n #         }\n #         unsafe { worker(); }\n #     }\n # }\n ```\n\n Working with 16-bit characters.\n\n ```\n #[cfg(target_arch = \"x86\")]\n use std::arch::x86::*;\n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;\n\n # fn main() {\n #     if is_x86_feature_detected!(\"sse4.2\") {\n #         #[target_feature(enable = \"sse4.2\")]\n #         unsafe fn worker() {\n # let mut some_utf16_words = [0u16; 8];\n # let mut more_utf16_words = [0u16; 8];\n # 'â¤'.encode_utf16(&mut some_utf16_words);\n # 'ð•Š'.encode_utf16(&mut more_utf16_words);\n // Load the input\n let a = unsafe { _mm_loadu_si128(some_utf16_words.as_ptr() as *const _) };\n let b = unsafe { _mm_loadu_si128(more_utf16_words.as_ptr() as *const _) };\n\n // Specify _SIDD_UWORD_OPS to compare words instead of bytes, and\n // use _SIDD_CMP_EQUAL_EACH to compare the two strings.\n let idx = _mm_cmpistri(a, b, _SIDD_UWORD_OPS | _SIDD_CMP_EQUAL_EACH);\n\n if idx == 0 {\n     println!(\"16-bit unicode strings were equal!\");\n     # panic!(\"Strings should not be equal!\")\n } else {\n     println!(\"16-bit unicode strings were not equal!\");\n }\n #         }\n #         unsafe { worker(); }\n #     }\n # }\n ```\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_cmpistri)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}