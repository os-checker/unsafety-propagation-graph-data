{
  "name": "core_arch::x86::kl::_mm_aesdecwide128kl_u8",
  "safe": false,
  "callees": {
    "ptr::slice_from_raw_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a raw slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n\n [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n\n # Examples\n\n ```rust\n use std::ptr;\n\n // create a slice pointer when starting out with a pointer to the first element\n let x = [5, 6, 7];\n let raw_pointer = x.as_ptr();\n let slice = ptr::slice_from_raw_parts(raw_pointer, 3);\n assert_eq!(unsafe { &*slice }[2], 7);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *const [u8] = ptr::slice_from_raw_parts(ptr::null(), 0);\n unsafe {\n     danger.as_ref().expect(\"references must not be null\");\n }\n ```\n",
      "adt": {}
    },
    "core_arch::x86::kl::aesdecwide128kl": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128i": [
      "Plain"
    ],
    "core_arch::x86::kl::WideAesOutput": [
      "Plain",
      "Unknown([Field(0, Ty { id: 46, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Field(1, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(2, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(3, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(4, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(5, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(6, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(7, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(8, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])"
    ]
  },
  "path": 11507,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/kl.rs:290:1: 301:2",
  "src": "pub unsafe fn _mm_aesdecwide128kl_u8(\n    output: *mut __m128i,\n    input: *const __m128i,\n    handle: *const u8,\n) -> u8 {\n    let input = &*ptr::slice_from_raw_parts(input, 8);\n    let WideAesOutput(status, out0, out1, out2, out3, out4, out5, out6, out7) = aesdecwide128kl(\n        handle, input[0], input[1], input[2], input[3], input[4], input[5], input[6], input[7],\n    );\n    *output.cast() = [out0, out1, out2, out3, out4, out5, out6, out7];\n    status\n}",
  "mir": "fn core_arch::x86::kl::_mm_aesdecwide128kl_u8(_1: *mut core_arch::x86::__m128i, _2: *const core_arch::x86::__m128i, _3: *const u8) -> u8 {\n    let mut _0: u8;\n    let  _4: &[core_arch::x86::__m128i];\n    let  _5: *const [core_arch::x86::__m128i];\n    let  _6: core_arch::x86::__m128i;\n    let  _7: core_arch::x86::__m128i;\n    let  _8: core_arch::x86::__m128i;\n    let  _9: core_arch::x86::__m128i;\n    let  _10: core_arch::x86::__m128i;\n    let  _11: core_arch::x86::__m128i;\n    let  _12: core_arch::x86::__m128i;\n    let  _13: core_arch::x86::__m128i;\n    let mut _14: core_arch::x86::kl::WideAesOutput;\n    let mut _15: core_arch::x86::__m128i;\n    let  _16: usize;\n    let mut _17: usize;\n    let mut _18: bool;\n    let mut _19: core_arch::x86::__m128i;\n    let  _20: usize;\n    let mut _21: usize;\n    let mut _22: bool;\n    let mut _23: core_arch::x86::__m128i;\n    let  _24: usize;\n    let mut _25: usize;\n    let mut _26: bool;\n    let mut _27: core_arch::x86::__m128i;\n    let  _28: usize;\n    let mut _29: usize;\n    let mut _30: bool;\n    let mut _31: core_arch::x86::__m128i;\n    let  _32: usize;\n    let mut _33: usize;\n    let mut _34: bool;\n    let mut _35: core_arch::x86::__m128i;\n    let  _36: usize;\n    let mut _37: usize;\n    let mut _38: bool;\n    let mut _39: core_arch::x86::__m128i;\n    let  _40: usize;\n    let mut _41: usize;\n    let mut _42: bool;\n    let mut _43: core_arch::x86::__m128i;\n    let  _44: usize;\n    let mut _45: usize;\n    let mut _46: bool;\n    let mut _47: *mut [core_arch::x86::__m128i; 8];\n    debug output => _1;\n    debug input => _2;\n    debug handle => _3;\n    debug input => _4;\n    debug status => _0;\n    debug out0 => _6;\n    debug out1 => _7;\n    debug out2 => _8;\n    debug out3 => _9;\n    debug out4 => _10;\n    debug out5 => _11;\n    debug out6 => _12;\n    debug out7 => _13;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ptr::slice_from_raw_parts::<core_arch::x86::__m128i>(_2, 8_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = &(*_5);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = 0_usize;\n        _17 = PtrMetadata(_4);\n        _18 = Lt(_16, _17);\n        assert(move _18, \"index out of bounds: the length is {} but the index is {}\", move _17, _16) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _15 = (*_4)[_16];\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = 1_usize;\n        _21 = PtrMetadata(_4);\n        _22 = Lt(_20, _21);\n        assert(move _22, \"index out of bounds: the length is {} but the index is {}\", move _21, _20) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _19 = (*_4)[_20];\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = 2_usize;\n        _25 = PtrMetadata(_4);\n        _26 = Lt(_24, _25);\n        assert(move _26, \"index out of bounds: the length is {} but the index is {}\", move _25, _24) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _23 = (*_4)[_24];\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = 3_usize;\n        _29 = PtrMetadata(_4);\n        _30 = Lt(_28, _29);\n        assert(move _30, \"index out of bounds: the length is {} but the index is {}\", move _29, _28) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _27 = (*_4)[_28];\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = 4_usize;\n        _33 = PtrMetadata(_4);\n        _34 = Lt(_32, _33);\n        assert(move _34, \"index out of bounds: the length is {} but the index is {}\", move _33, _32) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _31 = (*_4)[_32];\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = 5_usize;\n        _37 = PtrMetadata(_4);\n        _38 = Lt(_36, _37);\n        assert(move _38, \"index out of bounds: the length is {} but the index is {}\", move _37, _36) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _35 = (*_4)[_36];\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = 6_usize;\n        _41 = PtrMetadata(_4);\n        _42 = Lt(_40, _41);\n        assert(move _42, \"index out of bounds: the length is {} but the index is {}\", move _41, _40) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _39 = (*_4)[_40];\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = 7_usize;\n        _45 = PtrMetadata(_4);\n        _46 = Lt(_44, _45);\n        assert(move _46, \"index out of bounds: the length is {} but the index is {}\", move _45, _44) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _43 = (*_4)[_44];\n        _14 = core_arch::x86::kl::aesdecwide128kl(_3, move _15, move _19, move _23, move _27, move _31, move _35, move _39, move _43) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_43);\n        StorageDead(_39);\n        StorageDead(_35);\n        StorageDead(_31);\n        StorageDead(_27);\n        StorageDead(_23);\n        StorageDead(_19);\n        StorageDead(_15);\n        _0 = (_14.0: u8);\n        _6 = (_14.1: core_arch::x86::__m128i);\n        _7 = (_14.2: core_arch::x86::__m128i);\n        _8 = (_14.3: core_arch::x86::__m128i);\n        _9 = (_14.4: core_arch::x86::__m128i);\n        _10 = (_14.5: core_arch::x86::__m128i);\n        _11 = (_14.6: core_arch::x86::__m128i);\n        _12 = (_14.7: core_arch::x86::__m128i);\n        _13 = (_14.8: core_arch::x86::__m128i);\n        StorageDead(_44);\n        StorageDead(_40);\n        StorageDead(_36);\n        StorageDead(_32);\n        StorageDead(_28);\n        StorageDead(_24);\n        StorageDead(_20);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageLive(_47);\n        _47 = ptr::mut_ptr::<impl *mut core_arch::x86::__m128i>::cast::<[core_arch::x86::__m128i; 8]>(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        (*_47) = [_6, _7, _8, _9, _10, _11, _12, _13];\n        StorageDead(_47);\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Decrypt 10 rounds of 8 groups of unsigned 8-bit integers in `input` using 128-bit AES key specified\n in the 384-bit key handle `handle`. Store the resulting unsigned 8-bit integers into the corresponding\n elements of `output`. Returns `0` if the operation was successful, and `1` if the operation failed\n due to a handle violation.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_aesdecwide128kl_u8)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}