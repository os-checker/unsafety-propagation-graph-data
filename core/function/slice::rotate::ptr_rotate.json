{
  "name": "slice::rotate::ptr_rotate",
  "safe": false,
  "callees": {
    "slice::rotate::const_min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "slice::rotate::ptr_rotate_memmove": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Algorithm 1 is used if `min(left, right)` is small enough to fit onto a stack buffer. The\n `min(left, right)` elements are copied onto the buffer, `memmove` is applied to the others, and\n the ones on the buffer are moved back into the hole on the opposite side of where they\n originated.\n\n # Safety\n\n The specified range must be valid for reading and writing.\n",
      "adt": {}
    },
    "slice::rotate::ptr_rotate_gcd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Algorithm 2 is used for small values of `left + right` or for large `T`. The elements\n are moved into their final positions one at a time starting at `mid - left` and advancing by\n `right` steps modulo `left + right`, such that only one temporary is needed. Eventually, we\n arrive back at `mid - left`. However, if `gcd(left + right, right)` is not 1, the above steps\n skipped over elements. For example:\n ```text\n left = 10, right = 6\n the `^` indicates an element in its final place\n 6 7 8 9 10 11 12 13 14 15 . 0 1 2 3 4 5\n after using one step of the above algorithm (The X will be overwritten at the end of the round,\n and 12 is stored in a temporary):\n X 7 8 9 10 11 6 13 14 15 . 0 1 2 3 4 5\n               ^\n after using another step (now 2 is in the temporary):\n X 7 8 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n               ^                 ^\n after the third step (the steps wrap around, and 8 is in the temporary):\n X 7 2 9 10 11 6 13 14 15 . 0 1 12 3 4 5\n     ^         ^                 ^\n after 7 more steps, the round ends with the temporary 0 getting put in the X:\n 0 7 2 9 4 11 6 13 8 15 . 10 1 12 3 14 5\n ^   ^   ^    ^    ^       ^    ^    ^\n ```\n Fortunately, the number of skipped over elements between finalized elements is always equal, so\n we can just offset our starting position and do more rounds (the total number of rounds is the\n `gcd(left + right, right)` value). The end result is that all elements are finalized once and\n only once.\n\n Algorithm 2 can be vectorized by chunking and performing many rounds at once, but there are too\n few rounds on average until `left + right` is enormous, and the worst case of a single\n round is always there.\n\n # Safety\n\n The specified range must be valid for reading and writing.\n",
      "adt": {}
    },
    "slice::rotate::ptr_rotate_swap": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Algorithm 3 utilizes repeated swapping of `min(left, right)` elements.\n\n ///\n ```text\n left = 11, right = 4\n [4 5 6 7 8 9 10 11 12 13 14 . 0 1 2 3]\n                  ^  ^  ^  ^   ^ ^ ^ ^ swapping the right most elements with elements to the left\n [4 5 6 7 8 9 10 . 0 1 2 3] 11 12 13 14\n        ^ ^ ^  ^   ^ ^ ^ ^ swapping these\n [4 5 6 . 0 1 2 3] 7 8 9 10 11 12 13 14\n we cannot swap any more, but a smaller rotation problem is left to solve\n ```\n when `left < right` the swapping happens from the left instead.\n\n # Safety\n\n The specified range must be valid for reading and writing.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 16648,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/rotate.rs:14:1: 38:2",
  "src": "pub(super) const unsafe fn ptr_rotate<T>(left: usize, mid: *mut T, right: usize) {\n    if T::IS_ZST {\n        return;\n    }\n    // abort early if the rotate is a no-op\n    if (left == 0) || (right == 0) {\n        return;\n    }\n    // `T` is not a zero-sized type, so it's okay to divide by its size.\n    if !cfg!(feature = \"optimize_for_size\")\n        // FIXME(const-hack): Use cmp::min when available in const\n        && const_min(left, right) <= size_of::<BufType>() / size_of::<T>()\n    {\n        // SAFETY: guaranteed by the caller\n        unsafe { ptr_rotate_memmove(left, mid, right) };\n    } else if !cfg!(feature = \"optimize_for_size\")\n        && ((left + right < 24) || (size_of::<T>() > size_of::<[usize; 4]>()))\n    {\n        // SAFETY: guaranteed by the caller\n        unsafe { ptr_rotate_gcd(left, mid, right) }\n    } else {\n        // SAFETY: guaranteed by the caller\n        unsafe { ptr_rotate_swap(left, mid, right) }\n    }\n}",
  "mir": "fn slice::rotate::ptr_rotate(_1: usize, _2: *mut T, _3: usize) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: bool;\n    let  _10: ();\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: (usize, bool);\n    let mut _14: bool;\n    let mut _15: usize;\n    let mut _16: usize;\n    debug left => _1;\n    debug mid => _2;\n    debug right => _3;\n    bb0: {\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        goto -> bb27;\n    }\n    bb2: {\n        switchInt(_1) -> [0: bb3, otherwise: bb4];\n    }\n    bb3: {\n        goto -> bb7;\n    }\n    bb4: {\n        switchInt(_3) -> [0: bb5, otherwise: bb6];\n    }\n    bb5: {\n        goto -> bb7;\n    }\n    bb6: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = slice::rotate::const_min(_1, _3) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb27;\n    }\n    bb8: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = mem::size_of::<[usize; 32]>() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_8);\n        _8 = mem::size_of::<T>() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _9 = Eq(_8, 0_usize);\n        assert(!move _9, \"attempt to divide `{}` by zero\", _7) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _6 = Div(move _7, move _8);\n        StorageDead(_8);\n        StorageDead(_7);\n        _4 = Le(move _5, move _6);\n        switchInt(move _4) -> [0: bb14, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _10 = slice::rotate::ptr_rotate_memmove::<T>(_1, _2, _3) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        goto -> bb26;\n    }\n    bb14: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_11);\n        StorageLive(_12);\n        _13 = CheckedAdd(_1, _3);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _1, _3) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _12 = move (_13.0: usize);\n        _11 = Lt(move _12, 24_usize);\n        switchInt(move _11) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_12);\n        goto -> bb21;\n    }\n    bb17: {\n        StorageDead(_12);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = mem::size_of::<T>() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_16);\n        _16 = mem::size_of::<[usize; 4]>() -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _14 = Gt(move _15, move _16);\n        switchInt(move _14) -> [0: bb23, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_16);\n        StorageDead(_15);\n        goto -> bb21;\n    }\n    bb21: {\n        _0 = slice::rotate::ptr_rotate_gcd::<T>(_1, _2, _3) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        goto -> bb25;\n    }\n    bb23: {\n        StorageDead(_16);\n        StorageDead(_15);\n        _0 = slice::rotate::ptr_rotate_swap::<T>(_1, _2, _3) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_14);\n        StorageDead(_11);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_4);\n        goto -> bb27;\n    }\n    bb27: {\n        return;\n    }\n}\n",
  "doc": " Rotates the range `[mid-left, mid+right)` such that the element at `mid` becomes the first\n element. Equivalently, rotates the range `left` elements to the left or `right` elements to the\n right.\n\n # Safety\n\n The specified range must be valid for reading and writing.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}