{
  "name": "str::<impl str>::escape_debug",
  "safe": true,
  "callees": {
    "str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"yÃÜ\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {
        "str::iter::Chars": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::flatten": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that flattens nested structure.\n\n This is useful when you have an iterator of iterators or an iterator of\n things that can be turned into iterators and you want to remove one\n level of indirection.\n\n # Examples\n\n Basic usage:\n\n ```\n let data = vec![vec![1, 2, 3, 4], vec![5, 6]];\n let flattened: Vec<_> = data.into_iter().flatten().collect();\n assert_eq!(flattened, [1, 2, 3, 4, 5, 6]);\n ```\n\n Mapping and then flattening:\n\n ```\n let words = [\"alpha\", \"beta\", \"gamma\"];\n\n // chars() returns an iterator\n let merged: String = words.iter()\n                           .map(|s| s.chars())\n                           .flatten()\n                           .collect();\n assert_eq!(merged, \"alphabetagamma\");\n ```\n\n You can also rewrite this in terms of [`flat_map()`], which is preferable\n in this case since it conveys intent more clearly:\n\n ```\n let words = [\"alpha\", \"beta\", \"gamma\"];\n\n // chars() returns an iterator\n let merged: String = words.iter()\n                           .flat_map(|s| s.chars())\n                           .collect();\n assert_eq!(merged, \"alphabetagamma\");\n ```\n\n Flattening works on any `IntoIterator` type, including `Option` and `Result`:\n\n ```\n let options = vec![Some(123), Some(321), None, Some(231)];\n let flattened_options: Vec<_> = options.into_iter().flatten().collect();\n assert_eq!(flattened_options, [123, 321, 231]);\n\n let results = vec![Ok(123), Ok(321), Err(456), Ok(231)];\n let flattened_results: Vec<_> = results.into_iter().flatten().collect();\n assert_eq!(flattened_results, [123, 321, 231]);\n ```\n\n Flattening only removes one level of nesting at a time:\n\n ```\n let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n\n let d2: Vec<_> = d3.into_iter().flatten().collect();\n assert_eq!(d2, [[1, 2], [3, 4], [5, 6], [7, 8]]);\n\n let d1: Vec<_> = d3.into_iter().flatten().flatten().collect();\n assert_eq!(d1, [1, 2, 3, 4, 5, 6, 7, 8]);\n ```\n\n Here we see that `flatten()` does not perform a \"deep\" flatten.\n Instead, only one level of nesting is removed. That is, if you\n `flatten()` a three-dimensional array, the result will be\n two-dimensional and not one-dimensional. To get a one-dimensional\n structure, you have to `flatten()` again.\n\n [`flat_map()`]: Iterator::flat_map\n",
      "adt": {
        "iter::adapters::flatten::Flatten": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::flat_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that works like map, but flattens nested structure.\n\n The [`map`] adapter is very useful, but only when the closure\n argument produces values. If it produces an iterator instead, there's\n an extra layer of indirection. `flat_map()` will remove this extra layer\n on its own.\n\n You can think of `flat_map(f)` as the semantic equivalent\n of [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.\n\n Another way of thinking about `flat_map()`: [`map`]'s closure returns\n one item for each element, and `flat_map()`'s closure returns an\n iterator for each element.\n\n [`map`]: Iterator::map\n [`flatten`]: Iterator::flatten\n\n # Examples\n\n ```\n let words = [\"alpha\", \"beta\", \"gamma\"];\n\n // chars() returns an iterator\n let merged: String = words.iter()\n                           .flat_map(|s| s.chars())\n                           .collect();\n assert_eq!(merged, \"alphabetagamma\");\n ```\n",
      "adt": {
        "iter::adapters::flatten::FlatMap": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::chain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes two iterators and creates a new iterator over both in sequence.\n\n `chain()` will return a new iterator which will first iterate over\n values from the first iterator and then over values from the second\n iterator.\n\n In other words, it links two iterators together, in a chain. üîó\n\n [`once`] is commonly used to adapt a single value into a chain of\n other kinds of iteration.\n\n # Examples\n\n Basic usage:\n\n ```\n let s1 = \"abc\".chars();\n let s2 = \"def\".chars();\n\n let mut iter = s1.chain(s2);\n\n assert_eq!(iter.next(), Some('a'));\n assert_eq!(iter.next(), Some('b'));\n assert_eq!(iter.next(), Some('c'));\n assert_eq!(iter.next(), Some('d'));\n assert_eq!(iter.next(), Some('e'));\n assert_eq!(iter.next(), Some('f'));\n assert_eq!(iter.next(), None);\n ```\n\n Since the argument to `chain()` uses [`IntoIterator`], we can pass\n anything that can be converted into an [`Iterator`], not just an\n [`Iterator`] itself. For example, arrays (`[T]`) implement\n [`IntoIterator`], and so can be passed to `chain()` directly:\n\n ```\n let a1 = [1, 2, 3];\n let a2 = [4, 5, 6];\n\n let mut iter = a1.into_iter().chain(a2);\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(5));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you work with Windows API, you may wish to convert [`OsStr`] to `Vec<u16>`:\n\n ```\n #[cfg(windows)]\n fn os_str_to_utf16(s: &std::ffi::OsStr) -> Vec<u16> {\n     use std::os::windows::ffi::OsStrExt;\n     s.encode_wide().chain(std::iter::once(0)).collect()\n }\n ```\n\n [`once`]: crate::iter::once\n [`OsStr`]: ../../std/ffi/struct.OsStr.html\n",
      "adt": {
        "iter::adapters::chain::Chain": "Constructor"
      }
    }
  },
  "adts": {
    "str::iter::Chars": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain"
    ],
    "option::IntoIter": [
      "Plain"
    ],
    "iter::adapters::flatten::Flatten": [
      "Plain"
    ],
    "iter::adapters::flatten::FlatMap": [
      "Plain"
    ],
    "iter::adapters::chain::Chain": [
      "Plain"
    ],
    "str::iter::EscapeDebug": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::str::<impl str>::escape_debug"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:2997:5: 3007:6",
  "src": "pub fn escape_debug(&self) -> EscapeDebug<'_> {\n        let mut chars = self.chars();\n        EscapeDebug {\n            inner: chars\n                .next()\n                .map(|first| first.escape_debug_ext(EscapeDebugExtArgs::ESCAPE_ALL))\n                .into_iter()\n                .flatten()\n                .chain(chars.flat_map(CharEscapeDebugContinue)),\n        }\n    }",
  "mir": "fn str::<impl str>::escape_debug(_1: &str) -> str::iter::EscapeDebug<'_> {\n    let mut _0: str::iter::EscapeDebug<'_>;\n    let mut _2: str::iter::Chars<'_>;\n    let mut _3: iter::adapters::chain::Chain<iter::adapters::flatten::Flatten<option::IntoIter<char::EscapeDebug>>, iter::adapters::flatten::FlatMap<str::iter::Chars<'_>, char::EscapeDebug, str::CharEscapeDebugContinue>>;\n    let mut _4: iter::adapters::flatten::Flatten<option::IntoIter<char::EscapeDebug>>;\n    let mut _5: option::IntoIter<char::EscapeDebug>;\n    let mut _6: option::Option<char::EscapeDebug>;\n    let mut _7: option::Option<char>;\n    let mut _8: &mut str::iter::Chars<'_>;\n    let mut _9: iter::adapters::flatten::FlatMap<str::iter::Chars<'_>, char::EscapeDebug, str::CharEscapeDebugContinue>;\n    let mut _10: str::iter::Chars<'_>;\n    debug self => _1;\n    debug chars => _2;\n    bb0: {\n        StorageLive(_2);\n        _2 = str::<impl str>::chars(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &mut _2;\n        _7 = <str::iter::Chars<'_> as iter::traits::iterator::Iterator>::next(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _6 = option::Option::<char>::map::<char::EscapeDebug, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:3002:22: 3002:29}>(move _7, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:3002:22: 3002:29}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        _5 = <option::Option<char::EscapeDebug> as iter::traits::collect::IntoIterator>::into_iter(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        _4 = <option::IntoIter<char::EscapeDebug> as iter::traits::iterator::Iterator>::flatten(move _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = move _2;\n        _9 = <str::iter::Chars<'_> as iter::traits::iterator::Iterator>::flat_map::<char::EscapeDebug, str::CharEscapeDebugContinue>(move _10, str::CharEscapeDebugContinue) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _3 = <iter::adapters::flatten::Flatten<option::IntoIter<char::EscapeDebug>> as iter::traits::iterator::Iterator>::chain::<iter::adapters::flatten::FlatMap<str::iter::Chars<'_>, char::EscapeDebug, str::CharEscapeDebugContinue>>(move _4, move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageDead(_4);\n        _0 = EscapeDebug(move _3);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns an iterator that escapes each char in `self` with [`char::escape_debug`].\n\n Note: only extended grapheme codepoints that begin the string will be\n escaped.\n\n # Examples\n\n As an iterator:\n\n ```\n for c in \"‚ù§\\n!\".escape_debug() {\n     print!(\"{c}\");\n }\n println!();\n ```\n\n Using `println!` directly:\n\n ```\n println!(\"{}\", \"‚ù§\\n!\".escape_debug());\n ```\n\n\n Both are equivalent to:\n\n ```\n println!(\"‚ù§\\\\n!\");\n ```\n\n Using `to_string`:\n\n ```\n assert_eq!(\"‚ù§\\n!\".escape_debug().to_string(), \"‚ù§\\\\n!\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}