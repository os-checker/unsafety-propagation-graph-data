{
  "name": "num::int_sqrt::u32_stages",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "num::<impl u16>::overflowing_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates `self` - `rhs`.\n\n Returns a tuple of the subtraction along with a boolean indicating\n whether an arithmetic overflow would occur. If an overflow would\n have occurred then the wrapped value is returned.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u16>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u32>::overflowing_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the multiplication of `self` and `rhs`.\n\n Returns a tuple of the multiplication along with a boolean\n indicating whether an arithmetic overflow would occur. If an\n overflow would have occurred then the wrapped value is returned.\n\n If you want the *value* of the overflow, rather than just *whether*\n an overflow occurred, see [`Self::carrying_mul`].\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u32` is used.\n\n ```\n assert_eq!(5u32.overflowing_mul(2), (10, false));\n assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 14926,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_sqrt.rs:270:1: 274:2",
  "src": "const fn u32_stages(n: u32) -> u32 {\n    let (s, r) = first_stage!(32, n);\n    let (s, r) = middle_stage!(32, u16, n, s, r);\n    last_stage!(u32, n, s, r)\n}",
  "mir": "fn num::int_sqrt::u32_stages(_1: u32) -> u32 {\n    let mut _0: u32;\n    let  _2: u8;\n    let  _3: u8;\n    let mut _4: (u8, u8);\n    let  _5: !;\n    let mut _6: fmt::Arguments<'_>;\n    let  _7: u32;\n    let mut _8: bool;\n    let  _9: u8;\n    let  _10: u8;\n    let mut _11: [(u8, u8); 256];\n    let  _12: usize;\n    let mut _13: bool;\n    let  _14: ();\n    let mut _15: bool;\n    let  _16: u16;\n    let  _17: u16;\n    let mut _18: (u16, u16);\n    let  _19: !;\n    let mut _20: fmt::Arguments<'_>;\n    let  _21: u16;\n    let mut _22: u32;\n    let mut _23: bool;\n    let  _24: u16;\n    let  _25: u16;\n    let mut _26: u16;\n    let mut _27: u16;\n    let mut _28: bool;\n    let mut _29: u16;\n    let mut _30: bool;\n    let  _31: u16;\n    let mut _32: u16;\n    let mut _33: u32;\n    let mut _34: bool;\n    let  _35: u16;\n    let mut _36: bool;\n    let  _37: u16;\n    let mut _38: bool;\n    let mut _39: u16;\n    let mut _40: u16;\n    let mut _41: u8;\n    let mut _42: bool;\n    let mut _43: (u16, bool);\n    let mut _44: u16;\n    let  _45: bool;\n    let mut _46: (u16, bool);\n    let mut _47: u16;\n    let mut _48: u16;\n    let mut _49: bool;\n    let mut _50: u16;\n    let mut _51: u16;\n    let mut _52: (u16, bool);\n    let mut _53: u16;\n    let mut _54: u16;\n    let mut _55: u16;\n    let mut _56: u16;\n    let mut _57: u16;\n    let mut _58: (u16, bool);\n    let mut _59: (u16, bool);\n    let mut _60: (u16, bool);\n    let  _61: ();\n    let mut _62: bool;\n    let mut _63: u16;\n    let mut _64: u16;\n    let mut _65: u16;\n    let  _66: !;\n    let mut _67: fmt::Arguments<'_>;\n    let  _68: u32;\n    let  _69: u32;\n    let mut _70: u32;\n    let mut _71: u32;\n    let mut _72: bool;\n    let mut _73: u32;\n    let mut _74: bool;\n    let  _75: u32;\n    let mut _76: u32;\n    let mut _77: u32;\n    let mut _78: bool;\n    let  _79: u32;\n    let mut _80: bool;\n    let mut _81: u32;\n    let mut _82: u32;\n    let mut _83: u16;\n    let mut _84: bool;\n    let mut _85: (u32, bool);\n    let  _86: u32;\n    let  _87: bool;\n    let mut _88: (u32, bool);\n    let mut _89: u32;\n    let mut _90: u32;\n    let mut _91: bool;\n    let mut _92: (u32, bool);\n    debug n => _1;\n    debug s => _2;\n    debug r => _3;\n    debug n => _7;\n    debug s => _9;\n    debug r => _10;\n    debug s => _16;\n    debug r => _17;\n    debug n => _21;\n    debug lo => _24;\n    debug numerator => _25;\n    debug denominator => _31;\n    debug q => _35;\n    debug u => _37;\n    debug s => _39;\n    debug r => _44;\n    debug overflow => _45;\n    debug lo => _68;\n    debug numerator => _69;\n    debug denominator => _75;\n    debug q => _79;\n    debug s => _81;\n    debug s_squared => _86;\n    debug overflow => _87;\n    bb0: {\n        StorageLive(_4);\n        switchInt(_1) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _8 = Lt(num::int_sqrt::u32_stages::N_SHIFT, 32_u32);\n        assert(move _8, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u32_stages::N_SHIFT) -> [success: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = fmt::Arguments::<'_>::from_str(\"`$n` is  zero in `first_stage!`.\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n    bb4: {\n        _7 = Shr(_1, num::int_sqrt::u32_stages::N_SHIFT);\n        StorageLive(_11);\n        _11 = num::int_sqrt::U8_ISQRT_WITH_REMAINDER;\n        StorageLive(_12);\n        _12 = _7 as usize;\n        _13 = Lt(_12, 256_usize);\n        assert(move _13, \"index out of bounds: the length is {} but the index is {}\", 256_usize, _12) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = (_11[_12].0: u8);\n        _10 = (_11[_12].1: u8);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = Ne(_9, 0_u8);\n        _14 = hint::assert_unchecked(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _4 = (_9, _10);\n        _2 = (_4.0: u8);\n        _3 = (_4.1: u8);\n        StorageDead(_4);\n        StorageLive(_18);\n        switchInt(_2) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_22);\n        _23 = Lt(num::int_sqrt::u32_stages::N_SHIFT, 32_u32);\n        assert(move _23, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u32_stages::N_SHIFT) -> [success: bb10, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_20);\n        _20 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `middle_stage!`.\") -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _19 = panicking::panic_fmt(move _20) -> unwind unreachable;\n    }\n    bb10: {\n        _22 = Shr(_1, num::int_sqrt::u32_stages::N_SHIFT);\n        _21 = move _22 as u16;\n        StorageDead(_22);\n        _24 = BitAnd(_21, num::int_sqrt::u32_stages::LOWER_HALF_1_BITS);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _3 as u16;\n        _28 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 16_u32);\n        assert(move _28, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _26 = Shl(move _27, num::int_sqrt::u32_stages::QUARTER_BITS);\n        StorageDead(_27);\n        StorageLive(_29);\n        _30 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 16_u32);\n        assert(move _30, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _29 = Shr(_24, num::int_sqrt::u32_stages::QUARTER_BITS);\n        _25 = BitOr(move _26, move _29);\n        StorageDead(_29);\n        StorageDead(_26);\n        StorageLive(_32);\n        _32 = _2 as u16;\n        _33 = 1_i32 as u32;\n        _34 = Lt(move _33, 16_u32);\n        assert(move _34, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _31 = Shl(move _32, 1_i32);\n        StorageDead(_32);\n        _36 = Eq(_31, 0_u16);\n        assert(!move _36, \"attempt to divide `{}` by zero\", _25) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _35 = Div(_25, _31);\n        _38 = Eq(_31, 0_u16);\n        assert(!move _38, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _25) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _37 = Rem(_25, _31);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _42 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 8_u32);\n        assert(move _42, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _41 = Shl(_2, num::int_sqrt::u32_stages::QUARTER_BITS);\n        _40 = move _41 as u16;\n        StorageDead(_41);\n        _43 = CheckedAdd(_40, _35);\n        assert(!move (_43.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _40, _35) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _39 = move (_43.0: u16);\n        StorageDead(_40);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _49 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 16_u32);\n        assert(move _49, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _48 = Shl(_37, num::int_sqrt::u32_stages::QUARTER_BITS);\n        StorageLive(_50);\n        _50 = BitAnd(_24, num::int_sqrt::u32_stages::LOWEST_QUARTER_1_BITS);\n        _47 = BitOr(move _48, move _50);\n        StorageDead(_50);\n        StorageDead(_48);\n        StorageLive(_51);\n        _52 = CheckedMul(_35, _35);\n        assert(!move (_52.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _35, _35) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _51 = move (_52.0: u16);\n        _46 = num::<impl u16>::overflowing_sub(move _47, move _51) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_51);\n        StorageDead(_47);\n        StorageLive(_44);\n        _44 = (_46.0: u16);\n        _45 = (_46.1: bool);\n        StorageDead(_46);\n        switchInt(_45) -> [0: bb26, otherwise: bb21];\n    }\n    bb21: {\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = _44;\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = _39;\n        _58 = CheckedMul(2_u16, _57);\n        assert(!move (_58.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u16, move _57) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _56 = move (_58.0: u16);\n        StorageDead(_57);\n        _59 = CheckedSub(_56, 1_u16);\n        assert(!move (_59.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _56, 1_u16) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _55 = move (_59.0: u16);\n        StorageDead(_56);\n        _53 = num::<impl u16>::wrapping_add(move _54, move _55) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_55);\n        StorageDead(_54);\n        _44 = move _53;\n        StorageDead(_53);\n        _60 = CheckedSub(_39, 1_u16);\n        assert(!move (_60.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _39, 1_u16) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _39 = move (_60.0: u16);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = _39;\n        _62 = Ne(move _63, 0_u16);\n        StorageDead(_63);\n        _61 = hint::assert_unchecked(move _62) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_62);\n        StorageLive(_64);\n        _64 = _39;\n        StorageLive(_65);\n        _65 = _44;\n        _18 = (move _64, move _65);\n        StorageDead(_65);\n        StorageDead(_64);\n        StorageDead(_44);\n        StorageDead(_39);\n        _16 = (_18.0: u16);\n        _17 = (_18.1: u16);\n        StorageDead(_18);\n        switchInt(_16) -> [0: bb29, otherwise: bb28];\n    }\n    bb28: {\n        _68 = BitAnd(_1, num::int_sqrt::u32_stages::LOWER_HALF_1_BITS);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = _17 as u32;\n        _72 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 32_u32);\n        assert(move _72, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb31, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_67);\n        _67 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `last_stage!`.\") -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        _66 = panicking::panic_fmt(move _67) -> unwind unreachable;\n    }\n    bb31: {\n        _70 = Shl(move _71, num::int_sqrt::u32_stages::QUARTER_BITS);\n        StorageDead(_71);\n        StorageLive(_73);\n        _74 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 32_u32);\n        assert(move _74, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _73 = Shr(_68, num::int_sqrt::u32_stages::QUARTER_BITS);\n        _69 = BitOr(move _70, move _73);\n        StorageDead(_73);\n        StorageDead(_70);\n        StorageLive(_76);\n        _76 = _16 as u32;\n        _77 = 1_i32 as u32;\n        _78 = Lt(move _77, 32_u32);\n        assert(move _78, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _75 = Shl(move _76, 1_i32);\n        StorageDead(_76);\n        _80 = Eq(_75, 0_u32);\n        assert(!move _80, \"attempt to divide `{}` by zero\", _69) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _79 = Div(_69, _75);\n        StorageLive(_81);\n        StorageLive(_82);\n        StorageLive(_83);\n        _84 = Lt(num::int_sqrt::u32_stages::QUARTER_BITS, 16_u32);\n        assert(move _84, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u32_stages::QUARTER_BITS) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _83 = Shl(_16, num::int_sqrt::u32_stages::QUARTER_BITS);\n        _82 = move _83 as u32;\n        StorageDead(_83);\n        _85 = CheckedAdd(_82, _79);\n        assert(!move (_85.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _82, _79) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _81 = move (_85.0: u32);\n        StorageDead(_82);\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = _81;\n        StorageLive(_90);\n        _90 = _81;\n        _88 = num::<impl u32>::overflowing_mul(move _89, move _90) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_90);\n        StorageDead(_89);\n        _86 = (_88.0: u32);\n        _87 = (_88.1: bool);\n        StorageDead(_88);\n        switchInt(_87) -> [0: bb38, otherwise: bb40];\n    }\n    bb38: {\n        StorageLive(_91);\n        _91 = Gt(_86, _1);\n        switchInt(move _91) -> [0: bb42, otherwise: bb39];\n    }\n    bb39: {\n        goto -> bb40;\n    }\n    bb40: {\n        _92 = CheckedSub(_81, 1_u32);\n        assert(!move (_92.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _81, 1_u32) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _81 = move (_92.0: u32);\n        goto -> bb43;\n    }\n    bb42: {\n        goto -> bb43;\n    }\n    bb43: {\n        StorageDead(_91);\n        _0 = _81;\n        StorageDead(_81);\n        return;\n    }\n}\n",
  "doc": " Takes the normalized [`u32`](prim@u32) input and gets its normalized\n [integer square root](https://en.wikipedia.org/wiki/Integer_square_root).\n\n # Safety\n\n `n` must be nonzero.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}