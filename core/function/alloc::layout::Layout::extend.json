{
  "name": "alloc::layout::Layout::extend",
  "safe": true,
  "callees": {
    "ptr::alignment::Alignment::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ptr::alignment::Alignment": "Constructor"
      }
    },
    "alloc::layout::Layout::size_rounded_up_to_custom_align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the smallest multiple of `align` greater than or equal to `self.size()`.\n\n This can return at most `Alignment::MAX` (aka `isize::MAX + 1`)\n because the original size is at most `isize::MAX`.\n",
      "adt": {
        "alloc::layout::Layout": "ImmutableAsArgument"
      }
    },
    "alloc::layout::Layout::from_size_alignment": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Internal helper constructor to skip revalidating alignment validity.\n",
      "adt": {
        "alloc::layout::Layout": "Constructor",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "ptr::alignment::Alignment": [
      "Plain"
    ],
    "alloc::layout::Layout": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Unknown([Field(1, Ty { id: 1733, kind: RigidTy(Adt(AdtDef(DefId { id: 25068, name: \"ptr::alignment::Alignment\" }), GenericArgs([]))) })])",
      "Ref",
      "Unknown([Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Plain"
    ],
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1820, kind: RigidTy(Adt(AdtDef(DefId { id: 25090, name: \"alloc::layout::Layout\" }), GenericArgs([]))) })])"
    ]
  },
  "path": 4446,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/layout.rs:416:5: 431:6",
  "src": "pub const fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {\n        let new_align = Alignment::max(self.align, next.align);\n        let offset = self.size_rounded_up_to_custom_align(next.align);\n\n        // SAFETY: `offset` is at most `isize::MAX + 1` (such as from aligning\n        // to `Alignment::MAX`) and `next.size` is at most `isize::MAX` (from the\n        // `Layout` type invariant).  Thus the largest possible `new_size` is\n        // `isize::MAX + 1 + isize::MAX`, which is `usize::MAX`, and cannot overflow.\n        let new_size = unsafe { unchecked_add(offset, next.size) };\n\n        if let Ok(layout) = Layout::from_size_alignment(new_size, new_align) {\n            Ok((layout, offset))\n        } else {\n            Err(LayoutError)\n        }\n    }",
  "mir": "fn alloc::layout::Layout::extend(_1: &alloc::layout::Layout, _2: alloc::layout::Layout) -> result::Result<(alloc::layout::Layout, usize), alloc::layout::LayoutError> {\n    let mut _0: result::Result<(alloc::layout::Layout, usize), alloc::layout::LayoutError>;\n    let  _3: ptr::alignment::Alignment;\n    let mut _4: ptr::alignment::Alignment;\n    let mut _5: ptr::alignment::Alignment;\n    let  _6: usize;\n    let mut _7: ptr::alignment::Alignment;\n    let  _8: usize;\n    let mut _9: usize;\n    let mut _10: result::Result<alloc::layout::Layout, alloc::layout::LayoutError>;\n    let mut _11: isize;\n    let  _12: alloc::layout::Layout;\n    let mut _13: (alloc::layout::Layout, usize);\n    debug self => _1;\n    debug next => _2;\n    debug new_align => _3;\n    debug offset => _6;\n    debug new_size => _8;\n    debug layout => _12;\n    bb0: {\n        StorageLive(_4);\n        _4 = ((*_1).1: ptr::alignment::Alignment);\n        StorageLive(_5);\n        _5 = (_2.1: ptr::alignment::Alignment);\n        _3 = ptr::alignment::Alignment::max(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = (_2.1: ptr::alignment::Alignment);\n        _6 = alloc::layout::Layout::size_rounded_up_to_custom_align(_1, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = (_2.0: usize);\n        _8 = AddUnchecked(_6, move _9);\n        StorageDead(_9);\n        StorageLive(_10);\n        _10 = alloc::layout::Layout::from_size_alignment(_8, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _11 = discriminant(_10);\n        switchInt(move _11) -> [0: bb4, 1: bb5, otherwise: bb7];\n    }\n    bb4: {\n        _12 = ((_10 as variant#0).0: alloc::layout::Layout);\n        StorageLive(_13);\n        _13 = (_12, _6);\n        _0 = result::Result::Ok(move _13);\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb6;\n    }\n    bb5: {\n        StorageDead(_10);\n        _0 = result::Result::Err(alloc::layout::LayoutError);\n        goto -> bb6;\n    }\n    bb6: {\n        return;\n    }\n    bb7: {\n        unreachable;\n    }\n}\n",
  "doc": " Creates a layout describing the record for `self` followed by\n `next`, including any necessary padding to ensure that `next`\n will be properly aligned, but *no trailing padding*.\n\n In order to match C representation layout `repr(C)`, you should\n call `pad_to_align` after extending the layout with all fields.\n (There is no way to match the default Rust representation\n layout `repr(Rust)`, as it is unspecified.)\n\n Note that the alignment of the resulting layout will be the maximum of\n those of `self` and `next`, in order to ensure alignment of both parts.\n\n Returns `Ok((k, offset))`, where `k` is layout of the concatenated\n record and `offset` is the relative location, in bytes, of the\n start of the `next` embedded within the concatenated record\n (assuming that the record itself starts at offset 0).\n\n On arithmetic overflow, returns `LayoutError`.\n\n # Examples\n\n To calculate the layout of a `#[repr(C)]` structure and the offsets of\n the fields from its fields' layouts:\n\n ```rust\n # use std::alloc::{Layout, LayoutError};\n pub fn repr_c(fields: &[Layout]) -> Result<(Layout, Vec<usize>), LayoutError> {\n     let mut offsets = Vec::new();\n     let mut layout = Layout::from_size_align(0, 1)?;\n     for &field in fields {\n         let (new_layout, offset) = layout.extend(field)?;\n         layout = new_layout;\n         offsets.push(offset);\n     }\n     // Remember to finalize with `pad_to_align`!\n     Ok((layout.pad_to_align(), offsets))\n }\n # // test that it works\n # #[repr(C)] struct S { a: u64, b: u32, c: u16, d: u32 }\n # let s = Layout::new::<S>();\n # let u16 = Layout::new::<u16>();\n # let u32 = Layout::new::<u32>();\n # let u64 = Layout::new::<u64>();\n # assert_eq!(repr_c(&[u64, u32, u16, u32]), Ok((s, vec![0, 8, 12, 16])));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}