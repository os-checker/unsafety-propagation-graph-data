{
  "name": "str::pattern::TwoWaySearcher::next",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice depending on the type of\n index.\n\n - If given a position, returns a reference to the element at that\n   position or `None` if out of bounds.\n - If given a range, returns the subslice corresponding to that range,\n   or `None` if out of bounds.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&40), v.get(1));\n assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n assert_eq!(None, v.get(3));\n assert_eq!(None, v.get(0..4));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "str::pattern::TwoWayStrategy::rejecting": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "str::pattern::TwoWayStrategy::use_early_reject": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "str::pattern::TwoWaySearcher::byteset_contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "str::pattern::TwoWaySearcher": "ImmutableAsArgument"
      }
    },
    "cmp::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the maximum of two values.\n\n Returns the second argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::max`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::max(1, 2), 2);\n assert_eq!(cmp::max(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::max(Equal(\"v1\"), Equal(\"v2\")).0, \"v2\");\n ```\n",
      "adt": {}
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::rev::Rev": "Constructor"
      }
    },
    "str::pattern::TwoWayStrategy::matching": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "str::pattern::TwoWaySearcher": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(6)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::Range": [
      "Plain",
      "MutRef"
    ],
    "iter::adapters::rev::Rev": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 17072,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs:1460:5: 1528:6",
  "src": "fn next<S>(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> S::Output\n    where\n        S: TwoWayStrategy,\n    {\n        // `next()` uses `self.position` as its cursor\n        let old_pos = self.position;\n        let needle_last = needle.len() - 1;\n        'search: loop {\n            // Check that we have room to search in\n            // position + needle_last can not overflow if we assume slices\n            // are bounded by isize's range.\n            let tail_byte = match haystack.get(self.position + needle_last) {\n                Some(&b) => b,\n                None => {\n                    self.position = haystack.len();\n                    return S::rejecting(old_pos, self.position);\n                }\n            };\n\n            if S::use_early_reject() && old_pos != self.position {\n                return S::rejecting(old_pos, self.position);\n            }\n\n            // Quickly skip by large portions unrelated to our substring\n            if !self.byteset_contains(tail_byte) {\n                self.position += needle.len();\n                if !long_period {\n                    self.memory = 0;\n                }\n                continue 'search;\n            }\n\n            // See if the right part of the needle matches\n            let start =\n                if long_period { self.crit_pos } else { cmp::max(self.crit_pos, self.memory) };\n            for i in start..needle.len() {\n                if needle[i] != haystack[self.position + i] {\n                    self.position += i - self.crit_pos + 1;\n                    if !long_period {\n                        self.memory = 0;\n                    }\n                    continue 'search;\n                }\n            }\n\n            // See if the left part of the needle matches\n            let start = if long_period { 0 } else { self.memory };\n            for i in (start..self.crit_pos).rev() {\n                if needle[i] != haystack[self.position + i] {\n                    self.position += self.period;\n                    if !long_period {\n                        self.memory = needle.len() - self.period;\n                    }\n                    continue 'search;\n                }\n            }\n\n            // We have found a match!\n            let match_pos = self.position;\n\n            // Note: add self.period instead of needle.len() to have overlapping matches\n            self.position += needle.len();\n            if !long_period {\n                self.memory = 0; // set to needle.len() - self.period for overlapping matches\n            }\n\n            return S::matching(match_pos, match_pos + needle.len());\n        }\n    }",
  "mir": "fn str::pattern::TwoWaySearcher::next(_1: &mut str::pattern::TwoWaySearcher, _2: &[u8], _3: &[u8], _4: bool) -> <S as str::pattern::TwoWayStrategy>::Output {\n    let mut _0: <S as str::pattern::TwoWayStrategy>::Output;\n    let  _5: usize;\n    let  _6: usize;\n    let mut _7: usize;\n    let mut _8: (usize, bool);\n    let mut _9: option::Option<&u8>;\n    let mut _10: usize;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let mut _13: isize;\n    let  _14: u8;\n    let mut _15: usize;\n    let mut _16: usize;\n    let mut _17: bool;\n    let mut _18: bool;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: bool;\n    let mut _22: &str::pattern::TwoWaySearcher;\n    let mut _23: usize;\n    let mut _24: (usize, bool);\n    let  _25: usize;\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: ops::range::Range<usize>;\n    let mut _29: ops::range::Range<usize>;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: ops::range::Range<usize>;\n    let mut _33: option::Option<usize>;\n    let mut _34: &mut ops::range::Range<usize>;\n    let mut _35: isize;\n    let  _36: usize;\n    let mut _37: bool;\n    let mut _38: u8;\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: u8;\n    let  _42: usize;\n    let mut _43: usize;\n    let mut _44: (usize, bool);\n    let mut _45: usize;\n    let mut _46: bool;\n    let mut _47: usize;\n    let mut _48: usize;\n    let mut _49: usize;\n    let mut _50: (usize, bool);\n    let mut _51: (usize, bool);\n    let mut _52: (usize, bool);\n    let  _53: usize;\n    let mut _54: iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _55: iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _56: ops::range::Range<usize>;\n    let mut _57: usize;\n    let mut _58: usize;\n    let mut _59: iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _60: option::Option<usize>;\n    let mut _61: &mut iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _62: isize;\n    let  _63: usize;\n    let mut _64: bool;\n    let mut _65: u8;\n    let mut _66: usize;\n    let mut _67: bool;\n    let mut _68: u8;\n    let  _69: usize;\n    let mut _70: usize;\n    let mut _71: (usize, bool);\n    let mut _72: usize;\n    let mut _73: bool;\n    let mut _74: usize;\n    let mut _75: (usize, bool);\n    let mut _76: usize;\n    let mut _77: usize;\n    let mut _78: (usize, bool);\n    let  _79: usize;\n    let mut _80: usize;\n    let mut _81: (usize, bool);\n    let mut _82: usize;\n    let mut _83: usize;\n    let mut _84: (usize, bool);\n    let mut _85: &u8;\n    debug self => _1;\n    debug haystack => _2;\n    debug needle => _3;\n    debug long_period => _4;\n    debug old_pos => _5;\n    debug needle_last => _6;\n    debug tail_byte => _14;\n    debug b => _14;\n    debug start => _25;\n    debug iter => _32;\n    debug i => _36;\n    debug start => _53;\n    debug iter => _59;\n    debug i => _63;\n    debug match_pos => _79;\n    bb0: {\n        _5 = ((*_1).4: usize);\n        StorageLive(_7);\n        _7 = PtrMetadata(_3);\n        _8 = CheckedSub(_7, 1_usize);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _7, 1_usize) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = move (_8.0: usize);\n        StorageDead(_7);\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = ((*_1).4: usize);\n        _12 = CheckedAdd(_11, _6);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _11, _6) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _10 = move (_12.0: usize);\n        StorageDead(_11);\n        _9 = slice::<impl [u8]>::get::<usize>(_2, move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _13 = discriminant(_9);\n        switchInt(move _13) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_15);\n        _15 = PtrMetadata(_2);\n        ((*_1).4: usize) = move _15;\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = ((*_1).4: usize);\n        _0 = <S as str::pattern::TwoWayStrategy>::rejecting(_5, move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        _85 = ((_9 as variant#1).0: &u8);\n        _14 = (*_85);\n        StorageDead(_9);\n        StorageLive(_17);\n        _17 = <S as str::pattern::TwoWayStrategy>::use_early_reject() -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        StorageDead(_9);\n        goto -> bb65;\n    }\n    bb9: {\n        switchInt(move _17) -> [0: bb14, otherwise: bb10];\n    }\n    bb10: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = ((*_1).4: usize);\n        _18 = Ne(_5, move _19);\n        switchInt(move _18) -> [0: bb13, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = ((*_1).4: usize);\n        _0 = <S as str::pattern::TwoWayStrategy>::rejecting(_5, move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb65;\n    }\n    bb13: {\n        StorageDead(_19);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _21 = str::pattern::TwoWaySearcher::byteset_contains(move _22, _14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _21) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_25);\n        switchInt(_4) -> [0: bb22, otherwise: bb21];\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = PtrMetadata(_3);\n        _24 = CheckedAdd(((*_1).4: usize), _23);\n        assert(!move (_24.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).4: usize), move _23) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        ((*_1).4: usize) = move (_24.0: usize);\n        StorageDead(_23);\n        switchInt(_4) -> [0: bb19, otherwise: bb20];\n    }\n    bb19: {\n        ((*_1).6: usize) = 0_usize;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_21);\n        goto -> bb64;\n    }\n    bb21: {\n        _25 = ((*_1).0: usize);\n        goto -> bb24;\n    }\n    bb22: {\n        StorageLive(_26);\n        _26 = ((*_1).0: usize);\n        StorageLive(_27);\n        _27 = ((*_1).6: usize);\n        _25 = cmp::max::<usize>(move _26, move _27) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_27);\n        StorageDead(_26);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _25;\n        StorageLive(_31);\n        _31 = PtrMetadata(_3);\n        _29 = Range(move _30, move _31);\n        StorageDead(_31);\n        StorageDead(_30);\n        _28 = <ops::range::Range<usize> as iter::traits::collect::IntoIterator>::into_iter(move _29) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_29);\n        StorageLive(_32);\n        _32 = move _28;\n        goto -> bb26;\n    }\n    bb26: {\n        StorageLive(_33);\n        _34 = &mut _32;\n        _33 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::next(_34) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _35 = discriminant(_33);\n        switchInt(move _35) -> [0: bb29, 1: bb28, otherwise: bb5];\n    }\n    bb28: {\n        _36 = ((_33 as variant#1).0: usize);\n        StorageLive(_37);\n        StorageLive(_38);\n        _39 = PtrMetadata(_3);\n        _40 = Lt(_36, _39);\n        assert(move _40, \"index out of bounds: the length is {} but the index is {}\", move _39, _36) -> [success: bb30, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_28);\n        StorageLive(_53);\n        switchInt(_4) -> [0: bb41, otherwise: bb40];\n    }\n    bb30: {\n        _38 = (*_3)[_36];\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = ((*_1).4: usize);\n        _44 = CheckedAdd(_43, _36);\n        assert(!move (_44.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _43, _36) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _42 = move (_44.0: usize);\n        StorageDead(_43);\n        _45 = PtrMetadata(_2);\n        _46 = Lt(_42, _45);\n        assert(move _46, \"index out of bounds: the length is {} but the index is {}\", move _45, _42) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _41 = (*_2)[_42];\n        _37 = Ne(move _38, move _41);\n        switchInt(move _37) -> [0: bb39, otherwise: bb33];\n    }\n    bb33: {\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_38);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = ((*_1).0: usize);\n        _50 = CheckedSub(_36, _49);\n        assert(!move (_50.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _36, move _49) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _48 = move (_50.0: usize);\n        StorageDead(_49);\n        _51 = CheckedAdd(_48, 1_usize);\n        assert(!move (_51.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _48, 1_usize) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _47 = move (_51.0: usize);\n        StorageDead(_48);\n        _52 = CheckedAdd(((*_1).4: usize), _47);\n        assert(!move (_52.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).4: usize), move _47) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        ((*_1).4: usize) = move (_52.0: usize);\n        StorageDead(_47);\n        switchInt(_4) -> [0: bb37, otherwise: bb38];\n    }\n    bb37: {\n        ((*_1).6: usize) = 0_usize;\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_37);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_28);\n        goto -> bb63;\n    }\n    bb39: {\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_33);\n        goto -> bb26;\n    }\n    bb40: {\n        _53 = 0_usize;\n        goto -> bb42;\n    }\n    bb41: {\n        _53 = ((*_1).6: usize);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageLive(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = _53;\n        StorageLive(_58);\n        _58 = ((*_1).0: usize);\n        _56 = Range(move _57, move _58);\n        StorageDead(_58);\n        StorageDead(_57);\n        _55 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::rev(move _56) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_56);\n        _54 = <iter::adapters::rev::Rev<ops::range::Range<usize>> as iter::traits::collect::IntoIterator>::into_iter(move _55) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_55);\n        StorageLive(_59);\n        _59 = move _54;\n        goto -> bb45;\n    }\n    bb45: {\n        StorageLive(_60);\n        _61 = &mut _59;\n        _60 = <iter::adapters::rev::Rev<ops::range::Range<usize>> as iter::traits::iterator::Iterator>::next(_61) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _62 = discriminant(_60);\n        switchInt(move _62) -> [0: bb48, 1: bb47, otherwise: bb5];\n    }\n    bb47: {\n        _63 = ((_60 as variant#1).0: usize);\n        StorageLive(_64);\n        StorageLive(_65);\n        _66 = PtrMetadata(_3);\n        _67 = Lt(_63, _66);\n        assert(move _67, \"index out of bounds: the length is {} but the index is {}\", move _66, _63) -> [success: bb49, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_54);\n        _79 = ((*_1).4: usize);\n        StorageLive(_80);\n        _80 = PtrMetadata(_3);\n        _81 = CheckedAdd(((*_1).4: usize), _80);\n        assert(!move (_81.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).4: usize), move _80) -> [success: bb58, unwind unreachable];\n    }\n    bb49: {\n        _65 = (*_3)[_63];\n        StorageLive(_68);\n        StorageLive(_69);\n        StorageLive(_70);\n        _70 = ((*_1).4: usize);\n        _71 = CheckedAdd(_70, _63);\n        assert(!move (_71.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _70, _63) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _69 = move (_71.0: usize);\n        StorageDead(_70);\n        _72 = PtrMetadata(_2);\n        _73 = Lt(_69, _72);\n        assert(move _73, \"index out of bounds: the length is {} but the index is {}\", move _72, _69) -> [success: bb51, unwind unreachable];\n    }\n    bb51: {\n        _68 = (*_2)[_69];\n        _64 = Ne(move _65, move _68);\n        switchInt(move _64) -> [0: bb57, otherwise: bb52];\n    }\n    bb52: {\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_65);\n        StorageLive(_74);\n        _74 = ((*_1).2: usize);\n        _75 = CheckedAdd(((*_1).4: usize), _74);\n        assert(!move (_75.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).4: usize), move _74) -> [success: bb53, unwind unreachable];\n    }\n    bb53: {\n        ((*_1).4: usize) = move (_75.0: usize);\n        StorageDead(_74);\n        switchInt(_4) -> [0: bb54, otherwise: bb56];\n    }\n    bb54: {\n        StorageLive(_76);\n        _76 = PtrMetadata(_3);\n        StorageLive(_77);\n        _77 = ((*_1).2: usize);\n        _78 = CheckedSub(_76, _77);\n        assert(!move (_78.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _76, move _77) -> [success: bb55, unwind unreachable];\n    }\n    bb55: {\n        ((*_1).6: usize) = move (_78.0: usize);\n        StorageDead(_77);\n        StorageDead(_76);\n        goto -> bb56;\n    }\n    bb56: {\n        StorageDead(_64);\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_54);\n        StorageDead(_53);\n        goto -> bb63;\n    }\n    bb57: {\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_65);\n        StorageDead(_64);\n        StorageDead(_60);\n        goto -> bb45;\n    }\n    bb58: {\n        ((*_1).4: usize) = move (_81.0: usize);\n        StorageDead(_80);\n        switchInt(_4) -> [0: bb59, otherwise: bb60];\n    }\n    bb59: {\n        ((*_1).6: usize) = 0_usize;\n        goto -> bb60;\n    }\n    bb60: {\n        StorageLive(_82);\n        StorageLive(_83);\n        _83 = PtrMetadata(_3);\n        _84 = CheckedAdd(_79, _83);\n        assert(!move (_84.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _79, move _83) -> [success: bb61, unwind unreachable];\n    }\n    bb61: {\n        _82 = move (_84.0: usize);\n        StorageDead(_83);\n        _0 = <S as str::pattern::TwoWayStrategy>::matching(_79, move _82) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_82);\n        StorageDead(_53);\n        StorageDead(_25);\n        goto -> bb65;\n    }\n    bb63: {\n        StorageDead(_25);\n        goto -> bb64;\n    }\n    bb64: {\n        goto -> bb2;\n    }\n    bb65: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}