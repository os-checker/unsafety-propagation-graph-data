{
  "name": "convert::identity",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": 5048,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:105:1: 107:2",
  "src": "pub const fn identity<T>(x: T) -> T {\n    x\n}",
  "mir": "fn convert::identity(_1: T) -> T {\n    let mut _0: T;\n    debug x => _1;\n    bb0: {\n        _0 = move _1;\n        return;\n    }\n}\n",
  "doc": " The identity function.\n\n Two things are important to note about this function:\n\n - It is not always equivalent to a closure like `|x| x`, since the\n   closure may coerce `x` into a different type.\n\n - It moves the input `x` passed to the function.\n\n While it might seem strange to have a function that just returns back the\n input, there are some interesting uses.\n\n # Examples\n\n Using `identity` to do nothing in a sequence of other, interesting,\n functions:\n\n ```rust\n use std::convert::identity;\n\n fn manipulation(x: u32) -> u32 {\n     // Let's pretend that adding one is an interesting function.\n     x + 1\n }\n\n let _arr = &[identity, manipulation];\n ```\n\n Using `identity` as a \"do nothing\" base case in a conditional:\n\n ```rust\n use std::convert::identity;\n\n # let condition = true;\n #\n # fn manipulation(x: u32) -> u32 { x + 1 }\n #\n let do_stuff = if condition { manipulation } else { identity };\n\n // Do more interesting stuff...\n\n let _results = do_stuff(42);\n ```\n\n Using `identity` to keep the `Some` variants of an iterator of `Option<T>`:\n\n ```rust\n use std::convert::identity;\n\n let iter = [Some(1), None, Some(3)].into_iter();\n let filtered = iter.filter_map(identity).collect::<Vec<_>>();\n assert_eq!(vec![1, 3], filtered);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}