{
  "name": "<future::join::MaybeDone<F> as future::future::Future>::poll",
  "safe": true,
  "callees": {
    "pin::Pin::<Ptr>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the pinned value this `Pin<Ptr>` points to.\n\n This is a generic method to go from `&mut Pin<Pointer<T>>` to `Pin<&mut T>`.\n It is safe because, as part of the contract of `Pin::new_unchecked`,\n the pointee cannot move after `Pin<Pointer<T>>` got created.\n \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n ruled out by the contract of `Pin::new_unchecked`.\n\n This method is useful when doing multiple calls to functions that consume the\n pinning pointer.\n\n # Example\n\n ```\n use std::pin::Pin;\n\n # struct Type {}\n impl Type {\n     fn method(self: Pin<&mut Self>) {\n         // do something\n     }\n\n     fn call_method_twice(mut self: Pin<&mut Self>) {\n         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.\n         self.as_mut().method();\n         self.as_mut().method();\n     }\n }\n ```\n",
      "adt": {
        "pin::Pin": "Constructor"
      }
    },
    "pin::Pin::<&'a mut T>::get_unchecked_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the data inside of this `Pin`.\n\n # Safety\n\n This function is unsafe. You must guarantee that you will never move\n the data out of the mutable reference you receive when you call this\n function, so that the invariants on the `Pin` type can be upheld.\n\n If the underlying data is `Unpin`, `Pin::get_mut` should be used\n instead.\n",
      "adt": {}
    },
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "pin::Pin::<Ptr>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Pin<Ptr>` around a reference to some data of a type that\n may or may not implement [`Unpin`].\n\n If `pointer` dereferences to an [`Unpin`] type, [`Pin::new`] should be used\n instead.\n\n # Safety\n\n This constructor is unsafe because we cannot guarantee that the data\n pointed to by `pointer` is pinned. At its core, pinning a value means making the\n guarantee that the value's data will not be moved nor have its storage invalidated until\n it gets dropped. For a more thorough explanation of pinning, see the [`pin` module docs].\n\n If the caller that is constructing this `Pin<Ptr>` does not ensure that the data `Ptr`\n points to is pinned, that is a violation of the API contract and may lead to undefined\n behavior in later (even safe) operations.\n\n By using this method, you are also making a promise about the [`Deref`],\n [`DerefMut`], and [`Drop`] implementations of `Ptr`, if they exist. Most importantly, they\n must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n will call `DerefMut::deref_mut` and `Deref::deref` *on the pointer type `Ptr`*\n and expect these methods to uphold the pinning invariants.\n Moreover, by calling this method you promise that the reference `Ptr`\n dereferences to will not be moved out of again; in particular, it\n must not be possible to obtain a `&mut Ptr::Target` and then\n move out of that reference (using, for example [`mem::swap`]).\n\n For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n while you are able to pin it for the given lifetime `'a`, you have no control\n over whether it is kept pinned once `'a` ends, and therefore cannot uphold the\n guarantee that a value, once pinned, remains pinned until it is dropped:\n\n ```\n use std::mem;\n use std::pin::Pin;\n\n fn move_pinned_ref<T>(mut a: T, mut b: T) {\n     unsafe {\n         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n         // This should mean the pointee `a` can never move again.\n     }\n     mem::swap(&mut a, &mut b); // Potential UB down the road ⚠️\n     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n     // though we have previously pinned it! We have violated the pinning API contract.\n }\n ```\n A value, once pinned, must remain pinned until it is dropped (unless its type implements\n `Unpin`). Because `Pin<&mut T>` does not own the value, dropping the `Pin` will not drop\n the value and will not end the pinning contract. So moving the value after dropping the\n `Pin<&mut T>` is still a violation of the API contract.\n\n Similarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n aliases to the same data that are not subject to the pinning restrictions:\n ```\n use std::rc::Rc;\n use std::pin::Pin;\n\n fn move_pinned_rc<T>(mut x: Rc<T>) {\n     // This should mean the pointee can never move again.\n     let pin = unsafe { Pin::new_unchecked(Rc::clone(&x)) };\n     {\n         let p: Pin<&T> = pin.as_ref();\n         // ...\n     }\n     drop(pin);\n\n     let content = Rc::get_mut(&mut x).unwrap(); // Potential UB down the road ⚠️\n     // Now, if `x` was the only reference, we have a mutable reference to\n     // data that we pinned above, which we could use to move it as we have\n     // seen in the previous example. We have violated the pinning API contract.\n }\n ```\n\n ## Pinning of closure captures\n\n Particular care is required when using `Pin::new_unchecked` in a closure:\n `Pin::new_unchecked(&mut var)` where `var` is a by-value (moved) closure capture\n implicitly makes the promise that the closure itself is pinned, and that *all* uses\n of this closure capture respect that pinning.\n ```\n use std::pin::Pin;\n use std::task::Context;\n use std::future::Future;\n\n fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n     // Create a closure that moves `x`, and then internally uses it in a pinned way.\n     let mut closure = move || unsafe {\n         let _ignore = Pin::new_unchecked(&mut x).poll(cx);\n     };\n     // Call the closure, so the future can assume it has been pinned.\n     closure();\n     // Move the closure somewhere else. This also moves `x`!\n     let mut moved = closure;\n     // Calling it again means we polled the future from two different locations,\n     // violating the pinning API contract.\n     moved(); // Potential UB ⚠️\n }\n ```\n When passing a closure to another API, it might be moving the closure any time, so\n `Pin::new_unchecked` on closure captures may only be used if the API explicitly documents\n that the closure is pinned.\n\n The better alternative is to avoid all that trouble and do the pinning in the outer function\n instead (here using the [`pin!`][crate::pin::pin] macro):\n ```\n use std::pin::pin;\n use std::task::Context;\n use std::future::Future;\n\n fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n     let mut x = pin!(x);\n     // Create a closure that captures `x: Pin<&mut _>`, which is safe to move.\n     let mut closure = move || {\n         let _ignore = x.as_mut().poll(cx);\n     };\n     // Call the closure, so the future can assume it has been pinned.\n     closure();\n     // Move the closure somewhere else.\n     let mut moved = closure;\n     // Calling it again here is fine (except that we might be polling a future that already\n     // returned `Poll::Ready`, but that is a separate problem).\n     moved();\n }\n ```\n\n [`mem::swap`]: crate::mem::swap\n [`pin` module docs]: self\n",
      "adt": {
        "pin::Pin": "Constructor"
      }
    },
    "future::future::Future::poll": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to resolve the future to a final value, registering\n the current task for wakeup if the value is not yet available.\n\n # Return value\n\n This function returns:\n\n - [`Poll::Pending`] if the future is not ready yet\n - [`Poll::Ready(val)`] with the result `val` of this future if it\n   finished successfully.\n\n Once a future has finished, clients should not `poll` it again.\n\n When a future is not ready yet, `poll` returns `Poll::Pending` and\n stores a clone of the [`Waker`] copied from the current [`Context`].\n This [`Waker`] is then woken once the future can make progress.\n For example, a future waiting for a socket to become\n readable would call `.clone()` on the [`Waker`] and store it.\n When a signal arrives elsewhere indicating that the socket is readable,\n [`Waker::wake`] is called and the socket future's task is awoken.\n Once a task has been woken up, it should attempt to `poll` the future\n again, which may or may not produce a final value.\n\n Note that on multiple calls to `poll`, only the [`Waker`] from the\n [`Context`] passed to the most recent call should be scheduled to\n receive a wakeup.\n\n # Runtime characteristics\n\n Futures alone are *inert*; they must be *actively* `poll`ed for the\n underlying computation to make progress, meaning that each time the\n current task is woken up, it should actively re-`poll` pending futures\n that it still has an interest in.\n\n Having said that, some Futures may represent a value that is being\n computed in a different task. In this case, the future's underlying\n computation is simply acting as a conduit for a value being computed\n by that other task, which will proceed independently of the Future.\n Futures of this kind are typically obtained when spawning a new task into an\n async runtime.\n\n The `poll` function should not be called repeatedly in a tight loop --\n instead, it should only be called when the future indicates that it is\n ready to make progress (by calling `wake()`). If you're familiar with the\n `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures\n typically do *not* suffer the same problems of \"all wakeups must poll\n all events\"; they are more like `epoll(4)`.\n\n An implementation of `poll` should strive to return quickly, and should\n not block. Returning quickly prevents unnecessarily clogging up\n threads or event loops. If it is known ahead of time that a call to\n `poll` may end up taking a while, the work should be offloaded to a\n thread pool (or something similar) to ensure that `poll` can return\n quickly.\n\n # Panics\n\n Once a future has completed (returned `Ready` from `poll`), calling its\n `poll` method again may panic, block forever, or cause other kinds of\n problems; the `Future` trait places no requirements on the effects of\n such a call. However, as the `poll` method is not marked `unsafe`,\n Rust's usual rules apply: calls must never cause undefined behavior\n (memory corruption, incorrect use of `unsafe` functions, or the like),\n regardless of the future's state.\n\n [`Poll::Ready(val)`]: Poll::Ready\n [`Waker`]: crate::task::Waker\n [`Waker::wake`]: crate::task::Waker::wake\n",
      "adt": {}
    },
    "pin::Pin::<Ptr>::set": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Assigns a new value to the memory location pointed to by the `Pin<Ptr>`.\n\n This overwrites pinned data, but that is okay: the original pinned value's destructor gets\n run before being overwritten and the new value is also a valid value of the same type, so\n no pinning invariant is violated. See [the `pin` module documentation][subtle-details]\n for more information on how this upholds the pinning invariants.\n\n # Example\n\n ```\n use std::pin::Pin;\n\n let mut val: u8 = 5;\n let mut pinned: Pin<&mut u8> = Pin::new(&mut val);\n println!(\"{}\", pinned); // 5\n pinned.set(10);\n println!(\"{}\", pinned); // 10\n ```\n\n [subtle-details]: self#subtle-details-and-the-drop-guarantee\n",
      "adt": {
        "pin::Pin": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "pin::Pin": [
      "MutRef",
      "Plain"
    ],
    "future::join::MaybeDone": [
      "MutRef",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 467, kind: Param(ParamTy { index: 0, name: \"F\" }) })])",
      "Plain"
    ],
    "task::wake::Context": [
      "MutRef"
    ],
    "task::poll::Poll": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 10084, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 27478, name: \"future::future::Future::Output\" }), args: GenericArgs([Type(Ty { id: 467, kind: Param(ParamTy { index: 0, name: \"F\" }) })]) }) })])"
    ]
  },
  "path": 13111,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/join.rs:177:5: 192:6",
  "src": "fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        // SAFETY: pinning in structural for `f`\n        unsafe {\n            // Do not mix match ergonomics with unsafe.\n            match *self.as_mut().get_unchecked_mut() {\n                MaybeDone::Future(ref mut f) => {\n                    let val = ready!(Pin::new_unchecked(f).poll(cx));\n                    self.set(Self::Done(val));\n                }\n                MaybeDone::Done(_) => {}\n                MaybeDone::Taken => unreachable!(),\n            }\n        }\n\n        Poll::Ready(())\n    }",
  "mir": "fn <future::join::MaybeDone<F> as future::future::Future>::poll(_1: pin::Pin<&mut future::join::MaybeDone<F>>, _2: &mut task::wake::Context<'_>) -> task::poll::Poll<()> {\n    let mut _0: task::poll::Poll<()>;\n    let mut _3: &mut future::join::MaybeDone<F>;\n    let mut _4: pin::Pin<&mut future::join::MaybeDone<F>>;\n    let mut _5: &mut pin::Pin<&mut future::join::MaybeDone<F>>;\n    let mut _6: isize;\n    let  _7: &mut F;\n    let mut _8: task::poll::Poll<<F as future::future::Future>::Output>;\n    let mut _9: pin::Pin<&mut F>;\n    let mut _10: isize;\n    let  _11: <F as future::future::Future>::Output;\n    let  _12: ();\n    let mut _13: &mut pin::Pin<&mut future::join::MaybeDone<F>>;\n    let mut _14: future::join::MaybeDone<F>;\n    let mut _15: !;\n    debug self => _1;\n    debug cx => _2;\n    debug f => _7;\n    debug val => _11;\n    debug t => _11;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _1;\n        _4 = pin::Pin::<&mut future::join::MaybeDone<F>>::as_mut(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = pin::Pin::<&mut future::join::MaybeDone<F>>::get_unchecked_mut(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = discriminant((*_3));\n        switchInt(move _6) -> [0: bb5, 1: bb11, 2: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _15 = panicking::panic(\"internal error: entered unreachable code\") -> unwind unreachable;\n    }\n    bb5: {\n        _7 = &mut (((*_3) as variant#0).0: F);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = pin::Pin::<&mut F>::new_unchecked(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _8 = <F as future::future::Future>::poll(move _9, _2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        _10 = discriminant(_8);\n        switchInt(move _10) -> [0: bb9, 1: bb8, otherwise: bb3];\n    }\n    bb8: {\n        _0 = task::poll::Poll::Pending;\n        StorageDead(_8);\n        StorageDead(_3);\n        goto -> bb12;\n    }\n    bb9: {\n        _11 = move ((_8 as variant#0).0: <F as future::future::Future>::Output);\n        StorageDead(_8);\n        StorageLive(_13);\n        _13 = &mut _1;\n        StorageLive(_14);\n        _14 = future::join::MaybeDone::Done(_11);\n        _12 = pin::Pin::<&mut future::join::MaybeDone<F>>::set(move _13, move _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_3);\n        _0 = task::poll::Poll::Ready(());\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}