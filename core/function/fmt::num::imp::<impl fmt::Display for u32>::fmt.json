{
  "name": "fmt::num::imp::<impl fmt::Display for u32>::fmt",
  "safe": true,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "fmt::num::imp::<impl u32>::_fmt": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": "",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad_integral": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.\n\n # Arguments\n\n * is_nonnegative - whether the original integer was either positive or zero.\n * prefix - if the '#' character (Alternate) is provided, this\n   is the prefix to put in front of the number.\n * buf - the byte array that the number has been formatted into\n\n This function will correctly account for the flags provided as well as\n the minimum width. It will not take precision into account.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo { nb: i32 }\n\n impl Foo {\n     fn new(nb: i32) -> Foo {\n         Foo {\n             nb,\n         }\n     }\n }\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // We need to remove \"-\" from the number output.\n         let tmp = self.nb.abs().to_string();\n\n         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": 3589,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:135:13: 151:14",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                {\n                    const MAX_DEC_N: usize = $Unsigned::MAX.ilog10() as usize + 1;\n                    // Buffer decimals for self with right alignment.\n                    let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n                    // SAFETY: `buf` is always big enough to contain all the digits.\n                    unsafe { f.pad_integral(true, \"\", self._fmt(&mut buf)) }\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    ${concat($fmt_fn, _small)}(*self as $T, true, f)\n                }\n            }",
  "mir": "fn fmt::num::imp::<impl fmt::Display for u32>::fmt(_1: &u32, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: [mem::maybe_uninit::MaybeUninit<u8>; 10];\n    let mut _4: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _5: &str;\n    let  _6: &str;\n    let mut _7: u32;\n    let mut _8: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _9: &mut [mem::maybe_uninit::MaybeUninit<u8>; 10];\n    debug self => _1;\n    debug f => _2;\n    debug buf => _3;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = mem::maybe_uninit::MaybeUninit::<u8>::uninit() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = [move _4; 10];\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = \"\";\n        StorageLive(_7);\n        _7 = (*_1);\n        StorageLive(_8);\n        _9 = &mut _3;\n        _8 = _9 as &mut [mem::maybe_uninit::MaybeUninit<u8>];\n        _6 = fmt::num::imp::<impl u32>::_fmt(move _7, move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _0 = fmt::Formatter::<'_>::pad_integral(_2, true, move _5, _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}