{
  "name": "ptr::non_null::NonNull::<T>::read_volatile",
  "safe": false,
  "callees": {
    "ptr::non_null::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "ptr::read_volatile": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile read of the value from `src` without moving it.\n\n Volatile operations are intended to act on I/O memory. As such, they are considered externally\n observable events (just like syscalls, but less opaque), and are guaranteed to not be elided or\n reordered by the compiler across other externally observable events. With this in mind, there\n are two cases of usage that need to be distinguished:\n\n - When a volatile operation is used for memory inside an [allocation], it behaves exactly like\n   [`read`], except for the additional guarantee that it won't be elided or reordered (see\n   above). This implies that the operation will actually access memory and not e.g. be lowered to\n   reusing data from a previous read. Other than that, all the usual rules for memory accesses\n   apply (including provenance).  In particular, just like in C, whether an operation is volatile\n   has no bearing whatsoever on questions involving concurrent accesses from multiple threads.\n   Volatile accesses behave exactly like non-atomic accesses in that regard.\n\n - Volatile operations, however, may also be used to access memory that is _outside_ of any Rust\n   allocation. In this use-case, the pointer does *not* have to be [valid] for reads. This is\n   typically used for CPU and peripheral registers that must be accessed via an I/O memory\n   mapping, most commonly at fixed addresses reserved by the hardware. These often have special\n   semantics associated to their manipulation, and cannot be used as general purpose memory.\n   Here, any address value is possible, including 0 and [`usize::MAX`], so long as the semantics\n   of such a read are well-defined by the target hardware. The provenance of the pointer is\n   irrelevant, and it can be created with [`without_provenance`]. The access must not trap. It\n   can cause side-effects, but those must not affect Rust-allocated memory in any way. This\n   access is still not considered [atomic], and as such it cannot be used for inter-thread\n   synchronization.\n\n Note that volatile memory operations where T is a zero-sized type are noops and may be ignored.\n\n [allocation]: crate::ptr#allocated-object\n [atomic]: crate::sync::atomic#memory-model-for-atomic-accesses\n\n # Safety\n\n Like [`read`], `read_volatile` creates a bitwise copy of `T`, regardless of whether `T` is\n [`Copy`]. If `T` is not [`Copy`], using both the returned value and the value at `*src` can\n [violate memory safety][read-ownership]. However, storing non-[`Copy`] types in volatile memory\n is almost certainly incorrect.\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be either [valid] for reads, or it must point to memory outside of all Rust\n   allocations and reading from that memory must:\n   - not trap, and\n   - not cause any memory inside a Rust allocation to be modified.\n\n * `src` must be properly aligned.\n\n * Reading from `src` must produce a properly initialized value of type `T`.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n [valid]: self#safety\n [read-ownership]: read#ownership-of-the-returned-value\n\n # Examples\n\n Basic usage:\n\n ```\n let x = 12;\n let y = &x as *const i32;\n\n unsafe {\n     assert_eq!(std::ptr::read_volatile(y), 12);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ptr::non_null::NonNull": [
      "Plain"
    ]
  },
  "path": 16033,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:1007:5: 1013:6",
  "src": "pub unsafe fn read_volatile(self) -> T\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `read_volatile`.\n        unsafe { ptr::read_volatile(self.as_ptr()) }\n    }",
  "mir": "fn ptr::non_null::NonNull::<T>::read_volatile(_1: ptr::non_null::NonNull<T>) -> T {\n    let mut _0: T;\n    let mut _2: *const T;\n    let mut _3: *mut T;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ptr::non_null::NonNull::<T>::as_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = move _3 as *const T;\n        StorageDead(_3);\n        _0 = ptr::read_volatile::<T>(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Performs a volatile read of the value from `self` without moving it. This\n leaves the memory in `self` unchanged.\n\n Volatile operations are intended to act on I/O memory, and are guaranteed\n to not be elided or reordered by the compiler across other volatile\n operations.\n\n See [`ptr::read_volatile`] for safety concerns and examples.\n\n [`ptr::read_volatile`]: crate::ptr::read_volatile()\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}