{
  "name": "num::flt2dec::estimate_max_buf_len",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::estimate_max_buf_len"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/mod.rs:490:1: 492:2",
  "src": "fn estimate_max_buf_len(exp: i16) -> usize {\n    21 + ((if exp < 0 { -12 } else { 5 } * exp as i32) as usize >> 4)\n}",
  "mir": "fn num::flt2dec::estimate_max_buf_len(_1: i16) -> usize {\n    let mut _0: usize;\n    let mut _2: usize;\n    let mut _3: usize;\n    let mut _4: i32;\n    let mut _5: i32;\n    let mut _6: bool;\n    let mut _7: i32;\n    let mut _8: (i32, bool);\n    let mut _9: u32;\n    let mut _10: bool;\n    let mut _11: (usize, bool);\n    debug exp => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = Lt(_1, 0_i16);\n        switchInt(move _6) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _5 = -12_i32;\n        goto -> bb3;\n    }\n    bb2: {\n        _5 = 5_i32;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = _1 as i32;\n        _8 = CheckedMul(_5, _7);\n        assert(!move (_8.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _5, move _7) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _4 = move (_8.0: i32);\n        StorageDead(_7);\n        StorageDead(_5);\n        _3 = move _4 as usize;\n        StorageDead(_4);\n        _9 = 4_i32 as u32;\n        _10 = Lt(move _9, 64_u32);\n        assert(move _10, \"attempt to shift right by `{}`, which would overflow\", 4_i32) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _2 = Shr(move _3, 4_i32);\n        StorageDead(_3);\n        _11 = CheckedAdd(21_usize, _2);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 21_usize, move _2) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _0 = move (_11.0: usize);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a rather crude approximation (upper bound) for the maximum buffer size\n calculated from the given decoded exponent.\n\n The exact limit is:\n\n - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n\n `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n enough for our purposes.\n\n Why do we need this? `format_exact` functions will fill the entire buffer\n unless limited by the last digit restriction, but it is possible that\n the number of digits requested is ridiculously large (say, 30,000 digits).\n The vast majority of buffer will be filled with zeroes, so we don't want to\n allocate all the buffer beforehand. Consequently, for any given arguments,\n 826 bytes of buffer should be sufficient for `f64`. Compare this with\n the actual number for the worst case: 770 bytes (when `exp = -1074`).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}