{
  "name": "core_arch::x86::avx512fp16::_mm_maskz_conj_pch",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::_mm_setzero_ph": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return vector of type __m128h with all elements set to zero.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_setzero_ph)\n",
      "adt": {
        "core_arch::x86::__m128h": "Constructor"
      }
    },
    "core_arch::x86::avx512fp16::_mm_mask_conj_pch": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compute the complex conjugates of complex numbers in a, and store the results in dst using writemask k\n (the element is copied from src when corresponding mask bit is not set). Each complex number is composed of two\n adjacent half-precision (16-bit) floating-point elements, which defines the complex number\n `complex = vec.fp16[0] + i * vec.fp16[1]`, or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_conj_pch)\n",
      "adt": {
        "core_arch::x86::__m128h": "Constructor"
      }
    }
  },
  "adts": {
    "core_arch::x86::__m128h": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::avx512fp16::_mm_maskz_conj_pch"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:4034:1: 4036:2",
  "src": "pub fn _mm_maskz_conj_pch(k: __mmask8, a: __m128h) -> __m128h {\n    _mm_mask_conj_pch(_mm_setzero_ph(), k, a)\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm_maskz_conj_pch(_1: u8, _2: core_arch::x86::__m128h) -> core_arch::x86::__m128h {\n    let mut _0: core_arch::x86::__m128h;\n    let mut _3: core_arch::x86::__m128h;\n    debug k => _1;\n    debug a => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = core_arch::x86::avx512fp16::_mm_setzero_ph() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = core_arch::x86::avx512fp16::_mm_mask_conj_pch(move _3, _1, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Compute the complex conjugates of complex numbers in a, and store the results in dst using zeromask k\n (the element is zeroed out when corresponding mask bit is not set). Each complex number is composed of two adjacent\n half-precision (16-bit) floating-point elements, which defines the complex number `complex = vec.fp16[0] + i * vec.fp16[1]`,\n or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_maskz_conj_pch)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}