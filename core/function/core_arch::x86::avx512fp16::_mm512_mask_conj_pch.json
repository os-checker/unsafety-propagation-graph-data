{
  "name": "core_arch::x86::avx512fp16::_mm512_mask_conj_pch",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::_mm512_conj_pch": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compute the complex conjugates of complex numbers in a, and store the results in dst. Each complex number\n is composed of two adjacent half-precision (16-bit) floating-point elements, which defines the complex\n number `complex = vec.fp16[0] + i * vec.fp16[1]`, or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_conj_pch)\n",
      "adt": {
        "core_arch::x86::__m512h": "Constructor"
      }
    },
    "intrinsics::simd::simd_select_bitmask": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Selects elements from a bitmask.\n\n `M` must be an unsigned integer or array of `u8`, matching `simd_bitmask`.\n\n `T` must be a vector.\n\n For each element, if the bit in `mask` is `1`, select the element from\n `if_true`.  If the corresponding bit in `mask` is `0`, select the element from\n `if_false`.\n The remaining bits of the mask are ignored.\n\n The bitmask bit order matches `simd_bitmask`.\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m512h": [
      "Plain"
    ],
    "core_arch::x86::__m512": [
      "Plain"
    ]
  },
  "path": 10469,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:4100:1: 4105:2",
  "src": "pub fn _mm512_mask_conj_pch(src: __m512h, k: __mmask16, a: __m512h) -> __m512h {\n    unsafe {\n        let r: __m512 = transmute(_mm512_conj_pch(a));\n        transmute(simd_select_bitmask(k, r, transmute(src)))\n    }\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm512_mask_conj_pch(_1: core_arch::x86::__m512h, _2: u16, _3: core_arch::x86::__m512h) -> core_arch::x86::__m512h {\n    let mut _0: core_arch::x86::__m512h;\n    let  _4: core_arch::x86::__m512;\n    let mut _5: core_arch::x86::__m512h;\n    let mut _6: core_arch::x86::__m512;\n    let mut _7: core_arch::x86::__m512;\n    debug src => _1;\n    debug k => _2;\n    debug a => _3;\n    debug r => _4;\n    bb0: {\n        StorageLive(_5);\n        _5 = core_arch::x86::avx512fp16::_mm512_conj_pch(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = move _5 as core_arch::x86::__m512;\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _1 as core_arch::x86::__m512;\n        _6 = intrinsics::simd::simd_select_bitmask::<u16, core_arch::x86::__m512>(_2, _4, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _0 = move _6 as core_arch::x86::__m512h;\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Compute the complex conjugates of complex numbers in a, and store the results in dst using writemask k\n (the element is copied from src when corresponding mask bit is not set). Each complex number is composed of two\n adjacent half-precision (16-bit) floating-point elements, which defines the complex number `complex = vec.fp16[0] + i * vec.fp16[1]`,\n or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_mask_conj_pch)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}