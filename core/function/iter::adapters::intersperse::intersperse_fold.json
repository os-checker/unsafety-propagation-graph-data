{
  "name": "iter::adapters::intersperse::intersperse_fold",
  "safe": true,
  "callees": {
    "option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {
        "option::Option": "ImmutableAsArgument"
      }
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Folds every element into an accumulator by applying an operation,\n returning the final result.\n\n `fold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `fold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `fold()`, and similar methods that traverse the entire iterator,\n might not terminate for infinite iterators, even on traits for which a\n result is determinable in finite time.\n\n Note: [`reduce()`] can be used to use the first element as the initial\n value, if the accumulator type and item type is the same.\n\n Note: `fold()` combines elements in a *left-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `fold()` on the internal parts\n from which this iterator is composed.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of the array\n let sum = a.iter().fold(0, |acc, x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n Let's walk through each step of the iteration here:\n\n | element | acc | x | result |\n |---------|-----|---|--------|\n |         | 0   |   |        |\n | 1       | 0   | 1 | 1      |\n | 2       | 1   | 2 | 3      |\n | 3       | 3   | 3 | 6      |\n\n And so, our final result, `6`.\n\n This example demonstrates the left-associative nature of `fold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the front until the back:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().fold(zero, |acc, &x| {\n     format!(\"({acc} + {x})\")\n });\n\n assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n ```\n It's common for people who haven't used iterators a lot to\n use a `for` loop with a list of things to build up a result. Those\n can be turned into `fold()`s:\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let mut result = 0;\n\n // for loop:\n for i in &numbers {\n     result = result + i;\n }\n\n // fold:\n let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n // they're the same\n assert_eq!(result, result2);\n ```\n\n [`reduce()`]: Iterator::reduce\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "MutRef",
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4671, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25924, name: \"iter::traits::iterator::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])"
    ]
  },
  "path": 13900,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/intersperse.rs:211:1: 245:2",
  "src": "fn intersperse_fold<I, B, F, G>(\n    mut iter: I,\n    init: B,\n    mut f: F,\n    mut separator: G,\n    started: bool,\n    mut next_item: Option<I::Item>,\n) -> B\nwhere\n    I: Iterator,\n    F: FnMut(B, I::Item) -> B,\n    G: FnMut() -> I::Item,\n{\n    let mut accum = init;\n\n    let first = if started {\n        next_item.take()\n    } else {\n        let n = iter.next();\n        // skip invoking fold() for empty iterators\n        if n.is_none() {\n            return accum;\n        }\n        n\n    };\n    if let Some(x) = first {\n        accum = f(accum, x);\n    }\n\n    iter.fold(accum, |mut accum, x| {\n        accum = f(accum, separator());\n        accum = f(accum, x);\n        accum\n    })\n}",
  "mir": "fn iter::adapters::intersperse::intersperse_fold(_1: I, _2: B, _3: F, _4: G, _5: bool, _6: option::Option<<I as iter::traits::iterator::Iterator>::Item>) -> B {\n    let mut _0: B;\n    let mut _7: B;\n    let  _8: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _9: &mut option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let  _10: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _11: &mut I;\n    let mut _12: bool;\n    let mut _13: &option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _14: isize;\n    let  _15: <I as iter::traits::iterator::Iterator>::Item;\n    let mut _16: B;\n    let mut _17: &mut F;\n    let mut _18: (B, <I as iter::traits::iterator::Iterator>::Item);\n    let mut _19: B;\n    let mut _20: I;\n    let mut _21: B;\n    let mut _22: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/intersperse.rs:240:22: 240:36};\n    let mut _23: &mut F;\n    let mut _24: &mut G;\n    debug iter => _1;\n    debug init => _2;\n    debug f => _3;\n    debug separator => _4;\n    debug started => _5;\n    debug next_item => _6;\n    debug accum => _7;\n    debug first => _8;\n    debug n => _10;\n    debug x => _15;\n    bb0: {\n        StorageLive(_7);\n        _7 = move _2;\n        StorageLive(_8);\n        switchInt(_5) -> [0: bb3, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_9);\n        _9 = &mut _6;\n        _8 = option::Option::<<I as iter::traits::iterator::Iterator>::Item>::take(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        goto -> bb8;\n    }\n    bb3: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &mut _1;\n        _10 = <I as iter::traits::iterator::Iterator>::next(move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_10;\n        _12 = option::Option::<<I as iter::traits::iterator::Iterator>::Item>::is_none(move _13) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _12) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_13);\n        _0 = move _7;\n        StorageDead(_12);\n        drop(_10) -> [return: bb15, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _8 = move _10;\n        StorageDead(_10);\n        goto -> bb8;\n    }\n    bb8: {\n        _14 = discriminant(_8);\n        switchInt(move _14) -> [1: bb9, 0: bb11, otherwise: bb20];\n    }\n    bb9: {\n        _15 = move ((_8 as variant#1).0: <I as iter::traits::iterator::Iterator>::Item);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _3;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = move _7;\n        _18 = (move _19, _15);\n        _16 = <F as ops::function::FnMut<(B, <I as iter::traits::iterator::Iterator>::Item)>>::call_mut(move _17, move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        _7 = move _16;\n        StorageDead(_16);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_20);\n        _20 = move _1;\n        StorageLive(_21);\n        _21 = move _7;\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &mut _3;\n        StorageLive(_24);\n        _24 = &mut _4;\n        _22 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/intersperse.rs:240:22: 240:36}(move _23, move _24);\n        StorageDead(_24);\n        StorageDead(_23);\n        _0 = <I as iter::traits::iterator::Iterator>::fold::<B, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/intersperse.rs:240:22: 240:36}>(move _20, move _21, move _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_8);\n        StorageDead(_7);\n        drop(_6) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        drop(_4) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        drop(_3) -> [return: bb19, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageDead(_7);\n        drop(_6) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        drop(_4) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        drop(_3) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        drop(_1) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        return;\n    }\n    bb20: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}