{
  "name": "sync::atomic::AtomicPtr::<T>::fetch_update",
  "safe": true,
  "callees": {
    "sync::atomic::AtomicPtr::<T>::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the pointer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let ptr = &mut 5;\n let some_ptr = AtomicPtr::new(ptr);\n\n let value = some_ptr.load(Ordering::Relaxed);\n ```\n",
      "adt": {
        "sync::atomic::AtomicPtr": "ImmutableAsArgument"
      }
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "sync::atomic::AtomicPtr::<T>::compare_exchange_weak": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the pointer if the current value is the same as the `current` value.\n\n Unlike [`AtomicPtr::compare_exchange`], this function is allowed to spuriously fail even when the\n comparison succeeds, which can result in more efficient code on some platforms. The\n return value is a result indicating whether the new value was written and containing the\n previous value.\n\n `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. `success` describes the required ordering for the\n read-modify-write operation that takes place if the comparison with `current` succeeds.\n `failure` describes the required ordering for the load operation that takes place when\n the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note:** This method is only available on platforms that support atomic\n operations on pointers.\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let some_ptr = AtomicPtr::new(&mut 5);\n\n let new = &mut 10;\n let mut old = some_ptr.load(Ordering::Relaxed);\n loop {\n     match some_ptr.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {\n         Ok(_) => break,\n         Err(x) => old = x,\n     }\n }\n ```\n\n # Considerations\n\n `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n of CAS operations. In particular, a load of the value followed by a successful\n `compare_exchange` with the previous load *does not ensure* that other threads have not\n changed the value in the interim. This is usually important when the *equality* check in\n the `compare_exchange` is being used to check the *identity* of a value, but equality\n does not necessarily imply identity. This is a particularly common case for pointers, as\n a pointer holding the same address does not imply that the same object exists at that\n address! In this case, `compare_exchange` can lead to the [ABA problem].\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n",
      "adt": {
        "sync::atomic::AtomicPtr": "ImmutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sync::atomic::AtomicPtr": [
      "Ref"
    ],
    "sync::atomic::Ordering": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1181, kind: RigidTy(RawPtr(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])"
    ],
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1181, kind: RigidTy(RawPtr(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])"
    ]
  },
  "path": 17373,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:2045:5: 2062:6",
  "src": "pub fn fetch_update<F>(\n        &self,\n        set_order: Ordering,\n        fetch_order: Ordering,\n        mut f: F,\n    ) -> Result<*mut T, *mut T>\n    where\n        F: FnMut(*mut T) -> Option<*mut T>,\n    {\n        let mut prev = self.load(fetch_order);\n        while let Some(next) = f(prev) {\n            match self.compare_exchange_weak(prev, next, set_order, fetch_order) {\n                x @ Ok(_) => return x,\n                Err(next_prev) => prev = next_prev,\n            }\n        }\n        Err(prev)\n    }",
  "mir": "fn sync::atomic::AtomicPtr::<T>::fetch_update(_1: &sync::atomic::AtomicPtr<T>, _2: sync::atomic::Ordering, _3: sync::atomic::Ordering, _4: F) -> result::Result<*mut T, *mut T> {\n    let mut _0: result::Result<*mut T, *mut T>;\n    let mut _5: *mut T;\n    let mut _6: option::Option<*mut T>;\n    let mut _7: &mut F;\n    let mut _8: (*mut T,);\n    let mut _9: *mut T;\n    let mut _10: isize;\n    let  _11: *mut T;\n    let mut _12: result::Result<*mut T, *mut T>;\n    let mut _13: *mut T;\n    let mut _14: isize;\n    let  _15: *mut T;\n    let mut _16: *mut T;\n    debug self => _1;\n    debug set_order => _2;\n    debug fetch_order => _3;\n    debug f => _4;\n    debug prev => _5;\n    debug next => _11;\n    debug x => _12;\n    debug next_prev => _15;\n    bb0: {\n        StorageLive(_5);\n        _5 = sync::atomic::AtomicPtr::<T>::load(_1, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _4;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = _5;\n        _8 = (move _9);\n        _6 = <F as ops::function::FnMut<(*mut T,)>>::call_mut(move _7, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        _10 = discriminant(_6);\n        switchInt(move _10) -> [1: bb4, 0: bb9, otherwise: bb6];\n    }\n    bb4: {\n        _11 = ((_6 as variant#1).0: *mut T);\n        StorageLive(_13);\n        _13 = _5;\n        _12 = sync::atomic::AtomicPtr::<T>::compare_exchange_weak(_1, move _13, _11, _2, _3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        _14 = discriminant(_12);\n        switchInt(move _14) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _15 = ((_12 as variant#1).0: *mut T);\n        _5 = _15;\n        StorageDead(_6);\n        goto -> bb2;\n    }\n    bb8: {\n        _0 = _12;\n        StorageDead(_6);\n        StorageDead(_5);\n        drop(_4) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        StorageLive(_16);\n        _16 = _5;\n        _0 = result::Result::Err(move _16);\n        StorageDead(_16);\n        StorageDead(_5);\n        drop(_4) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        return;\n    }\n}\n",
  "doc": " Fetches the value, and applies a function to it that returns an optional\n new value. Returns a `Result` of `Ok(previous_value)` if the function\n returned `Some(_)`, else `Err(previous_value)`.\n\n Note: This may call the function multiple times if the value has been\n changed from other threads in the meantime, as long as the function\n returns `Some(_)`, but the function will have been applied only once to\n the stored value.\n\n `fetch_update` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. The first describes the required ordering for\n when the operation finally succeeds while the second describes the\n required ordering for loads. These correspond to the success and failure\n orderings of [`AtomicPtr::compare_exchange`] respectively.\n\n Using [`Acquire`] as success ordering makes the store part of this\n operation [`Relaxed`], and using [`Release`] makes the final successful\n load [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`],\n [`Acquire`] or [`Relaxed`].\n\n **Note:** This method is only available on platforms that support atomic\n operations on pointers.\n\n # Considerations\n\n This method is not magic; it is not provided by the hardware, and does not act like a\n critical section or mutex.\n\n It is implemented on top of an atomic [compare-and-swap operation], and thus is subject to\n the usual drawbacks of CAS operations. In particular, be careful of the [ABA problem],\n which is a particularly common pitfall for pointers!\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n\n # Examples\n\n ```rust\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let ptr: *mut _ = &mut 5;\n let some_ptr = AtomicPtr::new(ptr);\n\n let new: *mut _ = &mut 10;\n assert_eq!(some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(ptr));\n let result = some_ptr.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| {\n     if x == ptr {\n         Some(new)\n     } else {\n         None\n     }\n });\n assert_eq!(result, Ok(ptr));\n assert_eq!(some_ptr.load(Ordering::SeqCst), new);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}