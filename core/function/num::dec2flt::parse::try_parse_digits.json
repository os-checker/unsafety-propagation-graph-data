{
  "name": "num::dec2flt::parse::try_parse_digits",
  "safe": true,
  "callees": {
    "num::dec2flt::common::ByteSlice::read_u64": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads 8 bytes as a 64-bit integer in little-endian order.\n",
      "adt": {}
    },
    "num::dec2flt::common::is_8digits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determine if all characters in an 8-byte byte string (represented as a `u64`) are all decimal\n digits.\n\n This does not care about the order in which the bytes were loaded.\n",
      "adt": {}
    },
    "num::<impl u64>::wrapping_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) multiplication. Computes `self *\n rhs`, wrapping around at the boundary of the type.\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u8` is used.\n\n ```\n assert_eq!(10u8.wrapping_mul(12), 120);\n assert_eq!(25u8.wrapping_mul(12), 44);\n ```\n",
      "adt": {}
    },
    "num::dec2flt::parse::parse_8digits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Parse 8 digits, loaded as bytes in little-endian order.\n\n This uses the trick where every digit is in [0x030, 0x39],\n and therefore can be parsed in 3 multiplications, much\n faster than the normal 8.\n\n This is based off the algorithm described in \"Fast numeric string to\n int\", available here: <https://johnnylee-sde.github.io/Fast-numeric-string-to-int/>.\n",
      "adt": {}
    },
    "num::<impl u64>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "num::dec2flt::common::ByteSlice::parse_digits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Iteratively parse and consume digits from bytes.\n\n Returns the same bytes with consumed digits being elided. Breaks on invalid digits.\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::RangeFrom": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::dec2flt::parse::try_parse_digits"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/parse.rs:29:1: 47:2",
  "src": "fn try_parse_digits(mut s: &[u8], mut x: u64) -> (&[u8], u64) {\n    // may cause overflows, to be handled later\n\n    while s.len() >= 8 {\n        let num = s.read_u64();\n        if is_8digits(num) {\n            x = x.wrapping_mul(1_0000_0000).wrapping_add(parse_8digits(num));\n            s = &s[8..];\n        } else {\n            break;\n        }\n    }\n\n    s = s.parse_digits(|digit| {\n        x = x.wrapping_mul(10).wrapping_add(digit as _);\n    });\n\n    (s, x)\n}",
  "mir": "fn num::dec2flt::parse::try_parse_digits(_1: &[u8], _2: u64) -> (&[u8], u64) {\n    let mut _0: (&[u8], u64);\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &[u8];\n    let  _6: u64;\n    let mut _7: &[u8];\n    let mut _8: bool;\n    let mut _9: u64;\n    let mut _10: u64;\n    let mut _11: u64;\n    let mut _12: u64;\n    let  _13: &[u8];\n    let mut _14: &[u8];\n    let mut _15: ops::range::RangeFrom<usize>;\n    let  _16: &[u8];\n    let mut _17: &[u8];\n    let mut _18: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/parse.rs:42:24: 42:31};\n    let mut _19: &mut u64;\n    let mut _20: &[u8];\n    let mut _21: u64;\n    debug s => _1;\n    debug x => _2;\n    debug num => _6;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = _1;\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _3 = Ge(move _4, 8_usize);\n        switchInt(move _3) -> [0: bb11, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = _1;\n        _6 = <[u8] as num::dec2flt::common::ByteSlice>::read_u64(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = num::dec2flt::common::is_8digits(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _8) -> [0: bb10, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = _2;\n        _10 = num::<impl u64>::wrapping_mul(move _11, 100000000_u64) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageLive(_12);\n        _12 = num::dec2flt::parse::parse_8digits(_6) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = num::<impl u64>::wrapping_add(move _10, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageDead(_10);\n        _2 = move _9;\n        StorageDead(_9);\n        StorageLive(_14);\n        _14 = _1;\n        StorageLive(_15);\n        _15 = RangeFrom(8_usize);\n        _13 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(move _14, move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _1 = _13;\n        StorageDead(_8);\n        StorageDead(_3);\n        goto -> bb1;\n    }\n    bb10: {\n        StorageDead(_8);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_4);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_3);\n        StorageLive(_17);\n        _17 = _1;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _2;\n        _18 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/parse.rs:42:24: 42:31}(move _19);\n        StorageDead(_19);\n        _16 = <[u8] as num::dec2flt::common::ByteSlice>::parse_digits::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/parse.rs:42:24: 42:31}>(move _17, move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _1 = _16;\n        StorageLive(_20);\n        _20 = _1;\n        StorageLive(_21);\n        _21 = _2;\n        _0 = (move _20, move _21);\n        StorageDead(_21);\n        StorageDead(_20);\n        return;\n    }\n}\n",
  "doc": " Parse digits until a non-digit character is found.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}