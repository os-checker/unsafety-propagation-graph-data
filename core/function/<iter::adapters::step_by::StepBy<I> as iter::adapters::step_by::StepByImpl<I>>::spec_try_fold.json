{
  "name": "<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_try_fold",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "ops::try_trait::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_try_fold::nth": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "iter::sources::from_fn::from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator with the provided closure\n `F: FnMut() -> Option<T>` as its [`next`](Iterator::next) method.\n\n The iterator will yield the `T`s returned from the closure.\n\n This allows creating a custom iterator with any behavior\n without using the more verbose syntax of creating a dedicated type\n and implementing the [`Iterator`] trait for it.\n\n Note that the `FromFn` iterator doesn’t make assumptions about the behavior of the closure,\n and therefore conservatively does not implement [`FusedIterator`],\n or override [`Iterator::size_hint()`] from its default `(0, None)`.\n\n The closure can use captures and its environment to track state across iterations. Depending on\n how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n\n [`move`]: ../../std/keyword.move.html\n [`FusedIterator`]: crate::iter::FusedIterator\n\n # Examples\n\n Let’s re-implement the counter iterator from [module-level documentation]:\n\n [module-level documentation]: crate::iter\n\n ```\n let mut count = 0;\n let counter = std::iter::from_fn(move || {\n     // Increment our count. This is why we started at zero.\n     count += 1;\n\n     // Check to see if we've finished counting or not.\n     if count < 6 {\n         Some(count)\n     } else {\n         None\n     }\n });\n assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n ```\n",
      "adt": {
        "iter::sources::from_fn::FromFn": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::try_fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that applies a function as long as it returns\n successfully, producing a single, final value.\n\n `try_fold()` takes two arguments: an initial value, and a closure with\n two arguments: an 'accumulator', and an element. The closure either\n returns successfully, with the value that the accumulator should have\n for the next iteration, or it returns failure, with an error value that\n is propagated back to the caller immediately (short-circuiting).\n\n The initial value is the value the accumulator will have on the first\n call. If applying the closure succeeded against every element of the\n iterator, `try_fold()` returns the final accumulator as success.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `try_fold()` on the internal parts\n from which this iterator is composed. If multiple calls are needed,\n the `?` operator may be convenient for chaining the accumulator value\n along, but beware any invariants that need to be upheld before those\n early returns. This is a `&mut self` method, so iteration needs to be\n resumable after hitting an error here.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the checked sum of all of the elements of the array\n let sum = a.into_iter().try_fold(0i8, |acc, x| acc.checked_add(x));\n\n assert_eq!(sum, Some(6));\n ```\n\n Short-circuiting:\n\n ```\n let a = [10, 20, 30, 100, 40, 50];\n let mut iter = a.into_iter();\n\n // This sum overflows when adding the 100 element\n let sum = iter.try_fold(0i8, |acc, x| acc.checked_add(x));\n assert_eq!(sum, None);\n\n // Because it short-circuited, the remaining elements are still\n // available through the iterator.\n assert_eq!(iter.len(), 2);\n assert_eq!(iter.next(), Some(40));\n ```\n\n While you cannot `break` from a closure, the [`ControlFlow`] type allows\n a similar idea:\n\n ```\n use std::ops::ControlFlow;\n\n let triangular = (1..30).try_fold(0_i8, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Break(120));\n\n let triangular = (1..30).try_fold(0_u64, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Continue(435));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::step_by::StepBy": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4671, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25924, name: \"iter::traits::iterator::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 6241, kind: Param(ParamTy { index: 1, name: \"Acc\" }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6420, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25500, name: \"ops::try_trait::Try::Residual\" }), args: GenericArgs([Type(Ty { id: 3390, kind: Param(ParamTy { index: 3, name: \"R\" }) })]) }) })])"
    ],
    "iter::sources::from_fn::FromFn": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_try_fold"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:296:5: 317:6",
  "src": "default fn spec_try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n    where\n        F: FnMut(Acc, Self::Item) -> R,\n        R: Try<Output = Acc>,\n    {\n        #[inline]\n        fn nth<I: Iterator>(\n            iter: &mut I,\n            step_minus_one: usize,\n        ) -> impl FnMut() -> Option<I::Item> + '_ {\n            move || iter.nth(step_minus_one)\n        }\n\n        if self.first_take {\n            self.first_take = false;\n            match self.iter.next() {\n                None => return try { acc },\n                Some(x) => acc = f(acc, x)?,\n            }\n        }\n        from_fn(nth(&mut self.iter, self.step_minus_one)).try_fold(acc, f)\n    }",
  "mir": "fn <iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_try_fold(_1: &mut iter::adapters::step_by::StepBy<I>, _2: Acc, _3: F) -> R {\n    let mut _0: R;\n    let mut _4: bool;\n    let mut _5: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _6: &mut I;\n    let mut _7: isize;\n    let mut _8: Acc;\n    let  _9: <I as iter::traits::iterator::Iterator>::Item;\n    let mut _10: ops::control_flow::ControlFlow<<R as ops::try_trait::Try>::Residual, Acc>;\n    let mut _11: R;\n    let mut _12: &mut F;\n    let mut _13: (Acc, <I as iter::traits::iterator::Iterator>::Item);\n    let mut _14: Acc;\n    let mut _15: isize;\n    let  _16: <R as ops::try_trait::Try>::Residual;\n    let  _17: Acc;\n    let mut _18: &mut iter::sources::from_fn::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:306:13: 306:20}>;\n    let mut _19: iter::sources::from_fn::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:306:13: 306:20}>;\n    let mut _20: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:306:13: 306:20};\n    let mut _21: &mut I;\n    let mut _22: usize;\n    let mut _23: Acc;\n    let mut _24: F;\n    debug self => _1;\n    debug acc => _2;\n    debug f => _3;\n    debug x => _9;\n    debug residual => _16;\n    debug val => _17;\n    bb0: {\n        StorageLive(_4);\n        _4 = ((*_1).2: bool);\n        switchInt(move _4) -> [0: bb12, otherwise: bb1];\n    }\n    bb1: {\n        ((*_1).2: bool) = false;\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut ((*_1).0: I);\n        _5 = <I as iter::traits::iterator::Iterator>::next(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _9 = move ((_5 as variant#1).0: <I as iter::traits::iterator::Iterator>::Item);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut _3;\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = move _2;\n        _13 = (move _14, _9);\n        _11 = <F as ops::function::FnMut<(Acc, <I as iter::traits::iterator::Iterator>::Item)>>::call_mut(move _12, move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_8);\n        _8 = move _2;\n        _0 = <R as ops::try_trait::Try>::from_output(move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        goto -> bb16;\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        _10 = <R as ops::try_trait::Try>::branch(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _15 = discriminant(_10);\n        switchInt(move _15) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        _17 = move ((_10 as variant#0).0: Acc);\n        _2 = _17;\n        StorageDead(_10);\n        StorageDead(_5);\n        goto -> bb12;\n    }\n    bb10: {\n        _16 = move ((_10 as variant#1).0: <R as ops::try_trait::Try>::Residual);\n        _0 = <R as ops::try_trait::FromResidual>::from_residual(_16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_10);\n        goto -> bb16;\n    }\n    bb12: {\n        StorageDead(_4);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _21 = &mut ((*_1).0: I);\n        StorageLive(_22);\n        _22 = ((*_1).1: usize);\n        _20 = <iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_try_fold::nth::<I>(_21, move _22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_22);\n        _19 = iter::sources::from_fn::from_fn::<<I as iter::traits::iterator::Iterator>::Item, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:306:13: 306:20}>(move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _18 = &mut _19;\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = move _2;\n        StorageLive(_24);\n        _24 = move _3;\n        _0 = <iter::sources::from_fn::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:306:13: 306:20}> as iter::traits::iterator::Iterator>::try_fold::<Acc, F, R>(move _18, move _23, move _24) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_5);\n        StorageDead(_4);\n        drop(_3) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}