{
  "name": "slice::sort::shared::pivot::choose_pivot",
  "safe": true,
  "callees": {
    "intrinsics::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the execution of the process.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n as its behavior is more user-friendly and more stable.\n\n The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n on most platforms.\n On Unix, the\n process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n `SIGBUS`.  The precise behavior is not guaranteed and not stable.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::pivot::median3": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the median of 3 elements.\n\n SAFETY: a, b, c must be valid initialized elements.\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::offset_from_unsigned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the distance between two pointers within the same allocation, *where it's known that\n `self` is equal to or greater than `origin`*. The returned value is in\n units of T: the distance in bytes is divided by `size_of::<T>()`.\n\n This computes the same value that [`offset_from`](#method.offset_from)\n would compute, but with the added precondition that the offset is\n guaranteed to be non-negative.  This method is equivalent to\n `usize::try_from(self.offset_from(origin)).unwrap_unchecked()`,\n but it provides slightly more information to the optimizer, which can\n sometimes allow it to optimize slightly better with some backends.\n\n This method can be thought of as recovering the `count` that was passed\n to [`add`](#method.add) (or, with the parameters in the other order,\n to [`sub`](#method.sub)).  The following are all equivalent, assuming\n that their safety preconditions are met:\n ```rust\n # unsafe fn blah(ptr: *const i32, origin: *const i32, count: usize) -> bool { unsafe {\n ptr.offset_from_unsigned(origin) == count\n # &&\n origin.add(count) == ptr\n # &&\n ptr.sub(count) == origin\n # } }\n ```\n\n # Safety\n\n - The distance between the pointers must be non-negative (`self >= origin`)\n\n - *All* the safety conditions of [`offset_from`](#method.offset_from)\n   apply to this method as well; see it for the full details.\n\n Importantly, despite the return type of this method being able to represent\n a larger offset, it's still *not permitted* to pass pointers which differ\n by more than `isize::MAX` *bytes*.  As such, the result of this method will\n always be less than or equal to `isize::MAX as usize`.\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n ```\n let a = [0; 5];\n let ptr1: *const i32 = &a[1];\n let ptr2: *const i32 = &a[3];\n unsafe {\n     assert_eq!(ptr2.offset_from_unsigned(ptr1), 2);\n     assert_eq!(ptr1.add(2), ptr2);\n     assert_eq!(ptr2.sub(2), ptr1);\n     assert_eq!(ptr2.offset_from_unsigned(ptr2), 0);\n }\n\n // This would be incorrect, as the pointers are not correctly ordered:\n // ptr1.offset_from_unsigned(ptr2)\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::pivot::median3_rec": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates an approximate median of 3 elements from sections a, b, c, or\n recursively from an approximation of each, if they're large enough. By\n dividing the size of each section by 8 when recursing we have logarithmic\n recursion depth and overall sample from f(n) = 3*f(n/8) -> f(n) =\n O(n^(log(3)/log(8))) ~= O(n^0.528) elements.\n\n SAFETY: a, b, c must point to the start of initialized regions of memory of\n at least n elements.\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::sort::shared::pivot::choose_pivot"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/pivot.rs:13:1: 45:2",
  "src": "pub fn choose_pivot<T, F: FnMut(&T, &T) -> bool>(v: &[T], is_less: &mut F) -> usize {\n    // We use unsafe code and raw pointers here because we're dealing with\n    // heavy recursion. Passing safe slices around would involve a lot of\n    // branches and function call overhead.\n\n    let len = v.len();\n    if len < 8 {\n        intrinsics::abort();\n    }\n\n    // SAFETY: a, b, c point to initialized regions of len_div_8 elements,\n    // satisfying median3 and median3_rec's preconditions as v_base points\n    // to an initialized region of n = len elements.\n    let index = unsafe {\n        let v_base = v.as_ptr();\n        let len_div_8 = len / 8;\n\n        let a = v_base; // [0, floor(n/8))\n        let b = v_base.add(len_div_8 * 4); // [4*floor(n/8), 5*floor(n/8))\n        let c = v_base.add(len_div_8 * 7); // [7*floor(n/8), 8*floor(n/8))\n\n        if len < PSEUDO_MEDIAN_REC_THRESHOLD {\n            median3(&*a, &*b, &*c, is_less).offset_from_unsigned(v_base)\n        } else {\n            median3_rec(a, b, c, len_div_8, is_less).offset_from_unsigned(v_base)\n        }\n    };\n    // SAFETY: preconditions must have been met for offset_from_unsigned()\n    unsafe {\n        hint::assert_unchecked(index < v.len());\n        index\n    }\n}",
  "mir": "fn slice::sort::shared::pivot::choose_pivot(_1: &[T], _2: &mut F) -> usize {\n    let mut _0: usize;\n    let  _3: usize;\n    let mut _4: bool;\n    let  _5: !;\n    let  _6: usize;\n    let  _7: *const T;\n    let  _8: usize;\n    let mut _9: bool;\n    let  _10: *const T;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let  _13: *const T;\n    let mut _14: usize;\n    let mut _15: (usize, bool);\n    let mut _16: bool;\n    let mut _17: *const T;\n    let  _18: &T;\n    let  _19: &T;\n    let  _20: &T;\n    let mut _21: *const T;\n    let  _22: ();\n    let mut _23: bool;\n    let mut _24: usize;\n    let mut _25: usize;\n    debug v => _1;\n    debug is_less => _2;\n    debug len => _3;\n    debug index => _6;\n    debug v_base => _7;\n    debug len_div_8 => _8;\n    debug a => _7;\n    debug b => _10;\n    debug c => _13;\n    bb0: {\n        _3 = PtrMetadata(_1);\n        StorageLive(_4);\n        _4 = Lt(_3, 8_usize);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _5 = intrinsics::abort() -> unwind unreachable;\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _7 = slice::<impl [T]>::as_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = Eq(8_usize, 0_usize);\n        assert(!move _9, \"attempt to divide `{}` by zero\", _3) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = Div(_3, 8_usize);\n        StorageLive(_11);\n        _12 = CheckedMul(_8, 4_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _8, 4_usize) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _11 = move (_12.0: usize);\n        _10 = ptr::const_ptr::<impl *const T>::add(_7, move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageLive(_14);\n        _15 = CheckedMul(_8, 7_usize);\n        assert(!move (_15.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _8, 7_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = move (_15.0: usize);\n        _13 = ptr::const_ptr::<impl *const T>::add(_7, move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = Lt(_3, slice::sort::shared::pivot::PSEUDO_MEDIAN_REC_THRESHOLD);\n        switchInt(move _16) -> [0: bb12, otherwise: bb9];\n    }\n    bb9: {\n        StorageLive(_17);\n        _18 = &(*_7);\n        _19 = &(*_10);\n        _20 = &(*_13);\n        _17 = slice::sort::shared::pivot::median3::<T, F>(_18, _19, _20, _2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _6 = ptr::const_ptr::<impl *const T>::offset_from_unsigned(move _17, _7) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        goto -> bb15;\n    }\n    bb12: {\n        StorageLive(_21);\n        _21 = slice::sort::shared::pivot::median3_rec::<T, F>(_7, _10, _13, _8, _2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _6 = ptr::const_ptr::<impl *const T>::offset_from_unsigned(move _21, _7) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_21);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_16);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = _6;\n        StorageLive(_25);\n        _25 = PtrMetadata(_1);\n        _23 = Lt(move _24, move _25);\n        StorageDead(_25);\n        StorageDead(_24);\n        _22 = hint::assert_unchecked(move _23) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        _0 = _6;\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Selects a pivot from `v`. Algorithm taken from glidesort by Orson Peters.\n\n This chooses a pivot by sampling an adaptive amount of points, approximating\n the quality of a median of sqrt(n) elements.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}