{
  "name": "num::flt2dec::strategy::grisu::format_exact_opt::possibly_round",
  "safe": false,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable (unique) reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in the\n slice really is in an initialized state. For instance, `.assume_init_mut()` cannot\n be used to initialize a `MaybeUninit` slice.\n",
      "adt": {}
    },
    "num::flt2dec::round_up": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " When `d` contains decimal digits, increase the last digit and propagate carry.\n Returns a next digit when it causes the length to change.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 46, kind: RigidTy(Uint(U8)) })])"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ]
  },
  "path": 14872,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/strategy/grisu.rs:648:5: 757:6",
  "src": "unsafe fn possibly_round(\n        buf: &mut [MaybeUninit<u8>],\n        mut len: usize,\n        mut exp: i16,\n        limit: i16,\n        remainder: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        debug_assert!(remainder < ten_kappa);\n\n        //           10^kappa\n        //    :   :   :<->:   :\n        //    :   :   :   :   :\n        //    :|1 ulp|1 ulp|  :\n        //    :|<--->|<--->|  :\n        // ----|-----|-----|----\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // (for the reference, the dotted line indicates the exact value for\n        // possible representations in given number of digits.)\n        //\n        // error is too large that there are at least three possible representations\n        // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n        if ulp >= ten_kappa {\n            return None;\n        }\n\n        //    10^kappa\n        //   :<------->:\n        //   :         :\n        //   : |1 ulp|1 ulp|\n        //   : |<--->|<--->|\n        // ----|-----|-----|----\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // in fact, 1/2 ulp is enough to introduce two possible representations.\n        // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n        // this won't overflow, as `ulp < ten_kappa` from the first check.\n        if ten_kappa - ulp <= ulp {\n            return None;\n        }\n\n        //     remainder\n        //       :<->|                           :\n        //       :   |                           :\n        //       :<--------- 10^kappa ---------->:\n        //     | :   |                           :\n        //     |1 ulp|1 ulp|                     :\n        //     |<--->|<--->|                     :\n        // ----|-----|-----|------------------------\n        //     |     v     |\n        // v - 1 ulp   v + 1 ulp\n        //\n        // if `v + 1 ulp` is closer to the rounded-down representation (which is already in `buf`),\n        // then we can safely return. note that `v - 1 ulp` *can* be less than the current\n        // representation, but as `1 ulp < 10^kappa / 2`, this condition is enough:\n        // the distance between `v - 1 ulp` and the current representation\n        // cannot exceed `10^kappa / 2`.\n        //\n        // the condition equals to `remainder + ulp < 10^kappa / 2`.\n        // since this can easily overflow, first check if `remainder < 10^kappa / 2`.\n        // we've already verified that `ulp < 10^kappa / 2`, so as long as\n        // `10^kappa` did not overflow after all, the second check is fine.\n        if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n            // SAFETY: our caller initialized that memory.\n            return Some((unsafe { buf[..len].assume_init_ref() }, exp));\n        }\n\n        //   :<------- remainder ------>|   :\n        //   :                          |   :\n        //   :<--------- 10^kappa --------->:\n        //   :                    |     |   : |\n        //   :                    |1 ulp|1 ulp|\n        //   :                    |<--->|<--->|\n        // -----------------------|-----|-----|-----\n        //                        |     v     |\n        //                    v - 1 ulp   v + 1 ulp\n        //\n        // on the other hands, if `v - 1 ulp` is closer to the rounded-up representation,\n        // we should round up and return. for the same reason we don't need to check `v + 1 ulp`.\n        //\n        // the condition equals to `remainder - ulp >= 10^kappa / 2`.\n        // again we first check if `remainder > ulp` (note that this is not `remainder >= ulp`,\n        // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n        // so the second check does not overflow.\n        if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n            if let Some(c) =\n                // SAFETY: our caller must have initialized that memory.\n                round_up(unsafe { buf[..len].assume_init_mut() })\n            {\n                // only add an additional digit when we've been requested the fixed precision.\n                // we also need to check that, if the original buffer was empty,\n                // the additional digit can only be added when `exp == limit` (edge case).\n                exp += 1;\n                if exp > limit && len < buf.len() {\n                    buf[len] = MaybeUninit::new(c);\n                    len += 1;\n                }\n            }\n            // SAFETY: we and our caller initialized that memory.\n            return Some((unsafe { buf[..len].assume_init_ref() }, exp));\n        }\n\n        // otherwise we are doomed (i.e., some values between `v - 1 ulp` and `v + 1 ulp` are\n        // rounding down and others are rounding up) and give up.\n        None\n    }",
  "mir": "fn num::flt2dec::strategy::grisu::format_exact_opt::possibly_round(_1: &mut [mem::maybe_uninit::MaybeUninit<u8>], _2: usize, _3: i16, _4: i16, _5: u64, _6: u64, _7: u64) -> option::Option<(&[u8], i16)> {\n    let mut _0: option::Option<(&[u8], i16)>;\n    let mut _8: bool;\n    let mut _9: !;\n    let mut _10: bool;\n    let mut _11: bool;\n    let mut _12: u64;\n    let mut _13: (u64, bool);\n    let mut _14: bool;\n    let mut _15: u64;\n    let mut _16: (u64, bool);\n    let mut _17: bool;\n    let mut _18: u64;\n    let mut _19: u64;\n    let mut _20: (u64, bool);\n    let mut _21: (u64, bool);\n    let mut _22: u64;\n    let mut _23: (u64, bool);\n    let mut _24: (&[u8], i16);\n    let  _25: &[u8];\n    let  _26: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _27: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _28: ops::range::RangeTo<usize>;\n    let mut _29: usize;\n    let mut _30: i16;\n    let mut _31: bool;\n    let mut _32: bool;\n    let mut _33: u64;\n    let mut _34: u64;\n    let mut _35: (u64, bool);\n    let mut _36: (u64, bool);\n    let mut _37: u64;\n    let mut _38: (u64, bool);\n    let mut _39: option::Option<u8>;\n    let mut _40: &mut [u8];\n    let mut _41: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _42: ops::range::RangeTo<usize>;\n    let mut _43: usize;\n    let mut _44: isize;\n    let  _45: u8;\n    let mut _46: (i16, bool);\n    let mut _47: bool;\n    let mut _48: i16;\n    let mut _49: bool;\n    let mut _50: usize;\n    let mut _51: usize;\n    let mut _52: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _53: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _54: usize;\n    let mut _55: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _56: usize;\n    let mut _57: bool;\n    let mut _58: (usize, bool);\n    let mut _59: (&[u8], i16);\n    let  _60: &[u8];\n    let  _61: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _62: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _63: ops::range::RangeTo<usize>;\n    let mut _64: usize;\n    let mut _65: i16;\n    debug buf => _1;\n    debug len => _2;\n    debug exp => _3;\n    debug limit => _4;\n    debug remainder => _5;\n    debug ten_kappa => _6;\n    debug ulp => _7;\n    debug c => _45;\n    bb0: {\n        StorageLive(_8);\n        _8 = Lt(_5, _6);\n        switchInt(move _8) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = Ge(_7, _6);\n        switchInt(move _10) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        _9 = panicking::panic(\"assertion failed: remainder < ten_kappa\") -> unwind unreachable;\n    }\n    bb3: {\n        _0 = option::Option::None;\n        StorageDead(_10);\n        goto -> bb44;\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _13 = CheckedSub(_6, _7);\n        assert(!move (_13.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, _7) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = move (_13.0: u64);\n        _11 = Le(move _12, _7);\n        switchInt(move _11) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_12);\n        _0 = option::Option::None;\n        StorageDead(_11);\n        goto -> bb44;\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = CheckedSub(_6, _5);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, _5) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = move (_16.0: u64);\n        _14 = Gt(move _15, _5);\n        switchInt(move _14) -> [0: bb17, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = CheckedMul(2_u64, _5);\n        assert(!move (_20.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u64, _5) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _19 = move (_20.0: u64);\n        _21 = CheckedSub(_6, _19);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, move _19) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = move (_21.0: u64);\n        StorageDead(_19);\n        StorageLive(_22);\n        _23 = CheckedMul(2_u64, _7);\n        assert(!move (_23.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u64, _7) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _22 = move (_23.0: u64);\n        _17 = Ge(move _18, move _22);\n        switchInt(move _17) -> [0: bb16, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageLive(_24);\n        StorageLive(_27);\n        _27 = &(*_1);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = _2;\n        _28 = RangeTo(move _29);\n        StorageDead(_29);\n        _26 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _27, move _28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_28);\n        StorageDead(_27);\n        _25 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_30);\n        _30 = _3;\n        _24 = (_25, move _30);\n        StorageDead(_30);\n        _0 = option::Option::Some(move _24);\n        StorageDead(_24);\n        StorageDead(_17);\n        StorageDead(_14);\n        goto -> bb44;\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_18);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_15);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_17);\n        StorageDead(_14);\n        StorageLive(_31);\n        _31 = Gt(_5, _7);\n        switchInt(move _31) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _35 = CheckedSub(_5, _7);\n        assert(!move (_35.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _7) -> [success: bb21, unwind unreachable];\n    }\n    bb20: {\n        goto -> bb43;\n    }\n    bb21: {\n        _34 = move (_35.0: u64);\n        _36 = CheckedSub(_6, _34);\n        assert(!move (_36.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, move _34) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _33 = move (_36.0: u64);\n        StorageDead(_34);\n        StorageLive(_37);\n        _38 = CheckedSub(_5, _7);\n        assert(!move (_38.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _7) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _37 = move (_38.0: u64);\n        _32 = Le(move _33, move _37);\n        switchInt(move _32) -> [0: bb42, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_37);\n        StorageDead(_33);\n        StorageLive(_39);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = _2;\n        _42 = RangeTo(move _43);\n        StorageDead(_43);\n        _41 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_1, move _42) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_42);\n        _40 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_41) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _39 = num::flt2dec::round_up(_40) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _44 = discriminant(_39);\n        switchInt(move _44) -> [1: bb28, 0: bb38, otherwise: bb45];\n    }\n    bb28: {\n        _45 = ((_39 as variant#1).0: u8);\n        _46 = CheckedAdd(_3, 1_i16);\n        assert(!move (_46.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, 1_i16) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _3 = move (_46.0: i16);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _3;\n        _47 = Gt(move _48, _4);\n        switchInt(move _47) -> [0: bb36, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = _2;\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &(*_1);\n        _51 = PtrMetadata(move _52);\n        StorageDead(_52);\n        _49 = Lt(move _50, move _51);\n        switchInt(move _49) -> [0: bb35, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_51);\n        StorageDead(_50);\n        StorageLive(_53);\n        _53 = mem::maybe_uninit::MaybeUninit::<u8>::new(_45) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_54);\n        _54 = _2;\n        _55 = &raw const (fake) (*_1);\n        _56 = PtrMetadata(move _55);\n        _57 = Lt(_54, _56);\n        assert(move _57, \"index out of bounds: the length is {} but the index is {}\", move _56, _54) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        (*_1)[_54] = move _53;\n        StorageDead(_53);\n        StorageDead(_54);\n        _58 = CheckedAdd(_2, 1_usize);\n        assert(!move (_58.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _2 = move (_58.0: usize);\n        goto -> bb37;\n    }\n    bb35: {\n        StorageDead(_51);\n        StorageDead(_50);\n        goto -> bb37;\n    }\n    bb36: {\n        StorageDead(_48);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_49);\n        StorageDead(_47);\n        StorageDead(_39);\n        goto -> bb39;\n    }\n    bb38: {\n        StorageDead(_39);\n        goto -> bb39;\n    }\n    bb39: {\n        StorageLive(_59);\n        StorageLive(_62);\n        _62 = &(*_1);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _2;\n        _63 = RangeTo(move _64);\n        StorageDead(_64);\n        _61 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _62, move _63) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_63);\n        StorageDead(_62);\n        _60 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_61) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageLive(_65);\n        _65 = _3;\n        _59 = (_60, move _65);\n        StorageDead(_65);\n        _0 = option::Option::Some(move _59);\n        StorageDead(_59);\n        StorageDead(_32);\n        StorageDead(_31);\n        goto -> bb44;\n    }\n    bb42: {\n        StorageDead(_37);\n        StorageDead(_33);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _0 = option::Option::None;\n        goto -> bb44;\n    }\n    bb44: {\n        return;\n    }\n    bb45: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}