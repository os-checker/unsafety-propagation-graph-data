{
  "name": "sync::atomic::compiler_fence",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "intrinsics::atomic_singlethreadfence": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An atomic fence for synchronization within a single thread.\n\n The stabilized version of this intrinsic is available in\n [`atomic::compiler_fence`].\n",
      "adt": {}
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sync::atomic::Ordering": [
      "Plain"
    ],
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::sync::atomic::compiler_fence"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:4566:1: 4577:2",
  "src": "pub fn compiler_fence(order: Ordering) {\n    // SAFETY: using an atomic fence is safe.\n    unsafe {\n        match order {\n            Acquire => intrinsics::atomic_singlethreadfence::<{ AO::Acquire }>(),\n            Release => intrinsics::atomic_singlethreadfence::<{ AO::Release }>(),\n            AcqRel => intrinsics::atomic_singlethreadfence::<{ AO::AcqRel }>(),\n            SeqCst => intrinsics::atomic_singlethreadfence::<{ AO::SeqCst }>(),\n            Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n        }\n    }\n}",
  "mir": "fn sync::atomic::compiler_fence(_1: sync::atomic::Ordering) -> () {\n    let mut _0: ();\n    let mut _2: isize;\n    let  _3: !;\n    let mut _4: fmt::Arguments<'_>;\n    debug order => _1;\n    bb0: {\n        _2 = discriminant(_1);\n        switchInt(move _2) -> [0: bb2, 1: bb5, 2: bb6, 3: bb4, 4: bb3, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = fmt::Arguments::<'_>::from_str(\"there is no such thing as a relaxed fence\") -> [return: bb7, unwind unreachable];\n    }\n    bb3: {\n        _0 = intrinsics::atomic_singlethreadfence::<intrinsics::AtomicOrdering::SeqCst>() -> [return: bb8, unwind unreachable];\n    }\n    bb4: {\n        _0 = intrinsics::atomic_singlethreadfence::<intrinsics::AtomicOrdering::AcqRel>() -> [return: bb8, unwind unreachable];\n    }\n    bb5: {\n        _0 = intrinsics::atomic_singlethreadfence::<intrinsics::AtomicOrdering::Release>() -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = intrinsics::atomic_singlethreadfence::<intrinsics::AtomicOrdering::Acquire>() -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        _3 = panicking::panic_fmt(move _4) -> unwind unreachable;\n    }\n    bb8: {\n        return;\n    }\n}\n",
  "doc": " A \"compiler-only\" atomic fence.\n\n Like [`fence`], this function establishes synchronization with other atomic operations and\n fences. However, unlike [`fence`], `compiler_fence` only establishes synchronization with\n operations *in the same thread*. This may at first sound rather useless, since code within a\n thread is typically already totally ordered and does not need any further synchronization.\n However, there are cases where code can run on the same thread without being ordered:\n - The most common case is that of a *signal handler*: a signal handler runs in the same thread\n   as the code it interrupted, but it is not ordered with respect to that code. `compiler_fence`\n   can be used to establish synchronization between a thread and its signal handler, the same way\n   that `fence` can be used to establish synchronization across threads.\n - Similar situations can arise in embedded programming with interrupt handlers, or in custom\n   implementations of preemptive green threads. In general, `compiler_fence` can establish\n   synchronization with code that is guaranteed to run on the same hardware CPU.\n\n See [`fence`] for how a fence can be used to achieve synchronization. Note that just like\n [`fence`], synchronization still requires atomic operations to be used in both threads -- it is\n not possible to perform synchronization entirely with fences and non-atomic operations.\n\n `compiler_fence` does not emit any machine code, but restricts the kinds of memory re-ordering\n the compiler is allowed to do. `compiler_fence` corresponds to [`atomic_signal_fence`] in C and\n C++.\n\n [`atomic_signal_fence`]: https://en.cppreference.com/w/cpp/atomic/atomic_signal_fence\n\n # Panics\n\n Panics if `order` is [`Relaxed`].\n\n # Examples\n\n Without the two `compiler_fence` calls, the read of `IMPORTANT_VARIABLE` in `signal_handler`\n is *undefined behavior* due to a data race, despite everything happening in a single thread.\n This is because the signal handler is considered to run concurrently with its associated\n thread, and explicit synchronization is required to pass data between a thread and its\n signal handler. The code below uses two `compiler_fence` calls to establish the usual\n release-acquire synchronization pattern (see [`fence`] for an image).\n\n ```\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering;\n use std::sync::atomic::compiler_fence;\n\n static mut IMPORTANT_VARIABLE: usize = 0;\n static IS_READY: AtomicBool = AtomicBool::new(false);\n\n fn main() {\n     unsafe { IMPORTANT_VARIABLE = 42 };\n     // Marks earlier writes as being released with future relaxed stores.\n     compiler_fence(Ordering::Release);\n     IS_READY.store(true, Ordering::Relaxed);\n }\n\n fn signal_handler() {\n     if IS_READY.load(Ordering::Relaxed) {\n         // Acquires writes that were released with relaxed stores that we read from.\n         compiler_fence(Ordering::Acquire);\n         assert_eq!(unsafe { IMPORTANT_VARIABLE }, 42);\n     }\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}