{
  "name": "slice::memchr::memchr_aligned::runtime",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::align_offset": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.\n\n If it is not possible to align the pointer, the implementation returns\n `usize::MAX`.\n\n The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n used with the `wrapping_add` method.\n\n There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n beyond the allocation that the pointer points into. It is up to the caller to ensure that\n the returned offset is correct in all terms other than alignment.\n\n # Panics\n\n The function panics if `align` is not a power-of-two.\n\n # Examples\n\n Accessing adjacent `u8` as `u16`\n\n ```\n # unsafe {\n let x = [5_u8, 6, 7, 8, 9];\n let ptr = x.as_ptr();\n let offset = ptr.align_offset(align_of::<u16>());\n\n if offset < x.len() - 1 {\n     let u16_ptr = ptr.add(offset).cast::<u16>();\n     assert!(*u16_ptr == u16::from_ne_bytes([5, 6]) || *u16_ptr == u16::from_ne_bytes([6, 7]));\n } else {\n     // while the pointer can be aligned via `offset`, it would point\n     // outside the allocation\n }\n # }\n ```\n",
      "adt": {}
    },
    "cmp::Ord::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.min(2), 1);\n assert_eq!(2.min(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").min(Equal(\"other\")).0, \"self\");\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::memchr::memchr_naive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl usize>::repeat_u8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an `usize` where every byte is equal to `x`.\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "slice::memchr::contains_zero_byte": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `x` contains any zero byte.\n\n From *Matters Computational*, J. Arndt:\n\n \"The idea is to subtract one from each of the bytes and then look for\n bytes where the borrow propagated all the way to the most significant\n bit.\"\n",
      "adt": {}
    },
    "slice::raw::from_raw_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for reads for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations. See [below](#incorrect-usage)\n       for an example incorrectly not taking this into account.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be mutated for the duration\n   of lifetime `'a`, except inside an `UnsafeCell`.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To\n prevent accidental misuse, it's suggested to tie the lifetime to whichever\n source lifetime is safe in the context, such as by providing a helper\n function taking the lifetime of a host value for the slice, or by explicit\n annotation.\n\n # Examples\n\n ```\n use std::slice;\n\n // manifest a slice for a single element\n let x = 42;\n let ptr = &x as *const _;\n let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n assert_eq!(slice[0], 42);\n ```\n\n ### Incorrect usage\n\n The following `join_slices` function is **unsound** ⚠️\n\n ```rust,no_run\n use std::slice;\n\n fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n     let snd_start = snd.as_ptr();\n     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n     unsafe {\n         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n         // still be contained within _different allocations_, in which case\n         // creating this slice is undefined behavior.\n         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n     }\n }\n\n fn main() {\n     // `a` and `b` are different allocations...\n     let a = 42;\n     let b = 27;\n     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n }\n ```\n\n ### FFI: Handling null pointers\n\n In languages such as C++, pointers to empty collections are not guaranteed to be non-null.\n When accepting such pointers, they have to be checked for null-ness to avoid undefined\n behavior.\n\n ```\n use std::slice;\n\n /// Sum the elements of an FFI slice.\n ///\n /// # Safety\n ///\n /// If ptr is not NULL, it must be correctly aligned and\n /// point to `len` initialized items of type `f32`.\n unsafe extern \"C\" fn sum_slice(ptr: *const f32, len: usize) -> f32 {\n     let data = if ptr.is_null() {\n         // `len` is assumed to be 0.\n         &[]\n     } else {\n         // SAFETY: see function docstring.\n         unsafe { slice::from_raw_parts(ptr, len) }\n     };\n     data.into_iter().sum()\n }\n\n // This could be the result of C++'s std::vector::data():\n let ptr = std::ptr::null();\n // And this could be std::vector::size():\n let len = 0;\n assert_eq!(unsafe { sum_slice(ptr, len) }, 0.0);\n ```\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::RangeTo": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::memchr::memchr_aligned::runtime"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2437:9: 2439:10",
  "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
  "mir": "fn slice::memchr::memchr_aligned::runtime(_1: u8, _2: &[u8]) -> option::Option<usize> {\n    let mut _0: option::Option<usize>;\n    let  _3: usize;\n    let  _4: *const u8;\n    let mut _5: usize;\n    let mut _6: bool;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: usize;\n    let  _10: &[u8];\n    let mut _11: ops::range::RangeTo<usize>;\n    let mut _12: usize;\n    let mut _13: option::Option<usize>;\n    let mut _14: isize;\n    let  _15: usize;\n    let  _16: usize;\n    let mut _17: bool;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: (usize, bool);\n    let  _23: usize;\n    let mut _24: *const usize;\n    let mut _25: *const u8;\n    let mut _26: usize;\n    let  _27: usize;\n    let mut _28: *const usize;\n    let mut _29: *const u8;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    let  _33: bool;\n    let mut _34: usize;\n    let  _35: bool;\n    let mut _36: usize;\n    let mut _37: usize;\n    let mut _38: (usize, bool);\n    let mut _39: (usize, bool);\n    let  _40: &[u8];\n    let mut _41: *const u8;\n    let mut _42: *const u8;\n    let mut _43: usize;\n    let mut _44: usize;\n    let mut _45: usize;\n    let mut _46: usize;\n    let mut _47: (usize, bool);\n    let mut _48: option::Option<usize>;\n    let mut _49: isize;\n    let  _50: usize;\n    let mut _51: usize;\n    let mut _52: usize;\n    let mut _53: (usize, bool);\n    debug x => _1;\n    debug text => _2;\n    debug len => _3;\n    debug ptr => _4;\n    debug offset => _5;\n    debug slice => _10;\n    debug index => _15;\n    debug repeated_x => _16;\n    debug u => _23;\n    debug v => _27;\n    debug zu => _33;\n    debug zv => _35;\n    debug slice => _40;\n    debug i => _50;\n    bb0: {\n        _3 = PtrMetadata(_2);\n        _4 = slice::<impl [u8]>::as_ptr(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = ptr::const_ptr::<impl *const u8>::align_offset(_4, slice::memchr::USIZE_BYTES) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _5;\n        _6 = Gt(move _7, 0_usize);\n        switchInt(move _6) -> [0: bb9, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = _5;\n        _8 = <usize as cmp::Ord>::min(move _9, _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _5 = move _8;\n        StorageDead(_8);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _5;\n        _11 = RangeTo(move _12);\n        StorageDead(_12);\n        _10 = <[u8] as ops::index::Index<ops::range::RangeTo<usize>>>::index(_2, move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageLive(_13);\n        _13 = slice::memchr::memchr_naive(_1, _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _14 = discriminant(_13);\n        switchInt(move _14) -> [1: bb7, 0: bb8, otherwise: bb38];\n    }\n    bb7: {\n        _15 = ((_13 as variant#1).0: usize);\n        _0 = option::Option::Some(_15);\n        StorageDead(_13);\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb37;\n    }\n    bb8: {\n        StorageDead(_13);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_7);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_6);\n        _16 = num::<impl usize>::repeat_u8(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _5;\n        StorageLive(_19);\n        StorageLive(_20);\n        _21 = CheckedMul(2_usize, slice::memchr::USIZE_BYTES);\n        assert(!move (_21.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, slice::memchr::USIZE_BYTES) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_21.0: usize);\n        _22 = CheckedSub(_3, _20);\n        assert(!move (_22.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _20) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _19 = move (_22.0: usize);\n        StorageDead(_20);\n        _17 = Le(move _18, move _19);\n        switchInt(move _17) -> [0: bb26, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = _5;\n        _25 = ptr::const_ptr::<impl *const u8>::add(_4, move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _24 = move _25 as *const usize;\n        StorageDead(_25);\n        _23 = (*_24);\n        StorageDead(_24);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = _5;\n        _32 = CheckedAdd(_31, slice::memchr::USIZE_BYTES);\n        assert(!move (_32.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _31, slice::memchr::USIZE_BYTES) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _30 = move (_32.0: usize);\n        StorageDead(_31);\n        _29 = ptr::const_ptr::<impl *const u8>::add(_4, move _30) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        _28 = move _29 as *const usize;\n        StorageDead(_29);\n        _27 = (*_28);\n        StorageDead(_28);\n        StorageLive(_34);\n        _34 = BitXor(_23, _16);\n        _33 = slice::memchr::contains_zero_byte(move _34) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_34);\n        StorageLive(_36);\n        _36 = BitXor(_27, _16);\n        _35 = slice::memchr::contains_zero_byte(move _36) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_36);\n        switchInt(_33) -> [0: bb21, otherwise: bb22];\n    }\n    bb21: {\n        switchInt(_35) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        goto -> bb27;\n    }\n    bb23: {\n        StorageLive(_37);\n        _38 = CheckedMul(slice::memchr::USIZE_BYTES, 2_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} * {}`, which would overflow\", slice::memchr::USIZE_BYTES, 2_usize) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _37 = move (_38.0: usize);\n        _39 = CheckedAdd(_5, _37);\n        assert(!move (_39.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, move _37) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _5 = move (_39.0: usize);\n        StorageDead(_37);\n        StorageDead(_17);\n        goto -> bb12;\n    }\n    bb26: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_17);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = slice::<impl [u8]>::as_ptr(_2) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageLive(_43);\n        _43 = _5;\n        _41 = ptr::const_ptr::<impl *const u8>::add(move _42, move _43) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = PtrMetadata(_2);\n        StorageLive(_46);\n        _46 = _5;\n        _47 = CheckedSub(_45, _46);\n        assert(!move (_47.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _45, move _46) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _44 = move (_47.0: usize);\n        StorageDead(_46);\n        StorageDead(_45);\n        _40 = slice::raw::from_raw_parts::<'_, u8>(move _41, move _44) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_44);\n        StorageDead(_41);\n        StorageLive(_48);\n        _48 = slice::memchr::memchr_naive(_1, _40) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _49 = discriminant(_48);\n        switchInt(move _49) -> [1: bb33, 0: bb35, otherwise: bb38];\n    }\n    bb33: {\n        _50 = ((_48 as variant#1).0: usize);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = _5;\n        _53 = CheckedAdd(_52, _50);\n        assert(!move (_53.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _52, _50) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _51 = move (_53.0: usize);\n        StorageDead(_52);\n        _0 = option::Option::Some(move _51);\n        StorageDead(_51);\n        StorageDead(_48);\n        goto -> bb36;\n    }\n    bb35: {\n        StorageDead(_48);\n        _0 = option::Option::None;\n        goto -> bb36;\n    }\n    bb36: {\n        StorageDead(_5);\n        goto -> bb37;\n    }\n    bb37: {\n        return;\n    }\n    bb38: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}