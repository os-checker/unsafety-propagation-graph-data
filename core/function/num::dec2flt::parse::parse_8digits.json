{
  "name": "num::dec2flt::parse::parse_8digits",
  "safe": true,
  "callees": {
    "num::<impl u64>::wrapping_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) multiplication. Computes `self *\n rhs`, wrapping around at the boundary of the type.\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u8` is used.\n\n ```\n assert_eq!(10u8.wrapping_mul(12), 120);\n assert_eq!(25u8.wrapping_mul(12), 44);\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 14790,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/parse.rs:17:1: 26:2",
  "src": "fn parse_8digits(mut v: u64) -> u64 {\n    const MASK: u64 = 0x0000_00FF_0000_00FF;\n    const MUL1: u64 = 0x000F_4240_0000_0064;\n    const MUL2: u64 = 0x0000_2710_0000_0001;\n    v -= 0x3030_3030_3030_3030;\n    v = (v * 10) + (v >> 8); // will not overflow, fits in 63 bits\n    let v1 = (v & MASK).wrapping_mul(MUL1);\n    let v2 = ((v >> 16) & MASK).wrapping_mul(MUL2);\n    ((v1.wrapping_add(v2) >> 32) as u32) as u64\n}",
  "mir": "fn num::dec2flt::parse::parse_8digits(_1: u64) -> u64 {\n    let mut _0: u64;\n    let mut _2: (u64, bool);\n    let mut _3: u64;\n    let mut _4: u64;\n    let mut _5: (u64, bool);\n    let mut _6: u64;\n    let mut _7: u64;\n    let mut _8: u32;\n    let mut _9: bool;\n    let mut _10: (u64, bool);\n    let  _11: u64;\n    let mut _12: u64;\n    let mut _13: u64;\n    let  _14: u64;\n    let mut _15: u64;\n    let mut _16: u64;\n    let mut _17: u64;\n    let mut _18: u32;\n    let mut _19: bool;\n    let mut _20: u32;\n    let mut _21: u64;\n    let mut _22: u64;\n    let mut _23: u32;\n    let mut _24: bool;\n    debug v => _1;\n    debug v1 => _11;\n    debug v2 => _14;\n    bb0: {\n        _2 = CheckedSub(_1, 3472328296227680304_u64);\n        assert(!move (_2.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _1, 3472328296227680304_u64) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = move (_2.0: u64);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = _1;\n        _5 = CheckedMul(_4, 10_u64);\n        assert(!move (_5.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _4, 10_u64) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = move (_5.0: u64);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _1;\n        _8 = 8_i32 as u32;\n        _9 = Lt(move _8, 64_u32);\n        assert(move _9, \"attempt to shift right by `{}`, which would overflow\", 8_i32) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = Shr(move _7, 8_i32);\n        StorageDead(_7);\n        _10 = CheckedAdd(_3, _6);\n        assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _3, move _6) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _1 = move (_10.0: u64);\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = _1;\n        _12 = BitAnd(move _13, num::dec2flt::parse::parse_8digits::MASK);\n        StorageDead(_13);\n        _11 = num::<impl u64>::wrapping_mul(move _12, num::dec2flt::parse::parse_8digits::MUL1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _1;\n        _18 = 16_i32 as u32;\n        _19 = Lt(move _18, 64_u32);\n        assert(move _19, \"attempt to shift right by `{}`, which would overflow\", 16_i32) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _16 = Shr(move _17, 16_i32);\n        StorageDead(_17);\n        _15 = BitAnd(move _16, num::dec2flt::parse::parse_8digits::MASK);\n        StorageDead(_16);\n        _14 = num::<impl u64>::wrapping_mul(move _15, num::dec2flt::parse::parse_8digits::MUL2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_15);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = num::<impl u64>::wrapping_add(_11, _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _23 = 32_i32 as u32;\n        _24 = Lt(move _23, 64_u32);\n        assert(move _24, \"attempt to shift right by `{}`, which would overflow\", 32_i32) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _21 = Shr(move _22, 32_i32);\n        StorageDead(_22);\n        _20 = move _21 as u32;\n        StorageDead(_21);\n        _0 = move _20 as u64;\n        StorageDead(_20);\n        return;\n    }\n}\n",
  "doc": " Parse 8 digits, loaded as bytes in little-endian order.\n\n This uses the trick where every digit is in [0x030, 0x39],\n and therefore can be parsed in 3 multiplications, much\n faster than the normal 8.\n\n This is based off the algorithm described in \"Fast numeric string to\n int\", available here: <https://johnnylee-sde.github.io/Fast-numeric-string-to-int/>.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}