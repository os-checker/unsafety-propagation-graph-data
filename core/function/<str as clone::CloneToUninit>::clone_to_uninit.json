{
  "name": "<str as clone::CloneToUninit>::clone_to_uninit",
  "safe": false,
  "callees": {
    "str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "clone::CloneToUninit::clone_to_uninit": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs copy-assignment from `self` to `dest`.\n\n This is analogous to `std::ptr::write(dest.cast(), self.clone())`,\n except that `Self` may be a dynamically-sized type ([`!Sized`](Sized)).\n\n Before this function is called, `dest` may point to uninitialized memory.\n After this function is called, `dest` will point to initialized memory; it will be\n sound to create a `&Self` reference from the pointer with the [pointer metadata]\n from `self`.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dest` must be [valid] for writes for `size_of_val(self)` bytes.\n * `dest` must be properly aligned to `align_of_val(self)`.\n\n [valid]: crate::ptr#safety\n [pointer metadata]: crate::ptr::metadata()\n\n # Panics\n\n This function may panic. (For example, it might panic if memory allocation for a clone\n of a value owned by `self` fails.)\n If the call panics, then `*dest` should be treated as uninitialized memory; it must not be\n read or dropped, because even if it was previously valid, it may have been partially\n overwritten.\n\n The caller may wish to take care to deallocate the allocation pointed to by `dest`,\n if applicable, to avoid a memory leak (but this is not a requirement).\n\n Implementors should avoid leaking values by, upon unwinding, dropping all component values\n that might have already been created. (For example, if a `[Foo]` of length 3 is being\n cloned, and the second of the three calls to `Foo::clone()` unwinds, then the first `Foo`\n cloned should be dropped.)\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 3066,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs:570:5: 573:6",
  "src": "unsafe fn clone_to_uninit(&self, dest: *mut u8) {\n        // SAFETY: str is just a [u8] with UTF-8 invariant\n        unsafe { self.as_bytes().clone_to_uninit(dest) }\n    }",
  "mir": "fn <str as clone::CloneToUninit>::clone_to_uninit(_1: &str, _2: *mut u8) -> () {\n    let mut _0: ();\n    let  _3: &[u8];\n    debug self => _1;\n    debug dest => _2;\n    bb0: {\n        _3 = str::<impl str>::as_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = <[u8] as clone::CloneToUninit>::clone_to_uninit(_3, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}