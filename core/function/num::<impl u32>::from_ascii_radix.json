{
  "name": "num::<impl u32>::from_ascii_radix",
  "safe": true,
  "callees": {
    "num::from_ascii_radix_panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "num::can_not_overflow": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Determines if a string of text of that length of that radix could be guaranteed to be\n stored in the given type T.\n Note that if the radix is known to the compiler, it is just the check of digits.len that\n is done at runtime.\n",
      "adt": {}
    },
    "char::methods::<impl char>::to_digit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a `char` to a digit in the given radix.\n\n A 'radix' here is sometimes also called a 'base'. A radix of two\n indicates a binary number, a radix of ten, decimal, and a radix of\n sixteen, hexadecimal, to give some common values. Arbitrary\n radices are supported.\n\n 'Digit' is defined to be only the following characters:\n\n * `0-9`\n * `a-z`\n * `A-Z`\n\n # Errors\n\n Returns `None` if the `char` does not refer to a digit in the given radix.\n\n # Panics\n\n Panics if given a radix smaller than 2 or larger than 36.\n\n # Examples\n\n Basic usage:\n\n ```\n assert_eq!('1'.to_digit(10), Some(1));\n assert_eq!('f'.to_digit(16), Some(15));\n ```\n\n Passing a non-digit results in failure:\n\n ```\n assert_eq!('f'.to_digit(10), None);\n assert_eq!('z'.to_digit(16), None);\n ```\n\n Passing a large radix, causing a panic:\n\n ```should_panic\n // this panics\n let _ = '1'.to_digit(37);\n ```\n Passing a small radix, causing a panic:\n\n ```should_panic\n // this panics\n let _ = '1'.to_digit(1);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl u32>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl u32>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl u32>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "num::error::IntErrorKind": [
      "Plain"
    ],
    "num::error::ParseIntError": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Uint(U32)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::<impl u32>::from_ascii_radix"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:1573:13: 1661:14",
  "src": "pub const fn from_ascii_radix(src: &[u8], radix: u32) -> Result<$int_ty, ParseIntError> {\n                use self::IntErrorKind::*;\n                use self::ParseIntError as PIE;\n\n                if 2 > radix || radix > 36 {\n                    from_ascii_radix_panic(radix);\n                }\n\n                if src.is_empty() {\n                    return Err(PIE { kind: Empty });\n                }\n\n                #[allow(unused_comparisons)]\n                let is_signed_ty = 0 > <$int_ty>::MIN;\n\n                let (is_positive, mut digits) = match src {\n                    [b'+' | b'-'] => {\n                        return Err(PIE { kind: InvalidDigit });\n                    }\n                    [b'+', rest @ ..] => (true, rest),\n                    [b'-', rest @ ..] if is_signed_ty => (false, rest),\n                    _ => (true, src),\n                };\n\n                let mut result = 0;\n\n                macro_rules! unwrap_or_PIE {\n                    ($option:expr, $kind:ident) => {\n                        match $option {\n                            Some(value) => value,\n                            None => return Err(PIE { kind: $kind }),\n                        }\n                    };\n                }\n\n                if can_not_overflow::<$int_ty>(radix, is_signed_ty, digits) {\n                    // If the len of the str is short compared to the range of the type\n                    // we are parsing into, then we can be certain that an overflow will not occur.\n                    // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition\n                    // above is a faster (conservative) approximation of this.\n                    //\n                    // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:\n                    // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.\n                    // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.\n                    macro_rules! run_unchecked_loop {\n                        ($unchecked_additive_op:tt) => {{\n                            while let [c, rest @ ..] = digits {\n                                result = result * (radix as $int_ty);\n                                let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit);\n                                result = result $unchecked_additive_op (x as $int_ty);\n                                digits = rest;\n                            }\n                        }};\n                    }\n                    if is_positive {\n                        run_unchecked_loop!(+)\n                    } else {\n                        run_unchecked_loop!(-)\n                    };\n                } else {\n                    macro_rules! run_checked_loop {\n                        ($checked_additive_op:ident, $overflow_err:ident) => {{\n                            while let [c, rest @ ..] = digits {\n                                // When `radix` is passed in as a literal, rather than doing a slow `imul`\n                                // the compiler can use shifts if `radix` can be expressed as a\n                                // sum of powers of 2 (x*10 can be written as x*8 + x*2).\n                                // When the compiler can't use these optimisations,\n                                // the latency of the multiplication can be hidden by issuing it\n                                // before the result is needed to improve performance on\n                                // modern out-of-order CPU as multiplication here is slower\n                                // than the other instructions, we can get the end result faster\n                                // doing multiplication first and let the CPU spends other cycles\n                                // doing other computation and get multiplication result later.\n                                let mul = result.checked_mul(radix as $int_ty);\n                                let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit) as $int_ty;\n                                result = unwrap_or_PIE!(mul, $overflow_err);\n                                result = unwrap_or_PIE!(<$int_ty>::$checked_additive_op(result, x), $overflow_err);\n                                digits = rest;\n                            }\n                        }};\n                    }\n                    if is_positive {\n                        run_checked_loop!(checked_add, PosOverflow)\n                    } else {\n                        run_checked_loop!(checked_sub, NegOverflow)\n                    };\n                }\n                Ok(result)\n            }",
  "mir": "fn num::<impl u32>::from_ascii_radix(_1: &[u8], _2: u32) -> result::Result<u32, num::error::ParseIntError> {\n    let mut _0: result::Result<u32, num::error::ParseIntError>;\n    let mut _3: bool;\n    let mut _4: bool;\n    let  _5: !;\n    let mut _6: bool;\n    let mut _7: num::error::ParseIntError;\n    let mut _8: num::error::IntErrorKind;\n    let  _9: bool;\n    let  _10: bool;\n    let mut _11: &[u8];\n    let mut _12: (bool, &[u8]);\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: bool;\n    let mut _16: num::error::ParseIntError;\n    let mut _17: num::error::IntErrorKind;\n    let  _18: &[u8];\n    let  _19: &[u8];\n    let  _20: &&[u8];\n    let mut _21: u32;\n    let mut _22: bool;\n    let mut _23: &[u8];\n    let mut _24: usize;\n    let mut _25: bool;\n    let  _26: &u8;\n    let  _27: &[u8];\n    let mut _28: u32;\n    let mut _29: (u32, bool);\n    let mut _30: option::Option<u32>;\n    let mut _31: char;\n    let mut _32: u8;\n    let mut _33: isize;\n    let  _34: u32;\n    let mut _35: num::error::ParseIntError;\n    let mut _36: num::error::IntErrorKind;\n    let mut _37: u32;\n    let mut _38: (u32, bool);\n    let mut _39: usize;\n    let mut _40: bool;\n    let  _41: &u8;\n    let  _42: &[u8];\n    let mut _43: u32;\n    let mut _44: (u32, bool);\n    let mut _45: option::Option<u32>;\n    let mut _46: char;\n    let mut _47: u8;\n    let mut _48: isize;\n    let  _49: u32;\n    let mut _50: num::error::ParseIntError;\n    let mut _51: num::error::IntErrorKind;\n    let mut _52: u32;\n    let mut _53: (u32, bool);\n    let mut _54: usize;\n    let mut _55: bool;\n    let  _56: &u8;\n    let  _57: &[u8];\n    let  _58: option::Option<u32>;\n    let mut _59: u32;\n    let mut _60: option::Option<u32>;\n    let mut _61: char;\n    let mut _62: u8;\n    let mut _63: isize;\n    let  _64: u32;\n    let mut _65: num::error::ParseIntError;\n    let mut _66: num::error::IntErrorKind;\n    let mut _67: isize;\n    let  _68: u32;\n    let mut _69: num::error::ParseIntError;\n    let mut _70: num::error::IntErrorKind;\n    let mut _71: option::Option<u32>;\n    let mut _72: u32;\n    let mut _73: isize;\n    let  _74: u32;\n    let mut _75: num::error::ParseIntError;\n    let mut _76: num::error::IntErrorKind;\n    let mut _77: usize;\n    let mut _78: bool;\n    let  _79: &u8;\n    let  _80: &[u8];\n    let  _81: option::Option<u32>;\n    let mut _82: u32;\n    let mut _83: option::Option<u32>;\n    let mut _84: char;\n    let mut _85: u8;\n    let mut _86: isize;\n    let  _87: u32;\n    let mut _88: num::error::ParseIntError;\n    let mut _89: num::error::IntErrorKind;\n    let mut _90: isize;\n    let  _91: u32;\n    let mut _92: num::error::ParseIntError;\n    let mut _93: num::error::IntErrorKind;\n    let mut _94: option::Option<u32>;\n    let mut _95: u32;\n    let mut _96: isize;\n    let  _97: u32;\n    let mut _98: num::error::ParseIntError;\n    let mut _99: num::error::IntErrorKind;\n    let mut _100: u32;\n    debug src => _1;\n    debug radix => _2;\n    debug is_signed_ty => _9;\n    debug is_positive => _10;\n    debug digits => _11;\n    debug rest => _18;\n    debug rest => _19;\n    debug rest => _20;\n    debug result => _21;\n    debug c => _26;\n    debug rest => _27;\n    debug x => _34;\n    debug value => _34;\n    debug c => _41;\n    debug rest => _42;\n    debug x => _49;\n    debug value => _49;\n    debug c => _56;\n    debug rest => _57;\n    debug mul => _58;\n    debug x => _64;\n    debug value => _64;\n    debug value => _68;\n    debug value => _74;\n    debug c => _79;\n    debug rest => _80;\n    debug mul => _81;\n    debug x => _87;\n    debug value => _87;\n    debug value => _91;\n    debug value => _97;\n    bb0: {\n        StorageLive(_3);\n        _3 = Gt(2_u32, _2);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        goto -> bb4;\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = Gt(_2, 36_u32);\n        switchInt(move _4) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        _5 = num::from_ascii_radix_panic(_2) -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        _6 = slice::<impl [u8]>::is_empty(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _6) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = num::error::IntErrorKind::Empty;\n        _7 = ParseIntError(move _8);\n        StorageDead(_8);\n        _0 = result::Result::Err(move _7);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb68;\n    }\n    bb8: {\n        StorageDead(_6);\n        _9 = Gt(0_u32, num::<impl u32>::MIN);\n        StorageLive(_12);\n        _13 = PtrMetadata(_1);\n        switchInt(_13) -> [1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        _14 = PtrMetadata(_1);\n        _15 = Ge(_14, 1_usize);\n        switchInt(move _15) -> [0: bb11, otherwise: bb12];\n    }\n    bb10: {\n        switchInt((*_1)[0 of 1]) -> [43: bb15, 45: bb15, otherwise: bb9];\n    }\n    bb11: {\n        _12 = (true, _1);\n        goto -> bb18;\n    }\n    bb12: {\n        switchInt((*_1)[0 of 1]) -> [43: bb14, 45: bb13, otherwise: bb11];\n    }\n    bb13: {\n        StorageLive(_20);\n        _19 = &(*_1)[1:];\n        _20 = &_19;\n        switchInt(_9) -> [0: bb17, otherwise: bb16];\n    }\n    bb14: {\n        _18 = &(*_1)[1:];\n        _12 = (true, _18);\n        goto -> bb18;\n    }\n    bb15: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = num::error::IntErrorKind::InvalidDigit;\n        _16 = ParseIntError(move _17);\n        StorageDead(_17);\n        _0 = result::Result::Err(move _16);\n        StorageDead(_16);\n        StorageDead(_12);\n        goto -> bb67;\n    }\n    bb16: {\n        _12 = (false, _19);\n        StorageDead(_20);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_20);\n        goto -> bb11;\n    }\n    bb18: {\n        _10 = (_12.0: bool);\n        StorageLive(_11);\n        _11 = (_12.1: &[u8]);\n        StorageDead(_12);\n        StorageLive(_21);\n        _21 = 0_u32;\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = _11;\n        _22 = num::can_not_overflow::<u32>(_2, _9, move _23) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        switchInt(move _22) -> [0: bb37, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_23);\n        switchInt(_10) -> [0: bb29, otherwise: bb21];\n    }\n    bb21: {\n        _24 = PtrMetadata(_11);\n        _25 = Ge(_24, 1_usize);\n        switchInt(move _25) -> [0: bb36, otherwise: bb22];\n    }\n    bb22: {\n        StorageLive(_26);\n        _26 = &(*_11)[0 of 1];\n        _27 = &(*_11)[1:];\n        StorageLive(_28);\n        _28 = _21;\n        _29 = CheckedMul(_28, _2);\n        assert(!move (_29.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _28, _2) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _21 = move (_29.0: u32);\n        StorageDead(_28);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = (*_26);\n        _31 = move _32 as char;\n        StorageDead(_32);\n        _30 = char::methods::<impl char>::to_digit(move _31, _2) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_31);\n        _33 = discriminant(_30);\n        switchInt(move _33) -> [0: bb26, 1: bb27, otherwise: bb25];\n    }\n    bb25: {\n        unreachable;\n    }\n    bb26: {\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = num::error::IntErrorKind::InvalidDigit;\n        _35 = ParseIntError(move _36);\n        StorageDead(_36);\n        _0 = result::Result::Err(move _35);\n        StorageDead(_35);\n        StorageDead(_30);\n        StorageDead(_26);\n        goto -> bb65;\n    }\n    bb27: {\n        _34 = ((_30 as variant#1).0: u32);\n        StorageDead(_30);\n        StorageLive(_37);\n        _37 = _21;\n        _38 = CheckedAdd(_37, _34);\n        assert(!move (_38.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _37, _34) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _21 = move (_38.0: u32);\n        StorageDead(_37);\n        _11 = _27;\n        StorageDead(_26);\n        goto -> bb21;\n    }\n    bb29: {\n        _39 = PtrMetadata(_11);\n        _40 = Ge(_39, 1_usize);\n        switchInt(move _40) -> [0: bb36, otherwise: bb30];\n    }\n    bb30: {\n        StorageLive(_41);\n        _41 = &(*_11)[0 of 1];\n        _42 = &(*_11)[1:];\n        StorageLive(_43);\n        _43 = _21;\n        _44 = CheckedMul(_43, _2);\n        assert(!move (_44.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _43, _2) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _21 = move (_44.0: u32);\n        StorageDead(_43);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = (*_41);\n        _46 = move _47 as char;\n        StorageDead(_47);\n        _45 = char::methods::<impl char>::to_digit(move _46, _2) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_46);\n        _48 = discriminant(_45);\n        switchInt(move _48) -> [0: bb33, 1: bb34, otherwise: bb25];\n    }\n    bb33: {\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = num::error::IntErrorKind::InvalidDigit;\n        _50 = ParseIntError(move _51);\n        StorageDead(_51);\n        _0 = result::Result::Err(move _50);\n        StorageDead(_50);\n        StorageDead(_45);\n        StorageDead(_41);\n        goto -> bb65;\n    }\n    bb34: {\n        _49 = ((_45 as variant#1).0: u32);\n        StorageDead(_45);\n        StorageLive(_52);\n        _52 = _21;\n        _53 = CheckedSub(_52, _49);\n        assert(!move (_53.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _52, _49) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _21 = move (_53.0: u32);\n        StorageDead(_52);\n        _11 = _42;\n        StorageDead(_41);\n        goto -> bb29;\n    }\n    bb36: {\n        goto -> bb61;\n    }\n    bb37: {\n        StorageDead(_23);\n        switchInt(_10) -> [0: bb49, otherwise: bb38];\n    }\n    bb38: {\n        _54 = PtrMetadata(_11);\n        _55 = Ge(_54, 1_usize);\n        switchInt(move _55) -> [0: bb60, otherwise: bb39];\n    }\n    bb39: {\n        StorageLive(_56);\n        _56 = &(*_11)[0 of 1];\n        _57 = &(*_11)[1:];\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = _21;\n        _58 = num::<impl u32>::checked_mul(move _59, _2) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = (*_56);\n        _61 = move _62 as char;\n        StorageDead(_62);\n        _60 = char::methods::<impl char>::to_digit(move _61, _2) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_61);\n        _63 = discriminant(_60);\n        switchInt(move _63) -> [0: bb42, 1: bb43, otherwise: bb25];\n    }\n    bb42: {\n        StorageLive(_65);\n        StorageLive(_66);\n        _66 = num::error::IntErrorKind::InvalidDigit;\n        _65 = ParseIntError(move _66);\n        StorageDead(_66);\n        _0 = result::Result::Err(move _65);\n        StorageDead(_65);\n        StorageDead(_60);\n        goto -> bb63;\n    }\n    bb43: {\n        _64 = ((_60 as variant#1).0: u32);\n        StorageDead(_60);\n        _67 = discriminant(_58);\n        switchInt(move _67) -> [0: bb44, 1: bb45, otherwise: bb25];\n    }\n    bb44: {\n        StorageLive(_69);\n        StorageLive(_70);\n        _70 = num::error::IntErrorKind::PosOverflow;\n        _69 = ParseIntError(move _70);\n        StorageDead(_70);\n        _0 = result::Result::Err(move _69);\n        StorageDead(_69);\n        goto -> bb63;\n    }\n    bb45: {\n        _68 = ((_58 as variant#1).0: u32);\n        _21 = _68;\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = _21;\n        _71 = num::<impl u32>::checked_add(move _72, _64) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_72);\n        _73 = discriminant(_71);\n        switchInt(move _73) -> [0: bb47, 1: bb48, otherwise: bb25];\n    }\n    bb47: {\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = num::error::IntErrorKind::PosOverflow;\n        _75 = ParseIntError(move _76);\n        StorageDead(_76);\n        _0 = result::Result::Err(move _75);\n        StorageDead(_75);\n        StorageDead(_71);\n        goto -> bb63;\n    }\n    bb48: {\n        _74 = ((_71 as variant#1).0: u32);\n        _21 = _74;\n        StorageDead(_71);\n        _11 = _57;\n        StorageDead(_58);\n        StorageDead(_56);\n        goto -> bb38;\n    }\n    bb49: {\n        _77 = PtrMetadata(_11);\n        _78 = Ge(_77, 1_usize);\n        switchInt(move _78) -> [0: bb60, otherwise: bb50];\n    }\n    bb50: {\n        StorageLive(_79);\n        _79 = &(*_11)[0 of 1];\n        _80 = &(*_11)[1:];\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = _21;\n        _81 = num::<impl u32>::checked_mul(move _82, _2) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_82);\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = (*_79);\n        _84 = move _85 as char;\n        StorageDead(_85);\n        _83 = char::methods::<impl char>::to_digit(move _84, _2) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_84);\n        _86 = discriminant(_83);\n        switchInt(move _86) -> [0: bb53, 1: bb54, otherwise: bb25];\n    }\n    bb53: {\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = num::error::IntErrorKind::InvalidDigit;\n        _88 = ParseIntError(move _89);\n        StorageDead(_89);\n        _0 = result::Result::Err(move _88);\n        StorageDead(_88);\n        StorageDead(_83);\n        goto -> bb62;\n    }\n    bb54: {\n        _87 = ((_83 as variant#1).0: u32);\n        StorageDead(_83);\n        _90 = discriminant(_81);\n        switchInt(move _90) -> [0: bb55, 1: bb56, otherwise: bb25];\n    }\n    bb55: {\n        StorageLive(_92);\n        StorageLive(_93);\n        _93 = num::error::IntErrorKind::NegOverflow;\n        _92 = ParseIntError(move _93);\n        StorageDead(_93);\n        _0 = result::Result::Err(move _92);\n        StorageDead(_92);\n        goto -> bb62;\n    }\n    bb56: {\n        _91 = ((_81 as variant#1).0: u32);\n        _21 = _91;\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = _21;\n        _94 = num::<impl u32>::checked_sub(move _95, _87) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_95);\n        _96 = discriminant(_94);\n        switchInt(move _96) -> [0: bb58, 1: bb59, otherwise: bb25];\n    }\n    bb58: {\n        StorageLive(_98);\n        StorageLive(_99);\n        _99 = num::error::IntErrorKind::NegOverflow;\n        _98 = ParseIntError(move _99);\n        StorageDead(_99);\n        _0 = result::Result::Err(move _98);\n        StorageDead(_98);\n        StorageDead(_94);\n        goto -> bb62;\n    }\n    bb59: {\n        _97 = ((_94 as variant#1).0: u32);\n        _21 = _97;\n        StorageDead(_94);\n        _11 = _80;\n        StorageDead(_81);\n        StorageDead(_79);\n        goto -> bb49;\n    }\n    bb60: {\n        goto -> bb61;\n    }\n    bb61: {\n        StorageDead(_22);\n        StorageLive(_100);\n        _100 = _21;\n        _0 = result::Result::Ok(move _100);\n        StorageDead(_100);\n        StorageDead(_21);\n        StorageDead(_11);\n        goto -> bb68;\n    }\n    bb62: {\n        StorageDead(_81);\n        StorageDead(_79);\n        goto -> bb64;\n    }\n    bb63: {\n        StorageDead(_58);\n        StorageDead(_56);\n        goto -> bb64;\n    }\n    bb64: {\n        goto -> bb66;\n    }\n    bb65: {\n        goto -> bb66;\n    }\n    bb66: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_11);\n        goto -> bb67;\n    }\n    bb67: {\n        goto -> bb68;\n    }\n    bb68: {\n        return;\n    }\n}\n",
  "doc": " Parses an integer from an ASCII-byte slice with digits in a given base.\n\n The characters are expected to be an optional\n sign followed by only digits. Leading and trailing non-digit characters (including\n whitespace) represent an error. Underscores (which are accepted in Rust literals)\n also represent an error.\n\n Digits are a subset of these characters, depending on `radix`:\n * `0-9`\n * `a-z`\n * `A-Z`\n\n # Panics\n\n This function panics if `radix` is not in the range from 2 to 36.\n\n # Examples\n\n ```\n #![feature(int_from_ascii)]\n\n ```\n Trailing space returns error:\n ```\n # #![feature(int_from_ascii)]\n #\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}