{
  "name": "<wtf8::Wtf8 as fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "fmt::Write::write_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "wtf8::Wtf8::next_surrogate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "wtf8::Wtf8": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "str::converts::from_utf8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.\n\n This is an alias to [`str::from_utf8_unchecked`].\n\n See the safe version, [`from_utf8`], for more information.\n\n # Safety\n\n The bytes passed in must be valid UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = unsafe {\n     str::from_utf8_unchecked(&sparkle_heart)\n };\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "<wtf8::Wtf8 as fmt::Debug>::fmt::write_str_escaped": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    },
    "fmt::rt::Argument::<'_>::new_lower_hex": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::rt::Argument": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "fmt::Formatter::<'a>::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Glue for usage of the [`write!`] macro with implementors of this trait.\n\n This method should generally not be invoked manually, but rather through\n the [`write!`] macro itself.\n\n Writes some formatted information into this instance.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo(-1)), \"Foo -1\");\n assert_eq!(format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor",
        "fmt::Arguments": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ],
    "wtf8::Wtf8": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15531, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 136, kind: RigidTy(Uint(U16)) }])) }), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15531, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 136, kind: RigidTy(Uint(U16)) }])) }), Field(1, Ty { id: 136, kind: RigidTy(Uint(U16)) })])"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "fmt::rt::Argument": [
      "Plain"
    ],
    "fmt::Arguments": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<wtf8::Wtf8 as fmt::Debug>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/wtf8.rs:145:5: 174:6",
  "src": "fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fn write_str_escaped(f: &mut fmt::Formatter<'_>, s: &str) -> fmt::Result {\n            use crate::fmt::Write as _;\n            for c in s.chars().flat_map(|c| {\n                c.escape_debug_ext(EscapeDebugExtArgs {\n                    escape_grapheme_extended: true,\n                    escape_single_quote: false,\n                    escape_double_quote: true,\n                })\n            }) {\n                f.write_char(c)?\n            }\n            Ok(())\n        }\n\n        formatter.write_char('\"')?;\n        let mut pos = 0;\n        while let Some((surrogate_pos, surrogate)) = self.next_surrogate(pos) {\n            // SAFETY: next_surrogate provides an index for a range of valid UTF-8 bytes.\n            write_str_escaped(formatter, unsafe {\n                str::from_utf8_unchecked(&self.bytes[pos..surrogate_pos])\n            })?;\n            write!(formatter, \"\\\\u{{{:x}}}\", surrogate)?;\n            pos = surrogate_pos + 3;\n        }\n\n        // SAFETY: after next_surrogate returns None, the remainder is valid UTF-8.\n        write_str_escaped(formatter, unsafe { str::from_utf8_unchecked(&self.bytes[pos..]) })?;\n        formatter.write_char('\"')\n    }",
  "mir": "fn <wtf8::Wtf8 as fmt::Debug>::fmt(_1: &wtf8::Wtf8, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _4: result::Result<(), fmt::Error>;\n    let mut _5: isize;\n    let mut _6: usize;\n    let mut _7: option::Option<(usize, u16)>;\n    let mut _8: usize;\n    let mut _9: isize;\n    let  _10: usize;\n    let  _11: u16;\n    let mut _12: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _13: result::Result<(), fmt::Error>;\n    let  _14: &str;\n    let  _15: &[u8];\n    let mut _16: &[u8];\n    let mut _17: ops::range::Range<usize>;\n    let mut _18: usize;\n    let mut _19: isize;\n    let mut _20: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _21: result::Result<(), fmt::Error>;\n    let mut _22: fmt::Arguments<'_>;\n    let  _23: (&u16,);\n    let mut _24: &u16;\n    let  _25: [fmt::rt::Argument<'_>; 1];\n    let mut _26: fmt::rt::Argument<'_>;\n    let mut _27: &[u8; 8];\n    let  _28: &[fmt::rt::Argument<'_>; 1];\n    let mut _29: isize;\n    let mut _30: (usize, bool);\n    let mut _31: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _32: result::Result<(), fmt::Error>;\n    let  _33: &str;\n    let  _34: &[u8];\n    let mut _35: &[u8];\n    let mut _36: ops::range::RangeFrom<usize>;\n    let mut _37: usize;\n    let mut _38: isize;\n    let mut _39: &u16;\n    debug self => _1;\n    debug formatter => _2;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug pos => _6;\n    debug surrogate_pos => _10;\n    debug surrogate => _11;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug args => _23;\n    debug args => _25;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <fmt::Formatter<'_> as fmt::Write>::write_char(_2, '\"') -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_6);\n        _6 = 0_usize;\n        goto -> bb7;\n    }\n    bb5: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        goto -> bb36;\n    }\n    bb7: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = _6;\n        _7 = wtf8::Wtf8::next_surrogate(_1, move _8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [1: bb9, 0: bb25, otherwise: bb3];\n    }\n    bb9: {\n        _10 = (((_7 as variant#1).0: (usize, u16)).0: usize);\n        StorageLive(_11);\n        _11 = (((_7 as variant#1).0: (usize, u16)).1: u16);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_16);\n        _16 = &((*_1).0: [u8]);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _6;\n        _17 = Range(move _18, _10);\n        StorageDead(_18);\n        _15 = <[u8] as ops::index::Index<ops::range::Range<usize>>>::index(move _16, move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _14 = str::converts::from_utf8_unchecked(_15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _13 = <wtf8::Wtf8 as fmt::Debug>::fmt::write_str_escaped(_2, _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _12 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _13) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_13);\n        _19 = discriminant(_12);\n        switchInt(move _19) -> [0: bb14, 1: bb15, otherwise: bb3];\n    }\n    bb14: {\n        StorageDead(_12);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_11;\n        _23 = (move _24);\n        StorageDead(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _39 = (_23.0: &u16);\n        _26 = fmt::rt::Argument::<'_>::new_lower_hex::<u16>(_39) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_12);\n        goto -> bb34;\n    }\n    bb17: {\n        _25 = [move _26];\n        StorageDead(_26);\n        StorageLive(_27);\n        _27 = b\"\\x03\\\\u{\\xc0\\x01}\\x00\";\n        _28 = &_25;\n        _22 = fmt::Arguments::<'_>::new::<8, 1>(move _27, _28) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_27);\n        _21 = fmt::Formatter::<'_>::write_fmt(_2, move _22) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_22);\n        _20 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _21) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_21);\n        _29 = discriminant(_20);\n        switchInt(move _29) -> [0: bb21, 1: bb22, otherwise: bb3];\n    }\n    bb21: {\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_20);\n        _30 = CheckedAdd(_10, 3_usize);\n        assert(!move (_30.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _10, 3_usize) -> [success: bb24, unwind unreachable];\n    }\n    bb22: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_20);\n        goto -> bb34;\n    }\n    bb24: {\n        _6 = move (_30.0: usize);\n        StorageDead(_11);\n        StorageDead(_7);\n        goto -> bb7;\n    }\n    bb25: {\n        StorageDead(_7);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_35);\n        _35 = &((*_1).0: [u8]);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = _6;\n        _36 = RangeFrom(move _37);\n        StorageDead(_37);\n        _34 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(move _35, move _36) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_36);\n        StorageDead(_35);\n        _33 = str::converts::from_utf8_unchecked(_34) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _32 = <wtf8::Wtf8 as fmt::Debug>::fmt::write_str_escaped(_2, _33) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _31 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _32) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_32);\n        _38 = discriminant(_31);\n        switchInt(move _38) -> [0: bb30, 1: bb31, otherwise: bb3];\n    }\n    bb30: {\n        StorageDead(_31);\n        _0 = <fmt::Formatter<'_> as fmt::Write>::write_char(_2, '\"') -> [return: bb33, unwind unreachable];\n    }\n    bb31: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_31);\n        goto -> bb35;\n    }\n    bb33: {\n        StorageDead(_6);\n        goto -> bb36;\n    }\n    bb34: {\n        StorageDead(_11);\n        StorageDead(_7);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_6);\n        goto -> bb36;\n    }\n    bb36: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}