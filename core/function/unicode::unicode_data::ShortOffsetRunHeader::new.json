{
  "name": "unicode::unicode_data::ShortOffsetRunHeader::new",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "unicode::unicode_data::ShortOffsetRunHeader": [
      "Plain"
    ]
  },
  "path": 17748,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:65:5: 70:6",
  "src": "const fn new(start_index: usize, prefix_sum: u32) -> Self {\n        assert!(start_index < (1 << 11));\n        assert!(prefix_sum < (1 << 21));\n\n        Self((start_index as u32) << 21 | prefix_sum)\n    }",
  "mir": "fn unicode::unicode_data::ShortOffsetRunHeader::new(_1: usize, _2: u32) -> unicode::unicode_data::ShortOffsetRunHeader {\n    let mut _0: unicode::unicode_data::ShortOffsetRunHeader;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: u32;\n    let mut _6: bool;\n    let mut _7: !;\n    let mut _8: bool;\n    let mut _9: u32;\n    let mut _10: u32;\n    let mut _11: bool;\n    let mut _12: !;\n    let mut _13: u32;\n    let mut _14: u32;\n    let mut _15: u32;\n    let mut _16: u32;\n    let mut _17: bool;\n    debug start_index => _1;\n    debug prefix_sum => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = 11_i32 as u32;\n        _6 = Lt(move _5, 64_u32);\n        assert(move _6, \"attempt to shift left by `{}`, which would overflow\", 11_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = Shl(1_usize, 11_i32);\n        _3 = Lt(_1, move _4);\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _10 = 21_i32 as u32;\n        _11 = Lt(move _10, 32_u32);\n        assert(move _11, \"attempt to shift left by `{}`, which would overflow\", 21_i32) -> [success: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _7 = panicking::panic(\"assertion failed: start_index < (1 << 11)\") -> unwind unreachable;\n    }\n    bb4: {\n        _9 = Shl(1_u32, 21_i32);\n        _8 = Lt(_2, move _9);\n        switchInt(move _8) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _1 as u32;\n        _16 = 21_i32 as u32;\n        _17 = Lt(move _16, 32_u32);\n        assert(move _17, \"attempt to shift left by `{}`, which would overflow\", 21_i32) -> [success: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_9);\n        _12 = panicking::panic(\"assertion failed: prefix_sum < (1 << 21)\") -> unwind unreachable;\n    }\n    bb7: {\n        _14 = Shl(move _15, 21_i32);\n        StorageDead(_15);\n        _13 = BitOr(move _14, _2);\n        StorageDead(_14);\n        _0 = ShortOffsetRunHeader(move _13);\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}