{
  "name": "slice::<impl [T]>::partition_dedup_by",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "mem::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps the values at two mutable locations, without deinitializing either one.\n\n * If you want to swap with a default or dummy value, see [`take`].\n * If you want to swap with a passed value, returning the old value, see [`replace`].\n\n # Examples\n\n ```\n use std::mem;\n\n let mut x = 5;\n let mut y = 42;\n\n mem::swap(&mut x, &mut y);\n\n assert_eq!(42, x);\n assert_eq!(5, y);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::split_at_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_mut_checked`](slice::split_at_mut_checked).\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n let (left, right) = v.split_at_mut(2);\n assert_eq!(left, [1, 0]);\n assert_eq!(right, [3, 0, 5, 6]);\n left[1] = 2;\n right[1] = 4;\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1281,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3500:5: 3602:6",
  "src": "pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n        // Although we have a mutable reference to `self`, we cannot make\n        // *arbitrary* changes. The `same_bucket` calls could panic, so we\n        // must ensure that the slice is in a valid state at all times.\n        //\n        // The way that we handle this is by using swaps; we iterate\n        // over all the elements, swapping as we go so that at the end\n        // the elements we wish to keep are in the front, and those we\n        // wish to reject are at the back. We can then split the slice.\n        // This operation is still `O(n)`.\n        //\n        // Example: We start in this state, where `r` represents \"next\n        // read\" and `w` represents \"next_write\".\n        //\n        //           r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //           w\n        //\n        // Comparing self[r] against self[w-1], this is not a duplicate, so\n        // we swap self[r] and self[w] (no effect as r==w) and then increment both\n        // r and w, leaving us with:\n        //\n        //               r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //               w\n        //\n        // Comparing self[r] against self[w-1], this value is a duplicate,\n        // so we increment `r` but leave everything else unchanged:\n        //\n        //                   r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //               w\n        //\n        // Comparing self[r] against self[w-1], this is not a duplicate,\n        // so swap self[r] and self[w] and advance r and w:\n        //\n        //                       r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 2 | 1 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //                   w\n        //\n        // Not a duplicate, repeat:\n        //\n        //                           r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 2 | 3 | 1 | 3 |\n        //     +---+---+---+---+---+---+\n        //                       w\n        //\n        // Duplicate, advance r. End of slice. Split at w.\n\n        let len = self.len();\n        if len <= 1 {\n            return (self, &mut []);\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut next_read: usize = 1;\n        let mut next_write: usize = 1;\n\n        // SAFETY: the `while` condition guarantees `next_read` and `next_write`\n        // are less than `len`, thus are inside `self`. `prev_ptr_write` points to\n        // one element before `ptr_write`, but `next_write` starts at 1, so\n        // `prev_ptr_write` is never less than 0 and is inside the slice.\n        // This fulfils the requirements for dereferencing `ptr_read`, `prev_ptr_write`\n        // and `ptr_write`, and for using `ptr.add(next_read)`, `ptr.add(next_write - 1)`\n        // and `prev_ptr_write.offset(1)`.\n        //\n        // `next_write` is also incremented at most once per loop at most meaning\n        // no element is skipped when it may need to be swapped.\n        //\n        // `ptr_read` and `prev_ptr_write` never point to the same element. This\n        // is required for `&mut *ptr_read`, `&mut *prev_ptr_write` to be safe.\n        // The explanation is simply that `next_read >= next_write` is always true,\n        // thus `next_read > next_write - 1` is too.\n        unsafe {\n            // Avoid bounds checks by using raw pointers.\n            while next_read < len {\n                let ptr_read = ptr.add(next_read);\n                let prev_ptr_write = ptr.add(next_write - 1);\n                if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n                    if next_read != next_write {\n                        let ptr_write = prev_ptr_write.add(1);\n                        mem::swap(&mut *ptr_read, &mut *ptr_write);\n                    }\n                    next_write += 1;\n                }\n                next_read += 1;\n            }\n        }\n\n        self.split_at_mut(next_write)\n    }",
  "mir": "fn slice::<impl [T]>::partition_dedup_by(_1: &mut [T], _2: F) -> (&mut [T], &mut [T]) {\n    let mut _0: (&mut [T], &mut [T]);\n    let  _3: usize;\n    let mut _4: &[T];\n    let mut _5: bool;\n    let mut _6: &mut [T];\n    let mut _7: &mut [T; 0];\n    let  _8: *mut T;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: bool;\n    let mut _12: usize;\n    let  _13: *mut T;\n    let mut _14: usize;\n    let  _15: *mut T;\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: (usize, bool);\n    let mut _19: bool;\n    let mut _20: &mut F;\n    let mut _21: (&mut T, &mut T);\n    let mut _22: &mut T;\n    let mut _23: &mut T;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: usize;\n    let  _27: *mut T;\n    let  _28: ();\n    let mut _29: &mut T;\n    let mut _30: &mut T;\n    let mut _31: (usize, bool);\n    let mut _32: (usize, bool);\n    let mut _33: usize;\n    debug self => _1;\n    debug same_bucket => _2;\n    debug len => _3;\n    debug ptr => _8;\n    debug next_read => _9;\n    debug next_write => _10;\n    debug ptr_read => _13;\n    debug prev_ptr_write => _15;\n    debug ptr_write => _27;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = Le(_3, 1_usize);\n        switchInt(move _5) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_6);\n        _7 = slice::<impl [T]>::partition_dedup_by::<F>::promoted[0];\n        _6 = _7 as &mut [T];\n        _0 = (_1, move _6);\n        StorageDead(_6);\n        StorageDead(_5);\n        drop(_2) -> [return: bb22, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _8 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = 1_usize;\n        StorageLive(_10);\n        _10 = 1_usize;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _9;\n        _11 = Lt(move _12, _3);\n        switchInt(move _11) -> [0: bb20, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _9;\n        _13 = ptr::mut_ptr::<impl *mut T>::add(_8, move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _10;\n        _18 = CheckedSub(_17, 1_usize);\n        assert(!move (_18.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _17, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _16 = move (_18.0: usize);\n        StorageDead(_17);\n        _15 = ptr::mut_ptr::<impl *mut T>::add(_8, move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &mut _2;\n        StorageLive(_21);\n        _22 = &mut (*_13);\n        _23 = &mut (*_15);\n        _21 = (_22, _23);\n        _19 = <F as ops::function::FnMut<(&mut T, &mut T)>>::call_mut(move _20, move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _19) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb18;\n    }\n    bb11: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _9;\n        StorageLive(_26);\n        _26 = _10;\n        _24 = Ne(move _25, move _26);\n        switchInt(move _24) -> [0: bb15, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_27);\n        _27 = ptr::mut_ptr::<impl *mut T>::add(_15, 1_usize) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _29 = &mut (*_13);\n        _30 = &mut (*_27);\n        _28 = mem::swap::<T>(_29, _30) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        goto -> bb16;\n    }\n    bb15: {\n        StorageDead(_26);\n        StorageDead(_25);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_24);\n        _31 = CheckedAdd(_10, 1_usize);\n        assert(!move (_31.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _10, 1_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _10 = move (_31.0: usize);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_19);\n        _32 = CheckedAdd(_9, 1_usize);\n        assert(!move (_32.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _9 = move (_32.0: usize);\n        StorageDead(_13);\n        StorageDead(_11);\n        goto -> bb4;\n    }\n    bb20: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_33);\n        _33 = _10;\n        _0 = slice::<impl [T]>::split_at_mut(_1, move _33) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        StorageDead(_10);\n        StorageDead(_9);\n        drop(_2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": " Moves all but the first of consecutive elements to the end of the slice satisfying\n a given equality relation.\n\n Returns two slices. The first contains no consecutive repeated elements.\n The second contains all the duplicates in no specified order.\n\n The `same_bucket` function is passed references to two elements from the slice and\n must determine if the elements compare equal. The elements are passed in opposite order\n from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is moved\n at the end of the slice.\n\n If the slice is sorted, the first returned slice contains no duplicates.\n\n # Examples\n\n ```\n #![feature(slice_partition_dedup)]\n\n let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];\n\n let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n\n assert_eq!(dedup, [\"foo\", \"BAZ\", \"Bar\", \"baz\"]);\n assert_eq!(duplicates, [\"bar\", \"Foo\", \"BAZ\"]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}