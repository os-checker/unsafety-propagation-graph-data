{
  "name": "<str::pattern::CharSearcher<'a> as str::pattern::ReverseSearcher<'a>>::next_back",
  "safe": true,
  "callees": {
    "str::<impl str>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unchecked subslice of `str`.\n\n This is the unchecked alternative to indexing the `str`.\n\n # Safety\n\n Callers of this function are responsible that these preconditions are\n satisfied:\n\n * The starting index must not exceed the ending index;\n * Indexes must be within bounds of the original slice;\n * Indexes must lie on UTF-8 sequence boundaries.\n\n Failing that, the returned string slice may reference invalid memory or\n violate the invariants communicated by the `str` type.\n\n # Examples\n\n ```\n let v = \"üóª‚ààüåè\";\n unsafe {\n     assert_eq!(\"üóª\", v.get_unchecked(0..4));\n     assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n     assert_eq!(\"üåè\", v.get_unchecked(7..11));\n }\n ```\n",
      "adt": {}
    },
    "str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"yÃÜ\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {
        "str::iter::Chars": "Constructor"
      }
    },
    "iter::traits::exact_size::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "iter::traits::double_ended::DoubleEndedIterator::next_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes and returns an element from the end of the iterator.\n\n Returns `None` when there are no more elements.\n\n The [trait-level] docs contain more details.\n\n [trait-level]: DoubleEndedIterator\n\n # Examples\n\n Basic usage:\n\n ```\n let numbers = vec![1, 2, 3, 4, 5, 6];\n\n let mut iter = numbers.iter();\n\n assert_eq!(Some(&1), iter.next());\n assert_eq!(Some(&6), iter.next_back());\n assert_eq!(Some(&5), iter.next_back());\n assert_eq!(Some(&2), iter.next());\n assert_eq!(Some(&3), iter.next());\n assert_eq!(Some(&4), iter.next());\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next_back());\n ```\n\n # Remarks\n\n The elements yielded by `DoubleEndedIterator`'s methods may differ from\n the ones yielded by [`Iterator`]'s methods:\n\n ```\n let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];\n let uniq_by_fst_comp = || {\n     let mut seen = std::collections::HashSet::new();\n     vec.iter().copied().filter(move |x| seen.insert(x.0))\n };\n\n assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));\n assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));\n\n assert_eq!(\n     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(1, 'a'), (2, 'a')]\n );\n assert_eq!(\n     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(2, 'b'), (1, 'c')]\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "str::pattern::CharSearcher": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "MutRef"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "str::iter::Chars": [
      "Plain",
      "Unknown([Field(0, Ty { id: 554, kind: RigidTy(Adt(AdtDef(DefId { id: 24578, name: \"slice::iter::Iter\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 46, kind: RigidTy(Uint(U8)) })]))) })])",
      "MutRef"
    ],
    "slice::iter::Iter": [
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4458, kind: RigidTy(Char) })])"
    ],
    "str::pattern::SearchStep": [
      "Plain"
    ]
  },
  "path": 17029,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs:479:5: 497:6",
  "src": "fn next_back(&mut self) -> SearchStep {\n        let old_finger = self.finger_back;\n        // SAFETY: see the comment for next() above\n        let slice = unsafe { self.haystack.get_unchecked(self.finger..old_finger) };\n        let mut iter = slice.chars();\n        let old_len = iter.iter.len();\n        if let Some(ch) = iter.next_back() {\n            // subtract byte offset of current character\n            // without re-encoding as utf-8\n            self.finger_back -= old_len - iter.iter.len();\n            if ch == self.needle {\n                SearchStep::Match(self.finger_back, old_finger)\n            } else {\n                SearchStep::Reject(self.finger_back, old_finger)\n            }\n        } else {\n            SearchStep::Done\n        }\n    }",
  "mir": "fn <str::pattern::CharSearcher<'a> as str::pattern::ReverseSearcher<'a>>::next_back(_1: &mut str::pattern::CharSearcher<'_>) -> str::pattern::SearchStep {\n    let mut _0: str::pattern::SearchStep;\n    let  _2: usize;\n    let  _3: &str;\n    let mut _4: ops::range::Range<usize>;\n    let mut _5: usize;\n    let mut _6: str::iter::Chars<'_>;\n    let  _7: usize;\n    let mut _8: &slice::iter::Iter<'_, u8>;\n    let mut _9: option::Option<char>;\n    let mut _10: &mut str::iter::Chars<'_>;\n    let mut _11: isize;\n    let  _12: char;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: &slice::iter::Iter<'_, u8>;\n    let mut _16: (usize, bool);\n    let mut _17: (usize, bool);\n    let mut _18: bool;\n    let mut _19: char;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: &str;\n    debug self => _1;\n    debug old_finger => _2;\n    debug slice => _3;\n    debug iter => _6;\n    debug old_len => _7;\n    debug ch => _12;\n    bb0: {\n        _2 = ((*_1).2: usize);\n        _22 = ((*_1).0: &str);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).1: usize);\n        _4 = Range(move _5, _2);\n        StorageDead(_5);\n        _3 = str::<impl str>::get_unchecked::<ops::range::Range<usize>>(_22, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = str::<impl str>::chars(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_8);\n        _8 = &(_6.0: slice::iter::Iter<'_, u8>);\n        _7 = <slice::iter::Iter<'_, u8> as iter::traits::exact_size::ExactSizeIterator>::len(move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut _6;\n        _9 = <str::iter::Chars<'_> as iter::traits::double_ended::DoubleEndedIterator>::next_back(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [1: bb5, 0: bb12, otherwise: bb14];\n    }\n    bb5: {\n        _12 = ((_9 as variant#1).0: char);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(_6.0: slice::iter::Iter<'_, u8>);\n        _14 = <slice::iter::Iter<'_, u8> as iter::traits::exact_size::ExactSizeIterator>::len(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _16 = CheckedSub(_7, _14);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _7, move _14) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _13 = move (_16.0: usize);\n        StorageDead(_14);\n        _17 = CheckedSub(((*_1).2: usize), _13);\n        assert(!move (_17.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_1).2: usize), move _13) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        ((*_1).2: usize) = move (_17.0: usize);\n        StorageDead(_13);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = ((*_1).3: char);\n        _18 = Eq(_12, move _19);\n        switchInt(move _18) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = ((*_1).2: usize);\n        _0 = str::pattern::SearchStep::Match(move _20, _2);\n        StorageDead(_20);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_19);\n        StorageLive(_21);\n        _21 = ((*_1).2: usize);\n        _0 = str::pattern::SearchStep::Reject(move _21, _2);\n        StorageDead(_21);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_18);\n        StorageDead(_9);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_9);\n        _0 = str::pattern::SearchStep::Done;\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_6);\n        return;\n    }\n    bb14: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}