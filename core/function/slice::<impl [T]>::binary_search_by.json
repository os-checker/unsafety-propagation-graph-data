{
  "name": "slice::<impl [T]>::binary_search_by",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice, without doing bounds\n checking.\n\n For a safe alternative see [`get`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get(index).unwrap_unchecked()`.  It's UB\n to call `.get_unchecked(len)`, even if you immediately convert to a\n pointer.  And it's UB to call `.get_unchecked(..len + 1)`,\n `.get_unchecked(..=len)`, or similar.\n\n [`get`]: slice::get\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n\n unsafe {\n     assert_eq!(x.get_unchecked(1), &2);\n }\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "hint::select_unpredictable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns either `true_val` or `false_val` depending on the value of\n `condition`, with a hint to the compiler that `condition` is unlikely to be\n correctly predicted by a CPUâ€™s branch predictor.\n\n This method is functionally equivalent to\n ```ignore (this is just for illustrative purposes)\n fn select_unpredictable<T>(b: bool, true_val: T, false_val: T) -> T {\n     if b { true_val } else { false_val }\n }\n ```\n but might generate different assembly. In particular, on platforms with\n a conditional move or select instruction (like `cmov` on x86 or `csel`\n on ARM) the optimizer might use these instructions to avoid branches,\n which can benefit performance if the branch predictor is struggling\n with predicting `condition`, such as in an implementation of binary\n search.\n\n Note however that this lowering is not guaranteed (on any platform) and\n should not be relied upon when trying to write cryptographic constant-time\n code. Also be aware that this lowering might *decrease* performance if\n `condition` is well-predictable. It is advisable to perform benchmarks to\n tell if this function is useful.\n\n # Examples\n\n Distribute values evenly between two buckets:\n ```\n use std::hash::BuildHasher;\n use std::hint;\n\n fn append<H: BuildHasher>(hasher: &H, v: i32, bucket_one: &mut Vec<i32>, bucket_two: &mut Vec<i32>) {\n     let hash = hasher.hash_one(&v);\n     let bucket = hint::select_unpredictable(hash % 2 == 0, bucket_one, bucket_two);\n     bucket.push(v);\n }\n # let hasher = std::collections::hash_map::RandomState::new();\n # let mut bucket_one = Vec::new();\n # let mut bucket_two = Vec::new();\n # append(&hasher, 42, &mut bucket_one, &mut bucket_two);\n # assert_eq!(bucket_one.len() + bucket_two.len(), 1);\n ```\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ],
    "cmp::Ordering": [
      "Plain",
      "Ref"
    ]
  },
  "path": 1243,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:2967:5: 3019:6",
  "src": "pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> Ordering,\n    {\n        let mut size = self.len();\n        if size == 0 {\n            return Err(0);\n        }\n        let mut base = 0usize;\n\n        // This loop intentionally doesn't have an early exit if the comparison\n        // returns Equal. We want the number of loop iterations to depend *only*\n        // on the size of the input slice so that the CPU can reliably predict\n        // the loop count.\n        while size > 1 {\n            let half = size / 2;\n            let mid = base + half;\n\n            // SAFETY: the call is made safe by the following invariants:\n            // - `mid >= 0`: by definition\n            // - `mid < size`: `mid = size / 2 + size / 4 + size / 8 ...`\n            let cmp = f(unsafe { self.get_unchecked(mid) });\n\n            // Binary search interacts poorly with branch prediction, so force\n            // the compiler to use conditional moves if supported by the target\n            // architecture.\n            base = hint::select_unpredictable(cmp == Greater, base, mid);\n\n            // This is imprecise in the case where `size` is odd and the\n            // comparison returns Greater: the mid element still gets included\n            // by `size` even though it's known to be larger than the element\n            // being searched for.\n            //\n            // This is fine though: we gain more performance by keeping the\n            // loop iteration count invariant (and thus predictable) than we\n            // lose from considering one additional element.\n            size -= half;\n        }\n\n        // SAFETY: base is always in [0, size) because base <= mid.\n        let cmp = f(unsafe { self.get_unchecked(base) });\n        if cmp == Equal {\n            // SAFETY: same as the `get_unchecked` above.\n            unsafe { hint::assert_unchecked(base < self.len()) };\n            Ok(base)\n        } else {\n            let result = base + (cmp == Less) as usize;\n            // SAFETY: same as the `get_unchecked` above.\n            // Note that this is `<=`, unlike the assume in the `Ok` path.\n            unsafe { hint::assert_unchecked(result <= self.len()) };\n            Err(result)\n        }\n    }",
  "mir": "fn slice::<impl [T]>::binary_search_by(_1: &[T], _2: F) -> result::Result<usize, usize> {\n    let mut _0: result::Result<usize, usize>;\n    let mut _3: usize;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: bool;\n    let mut _7: usize;\n    let  _8: usize;\n    let mut _9: usize;\n    let mut _10: bool;\n    let  _11: usize;\n    let mut _12: usize;\n    let mut _13: (usize, bool);\n    let  _14: cmp::Ordering;\n    let mut _15: &mut F;\n    let mut _16: (&T,);\n    let  _17: &T;\n    let mut _18: usize;\n    let mut _19: bool;\n    let mut _20: &cmp::Ordering;\n    let mut _21: &cmp::Ordering;\n    let mut _22: usize;\n    let mut _23: (usize, bool);\n    let  _24: cmp::Ordering;\n    let mut _25: &mut F;\n    let mut _26: (&T,);\n    let  _27: &T;\n    let mut _28: usize;\n    let mut _29: bool;\n    let mut _30: &cmp::Ordering;\n    let mut _31: &cmp::Ordering;\n    let  _32: ();\n    let mut _33: bool;\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: usize;\n    let  _37: usize;\n    let mut _38: usize;\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: &cmp::Ordering;\n    let mut _42: &cmp::Ordering;\n    let mut _43: (usize, bool);\n    let  _44: ();\n    let mut _45: bool;\n    let mut _46: usize;\n    debug self => _1;\n    debug f => _2;\n    debug size => _3;\n    debug base => _5;\n    debug half => _8;\n    debug mid => _11;\n    debug cmp => _14;\n    debug cmp => _24;\n    debug result => _37;\n    bb0: {\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        StorageLive(_4);\n        _4 = _3;\n        switchInt(move _4) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = result::Result::Err(0_usize);\n        StorageDead(_3);\n        drop(_2) -> [return: bb23, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = 0_usize;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _3;\n        _6 = Gt(move _7, 1_usize);\n        switchInt(move _6) -> [0: bb12, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = _3;\n        _10 = Eq(2_usize, 0_usize);\n        assert(!move _10, \"attempt to divide `{}` by zero\", _9) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = Div(move _9, 2_usize);\n        StorageDead(_9);\n        StorageLive(_12);\n        _12 = _5;\n        _13 = CheckedAdd(_12, _8);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _12, _8) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = move (_13.0: usize);\n        StorageDead(_12);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _2;\n        StorageLive(_16);\n        _17 = slice::<impl [T]>::get_unchecked::<usize>(_1, _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _16 = (_17);\n        _14 = <F as ops::function::FnMut<(&T,)>>::call_mut(move _15, move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_14;\n        StorageLive(_21);\n        _21 = slice::<impl [T]>::binary_search_by::<'_, F>::promoted[0];\n        _19 = <cmp::Ordering as cmp::PartialEq>::eq(move _20, move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = _5;\n        _18 = hint::select_unpredictable::<usize>(move _19, move _22, _11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_22);\n        StorageDead(_19);\n        _5 = move _18;\n        StorageDead(_18);\n        _23 = CheckedSub(_3, _8);\n        assert(!move (_23.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _8) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _3 = move (_23.0: usize);\n        StorageDead(_14);\n        StorageDead(_6);\n        goto -> bb3;\n    }\n    bb12: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &mut _2;\n        StorageLive(_26);\n        StorageLive(_28);\n        _28 = _5;\n        _27 = slice::<impl [T]>::get_unchecked::<usize>(_1, move _28) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_28);\n        _26 = (_27);\n        _24 = <F as ops::function::FnMut<(&T,)>>::call_mut(move _25, move _26) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_24;\n        StorageLive(_31);\n        _31 = slice::<impl [T]>::binary_search_by::<'_, F>::promoted[2];\n        _29 = <cmp::Ordering as cmp::PartialEq>::eq(move _30, move _31) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _29) -> [0: bb18, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = _5;\n        StorageLive(_35);\n        _35 = PtrMetadata(_1);\n        _33 = Lt(move _34, move _35);\n        StorageDead(_35);\n        StorageDead(_34);\n        _32 = hint::assert_unchecked(move _33) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_33);\n        StorageLive(_36);\n        _36 = _5;\n        _0 = result::Result::Ok(move _36);\n        StorageDead(_36);\n        goto -> bb22;\n    }\n    bb18: {\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_38);\n        _38 = _5;\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &_24;\n        StorageLive(_42);\n        _42 = slice::<impl [T]>::binary_search_by::<'_, F>::promoted[1];\n        _40 = <cmp::Ordering as cmp::PartialEq>::eq(move _41, move _42) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_42);\n        StorageDead(_41);\n        _39 = move _40 as usize;\n        StorageDead(_40);\n        _43 = CheckedAdd(_38, _39);\n        assert(!move (_43.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _38, move _39) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _37 = move (_43.0: usize);\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = PtrMetadata(_1);\n        _45 = Le(_37, move _46);\n        StorageDead(_46);\n        _44 = hint::assert_unchecked(move _45) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_45);\n        _0 = result::Result::Err(_37);\n        goto -> bb22;\n    }\n    bb22: {\n        StorageDead(_29);\n        StorageDead(_24);\n        StorageDead(_5);\n        StorageDead(_3);\n        drop(_2) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        return;\n    }\n}\n",
  "doc": " Binary searches this slice with a comparator function.\n\n The comparator function should return an order code that indicates\n whether its argument is `Less`, `Equal` or `Greater` the desired\n target.\n If the slice is not sorted or if the comparator function does not\n implement an order consistent with the sort order of the underlying\n slice, the returned result is unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search`]: slice::binary_search\n [`binary_search_by_key`]: slice::binary_search_by_key\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n let seek = 13;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n let seek = 4;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n let seek = 100;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n let seek = 1;\n let r = s.binary_search_by(|probe| probe.cmp(&seek));\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}