{
  "name": "fmt::float::float_to_exponential_common_exact",
  "safe": true,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "num::flt2dec::to_exact_exp_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Formats given floating point number into the exponential form with\n exactly given number of significant digits. The result is stored to\n the supplied parts array while utilizing given byte buffer as a scratch.\n `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).\n\n `format_exact` should be the underlying digit-generation function.\n It should return the part of the buffer that it initialized.\n You probably would want `strategy::grisu::format_exact` for this.\n\n The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n so large that only the fixed number of digits will be ever written.\n (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n There should be at least 6 parts available, due to the worst case like\n `[+][1][.][2345][e][-][6]`.\n",
      "adt": {
        "num::fmt::Formatted": "Constructor"
      }
    },
    "num::flt2dec::strategy::grisu::format_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The exact and fixed mode implementation for Grisu with Dragon fallback.\n\n This should be used for most cases.\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad_formatted_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the formatted parts and applies the padding.\n\n Assumes that the caller already has rendered the parts with required precision,\n so that `self.precision` can be ignored.\n\n # Safety\n\n Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n",
      "adt": {
        "num::fmt::Formatted": "ImmutableAsArgument",
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "num::flt2dec::Sign": [
      "Plain"
    ],
    "num::fmt::Formatted": [
      "Plain",
      "Ref"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::fmt::float::float_to_exponential_common_exact"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/float.rs:102:1: 125:2",
  "src": "fn float_to_exponential_common_exact<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    precision: u16,\n    upper: bool,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    let mut buf: [MaybeUninit<u8>; 1024] = [MaybeUninit::uninit(); 1024]; // enough for f32 and f64\n    let mut parts: [MaybeUninit<numfmt::Part<'_>>; 6] = [MaybeUninit::uninit(); 6];\n    let formatted = flt2dec::to_exact_exp_str(\n        flt2dec::strategy::grisu::format_exact,\n        *num,\n        sign,\n        precision.into(),\n        upper,\n        &mut buf,\n        &mut parts,\n    );\n    // SAFETY: `to_exact_exp_str` and `format_exact` produce only ASCII characters.\n    unsafe { fmt.pad_formatted_parts(&formatted) }\n}",
  "mir": "fn fmt::float::float_to_exponential_common_exact(_1: &mut fmt::Formatter<'_>, _2: &T, _3: num::flt2dec::Sign, _4: u16, _5: bool) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _6: [mem::maybe_uninit::MaybeUninit<u8>; 1024];\n    let mut _7: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _8: [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>; 6];\n    let mut _9: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let  _10: num::fmt::Formatted<'_>;\n    let mut _11: T;\n    let mut _12: usize;\n    let mut _13: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _14: &mut [mem::maybe_uninit::MaybeUninit<u8>; 1024];\n    let mut _15: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _16: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>; 6];\n    let  _17: &num::fmt::Formatted<'_>;\n    debug fmt => _1;\n    debug num => _2;\n    debug sign => _3;\n    debug precision => _4;\n    debug upper => _5;\n    debug buf => _6;\n    debug parts => _8;\n    debug formatted => _10;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = mem::maybe_uninit::MaybeUninit::<u8>::uninit() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = [move _7; 1024];\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::uninit() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = [move _9; 6];\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = (*_2);\n        StorageLive(_12);\n        _12 = <u16 as convert::Into<usize>>::into(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_13);\n        _14 = &mut _6;\n        _13 = _14 as &mut [mem::maybe_uninit::MaybeUninit<u8>];\n        StorageLive(_15);\n        _16 = &mut _8;\n        _15 = _16 as &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n        _10 = num::flt2dec::to_exact_exp_str::<'_, T, for<'b, 'a> fn(&'b num::flt2dec::decoder::Decoded, &'a mut [mem::maybe_uninit::MaybeUninit<u8>], i16) -> (&'a [u8], i16) {num::flt2dec::strategy::grisu::format_exact}>(num::flt2dec::strategy::grisu::format_exact, move _11, _3, move _12, _5, move _13, move _15) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        _17 = &_10;\n        _0 = fmt::Formatter::<'_>::pad_formatted_parts(_1, _17) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}