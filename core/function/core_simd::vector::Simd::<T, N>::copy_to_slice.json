{
  "name": "core_simd::vector::Simd::<T, N>::copy_to_slice",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::store": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Store a vector to an array of `T`.\n\n See `load` as to why this function is necessary.\n\n # Safety\n Writing to `ptr` must be safe, as if by `<*mut [T; N]>::write`.\n",
      "adt": {
        "core_simd::vector::Simd": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ],
    "core_simd::vector::Simd": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_simd::vector::Simd::<T, N>::copy_to_slice"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:327:5: 335:6",
  "src": "pub fn copy_to_slice(self, slice: &mut [T]) {\n        assert!(\n            slice.len() >= Self::LEN,\n            \"slice length must be at least the number of elements\"\n        );\n        // SAFETY: We just checked that the slice contains\n        // at least `N` elements.\n        unsafe { self.store(slice.as_mut_ptr().cast()) }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::copy_to_slice(_1: core_simd::vector::Simd<T, N>, _2: &mut [T]) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &[T];\n    let  _6: !;\n    let mut _7: fmt::Arguments<'_>;\n    let mut _8: *mut [T; N];\n    let mut _9: *mut T;\n    debug self => _1;\n    debug slice => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_2);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _3 = Ge(move _4, core_simd::vector::Simd::<T, N>::LEN);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = slice::<impl [T]>::as_mut_ptr(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = fmt::Arguments::<'_>::from_str(\"slice length must be at least the number of elements\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = panicking::panic_fmt(move _7) -> unwind unreachable;\n    }\n    bb4: {\n        _8 = ptr::mut_ptr::<impl *mut T>::cast::<[T; N]>(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _0 = core_simd::vector::Simd::<T, N>::store(_1, move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Writes a SIMD vector to the first `N` elements of a slice.\n\n # Panics\n\n Panics if the slice's length is less than the vector's `Simd::N`.\n\n # Example\n\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::u32x4;\n let mut dest = vec![0; 6];\n let v = u32x4::from_array([1, 2, 3, 4]);\n v.copy_to_slice(&mut dest);\n assert_eq!(&dest, &[1, 2, 3, 4, 0, 0]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}