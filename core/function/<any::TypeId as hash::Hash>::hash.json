{
  "name": "<any::TypeId as hash::Hash>::hash",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::offset": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.offset(1) as char, '2');\n     assert_eq!(*ptr.offset(2) as char, '3');\n }\n ```\n",
      "adt": {}
    },
    "ptr::read_unaligned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.\n\n Unlike [`read`], `read_unaligned` works with unaligned pointers.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads.\n\n * `src` must point to a properly initialized value of type `T`.\n\n Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n value and the value at `*src` can [violate memory safety][read-ownership].\n\n [read-ownership]: read#ownership-of-the-returned-value\n [valid]: self#safety\n\n ## On `packed` structs\n\n Attempting to create a raw pointer to an `unaligned` struct field with\n an expression such as `&packed.unaligned as *const FieldType` creates an\n intermediate unaligned reference before converting that to a raw pointer.\n That this reference is temporary and immediately cast is inconsequential\n as the compiler always expects references to be properly aligned.\n As a result, using `&packed.unaligned as *const FieldType` causes immediate\n *undefined behavior* in your program.\n\n Instead you must use the `&raw const` syntax to create the pointer.\n You may use that constructed pointer together with this function.\n\n An example of what not to do and how this relates to `read_unaligned` is:\n\n ```\n #[repr(packed, C)]\n struct Packed {\n     _padding: u8,\n     unaligned: u32,\n }\n\n let packed = Packed {\n     _padding: 0x00,\n     unaligned: 0x01020304,\n };\n\n // Take the address of a 32-bit integer which is not aligned.\n // In contrast to `&packed.unaligned as *const _`, this has no undefined behavior.\n let unaligned = &raw const packed.unaligned;\n\n let v = unsafe { std::ptr::read_unaligned(unaligned) };\n assert_eq!(v, 0x01020304);\n ```\n\n Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however.\n\n # Examples\n\n Read a `usize` value from a byte buffer:\n\n ```\n fn read_usize(x: &[u8]) -> usize {\n     assert!(x.len() >= size_of::<usize>());\n\n     let ptr = x.as_ptr() as *const usize;\n\n     unsafe { ptr.read_unaligned() }\n }\n ```\n",
      "adt": {}
    },
    "hash::Hash::hash": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Feeds this value into the given [`Hasher`].\n\n # Examples\n\n ```\n use std::hash::{DefaultHasher, Hash, Hasher};\n\n let mut hasher = DefaultHasher::new();\n 7920.hash(&mut hasher);\n println!(\"Hash is {:x}!\", hasher.finish());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "any::TypeId": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": 4487,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/any.rs:807:5: 826:6",
  "src": "fn hash<H: hash::Hasher>(&self, state: &mut H) {\n        // We only hash the lower 64 bits of our (128 bit) internal numeric ID,\n        // because:\n        // - The hashing algorithm which backs `TypeId` is expected to be\n        //   unbiased and high quality, meaning further mixing would be somewhat\n        //   redundant compared to choosing (the lower) 64 bits arbitrarily.\n        // - `Hasher::finish` returns a u64 anyway, so the extra entropy we'd\n        //   get from hashing the full value would probably not be useful\n        //   (especially given the previous point about the lower 64 bits being\n        //   high quality on their own).\n        // - It is correct to do so -- only hashing a subset of `self` is still\n        //   compatible with an `Eq` implementation that considers the entire\n        //   value, as ours does.\n        let data =\n        // SAFETY: The `offset` stays in-bounds, it just moves the pointer to the 2nd half of the `TypeId`.\n        // Only the first ptr-sized chunk ever has provenance, so that second half is always\n        // fine to read at integer type.\n            unsafe { crate::ptr::read_unaligned(self.data.as_ptr().cast::<u64>().offset(1)) };\n        data.hash(state);\n    }",
  "mir": "fn <any::TypeId as hash::Hash>::hash(_1: &any::TypeId, _2: &mut H) -> () {\n    let mut _0: ();\n    let  _3: u64;\n    let mut _4: *const u64;\n    let mut _5: *const u64;\n    let mut _6: *const *const ();\n    let mut _7: &[*const ()];\n    let mut _8: &[*const (); 2];\n    let  _9: ();\n    let mut _10: &u64;\n    debug self => _1;\n    debug state => _2;\n    debug data => _3;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &((*_1).0: [*const (); 2]);\n        _7 = move _8 as &[*const ()];\n        StorageDead(_8);\n        _6 = slice::<impl [*const ()]>::as_ptr(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _5 = ptr::const_ptr::<impl *const *const ()>::cast::<u64>(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = ptr::const_ptr::<impl *const u64>::offset(move _5, 1_isize) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        _3 = ptr::read_unaligned::<u64>(move _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageLive(_10);\n        _10 = &_3;\n        _9 = <u64 as hash::Hash>::hash::<H>(move _10, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}