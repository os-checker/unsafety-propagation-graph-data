{
  "name": "array::iter::iter_inner::PolymorphicIter::<[mem::maybe_uninit::MaybeUninit<T>]>::advance_by",
  "safe": true,
  "callees": {
    "ops::index_range::IndexRange::take_prefix": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the first `n` items from this range, returning them as an `IndexRange`.\n If there are fewer than `n`, then the whole range is returned and\n `self` is left empty.\n\n This is designed to help implement `Iterator::advance_by`.\n",
      "adt": {
        "ops::index_range::IndexRange": "Constructor"
      }
    },
    "ops::index_range::IndexRange::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ops::index_range::IndexRange": "ImmutableAsArgument"
      }
    },
    "slice::<impl [T]>::get_unchecked_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to an element or subslice, without doing\n bounds checking.\n\n For a safe alternative see [`get_mut`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get_mut(index).unwrap_unchecked()`.  It's\n UB to call `.get_unchecked_mut(len)`, even if you immediately convert\n to a pointer.  And it's UB to call `.get_unchecked_mut(..len + 1)`,\n `.get_unchecked_mut(..=len)`, or similar.\n\n [`get_mut`]: slice::get_mut\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n\n unsafe {\n     let elem = x.get_unchecked_mut(1);\n     *elem = 13;\n }\n assert_eq!(x, &[1, 13, 4]);\n ```\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Drops the contained values in place.\n\n # Safety\n\n It is up to the caller to guarantee that every `MaybeUninit<T>` in the slice\n really is in an initialized state. Calling this when the content is not yet\n fully initialized causes undefined behavior.\n\n On top of that, all additional invariants of the type `T` must be\n satisfied, as the `Drop` implementation of `T` (or its members) may\n rely on this. For example, setting a `Vec<T>` to an invalid but\n non-null address makes it initialized (under the current implementation;\n this does not constitute a stable guarantee), because the only\n requirement the compiler knows about it is that the data pointer must be\n non-null. Dropping such a `Vec<T>` however will cause undefined\n behaviour.\n",
      "adt": {}
    },
    "num::nonzero::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::map_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the provided default result (if none),\n or applies a function to the contained value (if any).\n\n Arguments passed to `map_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`map_or_else`],\n which is lazily evaluated.\n\n [`map_or_else`]: Option::map_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.map_or(42, |v| v.len()), 3);\n\n let x: Option<&str> = None;\n assert_eq!(x.map_or(42, |v| v.len()), 42);\n ```\n",
      "adt": {}
    },
    "result::Result::Err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Contains the error value\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::index_range::IndexRange": [
      "MutRef",
      "Plain",
      "Ref"
    ],
    "array::iter::iter_inner::PolymorphicIter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "option::Option": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": 4508,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/iter/iter_inner.rs:185:5: 198:6",
  "src": "pub(super) fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        // This also moves the start, which marks them as conceptually \"dropped\",\n        // so if anything goes bad then our drop impl won't double-free them.\n        let range_to_drop = self.alive.take_prefix(n);\n        let remaining = n - range_to_drop.len();\n\n        // SAFETY: These elements are currently initialized, so it's fine to drop them.\n        unsafe {\n            let slice = self.data.get_unchecked_mut(range_to_drop);\n            slice.assume_init_drop();\n        }\n\n        NonZero::new(remaining).map_or(Ok(()), Err)\n    }",
  "mir": "fn array::iter::iter_inner::PolymorphicIter::<[mem::maybe_uninit::MaybeUninit<T>]>::advance_by(_1: &mut array::iter::iter_inner::PolymorphicIter<[mem::maybe_uninit::MaybeUninit<T>]>, _2: usize) -> result::Result<(), num::nonzero::NonZero<usize>> {\n    let mut _0: result::Result<(), num::nonzero::NonZero<usize>>;\n    let  _3: ops::index_range::IndexRange;\n    let mut _4: &mut ops::index_range::IndexRange;\n    let  _5: usize;\n    let mut _6: usize;\n    let mut _7: &ops::index_range::IndexRange;\n    let mut _8: (usize, bool);\n    let  _9: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _10: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let  _11: ();\n    let mut _12: option::Option<num::nonzero::NonZero<usize>>;\n    let mut _13: result::Result<(), num::nonzero::NonZero<usize>>;\n    debug self => _1;\n    debug n => _2;\n    debug range_to_drop => _3;\n    debug remaining => _5;\n    debug slice => _9;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: ops::index_range::IndexRange);\n        _3 = ops::index_range::IndexRange::take_prefix(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_3;\n        _6 = ops::index_range::IndexRange::len(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _8 = CheckedSub(_2, _6);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, move _6) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = move (_8.0: usize);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = &mut ((*_1).1: [mem::maybe_uninit::MaybeUninit<T>]);\n        _9 = slice::<impl [mem::maybe_uninit::MaybeUninit<T>]>::get_unchecked_mut::<ops::index_range::IndexRange>(move _10, _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _11 = <[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_drop(_9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_12);\n        _12 = num::nonzero::NonZero::<usize>::new(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_13);\n        _13 = result::Result::Ok(());\n        _0 = option::Option::<num::nonzero::NonZero<usize>>::map_or::<result::Result<(), num::nonzero::NonZero<usize>>, fn(num::nonzero::NonZero<usize>) -> result::Result<(), num::nonzero::NonZero<usize>> {result::Result::<(), num::nonzero::NonZero<usize>>::Err}>(move _12, move _13, result::Result::<(), num::nonzero::NonZero<usize>>::Err) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_12);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}