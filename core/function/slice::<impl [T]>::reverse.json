{
  "name": "slice::<impl [T]>::reverse",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the two unsafe mutable pointers spanning the slice.\n\n The returned range is half-open, which means that the end pointer\n points *one past* the last element of the slice. This way, an empty\n slice is represented by two equal pointers, and the difference between\n the two pointers represents the size of the slice.\n\n See [`as_mut_ptr`] for warnings on using these pointers. The end\n pointer requires extra caution, as it does not point to a valid element\n in the slice.\n\n This function is useful for interacting with foreign interfaces which\n use two pointers to refer to a range of elements in memory, as is\n common in C++.\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {
        "ops::range::Range": "Constructor"
      }
    },
    "slice::raw::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::sub": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Subtracts an unsigned offset from a pointer.\n\n This can only move the pointer backward (or not move it). If you need to move forward or\n backward depending on the value, then you might want [`offset`](#method.offset) instead\n which takes a signed offset.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The offset in bytes, `count * size_of::<T>()`, computed on mathematical integers (without\n   \"wrapping around\"), must fit in an `isize`.\n\n * If the computed offset is non-zero, then `self` must be [derived from][crate::ptr#provenance] a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n Consider using [`wrapping_sub`] instead if these constraints are\n difficult to satisfy. The only advantage of this method is that it\n enables more aggressive compiler optimizations.\n\n [`wrapping_sub`]: #method.wrapping_sub\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n let s: &str = \"123\";\n\n unsafe {\n     let end: *const u8 = s.as_ptr().add(3);\n     assert_eq!('3', *end.sub(1) as char);\n     assert_eq!('2', *end.sub(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::reverse::revswap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1181, kind: RigidTy(RawPtr(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 1181, kind: RigidTy(RawPtr(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Mut)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::reverse"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:977:5: 1018:6",
  "src": "pub const fn reverse(&mut self) {\n        let half_len = self.len() / 2;\n        let Range { start, end } = self.as_mut_ptr_range();\n\n        // These slices will skip the middle item for an odd length,\n        // since that one doesn't need to move.\n        let (front_half, back_half) =\n            // SAFETY: Both are subparts of the original slice, so the memory\n            // range is valid, and they don't overlap because they're each only\n            // half (or less) of the original slice.\n            unsafe {\n                (\n                    slice::from_raw_parts_mut(start, half_len),\n                    slice::from_raw_parts_mut(end.sub(half_len), half_len),\n                )\n            };\n\n        // Introducing a function boundary here means that the two halves\n        // get `noalias` markers, allowing better optimization as LLVM\n        // knows that they're disjoint, unlike in the original slice.\n        revswap(front_half, back_half, half_len);\n\n        #[inline]\n        const fn revswap<T>(a: &mut [T], b: &mut [T], n: usize) {\n            debug_assert!(a.len() == n);\n            debug_assert!(b.len() == n);\n\n            // Because this function is first compiled in isolation,\n            // this check tells LLVM that the indexing below is\n            // in-bounds. Then after inlining -- once the actual\n            // lengths of the slices are known -- it's removed.\n            // FIXME(const_trait_impl) replace with let (a, b) = (&mut a[..n], &mut b[..n]);\n            let (a, _) = a.split_at_mut(n);\n            let (b, _) = b.split_at_mut(n);\n\n            let mut i = 0;\n            while i < n {\n                mem::swap(&mut a[i], &mut b[n - 1 - i]);\n                i += 1;\n            }\n        }\n    }",
  "mir": "fn slice::<impl [T]>::reverse(_1: &mut [T]) -> () {\n    let mut _0: ();\n    let  _2: usize;\n    let mut _3: usize;\n    let mut _4: &[T];\n    let mut _5: bool;\n    let  _6: *mut T;\n    let  _7: *mut T;\n    let mut _8: ops::range::Range<*mut T>;\n    let  _9: &mut [T];\n    let  _10: &mut [T];\n    let mut _11: (&mut [T], &mut [T]);\n    let mut _12: &mut [T];\n    let mut _13: &mut [T];\n    let mut _14: *mut T;\n    let  _15: ();\n    debug self => _1;\n    debug half_len => _2;\n    debug start => _6;\n    debug end => _7;\n    debug front_half => _9;\n    debug back_half => _10;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        _5 = Eq(2_usize, 0_usize);\n        assert(!move _5, \"attempt to divide `{}` by zero\", _3) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = Div(move _3, 2_usize);\n        StorageDead(_3);\n        StorageLive(_8);\n        _8 = slice::<impl [T]>::as_mut_ptr_range(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = (_8.0: *mut T);\n        _7 = (_8.1: *mut T);\n        StorageDead(_8);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = slice::raw::from_raw_parts_mut::<'_, T>(_6, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ptr::mut_ptr::<impl *mut T>::sub(_7, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _13 = slice::raw::from_raw_parts_mut::<'_, T>(move _14, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        _11 = (move _12, move _13);\n        StorageDead(_13);\n        StorageDead(_12);\n        _9 = move (_11.0: &mut [T]);\n        _10 = move (_11.1: &mut [T]);\n        StorageDead(_11);\n        _15 = slice::<impl [T]>::reverse::revswap::<T>(_9, _10, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Reverses the order of elements in the slice, in place.\n\n # Examples\n\n ```\n let mut v = [1, 2, 3];\n v.reverse();\n assert!(v == [3, 2, 1]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}