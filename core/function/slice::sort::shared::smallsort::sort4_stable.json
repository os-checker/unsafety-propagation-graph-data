{
  "name": "slice::sort::shared::smallsort::sort4_stable",
  "safe": false,
  "callees": {
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "hint::select_unpredictable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns either `true_val` or `false_val` depending on the value of\n `condition`, with a hint to the compiler that `condition` is unlikely to be\n correctly predicted by a CPUâ€™s branch predictor.\n\n This method is functionally equivalent to\n ```ignore (this is just for illustrative purposes)\n fn select_unpredictable<T>(b: bool, true_val: T, false_val: T) -> T {\n     if b { true_val } else { false_val }\n }\n ```\n but might generate different assembly. In particular, on platforms with\n a conditional move or select instruction (like `cmov` on x86 or `csel`\n on ARM) the optimizer might use these instructions to avoid branches,\n which can benefit performance if the branch predictor is struggling\n with predicting `condition`, such as in an implementation of binary\n search.\n\n Note however that this lowering is not guaranteed (on any platform) and\n should not be relied upon when trying to write cryptographic constant-time\n code. Also be aware that this lowering might *decrease* performance if\n `condition` is well-predictable. It is advisable to perform benchmarks to\n tell if this function is useful.\n\n # Examples\n\n Distribute values evenly between two buckets:\n ```\n use std::hash::BuildHasher;\n use std::hint;\n\n fn append<H: BuildHasher>(hasher: &H, v: i32, bucket_one: &mut Vec<i32>, bucket_two: &mut Vec<i32>) {\n     let hash = hasher.hash_one(&v);\n     let bucket = hint::select_unpredictable(hash % 2 == 0, bucket_one, bucket_two);\n     bucket.push(v);\n }\n # let hasher = std::collections::hash_map::RandomState::new();\n # let mut bucket_one = Vec::new();\n # let mut bucket_two = Vec::new();\n # append(&hasher, 42, &mut bucket_one, &mut bucket_two);\n # assert_eq!(bucket_one.len() + bucket_two.len(), 1);\n ```\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::sort::shared::smallsort::sort4_stable"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:612:1: 658:2",
  "src": "pub unsafe fn sort4_stable<T, F: FnMut(&T, &T) -> bool>(\n    v_base: *const T,\n    dst: *mut T,\n    is_less: &mut F,\n) {\n    // By limiting select to picking pointers, we are guaranteed good cmov code-gen\n    // regardless of type T's size. Further this only does 5 instead of 6\n    // comparisons compared to a stable transposition 4 element sorting-network,\n    // and always copies each element exactly once.\n\n    // SAFETY: all pointers have offset at most 3 from v_base and dst, and are\n    // thus in-bounds by the precondition.\n    unsafe {\n        // Stably create two pairs a <= b and c <= d.\n        let c1 = is_less(&*v_base.add(1), &*v_base);\n        let c2 = is_less(&*v_base.add(3), &*v_base.add(2));\n        let a = v_base.add(c1 as usize);\n        let b = v_base.add(!c1 as usize);\n        let c = v_base.add(2 + c2 as usize);\n        let d = v_base.add(2 + (!c2 as usize));\n\n        // Compare (a, c) and (b, d) to identify max/min. We're left with two\n        // unknown elements, but because we are a stable sort we must know which\n        // one is leftmost and which one is rightmost.\n        // c3, c4 | min max unknown_left unknown_right\n        //  0,  0 |  a   d    b         c\n        //  0,  1 |  a   b    c         d\n        //  1,  0 |  c   d    a         b\n        //  1,  1 |  c   b    a         d\n        let c3 = is_less(&*c, &*a);\n        let c4 = is_less(&*d, &*b);\n        let min = hint::select_unpredictable(c3, c, a);\n        let max = hint::select_unpredictable(c4, b, d);\n        let unknown_left = hint::select_unpredictable(c3, a, hint::select_unpredictable(c4, c, b));\n        let unknown_right = hint::select_unpredictable(c4, d, hint::select_unpredictable(c3, b, c));\n\n        // Sort the last two unknown elements.\n        let c5 = is_less(&*unknown_right, &*unknown_left);\n        let lo = hint::select_unpredictable(c5, unknown_right, unknown_left);\n        let hi = hint::select_unpredictable(c5, unknown_left, unknown_right);\n\n        ptr::copy_nonoverlapping(min, dst, 1);\n        ptr::copy_nonoverlapping(lo, dst.add(1), 1);\n        ptr::copy_nonoverlapping(hi, dst.add(2), 1);\n        ptr::copy_nonoverlapping(max, dst.add(3), 1);\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::sort4_stable(_1: *const T, _2: *mut T, _3: &mut F) -> () {\n    let mut _0: ();\n    let  _4: bool;\n    let mut _5: (&T, &T);\n    let  _6: &T;\n    let  _7: *const T;\n    let  _8: &T;\n    let  _9: bool;\n    let mut _10: (&T, &T);\n    let  _11: &T;\n    let  _12: *const T;\n    let  _13: &T;\n    let  _14: *const T;\n    let  _15: *const T;\n    let mut _16: usize;\n    let  _17: *const T;\n    let mut _18: usize;\n    let mut _19: bool;\n    let  _20: *const T;\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: (usize, bool);\n    let  _24: *const T;\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: bool;\n    let mut _28: (usize, bool);\n    let  _29: bool;\n    let mut _30: (&T, &T);\n    let  _31: &T;\n    let  _32: &T;\n    let  _33: bool;\n    let mut _34: (&T, &T);\n    let  _35: &T;\n    let  _36: &T;\n    let  _37: *const T;\n    let  _38: *const T;\n    let  _39: *const T;\n    let mut _40: *const T;\n    let  _41: *const T;\n    let mut _42: *const T;\n    let  _43: bool;\n    let mut _44: (&T, &T);\n    let  _45: &T;\n    let  _46: &T;\n    let  _47: *const T;\n    let  _48: *const T;\n    let  _49: ();\n    let  _50: ();\n    let mut _51: *mut T;\n    let  _52: ();\n    let mut _53: *mut T;\n    let  _54: ();\n    let mut _55: *mut T;\n    debug v_base => _1;\n    debug dst => _2;\n    debug is_less => _3;\n    debug c1 => _4;\n    debug c2 => _9;\n    debug a => _15;\n    debug b => _17;\n    debug c => _20;\n    debug d => _24;\n    debug c3 => _29;\n    debug c4 => _33;\n    debug min => _37;\n    debug max => _38;\n    debug unknown_left => _39;\n    debug unknown_right => _41;\n    debug c5 => _43;\n    debug lo => _47;\n    debug hi => _48;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = ptr::const_ptr::<impl *const T>::add(_1, 1_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = &(*_7);\n        _8 = &(*_1);\n        _5 = (_6, _8);\n        _4 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_3, move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_12);\n        _12 = ptr::const_ptr::<impl *const T>::add(_1, 3_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _11 = &(*_12);\n        StorageLive(_14);\n        _14 = ptr::const_ptr::<impl *const T>::add(_1, 2_usize) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _13 = &(*_14);\n        _10 = (_11, _13);\n        _9 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_3, move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageLive(_16);\n        _16 = _4 as usize;\n        _15 = ptr::const_ptr::<impl *const T>::add(_1, move _16) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = Not(_4);\n        _18 = move _19 as usize;\n        StorageDead(_19);\n        _17 = ptr::const_ptr::<impl *const T>::add(_1, move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _9 as usize;\n        _23 = CheckedAdd(2_usize, _22);\n        assert(!move (_23.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 2_usize, move _22) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _21 = move (_23.0: usize);\n        StorageDead(_22);\n        _20 = ptr::const_ptr::<impl *const T>::add(_1, move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = Not(_9);\n        _26 = move _27 as usize;\n        StorageDead(_27);\n        _28 = CheckedAdd(2_usize, _26);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 2_usize, move _26) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _25 = move (_28.0: usize);\n        StorageDead(_26);\n        _24 = ptr::const_ptr::<impl *const T>::add(_1, move _25) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_25);\n        StorageLive(_30);\n        _31 = &(*_20);\n        _32 = &(*_15);\n        _30 = (_31, _32);\n        _29 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_3, move _30) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_30);\n        StorageLive(_34);\n        _35 = &(*_24);\n        _36 = &(*_17);\n        _34 = (_35, _36);\n        _33 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_3, move _34) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_34);\n        _37 = hint::select_unpredictable::<*const T>(_29, _20, _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _38 = hint::select_unpredictable::<*const T>(_33, _17, _24) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_40);\n        _40 = hint::select_unpredictable::<*const T>(_33, _20, _17) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _39 = hint::select_unpredictable::<*const T>(_29, _15, move _40) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_40);\n        StorageLive(_42);\n        _42 = hint::select_unpredictable::<*const T>(_29, _17, _20) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _41 = hint::select_unpredictable::<*const T>(_33, _24, move _42) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_42);\n        StorageLive(_44);\n        _45 = &(*_41);\n        _46 = &(*_39);\n        _44 = (_45, _46);\n        _43 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_3, move _44) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_44);\n        _47 = hint::select_unpredictable::<*const T>(_43, _41, _39) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _48 = hint::select_unpredictable::<*const T>(_43, _39, _41) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _49 = ptr::copy_nonoverlapping::<T>(_37, _2, 1_usize) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_51);\n        _51 = ptr::mut_ptr::<impl *mut T>::add(_2, 1_usize) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _50 = ptr::copy_nonoverlapping::<T>(_47, move _51, 1_usize) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_51);\n        StorageLive(_53);\n        _53 = ptr::mut_ptr::<impl *mut T>::add(_2, 2_usize) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _52 = ptr::copy_nonoverlapping::<T>(_48, move _53, 1_usize) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_53);\n        StorageLive(_55);\n        _55 = ptr::mut_ptr::<impl *mut T>::add(_2, 3_usize) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _54 = ptr::copy_nonoverlapping::<T>(_38, move _55, 1_usize) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_55);\n        return;\n    }\n}\n",
  "doc": " SAFETY: The caller MUST guarantee that `v_base` is valid for 4 reads and\n `dst` is valid for 4 writes. The result will be stored in `dst[0..4]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}