{
  "name": "core_arch::x86::avx512dq::_mm_reduce_sd",
  "safe": false,
  "callees": {
    "core_arch::x86::sse2::_mm_undefined_pd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns vector of type __m128d with indeterminate elements.with indetermination elements.\n Despite using the word \"undefined\" (following Intel's naming scheme), this non-deterministically\n picks some valid value and is not equivalent to [`mem::MaybeUninit`].\n In practice, this is typically equivalent to [`mem::zeroed`].\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_undefined_pd)\n",
      "adt": {
        "core_arch::x86::__m128d": "Constructor"
      }
    },
    "core_arch::x86::avx512dq::_mm_mask_reduce_sd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extract the reduced argument of the lower double-precision (64-bit) floating-point element in b\n by the number of bits specified by imm8, store the result in the lower element of dst using writemask\n k (the element is copied from src when mask bit 0 is not set), and copy the upper element from a\n to the upper element of dst.\n Rounding is done according to the imm8 parameter, which can be one of:\n\n * [`_MM_FROUND_TO_NEAREST_INT`] : round to nearest\n * [`_MM_FROUND_TO_NEG_INF`] : round down\n * [`_MM_FROUND_TO_POS_INF`] : round up\n * [`_MM_FROUND_TO_ZERO`] : truncate\n * [`_MM_FROUND_CUR_DIRECTION`] : use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`]\n\n [Intel's Documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mask_reduce_sd&ig_expand=5454)\n",
      "adt": {
        "core_arch::x86::__m128d": "Constructor"
      }
    }
  },
  "adts": {
    "core_arch::x86::__m128d": [
      "Plain"
    ]
  },
  "path": 7560,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512dq.rs:6404:1: 6407:2",
  "src": "pub fn _mm_reduce_sd<const IMM8: i32>(a: __m128d, b: __m128d) -> __m128d {\n    static_assert_uimm_bits!(IMM8, 8);\n    _mm_mask_reduce_sd::<IMM8>(_mm_undefined_pd(), 0xff, a, b)\n}",
  "mir": "fn core_arch::x86::avx512dq::_mm_reduce_sd(_1: core_arch::x86::__m128d, _2: core_arch::x86::__m128d) -> core_arch::x86::__m128d {\n    let mut _0: core_arch::x86::__m128d;\n    let mut _3: core_arch::x86::__m128d;\n    debug a => _1;\n    debug b => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = core_arch::x86::sse2::_mm_undefined_pd() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = core_arch::x86::avx512dq::_mm_mask_reduce_sd::<IMM8>(move _3, u8::MAX, _1, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Extract the reduced argument of the lower double-precision (64-bit) floating-point element in b\n by the number of bits specified by imm8, store the result in the lower element of dst using, and\n copy the upper element from a.\n to the upper element of dst.\n Rounding is done according to the imm8 parameter, which can be one of:\n\n * [`_MM_FROUND_TO_NEAREST_INT`] : round to nearest\n * [`_MM_FROUND_TO_NEG_INF`] : round down\n * [`_MM_FROUND_TO_POS_INF`] : round up\n * [`_MM_FROUND_TO_ZERO`] : truncate\n * [`_MM_FROUND_CUR_DIRECTION`] : use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`]\n\n [Intel's Documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_reduce_sd&ig_expand=5456)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}