{
  "name": "core_simd::vector::Simd::<T, N>::load_select",
  "safe": true,
  "callees": {
    "core_simd::vector::mask_up_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_simd::masks::Mask": "Constructor"
      }
    },
    "ops::bit::BitAndAssign::bitand_assign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `&=` operation.\n\n # Examples\n\n ```\n let mut x = true;\n x &= false;\n assert_eq!(x, false);\n\n let mut x = true;\n x &= true;\n assert_eq!(x, true);\n\n let mut x: u8 = 5;\n x &= 1;\n assert_eq!(x, 1);\n\n let mut x: u8 = 5;\n x &= 2;\n assert_eq!(x, 0);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::load_select_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads contiguous elements starting at `ptr`. Each element is read from memory if its\n corresponding element in `enable` is `true`.\n\n When the element is disabled, that memory location is not accessed and the corresponding\n value from `or` is passed through.\n\n # Safety\n Enabled `ptr` elements must be safe to read as if by `std::ptr::read`.\n",
      "adt": {
        "core_simd::vector::Simd": "Constructor"
      }
    }
  },
  "adts": {
    "core_simd::masks::Mask": [
      "MutRef",
      "Plain"
    ],
    "core_simd::vector::Simd": [
      "Plain"
    ]
  },
  "path": 12679,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:430:5: 439:6",
  "src": "pub fn load_select(\n        slice: &[T],\n        mut enable: Mask<<T as SimdElement>::Mask, N>,\n        or: Self,\n    ) -> Self {\n        enable &= mask_up_to(slice.len());\n        // SAFETY: We performed the bounds check by updating the mask. &[T] is properly aligned to\n        // the element.\n        unsafe { Self::load_select_ptr(slice.as_ptr(), enable, or) }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::load_select(_1: &[T], _2: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>, _3: core_simd::vector::Simd<T, N>) -> core_simd::vector::Simd<T, N> {\n    let mut _0: core_simd::vector::Simd<T, N>;\n    let  _4: ();\n    let mut _5: &mut core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>;\n    let mut _6: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>;\n    let mut _7: usize;\n    let mut _8: *const T;\n    let mut _9: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>;\n    debug slice => _1;\n    debug enable => _2;\n    debug or => _3;\n    bb0: {\n        StorageLive(_5);\n        _5 = &mut _2;\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = PtrMetadata(_1);\n        _6 = core_simd::vector::mask_up_to::<<T as core_simd::vector::SimdElement>::Mask, N>(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _4 = <core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N> as ops::bit::BitAndAssign>::bitand_assign(move _5, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = slice::<impl [T]>::as_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = _2;\n        _0 = core_simd::vector::Simd::<T, N>::load_select_ptr(move _8, move _9, _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Reads contiguous elements from `slice`. Each element is read from memory if its\n corresponding element in `enable` is `true`.\n\n When the element is disabled or out of bounds for the slice, that memory location\n is not accessed and the corresponding value from `or` is passed through.\n\n # Examples\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::{Simd, Mask};\n let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n let enable = Mask::from_array([true, true, false, true]);\n let or = Simd::from_array([-5, -4, -3, -2]);\n\n let result = Simd::load_select(&vec, enable, or);\n assert_eq!(result, Simd::from_array([10, 11, -3, 13]));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}