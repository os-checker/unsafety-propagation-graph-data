{
  "name": "<mem::maybe_uninit::MaybeUninit<T> as fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "any::type_name": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the name of a type as a string slice.\n\n # Note\n\n This is intended for diagnostic use. The exact contents and format of the\n string returned are not specified, other than being a best-effort\n description of the type. For example, amongst the strings\n that `type_name::<Option<String>>()` might return are `\"Option<String>\"` and\n `\"std::option::Option<std::string::String>\"`.\n\n The returned string must not be considered to be a unique identifier of a\n type as multiple types may map to the same type name. Similarly, there is no\n guarantee that all parts of a type will appear in the returned string. In\n addition, the output may change between versions of the compiler. For\n example, lifetime specifiers were omitted in some earlier versions.\n\n The current implementation uses the same infrastructure as compiler\n diagnostics and debuginfo, but this is not guaranteed.\n\n # Examples\n\n ```rust\n assert_eq!(\n     std::any::type_name::<Option<String>>(),\n     \"core::option::Option<alloc::string::String>\",\n );\n ```\n",
      "adt": {}
    },
    "str::<impl str>::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the byte index of the first character of this string slice that\n matches the pattern.\n\n Returns [`None`] if the pattern doesn't match.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Examples\n\n Simple patterns:\n\n ```\n let s = \"Löwe 老虎 Léopard Gepardi\";\n\n assert_eq!(s.find('L'), Some(0));\n assert_eq!(s.find('é'), Some(14));\n assert_eq!(s.find(\"pard\"), Some(17));\n ```\n\n More complex patterns using point-free style and closures:\n\n ```\n let s = \"Löwe 老虎 Léopard\";\n\n assert_eq!(s.find(char::is_whitespace), Some(5));\n assert_eq!(s.find(char::is_lowercase), Some(1));\n assert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\n assert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n ```\n\n Not finding the pattern:\n\n ```\n let s = \"Löwe 老虎 Léopard\";\n let x: &[_] = &['1', '2'];\n\n assert_eq!(s.find(x), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a string slice and emits it to the internal buffer after applying\n the relevant formatting flags specified.\n\n The flags recognized for generic strings are:\n\n * width - the minimum width of what to emit\n * fill/align - what to emit and where to emit it if the string\n                provided needs to be padded\n * precision - the maximum length to emit, the string is truncated if it\n               is longer than this length\n\n Notably this function ignores the `flag` parameters.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.pad(\"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo:<4}\"), \"Foo \");\n assert_eq!(format!(\"{Foo:0>4}\"), \"0Foo\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Ref"
    ]
  },
  "path": 14423,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/maybe_uninit.rs:367:5: 372:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // NB: there is no `.pad_fmt` so we can't use a simpler `format_args!(\"MaybeUninit<{..}>\").\n        let full_name = type_name::<Self>();\n        let prefix_len = full_name.find(\"MaybeUninit\").unwrap();\n        f.pad(&full_name[prefix_len..])\n    }",
  "mir": "fn <mem::maybe_uninit::MaybeUninit<T> as fmt::Debug>::fmt(_1: &mem::maybe_uninit::MaybeUninit<T>, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let  _3: &str;\n    let  _4: usize;\n    let mut _5: option::Option<usize>;\n    let  _6: &str;\n    let mut _7: ops::range::RangeFrom<usize>;\n    debug self => _1;\n    debug f => _2;\n    debug full_name => _3;\n    debug prefix_len => _4;\n    bb0: {\n        _3 = any::type_name::<mem::maybe_uninit::MaybeUninit<T>>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = str::<impl str>::find::<&str>(_3, \"MaybeUninit\") -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = option::Option::<usize>::unwrap(move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_7);\n        _7 = RangeFrom(_4);\n        _6 = <str as ops::index::Index<ops::range::RangeFrom<usize>>>::index(_3, move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _0 = fmt::Formatter::<'_>::pad(_2, _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}