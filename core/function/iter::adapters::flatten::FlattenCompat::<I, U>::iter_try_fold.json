{
  "name": "iter::adapters::flatten::FlattenCompat::<I, U>::iter_try_fold",
  "safe": true,
  "callees": {
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "iter::adapters::flatten::FlattenCompat::<I, U>::iter_try_fold::flatten": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "option::Option": "MutableAsArgument"
      }
    },
    "iter::traits::iterator::Iterator::try_fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that applies a function as long as it returns\n successfully, producing a single, final value.\n\n `try_fold()` takes two arguments: an initial value, and a closure with\n two arguments: an 'accumulator', and an element. The closure either\n returns successfully, with the value that the accumulator should have\n for the next iteration, or it returns failure, with an error value that\n is propagated back to the caller immediately (short-circuiting).\n\n The initial value is the value the accumulator will have on the first\n call. If applying the closure succeeded against every element of the\n iterator, `try_fold()` returns the final accumulator as success.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `try_fold()` on the internal parts\n from which this iterator is composed. If multiple calls are needed,\n the `?` operator may be convenient for chaining the accumulator value\n along, but beware any invariants that need to be upheld before those\n early returns. This is a `&mut self` method, so iteration needs to be\n resumable after hitting an error here.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the checked sum of all of the elements of the array\n let sum = a.into_iter().try_fold(0i8, |acc, x| acc.checked_add(x));\n\n assert_eq!(sum, Some(6));\n ```\n\n Short-circuiting:\n\n ```\n let a = [10, 20, 30, 100, 40, 50];\n let mut iter = a.into_iter();\n\n // This sum overflows when adding the 100 element\n let sum = iter.try_fold(0i8, |acc, x| acc.checked_add(x));\n assert_eq!(sum, None);\n\n // Because it short-circuited, the remaining elements are still\n // available through the iterator.\n assert_eq!(iter.len(), 2);\n assert_eq!(iter.next(), Some(40));\n ```\n\n While you cannot `break` from a closure, the [`ControlFlow`] type allows\n a similar idea:\n\n ```\n use std::ops::ControlFlow;\n\n let triangular = (1..30).try_fold(0_i8, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Break(120));\n\n let triangular = (1..30).try_fold(0_u64, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Continue(435));\n ```\n",
      "adt": {}
    },
    "ops::try_trait::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "MutRef",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 748, kind: Param(ParamTy { index: 1, name: \"U\" }) })])",
      "Plain"
    ],
    "iter::adapters::flatten::FlattenCompat": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4114, kind: Param(ParamTy { index: 2, name: \"Acc\" }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5987, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25500, name: \"ops::try_trait::Try::Residual\" }), args: GenericArgs([Type(Ty { id: 4118, kind: Param(ParamTy { index: 4, name: \"R\" }) })]) }) })])"
    ],
    "iter::adapters::fuse::Fuse": [
      "MutRef"
    ]
  },
  "path": 13842,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/flatten.rs:410:5: 437:6",
  "src": "fn iter_try_fold<Acc, Fold, R>(&mut self, mut acc: Acc, mut fold: Fold) -> R\n    where\n        Fold: FnMut(Acc, &mut U) -> R,\n        R: Try<Output = Acc>,\n    {\n        #[inline]\n        fn flatten<'a, T: IntoIterator, Acc, R: Try<Output = Acc>>(\n            frontiter: &'a mut Option<T::IntoIter>,\n            fold: &'a mut impl FnMut(Acc, &mut T::IntoIter) -> R,\n        ) -> impl FnMut(Acc, T) -> R + 'a {\n            move |acc, iter| fold(acc, frontiter.insert(iter.into_iter()))\n        }\n\n        if let Some(iter) = &mut self.frontiter {\n            acc = fold(acc, iter)?;\n        }\n        self.frontiter = None;\n\n        acc = self.iter.try_fold(acc, flatten(&mut self.frontiter, &mut fold))?;\n        self.frontiter = None;\n\n        if let Some(iter) = &mut self.backiter {\n            acc = fold(acc, iter)?;\n        }\n        self.backiter = None;\n\n        try { acc }\n    }",
  "mir": "fn iter::adapters::flatten::FlattenCompat::<I, U>::iter_try_fold(_1: &mut iter::adapters::flatten::FlattenCompat<I, U>, _2: Acc, _3: Fold) -> R {\n    let mut _0: R;\n    let mut _4: &mut option::Option<U>;\n    let mut _5: isize;\n    let  _6: &mut U;\n    let mut _7: ops::control_flow::ControlFlow<<R as ops::try_trait::Try>::Residual, Acc>;\n    let mut _8: R;\n    let mut _9: &mut Fold;\n    let mut _10: (Acc, &mut U);\n    let mut _11: Acc;\n    let mut _12: isize;\n    let  _13: <R as ops::try_trait::Try>::Residual;\n    let  _14: Acc;\n    let mut _15: option::Option<U>;\n    let mut _16: ops::control_flow::ControlFlow<<R as ops::try_trait::Try>::Residual, Acc>;\n    let mut _17: R;\n    let mut _18: &mut iter::adapters::fuse::Fuse<I>;\n    let mut _19: Acc;\n    let mut _20: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/flatten.rs:420:13: 420:29};\n    let mut _21: &mut option::Option<U>;\n    let mut _22: &mut Fold;\n    let mut _23: isize;\n    let  _24: <R as ops::try_trait::Try>::Residual;\n    let  _25: Acc;\n    let mut _26: option::Option<U>;\n    let mut _27: &mut option::Option<U>;\n    let mut _28: isize;\n    let  _29: &mut U;\n    let mut _30: ops::control_flow::ControlFlow<<R as ops::try_trait::Try>::Residual, Acc>;\n    let mut _31: R;\n    let mut _32: &mut Fold;\n    let mut _33: (Acc, &mut U);\n    let mut _34: Acc;\n    let mut _35: isize;\n    let  _36: <R as ops::try_trait::Try>::Residual;\n    let  _37: Acc;\n    let mut _38: option::Option<U>;\n    let mut _39: Acc;\n    debug self => _1;\n    debug acc => _2;\n    debug fold => _3;\n    debug iter => _6;\n    debug residual => _13;\n    debug val => _14;\n    debug residual => _24;\n    debug val => _25;\n    debug iter => _29;\n    debug residual => _36;\n    debug val => _37;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).1: option::Option<U>);\n        _5 = discriminant((*_4));\n        switchInt(move _5) -> [1: bb1, 0: bb8, otherwise: bb4];\n    }\n    bb1: {\n        _6 = &mut (((*_4) as variant#1).0: U);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &mut _3;\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = move _2;\n        _10 = (move _11, _6);\n        _8 = <Fold as ops::function::FnMut<(Acc, &mut U)>>::call_mut(move _9, move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        _7 = <R as ops::try_trait::Try>::branch(move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        _12 = discriminant(_7);\n        switchInt(move _12) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _14 = move ((_7 as variant#0).0: Acc);\n        _2 = _14;\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb9;\n    }\n    bb6: {\n        _13 = move ((_7 as variant#1).0: <R as ops::try_trait::Try>::Residual);\n        _0 = <R as ops::try_trait::FromResidual>::from_residual(_13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb28;\n    }\n    bb8: {\n        StorageDead(_4);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_15);\n        _15 = option::Option::None;\n        drop(((*_1).1: option::Option<U>)) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        ((*_1).1: option::Option<U>) = move _15;\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &mut ((*_1).0: iter::adapters::fuse::Fuse<I>);\n        StorageLive(_19);\n        _19 = move _2;\n        StorageLive(_20);\n        _21 = &mut ((*_1).1: option::Option<U>);\n        _22 = &mut _3;\n        _20 = iter::adapters::flatten::FlattenCompat::<I, U>::iter_try_fold::flatten::<<I as iter::traits::iterator::Iterator>::Item, Acc, R, Fold>(_21, _22) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _17 = <iter::adapters::fuse::Fuse<I> as iter::traits::iterator::Iterator>::try_fold::<Acc, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/flatten.rs:420:13: 420:29}, R>(move _18, move _19, move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        _16 = <R as ops::try_trait::Try>::branch(move _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        _23 = discriminant(_16);\n        switchInt(move _23) -> [0: bb14, 1: bb15, otherwise: bb4];\n    }\n    bb14: {\n        _25 = move ((_16 as variant#0).0: Acc);\n        _2 = _25;\n        StorageDead(_16);\n        StorageLive(_26);\n        _26 = option::Option::None;\n        drop(((*_1).1: option::Option<U>)) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _24 = move ((_16 as variant#1).0: <R as ops::try_trait::Try>::Residual);\n        _0 = <R as ops::try_trait::FromResidual>::from_residual(_24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_16);\n        goto -> bb28;\n    }\n    bb17: {\n        ((*_1).1: option::Option<U>) = move _26;\n        StorageDead(_26);\n        StorageLive(_27);\n        _27 = &mut ((*_1).2: option::Option<U>);\n        _28 = discriminant((*_27));\n        switchInt(move _28) -> [1: bb18, 0: bb24, otherwise: bb4];\n    }\n    bb18: {\n        _29 = &mut (((*_27) as variant#1).0: U);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &mut _3;\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = move _2;\n        _33 = (move _34, _29);\n        _31 = <Fold as ops::function::FnMut<(Acc, &mut U)>>::call_mut(move _32, move _33) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_32);\n        _30 = <R as ops::try_trait::Try>::branch(move _31) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_31);\n        _35 = discriminant(_30);\n        switchInt(move _35) -> [0: bb21, 1: bb22, otherwise: bb4];\n    }\n    bb21: {\n        _37 = move ((_30 as variant#0).0: Acc);\n        _2 = _37;\n        StorageDead(_30);\n        StorageDead(_27);\n        goto -> bb25;\n    }\n    bb22: {\n        _36 = move ((_30 as variant#1).0: <R as ops::try_trait::Try>::Residual);\n        _0 = <R as ops::try_trait::FromResidual>::from_residual(_36) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_30);\n        StorageDead(_27);\n        goto -> bb28;\n    }\n    bb24: {\n        StorageDead(_27);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_38);\n        _38 = option::Option::None;\n        drop(((*_1).2: option::Option<U>)) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        ((*_1).2: option::Option<U>) = move _38;\n        StorageDead(_38);\n        StorageLive(_39);\n        _39 = move _2;\n        _0 = <R as ops::try_trait::Try>::from_output(move _39) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_39);\n        drop(_3) -> [return: bb29, unwind unreachable];\n    }\n    bb28: {\n        drop(_3) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        return;\n    }\n}\n",
  "doc": " Folds over the inner iterators as long as the given function returns successfully,\n always storing the most recent inner iterator in `self.frontiter`.\n\n Folds over the inner iterators, not over their elements. Is used by the `try_fold` and\n `advance_by` methods.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}