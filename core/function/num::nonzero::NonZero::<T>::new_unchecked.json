{
  "name": "num::nonzero::NonZero::<T>::new_unchecked",
  "safe": false,
  "callees": {
    "num::nonzero::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {
        "option::Option": "Constructor",
        "num::nonzero::NonZero": "Constructor"
      }
    },
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "num::nonzero::NonZero::<T>::new_unchecked::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1088, kind: RigidTy(Adt(AdtDef(DefId { id: 24832, name: \"num::nonzero::NonZero\" }), GenericArgs([Type(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "num::nonzero::NonZero": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::nonzero::NonZero::<T>::new_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/nonzero.rs:418:5: 433:6",
  "src": "pub const unsafe fn new_unchecked(n: T) -> Self {\n        match Self::new(n) {\n            Some(n) => n,\n            None => {\n                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.\n                unsafe {\n                    ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    );\n                    intrinsics::unreachable()\n                }\n            }\n        }\n    }",
  "mir": "fn num::nonzero::NonZero::<T>::new_unchecked(_1: T) -> num::nonzero::NonZero<T> {\n    let mut _0: num::nonzero::NonZero<T>;\n    let mut _2: option::Option<num::nonzero::NonZero<T>>;\n    let mut _3: isize;\n    let mut _4: bool;\n    let  _5: ();\n    debug n => _1;\n    debug n => _0;\n    bb0: {\n        StorageLive(_2);\n        _2 = num::nonzero::NonZero::<T>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = discriminant(_2);\n        switchInt(move _3) -> [0: bb3, 1: bb4, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_4);\n        _4 = ub_checks::check_language_ub() -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        _0 = ((_2 as variant#1).0: num::nonzero::NonZero<T>);\n        StorageDead(_2);\n        return;\n    }\n    bb5: {\n        switchInt(move _4) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        _5 = num::nonzero::NonZero::<T>::new_unchecked::precondition_check() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_4);\n        unreachable;\n    }\n}\n",
  "doc": " Creates a non-zero without checking whether the value is non-zero.\n This results in undefined behavior if the value is zero.\n\n # Safety\n\n The value must not be zero.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}