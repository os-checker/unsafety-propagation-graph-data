{
  "name": "task::wake::Waker::will_wake",
  "safe": true,
  "callees": {
    "ptr::eq": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "ambiguous_wide_pointer_comparisons"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* ambiguous_wide_pointer_comparisons\n"
        ]
      },
      "doc": " Compares raw pointers for equality.\n\n This is the same as using the `==` operator, but less generic:\n the arguments have to be `*const T` raw pointers,\n not anything that implements `PartialEq`.\n\n This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n by their address rather than comparing the values they point to\n (which is what the `PartialEq for &T` implementation does).\n\n When comparing wide pointers, both the address and the metadata are tested for equality.\n However, note that comparing trait object pointers (`*const dyn Trait`) is unreliable: pointers\n to values of the same underlying type can compare inequal (because vtables are duplicated in\n multiple codegen units), and pointers to values of *different* underlying type can compare equal\n (since identical vtables can be deduplicated within a codegen unit).\n\n # Examples\n\n ```\n use std::ptr;\n\n let five = 5;\n let other_five = 5;\n let five_ref = &five;\n let same_five_ref = &five;\n let other_five_ref = &other_five;\n\n assert!(five_ref == same_five_ref);\n assert!(ptr::eq(five_ref, same_five_ref));\n\n assert!(five_ref == other_five_ref);\n assert!(!ptr::eq(five_ref, other_five_ref));\n ```\n\n Slices are also compared by their length (fat pointers):\n\n ```\n let a = [1, 2, 3];\n assert!(std::ptr::eq(&a[..3], &a[..3]));\n assert!(!std::ptr::eq(&a[..2], &a[..3]));\n assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "task::wake::Waker": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "task::wake::RawWakerVTable": [
      "Ref",
      "Deref"
    ]
  },
  "path": 17634,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/task/wake.rs:478:5: 484:6",
  "src": "pub fn will_wake(&self, other: &Waker) -> bool {\n        // We optimize this by comparing vtable addresses instead of vtable contents.\n        // This is permitted since the function is documented as best-effort.\n        let RawWaker { data: a_data, vtable: a_vtable } = self.waker;\n        let RawWaker { data: b_data, vtable: b_vtable } = other.waker;\n        a_data == b_data && ptr::eq(a_vtable, b_vtable)\n    }",
  "mir": "fn task::wake::Waker::will_wake(_1: &task::wake::Waker, _2: &task::wake::Waker) -> bool {\n    let mut _0: bool;\n    let  _3: *const ();\n    let  _4: &task::wake::RawWakerVTable;\n    let  _5: *const ();\n    let  _6: &task::wake::RawWakerVTable;\n    let mut _7: bool;\n    let mut _8: *const task::wake::RawWakerVTable;\n    let mut _9: *const task::wake::RawWakerVTable;\n    debug self => _1;\n    debug other => _2;\n    debug a_data => _3;\n    debug a_vtable => _4;\n    debug b_data => _5;\n    debug b_vtable => _6;\n    bb0: {\n        _3 = (((*_1).0: task::wake::RawWaker).0: *const ());\n        StorageLive(_4);\n        _4 = (((*_1).0: task::wake::RawWaker).1: &task::wake::RawWakerVTable);\n        _5 = (((*_2).0: task::wake::RawWaker).0: *const ());\n        StorageLive(_6);\n        _6 = (((*_2).0: task::wake::RawWaker).1: &task::wake::RawWakerVTable);\n        StorageLive(_7);\n        _7 = Eq(_3, _5);\n        switchInt(move _7) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_8);\n        _8 = &raw const (*_4);\n        StorageLive(_9);\n        _9 = &raw const (*_6);\n        _0 = ptr::eq::<task::wake::RawWakerVTable>(move _8, move _9) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        _0 = false;\n        goto -> bb4;\n    }\n    bb3: {\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Returns `true` if this `Waker` and another `Waker` would awake the same task.\n\n This function works on a best-effort basis, and may return false even\n when the `Waker`s would awaken the same task. However, if this function\n returns `true`, it is guaranteed that the `Waker`s will awaken the same task.\n\n This function is primarily used for optimization purposes â€” for example,\n this type's [`clone_from`](Self::clone_from) implementation uses it to\n avoid cloning the waker when they would wake the same task anyway.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}