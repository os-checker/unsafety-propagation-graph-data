{
  "name": "iter::sources::once::once",
  "safe": true,
  "callees": {
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ],
    "option::IntoIter": [
      "Plain"
    ],
    "iter::sources::once::Once": [
      "Plain"
    ]
  },
  "path": 14186,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/sources/once.rs:56:1: 58:2",
  "src": "pub fn once<T>(value: T) -> Once<T> {\n    Once { inner: Some(value).into_iter() }\n}",
  "mir": "fn iter::sources::once::once(_1: T) -> iter::sources::once::Once<T> {\n    let mut _0: iter::sources::once::Once<T>;\n    let mut _2: option::IntoIter<T>;\n    let mut _3: option::Option<T>;\n    debug value => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = option::Option::Some(_1);\n        _2 = <option::Option<T> as iter::traits::collect::IntoIterator>::into_iter(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = Once(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates an iterator that yields an element exactly once.\n\n This is commonly used to adapt a single value into a [`chain()`] of other\n kinds of iteration. Maybe you have an iterator that covers almost\n everything, but you need an extra special case. Maybe you have a function\n which works on iterators, but you only need to process one value.\n\n [`chain()`]: Iterator::chain\n\n # Examples\n\n Basic usage:\n\n ```\n use std::iter;\n\n // one is the loneliest number\n let mut one = iter::once(1);\n\n assert_eq!(Some(1), one.next());\n\n // just one, that's all we get\n assert_eq!(None, one.next());\n ```\n\n Chaining together with another iterator. Let's say that we want to iterate\n over each file of the `.foo` directory, but also a configuration file,\n `.foorc`:\n\n ```no_run\n use std::iter;\n use std::fs;\n use std::path::PathBuf;\n\n let dirs = fs::read_dir(\".foo\")?;\n\n // we need to convert from an iterator of DirEntry-s to an iterator of\n // PathBufs, so we use map\n let dirs = dirs.map(|file| file.unwrap().path());\n\n // now, our iterator just for our config file\n let config = iter::once(PathBuf::from(\".foorc\"));\n\n // chain the two iterators together into one big iterator\n let files = dirs.chain(config);\n\n // this will give us all of the files in .foo as well as .foorc\n for f in files {\n     println!(\"{f:?}\");\n }\n # std::io::Result::Ok(())\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}