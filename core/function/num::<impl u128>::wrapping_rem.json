{
  "name": "num::<impl u128>::wrapping_rem",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl u128>::wrapping_rem"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:2533:9: 2535:10",
  "src": "pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }",
  "mir": "fn num::<impl u128>::wrapping_rem(_1: u128, _2: u128) -> u128 {\n    let mut _0: u128;\n    let mut _3: bool;\n    debug self => _1;\n    debug rhs => _2;\n    bb0: {\n        _3 = Eq(_2, 0_u128);\n        assert(!move _3, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Rem(_1, _2);\n        return;\n    }\n}\n",
  "doc": " Wrapping (modular) remainder. Computes `self % rhs`.\n\n Wrapped remainder calculation on unsigned types is just the regular\n remainder calculation. There's no way wrapping could ever happen.\n This function exists so that all operations are accounted for in the\n wrapping operations.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}