{
  "name": "slice::index::into_slice_range",
  "safe": true,
  "callees": {
    "slice::index::slice_index_fail": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::Bound": [
      "Plain",
      "Unknown([Field(0, Ty { id: 12961, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Field(1, Ty { id: 12961, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::Range": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::index::into_slice_range"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/index.rs:1039:1: 1066:2",
  "src": "pub(crate) fn into_slice_range(\n    len: usize,\n    (start, end): (ops::Bound<usize>, ops::Bound<usize>),\n) -> ops::Range<usize> {\n    let end = match end {\n        ops::Bound::Included(end) if end >= len => slice_index_fail(0, end, len),\n        // Cannot overflow because `end < len` implies `end < usize::MAX`.\n        ops::Bound::Included(end) => end + 1,\n\n        ops::Bound::Excluded(end) if end > len => slice_index_fail(0, end, len),\n        ops::Bound::Excluded(end) => end,\n\n        ops::Bound::Unbounded => len,\n    };\n\n    let start = match start {\n        ops::Bound::Excluded(start) if start >= end => slice_index_fail(start, end, len),\n        // Cannot overflow because `start < end` implies `start < usize::MAX`.\n        ops::Bound::Excluded(start) => start + 1,\n\n        ops::Bound::Included(start) if start > end => slice_index_fail(start, end, len),\n        ops::Bound::Included(start) => start,\n\n        ops::Bound::Unbounded => 0,\n    };\n\n    start..end\n}",
  "mir": "fn slice::index::into_slice_range(_1: usize, _2: (ops::range::Bound<usize>, ops::range::Bound<usize>)) -> ops::range::Range<usize> {\n    let mut _0: ops::range::Range<usize>;\n    let  _3: ops::range::Bound<usize>;\n    let  _4: ops::range::Bound<usize>;\n    let  _5: usize;\n    let mut _6: isize;\n    let  _7: usize;\n    let  _8: &usize;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: !;\n    let  _12: usize;\n    let mut _13: (usize, bool);\n    let  _14: usize;\n    let  _15: &usize;\n    let mut _16: bool;\n    let mut _17: usize;\n    let mut _18: !;\n    let  _19: usize;\n    let  _20: usize;\n    let mut _21: isize;\n    let  _22: usize;\n    let  _23: &usize;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: !;\n    let mut _28: usize;\n    let  _29: usize;\n    let mut _30: (usize, bool);\n    let  _31: usize;\n    let  _32: &usize;\n    let mut _33: bool;\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: !;\n    let mut _37: usize;\n    let  _38: usize;\n    let mut _39: usize;\n    let mut _40: usize;\n    debug len => _1;\n    debug start => _3;\n    debug end => _4;\n    debug end => _5;\n    debug end => _7;\n    debug end => _8;\n    debug end => _12;\n    debug end => _14;\n    debug end => _15;\n    debug end => _19;\n    debug start => _20;\n    debug start => _22;\n    debug start => _23;\n    debug start => _29;\n    debug start => _31;\n    debug start => _32;\n    debug start => _38;\n    bb0: {\n        StorageLive(_3);\n        _3 = (_2.0: ops::range::Bound<usize>);\n        StorageLive(_4);\n        _4 = (_2.1: ops::range::Bound<usize>);\n        StorageLive(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb3, 2: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _5 = _1;\n        goto -> bb10;\n    }\n    bb3: {\n        StorageLive(_15);\n        _15 = &((_4 as variant#1).0: usize);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (*_15);\n        _16 = Gt(move _17, _1);\n        switchInt(move _16) -> [0: bb9, otherwise: bb8];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = &((_4 as variant#0).0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (*_8);\n        _9 = Ge(move _10, _1);\n        switchInt(move _9) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        _7 = ((_4 as variant#0).0: usize);\n        _11 = slice::index::slice_index_fail(0_usize, _7, _1) -> unwind unreachable;\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        _12 = ((_4 as variant#0).0: usize);\n        _13 = CheckedAdd(_12, 1_usize);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _12, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _5 = move (_13.0: usize);\n        goto -> bb10;\n    }\n    bb8: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _14 = ((_4 as variant#1).0: usize);\n        _18 = slice::index::slice_index_fail(0_usize, _14, _1) -> unwind unreachable;\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_19);\n        _19 = ((_4 as variant#1).0: usize);\n        _5 = _19;\n        StorageDead(_19);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_20);\n        _21 = discriminant(_3);\n        switchInt(move _21) -> [0: bb12, 1: bb13, 2: bb11, otherwise: bb1];\n    }\n    bb11: {\n        _20 = 0_usize;\n        goto -> bb19;\n    }\n    bb12: {\n        StorageLive(_32);\n        _32 = &((_3 as variant#0).0: usize);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = (*_32);\n        StorageLive(_35);\n        _35 = _5;\n        _33 = Gt(move _34, move _35);\n        switchInt(move _33) -> [0: bb18, otherwise: bb17];\n    }\n    bb13: {\n        StorageLive(_23);\n        _23 = &((_3 as variant#1).0: usize);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = (*_23);\n        StorageLive(_26);\n        _26 = _5;\n        _24 = Ge(move _25, move _26);\n        switchInt(move _24) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        _22 = ((_3 as variant#1).0: usize);\n        StorageLive(_28);\n        _28 = _5;\n        _27 = slice::index::slice_index_fail(_22, move _28, _1) -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        _29 = ((_3 as variant#1).0: usize);\n        _30 = CheckedAdd(_29, 1_usize);\n        assert(!move (_30.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _29, 1_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _20 = move (_30.0: usize);\n        goto -> bb19;\n    }\n    bb17: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        _31 = ((_3 as variant#0).0: usize);\n        StorageLive(_37);\n        _37 = _5;\n        _36 = slice::index::slice_index_fail(_31, move _37, _1) -> unwind unreachable;\n    }\n    bb18: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_38);\n        _38 = ((_3 as variant#0).0: usize);\n        _20 = _38;\n        StorageDead(_38);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_39);\n        _39 = _20;\n        StorageLive(_40);\n        _40 = _5;\n        _0 = Range(move _39, move _40);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_20);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Converts pair of `ops::Bound`s into `ops::Range`.\n Panics on overflowing indices.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}