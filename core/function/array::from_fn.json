{
  "name": "array::from_fn",
  "safe": true,
  "callees": {
    "ops::try_trait::NeverShortCircuit::<T>::wrap_mut_1": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a unary function to produce one that wraps the output into a `NeverShortCircuit`.\n\n This is useful for implementing infallible functions in terms of the `try_` ones,\n without accidentally capturing extra generic parameters in a closure.\n",
      "adt": {
        "ops::try_trait::Wrapped": "Constructor"
      }
    },
    "array::try_from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n Unlike [`from_fn`], where the element creation can't fail, this version will return an error\n if any element creation was unsuccessful.\n\n The return type of this function depends on the return type of the closure.\n If you return `Result<T, E>` from the closure, you'll get a `Result<[T; N], E>`.\n If you return `Option<T>` from the closure, you'll get an `Option<[T; N]>`.\n\n # Arguments\n\n * `cb`: Callback where the passed argument is the current array index.\n\n # Example\n\n ```rust\n #![feature(array_try_from_fn)]\n\n let array: Result<[u8; 5], _> = std::array::try_from_fn(|i| i.try_into());\n assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n\n let array: Result<[i8; 200], _> = std::array::try_from_fn(|i| i.try_into());\n assert!(array.is_err());\n\n let array: Option<[_; 4]> = std::array::try_from_fn(|i| i.checked_add(100));\n assert_eq!(array, Some([100, 101, 102, 103]));\n\n let array: Option<[_; 4]> = std::array::try_from_fn(|i| i.checked_sub(100));\n assert_eq!(array, None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::try_trait::Wrapped": [
      "Plain"
    ],
    "ops::try_trait::NeverShortCircuit": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1462, kind: RigidTy(Array(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) }, TyConst { kind: Param(ParamConst { index: 1, name: \"N\" }), id: TyConstId(37, ThreadLocalIndex) })) })])"
    ]
  },
  "path": 4549,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/mod.rs:109:1: 114:2",
  "src": "pub const fn from_fn<T: [const] Destruct, const N: usize, F>(f: F) -> [T; N]\nwhere\n    F: [const] FnMut(usize) -> T + [const] Destruct,\n{\n    try_from_fn(NeverShortCircuit::wrap_mut_1(f)).0\n}",
  "mir": "fn array::from_fn(_1: F) -> [T; N] {\n    let mut _0: [T; N];\n    let mut _2: ops::try_trait::NeverShortCircuit<[T; N]>;\n    let mut _3: ops::try_trait::Wrapped<T, usize, F>;\n    debug f => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ops::try_trait::NeverShortCircuit::<T>::wrap_mut_1::<usize, F>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = array::try_from_fn::<ops::try_trait::NeverShortCircuit<T>, N, ops::try_trait::Wrapped<T, usize, F>>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = move (_2.0: [T; N]);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates an array where each element is produced by calling `f` with\n that element's index while walking forward through the array.\n\n This is essentially the same as writing\n ```text\n [f(0), f(1), f(2), â€¦, f(N - 2), f(N - 1)]\n ```\n and is similar to `(0..i).map(f)`, just for arrays not iterators.\n\n If `N == 0`, this produces an empty array without ever calling `f`.\n\n # Example\n\n ```rust\n // type inference is helping us here, the way `from_fn` knows how many\n // elements to produce is the length of array down there: only arrays of\n // equal lengths can be compared, so the const generic parameter `N` is\n // inferred to be 5, thus creating array of 5 elements.\n\n let array = core::array::from_fn(|i| i);\n // indexes are:    0  1  2  3  4\n assert_eq!(array, [0, 1, 2, 3, 4]);\n\n let array2: [usize; 8] = core::array::from_fn(|i| i * 2);\n // indexes are:     0  1  2  3  4  5   6   7\n assert_eq!(array2, [0, 2, 4, 6, 8, 10, 12, 14]);\n\n let bool_arr = core::array::from_fn::<_, 5, _>(|i| i % 2 == 0);\n // indexes are:       0     1      2     3      4\n assert_eq!(bool_arr, [true, false, true, false, true]);\n ```\n\n You can also capture things, for example to create an array full of clones\n where you can't just use `[item; N]` because it's not `Copy`:\n ```\n # // TBH `array::repeat` would be better for this, but it's not stable yet.\n let my_string = String::from(\"Hello\");\n let clones: [String; 42] = std::array::from_fn(|_| my_string.clone());\n assert!(clones.iter().all(|x| *x == my_string));\n ```\n\n The array is generated in ascending index order, starting from the front\n and going towards the back, so you can use closures with mutable state:\n ```\n let mut state = 1;\n let a = std::array::from_fn(|_| { let x = state; state *= 2; x });\n assert_eq!(a, [1, 2, 4, 8, 16, 32]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}