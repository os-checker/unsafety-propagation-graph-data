{
  "name": "<iter::adapters::skip::Skip<I> as iter::traits::iterator::Iterator>::nth",
  "safe": true,
  "callees": {
    "mem::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Replaces `dest` with the default value of `T`, returning the previous `dest` value.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a passed value instead of the default value, see [`replace`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::take(&mut v);\n assert_eq!(vec![1, 2], old_v);\n assert!(v.is_empty());\n ```\n\n `take` allows taking ownership of a struct field by replacing it with an \"empty\" value.\n Without `take` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn get_and_reset(&mut self) -> Vec<T> {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let buf = self.buf;\n         self.buf = Vec::new();\n         buf\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n `self.buf`. But `take` can be used to disassociate the original value of `self.buf` from\n `self`, allowing it to be returned:\n\n ```\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn get_and_reset(&mut self) -> Vec<T> {\n         mem::take(&mut self.buf)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf.len(), 2);\n\n assert_eq!(buffer.get_and_reset(), vec![0, 1]);\n assert_eq!(buffer.buf.len(), 0);\n ```\n",
      "adt": {}
    },
    "num::<impl usize>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::nth": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element of the iterator.\n\n Like most indexing operations, the count starts from zero, so `nth(0)`\n returns the first value, `nth(1)` the second, and so on.\n\n Note that all preceding elements, as well as the returned element, will be\n consumed from the iterator. That means that the preceding elements will be\n discarded, and also that calling `nth(0)` multiple times on the same iterator\n will return different elements.\n\n `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(1), Some(2));\n ```\n\n Calling `nth()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.nth(1), Some(2));\n assert_eq!(iter.nth(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(10), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::skip::Skip": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4671, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25924, name: \"iter::traits::iterator::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::skip::Skip<I> as iter::traits::iterator::Iterator>::nth"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/skip.rs:49:5: 68:6",
  "src": "fn nth(&mut self, n: usize) -> Option<I::Item> {\n        if self.n > 0 {\n            let skip: usize = crate::mem::take(&mut self.n);\n            // Checked add to handle overflow case.\n            let n = match skip.checked_add(n) {\n                Some(nth) => nth,\n                None => {\n                    // In case of overflow, load skip value, before loading `n`.\n                    // Because the amount of elements to iterate is beyond `usize::MAX`, this\n                    // is split into two `nth` calls where the `skip` `nth` call is discarded.\n                    self.iter.nth(skip - 1)?;\n                    n\n                }\n            };\n            // Load nth element including skip.\n            self.iter.nth(n)\n        } else {\n            self.iter.nth(n)\n        }\n    }",
  "mir": "fn <iter::adapters::skip::Skip<I> as iter::traits::iterator::Iterator>::nth(_1: &mut iter::adapters::skip::Skip<I>, _2: usize) -> option::Option<<I as iter::traits::iterator::Iterator>::Item> {\n    let mut _0: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _3: bool;\n    let mut _4: usize;\n    let  _5: usize;\n    let mut _6: &mut usize;\n    let  _7: usize;\n    let mut _8: option::Option<usize>;\n    let mut _9: isize;\n    let  _10: usize;\n    let  _11: <I as iter::traits::iterator::Iterator>::Item;\n    let mut _12: ops::control_flow::ControlFlow<option::Option<convert::Infallible>, <I as iter::traits::iterator::Iterator>::Item>;\n    let mut _13: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _14: &mut I;\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let mut _17: isize;\n    let  _18: <I as iter::traits::iterator::Iterator>::Item;\n    let mut _19: &mut I;\n    let mut _20: usize;\n    let mut _21: &mut I;\n    debug self => _1;\n    debug n => _2;\n    debug skip => _5;\n    debug n => _7;\n    debug nth => _10;\n    debug residual => option::Option::<convert::Infallible>::None;\n    debug val => _18;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).1: usize);\n        _3 = Gt(move _4, 0_usize);\n        switchInt(move _3) -> [0: bb16, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        _6 = &mut ((*_1).1: usize);\n        _5 = mem::take::<usize>(_6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = num::<impl usize>::checked_add(_5, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = discriminant(_8);\n        switchInt(move _9) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &mut ((*_1).0: I);\n        StorageLive(_15);\n        _16 = CheckedSub(_5, 1_usize);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_10);\n        _10 = ((_8 as variant#1).0: usize);\n        _7 = _10;\n        StorageDead(_10);\n        goto -> bb14;\n    }\n    bb7: {\n        _15 = move (_16.0: usize);\n        _13 = <I as iter::traits::iterator::Iterator>::nth(move _14, move _15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _12 = <option::Option<<I as iter::traits::iterator::Iterator>::Item> as ops::try_trait::Try>::branch(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _17 = discriminant(_12);\n        switchInt(move _17) -> [0: bb10, 1: bb11, otherwise: bb4];\n    }\n    bb10: {\n        StorageLive(_18);\n        _18 = move ((_12 as variant#0).0: <I as iter::traits::iterator::Iterator>::Item);\n        _11 = move _18;\n        StorageDead(_18);\n        drop(_11) -> [return: bb13, unwind unreachable];\n    }\n    bb11: {\n        _0 = <option::Option<<I as iter::traits::iterator::Iterator>::Item> as ops::try_trait::FromResidual<option::Option<convert::Infallible>>>::from_residual(option::Option::<convert::Infallible>::None) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_3);\n        goto -> bb19;\n    }\n    bb13: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _7 = _2;\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_8);\n        StorageLive(_19);\n        _19 = &mut ((*_1).0: I);\n        StorageLive(_20);\n        _20 = _7;\n        _0 = <I as iter::traits::iterator::Iterator>::nth(move _19, move _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_7);\n        goto -> bb18;\n    }\n    bb16: {\n        StorageDead(_4);\n        StorageLive(_21);\n        _21 = &mut ((*_1).0: I);\n        _0 = <I as iter::traits::iterator::Iterator>::nth(move _21, _2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_21);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_3);\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}