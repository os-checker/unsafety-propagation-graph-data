{
  "name": "slice::sort::shared::smallsort::swap_if_less",
  "safe": false,
  "callees": {
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "hint::select_unpredictable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns either `true_val` or `false_val` depending on the value of\n `condition`, with a hint to the compiler that `condition` is unlikely to be\n correctly predicted by a CPUâ€™s branch predictor.\n\n This method is functionally equivalent to\n ```ignore (this is just for illustrative purposes)\n fn select_unpredictable<T>(b: bool, true_val: T, false_val: T) -> T {\n     if b { true_val } else { false_val }\n }\n ```\n but might generate different assembly. In particular, on platforms with\n a conditional move or select instruction (like `cmov` on x86 or `csel`\n on ARM) the optimizer might use these instructions to avoid branches,\n which can benefit performance if the branch predictor is struggling\n with predicting `condition`, such as in an implementation of binary\n search.\n\n Note however that this lowering is not guaranteed (on any platform) and\n should not be relied upon when trying to write cryptographic constant-time\n code. Also be aware that this lowering might *decrease* performance if\n `condition` is well-predictable. It is advisable to perform benchmarks to\n tell if this function is useful.\n\n # Examples\n\n Distribute values evenly between two buckets:\n ```\n use std::hash::BuildHasher;\n use std::hint;\n\n fn append<H: BuildHasher>(hasher: &H, v: i32, bucket_one: &mut Vec<i32>, bucket_two: &mut Vec<i32>) {\n     let hash = hasher.hash_one(&v);\n     let bucket = hint::select_unpredictable(hash % 2 == 0, bucket_one, bucket_two);\n     bucket.push(v);\n }\n # let hasher = std::collections::hash_map::RandomState::new();\n # let mut bucket_one = Vec::new();\n # let mut bucket_two = Vec::new();\n # append(&hasher, 42, &mut bucket_one, &mut bucket_two);\n # assert_eq!(bucket_one.len() + bucket_two.len(), 1);\n ```\n",
      "adt": {}
    },
    "ptr::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `src` without moving it. This leaves the\n memory in `src` unchanged.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads.\n\n * `src` must be properly aligned. Use [`read_unaligned`] if this is not the\n   case.\n\n * `src` must point to a properly initialized value of type `T`.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n # Examples\n\n Basic usage:\n\n ```\n let x = 12;\n let y = &x as *const i32;\n\n unsafe {\n     assert_eq!(std::ptr::read(y), 12);\n }\n ```\n\n Manually implement [`mem::swap`]:\n\n ```\n use std::ptr;\n\n fn swap<T>(a: &mut T, b: &mut T) {\n     unsafe {\n         // Create a bitwise copy of the value at `a` in `tmp`.\n         let tmp = ptr::read(a);\n\n         // Exiting at this point (either by explicitly returning or by\n         // calling a function which panics) would cause the value in `tmp` to\n         // be dropped while the same value is still referenced by `a`. This\n         // could trigger undefined behavior if `T` is not `Copy`.\n\n         // Create a bitwise copy of the value at `b` in `a`.\n         // This is safe because mutable references cannot alias.\n         ptr::copy_nonoverlapping(b, a, 1);\n\n         // As above, exiting here could trigger undefined behavior because\n         // the same value is referenced by `a` and `b`.\n\n         // Move `tmp` into `b`.\n         ptr::write(b, tmp);\n\n         // `tmp` has been moved (`write` takes ownership of its second argument),\n         // so nothing is dropped implicitly here.\n     }\n }\n\n let mut foo = \"foo\".to_owned();\n let mut bar = \"bar\".to_owned();\n\n swap(&mut foo, &mut bar);\n\n assert_eq!(foo, \"bar\");\n assert_eq!(bar, \"foo\");\n ```\n\n ## Ownership of the Returned Value\n\n `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n If `T` is not [`Copy`], using both the returned value and the value at\n `*src` can violate memory safety. Note that assigning to `*src` counts as a\n use because it will attempt to drop the value at `*src`.\n\n [`write()`] can be used to overwrite data without causing it to be dropped.\n\n ```\n use std::ptr;\n\n let mut s = String::from(\"foo\");\n unsafe {\n     // `s2` now points to the same underlying memory as `s`.\n     let mut s2: String = ptr::read(&s);\n\n     assert_eq!(s2, \"foo\");\n\n     // Assigning to `s2` causes its original value to be dropped. Beyond\n     // this point, `s` must no longer be used, as the underlying memory has\n     // been freed.\n     s2 = String::default();\n     assert_eq!(s2, \"\");\n\n     // Assigning to `s` would cause the old value to be dropped again,\n     // resulting in undefined behavior.\n     // s = String::from(\"bar\"); // ERROR\n\n     // `ptr::write` can be used to overwrite a value without dropping it.\n     ptr::write(&mut s, String::from(\"bar\"));\n }\n\n assert_eq!(s, \"bar\");\n ```\n\n [valid]: self#safety\n",
      "adt": {}
    },
    "mem::manually_drop::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {
        "mem::manually_drop::ManuallyDrop": "Constructor"
      }
    },
    "ptr::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n\n If the source and destination will *never* overlap,\n [`copy_nonoverlapping`] can be used instead.\n\n `copy` is semantically equivalent to C's [`memmove`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n Copying takes place as if the bytes were copied from `src`\n to a temporary array and then copied from the array to `dst`.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\n   when `src` is read for `count * size_of::<T>()` bytes. (This means if the memory ranges\n   overlap, the `dst` pointer must not be invalidated by `src` reads.)\n\n * Both `src` and `dst` must be properly aligned.\n\n Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Efficiently create a Rust vector from an unsafe buffer:\n\n ```\n use std::ptr;\n\n /// # Safety\n ///\n /// * `ptr` must be correctly aligned for its type and non-zero.\n /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n /// * Those elements must not be used after calling this function unless `T: Copy`.\n # #[allow(dead_code)]\n unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     let mut dst = Vec::with_capacity(elts);\n\n     // SAFETY: Our precondition ensures the source is aligned and valid,\n     // and `Vec::with_capacity` ensures that we have usable space to write them.\n     unsafe { ptr::copy(ptr, dst.as_mut_ptr(), elts); }\n\n     // SAFETY: We created it with this much capacity earlier,\n     // and the previous `copy` has initialized these elements.\n     unsafe { dst.set_len(elts); }\n     dst\n }\n ```\n",
      "adt": {}
    },
    "ops::deref::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "mem::manually_drop::ManuallyDrop": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::sort::shared::smallsort::swap_if_less"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:386:1: 418:2",
  "src": "unsafe fn swap_if_less<T, F>(v_base: *mut T, a_pos: usize, b_pos: usize, is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    // SAFETY: the caller must guarantee that `a_pos` and `b_pos` each added to `v_base` yield valid\n    // pointers into `v_base`, and are properly aligned, and part of the same allocation.\n    unsafe {\n        let v_a = v_base.add(a_pos);\n        let v_b = v_base.add(b_pos);\n\n        // PANIC SAFETY: if is_less panics, no scratch memory was created and the slice should still be\n        // in a well defined state, without duplicates.\n\n        // Important to only swap if it is more and not if it is equal. is_less should return false for\n        // equal, so we don't swap.\n        let should_swap = is_less(&*v_b, &*v_a);\n\n        // This is a branchless version of swap if.\n        // The equivalent code with a branch would be:\n        //\n        // if should_swap {\n        //     ptr::swap(v_a, v_b, 1);\n        // }\n\n        // The goal is to generate cmov instructions here.\n        let v_a_swap = hint::select_unpredictable(should_swap, v_b, v_a);\n        let v_b_swap = hint::select_unpredictable(should_swap, v_a, v_b);\n\n        let v_b_swap_tmp = ManuallyDrop::new(ptr::read(v_b_swap));\n        ptr::copy(v_a_swap, v_a, 1);\n        ptr::copy_nonoverlapping(&*v_b_swap_tmp, v_b, 1);\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::swap_if_less(_1: *mut T, _2: usize, _3: usize, _4: &mut F) -> () {\n    let mut _0: ();\n    let  _5: *mut T;\n    let  _6: *mut T;\n    let  _7: bool;\n    let mut _8: (&T, &T);\n    let  _9: &T;\n    let  _10: &T;\n    let  _11: *mut T;\n    let  _12: *mut T;\n    let  _13: mem::manually_drop::ManuallyDrop<T>;\n    let mut _14: T;\n    let mut _15: *const T;\n    let  _16: ();\n    let mut _17: *const T;\n    let  _18: ();\n    let mut _19: *const T;\n    let  _20: &T;\n    let mut _21: &mem::manually_drop::ManuallyDrop<T>;\n    debug v_base => _1;\n    debug a_pos => _2;\n    debug b_pos => _3;\n    debug is_less => _4;\n    debug v_a => _5;\n    debug v_b => _6;\n    debug should_swap => _7;\n    debug v_a_swap => _11;\n    debug v_b_swap => _12;\n    debug v_b_swap_tmp => _13;\n    bb0: {\n        _5 = ptr::mut_ptr::<impl *mut T>::add(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = ptr::mut_ptr::<impl *mut T>::add(_1, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_8);\n        _9 = &(*_6);\n        _10 = &(*_5);\n        _8 = (_9, _10);\n        _7 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_4, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        _11 = hint::select_unpredictable::<*mut T>(_7, _6, _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _12 = hint::select_unpredictable::<*mut T>(_7, _5, _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _12 as *const T;\n        _14 = ptr::read::<T>(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _13 = mem::manually_drop::ManuallyDrop::<T>::new(move _14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageLive(_17);\n        _17 = _11 as *const T;\n        _16 = ptr::copy::<T>(move _17, _5, 1_usize) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        StorageLive(_19);\n        StorageLive(_21);\n        _21 = &_13;\n        _20 = <mem::manually_drop::ManuallyDrop<T> as ops::deref::Deref>::deref(move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        _19 = &raw const (*_20);\n        _18 = ptr::copy_nonoverlapping::<T>(move _19, _6, 1_usize) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " Swap two values in the slice pointed to by `v_base` at the position `a_pos` and `b_pos` if the\n value at position `b_pos` is less than the one at position `a_pos`.\n\n Purposefully not marked `#[inline]`, despite us wanting it to be inlined for integers like\n types. `is_less` could be a huge function and we want to give the compiler an option to\n not inline this function. For the same reasons that this function is very perf critical\n it should be in the same module as the functions that use it.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}