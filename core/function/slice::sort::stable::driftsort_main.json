{
  "name": "slice::sort::stable::driftsort_main",
  "safe": true,
  "callees": {
    "mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "cmp::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the maximum of two values.\n\n Returns the second argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::max`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::max(1, 2), 2);\n assert_eq!(cmp::max(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::max(Equal(\"v1\"), Equal(\"v2\")).0, \"v2\");\n ```\n",
      "adt": {}
    },
    "slice::sort::stable::AlignedStorage::<T, N>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "slice::sort::stable::AlignedStorage": "Constructor"
      }
    },
    "slice::sort::stable::AlignedStorage::<T, N>::as_uninit_slice_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "slice::sort::stable::AlignedStorage": "MutableAsArgument"
      }
    },
    "slice::sort::stable::BufGuard::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new buffer that holds at least `capacity` memory.\n",
      "adt": {}
    },
    "slice::sort::stable::BufGuard::as_uninit_slice_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns mutable access to uninitialized memory owned by the buffer.\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::StableSmallSortTypeImpl::small_sort_threshold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " For which input length <= return value of this function, is it valid to call `small_sort`.\n",
      "adt": {}
    },
    "slice::sort::stable::drift::sort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts `v` based on comparison function `is_less`. If `eager_sort` is true,\n it will only do small-sorts and physical merges, ensuring O(N * log(N))\n worst-case complexity. `scratch.len()` must be at least\n `max(v.len() - v.len() / 2, SMALL_SORT_GENERAL_SCRATCH_LEN)` otherwise the implementation may abort.\n Fully ascending and descending inputs will be sorted with exactly N - 1\n comparisons.\n\n This is the main loop for driftsort, which uses powersort's heuristic to\n determine in which order to merge runs, see below for details.\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::sort::stable::AlignedStorage": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::sort::stable::driftsort_main"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/stable/mod.rs:94:1: 136:2",
  "src": "fn driftsort_main<T, F: FnMut(&T, &T) -> bool, BufT: BufGuard<T>>(v: &mut [T], is_less: &mut F) {\n    // By allocating n elements of memory we can ensure the entire input can\n    // be sorted using stable quicksort, which allows better performance on\n    // random and low-cardinality distributions. However, we still want to\n    // reduce our memory usage to n - n / 2 for large inputs. We do this by scaling\n    // our allocation as max(n - n / 2, min(n, 8MB)), ensuring we scale like n for\n    // small inputs and n - n / 2 for large inputs, without a sudden drop off. We\n    // also need to ensure our alloc >= SMALL_SORT_GENERAL_SCRATCH_LEN, as the\n    // small-sort always needs this much memory.\n    //\n    // driftsort will produce unsorted runs of up to min_good_run_len, which\n    // is at most len - len / 2.\n    // Unsorted runs need to be processed by quicksort, which requires as much\n    // scratch space as the run length, therefore the scratch space must be at\n    // least len - len / 2.\n    // If min_good_run_len is ever modified, this code must be updated to allocate\n    // the correct scratch size for it.\n    const MAX_FULL_ALLOC_BYTES: usize = 8_000_000; // 8MB\n    let max_full_alloc = MAX_FULL_ALLOC_BYTES / size_of::<T>();\n    let len = v.len();\n    let alloc_len = cmp::max(\n        cmp::max(len - len / 2, cmp::min(len, max_full_alloc)),\n        SMALL_SORT_GENERAL_SCRATCH_LEN,\n    );\n\n    // For small inputs 4KiB of stack storage suffices, which allows us to avoid\n    // calling the (de-)allocator. Benchmarks showed this was quite beneficial.\n    let mut stack_buf = AlignedStorage::<T, 4096>::new();\n    let stack_scratch = stack_buf.as_uninit_slice_mut();\n    let mut heap_buf;\n    let scratch = if stack_scratch.len() >= alloc_len {\n        stack_scratch\n    } else {\n        heap_buf = BufT::with_capacity(alloc_len);\n        heap_buf.as_uninit_slice_mut()\n    };\n\n    // For small inputs using quicksort is not yet beneficial, and a single\n    // small-sort or two small-sorts plus a single merge outperforms it, so use\n    // eager mode.\n    let eager_sort = len <= T::small_sort_threshold() * 2;\n    crate::slice::sort::stable::drift::sort(v, scratch, eager_sort, is_less);\n}",
  "mir": "fn slice::sort::stable::driftsort_main(_1: &mut [T], _2: &mut F) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: bool;\n    let  _6: usize;\n    let mut _7: &[T];\n    let  _8: usize;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: usize;\n    let mut _12: bool;\n    let mut _13: (usize, bool);\n    let mut _14: usize;\n    let mut _15: slice::sort::stable::AlignedStorage<T, 4096>;\n    let  _16: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _17: &mut slice::sort::stable::AlignedStorage<T, 4096>;\n    let mut _18: BufT;\n    let  _19: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _20: bool;\n    let mut _21: usize;\n    let mut _22: &[mem::maybe_uninit::MaybeUninit<T>];\n    let mut _23: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _24: BufT;\n    let mut _25: &mut BufT;\n    let  _26: bool;\n    let mut _27: usize;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let  _30: ();\n    let mut _31: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _32: bool;\n    debug v => _1;\n    debug is_less => _2;\n    debug max_full_alloc => _3;\n    debug len => _6;\n    debug alloc_len => _8;\n    debug stack_buf => _15;\n    debug stack_scratch => _16;\n    debug heap_buf => _18;\n    debug scratch => _19;\n    debug eager_sort => _26;\n    bb0: {\n        _32 = false;\n        StorageLive(_4);\n        _4 = mem::size_of::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = Eq(_4, 0_usize);\n        assert(!move _5, \"attempt to divide `{}` by zero\", slice::sort::stable::driftsort_main::MAX_FULL_ALLOC_BYTES) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = Div(slice::sort::stable::driftsort_main::MAX_FULL_ALLOC_BYTES, move _4);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _12 = Eq(2_usize, 0_usize);\n        assert(!move _12, \"attempt to divide `{}` by zero\", _6) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _11 = Div(_6, 2_usize);\n        _13 = CheckedSub(_6, _11);\n        assert(!move (_13.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, move _11) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = move (_13.0: usize);\n        StorageDead(_11);\n        StorageLive(_14);\n        _14 = cmp::min::<usize>(_6, _3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = cmp::max::<usize>(move _10, move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageDead(_10);\n        _8 = cmp::max::<usize>(move _9, slice::sort::shared::smallsort::SMALL_SORT_GENERAL_SCRATCH_LEN) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageLive(_15);\n        _15 = slice::sort::stable::AlignedStorage::<T, 4096>::new() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _15;\n        _16 = slice::sort::stable::AlignedStorage::<T, 4096>::as_uninit_slice_mut(move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_16);\n        _21 = PtrMetadata(move _22);\n        StorageDead(_22);\n        _20 = Ge(move _21, _8);\n        switchInt(move _20) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_21);\n        _19 = move _16;\n        goto -> bb14;\n    }\n    bb11: {\n        StorageDead(_21);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = <BufT as slice::sort::stable::BufGuard<T>>::with_capacity(_8) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _32 = true;\n        _18 = move _24;\n        StorageDead(_24);\n        StorageLive(_25);\n        _25 = &mut _18;\n        _23 = <BufT as slice::sort::stable::BufGuard<T>>::as_uninit_slice_mut(move _25) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_25);\n        _19 = _23;\n        StorageDead(_23);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = <T as slice::sort::shared::smallsort::StableSmallSortTypeImpl>::small_sort_threshold() -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _29 = CheckedMul(_28, 2_usize);\n        assert(!move (_29.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _28, 2_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _27 = move (_29.0: usize);\n        StorageDead(_28);\n        _26 = Le(_6, move _27);\n        StorageDead(_27);\n        StorageLive(_31);\n        _31 = _19;\n        _30 = slice::sort::stable::drift::sort::<T, F>(_1, move _31, _26, _2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_31);\n        StorageDead(_19);\n        switchInt(_32) -> [0: bb18, otherwise: bb19];\n    }\n    bb18: {\n        _32 = false;\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_15);\n        return;\n    }\n    bb19: {\n        drop(_18) -> [return: bb18, unwind unreachable];\n    }\n}\n",
  "doc": " See [`sort`]\n\n Deliberately don't inline the main sorting routine entrypoint to ensure the\n inlined insertion sort i-cache footprint remains minimal.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}