{
  "name": "option::Option::<T>::as_mut_slice",
  "safe": true,
  "callees": {
    "ptr::mut_ptr::<impl *mut T>::byte_add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an unsigned offset in bytes to a pointer.\n\n `count` is in units of bytes.\n\n This is purely a convenience for casting to a `u8` pointer and\n using [add][pointer::add] on it. See that method for documentation\n and safety requirements.\n\n For non-`Sized` pointees this operation changes only the data pointer,\n leaving the metadata untouched.\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "option::Option::<T>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "option::Option": "MutableAsArgument"
      }
    },
    "slice::raw::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Deref",
      "Ref",
      "MutRef"
    ]
  },
  "path": 15725,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:899:5: 918:6",
  "src": "pub const fn as_mut_slice(&mut self) -> &mut [T] {\n        // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n        // to the payload, with a length of 1, so this is equivalent to\n        // `slice::from_mut`, and thus is safe.\n        // When the `Option` is `None`, the length used is 0, so to be safe it\n        // just needs to be aligned, which it is because `&self` is aligned and\n        // the offset used is a multiple of alignment.\n        //\n        // In the new version, the intrinsic creates a `*const T` from a\n        // mutable reference  so it is safe to cast back to a mutable pointer\n        // here. As with `as_slice`, the intrinsic always returns a pointer to\n        // an in-bounds and correctly aligned position for a `T` (even if in\n        // the `None` case it's just padding).\n        unsafe {\n            slice::from_raw_parts_mut(\n                (self as *mut Self).byte_add(core::mem::offset_of!(Self, Some.0)).cast(),\n                self.len(),\n            )\n        }\n    }",
  "mir": "fn option::Option::<T>::as_mut_slice(_1: &mut option::Option<T>) -> &mut [T] {\n    let mut _0: &mut [T];\n    let mut _2: *mut T;\n    let mut _3: *mut option::Option<T>;\n    let mut _4: *mut option::Option<T>;\n    let mut _5: usize;\n    let mut _6: &option::Option<T>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &raw mut (*_1);\n        _3 = ptr::mut_ptr::<impl *mut option::Option<T>>::byte_add(move _4, option::Option::<T>::as_mut_slice::{constant#0}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = ptr::mut_ptr::<impl *mut option::Option<T>>::cast::<T>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = option::Option::<T>::len(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _0 = slice::raw::from_raw_parts_mut::<'_, T>(move _2, move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a mutable slice of the contained value, if any. If this is\n `None`, an empty slice is returned. This can be useful to have a\n single type of iterator over an `Option` or slice.\n\n Note: Should you have an `Option<&mut T>` instead of a\n `&mut Option<T>`, which this method takes, you can obtain a mutable\n slice via `opt.map_or(&mut [], std::slice::from_mut)`.\n\n # Examples\n\n ```rust\n assert_eq!(\n     [Some(1234).as_mut_slice(), None.as_mut_slice()],\n     [&mut [1234][..], &mut [][..]],\n );\n ```\n\n The result is a mutable slice of zero or one items that points into\n our original `Option`:\n\n ```rust\n let mut x = Some(1234);\n x.as_mut_slice()[0] += 1;\n assert_eq!(x, Some(1235));\n ```\n\n The inverse of this method (discounting borrowing)\n is [`[_]::first_mut`](slice::first_mut):\n\n ```rust\n assert_eq!(Some(123).as_mut_slice().first_mut(), Some(&mut 123))\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}