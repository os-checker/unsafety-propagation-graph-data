{
  "name": "hash::sip::u8to64_le",
  "safe": false,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "num::<impl u32>::to_le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts `self` to little endian from the target's endianness.\n\n On little endian this is a no-op. On big endian the bytes are\n swapped.\n\n # Examples\n\n ```\n\n if cfg!(target_endian = \"little\") {\n     assert_eq!(n.to_le(), n)\n } else {\n     assert_eq!(n.to_le(), n.swap_bytes())\n }\n ```\n",
      "adt": {}
    },
    "num::<impl u16>::to_le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts `self` to little endian from the target's endianness.\n\n On little endian this is a no-op. On big endian the bytes are\n swapped.\n\n # Examples\n\n ```\n\n if cfg!(target_endian = \"little\") {\n     assert_eq!(n.to_le(), n)\n } else {\n     assert_eq!(n.to_le(), n.swap_bytes())\n }\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice, without doing bounds\n checking.\n\n For a safe alternative see [`get`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get(index).unwrap_unchecked()`.  It's UB\n to call `.get_unchecked(len)`, even if you immediately convert to a\n pointer.  And it's UB to call `.get_unchecked(..len + 1)`,\n `.get_unchecked(..=len)`, or similar.\n\n [`get`]: slice::get\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n\n unsafe {\n     assert_eq!(x.get_unchecked(1), &2);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 13137,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hash/sip.rs:120:1: 143:2",
  "src": "unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n    debug_assert!(len < 8);\n    let mut i = 0; // current byte index (from LSB) in the output u64\n    let mut out = 0;\n    if i + 3 < len {\n        // SAFETY: `i` cannot be greater than `len`, and the caller must guarantee\n        // that the index start..start+len is in bounds.\n        out = unsafe { load_int_le!(buf, start + i, u32) } as u64;\n        i += 4;\n    }\n    if i + 1 < len {\n        // SAFETY: same as above.\n        out |= (unsafe { load_int_le!(buf, start + i, u16) } as u64) << (i * 8);\n        i += 2\n    }\n    if i < len {\n        // SAFETY: same as above.\n        out |= (unsafe { *buf.get_unchecked(start + i) } as u64) << (i * 8);\n        i += 1;\n    }\n    //FIXME(fee1-dead): use debug_assert_eq\n    debug_assert!(i == len);\n    out\n}",
  "mir": "fn hash::sip::u8to64_le(_1: &[u8], _2: usize, _3: usize) -> u64 {\n    let mut _0: u64;\n    let mut _4: bool;\n    let mut _5: !;\n    let mut _6: usize;\n    let mut _7: u64;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let mut _12: u32;\n    let mut _13: bool;\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let mut _20: usize;\n    let mut _21: !;\n    let mut _22: u32;\n    let  _23: ();\n    let mut _24: *const u8;\n    let mut _25: *const u8;\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let mut _29: *mut u8;\n    let mut _30: *mut u32;\n    let mut _31: &mut u32;\n    let mut _32: usize;\n    let mut _33: u32;\n    let mut _34: (usize, bool);\n    let mut _35: bool;\n    let mut _36: usize;\n    let mut _37: usize;\n    let mut _38: (usize, bool);\n    let mut _39: u64;\n    let mut _40: u64;\n    let mut _41: u16;\n    let mut _42: bool;\n    let mut _43: usize;\n    let mut _44: usize;\n    let mut _45: usize;\n    let mut _46: (usize, bool);\n    let mut _47: usize;\n    let mut _48: (usize, bool);\n    let mut _49: usize;\n    let mut _50: !;\n    let mut _51: u16;\n    let  _52: ();\n    let mut _53: *const u8;\n    let mut _54: *const u8;\n    let mut _55: usize;\n    let mut _56: usize;\n    let mut _57: (usize, bool);\n    let mut _58: *mut u8;\n    let mut _59: *mut u16;\n    let mut _60: &mut u16;\n    let mut _61: usize;\n    let mut _62: u16;\n    let mut _63: usize;\n    let mut _64: usize;\n    let mut _65: (usize, bool);\n    let mut _66: bool;\n    let mut _67: (usize, bool);\n    let mut _68: bool;\n    let mut _69: usize;\n    let mut _70: u64;\n    let mut _71: u64;\n    let mut _72: u8;\n    let mut _73: &u8;\n    let mut _74: usize;\n    let mut _75: usize;\n    let mut _76: (usize, bool);\n    let mut _77: usize;\n    let mut _78: usize;\n    let mut _79: (usize, bool);\n    let mut _80: bool;\n    let mut _81: (usize, bool);\n    let mut _82: bool;\n    let mut _83: usize;\n    let mut _84: !;\n    debug buf => _1;\n    debug start => _2;\n    debug len => _3;\n    debug i => _6;\n    debug out => _7;\n    debug data => _22;\n    debug data => _51;\n    bb0: {\n        StorageLive(_4);\n        _4 = Lt(_3, 8_usize);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = 0_usize;\n        StorageLive(_7);\n        _7 = 0_u64;\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _6;\n        _11 = CheckedAdd(_10, 3_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _10, 3_usize) -> [success: bb3, unwind unreachable];\n    }\n    bb2: {\n        _5 = panicking::panic(\"assertion failed: len < 8\") -> unwind unreachable;\n    }\n    bb3: {\n        _9 = move (_11.0: usize);\n        StorageDead(_10);\n        _8 = Lt(move _9, _3);\n        switchInt(move _8) -> [0: bb17, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _6;\n        _17 = CheckedAdd(_2, _16);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, move _16) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _15 = move (_17.0: usize);\n        StorageDead(_16);\n        StorageLive(_18);\n        _18 = mem::size_of::<u32>() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _19 = CheckedAdd(_15, _18);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _15, move _18) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = move (_19.0: usize);\n        StorageDead(_18);\n        StorageDead(_15);\n        StorageLive(_20);\n        _20 = PtrMetadata(_1);\n        _13 = Le(move _14, move _20);\n        switchInt(move _13) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_20);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_22);\n        _22 = 0_u32;\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = slice::<impl [u8]>::as_ptr(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_20);\n        StorageDead(_14);\n        _21 = panicking::panic(\"assertion failed: start + i + size_of::<u32>() <= buf.len()\") -> unwind unreachable;\n    }\n    bb10: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _6;\n        _28 = CheckedAdd(_2, _27);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, move _27) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _26 = move (_28.0: usize);\n        StorageDead(_27);\n        _24 = ptr::const_ptr::<impl *const u8>::add(move _25, move _26) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_29);\n        StorageLive(_31);\n        _31 = &mut _22;\n        _30 = &raw mut (*_31);\n        _29 = _30 as *mut u8;\n        StorageLive(_32);\n        _32 = mem::size_of::<u32>() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _23 = ptr::copy_nonoverlapping::<u8>(move _24, move _29, move _32) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_32);\n        StorageDead(_29);\n        StorageDead(_24);\n        StorageDead(_31);\n        StorageLive(_33);\n        _33 = _22;\n        _12 = num::<impl u32>::to_le(move _33) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_33);\n        StorageDead(_22);\n        _7 = move _12 as u64;\n        StorageDead(_12);\n        _34 = CheckedAdd(_6, 4_usize);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 4_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _6 = move (_34.0: usize);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_9);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_8);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = _6;\n        _38 = CheckedAdd(_37, 1_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _37, 1_usize) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _36 = move (_38.0: usize);\n        StorageDead(_37);\n        _35 = Lt(move _36, _3);\n        switchInt(move _35) -> [0: bb35, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_36);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = _6;\n        _46 = CheckedAdd(_2, _45);\n        assert(!move (_46.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, move _45) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _44 = move (_46.0: usize);\n        StorageDead(_45);\n        StorageLive(_47);\n        _47 = mem::size_of::<u16>() -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _48 = CheckedAdd(_44, _47);\n        assert(!move (_48.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _44, move _47) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _43 = move (_48.0: usize);\n        StorageDead(_47);\n        StorageDead(_44);\n        StorageLive(_49);\n        _49 = PtrMetadata(_1);\n        _42 = Le(move _43, move _49);\n        switchInt(move _42) -> [0: bb25, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_49);\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageLive(_51);\n        _51 = 0_u16;\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = slice::<impl [u8]>::as_ptr(_1) -> [return: bb26, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_49);\n        StorageDead(_43);\n        _50 = panicking::panic(\"assertion failed: start + i + size_of::<u16>() <= buf.len()\") -> unwind unreachable;\n    }\n    bb26: {\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = _6;\n        _57 = CheckedAdd(_2, _56);\n        assert(!move (_57.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, move _56) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _55 = move (_57.0: usize);\n        StorageDead(_56);\n        _53 = ptr::const_ptr::<impl *const u8>::add(move _54, move _55) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageLive(_58);\n        StorageLive(_60);\n        _60 = &mut _51;\n        _59 = &raw mut (*_60);\n        _58 = _59 as *mut u8;\n        StorageLive(_61);\n        _61 = mem::size_of::<u16>() -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _52 = ptr::copy_nonoverlapping::<u8>(move _53, move _58, move _61) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_61);\n        StorageDead(_58);\n        StorageDead(_53);\n        StorageDead(_60);\n        StorageLive(_62);\n        _62 = _51;\n        _41 = num::<impl u16>::to_le(move _62) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_62);\n        StorageDead(_51);\n        _40 = move _41 as u64;\n        StorageDead(_41);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _6;\n        _65 = CheckedMul(_64, 8_usize);\n        assert(!move (_65.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _64, 8_usize) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _63 = move (_65.0: usize);\n        StorageDead(_64);\n        _66 = Lt(_63, 64_usize);\n        assert(move _66, \"attempt to shift left by `{}`, which would overflow\", _63) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _39 = Shl(move _40, move _63);\n        StorageDead(_63);\n        StorageDead(_40);\n        _7 = BitOr(_7, move _39);\n        StorageDead(_39);\n        _67 = CheckedAdd(_6, 2_usize);\n        assert(!move (_67.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 2_usize) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _6 = move (_67.0: usize);\n        goto -> bb36;\n    }\n    bb35: {\n        StorageDead(_36);\n        goto -> bb36;\n    }\n    bb36: {\n        StorageDead(_35);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = _6;\n        _68 = Lt(move _69, _3);\n        switchInt(move _68) -> [0: bb43, otherwise: bb37];\n    }\n    bb37: {\n        StorageDead(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        StorageLive(_75);\n        _75 = _6;\n        _76 = CheckedAdd(_2, _75);\n        assert(!move (_76.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, move _75) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        _74 = move (_76.0: usize);\n        StorageDead(_75);\n        _73 = slice::<impl [u8]>::get_unchecked::<usize>(_1, move _74) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_74);\n        _72 = (*_73);\n        StorageDead(_73);\n        _71 = move _72 as u64;\n        StorageDead(_72);\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = _6;\n        _79 = CheckedMul(_78, 8_usize);\n        assert(!move (_79.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _78, 8_usize) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _77 = move (_79.0: usize);\n        StorageDead(_78);\n        _80 = Lt(_77, 64_usize);\n        assert(move _80, \"attempt to shift left by `{}`, which would overflow\", _77) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _70 = Shl(move _71, move _77);\n        StorageDead(_77);\n        StorageDead(_71);\n        _7 = BitOr(_7, move _70);\n        StorageDead(_70);\n        _81 = CheckedAdd(_6, 1_usize);\n        assert(!move (_81.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, 1_usize) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _6 = move (_81.0: usize);\n        goto -> bb44;\n    }\n    bb43: {\n        StorageDead(_69);\n        goto -> bb44;\n    }\n    bb44: {\n        StorageDead(_68);\n        StorageLive(_82);\n        StorageLive(_83);\n        _83 = _6;\n        _82 = Eq(move _83, _3);\n        switchInt(move _82) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_83);\n        StorageDead(_82);\n        _0 = _7;\n        StorageDead(_7);\n        StorageDead(_6);\n        return;\n    }\n    bb46: {\n        StorageDead(_83);\n        _84 = panicking::panic(\"assertion failed: i == len\") -> unwind unreachable;\n    }\n}\n",
  "doc": " Loads a u64 using up to 7 bytes of a byte slice. It looks clumsy but the\n `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed\n sizes and avoid calling `memcpy`, which is good for speed.\n\n Safety: this performs unchecked indexing of `buf` at `start..start+len`, so\n that must be in-bounds.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}