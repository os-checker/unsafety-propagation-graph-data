{
  "name": "slice::<impl [T]>::get_disjoint_mut",
  "safe": true,
  "callees": {
    "slice::get_disjoint_check_valid": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This checks every index against each other, and against `len`.\n\n This will do `binomial(N + 1, 2) = N * (N + 1) / 2 = 0, 1, 3, 6, 10, ..`\n comparison operations.\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::get_disjoint_unchecked_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns mutable references to many indices at once, without doing any checks.\n\n An index can be either a `usize`, a [`Range`] or a [`RangeInclusive`]. Note\n that this method takes an array, so all indices must be of the same type.\n If passed an array of `usize`s this method gives back an array of mutable references\n to single elements, while if passed an array of ranges it gives back an array of\n mutable references to slices.\n\n For a safe alternative see [`get_disjoint_mut`].\n\n # Safety\n\n Calling this method with overlapping or out-of-bounds indices is *[undefined behavior]*\n even if the resulting references are not used.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n\n unsafe {\n     let [a, b] = x.get_disjoint_unchecked_mut([0, 2]);\n     *a *= 10;\n     *b *= 100;\n }\n assert_eq!(x, &[10, 2, 400]);\n\n unsafe {\n     let [a, b] = x.get_disjoint_unchecked_mut([0..1, 1..3]);\n     a[0] = 8;\n     b[0] = 88;\n     b[1] = 888;\n }\n assert_eq!(x, &[8, 88, 888]);\n\n unsafe {\n     let [a, b] = x.get_disjoint_unchecked_mut([1..=2, 0..=0]);\n     a[0] = 11;\n     a[1] = 111;\n     b[0] = 1;\n }\n assert_eq!(x, &[1, 11, 111]);\n ```\n\n [`get_disjoint_mut`]: slice::get_disjoint_mut\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14074, kind: RigidTy(Adt(AdtDef(DefId { id: 24645, name: \"result::Result\" }), GenericArgs([Type(Ty { id: 487, kind: RigidTy(Adt(AdtDef(DefId { id: 24781, name: \"convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 14075, kind: RigidTy(Adt(AdtDef(DefId { id: 29000, name: \"slice::GetDisjointMutError\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::get_disjoint_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4781:5: 4792:6",
  "src": "pub fn get_disjoint_mut<I, const N: usize>(\n        &mut self,\n        indices: [I; N],\n    ) -> Result<[&mut I::Output; N], GetDisjointMutError>\n    where\n        I: GetDisjointMutIndex + SliceIndex<Self>,\n    {\n        get_disjoint_check_valid(&indices, self.len())?;\n        // SAFETY: The `get_disjoint_check_valid()` call checked that all indices\n        // are disjunct and in bounds.\n        unsafe { Ok(self.get_disjoint_unchecked_mut(indices)) }\n    }",
  "mir": "fn slice::<impl [T]>::get_disjoint_mut(_1: &mut [T], _2: [I; N]) -> result::Result<[&mut <I as slice::index::SliceIndex<[T]>>::Output; N], slice::GetDisjointMutError> {\n    let mut _0: result::Result<[&mut <I as slice::index::SliceIndex<[T]>>::Output; N], slice::GetDisjointMutError>;\n    let mut _3: ops::control_flow::ControlFlow<result::Result<convert::Infallible, slice::GetDisjointMutError>>;\n    let mut _4: result::Result<(), slice::GetDisjointMutError>;\n    let  _5: &[I; N];\n    let mut _6: usize;\n    let mut _7: &[T];\n    let mut _8: isize;\n    let  _9: result::Result<convert::Infallible, slice::GetDisjointMutError>;\n    let mut _10: [&mut <I as slice::index::SliceIndex<[T]>>::Output; N];\n    let mut _11: [I; N];\n    debug self => _1;\n    debug indices => _2;\n    debug residual => _9;\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = &_2;\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        _4 = slice::get_disjoint_check_valid::<I, N>(_5, move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _3 = <result::Result<(), slice::GetDisjointMutError> as ops::try_trait::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _8 = discriminant(_3);\n        switchInt(move _8) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = move _2;\n        _10 = slice::<impl [T]>::get_disjoint_unchecked_mut::<I, N>(_1, move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _9 = move ((_3 as variant#1).0: result::Result<convert::Infallible, slice::GetDisjointMutError>);\n        _0 = <result::Result<[&mut <I as slice::index::SliceIndex<[T]>>::Output; N], slice::GetDisjointMutError> as ops::try_trait::FromResidual<result::Result<convert::Infallible, slice::GetDisjointMutError>>>::from_residual(_9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _0 = result::Result::Ok(move _10);\n        StorageDead(_10);\n        goto -> bb8;\n    }\n    bb8: {\n        return;\n    }\n}\n",
  "doc": " Returns mutable references to many indices at once.\n\n An index can be either a `usize`, a [`Range`] or a [`RangeInclusive`]. Note\n that this method takes an array, so all indices must be of the same type.\n If passed an array of `usize`s this method gives back an array of mutable references\n to single elements, while if passed an array of ranges it gives back an array of\n mutable references to slices.\n\n Returns an error if any index is out-of-bounds, or if there are overlapping indices.\n An empty range is not considered to overlap if it is located at the beginning or at\n the end of another range, but is considered to overlap if it is located in the middle.\n\n This method does a O(n^2) check to check that there are no overlapping indices, so be careful\n when passing many indices.\n\n # Examples\n\n ```\n let v = &mut [1, 2, 3];\n if let Ok([a, b]) = v.get_disjoint_mut([0, 2]) {\n     *a = 413;\n     *b = 612;\n }\n assert_eq!(v, &[413, 2, 612]);\n\n if let Ok([a, b]) = v.get_disjoint_mut([0..1, 1..3]) {\n     a[0] = 8;\n     b[0] = 88;\n     b[1] = 888;\n }\n assert_eq!(v, &[8, 88, 888]);\n\n if let Ok([a, b]) = v.get_disjoint_mut([1..=2, 0..=0]) {\n     a[0] = 11;\n     a[1] = 111;\n     b[0] = 1;\n }\n assert_eq!(v, &[1, 11, 111]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}