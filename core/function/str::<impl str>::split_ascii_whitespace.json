{
  "name": "str::<impl str>::split_ascii_whitespace",
  "safe": true,
  "callees": {
    "str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over subslices separated by elements that match\n `pred`. The matched element is not contained in the subslices.\n\n # Examples\n\n ```\n let slice = [10, 40, 33, 20];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10, 40]);\n assert_eq!(iter.next().unwrap(), &[20]);\n assert!(iter.next().is_none());\n ```\n\n If the first element is matched, an empty slice will be the first item\n returned by the iterator. Similarly, if the last element in the slice\n is matched, an empty slice will be the last item returned by the\n iterator:\n\n ```\n let slice = [10, 40, 33];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10, 40]);\n assert_eq!(iter.next().unwrap(), &[]);\n assert!(iter.next().is_none());\n ```\n\n If two matched elements are directly adjacent, an empty slice will be\n present between them:\n\n ```\n let slice = [10, 6, 33, 20];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10]);\n assert_eq!(iter.next().unwrap(), &[]);\n assert_eq!(iter.next().unwrap(), &[20]);\n assert!(iter.next().is_none());\n ```\n",
      "adt": {
        "slice::iter::Split": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::filter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which uses a closure to determine if an element\n should be yielded.\n\n Given an element the closure must return `true` or `false`. The returned\n iterator will yield only the elements for which the closure returns\n `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0i32, 1, 2];\n\n let mut iter = a.into_iter().filter(|x| x.is_positive());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `filter()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|x| **x > 1); // needs two *s!\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n It's common to instead use destructuring on the argument to strip away one:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&x| *x > 1); // both & and *\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n or both:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&&x| x > 1); // two &s\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n of these layers.\n\n Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n",
      "adt": {
        "iter::adapters::filter::Filter": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {
        "iter::adapters::map::Map": "Constructor"
      }
    }
  },
  "adts": {
    "slice::iter::Split": [
      "Plain"
    ],
    "iter::adapters::filter::Filter": [
      "Plain"
    ],
    "iter::adapters::map::Map": [
      "Plain"
    ],
    "str::iter::SplitAsciiWhitespace": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::str::<impl str>::split_ascii_whitespace"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:1233:5: 1237:6",
  "src": "pub fn split_ascii_whitespace(&self) -> SplitAsciiWhitespace<'_> {\n        let inner =\n            self.as_bytes().split(IsAsciiWhitespace).filter(BytesIsNotEmpty).map(UnsafeBytesToStr);\n        SplitAsciiWhitespace { inner }\n    }",
  "mir": "fn str::<impl str>::split_ascii_whitespace(_1: &str) -> str::iter::SplitAsciiWhitespace<'_> {\n    let mut _0: str::iter::SplitAsciiWhitespace<'_>;\n    let  _2: iter::adapters::map::Map<iter::adapters::filter::Filter<slice::iter::Split<'_, u8, str::IsAsciiWhitespace>, str::BytesIsNotEmpty>, str::UnsafeBytesToStr>;\n    let mut _3: iter::adapters::filter::Filter<slice::iter::Split<'_, u8, str::IsAsciiWhitespace>, str::BytesIsNotEmpty>;\n    let mut _4: slice::iter::Split<'_, u8, str::IsAsciiWhitespace>;\n    let  _5: &[u8];\n    debug self => _1;\n    debug inner => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = str::<impl str>::as_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = slice::<impl [u8]>::split::<str::IsAsciiWhitespace>(_5, str::IsAsciiWhitespace) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = <slice::iter::Split<'_, u8, str::IsAsciiWhitespace> as iter::traits::iterator::Iterator>::filter::<str::BytesIsNotEmpty>(move _4, str::BytesIsNotEmpty) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _2 = <iter::adapters::filter::Filter<slice::iter::Split<'_, u8, str::IsAsciiWhitespace>, str::BytesIsNotEmpty> as iter::traits::iterator::Iterator>::map::<&str, str::UnsafeBytesToStr>(move _3, str::UnsafeBytesToStr) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = SplitAsciiWhitespace(_2);\n        return;\n    }\n}\n",
  "doc": " Splits a string slice by ASCII whitespace.\n\n The iterator returned will return string slices that are sub-slices of\n the original string slice, separated by any amount of ASCII whitespace.\n\n This uses the same definition as [`char::is_ascii_whitespace`].\n To split by Unicode `Whitespace` instead, use [`split_whitespace`].\n\n [`split_whitespace`]: str::split_whitespace\n\n # Examples\n\n Basic usage:\n\n ```\n let mut iter = \"A few words\".split_ascii_whitespace();\n\n assert_eq!(Some(\"A\"), iter.next());\n assert_eq!(Some(\"few\"), iter.next());\n assert_eq!(Some(\"words\"), iter.next());\n\n assert_eq!(None, iter.next());\n ```\n\n Various kinds of ASCII whitespace are considered\n (see [`char::is_ascii_whitespace`]):\n\n ```\n let mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_ascii_whitespace();\n assert_eq!(Some(\"Mary\"), iter.next());\n assert_eq!(Some(\"had\"), iter.next());\n assert_eq!(Some(\"a\"), iter.next());\n assert_eq!(Some(\"little\"), iter.next());\n assert_eq!(Some(\"lamb\"), iter.next());\n\n assert_eq!(None, iter.next());\n ```\n\n If the string is empty or all ASCII whitespace, the iterator yields no string slices:\n ```\n assert_eq!(\"\".split_ascii_whitespace().next(), None);\n assert_eq!(\"   \".split_ascii_whitespace().next(), None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}