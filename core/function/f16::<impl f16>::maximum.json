{
  "name": "f16::<impl f16>::maximum",
  "safe": true,
  "callees": {
    "intrinsics::maximumf16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the maximum of two `f16` values, propagating NaN.\n\n This behaves like IEEE 754-2019 maximum. In particular:\n If one of the arguments is NaN, then a NaN is returned using the usual NaN propagation rules.\n For this operation, -0.0 is considered to be strictly less than +0.0.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::f16::<impl f16>::maximum"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f16.rs:776:5: 778:6",
  "src": "pub const fn maximum(self, other: f16) -> f16 {\n        intrinsics::maximumf16(self, other)\n    }",
  "mir": "fn f16::<impl f16>::maximum(_1: f16, _2: f16) -> f16 {\n    let mut _0: f16;\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        _0 = intrinsics::maximumf16(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Returns the maximum of the two numbers, propagating NaN.\n\n If at least one of the arguments is NaN, the return value is NaN, with the bit pattern\n picked using the usual [rules for arithmetic operations](f32#nan-bit-patterns). Furthermore,\n `-0.0` is considered to be less than `+0.0`, making this function fully deterministic for\n non-NaN inputs.\n\n This is in contrast to [`f16::max`] which only returns NaN when *both* arguments are NaN,\n and which does not reliably order `-0.0` and `+0.0`.\n\n This follows the IEEE 754-2019 semantics for `maximum`.\n\n ```\n #![feature(f16)]\n #![feature(float_minimum_maximum)]\n # #[cfg(target_arch = \"aarch64\")] { // FIXME(f16_F128): rust-lang/rust#123885\n\n let x = 1.0f16;\n let y = 2.0f16;\n\n assert_eq!(x.maximum(y), y);\n assert!(x.maximum(f16::NAN).is_nan());\n # }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}