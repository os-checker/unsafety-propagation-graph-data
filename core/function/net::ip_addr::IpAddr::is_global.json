{
  "name": "net::ip_addr::IpAddr::is_global",
  "safe": true,
  "callees": {
    "net::ip_addr::Ipv6Addr::is_global": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns [`true`] if the address appears to be globally reachable\n as specified by the [IANA IPv6 Special-Purpose Address Registry].\n\n Whether or not an address is practically reachable will depend on your\n network configuration. Most IPv6 addresses are globally reachable, unless\n they are specifically defined as *not* globally reachable.\n\n Non-exhaustive list of notable addresses that are not globally reachable:\n - The [unspecified address] ([`is_unspecified`](Ipv6Addr::is_unspecified))\n - The [loopback address] ([`is_loopback`](Ipv6Addr::is_loopback))\n - IPv4-mapped addresses\n - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv6Addr::is_benchmarking))\n - Addresses reserved for documentation ([`is_documentation`](Ipv6Addr::is_documentation))\n - Unique local addresses ([`is_unique_local`](Ipv6Addr::is_unique_local))\n - Unicast addresses with link-local scope ([`is_unicast_link_local`](Ipv6Addr::is_unicast_link_local))\n\n For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv6 Special-Purpose Address Registry].\n\n Note that an address having global scope is not the same as being globally reachable,\n and there is no direct relation between the two concepts: There exist addresses with global scope\n that are not globally reachable (for example unique local addresses),\n and addresses that are globally reachable without having global scope\n (multicast addresses with non-global scope).\n\n [IANA IPv6 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv6-special-registry/iana-ipv6-special-registry.xhtml\n [unspecified address]: Ipv6Addr::UNSPECIFIED\n [loopback address]: Ipv6Addr::LOCALHOST\n\n # Examples\n\n ```\n #![feature(ip)]\n\n use std::net::Ipv6Addr;\n\n // Most IPv6 addresses are globally reachable:\n assert_eq!(Ipv6Addr::new(0x26, 0, 0x1c9, 0, 0, 0xafc8, 0x10, 0x1).is_global(), true);\n\n // However some addresses have been assigned a special meaning\n // that makes them not globally reachable. Some examples are:\n\n // The unspecified address (`::`)\n assert_eq!(Ipv6Addr::UNSPECIFIED.is_global(), false);\n\n // The loopback address (`::1`)\n assert_eq!(Ipv6Addr::LOCALHOST.is_global(), false);\n\n // IPv4-mapped addresses (`::ffff:0:0/96`)\n assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc00a, 0x2ff).is_global(), false);\n\n // Addresses reserved for benchmarking (`2001:2::/48`)\n assert_eq!(Ipv6Addr::new(0x2001, 2, 0, 0, 0, 0, 0, 1,).is_global(), false);\n\n // Addresses reserved for documentation (`2001:db8::/32` and `3fff::/20`)\n assert_eq!(Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 1).is_global(), false);\n assert_eq!(Ipv6Addr::new(0x3fff, 0, 0, 0, 0, 0, 0, 0).is_global(), false);\n\n // Unique local addresses (`fc00::/7`)\n assert_eq!(Ipv6Addr::new(0xfc02, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n\n // Unicast addresses with link-local scope (`fe80::/10`)\n assert_eq!(Ipv6Addr::new(0xfe81, 0, 0, 0, 0, 0, 0, 1).is_global(), false);\n\n // For a complete overview see the IANA IPv6 Special-Purpose Address Registry.\n ```\n",
      "adt": {
        "net::ip_addr::Ipv6Addr": "ImmutableAsArgument"
      }
    },
    "net::ip_addr::Ipv4Addr::is_global": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns [`true`] if the address appears to be globally reachable\n as specified by the [IANA IPv4 Special-Purpose Address Registry].\n\n Whether or not an address is practically reachable will depend on your\n network configuration. Most IPv4 addresses are globally reachable, unless\n they are specifically defined as *not* globally reachable.\n\n Non-exhaustive list of notable addresses that are not globally reachable:\n\n - The [unspecified address] ([`is_unspecified`](Ipv4Addr::is_unspecified))\n - Addresses reserved for private use ([`is_private`](Ipv4Addr::is_private))\n - Addresses in the shared address space ([`is_shared`](Ipv4Addr::is_shared))\n - Loopback addresses ([`is_loopback`](Ipv4Addr::is_loopback))\n - Link-local addresses ([`is_link_local`](Ipv4Addr::is_link_local))\n - Addresses reserved for documentation ([`is_documentation`](Ipv4Addr::is_documentation))\n - Addresses reserved for benchmarking ([`is_benchmarking`](Ipv4Addr::is_benchmarking))\n - Reserved addresses ([`is_reserved`](Ipv4Addr::is_reserved))\n - The [broadcast address] ([`is_broadcast`](Ipv4Addr::is_broadcast))\n\n For the complete overview of which addresses are globally reachable, see the table at the [IANA IPv4 Special-Purpose Address Registry].\n\n [IANA IPv4 Special-Purpose Address Registry]: https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml\n [unspecified address]: Ipv4Addr::UNSPECIFIED\n [broadcast address]: Ipv4Addr::BROADCAST\n\n # Examples\n\n ```\n #![feature(ip)]\n\n use std::net::Ipv4Addr;\n\n // Most IPv4 addresses are globally reachable:\n assert_eq!(Ipv4Addr::new(80, 9, 12, 3).is_global(), true);\n\n // However some addresses have been assigned a special meaning\n // that makes them not globally reachable. Some examples are:\n\n // The unspecified address (`0.0.0.0`)\n assert_eq!(Ipv4Addr::UNSPECIFIED.is_global(), false);\n\n // Addresses reserved for private use (`10.0.0.0/8`, `172.16.0.0/12`, 192.168.0.0/16)\n assert_eq!(Ipv4Addr::new(10, 254, 0, 0).is_global(), false);\n assert_eq!(Ipv4Addr::new(192, 168, 10, 65).is_global(), false);\n assert_eq!(Ipv4Addr::new(172, 16, 10, 65).is_global(), false);\n\n // Addresses in the shared address space (`100.64.0.0/10`)\n assert_eq!(Ipv4Addr::new(100, 100, 0, 0).is_global(), false);\n\n // The loopback addresses (`127.0.0.0/8`)\n assert_eq!(Ipv4Addr::LOCALHOST.is_global(), false);\n\n // Link-local addresses (`169.254.0.0/16`)\n assert_eq!(Ipv4Addr::new(169, 254, 45, 1).is_global(), false);\n\n // Addresses reserved for documentation (`192.0.2.0/24`, `198.51.100.0/24`, `203.0.113.0/24`)\n assert_eq!(Ipv4Addr::new(192, 0, 2, 255).is_global(), false);\n assert_eq!(Ipv4Addr::new(198, 51, 100, 65).is_global(), false);\n assert_eq!(Ipv4Addr::new(203, 0, 113, 6).is_global(), false);\n\n // Addresses reserved for benchmarking (`198.18.0.0/15`)\n assert_eq!(Ipv4Addr::new(198, 18, 0, 0).is_global(), false);\n\n // Reserved addresses (`240.0.0.0/4`)\n assert_eq!(Ipv4Addr::new(250, 10, 20, 30).is_global(), false);\n\n // The broadcast address (`255.255.255.255`)\n assert_eq!(Ipv4Addr::BROADCAST.is_global(), false);\n\n // For a complete overview see the IANA IPv4 Special-Purpose Address Registry.\n ```\n",
      "adt": {
        "net::ip_addr::Ipv4Addr": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "net::ip_addr::IpAddr": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8198, kind: RigidTy(Adt(AdtDef(DefId { id: 26934, name: \"net::ip_addr::Ipv6Addr\" }), GenericArgs([]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8184, kind: RigidTy(Adt(AdtDef(DefId { id: 26930, name: \"net::ip_addr::Ipv4Addr\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "net::ip_addr::Ipv6Addr": [
      "Ref"
    ],
    "net::ip_addr::Ipv4Addr": [
      "Ref"
    ]
  },
  "path": 14596,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/net/ip_addr.rs:302:5: 307:6",
  "src": "pub const fn is_global(&self) -> bool {\n        match self {\n            IpAddr::V4(ip) => ip.is_global(),\n            IpAddr::V6(ip) => ip.is_global(),\n        }\n    }",
  "mir": "fn net::ip_addr::IpAddr::is_global(_1: &net::ip_addr::IpAddr) -> bool {\n    let mut _0: bool;\n    let mut _2: isize;\n    let  _3: &net::ip_addr::Ipv4Addr;\n    let  _4: &net::ip_addr::Ipv6Addr;\n    debug self => _1;\n    debug ip => _3;\n    debug ip => _4;\n    bb0: {\n        _2 = discriminant((*_1));\n        switchInt(move _2) -> [0: bb3, 1: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _4 = &(((*_1) as variant#1).0: net::ip_addr::Ipv6Addr);\n        _0 = net::ip_addr::Ipv6Addr::is_global(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb3: {\n        _3 = &(((*_1) as variant#0).0: net::ip_addr::Ipv4Addr);\n        _0 = net::ip_addr::Ipv4Addr::is_global(_3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        goto -> bb6;\n    }\n    bb5: {\n        goto -> bb6;\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Returns [`true`] if the address appears to be globally routable.\n\n See the documentation for [`Ipv4Addr::is_global()`] and\n [`Ipv6Addr::is_global()`] for more details.\n\n # Examples\n\n ```\n #![feature(ip)]\n\n use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n\n assert_eq!(IpAddr::V4(Ipv4Addr::new(80, 9, 12, 3)).is_global(), true);\n assert_eq!(IpAddr::V6(Ipv6Addr::new(0, 0, 0x1c9, 0, 0, 0xafc8, 0, 0x1)).is_global(), true);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}