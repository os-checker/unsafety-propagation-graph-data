{
  "name": "num::flt2dec::strategy::dragon::format_shortest",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::<impl u64>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {
        "option::Option": "MutableAsArgument"
      }
    },
    "num::<impl u64>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::flt2dec::estimator::estimate_scaling_factor": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.\n\n This is used to approximate `k = ceil(log_10 (mant * 2^exp))`;\n the true `k` is either `k_0` or `k_0+1`.\n",
      "adt": {}
    },
    "num::bignum::Big32x40::from_u64": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a bignum from `u64` value.\n",
      "adt": {
        "num::bignum::Big32x40": "Constructor"
      }
    },
    "num::bignum::Big32x40::from_small": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a bignum from one digit.\n",
      "adt": {
        "num::bignum::Big32x40": "Constructor"
      }
    },
    "num::bignum::Big32x40::mul_pow2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiplies itself by `2^bits` and returns its own mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "num::flt2dec::strategy::dragon::mul_pow10": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": "",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "num::bignum::Big32x40::add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds `other` to itself and returns its own mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "cmp::Ord::cmp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This method returns an [`Ordering`] between `self` and `other`.\n\n By convention, `self.cmp(&other)` returns the ordering matching the expression\n `self <operator> other` if true.\n\n # Examples\n\n ```\n use std::cmp::Ordering;\n\n assert_eq!(5.cmp(&10), Ordering::Less);\n assert_eq!(10.cmp(&5), Ordering::Greater);\n assert_eq!(5.cmp(&5), Ordering::Equal);\n ```\n",
      "adt": {}
    },
    "cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    },
    "num::bignum::Big32x40::mul_small": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiplies itself by a digit-sized `other` and returns its own\n mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "num::flt2dec::strategy::dragon::div_rem_upto_16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "cmp::PartialOrd::ge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests greater than or equal to (for `self` and `other`) and is used by\n the `>=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 >= 1.0, true);\n assert_eq!(1.0 >= 2.0, false);\n assert_eq!(2.0 >= 1.0, true);\n ```\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable (unique) reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in the\n slice really is in an initialized state. For instance, `.assume_init_mut()` cannot\n be used to initialize a `MaybeUninit` slice.\n",
      "adt": {}
    },
    "num::flt2dec::round_up": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " When `d` contains decimal digits, increase the last digit and propagate carry.\n Returns a next digit when it causes the length to change.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::flt2dec::decoder::Decoded": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 46, kind: RigidTy(Uint(U8)) })])"
    ],
    "cmp::Ordering": [
      "Plain",
      "Ref"
    ],
    "num::bignum::Big32x40": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref",
      "MutRefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::strategy::dragon::format_shortest"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/strategy/dragon.rs:102:1: 259:2",
  "src": "pub fn format_shortest<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    // the number `v` to format is known to be:\n    // - equal to `mant * 2^exp`;\n    // - preceded by `(mant - 2 * minus) * 2^exp` in the original type; and\n    // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n    //\n    // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n    // also we assume that at least one digit is generated, i.e., `mant` cannot be zero too.\n    //\n    // this also means that any number between `low = (mant - minus) * 2^exp` and\n    // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n    // with bounds included when the original mantissa was even (i.e., `!mant_was_odd`).\n\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n\n    // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n    let rounding = if d.inclusive { Ordering::Greater } else { Ordering::Equal };\n\n    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n    // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n    let mut k = estimate_scaling_factor(d.mant + d.plus, d.exp);\n\n    // convert `{mant, plus, minus} * 2^exp` into the fractional form so that:\n    // - `v = mant / scale`\n    // - `low = (mant - minus) / scale`\n    // - `high = (mant + plus) / scale`\n    let mut mant = Big::from_u64(d.mant);\n    let mut minus = Big::from_u64(d.minus);\n    let mut plus = Big::from_u64(d.plus);\n    let mut scale = Big::from_small(1);\n    if d.exp < 0 {\n        scale.mul_pow2(-d.exp as usize);\n    } else {\n        mant.mul_pow2(d.exp as usize);\n        minus.mul_pow2(d.exp as usize);\n        plus.mul_pow2(d.exp as usize);\n    }\n\n    // divide `mant` by `10^k`. now `scale / 10 < mant + plus <= scale * 10`.\n    if k >= 0 {\n        mul_pow10(&mut scale, k as usize);\n    } else {\n        mul_pow10(&mut mant, -k as usize);\n        mul_pow10(&mut minus, -k as usize);\n        mul_pow10(&mut plus, -k as usize);\n    }\n\n    // fixup when `mant + plus > scale` (or `>=`).\n    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n    // now `scale < mant + plus <= scale * 10` and we are ready to generate digits.\n    //\n    // note that `d[0]` *can* be zero, when `scale - plus < mant < scale`.\n    // in this case rounding-up condition (`up` below) will be triggered immediately.\n    if scale.cmp(mant.clone().add(&plus)) < rounding {\n        // equivalent to scaling `scale` by 10\n        k += 1;\n    } else {\n        mant.mul_small(10);\n        minus.mul_small(10);\n        plus.mul_small(10);\n    }\n\n    // cache `(2, 4, 8) * scale` for digit generation.\n    let mut scale2 = scale.clone();\n    scale2.mul_pow2(1);\n    let mut scale4 = scale.clone();\n    scale4.mul_pow2(2);\n    let mut scale8 = scale.clone();\n    scale8.mul_pow2(3);\n\n    let mut down;\n    let mut up;\n    let mut i = 0;\n    loop {\n        // invariants, where `d[0..n-1]` are digits generated so far:\n        // - `v = mant / scale * 10^(k-n-1) + d[0..n-1] * 10^(k-n)`\n        // - `v - low = minus / scale * 10^(k-n-1)`\n        // - `high - v = plus / scale * 10^(k-n-1)`\n        // - `(mant + plus) / scale <= 10` (thus `mant / scale < 10`)\n        // where `d[i..j]` is a shorthand for `d[i] * 10^(j-i) + ... + d[j-1] * 10 + d[j]`.\n\n        // generate one digit: `d[n] = floor(mant / scale) < 10`.\n        let (d, _) = div_rem_upto_16(&mut mant, &scale, &scale2, &scale4, &scale8);\n        debug_assert!(d < 10);\n        buf[i] = MaybeUninit::new(b'0' + d);\n        i += 1;\n\n        // this is a simplified description of the modified Dragon algorithm.\n        // many intermediate derivations and completeness arguments are omitted for convenience.\n        //\n        // start with modified invariants, as we've updated `n`:\n        // - `v = mant / scale * 10^(k-n) + d[0..n-1] * 10^(k-n)`\n        // - `v - low = minus / scale * 10^(k-n)`\n        // - `high - v = plus / scale * 10^(k-n)`\n        //\n        // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n        // i.e., `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n        // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n        // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n        //\n        // the second condition simplifies to `2 * mant <= scale`.\n        // solving invariants in terms of `mant`, `low` and `high` yields\n        // a simpler version of the first condition: `-plus < mant < minus`.\n        // since `-plus < 0 <= mant`, we have the correct shortest representation\n        // when `mant < minus` and `2 * mant <= scale`.\n        // (the former becomes `mant <= minus` when the original mantissa is even.)\n        //\n        // when the second doesn't hold (`2 * mant > scale`), we need to increase the last digit.\n        // this is enough for restoring that condition: we already know that\n        // the digit generation guarantees `0 <= v / 10^(k-n) - d[0..n-1] < 1`.\n        // in this case, the first condition becomes `-plus < mant - scale < minus`.\n        // since `mant < scale` after the generation, we have `scale < mant + plus`.\n        // (again, this becomes `scale <= mant + plus` when the original mantissa is even.)\n        //\n        // in short:\n        // - stop and round `down` (keep digits as is) when `mant < minus` (or `<=`).\n        // - stop and round `up` (increase the last digit) when `scale < mant + plus` (or `<=`).\n        // - keep generating otherwise.\n        down = mant.cmp(&minus) < rounding;\n        up = scale.cmp(mant.clone().add(&plus)) < rounding;\n        if down || up {\n            break;\n        } // we have the shortest representation, proceed to the rounding\n\n        // restore the invariants.\n        // this makes the algorithm always terminating: `minus` and `plus` always increases,\n        // but `mant` is clipped modulo `scale` and `scale` is fixed.\n        mant.mul_small(10);\n        minus.mul_small(10);\n        plus.mul_small(10);\n    }\n\n    // rounding up happens when\n    // i) only the rounding-up condition was triggered, or\n    // ii) both conditions were triggered and tie breaking prefers rounding up.\n    if up && (!down || *mant.mul_pow2(1) >= scale) {\n        // if rounding up changes the length, the exponent should also change.\n        // it seems that this condition is very hard to satisfy (possibly impossible),\n        // but we are just being safe and consistent here.\n        // SAFETY: we initialized that memory above.\n        if let Some(c) = round_up(unsafe { buf[..i].assume_init_mut() }) {\n            buf[i] = MaybeUninit::new(c);\n            i += 1;\n            k += 1;\n        }\n    }\n\n    // SAFETY: we initialized that memory above.\n    (unsafe { buf[..i].assume_init_ref() }, k)\n}",
  "mir": "fn num::flt2dec::strategy::dragon::format_shortest(_1: &num::flt2dec::decoder::Decoded, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>]) -> (&[u8], i16) {\n    let mut _0: (&[u8], i16);\n    let mut _3: bool;\n    let mut _4: u64;\n    let mut _5: !;\n    let mut _6: bool;\n    let mut _7: u64;\n    let mut _8: !;\n    let mut _9: bool;\n    let mut _10: u64;\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: &option::Option<u64>;\n    let  _14: option::Option<u64>;\n    let mut _15: u64;\n    let mut _16: u64;\n    let mut _17: !;\n    let mut _18: bool;\n    let mut _19: &option::Option<u64>;\n    let  _20: option::Option<u64>;\n    let mut _21: u64;\n    let mut _22: u64;\n    let mut _23: !;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _27: !;\n    let  _28: cmp::Ordering;\n    let mut _29: bool;\n    let mut _30: i16;\n    let mut _31: u64;\n    let mut _32: u64;\n    let mut _33: u64;\n    let mut _34: (u64, bool);\n    let mut _35: i16;\n    let mut _36: num::bignum::Big32x40;\n    let mut _37: u64;\n    let mut _38: num::bignum::Big32x40;\n    let mut _39: u64;\n    let mut _40: num::bignum::Big32x40;\n    let mut _41: u64;\n    let mut _42: num::bignum::Big32x40;\n    let mut _43: bool;\n    let mut _44: i16;\n    let  _45: &mut num::bignum::Big32x40;\n    let mut _46: &mut num::bignum::Big32x40;\n    let mut _47: usize;\n    let mut _48: i16;\n    let mut _49: i16;\n    let mut _50: bool;\n    let  _51: &mut num::bignum::Big32x40;\n    let mut _52: &mut num::bignum::Big32x40;\n    let mut _53: usize;\n    let mut _54: i16;\n    let  _55: &mut num::bignum::Big32x40;\n    let mut _56: &mut num::bignum::Big32x40;\n    let mut _57: usize;\n    let mut _58: i16;\n    let  _59: &mut num::bignum::Big32x40;\n    let mut _60: &mut num::bignum::Big32x40;\n    let mut _61: usize;\n    let mut _62: i16;\n    let mut _63: bool;\n    let mut _64: i16;\n    let  _65: &mut num::bignum::Big32x40;\n    let mut _66: &mut num::bignum::Big32x40;\n    let mut _67: usize;\n    let mut _68: i16;\n    let  _69: &mut num::bignum::Big32x40;\n    let mut _70: &mut num::bignum::Big32x40;\n    let mut _71: usize;\n    let mut _72: i16;\n    let mut _73: i16;\n    let mut _74: bool;\n    let  _75: &mut num::bignum::Big32x40;\n    let mut _76: &mut num::bignum::Big32x40;\n    let mut _77: usize;\n    let mut _78: i16;\n    let mut _79: i16;\n    let mut _80: bool;\n    let  _81: &mut num::bignum::Big32x40;\n    let mut _82: &mut num::bignum::Big32x40;\n    let mut _83: usize;\n    let mut _84: i16;\n    let mut _85: i16;\n    let mut _86: bool;\n    let mut _87: bool;\n    let mut _88: &cmp::Ordering;\n    let  _89: cmp::Ordering;\n    let mut _90: &num::bignum::Big32x40;\n    let mut _91: &num::bignum::Big32x40;\n    let  _92: &mut num::bignum::Big32x40;\n    let mut _93: &mut num::bignum::Big32x40;\n    let mut _94: num::bignum::Big32x40;\n    let mut _95: &num::bignum::Big32x40;\n    let  _96: &num::bignum::Big32x40;\n    let mut _97: &cmp::Ordering;\n    let mut _98: (i16, bool);\n    let  _99: &mut num::bignum::Big32x40;\n    let mut _100: &mut num::bignum::Big32x40;\n    let  _101: &mut num::bignum::Big32x40;\n    let mut _102: &mut num::bignum::Big32x40;\n    let  _103: &mut num::bignum::Big32x40;\n    let mut _104: &mut num::bignum::Big32x40;\n    let mut _105: num::bignum::Big32x40;\n    let mut _106: &num::bignum::Big32x40;\n    let  _107: &mut num::bignum::Big32x40;\n    let mut _108: &mut num::bignum::Big32x40;\n    let mut _109: num::bignum::Big32x40;\n    let mut _110: &num::bignum::Big32x40;\n    let  _111: &mut num::bignum::Big32x40;\n    let mut _112: &mut num::bignum::Big32x40;\n    let mut _113: num::bignum::Big32x40;\n    let mut _114: &num::bignum::Big32x40;\n    let  _115: &mut num::bignum::Big32x40;\n    let mut _116: &mut num::bignum::Big32x40;\n    let mut _117: usize;\n    let  _118: u8;\n    let mut _119: (u8, &mut num::bignum::Big32x40);\n    let mut _120: &mut num::bignum::Big32x40;\n    let  _121: &num::bignum::Big32x40;\n    let  _122: &num::bignum::Big32x40;\n    let  _123: &num::bignum::Big32x40;\n    let  _124: &num::bignum::Big32x40;\n    let mut _125: bool;\n    let mut _126: !;\n    let mut _127: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _128: u8;\n    let mut _129: (u8, bool);\n    let  _130: usize;\n    let mut _131: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _132: usize;\n    let mut _133: bool;\n    let mut _134: (usize, bool);\n    let mut _135: bool;\n    let mut _136: &cmp::Ordering;\n    let  _137: cmp::Ordering;\n    let mut _138: &num::bignum::Big32x40;\n    let  _139: &num::bignum::Big32x40;\n    let mut _140: &cmp::Ordering;\n    let mut _141: bool;\n    let mut _142: &cmp::Ordering;\n    let  _143: cmp::Ordering;\n    let mut _144: &num::bignum::Big32x40;\n    let mut _145: &num::bignum::Big32x40;\n    let  _146: &mut num::bignum::Big32x40;\n    let mut _147: &mut num::bignum::Big32x40;\n    let mut _148: num::bignum::Big32x40;\n    let mut _149: &num::bignum::Big32x40;\n    let  _150: &num::bignum::Big32x40;\n    let mut _151: &cmp::Ordering;\n    let  _152: &mut num::bignum::Big32x40;\n    let mut _153: &mut num::bignum::Big32x40;\n    let  _154: &mut num::bignum::Big32x40;\n    let mut _155: &mut num::bignum::Big32x40;\n    let  _156: &mut num::bignum::Big32x40;\n    let mut _157: &mut num::bignum::Big32x40;\n    let mut _158: bool;\n    let mut _159: &num::bignum::Big32x40;\n    let  _160: &mut num::bignum::Big32x40;\n    let mut _161: &mut num::bignum::Big32x40;\n    let mut _162: &num::bignum::Big32x40;\n    let mut _163: option::Option<u8>;\n    let mut _164: &mut [u8];\n    let mut _165: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _166: ops::range::RangeTo<usize>;\n    let mut _167: usize;\n    let mut _168: isize;\n    let  _169: u8;\n    let mut _170: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _171: usize;\n    let mut _172: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _173: usize;\n    let mut _174: bool;\n    let mut _175: (usize, bool);\n    let mut _176: (i16, bool);\n    let  _177: &[u8];\n    let  _178: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _179: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _180: ops::range::RangeTo<usize>;\n    let mut _181: usize;\n    let mut _182: i16;\n    debug d => _1;\n    debug buf => _2;\n    debug rounding => _28;\n    debug k => _30;\n    debug mant => _36;\n    debug minus => _38;\n    debug plus => _40;\n    debug scale => _42;\n    debug scale2 => _105;\n    debug scale4 => _109;\n    debug scale8 => _113;\n    debug down => _135;\n    debug up => _141;\n    debug i => _117;\n    debug d => _118;\n    debug c => _169;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).0: u64);\n        _3 = Gt(move _4, 0_u64);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = ((*_1).1: u64);\n        _6 = Gt(move _7, 0_u64);\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = panicking::panic(\"assertion failed: d.mant > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).2: u64);\n        _9 = Gt(move _10, 0_u64);\n        switchInt(move _9) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_7);\n        _8 = panicking::panic(\"assertion failed: d.minus > 0\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = ((*_1).0: u64);\n        StorageLive(_16);\n        _16 = ((*_1).2: u64);\n        _14 = num::<impl u64>::checked_add(move _15, move _16) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _11 = panicking::panic(\"assertion failed: d.plus > 0\") -> unwind unreachable;\n    }\n    bb7: {\n        _13 = &_14;\n        StorageDead(_16);\n        StorageDead(_15);\n        _12 = option::Option::<u64>::is_some(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _12) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = ((*_1).0: u64);\n        StorageLive(_22);\n        _22 = ((*_1).1: u64);\n        _20 = num::<impl u64>::checked_sub(move _21, move _22) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_14);\n        _17 = panicking::panic(\"assertion failed: d.mant.checked_add(d.plus).is_some()\") -> unwind unreachable;\n    }\n    bb11: {\n        _19 = &_20;\n        StorageDead(_22);\n        StorageDead(_21);\n        _18 = option::Option::<u64>::is_some(move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _18) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_2);\n        _25 = PtrMetadata(move _26);\n        StorageDead(_26);\n        _24 = Ge(move _25, num::flt2dec::MAX_SIG_DIGITS);\n        switchInt(move _24) -> [0: bb16, otherwise: bb15];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_20);\n        _23 = panicking::panic(\"assertion failed: d.mant.checked_sub(d.minus).is_some()\") -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = ((*_1).4: bool);\n        switchInt(move _29) -> [0: bb18, otherwise: bb17];\n    }\n    bb16: {\n        StorageDead(_25);\n        _27 = panicking::panic(\"assertion failed: buf.len() >= MAX_SIG_DIGITS\") -> unwind unreachable;\n    }\n    bb17: {\n        _28 = cmp::Ordering::Greater;\n        goto -> bb19;\n    }\n    bb18: {\n        _28 = cmp::Ordering::Equal;\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = ((*_1).0: u64);\n        StorageLive(_33);\n        _33 = ((*_1).2: u64);\n        _34 = CheckedAdd(_32, _33);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _32, move _33) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _31 = move (_34.0: u64);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_35);\n        _35 = ((*_1).3: i16);\n        _30 = num::flt2dec::estimator::estimate_scaling_factor(move _31, move _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_35);\n        StorageDead(_31);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = ((*_1).0: u64);\n        _36 = num::bignum::Big32x40::from_u64(move _37) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = ((*_1).1: u64);\n        _38 = num::bignum::Big32x40::from_u64(move _39) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = ((*_1).2: u64);\n        _40 = num::bignum::Big32x40::from_u64(move _41) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_41);\n        StorageLive(_42);\n        _42 = num::bignum::Big32x40::from_small(1_u32) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = ((*_1).3: i16);\n        _43 = Lt(move _44, 0_i16);\n        switchInt(move _43) -> [0: bb29, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &mut _42;\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = ((*_1).3: i16);\n        _50 = Eq(_49, i16::MIN);\n        assert(!move _50, \"attempt to negate `{}`, which would overflow\", _49) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _48 = Neg(move _49);\n        StorageDead(_49);\n        _47 = move _48 as usize;\n        StorageDead(_48);\n        _45 = num::bignum::Big32x40::mul_pow2(move _46, move _47) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageDead(_45);\n        goto -> bb33;\n    }\n    bb29: {\n        StorageDead(_44);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &mut _36;\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = ((*_1).3: i16);\n        _53 = move _54 as usize;\n        StorageDead(_54);\n        _51 = num::bignum::Big32x40::mul_pow2(move _52, move _53) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageDead(_51);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = &mut _38;\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = ((*_1).3: i16);\n        _57 = move _58 as usize;\n        StorageDead(_58);\n        _55 = num::bignum::Big32x40::mul_pow2(move _56, move _57) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &mut _40;\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = ((*_1).3: i16);\n        _61 = move _62 as usize;\n        StorageDead(_62);\n        _59 = num::bignum::Big32x40::mul_pow2(move _60, move _61) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_61);\n        StorageDead(_60);\n        StorageDead(_59);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_43);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _30;\n        _63 = Ge(move _64, 0_i16);\n        switchInt(move _63) -> [0: bb36, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_64);\n        StorageLive(_65);\n        _66 = &mut _42;\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = _30;\n        _67 = move _68 as usize;\n        StorageDead(_68);\n        _65 = num::flt2dec::strategy::dragon::mul_pow10(_66, move _67) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_67);\n        StorageDead(_65);\n        goto -> bb43;\n    }\n    bb36: {\n        StorageDead(_64);\n        StorageLive(_69);\n        _70 = &mut _36;\n        StorageLive(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        _73 = _30;\n        _74 = Eq(_73, i16::MIN);\n        assert(!move _74, \"attempt to negate `{}`, which would overflow\", _73) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _72 = Neg(move _73);\n        StorageDead(_73);\n        _71 = move _72 as usize;\n        StorageDead(_72);\n        _69 = num::flt2dec::strategy::dragon::mul_pow10(_70, move _71) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_71);\n        StorageDead(_69);\n        StorageLive(_75);\n        _76 = &mut _38;\n        StorageLive(_77);\n        StorageLive(_78);\n        StorageLive(_79);\n        _79 = _30;\n        _80 = Eq(_79, i16::MIN);\n        assert(!move _80, \"attempt to negate `{}`, which would overflow\", _79) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _78 = Neg(move _79);\n        StorageDead(_79);\n        _77 = move _78 as usize;\n        StorageDead(_78);\n        _75 = num::flt2dec::strategy::dragon::mul_pow10(_76, move _77) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_77);\n        StorageDead(_75);\n        StorageLive(_81);\n        _82 = &mut _40;\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = _30;\n        _86 = Eq(_85, i16::MIN);\n        assert(!move _86, \"attempt to negate `{}`, which would overflow\", _85) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _84 = Neg(move _85);\n        StorageDead(_85);\n        _83 = move _84 as usize;\n        StorageDead(_84);\n        _81 = num::flt2dec::strategy::dragon::mul_pow10(_82, move _83) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_83);\n        StorageDead(_81);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageDead(_63);\n        StorageLive(_87);\n        StorageLive(_88);\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = &_42;\n        StorageLive(_91);\n        StorageLive(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = &_36;\n        _94 = <num::bignum::Big32x40 as clone::Clone>::clone(move _95) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _93 = &mut _94;\n        StorageDead(_95);\n        _96 = &_40;\n        _92 = num::bignum::Big32x40::add(move _93, _96) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        _91 = &(*_92);\n        StorageDead(_93);\n        _89 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _90, move _91) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _88 = &_89;\n        StorageDead(_91);\n        StorageDead(_90);\n        StorageLive(_97);\n        _97 = &_28;\n        _87 = <cmp::Ordering as cmp::PartialOrd>::lt(move _88, move _97) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        switchInt(move _87) -> [0: bb50, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_97);\n        StorageDead(_94);\n        StorageDead(_92);\n        StorageDead(_89);\n        StorageDead(_88);\n        _98 = CheckedAdd(_30, 1_i16);\n        assert(!move (_98.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _30, 1_i16) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _30 = move (_98.0: i16);\n        goto -> bb54;\n    }\n    bb50: {\n        StorageDead(_97);\n        StorageDead(_94);\n        StorageDead(_92);\n        StorageDead(_89);\n        StorageDead(_88);\n        StorageLive(_99);\n        StorageLive(_100);\n        _100 = &mut _36;\n        _99 = num::bignum::Big32x40::mul_small(move _100, 10_u32) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_100);\n        StorageDead(_99);\n        StorageLive(_101);\n        StorageLive(_102);\n        _102 = &mut _38;\n        _101 = num::bignum::Big32x40::mul_small(move _102, 10_u32) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_102);\n        StorageDead(_101);\n        StorageLive(_103);\n        StorageLive(_104);\n        _104 = &mut _40;\n        _103 = num::bignum::Big32x40::mul_small(move _104, 10_u32) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_104);\n        StorageDead(_103);\n        goto -> bb54;\n    }\n    bb54: {\n        StorageDead(_87);\n        StorageLive(_105);\n        StorageLive(_106);\n        _106 = &_42;\n        _105 = <num::bignum::Big32x40 as clone::Clone>::clone(move _106) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_106);\n        StorageLive(_107);\n        StorageLive(_108);\n        _108 = &mut _105;\n        _107 = num::bignum::Big32x40::mul_pow2(move _108, 1_usize) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_108);\n        StorageDead(_107);\n        StorageLive(_109);\n        StorageLive(_110);\n        _110 = &_42;\n        _109 = <num::bignum::Big32x40 as clone::Clone>::clone(move _110) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_110);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = &mut _109;\n        _111 = num::bignum::Big32x40::mul_pow2(move _112, 2_usize) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_112);\n        StorageDead(_111);\n        StorageLive(_113);\n        StorageLive(_114);\n        _114 = &_42;\n        _113 = <num::bignum::Big32x40 as clone::Clone>::clone(move _114) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_114);\n        StorageLive(_115);\n        StorageLive(_116);\n        _116 = &mut _113;\n        _115 = num::bignum::Big32x40::mul_pow2(move _116, 3_usize) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_116);\n        StorageDead(_115);\n        StorageLive(_117);\n        _117 = 0_usize;\n        goto -> bb61;\n    }\n    bb61: {\n        StorageLive(_119);\n        _120 = &mut _36;\n        _121 = &_42;\n        _122 = &_105;\n        _123 = &_109;\n        _124 = &_113;\n        _119 = num::flt2dec::strategy::dragon::div_rem_upto_16(_120, _121, _122, _123, _124) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        _118 = (_119.0: u8);\n        StorageDead(_119);\n        StorageLive(_125);\n        _125 = Lt(_118, 10_u8);\n        switchInt(move _125) -> [0: bb64, otherwise: bb63];\n    }\n    bb63: {\n        StorageDead(_125);\n        StorageLive(_127);\n        StorageLive(_128);\n        _129 = CheckedAdd(48_u8, _118);\n        assert(!move (_129.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, _118) -> [success: bb65, unwind unreachable];\n    }\n    bb64: {\n        _126 = panicking::panic(\"assertion failed: d < 10\") -> unwind unreachable;\n    }\n    bb65: {\n        _128 = move (_129.0: u8);\n        _127 = mem::maybe_uninit::MaybeUninit::<u8>::new(move _128) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_128);\n        StorageLive(_130);\n        _130 = _117;\n        _131 = &raw const (fake) (*_2);\n        _132 = PtrMetadata(move _131);\n        _133 = Lt(_130, _132);\n        assert(move _133, \"index out of bounds: the length is {} but the index is {}\", move _132, _130) -> [success: bb67, unwind unreachable];\n    }\n    bb67: {\n        (*_2)[_130] = move _127;\n        StorageDead(_127);\n        StorageDead(_130);\n        _134 = CheckedAdd(_117, 1_usize);\n        assert(!move (_134.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _117, 1_usize) -> [success: bb68, unwind unreachable];\n    }\n    bb68: {\n        _117 = move (_134.0: usize);\n        StorageLive(_136);\n        StorageLive(_137);\n        StorageLive(_138);\n        _138 = &_36;\n        _139 = &_38;\n        _137 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _138, _139) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        _136 = &_137;\n        StorageDead(_138);\n        StorageLive(_140);\n        _140 = &_28;\n        _135 = <cmp::Ordering as cmp::PartialOrd>::lt(move _136, move _140) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_140);\n        StorageDead(_136);\n        StorageDead(_137);\n        StorageLive(_142);\n        StorageLive(_143);\n        StorageLive(_144);\n        _144 = &_42;\n        StorageLive(_145);\n        StorageLive(_146);\n        StorageLive(_147);\n        StorageLive(_148);\n        StorageLive(_149);\n        _149 = &_36;\n        _148 = <num::bignum::Big32x40 as clone::Clone>::clone(move _149) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        _147 = &mut _148;\n        StorageDead(_149);\n        _150 = &_40;\n        _146 = num::bignum::Big32x40::add(move _147, _150) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        _145 = &(*_146);\n        StorageDead(_147);\n        _143 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _144, move _145) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        _142 = &_143;\n        StorageDead(_145);\n        StorageDead(_144);\n        StorageLive(_151);\n        _151 = &_28;\n        _141 = <cmp::Ordering as cmp::PartialOrd>::lt(move _142, move _151) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_151);\n        StorageDead(_142);\n        StorageDead(_148);\n        StorageDead(_146);\n        StorageDead(_143);\n        switchInt(_135) -> [0: bb75, otherwise: bb76];\n    }\n    bb75: {\n        switchInt(_141) -> [0: bb77, otherwise: bb76];\n    }\n    bb76: {\n        switchInt(_141) -> [0: bb97, otherwise: bb81];\n    }\n    bb77: {\n        StorageLive(_152);\n        StorageLive(_153);\n        _153 = &mut _36;\n        _152 = num::bignum::Big32x40::mul_small(move _153, 10_u32) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        StorageDead(_153);\n        StorageDead(_152);\n        StorageLive(_154);\n        StorageLive(_155);\n        _155 = &mut _38;\n        _154 = num::bignum::Big32x40::mul_small(move _155, 10_u32) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_155);\n        StorageDead(_154);\n        StorageLive(_156);\n        StorageLive(_157);\n        _157 = &mut _40;\n        _156 = num::bignum::Big32x40::mul_small(move _157, 10_u32) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_157);\n        StorageDead(_156);\n        goto -> bb61;\n    }\n    bb81: {\n        switchInt(_135) -> [0: bb86, otherwise: bb82];\n    }\n    bb82: {\n        StorageLive(_158);\n        StorageLive(_159);\n        StorageLive(_160);\n        StorageLive(_161);\n        _161 = &mut _36;\n        _160 = num::bignum::Big32x40::mul_pow2(move _161, 1_usize) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        StorageDead(_161);\n        _159 = &(*_160);\n        StorageLive(_162);\n        _162 = &_42;\n        _158 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _159, move _162) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        switchInt(move _158) -> [0: bb96, otherwise: bb85];\n    }\n    bb85: {\n        StorageDead(_162);\n        StorageDead(_160);\n        StorageDead(_159);\n        goto -> bb86;\n    }\n    bb86: {\n        StorageLive(_163);\n        StorageLive(_166);\n        StorageLive(_167);\n        _167 = _117;\n        _166 = RangeTo(move _167);\n        StorageDead(_167);\n        _165 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_2, move _166) -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        StorageDead(_166);\n        _164 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_165) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        _163 = num::flt2dec::round_up(_164) -> [return: bb89, unwind unreachable];\n    }\n    bb89: {\n        _168 = discriminant(_163);\n        switchInt(move _168) -> [1: bb90, 0: bb95, otherwise: bb100];\n    }\n    bb90: {\n        _169 = ((_163 as variant#1).0: u8);\n        StorageLive(_170);\n        _170 = mem::maybe_uninit::MaybeUninit::<u8>::new(_169) -> [return: bb91, unwind unreachable];\n    }\n    bb91: {\n        StorageLive(_171);\n        _171 = _117;\n        _172 = &raw const (fake) (*_2);\n        _173 = PtrMetadata(move _172);\n        _174 = Lt(_171, _173);\n        assert(move _174, \"index out of bounds: the length is {} but the index is {}\", move _173, _171) -> [success: bb92, unwind unreachable];\n    }\n    bb92: {\n        (*_2)[_171] = move _170;\n        StorageDead(_170);\n        StorageDead(_171);\n        _175 = CheckedAdd(_117, 1_usize);\n        assert(!move (_175.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _117, 1_usize) -> [success: bb93, unwind unreachable];\n    }\n    bb93: {\n        _117 = move (_175.0: usize);\n        _176 = CheckedAdd(_30, 1_i16);\n        assert(!move (_176.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _30, 1_i16) -> [success: bb94, unwind unreachable];\n    }\n    bb94: {\n        _30 = move (_176.0: i16);\n        StorageDead(_163);\n        goto -> bb97;\n    }\n    bb95: {\n        StorageDead(_163);\n        goto -> bb97;\n    }\n    bb96: {\n        StorageDead(_162);\n        StorageDead(_160);\n        StorageDead(_159);\n        goto -> bb97;\n    }\n    bb97: {\n        StorageDead(_158);\n        StorageLive(_179);\n        _179 = &(*_2);\n        StorageLive(_180);\n        StorageLive(_181);\n        _181 = _117;\n        _180 = RangeTo(move _181);\n        StorageDead(_181);\n        _178 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _179, move _180) -> [return: bb98, unwind unreachable];\n    }\n    bb98: {\n        StorageDead(_180);\n        StorageDead(_179);\n        _177 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_178) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        StorageLive(_182);\n        _182 = _30;\n        _0 = (_177, move _182);\n        StorageDead(_182);\n        StorageDead(_117);\n        StorageDead(_113);\n        StorageDead(_109);\n        StorageDead(_105);\n        StorageDead(_42);\n        StorageDead(_40);\n        StorageDead(_38);\n        StorageDead(_36);\n        StorageDead(_30);\n        StorageDead(_28);\n        return;\n    }\n    bb100: {\n        unreachable;\n    }\n}\n",
  "doc": " The shortest mode implementation for Dragon.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}