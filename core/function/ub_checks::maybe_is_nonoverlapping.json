{
  "name": "ub_checks::maybe_is_nonoverlapping",
  "safe": true,
  "callees": {
    "ub_checks::maybe_is_nonoverlapping::runtime": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::ub_checks::maybe_is_nonoverlapping"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs:160:1: 185:2",
  "src": "pub(crate) const fn maybe_is_nonoverlapping(\n    src: *const (),\n    dst: *const (),\n    size: usize,\n    count: usize,\n) -> bool {\n    // This is just for safety checks so we can const_eval_select.\n    const_eval_select!(\n        @capture { src: *const (), dst: *const (), size: usize, count: usize } -> bool:\n        if const {\n            true\n        } else {\n            let src_usize = src.addr();\n            let dst_usize = dst.addr();\n            let Some(size) = size.checked_mul(count) else {\n                crate::panicking::panic_nounwind(\n                    \"is_nonoverlapping: `size_of::<T>() * count` overflows a usize\",\n                )\n            };\n            let diff = src_usize.abs_diff(dst_usize);\n            // If the absolute distance between the ptrs is at least as big as the size of the buffer,\n            // they do not overlap.\n            diff >= size\n        }\n    )\n}",
  "mir": "fn ub_checks::maybe_is_nonoverlapping(_1: *const (), _2: *const (), _3: usize, _4: usize) -> bool {\n    let mut _0: bool;\n    let mut _5: (*const (), *const (), usize, usize);\n    debug src => _1;\n    debug dst => _2;\n    debug size => _3;\n    debug count => _4;\n    bb0: {\n        StorageLive(_5);\n        _5 = (_1, _2, _3, _4);\n        _0 = ub_checks::maybe_is_nonoverlapping::runtime(move (_5.0: *const ()), move (_5.1: *const ()), move (_5.2: usize), move (_5.3: usize)) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Checks whether the regions of memory starting at `src` and `dst` of size\n `count * size` do *not* overlap.\n\n Note that in const-eval this function just returns `true` and therefore must\n only be used with `assert_unsafe_precondition!`, similar to `is_aligned_and_not_null`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}