{
  "name": "str::validations::run_utf8_validation",
  "safe": true,
  "callees": {
    "str::validations::run_utf8_validation::runtime": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "str::validations::utf8_char_width": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given a first byte, determines how many bytes are in this UTF-8 character.\n",
      "adt": {}
    },
    "num::<impl usize>::wrapping_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) subtraction. Computes `self - rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl usize>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "str::validations::contains_nonascii": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if any byte in the word `x` is nonascii (>= 128).\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ],
    "str::error::Utf8Error": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::str::validations::run_utf8_validation"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs:126:1: 251:2",
  "src": "pub(super) const fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n    let mut index = 0;\n    let len = v.len();\n\n    const USIZE_BYTES: usize = size_of::<usize>();\n\n    let ascii_block_size = 2 * USIZE_BYTES;\n    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n    // Below, we safely fall back to a slower codepath if the offset is `usize::MAX`,\n    // so the end-to-end behavior is the same at compiletime and runtime.\n    let align = const_eval_select!(\n        @capture { v: &[u8] } -> usize:\n        if const {\n            usize::MAX\n        } else {\n            v.as_ptr().align_offset(USIZE_BYTES)\n        }\n    );\n\n    while index < len {\n        let old_offset = index;\n        macro_rules! err {\n            ($error_len: expr) => {\n                return Err(Utf8Error { valid_up_to: old_offset, error_len: $error_len })\n            };\n        }\n\n        macro_rules! next {\n            () => {{\n                index += 1;\n                // we needed data, but there was none: error!\n                if index >= len {\n                    err!(None)\n                }\n                v[index]\n            }};\n        }\n\n        let first = v[index];\n        if first >= 128 {\n            let w = utf8_char_width(first);\n            // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n            //        first  C2 80        last DF BF\n            // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n            //        first  E0 A0 80     last EF BF BF\n            //   excluding surrogates codepoints  \\u{d800} to  \\u{dfff}\n            //               ED A0 80 to       ED BF BF\n            // 4-byte encoding is for codepoints \\u{10000} to \\u{10ffff}\n            //        first  F0 90 80 80  last F4 8F BF BF\n            //\n            // Use the UTF-8 syntax from the RFC\n            //\n            // https://tools.ietf.org/html/rfc3629\n            // UTF8-1      = %x00-7F\n            // UTF8-2      = %xC2-DF UTF8-tail\n            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n            //               %xF4 %x80-8F 2( UTF8-tail )\n            match w {\n                2 => {\n                    if next!() as i8 >= -64 {\n                        err!(Some(1))\n                    }\n                }\n                3 => {\n                    match (first, next!()) {\n                        (0xE0, 0xA0..=0xBF)\n                        | (0xE1..=0xEC, 0x80..=0xBF)\n                        | (0xED, 0x80..=0x9F)\n                        | (0xEE..=0xEF, 0x80..=0xBF) => {}\n                        _ => err!(Some(1)),\n                    }\n                    if next!() as i8 >= -64 {\n                        err!(Some(2))\n                    }\n                }\n                4 => {\n                    match (first, next!()) {\n                        (0xF0, 0x90..=0xBF) | (0xF1..=0xF3, 0x80..=0xBF) | (0xF4, 0x80..=0x8F) => {}\n                        _ => err!(Some(1)),\n                    }\n                    if next!() as i8 >= -64 {\n                        err!(Some(2))\n                    }\n                    if next!() as i8 >= -64 {\n                        err!(Some(3))\n                    }\n                }\n                _ => err!(Some(1)),\n            }\n            index += 1;\n        } else {\n            // Ascii case, try to skip forward quickly.\n            // When the pointer is aligned, read 2 words of data per iteration\n            // until we find a word containing a non-ascii byte.\n            if align != usize::MAX && align.wrapping_sub(index).is_multiple_of(USIZE_BYTES) {\n                let ptr = v.as_ptr();\n                while index < blocks_end {\n                    // SAFETY: since `align - index` and `ascii_block_size` are\n                    // multiples of `USIZE_BYTES`, `block = ptr.add(index)` is\n                    // always aligned with a `usize` so it's safe to dereference\n                    // both `block` and `block.add(1)`.\n                    unsafe {\n                        let block = ptr.add(index) as *const usize;\n                        // break if there is a nonascii byte\n                        let zu = contains_nonascii(*block);\n                        let zv = contains_nonascii(*block.add(1));\n                        if zu || zv {\n                            break;\n                        }\n                    }\n                    index += ascii_block_size;\n                }\n                // step from the point where the wordwise loop stopped\n                while index < len && v[index] < 128 {\n                    index += 1;\n                }\n            } else {\n                index += 1;\n            }\n        }\n    }\n\n    Ok(())\n}",
  "mir": "fn str::validations::run_utf8_validation(_1: &[u8]) -> result::Result<(), str::error::Utf8Error> {\n    let mut _0: result::Result<(), str::error::Utf8Error>;\n    let mut _2: usize;\n    let  _3: usize;\n    let  _4: usize;\n    let mut _5: (usize, bool);\n    let  _6: usize;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: (usize, bool);\n    let mut _10: (usize, bool);\n    let  _11: usize;\n    let mut _12: (&[u8],);\n    let mut _13: bool;\n    let mut _14: usize;\n    let  _15: usize;\n    let  _16: u8;\n    let  _17: usize;\n    let mut _18: usize;\n    let mut _19: bool;\n    let mut _20: bool;\n    let  _21: usize;\n    let mut _22: bool;\n    let mut _23: i8;\n    let mut _24: u8;\n    let mut _25: (usize, bool);\n    let mut _26: bool;\n    let mut _27: usize;\n    let mut _28: str::error::Utf8Error;\n    let mut _29: option::Option<u8>;\n    let  _30: usize;\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: str::error::Utf8Error;\n    let mut _34: option::Option<u8>;\n    let mut _35: (u8, u8);\n    let mut _36: u8;\n    let mut _37: (usize, bool);\n    let mut _38: bool;\n    let mut _39: usize;\n    let mut _40: str::error::Utf8Error;\n    let mut _41: option::Option<u8>;\n    let  _42: usize;\n    let mut _43: usize;\n    let mut _44: bool;\n    let mut _45: bool;\n    let mut _46: bool;\n    let mut _47: bool;\n    let mut _48: bool;\n    let mut _49: bool;\n    let mut _50: bool;\n    let mut _51: bool;\n    let mut _52: bool;\n    let mut _53: bool;\n    let mut _54: bool;\n    let mut _55: bool;\n    let mut _56: bool;\n    let mut _57: str::error::Utf8Error;\n    let mut _58: option::Option<u8>;\n    let mut _59: bool;\n    let mut _60: i8;\n    let mut _61: u8;\n    let mut _62: (usize, bool);\n    let mut _63: bool;\n    let mut _64: usize;\n    let mut _65: str::error::Utf8Error;\n    let mut _66: option::Option<u8>;\n    let  _67: usize;\n    let mut _68: usize;\n    let mut _69: bool;\n    let mut _70: str::error::Utf8Error;\n    let mut _71: option::Option<u8>;\n    let mut _72: (u8, u8);\n    let mut _73: u8;\n    let mut _74: (usize, bool);\n    let mut _75: bool;\n    let mut _76: usize;\n    let mut _77: str::error::Utf8Error;\n    let mut _78: option::Option<u8>;\n    let  _79: usize;\n    let mut _80: usize;\n    let mut _81: bool;\n    let mut _82: bool;\n    let mut _83: bool;\n    let mut _84: bool;\n    let mut _85: bool;\n    let mut _86: bool;\n    let mut _87: bool;\n    let mut _88: bool;\n    let mut _89: bool;\n    let mut _90: str::error::Utf8Error;\n    let mut _91: option::Option<u8>;\n    let mut _92: bool;\n    let mut _93: i8;\n    let mut _94: u8;\n    let mut _95: (usize, bool);\n    let mut _96: bool;\n    let mut _97: usize;\n    let mut _98: str::error::Utf8Error;\n    let mut _99: option::Option<u8>;\n    let  _100: usize;\n    let mut _101: usize;\n    let mut _102: bool;\n    let mut _103: str::error::Utf8Error;\n    let mut _104: option::Option<u8>;\n    let mut _105: bool;\n    let mut _106: i8;\n    let mut _107: u8;\n    let mut _108: (usize, bool);\n    let mut _109: bool;\n    let mut _110: usize;\n    let mut _111: str::error::Utf8Error;\n    let mut _112: option::Option<u8>;\n    let  _113: usize;\n    let mut _114: usize;\n    let mut _115: bool;\n    let mut _116: str::error::Utf8Error;\n    let mut _117: option::Option<u8>;\n    let mut _118: str::error::Utf8Error;\n    let mut _119: option::Option<u8>;\n    let mut _120: (usize, bool);\n    let mut _121: bool;\n    let mut _122: bool;\n    let mut _123: usize;\n    let mut _124: usize;\n    let  _125: *const u8;\n    let mut _126: bool;\n    let mut _127: usize;\n    let mut _128: usize;\n    let  _129: *const usize;\n    let mut _130: *const u8;\n    let mut _131: usize;\n    let  _132: bool;\n    let mut _133: usize;\n    let  _134: bool;\n    let mut _135: usize;\n    let mut _136: *const usize;\n    let mut _137: (usize, bool);\n    let mut _138: bool;\n    let mut _139: usize;\n    let mut _140: bool;\n    let mut _141: u8;\n    let  _142: usize;\n    let mut _143: usize;\n    let mut _144: bool;\n    let mut _145: (usize, bool);\n    let mut _146: (usize, bool);\n    debug v => _1;\n    debug index => _2;\n    debug len => _3;\n    debug ascii_block_size => _4;\n    debug blocks_end => _6;\n    debug align => _11;\n    debug old_offset => _15;\n    debug first => _16;\n    debug w => _21;\n    debug ptr => _125;\n    debug block => _129;\n    debug zu => _132;\n    debug zv => _134;\n    bb0: {\n        StorageLive(_2);\n        _2 = 0_usize;\n        _3 = PtrMetadata(_1);\n        _5 = CheckedMul(2_usize, str::validations::run_utf8_validation::USIZE_BYTES);\n        assert(!move (_5.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, str::validations::run_utf8_validation::USIZE_BYTES) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = move (_5.0: usize);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = Ge(_3, _4);\n        switchInt(move _7) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_8);\n        _9 = CheckedSub(_3, _4);\n        assert(!move (_9.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _4) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = move (_9.0: usize);\n        _10 = CheckedAdd(_8, 1_usize);\n        assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _8, 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = move (_10.0: usize);\n        StorageDead(_8);\n        goto -> bb6;\n    }\n    bb5: {\n        _6 = 0_usize;\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageLive(_12);\n        _12 = (_1);\n        _11 = str::validations::run_utf8_validation::runtime(move (_12.0: &[u8])) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _2;\n        _13 = Lt(move _14, _3);\n        switchInt(move _13) -> [0: bb107, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        _15 = _2;\n        StorageLive(_17);\n        _17 = _2;\n        _18 = PtrMetadata(_1);\n        _19 = Lt(_17, _18);\n        assert(move _19, \"index out of bounds: the length is {} but the index is {}\", move _18, _17) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _16 = (*_1)[_17];\n        StorageDead(_17);\n        StorageLive(_20);\n        _20 = Ge(_16, 128_u8);\n        switchInt(move _20) -> [0: bb75, otherwise: bb11];\n    }\n    bb11: {\n        StorageLive(_21);\n        _21 = str::validations::utf8_char_width(_16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(_21) -> [2: bb16, 3: bb15, 4: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageLive(_118);\n        StorageLive(_119);\n        _119 = option::Option::Some(1_u8);\n        _118 = Utf8Error(_15, move _119);\n        StorageDead(_119);\n        _0 = result::Result::Err(move _118);\n        StorageDead(_118);\n        goto -> bb114;\n    }\n    bb14: {\n        StorageLive(_72);\n        StorageLive(_73);\n        _74 = CheckedAdd(_2, 1_usize);\n        assert(!move (_74.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb47, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_35);\n        StorageLive(_36);\n        _37 = CheckedAdd(_2, 1_usize);\n        assert(!move (_37.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb23, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _25 = CheckedAdd(_2, 1_usize);\n        assert(!move (_25.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _2 = move (_25.0: usize);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _2;\n        _26 = Ge(move _27, _3);\n        switchInt(move _26) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = option::Option::None;\n        _28 = Utf8Error(_15, move _29);\n        StorageDead(_29);\n        _0 = result::Result::Err(move _28);\n        StorageDead(_28);\n        StorageDead(_26);\n        StorageDead(_24);\n        StorageDead(_23);\n        goto -> bb113;\n    }\n    bb19: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_30);\n        _30 = _2;\n        _31 = PtrMetadata(_1);\n        _32 = Lt(_30, _31);\n        assert(move _32, \"index out of bounds: the length is {} but the index is {}\", move _31, _30) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _24 = (*_1)[_30];\n        StorageDead(_30);\n        _23 = move _24 as i8;\n        StorageDead(_24);\n        _22 = Ge(move _23, -64_i8);\n        switchInt(move _22) -> [0: bb22, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_23);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = option::Option::Some(1_u8);\n        _33 = Utf8Error(_15, move _34);\n        StorageDead(_34);\n        _0 = result::Result::Err(move _33);\n        StorageDead(_33);\n        goto -> bb113;\n    }\n    bb22: {\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb73;\n    }\n    bb23: {\n        _2 = move (_37.0: usize);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = _2;\n        _38 = Ge(move _39, _3);\n        switchInt(move _38) -> [0: bb25, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = option::Option::None;\n        _40 = Utf8Error(_15, move _41);\n        StorageDead(_41);\n        _0 = result::Result::Err(move _40);\n        StorageDead(_40);\n        StorageDead(_38);\n        StorageDead(_36);\n        goto -> bb112;\n    }\n    bb25: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_42);\n        _42 = _2;\n        _43 = PtrMetadata(_1);\n        _44 = Lt(_42, _43);\n        assert(move _44, \"index out of bounds: the length is {} but the index is {}\", move _43, _42) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _36 = (*_1)[_42];\n        StorageDead(_42);\n        _35 = (_16, move _36);\n        StorageDead(_36);\n        switchInt((_35.0: u8)) -> [224: bb28, 237: bb38, otherwise: bb30];\n    }\n    bb27: {\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = option::Option::Some(1_u8);\n        _57 = Utf8Error(_15, move _58);\n        StorageDead(_58);\n        _0 = result::Result::Err(move _57);\n        StorageDead(_57);\n        goto -> bb112;\n    }\n    bb28: {\n        _45 = Le(160_u8, (_35.1: u8));\n        switchInt(move _45) -> [0: bb27, otherwise: bb29];\n    }\n    bb29: {\n        _46 = Le((_35.1: u8), 191_u8);\n        switchInt(move _46) -> [0: bb27, otherwise: bb40];\n    }\n    bb30: {\n        _53 = Le(225_u8, (_35.0: u8));\n        switchInt(move _53) -> [0: bb33, otherwise: bb37];\n    }\n    bb31: {\n        _47 = Le(128_u8, (_35.1: u8));\n        switchInt(move _47) -> [0: bb27, otherwise: bb32];\n    }\n    bb32: {\n        _48 = Le((_35.1: u8), 191_u8);\n        switchInt(move _48) -> [0: bb27, otherwise: bb40];\n    }\n    bb33: {\n        _51 = Le(238_u8, (_35.0: u8));\n        switchInt(move _51) -> [0: bb27, otherwise: bb36];\n    }\n    bb34: {\n        _49 = Le(128_u8, (_35.1: u8));\n        switchInt(move _49) -> [0: bb27, otherwise: bb35];\n    }\n    bb35: {\n        _50 = Le((_35.1: u8), 191_u8);\n        switchInt(move _50) -> [0: bb27, otherwise: bb40];\n    }\n    bb36: {\n        _52 = Le((_35.0: u8), 239_u8);\n        switchInt(move _52) -> [0: bb27, otherwise: bb34];\n    }\n    bb37: {\n        _54 = Le((_35.0: u8), 236_u8);\n        switchInt(move _54) -> [0: bb33, otherwise: bb31];\n    }\n    bb38: {\n        _55 = Le(128_u8, (_35.1: u8));\n        switchInt(move _55) -> [0: bb27, otherwise: bb39];\n    }\n    bb39: {\n        _56 = Le((_35.1: u8), 159_u8);\n        switchInt(move _56) -> [0: bb27, otherwise: bb40];\n    }\n    bb40: {\n        StorageDead(_35);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _62 = CheckedAdd(_2, 1_usize);\n        assert(!move (_62.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _2 = move (_62.0: usize);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _2;\n        _63 = Ge(move _64, _3);\n        switchInt(move _63) -> [0: bb43, otherwise: bb42];\n    }\n    bb42: {\n        StorageDead(_64);\n        StorageLive(_65);\n        StorageLive(_66);\n        _66 = option::Option::None;\n        _65 = Utf8Error(_15, move _66);\n        StorageDead(_66);\n        _0 = result::Result::Err(move _65);\n        StorageDead(_65);\n        StorageDead(_63);\n        StorageDead(_61);\n        StorageDead(_60);\n        goto -> bb111;\n    }\n    bb43: {\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageLive(_67);\n        _67 = _2;\n        _68 = PtrMetadata(_1);\n        _69 = Lt(_67, _68);\n        assert(move _69, \"index out of bounds: the length is {} but the index is {}\", move _68, _67) -> [success: bb44, unwind unreachable];\n    }\n    bb44: {\n        _61 = (*_1)[_67];\n        StorageDead(_67);\n        _60 = move _61 as i8;\n        StorageDead(_61);\n        _59 = Ge(move _60, -64_i8);\n        switchInt(move _59) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_60);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = option::Option::Some(2_u8);\n        _70 = Utf8Error(_15, move _71);\n        StorageDead(_71);\n        _0 = result::Result::Err(move _70);\n        StorageDead(_70);\n        goto -> bb111;\n    }\n    bb46: {\n        StorageDead(_60);\n        StorageDead(_59);\n        goto -> bb73;\n    }\n    bb47: {\n        _2 = move (_74.0: usize);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = _2;\n        _75 = Ge(move _76, _3);\n        switchInt(move _75) -> [0: bb49, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_76);\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = option::Option::None;\n        _77 = Utf8Error(_15, move _78);\n        StorageDead(_78);\n        _0 = result::Result::Err(move _77);\n        StorageDead(_77);\n        StorageDead(_75);\n        StorageDead(_73);\n        goto -> bb110;\n    }\n    bb49: {\n        StorageDead(_76);\n        StorageDead(_75);\n        StorageLive(_79);\n        _79 = _2;\n        _80 = PtrMetadata(_1);\n        _81 = Lt(_79, _80);\n        assert(move _81, \"index out of bounds: the length is {} but the index is {}\", move _80, _79) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _73 = (*_1)[_79];\n        StorageDead(_79);\n        _72 = (_16, move _73);\n        StorageDead(_73);\n        switchInt((_72.0: u8)) -> [240: bb52, 244: bb58, otherwise: bb54];\n    }\n    bb51: {\n        StorageLive(_90);\n        StorageLive(_91);\n        _91 = option::Option::Some(1_u8);\n        _90 = Utf8Error(_15, move _91);\n        StorageDead(_91);\n        _0 = result::Result::Err(move _90);\n        StorageDead(_90);\n        goto -> bb110;\n    }\n    bb52: {\n        _82 = Le(144_u8, (_72.1: u8));\n        switchInt(move _82) -> [0: bb51, otherwise: bb53];\n    }\n    bb53: {\n        _83 = Le((_72.1: u8), 191_u8);\n        switchInt(move _83) -> [0: bb51, otherwise: bb60];\n    }\n    bb54: {\n        _86 = Le(241_u8, (_72.0: u8));\n        switchInt(move _86) -> [0: bb51, otherwise: bb57];\n    }\n    bb55: {\n        _84 = Le(128_u8, (_72.1: u8));\n        switchInt(move _84) -> [0: bb51, otherwise: bb56];\n    }\n    bb56: {\n        _85 = Le((_72.1: u8), 191_u8);\n        switchInt(move _85) -> [0: bb51, otherwise: bb60];\n    }\n    bb57: {\n        _87 = Le((_72.0: u8), 243_u8);\n        switchInt(move _87) -> [0: bb51, otherwise: bb55];\n    }\n    bb58: {\n        _88 = Le(128_u8, (_72.1: u8));\n        switchInt(move _88) -> [0: bb51, otherwise: bb59];\n    }\n    bb59: {\n        _89 = Le((_72.1: u8), 143_u8);\n        switchInt(move _89) -> [0: bb51, otherwise: bb60];\n    }\n    bb60: {\n        StorageDead(_72);\n        StorageLive(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        _95 = CheckedAdd(_2, 1_usize);\n        assert(!move (_95.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb61, unwind unreachable];\n    }\n    bb61: {\n        _2 = move (_95.0: usize);\n        StorageLive(_96);\n        StorageLive(_97);\n        _97 = _2;\n        _96 = Ge(move _97, _3);\n        switchInt(move _96) -> [0: bb63, otherwise: bb62];\n    }\n    bb62: {\n        StorageDead(_97);\n        StorageLive(_98);\n        StorageLive(_99);\n        _99 = option::Option::None;\n        _98 = Utf8Error(_15, move _99);\n        StorageDead(_99);\n        _0 = result::Result::Err(move _98);\n        StorageDead(_98);\n        StorageDead(_96);\n        StorageDead(_94);\n        StorageDead(_93);\n        goto -> bb109;\n    }\n    bb63: {\n        StorageDead(_97);\n        StorageDead(_96);\n        StorageLive(_100);\n        _100 = _2;\n        _101 = PtrMetadata(_1);\n        _102 = Lt(_100, _101);\n        assert(move _102, \"index out of bounds: the length is {} but the index is {}\", move _101, _100) -> [success: bb64, unwind unreachable];\n    }\n    bb64: {\n        _94 = (*_1)[_100];\n        StorageDead(_100);\n        _93 = move _94 as i8;\n        StorageDead(_94);\n        _92 = Ge(move _93, -64_i8);\n        switchInt(move _92) -> [0: bb66, otherwise: bb65];\n    }\n    bb65: {\n        StorageDead(_93);\n        StorageLive(_103);\n        StorageLive(_104);\n        _104 = option::Option::Some(2_u8);\n        _103 = Utf8Error(_15, move _104);\n        StorageDead(_104);\n        _0 = result::Result::Err(move _103);\n        StorageDead(_103);\n        goto -> bb109;\n    }\n    bb66: {\n        StorageDead(_93);\n        StorageDead(_92);\n        StorageLive(_105);\n        StorageLive(_106);\n        StorageLive(_107);\n        _108 = CheckedAdd(_2, 1_usize);\n        assert(!move (_108.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb67, unwind unreachable];\n    }\n    bb67: {\n        _2 = move (_108.0: usize);\n        StorageLive(_109);\n        StorageLive(_110);\n        _110 = _2;\n        _109 = Ge(move _110, _3);\n        switchInt(move _109) -> [0: bb69, otherwise: bb68];\n    }\n    bb68: {\n        StorageDead(_110);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = option::Option::None;\n        _111 = Utf8Error(_15, move _112);\n        StorageDead(_112);\n        _0 = result::Result::Err(move _111);\n        StorageDead(_111);\n        StorageDead(_109);\n        StorageDead(_107);\n        StorageDead(_106);\n        goto -> bb108;\n    }\n    bb69: {\n        StorageDead(_110);\n        StorageDead(_109);\n        StorageLive(_113);\n        _113 = _2;\n        _114 = PtrMetadata(_1);\n        _115 = Lt(_113, _114);\n        assert(move _115, \"index out of bounds: the length is {} but the index is {}\", move _114, _113) -> [success: bb70, unwind unreachable];\n    }\n    bb70: {\n        _107 = (*_1)[_113];\n        StorageDead(_113);\n        _106 = move _107 as i8;\n        StorageDead(_107);\n        _105 = Ge(move _106, -64_i8);\n        switchInt(move _105) -> [0: bb72, otherwise: bb71];\n    }\n    bb71: {\n        StorageDead(_106);\n        StorageLive(_116);\n        StorageLive(_117);\n        _117 = option::Option::Some(3_u8);\n        _116 = Utf8Error(_15, move _117);\n        StorageDead(_117);\n        _0 = result::Result::Err(move _116);\n        StorageDead(_116);\n        goto -> bb108;\n    }\n    bb72: {\n        StorageDead(_106);\n        StorageDead(_105);\n        goto -> bb73;\n    }\n    bb73: {\n        _120 = CheckedAdd(_2, 1_usize);\n        assert(!move (_120.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb74, unwind unreachable];\n    }\n    bb74: {\n        _2 = move (_120.0: usize);\n        StorageDead(_21);\n        goto -> bb106;\n    }\n    bb75: {\n        StorageLive(_121);\n        _121 = Ne(_11, num::<impl usize>::MAX);\n        switchInt(move _121) -> [0: bb102, otherwise: bb76];\n    }\n    bb76: {\n        StorageLive(_122);\n        StorageLive(_123);\n        StorageLive(_124);\n        _124 = _2;\n        _123 = num::<impl usize>::wrapping_sub(_11, move _124) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_124);\n        _122 = num::<impl usize>::is_multiple_of(move _123, str::validations::run_utf8_validation::USIZE_BYTES) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        switchInt(move _122) -> [0: bb101, otherwise: bb79];\n    }\n    bb79: {\n        StorageDead(_123);\n        _125 = slice::<impl [u8]>::as_ptr(_1) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        goto -> bb81;\n    }\n    bb81: {\n        StorageLive(_126);\n        StorageLive(_127);\n        _127 = _2;\n        StorageLive(_128);\n        _128 = _6;\n        _126 = Lt(move _127, move _128);\n        switchInt(move _126) -> [0: bb91, otherwise: bb82];\n    }\n    bb82: {\n        StorageDead(_128);\n        StorageDead(_127);\n        StorageLive(_130);\n        StorageLive(_131);\n        _131 = _2;\n        _130 = ptr::const_ptr::<impl *const u8>::add(_125, move _131) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        StorageDead(_131);\n        _129 = move _130 as *const usize;\n        StorageDead(_130);\n        StorageLive(_133);\n        _133 = (*_129);\n        _132 = str::validations::contains_nonascii(move _133) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        StorageDead(_133);\n        StorageLive(_135);\n        StorageLive(_136);\n        _136 = ptr::const_ptr::<impl *const usize>::add(_129, 1_usize) -> [return: bb85, unwind unreachable];\n    }\n    bb85: {\n        _135 = (*_136);\n        _134 = str::validations::contains_nonascii(move _135) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        StorageDead(_135);\n        StorageDead(_136);\n        switchInt(_132) -> [0: bb87, otherwise: bb88];\n    }\n    bb87: {\n        switchInt(_134) -> [0: bb89, otherwise: bb88];\n    }\n    bb88: {\n        goto -> bb92;\n    }\n    bb89: {\n        _137 = CheckedAdd(_2, _4);\n        assert(!move (_137.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, _4) -> [success: bb90, unwind unreachable];\n    }\n    bb90: {\n        _2 = move (_137.0: usize);\n        StorageDead(_126);\n        goto -> bb81;\n    }\n    bb91: {\n        StorageDead(_128);\n        StorageDead(_127);\n        goto -> bb92;\n    }\n    bb92: {\n        StorageDead(_126);\n        goto -> bb93;\n    }\n    bb93: {\n        StorageLive(_138);\n        StorageLive(_139);\n        _139 = _2;\n        _138 = Lt(move _139, _3);\n        switchInt(move _138) -> [0: bb99, otherwise: bb94];\n    }\n    bb94: {\n        StorageDead(_139);\n        StorageLive(_140);\n        StorageLive(_141);\n        StorageLive(_142);\n        _142 = _2;\n        _143 = PtrMetadata(_1);\n        _144 = Lt(_142, _143);\n        assert(move _144, \"index out of bounds: the length is {} but the index is {}\", move _143, _142) -> [success: bb95, unwind unreachable];\n    }\n    bb95: {\n        _141 = (*_1)[_142];\n        _140 = Lt(move _141, 128_u8);\n        switchInt(move _140) -> [0: bb98, otherwise: bb96];\n    }\n    bb96: {\n        StorageDead(_142);\n        StorageDead(_141);\n        _145 = CheckedAdd(_2, 1_usize);\n        assert(!move (_145.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb97, unwind unreachable];\n    }\n    bb97: {\n        _2 = move (_145.0: usize);\n        StorageDead(_140);\n        StorageDead(_138);\n        goto -> bb93;\n    }\n    bb98: {\n        StorageDead(_142);\n        StorageDead(_141);\n        goto -> bb100;\n    }\n    bb99: {\n        StorageDead(_139);\n        goto -> bb100;\n    }\n    bb100: {\n        StorageDead(_140);\n        StorageDead(_138);\n        goto -> bb105;\n    }\n    bb101: {\n        StorageDead(_123);\n        goto -> bb103;\n    }\n    bb102: {\n        goto -> bb103;\n    }\n    bb103: {\n        _146 = CheckedAdd(_2, 1_usize);\n        assert(!move (_146.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb104, unwind unreachable];\n    }\n    bb104: {\n        _2 = move (_146.0: usize);\n        goto -> bb105;\n    }\n    bb105: {\n        StorageDead(_122);\n        StorageDead(_121);\n        goto -> bb106;\n    }\n    bb106: {\n        StorageDead(_20);\n        StorageDead(_13);\n        goto -> bb8;\n    }\n    bb107: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _0 = result::Result::Ok(());\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb115;\n    }\n    bb108: {\n        StorageDead(_105);\n        goto -> bb114;\n    }\n    bb109: {\n        StorageDead(_92);\n        goto -> bb114;\n    }\n    bb110: {\n        StorageDead(_72);\n        goto -> bb114;\n    }\n    bb111: {\n        StorageDead(_59);\n        goto -> bb114;\n    }\n    bb112: {\n        StorageDead(_35);\n        goto -> bb114;\n    }\n    bb113: {\n        StorageDead(_22);\n        goto -> bb114;\n    }\n    bb114: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_13);\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb115;\n    }\n    bb115: {\n        return;\n    }\n}\n",
  "doc": " Walks through `v` checking that it's a valid UTF-8 sequence,\n returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}