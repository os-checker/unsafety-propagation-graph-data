{
  "name": "unicode::printable::check",
  "safe": true,
  "callees": {
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {
        "slice::iter::Iter": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::cloned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which [`clone`]s all of its elements.\n\n This is useful when you have an iterator over `&T`, but you need an\n iterator over `T`.\n\n There is no guarantee whatsoever about the `clone` method actually\n being called *or* optimized away. So code should not depend on\n either.\n\n [`clone`]: Clone::clone\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let v_cloned: Vec<_> = a.iter().cloned().collect();\n\n // cloned is the same as .map(|&x| x), for integers\n let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\n assert_eq!(v_cloned, [1, 2, 3]);\n assert_eq!(v_map, [1, 2, 3]);\n ```\n\n To get the best performance, try to clone late:\n\n ```\n let a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];\n // don't do this:\n let slower: Vec<_> = a.iter().cloned().filter(|s| s.len() == 1).collect();\n assert_eq!(&[vec![23]], &slower[..]);\n // instead call `cloned` late\n let faster: Vec<_> = a.iter().filter(|s| s.len() == 1).cloned().collect();\n assert_eq!(&[vec![23]], &faster[..]);\n ```\n",
      "adt": {
        "iter::adapters::cloned::Cloned": "Constructor"
      }
    },
    "option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::iter::Iter": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15679, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1071, kind: RigidTy(Tuple([Ty { id: 46, kind: RigidTy(Uint(U8)) }, Ty { id: 46, kind: RigidTy(Uint(U8)) }])) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 46, kind: RigidTy(Uint(U8)) })])"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "iter::adapters::cloned::Cloned": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::unicode::printable::check"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/printable.rs:4:1: 37:2",
  "src": "fn check(x: u16, singletonuppers: &[(u8, u8)], singletonlowers: &[u8], normal: &[u8]) -> bool {\n    let xupper = (x >> 8) as u8;\n    let mut lowerstart = 0;\n    for &(upper, lowercount) in singletonuppers {\n        let lowerend = lowerstart + lowercount as usize;\n        if xupper == upper {\n            for &lower in &singletonlowers[lowerstart..lowerend] {\n                if lower == x as u8 {\n                    return false;\n                }\n            }\n        } else if xupper < upper {\n            break;\n        }\n        lowerstart = lowerend;\n    }\n\n    let mut x = x as i32;\n    let mut normal = normal.iter().cloned();\n    let mut current = true;\n    while let Some(v) = normal.next() {\n        let len = if v & 0x80 != 0 {\n            ((v & 0x7f) as i32) << 8 | normal.next().unwrap() as i32\n        } else {\n            v as i32\n        };\n        x -= len;\n        if x < 0 {\n            break;\n        }\n        current = !current;\n    }\n    current\n}",
  "mir": "fn unicode::printable::check(_1: u16, _2: &[(u8, u8)], _3: &[u8], _4: &[u8]) -> bool {\n    let mut _0: bool;\n    let  _5: u8;\n    let mut _6: u16;\n    let mut _7: u32;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: slice::iter::Iter<'_, (u8, u8)>;\n    let mut _11: slice::iter::Iter<'_, (u8, u8)>;\n    let mut _12: option::Option<&(u8, u8)>;\n    let mut _13: &mut slice::iter::Iter<'_, (u8, u8)>;\n    let mut _14: isize;\n    let  _15: u8;\n    let  _16: u8;\n    let  _17: usize;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: (usize, bool);\n    let mut _21: bool;\n    let mut _22: slice::iter::Iter<'_, u8>;\n    let  _23: &[u8];\n    let mut _24: ops::range::Range<usize>;\n    let mut _25: usize;\n    let mut _26: slice::iter::Iter<'_, u8>;\n    let mut _27: option::Option<&u8>;\n    let mut _28: &mut slice::iter::Iter<'_, u8>;\n    let mut _29: isize;\n    let  _30: u8;\n    let mut _31: bool;\n    let mut _32: u8;\n    let mut _33: bool;\n    let mut _34: i32;\n    let mut _35: iter::adapters::cloned::Cloned<slice::iter::Iter<'_, u8>>;\n    let mut _36: slice::iter::Iter<'_, u8>;\n    let mut _37: bool;\n    let mut _38: option::Option<u8>;\n    let mut _39: &mut iter::adapters::cloned::Cloned<slice::iter::Iter<'_, u8>>;\n    let mut _40: isize;\n    let  _41: u8;\n    let  _42: i32;\n    let mut _43: u8;\n    let mut _44: i32;\n    let mut _45: i32;\n    let mut _46: u8;\n    let mut _47: u32;\n    let mut _48: bool;\n    let mut _49: i32;\n    let mut _50: u8;\n    let mut _51: option::Option<u8>;\n    let mut _52: &mut iter::adapters::cloned::Cloned<slice::iter::Iter<'_, u8>>;\n    let mut _53: i32;\n    let mut _54: (i32, bool);\n    let mut _55: bool;\n    let mut _56: i32;\n    let mut _57: bool;\n    let mut _58: &(u8, u8);\n    let mut _59: &(u8, u8);\n    let mut _60: &u8;\n    debug x => _1;\n    debug singletonuppers => _2;\n    debug singletonlowers => _3;\n    debug normal => _4;\n    debug xupper => _5;\n    debug lowerstart => _9;\n    debug iter => _11;\n    debug upper => _15;\n    debug lowercount => _16;\n    debug lowerend => _17;\n    debug iter => _26;\n    debug lower => _30;\n    debug x => _34;\n    debug normal => _35;\n    debug current => _37;\n    debug v => _41;\n    debug len => _42;\n    bb0: {\n        StorageLive(_6);\n        _7 = 8_i32 as u32;\n        _8 = Lt(move _7, 16_u32);\n        assert(move _8, \"attempt to shift right by `{}`, which would overflow\", 8_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = Shr(_1, 8_i32);\n        _5 = move _6 as u8;\n        StorageDead(_6);\n        StorageLive(_9);\n        _9 = 0_usize;\n        StorageLive(_10);\n        _10 = <&[(u8, u8)] as iter::traits::collect::IntoIterator>::into_iter(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_11);\n        _11 = move _10;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_12);\n        _13 = &mut _11;\n        _12 = <slice::iter::Iter<'_, (u8, u8)> as iter::traits::iterator::Iterator>::next(_13) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _14 = discriminant(_12);\n        switchInt(move _14) -> [0: bb21, 1: bb6, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _58 = ((_12 as variant#1).0: &(u8, u8));\n        _15 = ((*_58).0: u8);\n        _59 = ((_12 as variant#1).0: &(u8, u8));\n        _16 = ((*_59).1: u8);\n        StorageLive(_18);\n        _18 = _9;\n        StorageLive(_19);\n        _19 = _16 as usize;\n        _20 = CheckedAdd(_18, _19);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _18, move _19) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _17 = move (_20.0: usize);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_21);\n        _21 = Eq(_5, _15);\n        switchInt(move _21) -> [0: bb17, otherwise: bb8];\n    }\n    bb8: {\n        StorageLive(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _9;\n        _24 = Range(move _25, _17);\n        StorageDead(_25);\n        _23 = <[u8] as ops::index::Index<ops::range::Range<usize>>>::index(_3, move _24) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_24);\n        _22 = <&[u8] as iter::traits::collect::IntoIterator>::into_iter(_23) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_26);\n        _26 = move _22;\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_27);\n        _28 = &mut _26;\n        _27 = <slice::iter::Iter<'_, u8> as iter::traits::iterator::Iterator>::next(_28) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _29 = discriminant(_27);\n        switchInt(move _29) -> [0: bb14, 1: bb13, otherwise: bb5];\n    }\n    bb13: {\n        _60 = ((_27 as variant#1).0: &u8);\n        _30 = (*_60);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _1 as u8;\n        _31 = Eq(_30, move _32);\n        switchInt(move _31) -> [0: bb16, otherwise: bb15];\n    }\n    bb14: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_22);\n        goto -> bb20;\n    }\n    bb15: {\n        StorageDead(_32);\n        _0 = false;\n        StorageDead(_31);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb38;\n    }\n    bb16: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_27);\n        goto -> bb11;\n    }\n    bb17: {\n        StorageLive(_33);\n        _33 = Lt(_5, _15);\n        switchInt(move _33) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_33);\n        StorageDead(_21);\n        goto -> bb21;\n    }\n    bb19: {\n        StorageDead(_33);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_21);\n        _9 = _17;\n        StorageDead(_12);\n        goto -> bb3;\n    }\n    bb21: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_34);\n        _34 = _1 as i32;\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = slice::<impl [u8]>::iter(_4) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _35 = <slice::iter::Iter<'_, u8> as iter::traits::iterator::Iterator>::cloned::<'_, u8>(move _36) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_36);\n        StorageLive(_37);\n        _37 = true;\n        goto -> bb24;\n    }\n    bb24: {\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &mut _35;\n        _38 = <iter::adapters::cloned::Cloned<slice::iter::Iter<'_, u8>> as iter::traits::iterator::Iterator>::next(move _39) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_39);\n        _40 = discriminant(_38);\n        switchInt(move _40) -> [1: bb26, 0: bb36, otherwise: bb5];\n    }\n    bb26: {\n        _41 = ((_38 as variant#1).0: u8);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = BitAnd(_41, 128_u8);\n        switchInt(move _43) -> [0: bb31, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = BitAnd(_41, 127_u8);\n        _45 = move _46 as i32;\n        StorageDead(_46);\n        _47 = 8_i32 as u32;\n        _48 = Lt(move _47, 32_u32);\n        assert(move _48, \"attempt to shift left by `{}`, which would overflow\", 8_i32) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _44 = Shl(move _45, 8_i32);\n        StorageDead(_45);\n        StorageLive(_49);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &mut _35;\n        _51 = <iter::adapters::cloned::Cloned<slice::iter::Iter<'_, u8>> as iter::traits::iterator::Iterator>::next(move _52) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_52);\n        _50 = option::Option::<u8>::unwrap(move _51) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_51);\n        _49 = move _50 as i32;\n        StorageDead(_50);\n        _42 = BitOr(move _44, move _49);\n        StorageDead(_49);\n        StorageDead(_44);\n        goto -> bb32;\n    }\n    bb31: {\n        StorageDead(_43);\n        _42 = _41 as i32;\n        goto -> bb32;\n    }\n    bb32: {\n        StorageLive(_53);\n        _53 = _42;\n        _54 = CheckedSub(_34, _53);\n        assert(!move (_54.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _34, move _53) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _34 = move (_54.0: i32);\n        StorageDead(_53);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = _34;\n        _55 = Lt(move _56, 0_i32);\n        switchInt(move _55) -> [0: bb35, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageDead(_42);\n        StorageDead(_38);\n        goto -> bb37;\n    }\n    bb35: {\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageLive(_57);\n        _57 = _37;\n        _37 = Not(move _57);\n        StorageDead(_57);\n        StorageDead(_42);\n        StorageDead(_38);\n        goto -> bb24;\n    }\n    bb36: {\n        StorageDead(_38);\n        goto -> bb37;\n    }\n    bb37: {\n        _0 = _37;\n        StorageDead(_37);\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_9);\n        goto -> bb38;\n    }\n    bb38: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}