{
  "name": "core_arch::x86::avx512fp16::_mm512_maskz_fmsubadd_round_ph",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::_mm512_fmsubadd_round_ph": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiply packed half-precision (16-bit) floating-point elements in a and b, alternatively subtract\n and add packed elements in c to/from the intermediate result, and store the results in dst.\n\n Rounding is done according to the rounding parameter, which can be one of:\n\n * [`_MM_FROUND_TO_NEAREST_INT`] | [`_MM_FROUND_NO_EXC`] : round to nearest and suppress exceptions\n * [`_MM_FROUND_TO_NEG_INF`] | [`_MM_FROUND_NO_EXC`] : round down and suppress exceptions\n * [`_MM_FROUND_TO_POS_INF`] | [`_MM_FROUND_NO_EXC`] : round up and suppress exceptions\n * [`_MM_FROUND_TO_ZERO`] | [`_MM_FROUND_NO_EXC`] : truncate and suppress exceptions\n * [`_MM_FROUND_CUR_DIRECTION`] : use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`]\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_fmsubadd_round_ph)\n",
      "adt": {
        "core_arch::x86::__m512h": "Constructor"
      }
    },
    "core_arch::x86::avx512fp16::_mm512_setzero_ph": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return vector of type __m512h with all elements set to zero.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_setzero_ph)\n",
      "adt": {
        "core_arch::x86::__m512h": "Constructor"
      }
    },
    "intrinsics::simd::simd_select_bitmask": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Selects elements from a bitmask.\n\n `M` must be an unsigned integer or array of `u8`, matching `simd_bitmask`.\n\n `T` must be a vector.\n\n For each element, if the bit in `mask` is `1`, select the element from\n `if_true`.  If the corresponding bit in `mask` is `0`, select the element from\n `if_false`.\n The remaining bits of the mask are ignored.\n\n The bitmask bit order matches `simd_bitmask`.\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m512h": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::avx512fp16::_mm512_maskz_fmsubadd_round_ph"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:7735:1: 7749:2",
  "src": "pub fn _mm512_maskz_fmsubadd_round_ph<const ROUNDING: i32>(\n    k: __mmask32,\n    a: __m512h,\n    b: __m512h,\n    c: __m512h,\n) -> __m512h {\n    unsafe {\n        static_assert_rounding!(ROUNDING);\n        simd_select_bitmask(\n            k,\n            _mm512_fmsubadd_round_ph::<ROUNDING>(a, b, c),\n            _mm512_setzero_ph(),\n        )\n    }\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm512_maskz_fmsubadd_round_ph(_1: u32, _2: core_arch::x86::__m512h, _3: core_arch::x86::__m512h, _4: core_arch::x86::__m512h) -> core_arch::x86::__m512h {\n    let mut _0: core_arch::x86::__m512h;\n    let mut _5: core_arch::x86::__m512h;\n    let mut _6: core_arch::x86::__m512h;\n    debug k => _1;\n    debug a => _2;\n    debug b => _3;\n    debug c => _4;\n    bb0: {\n        StorageLive(_5);\n        _5 = core_arch::x86::avx512fp16::_mm512_fmsubadd_round_ph::<ROUNDING>(_2, _3, _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = core_arch::x86::avx512fp16::_mm512_setzero_ph() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = intrinsics::simd::simd_select_bitmask::<u32, core_arch::x86::__m512h>(_1, move _5, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Multiply packed half-precision (16-bit) floating-point elements in a and b, alternatively subtract\n and add packed elements in c to/from the intermediate result, and store the results in dst using zeromask k\n (the element is zeroed out when the corresponding mask bit is not set).\n\n Rounding is done according to the rounding parameter, which can be one of:\n\n * [`_MM_FROUND_TO_NEAREST_INT`] | [`_MM_FROUND_NO_EXC`] : round to nearest and suppress exceptions\n * [`_MM_FROUND_TO_NEG_INF`] | [`_MM_FROUND_NO_EXC`] : round down and suppress exceptions\n * [`_MM_FROUND_TO_POS_INF`] | [`_MM_FROUND_NO_EXC`] : round up and suppress exceptions\n * [`_MM_FROUND_TO_ZERO`] | [`_MM_FROUND_NO_EXC`] : truncate and suppress exceptions\n * [`_MM_FROUND_CUR_DIRECTION`] : use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`]\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm512_maskz_fmsubadd_round_ph)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}