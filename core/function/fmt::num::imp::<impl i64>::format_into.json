{
  "name": "fmt::num::imp::<impl i64>::format_into",
  "safe": true,
  "callees": {
    "num::<impl i64>::unsigned_abs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes the absolute value of `self` without any wrapping\n or panicking.\n\n\n # Examples\n\n ```\n assert_eq!((-128i8).unsigned_abs(), 128u8);\n ```\n",
      "adt": {}
    },
    "fmt::num::imp::<impl u64>::_fmt_inner": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "fmt::num::slice_buffer_to_str": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This function converts a slice of ascii characters into a `&str` starting from `offset`.\n\n # Safety\n\n `buf` content starting from `offset` index MUST BE initialized and MUST BE ascii\n characters.\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::num_buffer::NumBuffer": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef"
    ]
  },
  "path": 2551,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:277:13: 298:14",
  "src": "pub fn format_into(self, buf: &mut NumBuffer<Self>) -> &str {\n                let mut offset;\n\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                // SAFETY: `buf` will always be big enough to contain all digits.\n                unsafe {\n                    offset = self.unsigned_abs()._fmt_inner(&mut buf.buf);\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    offset = ${concat($fmt_fn, _in_buf_small)}(self.unsigned_abs() as $T, &mut buf.buf);\n                }\n                // Only difference between signed and unsigned are these 4 lines.\n                if self < 0 {\n                    offset -= 1;\n                    buf.buf[offset].write(b'-');\n                }\n                // SAFETY: Starting from `offset`, all elements of the slice have been set.\n                unsafe { slice_buffer_to_str(&buf.buf, offset) }\n            }",
  "mir": "fn fmt::num::imp::<impl i64>::format_into(_1: i64, _2: &mut fmt::num_buffer::NumBuffer<i64>) -> &str {\n    let mut _0: &str;\n    let mut _3: usize;\n    let mut _4: usize;\n    let mut _5: u64;\n    let mut _6: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _7: &mut [mem::maybe_uninit::MaybeUninit<u8>; 40];\n    let mut _8: bool;\n    let mut _9: (usize, bool);\n    let  _10: &mut u8;\n    let mut _11: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _12: usize;\n    let mut _13: bool;\n    let mut _14: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let  _15: &[mem::maybe_uninit::MaybeUninit<u8>; 40];\n    let mut _16: usize;\n    debug self => _1;\n    debug buf => _2;\n    debug offset => _3;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = num::<impl i64>::unsigned_abs(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _7 = &mut ((*_2).0: [mem::maybe_uninit::MaybeUninit<u8>; 40]);\n        _6 = _7 as &mut [mem::maybe_uninit::MaybeUninit<u8>];\n        _4 = fmt::num::imp::<impl u64>::_fmt_inner(move _5, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _3 = move _4;\n        StorageDead(_4);\n        StorageLive(_8);\n        _8 = Lt(_1, 0_i64);\n        switchInt(move _8) -> [0: bb7, otherwise: bb3];\n    }\n    bb3: {\n        _9 = CheckedSub(_3, 1_usize);\n        assert(!move (_9.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _3 = move (_9.0: usize);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _3;\n        _13 = Lt(_12, 40_usize);\n        assert(move _13, \"index out of bounds: the length is {} but the index is {}\", 40_usize, _12) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _11 = &mut ((*_2).0: [mem::maybe_uninit::MaybeUninit<u8>; 40])[_12];\n        _10 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _11, 45_u8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageDead(_12);\n        StorageDead(_10);\n        goto -> bb8;\n    }\n    bb7: {\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_8);\n        StorageLive(_14);\n        _15 = &((*_2).0: [mem::maybe_uninit::MaybeUninit<u8>; 40]);\n        _14 = _15 as &[mem::maybe_uninit::MaybeUninit<u8>];\n        StorageLive(_16);\n        _16 = _3;\n        _0 = fmt::num::slice_buffer_to_str(move _14, move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Allows users to write an integer (in signed decimal format) into a variable `buf` of\n type [`NumBuffer`] that is passed by the caller by mutable reference.\n\n # Examples\n\n ```\n #![feature(int_format_into)]\n use core::fmt::NumBuffer;\n\n let mut buf = NumBuffer::new();\n assert_eq!(n.format_into(&mut buf), \"0\");\n\n assert_eq!(n1.format_into(&mut buf), \"32\");\n\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}