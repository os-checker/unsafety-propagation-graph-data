{
  "name": "slice::<impl [T]>::binary_search_by_key",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::binary_search_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Binary searches this slice with a comparator function.\n\n The comparator function should return an order code that indicates\n whether its argument is `Less`, `Equal` or `Greater` the desired\n target.\n If the slice is not sorted or if the comparator function does not\n implement an order consistent with the sort order of the underlying\n slice, the returned result is unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search`]: slice::binary_search\n [`binary_search_by_key`]: slice::binary_search_by_key\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n let seek = 13;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n let seek = 4;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n let seek = 100;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n let seek = 1;\n let r = s.binary_search_by(|probe| probe.cmp(&seek));\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ]
  },
  "path": 1244,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3068:5: 3074:6",
  "src": "pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n    where\n        F: FnMut(&'a T) -> B,\n        B: Ord,\n    {\n        self.binary_search_by(|k| f(k).cmp(b))\n    }",
  "mir": "fn slice::<impl [T]>::binary_search_by_key(_1: &[T], _2: &B, _3: F) -> result::Result<usize, usize> {\n    let mut _0: result::Result<usize, usize>;\n    let mut _4: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3073:31: 3073:34};\n    let mut _5: &mut F;\n    debug self => _1;\n    debug b => _2;\n    debug f => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _3;\n        _4 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3073:31: 3073:34}(move _5, _2);\n        StorageDead(_5);\n        _0 = slice::<impl [T]>::binary_search_by::<'_, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3073:31: 3073:34}>(_1, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        drop(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Binary searches this slice with a key extraction function.\n\n Assumes that the slice is sorted by the key, for instance with\n [`sort_by_key`] using the same key extraction function.\n If the slice is not sorted by the key, the returned result is\n unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n\n [`sort_by_key`]: slice::sort_by_key\n [`binary_search`]: slice::binary_search\n [`binary_search_by`]: slice::binary_search_by\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements in a slice of pairs sorted by\n their second elements. The first is found, with a uniquely\n determined position; the second and third are not found; the\n fourth could match any position in `[1, 4]`.\n\n ```\n let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n          (1, 21), (2, 34), (4, 55)];\n\n assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));\n assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));\n assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));\n let r = s.binary_search_by_key(&1, |&(a, b)| b);\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}