{
  "name": "ptr::write_bytes",
  "safe": false,
  "callees": {
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "ptr::write_bytes::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "intrinsics::write_bytes": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This is an accidentally-stable alias to [`ptr::write_bytes`]; use that instead.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 16098,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:697:1: 711:2",
  "src": "pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n    // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::write_bytes requires that the destination pointer is aligned and non-null\",\n            (\n                addr: *const () = dst as *const (),\n                align: usize = align_of::<T>(),\n                zero_size: bool = T::IS_ZST || count == 0,\n            ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, zero_size)\n        );\n        crate::intrinsics::write_bytes(dst, val, count)\n    }\n}",
  "mir": "fn ptr::write_bytes(_1: *mut T, _2: u8, _3: usize) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let  _5: ();\n    let mut _6: *const ();\n    let mut _7: usize;\n    let mut _8: bool;\n    debug dst => _1;\n    debug val => _2;\n    debug count => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = ub_checks::check_language_ub() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _4) -> [0: bb8, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = _1 as *const ();\n        StorageLive(_7);\n        _7 = mem::align_of::<T>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_8);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        _8 = true;\n        goto -> bb6;\n    }\n    bb5: {\n        _8 = Eq(_3, 0_usize);\n        goto -> bb6;\n    }\n    bb6: {\n        _5 = ptr::write_bytes::precondition_check(move _6, move _7, move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_4);\n        _0 = intrinsics::write_bytes::<T>(_1, _2, _3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        return;\n    }\n}\n",
  "doc": " Sets `count * size_of::<T>()` bytes of memory starting at `dst` to\n `val`.\n\n `write_bytes` is similar to C's [`memset`], but sets `count *\n size_of::<T>()` bytes to `val`.\n\n [`memset`]: https://en.cppreference.com/w/c/string/byte/memset\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * `dst` must be properly aligned.\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointer must be properly aligned.\n\n Additionally, note that changing `*dst` in this way can easily lead to undefined behavior (UB)\n later if the written bytes are not a valid representation of some `T`. For instance, the\n following is an **incorrect** use of this function:\n\n ```rust,no_run\n unsafe {\n     let mut value: u8 = 0;\n     let ptr: *mut bool = &mut value as *mut u8 as *mut bool;\n     let _bool = ptr.read(); // This is fine, `ptr` points to a valid `bool`.\n     ptr.write_bytes(42u8, 1); // This function itself does not cause UB...\n     let _bool = ptr.read(); // ...but it makes this operation UB! ⚠️\n }\n ```\n\n [valid]: crate::ptr#safety\n\n # Examples\n\n Basic usage:\n\n ```\n use std::ptr;\n\n let mut vec = vec![0u32; 4];\n unsafe {\n     let vec_ptr = vec.as_mut_ptr();\n     ptr::write_bytes(vec_ptr, 0xfe, 2);\n }\n assert_eq!(vec, [0xfefefefe, 0xfefefefe, 0, 0]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}