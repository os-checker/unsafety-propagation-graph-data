{
  "name": "ptr::const_ptr::<impl *const T>::guaranteed_ne",
  "safe": true,
  "callees": {
    "ptr::const_ptr::<impl *const T>::guaranteed_eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether two pointers are guaranteed to be equal.\n\n At runtime this function behaves like `Some(self == other)`.\n However, in some contexts (e.g., compile-time evaluation),\n it is not always possible to determine equality of two pointers, so this function may\n spuriously return `None` for pointers that later actually turn out to have its equality known.\n But when it returns `Some`, the pointers' equality is guaranteed to be known.\n\n The return value may change from `Some` to `None` and vice versa depending on the compiler\n version and unsafe code must not\n rely on the result of this function for soundness. It is suggested to only use this function\n for performance optimizations where spurious `None` return values by this function do not\n affect the outcome, but just the performance.\n The consequences of using this method to make runtime and compile-time code behave\n differently have not been explored. This method should not be used to introduce such\n differences, and it should also not be stabilized before we have a better understanding\n of this issue.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3, kind: RigidTy(Bool) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::ptr::const_ptr::<impl *const T>::guaranteed_ne"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:801:5: 809:6",
  "src": "pub const fn guaranteed_ne(self, other: *const T) -> Option<bool>\n    where\n        T: Sized,\n    {\n        match self.guaranteed_eq(other) {\n            None => None,\n            Some(eq) => Some(!eq),\n        }\n    }",
  "mir": "fn ptr::const_ptr::<impl *const T>::guaranteed_ne(_1: *const T, _2: *const T) -> option::Option<bool> {\n    let mut _0: option::Option<bool>;\n    let mut _3: option::Option<bool>;\n    let mut _4: isize;\n    let  _5: bool;\n    let mut _6: bool;\n    debug self => _1;\n    debug other => _2;\n    debug eq => _5;\n    bb0: {\n        StorageLive(_3);\n        _3 = ptr::const_ptr::<impl *const T>::guaranteed_eq(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = discriminant(_3);\n        switchInt(move _4) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _5 = ((_3 as variant#1).0: bool);\n        StorageLive(_6);\n        _6 = Not(_5);\n        _0 = option::Option::Some(move _6);\n        StorageDead(_6);\n        goto -> bb5;\n    }\n    bb4: {\n        _0 = option::Option::None;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns whether two pointers are guaranteed to be inequal.\n\n At runtime this function behaves like `Some(self != other)`.\n However, in some contexts (e.g., compile-time evaluation),\n it is not always possible to determine inequality of two pointers, so this function may\n spuriously return `None` for pointers that later actually turn out to have its inequality known.\n But when it returns `Some`, the pointers' inequality is guaranteed to be known.\n\n The return value may change from `Some` to `None` and vice versa depending on the compiler\n version and unsafe code must not\n rely on the result of this function for soundness. It is suggested to only use this function\n for performance optimizations where spurious `None` return values by this function do not\n affect the outcome, but just the performance.\n The consequences of using this method to make runtime and compile-time code behave\n differently have not been explored. This method should not be used to introduce such\n differences, and it should also not be stabilized before we have a better understanding\n of this issue.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}