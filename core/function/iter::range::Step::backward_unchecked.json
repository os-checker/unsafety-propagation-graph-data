{
  "name": "iter::range::Step::backward_unchecked",
  "safe": false,
  "callees": {
    "iter::range::Step::backward": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value that would be obtained by taking the *predecessor*\n of `self` `count` times.\n\n If this would overflow the range of values supported by `Self`,\n this function is allowed to panic, wrap, or saturate.\n The suggested behavior is to panic when debug assertions are enabled,\n and to wrap or saturate otherwise.\n\n Unsafe code should not rely on the correctness of behavior after overflow.\n\n # Invariants\n\n For any `a`, `n`, and `m`, where no overflow occurs:\n\n * `Step::backward(Step::backward(a, n), m) == Step::backward(a, n + m)`\n\n For any `a` and `n`, where no overflow occurs:\n\n * `Step::backward_checked(a, n) == Some(Step::backward(a, n))`\n * `Step::backward(a, n) == (0..n).fold(a, |x, _| Step::backward(x, 1))`\n   * Corollary: `Step::backward(a, 0) == a`\n * `Step::backward(a, n) <= a`\n * `Step::forward(Step::backward(a, n), n) == a`\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": "iter::range::Step::backward_unchecked",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/range.rs:178:5: 180:6",
  "src": "unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n        Step::backward(start, count)\n    }",
  "mir": "fn iter::range::Step::backward_unchecked(_1: Self, _2: usize) -> Self {\n    let mut _0: Self;\n    debug start => _1;\n    debug count => _2;\n    bb0: {\n        _0 = <Self as iter::range::Step>::backward(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Returns the value that would be obtained by taking the *predecessor*\n of `self` `count` times.\n\n # Safety\n\n It is undefined behavior for this operation to overflow the\n range of values supported by `Self`. If you cannot guarantee that this\n will not overflow, use `backward` or `backward_checked` instead.\n\n # Invariants\n\n For any `a`:\n\n * if there exists `b` such that `b < a`, it is safe to call `Step::backward_unchecked(a, 1)`\n * if there exists `b`, `n` such that `steps_between(&b, &a) == (n, Some(n))`,\n   it is safe to call `Step::backward_unchecked(a, m)` for any `m <= n`.\n   * Corollary: `Step::backward_unchecked(a, 0)` is always safe.\n\n For any `a` and `n`, where no overflow occurs:\n\n * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}