{
  "name": "<iter::adapters::take::Take<I> as iter::traits::double_ended::DoubleEndedIterator>::advance_back_by",
  "safe": true,
  "callees": {
    "iter::traits::exact_size::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "num::<impl usize>::saturating_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer subtraction. Computes `self - rhs`, saturating\n at the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl usize>::saturating_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "iter::traits::double_ended::DoubleEndedIterator::advance_back_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator from the back by `n` elements.\n\n `advance_back_by` is the reverse version of [`advance_by`]. This method will\n eagerly skip `n` elements starting from the back by calling [`next_back`] up\n to `n` times until [`None`] is encountered.\n\n `advance_back_by(n)` will return `Ok(())` if the iterator successfully advances by\n `n` elements, or a `Err(NonZero<usize>)` with value `k` if [`None`] is encountered, where `k`\n is remaining number of steps that could not be advanced because the iterator ran out.\n If `self` is empty and `n` is non-zero, then this returns `Err(n)`.\n Otherwise, `k` is always less than `n`.\n\n Calling `advance_back_by(0)` can do meaningful work, for example [`Flatten`] can advance its\n outer iterator until it finds an inner iterator that is not empty, which then often\n allows it to return a more accurate `size_hint()` than in its initial state.\n\n [`advance_by`]: Iterator::advance_by\n [`Flatten`]: crate::iter::Flatten\n [`next_back`]: DoubleEndedIterator::next_back\n\n # Examples\n\n Basic usage:\n\n ```\n #![feature(iter_advance_by)]\n\n use std::num::NonZero;\n\n let a = [3, 4, 5, 6];\n let mut iter = a.iter();\n\n assert_eq!(iter.advance_back_by(2), Ok(()));\n assert_eq!(iter.next_back(), Some(&4));\n assert_eq!(iter.advance_back_by(0), Ok(()));\n assert_eq!(iter.advance_back_by(100), Err(NonZero::new(99).unwrap())); // only `&3` was skipped\n ```\n\n [`Ok(())`]: Ok\n [`Err(k)`]: Err\n",
      "adt": {
        "result::Result": "Constructor",
        "num::nonzero::NonZero": "Constructor"
      }
    },
    "num::nonzero::NonZero::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained value as a primitive type.\n",
      "adt": {}
    },
    "num::nonzero::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {
        "num::nonzero::NonZero": "Constructor",
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::map_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the provided default result (if none),\n or applies a function to the contained value (if any).\n\n Arguments passed to `map_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`map_or_else`],\n which is lazily evaluated.\n\n [`map_or_else`]: Option::map_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.map_or(42, |v| v.len()), 3);\n\n let x: Option<&str> = None;\n assert_eq!(x.map_or(42, |v| v.len()), 42);\n ```\n",
      "adt": {}
    },
    "result::Result::Err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Contains the error value\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::take::Take": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1742, kind: RigidTy(Adt(AdtDef(DefId { id: 24832, name: \"num::nonzero::NonZero\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "num::nonzero::NonZero": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::take::Take<I> as iter::traits::double_ended::DoubleEndedIterator>::advance_back_by"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/take.rs:220:5: 237:6",
  "src": "fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        // The amount by which the inner iterator needs to be shortened for it to be\n        // at most as long as the take() amount.\n        let trim_inner = self.iter.len().saturating_sub(self.n);\n        // The amount we need to advance inner to fulfill the caller's request.\n        // take(), advance_by() and len() all can be at most usize, so we don't have to worry\n        // about having to advance more than usize::MAX here.\n        let advance_by = trim_inner.saturating_add(n);\n\n        let remainder = match self.iter.advance_back_by(advance_by) {\n            Ok(()) => 0,\n            Err(rem) => rem.get(),\n        };\n        let advanced_by_inner = advance_by - remainder;\n        let advanced_by = advanced_by_inner - trim_inner;\n        self.n -= advanced_by;\n        NonZero::new(n - advanced_by).map_or(Ok(()), Err)\n    }",
  "mir": "fn <iter::adapters::take::Take<I> as iter::traits::double_ended::DoubleEndedIterator>::advance_back_by(_1: &mut iter::adapters::take::Take<I>, _2: usize) -> result::Result<(), num::nonzero::NonZero<usize>> {\n    let mut _0: result::Result<(), num::nonzero::NonZero<usize>>;\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: &I;\n    let mut _6: usize;\n    let  _7: usize;\n    let  _8: usize;\n    let mut _9: result::Result<(), num::nonzero::NonZero<usize>>;\n    let mut _10: &mut I;\n    let mut _11: isize;\n    let  _12: num::nonzero::NonZero<usize>;\n    let  _13: usize;\n    let mut _14: usize;\n    let mut _15: (usize, bool);\n    let  _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: (usize, bool);\n    let mut _19: option::Option<num::nonzero::NonZero<usize>>;\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: result::Result<(), num::nonzero::NonZero<usize>>;\n    debug self => _1;\n    debug n => _2;\n    debug trim_inner => _3;\n    debug advance_by => _7;\n    debug remainder => _8;\n    debug rem => _12;\n    debug advanced_by_inner => _13;\n    debug advanced_by => _16;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: I);\n        _4 = <I as iter::traits::exact_size::ExactSizeIterator>::len(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = ((*_1).1: usize);\n        _3 = num::<impl usize>::saturating_sub(move _4, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_4);\n        _7 = num::<impl usize>::saturating_add(_3, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut ((*_1).0: I);\n        _9 = <I as iter::traits::double_ended::DoubleEndedIterator>::advance_back_by(move _10, _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [0: bb7, 1: bb6, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _12 = ((_9 as variant#1).0: num::nonzero::NonZero<usize>);\n        _8 = num::nonzero::NonZero::<usize>::get(_12) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        _8 = 0_usize;\n        goto -> bb9;\n    }\n    bb8: {\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageLive(_14);\n        _14 = _8;\n        _15 = CheckedSub(_7, _14);\n        assert(!move (_15.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _7, move _14) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _13 = move (_15.0: usize);\n        StorageDead(_14);\n        _17 = CheckedSub(_13, _3);\n        assert(!move (_17.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _13, _3) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _16 = move (_17.0: usize);\n        _18 = CheckedSub(((*_1).1: usize), _16);\n        assert(!move (_18.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_1).1: usize), _16) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        ((*_1).1: usize) = move (_18.0: usize);\n        StorageLive(_19);\n        StorageLive(_20);\n        _21 = CheckedSub(_2, _16);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, _16) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_21.0: usize);\n        _19 = num::nonzero::NonZero::<usize>::new(move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = result::Result::Ok(());\n        _0 = option::Option::<num::nonzero::NonZero<usize>>::map_or::<result::Result<(), num::nonzero::NonZero<usize>>, fn(num::nonzero::NonZero<usize>) -> result::Result<(), num::nonzero::NonZero<usize>> {result::Result::<(), num::nonzero::NonZero<usize>>::Err}>(move _19, move _22, result::Result::<(), num::nonzero::NonZero<usize>>::Err) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_19);\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}