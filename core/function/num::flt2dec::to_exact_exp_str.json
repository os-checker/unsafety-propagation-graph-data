{
  "name": "num::flt2dec::to_exact_exp_str",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::flt2dec::decoder::decode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "Constructor"
      }
    },
    "num::flt2dec::determine_sign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the static byte string corresponding to the sign to be formatted.\n It can be either `\"\"`, `\"+\"` or `\"-\"`.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "MutableAsArgument"
      }
    },
    "num::flt2dec::estimate_max_buf_len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a rather crude approximation (upper bound) for the maximum buffer size\n calculated from the given decoded exponent.\n\n The exact limit is:\n\n - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n\n `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n enough for our purposes.\n\n Why do we need this? `format_exact` functions will fill the entire buffer\n unless limited by the last digit restriction, but it is possible that\n the number of digits requested is ridiculously large (say, 30,000 digits).\n The vast majority of buffer will be filled with zeroes, so we don't want to\n allocate all the buffer beforehand. Consequently, for any given arguments,\n 826 bytes of buffer should be sufficient for `f64`. Compare this with\n the actual number for the worst case: 770 bytes (when `exp = -1074`).\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "num::flt2dec::digits_to_exp_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n form with at least the given number of significant digits. When `upper` is `true`,\n the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n stored to the supplied parts array and a slice of written parts is returned.\n\n `min_digits` can be less than the number of actual significant digits in `buf`;\n it will be ignored and full digits will be printed. It is only used to print\n additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n it will only print the given digits and nothing else.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::flt2dec::decoder::FullDecoded": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3, kind: RigidTy(Bool) })])",
      "Unknown([Field(1, Ty { id: 759, kind: RigidTy(Adt(AdtDef(DefId { id: 24675, name: \"num::flt2dec::decoder::FullDecoded\" }), GenericArgs([]))) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(3, ThreadLocalIndex)), Field(0, Ty { id: 760, kind: RigidTy(Adt(AdtDef(DefId { id: 24674, name: \"num::flt2dec::decoder::Decoded\" }), GenericArgs([]))) })])"
    ],
    "num::flt2dec::Sign": [
      "Plain"
    ],
    "num::flt2dec::decoder::Decoded": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "num::fmt::Part": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "num::fmt::Formatted": [
      "Plain"
    ]
  },
  "path": 14879,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/mod.rs:510:1: 568:2",
  "src": "pub fn to_exact_exp_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    ndigits: usize,\n    upper: bool,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 6);\n    assert!(ndigits > 0);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            if ndigits > 1 {\n                // [0.][0000][e0]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(ndigits - 1));\n                parts[2] = MaybeUninit::new(Part::Copy(if upper { b\"E0\" } else { b\"e0\" }));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..3`.\n                    parts: unsafe { parts[..3].assume_init_ref() },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { parts[..1].assume_init_ref() },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let maxlen = estimate_max_buf_len(decoded.exp);\n            assert!(buf.len() >= ndigits || buf.len() >= maxlen);\n\n            let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n            let (buf, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n            Formatted { sign, parts: digits_to_exp_str(buf, exp, ndigits, upper, parts) }\n        }\n    }\n}",
  "mir": "fn num::flt2dec::to_exact_exp_str(_1: F, _2: T, _3: num::flt2dec::Sign, _4: usize, _5: bool, _6: &mut [mem::maybe_uninit::MaybeUninit<u8>], _7: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]) -> num::fmt::Formatted<'_> {\n    let mut _0: num::fmt::Formatted<'_>;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: !;\n    let  _14: bool;\n    let  _15: num::flt2dec::decoder::FullDecoded;\n    let mut _16: (bool, num::flt2dec::decoder::FullDecoded);\n    let  _17: &str;\n    let  _18: &num::flt2dec::decoder::FullDecoded;\n    let mut _19: isize;\n    let mut _20: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _21: num::fmt::Part<'_>;\n    let mut _22: &[u8];\n    let mut _23: &[u8; 3];\n    let  _24: usize;\n    let mut _25: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _26: usize;\n    let mut _27: bool;\n    let  _28: &[num::fmt::Part<'_>];\n    let  _29: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _30: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _31: ops::range::RangeTo<usize>;\n    let mut _32: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _33: num::fmt::Part<'_>;\n    let mut _34: &[u8];\n    let mut _35: &[u8; 3];\n    let  _36: usize;\n    let mut _37: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _38: usize;\n    let mut _39: bool;\n    let  _40: &[num::fmt::Part<'_>];\n    let  _41: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _42: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _43: ops::range::RangeTo<usize>;\n    let mut _44: bool;\n    let mut _45: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _46: num::fmt::Part<'_>;\n    let mut _47: &[u8];\n    let mut _48: &[u8; 2];\n    let  _49: usize;\n    let mut _50: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _51: usize;\n    let mut _52: bool;\n    let mut _53: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _54: num::fmt::Part<'_>;\n    let mut _55: usize;\n    let mut _56: (usize, bool);\n    let  _57: usize;\n    let mut _58: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _59: usize;\n    let mut _60: bool;\n    let mut _61: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _62: num::fmt::Part<'_>;\n    let mut _63: &[u8];\n    let mut _64: &[u8; 2];\n    let mut _65: &[u8; 2];\n    let  _66: usize;\n    let mut _67: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _68: usize;\n    let mut _69: bool;\n    let  _70: &[num::fmt::Part<'_>];\n    let  _71: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _72: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _73: ops::range::RangeTo<usize>;\n    let mut _74: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _75: num::fmt::Part<'_>;\n    let mut _76: &[u8];\n    let mut _77: &[u8; 3];\n    let mut _78: &[u8; 3];\n    let  _79: usize;\n    let mut _80: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _81: usize;\n    let mut _82: bool;\n    let  _83: &[num::fmt::Part<'_>];\n    let  _84: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _85: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _86: ops::range::RangeTo<usize>;\n    let  _87: &num::flt2dec::decoder::Decoded;\n    let  _88: usize;\n    let mut _89: i16;\n    let mut _90: bool;\n    let mut _91: usize;\n    let mut _92: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _93: bool;\n    let mut _94: usize;\n    let mut _95: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _96: !;\n    let  _97: usize;\n    let mut _98: bool;\n    let  _99: &[u8];\n    let  _100: i16;\n    let mut _101: (&[u8], i16);\n    let mut _102: &mut F;\n    let mut _103: (&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>], i16);\n    let mut _104: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _105: ops::range::RangeTo<usize>;\n    let mut _106: usize;\n    let  _107: &[num::fmt::Part<'_>];\n    debug format_exact => _1;\n    debug v => _2;\n    debug sign => _3;\n    debug ndigits => _4;\n    debug upper => _5;\n    debug buf => _6;\n    debug parts => _7;\n    debug negative => _14;\n    debug full_decoded => _15;\n    debug sign => _17;\n    debug decoded => _87;\n    debug maxlen => _88;\n    debug trunc => _97;\n    debug buf => _99;\n    debug exp => _100;\n    bb0: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_7);\n        _9 = PtrMetadata(move _10);\n        StorageDead(_10);\n        _8 = Ge(move _9, 6_usize);\n        switchInt(move _8) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_12);\n        _12 = Gt(_4, 0_usize);\n        switchInt(move _12) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_9);\n        _11 = panicking::panic(\"assertion failed: parts.len() >= 6\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_12);\n        StorageLive(_16);\n        _16 = num::flt2dec::decoder::decode::<T>(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        _13 = panicking::panic(\"assertion failed: ndigits > 0\") -> unwind unreachable;\n    }\n    bb5: {\n        _14 = (_16.0: bool);\n        StorageLive(_15);\n        _15 = (_16.1: num::flt2dec::decoder::FullDecoded);\n        StorageDead(_16);\n        _18 = &_15;\n        _17 = num::flt2dec::determine_sign(_3, _18, _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _19 = discriminant(_15);\n        switchInt(move _19) -> [0: bb11, 1: bb10, 2: bb9, 3: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _87 = &((_15 as variant#3).0: num::flt2dec::decoder::Decoded);\n        StorageLive(_89);\n        _89 = ((*_87).3: i16);\n        _88 = num::flt2dec::estimate_max_buf_len(move _89) -> [return: bb42, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_44);\n        _44 = Gt(_4, 1_usize);\n        switchInt(move _44) -> [0: bb33, otherwise: bb20];\n    }\n    bb10: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = b\"inf\";\n        _34 = move _35 as &[u8];\n        StorageDead(_35);\n        _33 = num::fmt::Part::Copy(move _34);\n        StorageDead(_34);\n        _32 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _33) -> [return: bb16, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = b\"NaN\";\n        _22 = move _23 as &[u8];\n        StorageDead(_23);\n        _21 = num::fmt::Part::Copy(move _22);\n        StorageDead(_22);\n        _20 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_21);\n        StorageLive(_24);\n        _24 = 0_usize;\n        _25 = &raw const (fake) (*_7);\n        _26 = PtrMetadata(move _25);\n        _27 = Lt(_24, _26);\n        assert(move _27, \"index out of bounds: the length is {} but the index is {}\", move _26, _24) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        (*_7)[_24] = move _20;\n        StorageDead(_20);\n        StorageDead(_24);\n        StorageLive(_30);\n        _30 = &(*_7);\n        StorageLive(_31);\n        _31 = RangeTo(1_usize);\n        _29 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _30, move _31) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_31);\n        StorageDead(_30);\n        _28 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_29) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _0 = Formatted(_17, _28);\n        goto -> bb54;\n    }\n    bb16: {\n        StorageDead(_33);\n        StorageLive(_36);\n        _36 = 0_usize;\n        _37 = &raw const (fake) (*_7);\n        _38 = PtrMetadata(move _37);\n        _39 = Lt(_36, _38);\n        assert(move _39, \"index out of bounds: the length is {} but the index is {}\", move _38, _36) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        (*_7)[_36] = move _32;\n        StorageDead(_32);\n        StorageDead(_36);\n        StorageLive(_42);\n        _42 = &(*_7);\n        StorageLive(_43);\n        _43 = RangeTo(1_usize);\n        _41 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _42, move _43) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_43);\n        StorageDead(_42);\n        _40 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_41) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _0 = Formatted(_17, _40);\n        goto -> bb54;\n    }\n    bb20: {\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = b\"0.\";\n        _47 = move _48 as &[u8];\n        StorageDead(_48);\n        _46 = num::fmt::Part::Copy(move _47);\n        StorageDead(_47);\n        _45 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _46) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_46);\n        StorageLive(_49);\n        _49 = 0_usize;\n        _50 = &raw const (fake) (*_7);\n        _51 = PtrMetadata(move _50);\n        _52 = Lt(_49, _51);\n        assert(move _52, \"index out of bounds: the length is {} but the index is {}\", move _51, _49) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        (*_7)[_49] = move _45;\n        StorageDead(_45);\n        StorageDead(_49);\n        StorageLive(_53);\n        StorageLive(_54);\n        StorageLive(_55);\n        _56 = CheckedSub(_4, 1_usize);\n        assert(!move (_56.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, 1_usize) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _55 = move (_56.0: usize);\n        _54 = num::fmt::Part::Zero(move _55);\n        StorageDead(_55);\n        _53 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _54) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_54);\n        StorageLive(_57);\n        _57 = 1_usize;\n        _58 = &raw const (fake) (*_7);\n        _59 = PtrMetadata(move _58);\n        _60 = Lt(_57, _59);\n        assert(move _60, \"index out of bounds: the length is {} but the index is {}\", move _59, _57) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        (*_7)[_57] = move _53;\n        StorageDead(_53);\n        StorageDead(_57);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        switchInt(_5) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageLive(_64);\n        _64 = b\"E0\";\n        _63 = move _64 as &[u8];\n        StorageDead(_64);\n        goto -> bb28;\n    }\n    bb27: {\n        StorageLive(_65);\n        _65 = b\"e0\";\n        _63 = move _65 as &[u8];\n        StorageDead(_65);\n        goto -> bb28;\n    }\n    bb28: {\n        _62 = num::fmt::Part::Copy(move _63);\n        StorageDead(_63);\n        _61 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _62) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_62);\n        StorageLive(_66);\n        _66 = 2_usize;\n        _67 = &raw const (fake) (*_7);\n        _68 = PtrMetadata(move _67);\n        _69 = Lt(_66, _68);\n        assert(move _69, \"index out of bounds: the length is {} but the index is {}\", move _68, _66) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        (*_7)[_66] = move _61;\n        StorageDead(_61);\n        StorageDead(_66);\n        StorageLive(_72);\n        _72 = &(*_7);\n        StorageLive(_73);\n        _73 = RangeTo(3_usize);\n        _71 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _72, move _73) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_73);\n        StorageDead(_72);\n        _70 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_71) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _0 = Formatted(_17, _70);\n        goto -> bb41;\n    }\n    bb33: {\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        switchInt(_5) -> [0: bb35, otherwise: bb34];\n    }\n    bb34: {\n        StorageLive(_77);\n        _77 = b\"0E0\";\n        _76 = move _77 as &[u8];\n        StorageDead(_77);\n        goto -> bb36;\n    }\n    bb35: {\n        StorageLive(_78);\n        _78 = b\"0e0\";\n        _76 = move _78 as &[u8];\n        StorageDead(_78);\n        goto -> bb36;\n    }\n    bb36: {\n        _75 = num::fmt::Part::Copy(move _76);\n        StorageDead(_76);\n        _74 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _75) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_75);\n        StorageLive(_79);\n        _79 = 0_usize;\n        _80 = &raw const (fake) (*_7);\n        _81 = PtrMetadata(move _80);\n        _82 = Lt(_79, _81);\n        assert(move _82, \"index out of bounds: the length is {} but the index is {}\", move _81, _79) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        (*_7)[_79] = move _74;\n        StorageDead(_74);\n        StorageDead(_79);\n        StorageLive(_85);\n        _85 = &(*_7);\n        StorageLive(_86);\n        _86 = RangeTo(1_usize);\n        _84 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _85, move _86) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_86);\n        StorageDead(_85);\n        _83 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_84) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _0 = Formatted(_17, _83);\n        goto -> bb41;\n    }\n    bb41: {\n        StorageDead(_44);\n        goto -> bb54;\n    }\n    bb42: {\n        StorageDead(_89);\n        StorageLive(_90);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = &(*_6);\n        _91 = PtrMetadata(move _92);\n        StorageDead(_92);\n        _90 = Ge(move _91, _4);\n        switchInt(move _90) -> [0: bb44, otherwise: bb43];\n    }\n    bb43: {\n        StorageDead(_91);\n        goto -> bb47;\n    }\n    bb44: {\n        StorageDead(_91);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = &(*_6);\n        _94 = PtrMetadata(move _95);\n        StorageDead(_95);\n        _93 = Ge(move _94, _88);\n        switchInt(move _93) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_94);\n        goto -> bb47;\n    }\n    bb46: {\n        StorageDead(_94);\n        _96 = panicking::panic(\"assertion failed: buf.len() >= ndigits || buf.len() >= maxlen\") -> unwind unreachable;\n    }\n    bb47: {\n        StorageDead(_93);\n        StorageDead(_90);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = Lt(_4, _88);\n        switchInt(move _98) -> [0: bb49, otherwise: bb48];\n    }\n    bb48: {\n        _97 = _4;\n        goto -> bb50;\n    }\n    bb49: {\n        _97 = _88;\n        goto -> bb50;\n    }\n    bb50: {\n        StorageDead(_98);\n        StorageLive(_101);\n        StorageLive(_102);\n        _102 = &mut _1;\n        StorageLive(_103);\n        StorageLive(_105);\n        StorageLive(_106);\n        _106 = _97;\n        _105 = RangeTo(move _106);\n        StorageDead(_106);\n        _104 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_6, move _105) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_105);\n        _103 = (_87, _104, num::<impl i16>::MIN);\n        _101 = <F as ops::function::FnMut<(&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>], i16)>>::call_mut(move _102, move _103) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_103);\n        StorageDead(_102);\n        _99 = (_101.0: &[u8]);\n        _100 = (_101.1: i16);\n        StorageDead(_101);\n        _107 = num::flt2dec::digits_to_exp_str(_99, _100, _4, _5, _7) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        _0 = Formatted(_17, _107);\n        StorageDead(_97);\n        goto -> bb54;\n    }\n    bb54: {\n        StorageDead(_15);\n        drop(_1) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        return;\n    }\n}\n",
  "doc": " Formats given floating point number into the exponential form with\n exactly given number of significant digits. The result is stored to\n the supplied parts array while utilizing given byte buffer as a scratch.\n `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).\n\n `format_exact` should be the underlying digit-generation function.\n It should return the part of the buffer that it initialized.\n You probably would want `strategy::grisu::format_exact` for this.\n\n The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n so large that only the fixed number of digits will be ever written.\n (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n There should be at least 6 parts available, due to the worst case like\n `[+][1][.][2345][e][-][6]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}