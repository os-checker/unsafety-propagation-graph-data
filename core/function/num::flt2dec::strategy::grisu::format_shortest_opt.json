{
  "name": "num::flt2dec::strategy::grisu::format_shortest_opt",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::<impl u64>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {
        "option::Option": "MutableAsArgument"
      }
    },
    "num::<impl u64>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::diy_float::Fp::normalize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Normalizes itself so that the resulting mantissa is at least `2^63`.\n",
      "adt": {
        "num::diy_float::Fp": "Constructor"
      }
    },
    "num::diy_float::Fp::normalize_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Normalizes itself to have the shared exponent.\n It can only decrease the exponent (and thus increase the mantissa).\n",
      "adt": {
        "num::diy_float::Fp": "Constructor"
      }
    },
    "num::flt2dec::strategy::grisu::cached_power": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": "",
      "adt": {
        "num::diy_float::Fp": "Constructor"
      }
    },
    "num::diy_float::Fp::mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a correctly rounded product of itself and `other`.\n",
      "adt": {
        "num::diy_float::Fp": "Constructor"
      }
    },
    "panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "num::flt2dec::strategy::grisu::max_pow10_no_more_than": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable (unique) reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in the\n slice really is in an initialized state. For instance, `.assume_init_mut()` cannot\n be used to initialize a `MaybeUninit` slice.\n",
      "adt": {}
    },
    "num::flt2dec::strategy::grisu::format_shortest_opt::round_and_weed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "num::flt2dec::decoder::Decoded": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Ref"
    ],
    "num::diy_float::Fp": [
      "Plain",
      "Unknown([Field(1, Ty { id: 178, kind: RigidTy(Int(I16)) })])",
      "Unknown([Field(0, Ty { id: 178, kind: RigidTy(Int(I16)) })])",
      "Unknown([Field(1, Ty { id: 738, kind: RigidTy(Adt(AdtDef(DefId { id: 24664, name: \"num::diy_float::Fp\" }), GenericArgs([]))) })])",
      "Unknown([Field(0, Ty { id: 325, kind: RigidTy(Uint(U64)) })])"
    ],
    "panicking::AssertKind": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::strategy::grisu::format_shortest_opt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/strategy/grisu.rs:165:1: 449:2",
  "src": "pub fn format_shortest_opt<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> Option<(/*digits*/ &'a [u8], /*exp*/ i16)> {\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n    assert!(d.mant + d.plus < (1 << 61)); // we need at least three bits of additional precision\n\n    // start with the normalized values with the shared exponent\n    let plus = Fp { f: d.mant + d.plus, e: d.exp }.normalize();\n    let minus = Fp { f: d.mant - d.minus, e: d.exp }.normalize_to(plus.e);\n    let v = Fp { f: d.mant, e: d.exp }.normalize_to(plus.e);\n\n    // find any `cached = 10^minusk` such that `ALPHA <= minusk + plus.e + 64 <= GAMMA`.\n    // since `plus` is normalized, this means `2^(62 + ALPHA) <= plus * cached < 2^(64 + GAMMA)`;\n    // given our choices of `ALPHA` and `GAMMA`, this puts `plus * cached` into `[4, 2^32)`.\n    //\n    // it is obviously desirable to maximize `GAMMA - ALPHA`,\n    // so that we don't need many cached powers of 10, but there are some considerations:\n    //\n    // 1. we want to keep `floor(plus * cached)` within `u32` since it needs a costly division.\n    //    (this is not really avoidable, remainder is required for accuracy estimation.)\n    // 2. the remainder of `floor(plus * cached)` repeatedly gets multiplied by 10,\n    //    and it should not overflow.\n    //\n    // the first gives `64 + GAMMA <= 32`, while the second gives `10 * 2^-ALPHA <= 2^64`;\n    // -60 and -32 is the maximal range with this constraint, and V8 also uses them.\n    let (minusk, cached) = cached_power(ALPHA - plus.e - 64, GAMMA - plus.e - 64);\n\n    // scale fps. this gives the maximal error of 1 ulp (proved from Theorem 5.1).\n    let plus = plus.mul(cached);\n    let minus = minus.mul(cached);\n    let v = v.mul(cached);\n    debug_assert_eq!(plus.e, minus.e);\n    debug_assert_eq!(plus.e, v.e);\n\n    //         +- actual range of minus\n    //   | <---|---------------------- unsafe region --------------------------> |\n    //   |     |                                                                 |\n    //   |  |<--->|  | <--------------- safe region ---------------> |           |\n    //   |  |     |  |                                               |           |\n    //   |1 ulp|1 ulp|                 |1 ulp|1 ulp|                 |1 ulp|1 ulp|\n    //   |<--->|<--->|                 |<--->|<--->|                 |<--->|<--->|\n    //   |-----|-----|-------...-------|-----|-----|-------...-------|-----|-----|\n    //   |   minus   |                 |     v     |                 |   plus    |\n    // minus1     minus0           v - 1 ulp   v + 1 ulp           plus0       plus1\n    //\n    // above `minus`, `v` and `plus` are *quantized* approximations (error < 1 ulp).\n    // as we don't know the error is positive or negative, we use two approximations spaced equally\n    // and have the maximal error of 2 ulps.\n    //\n    // the \"unsafe region\" is a liberal interval which we initially generate.\n    // the \"safe region\" is a conservative interval which we only accept.\n    // we start with the correct repr within the unsafe region, and try to find the closest repr\n    // to `v` which is also within the safe region. if we can't, we give up.\n    let plus1 = plus.f + 1;\n    //  let plus0 = plus.f - 1; // only for explanation\n    //  let minus0 = minus.f + 1; // only for explanation\n    let minus1 = minus.f - 1;\n    let e = -plus.e as usize; // shared exponent\n\n    // divide `plus1` into integral and fractional parts.\n    // integral parts are guaranteed to fit in u32, since cached power guarantees `plus < 2^32`\n    // and normalized `plus.f` is always less than `2^64 - 2^4` due to the precision requirement.\n    let plus1int = (plus1 >> e) as u32;\n    let plus1frac = plus1 & ((1 << e) - 1);\n\n    // calculate the largest `10^max_kappa` no more than `plus1` (thus `plus1 < 10^(max_kappa+1)`).\n    // this is an upper bound of `kappa` below.\n    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(plus1int);\n\n    let mut i = 0;\n    let exp = max_kappa as i16 - minusk + 1;\n\n    // Theorem 6.2: if `k` is the greatest integer s.t. `0 <= y mod 10^k <= y - x`,\n    //              then `V = floor(y / 10^k) * 10^k` is in `[x, y]` and one of the shortest\n    //              representations (with the minimal number of significant digits) in that range.\n    //\n    // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n    // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n    // (e.g., `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n    // the algorithm relies on the later verification phase to exclude `y`.\n    let delta1 = plus1 - minus1;\n    //  let delta1int = (delta1 >> e) as usize; // only for explanation\n    let delta1frac = delta1 & ((1 << e) - 1);\n\n    // render integral parts, while checking for the accuracy at each step.\n    let mut ten_kappa = max_ten_kappa; // 10^kappa\n    let mut remainder = plus1int; // digits yet to be rendered\n    loop {\n        // we always have at least one digit to render, as `plus1 >= 10^kappa`\n        // invariants:\n        // - `delta1int <= remainder < 10^(kappa+1)`\n        // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n        //   (it follows that `remainder = plus1int % 10^(kappa+1)`)\n\n        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n        let q = remainder / ten_kappa;\n        let r = remainder % ten_kappa;\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        let plus1rem = ((r as u64) << e) + plus1frac; // == (plus1 % 10^kappa) * 2^e\n        if plus1rem < delta1 {\n            // `plus1 % 10^kappa < delta1 = plus1 - minus1`; we've found the correct `kappa`.\n            let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n            return round_and_weed(\n                // SAFETY: we initialized that memory above.\n                unsafe { buf[..i].assume_init_mut() },\n                exp,\n                plus1rem,\n                delta1,\n                plus1 - v.f,\n                ten_kappa,\n                1,\n            );\n        }\n\n        // break the loop when we have rendered all integral digits.\n        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n        if i > max_kappa as usize {\n            debug_assert_eq!(ten_kappa, 1);\n            break;\n        }\n\n        // restore invariants\n        ten_kappa /= 10;\n        remainder = r;\n    }\n\n    // render fractional parts, while checking for the accuracy at each step.\n    // this time we rely on repeated multiplications, as division will lose the precision.\n    let mut remainder = plus1frac;\n    let mut threshold = delta1frac;\n    let mut ulp = 1;\n    loop {\n        // the next digit should be significant as we've tested that before breaking out\n        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n        // - `remainder < 2^e`\n        // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n\n        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n        threshold *= 10;\n        ulp *= 10;\n\n        // divide `remainder` by `10^kappa`.\n        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n        let q = remainder >> e;\n        let r = remainder & ((1 << e) - 1);\n        debug_assert!(q < 10);\n        buf[i] = MaybeUninit::new(b'0' + q as u8);\n        i += 1;\n\n        if r < threshold {\n            let ten_kappa = 1 << e; // implicit divisor\n            return round_and_weed(\n                // SAFETY: we initialized that memory above.\n                unsafe { buf[..i].assume_init_mut() },\n                exp,\n                r,\n                threshold,\n                (plus1 - v.f) * ulp,\n                ten_kappa,\n                ulp,\n            );\n        }\n\n        // restore invariants\n        remainder = r;\n    }\n\n    // we've generated all significant digits of `plus1`, but not sure if it's the optimal one.\n    // for example, if `minus1` is 3.14153... and `plus1` is 3.14158..., there are 5 different\n    // shortest representation from 3.14154 to 3.14158 but we only have the greatest one.\n    // we have to successively decrease the last digit and check if this is the optimal repr.\n    // there are at most 9 candidates (..1 to ..9), so this is fairly quick. (\"rounding\" phase)\n    //\n    // the function checks if this \"optimal\" repr is actually within the ulp ranges,\n    // and also, it is possible that the \"second-to-optimal\" repr can actually be optimal\n    // due to the rounding error. in either cases this returns `None`. (\"weeding\" phase)\n    //\n    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n    // - `remainder = (plus1 % 10^kappa) * k`\n    // - `threshold = (plus1 - minus1) * k` (and also, `remainder < threshold`)\n    // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n    // - `ten_kappa = 10^kappa * k`\n    // - `ulp = 2^-e * k`\n    fn round_and_weed(\n        buf: &mut [u8],\n        exp: i16,\n        remainder: u64,\n        threshold: u64,\n        plus1v: u64,\n        ten_kappa: u64,\n        ulp: u64,\n    ) -> Option<(&[u8], i16)> {\n        assert!(!buf.is_empty());\n\n        // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n        // the resulting representation should be the closest representation to both.\n        //\n        // here `plus1 - v` is used since calculations are done with respect to `plus1`\n        // in order to avoid overflow/underflow (hence the seemingly swapped names).\n        let plus1v_down = plus1v + ulp; // plus1 - (v - 1 ulp)\n        let plus1v_up = plus1v - ulp; // plus1 - (v + 1 ulp)\n\n        // decrease the last digit and stop at the closest representation to `v + 1 ulp`.\n        let mut plus1w = remainder; // plus1w(n) = plus1 - w(n)\n        {\n            let last = buf.last_mut().unwrap();\n\n            // we work with the approximated digits `w(n)`, which is initially equal to `plus1 -\n            // plus1 % 10^kappa`. after running the loop body `n` times, `w(n) = plus1 -\n            // plus1 % 10^kappa - n * 10^kappa`. we set `plus1w(n) = plus1 - w(n) =\n            // plus1 % 10^kappa + n * 10^kappa` (thus `remainder = plus1w(0)`) to simplify checks.\n            // note that `plus1w(n)` is always increasing.\n            //\n            // we have three conditions to terminate. any of them will make the loop unable to\n            // proceed, but we then have at least one valid representation known to be closest to\n            // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n            //\n            // TC1: `w(n) <= v + 1 ulp`, i.e., this is the last repr that can be the closest one.\n            // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n            // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n            // overflow on the calculation of `plus1w(n)`.\n            //\n            // TC2: `w(n+1) < minus1`, i.e., the next repr definitely does not round to `v`.\n            // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n            // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n            // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n            // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n            // `threshold - plus1w(n) < 10^kappa` instead.\n            //\n            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e., the next repr is\n            // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n            // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n            // `z(n) > 0`. we have two cases to consider:\n            //\n            // - when `z(n+1) >= 0`: TC3 becomes `z(n) <= z(n+1)`. as `plus1w(n)` is increasing,\n            //   `z(n)` should be decreasing and this is clearly false.\n            // - when `z(n+1) < 0`:\n            //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n            //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e., `plus1v_up - plus1w(n) >=\n            //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n            //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n            //     combined with TC3a.\n            //\n            // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n            // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n            while plus1w < plus1v_up\n                && threshold - plus1w >= ten_kappa\n                && (plus1w + ten_kappa < plus1v_up\n                    || plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up)\n            {\n                *last -= 1;\n                debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n                plus1w += ten_kappa;\n            }\n        }\n\n        // check if this representation is also the closest representation to `v - 1 ulp`.\n        //\n        // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n        // replaced by `plus1v_down` instead. overflow analysis equally holds.\n        if plus1w < plus1v_down\n            && threshold - plus1w >= ten_kappa\n            && (plus1w + ten_kappa < plus1v_down\n                || plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down)\n        {\n            return None;\n        }\n\n        // now we have the closest representation to `v` between `plus1` and `minus1`.\n        // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n        // i.e., `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n        // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp { Some((buf, exp)) } else { None }\n    }\n}",
  "mir": "fn num::flt2dec::strategy::grisu::format_shortest_opt(_1: &num::flt2dec::decoder::Decoded, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>]) -> option::Option<(&[u8], i16)> {\n    let mut _0: option::Option<(&[u8], i16)>;\n    let mut _3: bool;\n    let mut _4: u64;\n    let mut _5: !;\n    let mut _6: bool;\n    let mut _7: u64;\n    let mut _8: !;\n    let mut _9: bool;\n    let mut _10: u64;\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: &option::Option<u64>;\n    let  _14: option::Option<u64>;\n    let mut _15: u64;\n    let mut _16: u64;\n    let mut _17: !;\n    let mut _18: bool;\n    let mut _19: &option::Option<u64>;\n    let  _20: option::Option<u64>;\n    let mut _21: u64;\n    let mut _22: u64;\n    let mut _23: !;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _27: !;\n    let mut _28: bool;\n    let mut _29: u64;\n    let mut _30: u64;\n    let mut _31: u64;\n    let mut _32: (u64, bool);\n    let mut _33: u64;\n    let mut _34: u32;\n    let mut _35: bool;\n    let mut _36: !;\n    let  _37: num::diy_float::Fp;\n    let mut _38: num::diy_float::Fp;\n    let mut _39: u64;\n    let mut _40: u64;\n    let mut _41: u64;\n    let mut _42: (u64, bool);\n    let mut _43: i16;\n    let  _44: num::diy_float::Fp;\n    let mut _45: num::diy_float::Fp;\n    let mut _46: u64;\n    let mut _47: u64;\n    let mut _48: u64;\n    let mut _49: (u64, bool);\n    let mut _50: i16;\n    let mut _51: i16;\n    let  _52: num::diy_float::Fp;\n    let mut _53: num::diy_float::Fp;\n    let mut _54: u64;\n    let mut _55: i16;\n    let mut _56: i16;\n    let  _57: i16;\n    let  _58: num::diy_float::Fp;\n    let mut _59: (i16, num::diy_float::Fp);\n    let mut _60: i16;\n    let mut _61: i16;\n    let mut _62: i16;\n    let mut _63: (i16, bool);\n    let mut _64: (i16, bool);\n    let mut _65: i16;\n    let mut _66: i16;\n    let mut _67: i16;\n    let mut _68: (i16, bool);\n    let mut _69: (i16, bool);\n    let  _70: num::diy_float::Fp;\n    let  _71: num::diy_float::Fp;\n    let  _72: num::diy_float::Fp;\n    let mut _73: (&i16, &i16);\n    let mut _74: &i16;\n    let mut _75: &i16;\n    let  _76: &i16;\n    let  _77: &i16;\n    let mut _78: bool;\n    let mut _79: i16;\n    let mut _80: i16;\n    let  _81: panicking::AssertKind;\n    let  _82: !;\n    let mut _83: option::Option<fmt::Arguments<'_>>;\n    let mut _84: (&i16, &i16);\n    let mut _85: &i16;\n    let mut _86: &i16;\n    let  _87: &i16;\n    let  _88: &i16;\n    let mut _89: bool;\n    let mut _90: i16;\n    let mut _91: i16;\n    let  _92: panicking::AssertKind;\n    let  _93: !;\n    let mut _94: option::Option<fmt::Arguments<'_>>;\n    let  _95: u64;\n    let mut _96: u64;\n    let mut _97: (u64, bool);\n    let  _98: u64;\n    let mut _99: u64;\n    let mut _100: (u64, bool);\n    let  _101: usize;\n    let mut _102: i16;\n    let mut _103: i16;\n    let mut _104: bool;\n    let  _105: u32;\n    let mut _106: u64;\n    let mut _107: bool;\n    let  _108: u64;\n    let mut _109: u64;\n    let mut _110: u64;\n    let mut _111: bool;\n    let mut _112: (u64, bool);\n    let  _113: u8;\n    let  _114: u32;\n    let mut _115: (u8, u32);\n    let mut _116: usize;\n    let  _117: i16;\n    let mut _118: i16;\n    let mut _119: i16;\n    let mut _120: (i16, bool);\n    let mut _121: (i16, bool);\n    let  _122: u64;\n    let mut _123: (u64, bool);\n    let  _124: u64;\n    let mut _125: u64;\n    let mut _126: u64;\n    let mut _127: bool;\n    let mut _128: (u64, bool);\n    let mut _129: u32;\n    let mut _130: u32;\n    let  _131: u32;\n    let mut _132: u32;\n    let mut _133: u32;\n    let mut _134: bool;\n    let  _135: u32;\n    let mut _136: u32;\n    let mut _137: u32;\n    let mut _138: bool;\n    let mut _139: bool;\n    let mut _140: !;\n    let mut _141: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _142: u8;\n    let mut _143: u8;\n    let mut _144: (u8, bool);\n    let  _145: usize;\n    let mut _146: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _147: usize;\n    let mut _148: bool;\n    let mut _149: (usize, bool);\n    let  _150: u64;\n    let mut _151: u64;\n    let mut _152: u64;\n    let mut _153: bool;\n    let mut _154: (u64, bool);\n    let mut _155: bool;\n    let  _156: u64;\n    let mut _157: u64;\n    let mut _158: u32;\n    let mut _159: bool;\n    let mut _160: &mut [u8];\n    let mut _161: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _162: ops::range::RangeTo<usize>;\n    let mut _163: usize;\n    let mut _164: u64;\n    let mut _165: u64;\n    let mut _166: (u64, bool);\n    let mut _167: bool;\n    let mut _168: usize;\n    let mut _169: usize;\n    let mut _170: (&u32, &u32);\n    let mut _171: &u32;\n    let mut _172: &u32;\n    let  _173: &u32;\n    let  _174: &u32;\n    let mut _175: bool;\n    let mut _176: u32;\n    let mut _177: u32;\n    let  _178: panicking::AssertKind;\n    let  _179: !;\n    let mut _180: option::Option<fmt::Arguments<'_>>;\n    let mut _181: bool;\n    let mut _182: u64;\n    let mut _183: u64;\n    let mut _184: u64;\n    let mut _185: (u64, bool);\n    let mut _186: (u64, bool);\n    let mut _187: (u64, bool);\n    let  _188: u64;\n    let mut _189: u64;\n    let mut _190: bool;\n    let  _191: u64;\n    let mut _192: u64;\n    let mut _193: u64;\n    let mut _194: u64;\n    let mut _195: bool;\n    let mut _196: (u64, bool);\n    let mut _197: bool;\n    let mut _198: !;\n    let mut _199: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _200: u8;\n    let mut _201: u8;\n    let mut _202: (u8, bool);\n    let  _203: usize;\n    let mut _204: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _205: usize;\n    let mut _206: bool;\n    let mut _207: (usize, bool);\n    let mut _208: bool;\n    let mut _209: u64;\n    let  _210: u64;\n    let mut _211: bool;\n    let mut _212: &mut [u8];\n    let mut _213: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _214: ops::range::RangeTo<usize>;\n    let mut _215: usize;\n    let mut _216: u64;\n    let mut _217: u64;\n    let mut _218: u64;\n    let mut _219: u64;\n    let mut _220: (u64, bool);\n    let mut _221: u64;\n    let mut _222: (u64, bool);\n    let mut _223: u64;\n    debug d => _1;\n    debug buf => _2;\n    debug plus => _37;\n    debug minus => _44;\n    debug v => _52;\n    debug minusk => _57;\n    debug cached => _58;\n    debug plus => _70;\n    debug minus => _71;\n    debug v => _72;\n    debug left_val => _76;\n    debug right_val => _77;\n    debug kind => _81;\n    debug left_val => _87;\n    debug right_val => _88;\n    debug kind => _92;\n    debug plus1 => _95;\n    debug minus1 => _98;\n    debug e => _101;\n    debug plus1int => _105;\n    debug plus1frac => _108;\n    debug max_kappa => _113;\n    debug max_ten_kappa => _114;\n    debug i => _116;\n    debug exp => _117;\n    debug delta1 => _122;\n    debug delta1frac => _124;\n    debug ten_kappa => _129;\n    debug remainder => _130;\n    debug q => _131;\n    debug r => _135;\n    debug plus1rem => _150;\n    debug ten_kappa => _156;\n    debug left_val => _173;\n    debug right_val => _174;\n    debug kind => _178;\n    debug remainder => _182;\n    debug threshold => _183;\n    debug ulp => _184;\n    debug q => _188;\n    debug r => _191;\n    debug ten_kappa => _210;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).0: u64);\n        _3 = Gt(move _4, 0_u64);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = ((*_1).1: u64);\n        _6 = Gt(move _7, 0_u64);\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = panicking::panic(\"assertion failed: d.mant > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).2: u64);\n        _9 = Gt(move _10, 0_u64);\n        switchInt(move _9) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_7);\n        _8 = panicking::panic(\"assertion failed: d.minus > 0\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = ((*_1).0: u64);\n        StorageLive(_16);\n        _16 = ((*_1).2: u64);\n        _14 = num::<impl u64>::checked_add(move _15, move _16) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _11 = panicking::panic(\"assertion failed: d.plus > 0\") -> unwind unreachable;\n    }\n    bb7: {\n        _13 = &_14;\n        StorageDead(_16);\n        StorageDead(_15);\n        _12 = option::Option::<u64>::is_some(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _12) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = ((*_1).0: u64);\n        StorageLive(_22);\n        _22 = ((*_1).1: u64);\n        _20 = num::<impl u64>::checked_sub(move _21, move _22) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_14);\n        _17 = panicking::panic(\"assertion failed: d.mant.checked_add(d.plus).is_some()\") -> unwind unreachable;\n    }\n    bb11: {\n        _19 = &_20;\n        StorageDead(_22);\n        StorageDead(_21);\n        _18 = option::Option::<u64>::is_some(move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _18) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_2);\n        _25 = PtrMetadata(move _26);\n        StorageDead(_26);\n        _24 = Ge(move _25, num::flt2dec::MAX_SIG_DIGITS);\n        switchInt(move _24) -> [0: bb16, otherwise: bb15];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_20);\n        _23 = panicking::panic(\"assertion failed: d.mant.checked_sub(d.minus).is_some()\") -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = ((*_1).0: u64);\n        StorageLive(_31);\n        _31 = ((*_1).2: u64);\n        _32 = CheckedAdd(_30, _31);\n        assert(!move (_32.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _30, move _31) -> [success: bb17, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_25);\n        _27 = panicking::panic(\"assertion failed: buf.len() >= MAX_SIG_DIGITS\") -> unwind unreachable;\n    }\n    bb17: {\n        _29 = move (_32.0: u64);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_33);\n        _34 = 61_i32 as u32;\n        _35 = Lt(move _34, 64_u32);\n        assert(move _35, \"attempt to shift left by `{}`, which would overflow\", 61_i32) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _33 = Shl(1_u64, 61_i32);\n        _28 = Lt(move _29, move _33);\n        switchInt(move _28) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_33);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = ((*_1).0: u64);\n        StorageLive(_41);\n        _41 = ((*_1).2: u64);\n        _42 = CheckedAdd(_40, _41);\n        assert(!move (_42.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _40, move _41) -> [success: bb21, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_33);\n        StorageDead(_29);\n        _36 = panicking::panic(\"assertion failed: d.mant + d.plus < (1 << 61)\") -> unwind unreachable;\n    }\n    bb21: {\n        _39 = move (_42.0: u64);\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageLive(_43);\n        _43 = ((*_1).3: i16);\n        _38 = Fp(move _39, move _43);\n        StorageDead(_43);\n        StorageDead(_39);\n        _37 = num::diy_float::Fp::normalize(move _38) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_38);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = ((*_1).0: u64);\n        StorageLive(_48);\n        _48 = ((*_1).1: u64);\n        _49 = CheckedSub(_47, _48);\n        assert(!move (_49.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _47, move _48) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _46 = move (_49.0: u64);\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageLive(_50);\n        _50 = ((*_1).3: i16);\n        _45 = Fp(move _46, move _50);\n        StorageDead(_50);\n        StorageDead(_46);\n        StorageLive(_51);\n        _51 = (_37.1: i16);\n        _44 = num::diy_float::Fp::normalize_to(move _45, move _51) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_51);\n        StorageDead(_45);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = ((*_1).0: u64);\n        StorageLive(_55);\n        _55 = ((*_1).3: i16);\n        _53 = Fp(move _54, move _55);\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageLive(_56);\n        _56 = (_37.1: i16);\n        _52 = num::diy_float::Fp::normalize_to(move _53, move _56) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_56);\n        StorageDead(_53);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = (_37.1: i16);\n        _63 = CheckedSub(num::flt2dec::strategy::grisu::ALPHA, _62);\n        assert(!move (_63.1: bool), \"attempt to compute `{} - {}`, which would overflow\", num::flt2dec::strategy::grisu::ALPHA, move _62) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _61 = move (_63.0: i16);\n        StorageDead(_62);\n        _64 = CheckedSub(_61, 64_i16);\n        assert(!move (_64.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _61, 64_i16) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _60 = move (_64.0: i16);\n        StorageDead(_61);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = (_37.1: i16);\n        _68 = CheckedSub(num::flt2dec::strategy::grisu::GAMMA, _67);\n        assert(!move (_68.1: bool), \"attempt to compute `{} - {}`, which would overflow\", num::flt2dec::strategy::grisu::GAMMA, move _67) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _66 = move (_68.0: i16);\n        StorageDead(_67);\n        _69 = CheckedSub(_66, 64_i16);\n        assert(!move (_69.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _66, 64_i16) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _65 = move (_69.0: i16);\n        StorageDead(_66);\n        _59 = num::flt2dec::strategy::grisu::cached_power(move _60, move _65) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_65);\n        StorageDead(_60);\n        _57 = (_59.0: i16);\n        _58 = (_59.1: num::diy_float::Fp);\n        StorageDead(_59);\n        StorageLive(_70);\n        _70 = num::diy_float::Fp::mul(_37, _58) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageLive(_71);\n        _71 = num::diy_float::Fp::mul(_44, _58) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_72);\n        _72 = num::diy_float::Fp::mul(_52, _58) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = &(_70.1: i16);\n        StorageLive(_75);\n        _75 = &(_71.1: i16);\n        _73 = (move _74, move _75);\n        StorageDead(_75);\n        StorageDead(_74);\n        _76 = (_73.0: &i16);\n        _77 = (_73.1: &i16);\n        StorageLive(_78);\n        StorageLive(_79);\n        _79 = (*_76);\n        StorageLive(_80);\n        _80 = (*_77);\n        _78 = Eq(move _79, move _80);\n        switchInt(move _78) -> [0: bb35, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_80);\n        StorageDead(_79);\n        StorageDead(_78);\n        StorageDead(_73);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = &(_70.1: i16);\n        StorageLive(_86);\n        _86 = &(_72.1: i16);\n        _84 = (move _85, move _86);\n        StorageDead(_86);\n        StorageDead(_85);\n        _87 = (_84.0: &i16);\n        _88 = (_84.1: &i16);\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = (*_87);\n        StorageLive(_91);\n        _91 = (*_88);\n        _89 = Eq(move _90, move _91);\n        switchInt(move _89) -> [0: bb37, otherwise: bb36];\n    }\n    bb35: {\n        StorageDead(_80);\n        StorageDead(_79);\n        _81 = panicking::AssertKind::Eq;\n        StorageLive(_83);\n        _83 = option::Option::None;\n        _82 = panicking::assert_failed::<i16, i16>(_81, _76, _77, move _83) -> unwind unreachable;\n    }\n    bb36: {\n        StorageDead(_91);\n        StorageDead(_90);\n        StorageDead(_89);\n        StorageDead(_84);\n        StorageLive(_96);\n        _96 = (_70.0: u64);\n        _97 = CheckedAdd(_96, 1_u64);\n        assert(!move (_97.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _96, 1_u64) -> [success: bb38, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_91);\n        StorageDead(_90);\n        _92 = panicking::AssertKind::Eq;\n        StorageLive(_94);\n        _94 = option::Option::None;\n        _93 = panicking::assert_failed::<i16, i16>(_92, _87, _88, move _94) -> unwind unreachable;\n    }\n    bb38: {\n        _95 = move (_97.0: u64);\n        StorageDead(_96);\n        StorageLive(_99);\n        _99 = (_71.0: u64);\n        _100 = CheckedSub(_99, 1_u64);\n        assert(!move (_100.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _99, 1_u64) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _98 = move (_100.0: u64);\n        StorageDead(_99);\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = (_70.1: i16);\n        _104 = Eq(_103, i16::MIN);\n        assert(!move _104, \"attempt to negate `{}`, which would overflow\", _103) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _102 = Neg(move _103);\n        StorageDead(_103);\n        _101 = move _102 as usize;\n        StorageDead(_102);\n        StorageLive(_106);\n        _107 = Lt(_101, 64_usize);\n        assert(move _107, \"attempt to shift right by `{}`, which would overflow\", _101) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _106 = Shr(_95, _101);\n        _105 = move _106 as u32;\n        StorageDead(_106);\n        StorageLive(_109);\n        StorageLive(_110);\n        _111 = Lt(_101, 64_usize);\n        assert(move _111, \"attempt to shift left by `{}`, which would overflow\", _101) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _110 = Shl(1_u64, _101);\n        _112 = CheckedSub(_110, 1_u64);\n        assert(!move (_112.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _110, 1_u64) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _109 = move (_112.0: u64);\n        StorageDead(_110);\n        _108 = BitAnd(_95, move _109);\n        StorageDead(_109);\n        StorageLive(_115);\n        _115 = num::flt2dec::strategy::grisu::max_pow10_no_more_than(_105) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _113 = (_115.0: u8);\n        StorageLive(_114);\n        _114 = (_115.1: u32);\n        StorageDead(_115);\n        StorageLive(_116);\n        _116 = 0_usize;\n        StorageLive(_118);\n        StorageLive(_119);\n        _119 = _113 as i16;\n        _120 = CheckedSub(_119, _57);\n        assert(!move (_120.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _119, _57) -> [success: bb45, unwind unreachable];\n    }\n    bb45: {\n        _118 = move (_120.0: i16);\n        StorageDead(_119);\n        _121 = CheckedAdd(_118, 1_i16);\n        assert(!move (_121.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _118, 1_i16) -> [success: bb46, unwind unreachable];\n    }\n    bb46: {\n        _117 = move (_121.0: i16);\n        StorageDead(_118);\n        _123 = CheckedSub(_95, _98);\n        assert(!move (_123.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _95, _98) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _122 = move (_123.0: u64);\n        StorageLive(_124);\n        StorageLive(_125);\n        StorageLive(_126);\n        _127 = Lt(_101, 64_usize);\n        assert(move _127, \"attempt to shift left by `{}`, which would overflow\", _101) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _126 = Shl(1_u64, _101);\n        _128 = CheckedSub(_126, 1_u64);\n        assert(!move (_128.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _126, 1_u64) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _125 = move (_128.0: u64);\n        StorageDead(_126);\n        _124 = BitAnd(_122, move _125);\n        StorageDead(_125);\n        StorageLive(_129);\n        _129 = _114;\n        StorageLive(_130);\n        _130 = _105;\n        goto -> bb50;\n    }\n    bb50: {\n        StorageLive(_132);\n        _132 = _130;\n        StorageLive(_133);\n        _133 = _129;\n        _134 = Eq(_133, 0_u32);\n        assert(!move _134, \"attempt to divide `{}` by zero\", _132) -> [success: bb51, unwind unreachable];\n    }\n    bb51: {\n        _131 = Div(move _132, move _133);\n        StorageDead(_133);\n        StorageDead(_132);\n        StorageLive(_136);\n        _136 = _130;\n        StorageLive(_137);\n        _137 = _129;\n        _138 = Eq(_137, 0_u32);\n        assert(!move _138, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _136) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        _135 = Rem(move _136, move _137);\n        StorageDead(_137);\n        StorageDead(_136);\n        StorageLive(_139);\n        _139 = Lt(_131, 10_u32);\n        switchInt(move _139) -> [0: bb54, otherwise: bb53];\n    }\n    bb53: {\n        StorageDead(_139);\n        StorageLive(_141);\n        StorageLive(_142);\n        StorageLive(_143);\n        _143 = _131 as u8;\n        _144 = CheckedAdd(48_u8, _143);\n        assert(!move (_144.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _143) -> [success: bb55, unwind unreachable];\n    }\n    bb54: {\n        _140 = panicking::panic(\"assertion failed: q < 10\") -> unwind unreachable;\n    }\n    bb55: {\n        _142 = move (_144.0: u8);\n        StorageDead(_143);\n        _141 = mem::maybe_uninit::MaybeUninit::<u8>::new(move _142) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_142);\n        StorageLive(_145);\n        _145 = _116;\n        _146 = &raw const (fake) (*_2);\n        _147 = PtrMetadata(move _146);\n        _148 = Lt(_145, _147);\n        assert(move _148, \"index out of bounds: the length is {} but the index is {}\", move _147, _145) -> [success: bb57, unwind unreachable];\n    }\n    bb57: {\n        (*_2)[_145] = move _141;\n        StorageDead(_141);\n        StorageDead(_145);\n        _149 = CheckedAdd(_116, 1_usize);\n        assert(!move (_149.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _116, 1_usize) -> [success: bb58, unwind unreachable];\n    }\n    bb58: {\n        _116 = move (_149.0: usize);\n        StorageLive(_151);\n        StorageLive(_152);\n        _152 = _135 as u64;\n        _153 = Lt(_101, 64_usize);\n        assert(move _153, \"attempt to shift left by `{}`, which would overflow\", _101) -> [success: bb59, unwind unreachable];\n    }\n    bb59: {\n        _151 = Shl(move _152, _101);\n        StorageDead(_152);\n        _154 = CheckedAdd(_151, _108);\n        assert(!move (_154.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _151, _108) -> [success: bb60, unwind unreachable];\n    }\n    bb60: {\n        _150 = move (_154.0: u64);\n        StorageDead(_151);\n        StorageLive(_155);\n        _155 = Lt(_150, _122);\n        switchInt(move _155) -> [0: bb67, otherwise: bb61];\n    }\n    bb61: {\n        StorageLive(_157);\n        StorageLive(_158);\n        _158 = _129;\n        _157 = move _158 as u64;\n        StorageDead(_158);\n        _159 = Lt(_101, 64_usize);\n        assert(move _159, \"attempt to shift left by `{}`, which would overflow\", _101) -> [success: bb62, unwind unreachable];\n    }\n    bb62: {\n        _156 = Shl(move _157, _101);\n        StorageDead(_157);\n        StorageLive(_162);\n        StorageLive(_163);\n        _163 = _116;\n        _162 = RangeTo(move _163);\n        StorageDead(_163);\n        _161 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_2, move _162) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_162);\n        _160 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_161) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageLive(_164);\n        StorageLive(_165);\n        _165 = (_72.0: u64);\n        _166 = CheckedSub(_95, _165);\n        assert(!move (_166.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _95, move _165) -> [success: bb65, unwind unreachable];\n    }\n    bb65: {\n        _164 = move (_166.0: u64);\n        StorageDead(_165);\n        _0 = num::flt2dec::strategy::grisu::format_shortest_opt::round_and_weed(_160, _117, _150, _122, move _164, _156, 1_u64) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_164);\n        StorageDead(_155);\n        goto -> bb94;\n    }\n    bb67: {\n        StorageDead(_155);\n        StorageLive(_167);\n        StorageLive(_168);\n        _168 = _116;\n        StorageLive(_169);\n        _169 = _113 as usize;\n        _167 = Gt(move _168, move _169);\n        switchInt(move _167) -> [0: bb69, otherwise: bb68];\n    }\n    bb68: {\n        StorageDead(_169);\n        StorageDead(_168);\n        StorageLive(_170);\n        StorageLive(_171);\n        _171 = &_129;\n        StorageLive(_172);\n        _172 = num::flt2dec::strategy::grisu::format_shortest_opt::promoted[0];\n        _170 = (move _171, move _172);\n        StorageDead(_172);\n        StorageDead(_171);\n        _173 = (_170.0: &u32);\n        _174 = (_170.1: &u32);\n        StorageLive(_175);\n        StorageLive(_176);\n        _176 = (*_173);\n        StorageLive(_177);\n        _177 = (*_174);\n        _175 = Eq(move _176, move _177);\n        switchInt(move _175) -> [0: bb71, otherwise: bb70];\n    }\n    bb69: {\n        StorageDead(_169);\n        StorageDead(_168);\n        StorageDead(_167);\n        _181 = Eq(10_u32, 0_u32);\n        assert(!move _181, \"attempt to divide `{}` by zero\", _129) -> [success: bb72, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_177);\n        StorageDead(_176);\n        StorageDead(_175);\n        StorageDead(_170);\n        StorageDead(_167);\n        StorageLive(_182);\n        _182 = _108;\n        StorageLive(_183);\n        _183 = _124;\n        StorageLive(_184);\n        _184 = 1_u64;\n        goto -> bb73;\n    }\n    bb71: {\n        StorageDead(_177);\n        StorageDead(_176);\n        _178 = panicking::AssertKind::Eq;\n        StorageLive(_180);\n        _180 = option::Option::None;\n        _179 = panicking::assert_failed::<u32, u32>(_178, _173, _174, move _180) -> unwind unreachable;\n    }\n    bb72: {\n        _129 = Div(_129, 10_u32);\n        _130 = _135;\n        goto -> bb50;\n    }\n    bb73: {\n        _185 = CheckedMul(_182, 10_u64);\n        assert(!move (_185.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _182, 10_u64) -> [success: bb74, unwind unreachable];\n    }\n    bb74: {\n        _182 = move (_185.0: u64);\n        _186 = CheckedMul(_183, 10_u64);\n        assert(!move (_186.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _183, 10_u64) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _183 = move (_186.0: u64);\n        _187 = CheckedMul(_184, 10_u64);\n        assert(!move (_187.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _184, 10_u64) -> [success: bb76, unwind unreachable];\n    }\n    bb76: {\n        _184 = move (_187.0: u64);\n        StorageLive(_189);\n        _189 = _182;\n        _190 = Lt(_101, 64_usize);\n        assert(move _190, \"attempt to shift right by `{}`, which would overflow\", _101) -> [success: bb77, unwind unreachable];\n    }\n    bb77: {\n        _188 = Shr(move _189, _101);\n        StorageDead(_189);\n        StorageLive(_192);\n        _192 = _182;\n        StorageLive(_193);\n        StorageLive(_194);\n        _195 = Lt(_101, 64_usize);\n        assert(move _195, \"attempt to shift left by `{}`, which would overflow\", _101) -> [success: bb78, unwind unreachable];\n    }\n    bb78: {\n        _194 = Shl(1_u64, _101);\n        _196 = CheckedSub(_194, 1_u64);\n        assert(!move (_196.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _194, 1_u64) -> [success: bb79, unwind unreachable];\n    }\n    bb79: {\n        _193 = move (_196.0: u64);\n        StorageDead(_194);\n        _191 = BitAnd(move _192, move _193);\n        StorageDead(_193);\n        StorageDead(_192);\n        StorageLive(_197);\n        _197 = Lt(_188, 10_u64);\n        switchInt(move _197) -> [0: bb81, otherwise: bb80];\n    }\n    bb80: {\n        StorageDead(_197);\n        StorageLive(_199);\n        StorageLive(_200);\n        StorageLive(_201);\n        _201 = _188 as u8;\n        _202 = CheckedAdd(48_u8, _201);\n        assert(!move (_202.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _201) -> [success: bb82, unwind unreachable];\n    }\n    bb81: {\n        _198 = panicking::panic(\"assertion failed: q < 10\") -> unwind unreachable;\n    }\n    bb82: {\n        _200 = move (_202.0: u8);\n        StorageDead(_201);\n        _199 = mem::maybe_uninit::MaybeUninit::<u8>::new(move _200) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        StorageDead(_200);\n        StorageLive(_203);\n        _203 = _116;\n        _204 = &raw const (fake) (*_2);\n        _205 = PtrMetadata(move _204);\n        _206 = Lt(_203, _205);\n        assert(move _206, \"index out of bounds: the length is {} but the index is {}\", move _205, _203) -> [success: bb84, unwind unreachable];\n    }\n    bb84: {\n        (*_2)[_203] = move _199;\n        StorageDead(_199);\n        StorageDead(_203);\n        _207 = CheckedAdd(_116, 1_usize);\n        assert(!move (_207.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _116, 1_usize) -> [success: bb85, unwind unreachable];\n    }\n    bb85: {\n        _116 = move (_207.0: usize);\n        StorageLive(_208);\n        StorageLive(_209);\n        _209 = _183;\n        _208 = Lt(_191, move _209);\n        switchInt(move _208) -> [0: bb93, otherwise: bb86];\n    }\n    bb86: {\n        StorageDead(_209);\n        _211 = Lt(_101, 64_usize);\n        assert(move _211, \"attempt to shift left by `{}`, which would overflow\", _101) -> [success: bb87, unwind unreachable];\n    }\n    bb87: {\n        _210 = Shl(1_u64, _101);\n        StorageLive(_214);\n        StorageLive(_215);\n        _215 = _116;\n        _214 = RangeTo(move _215);\n        StorageDead(_215);\n        _213 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_2, move _214) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        StorageDead(_214);\n        _212 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_213) -> [return: bb89, unwind unreachable];\n    }\n    bb89: {\n        StorageLive(_216);\n        _216 = _183;\n        StorageLive(_217);\n        StorageLive(_218);\n        StorageLive(_219);\n        _219 = (_72.0: u64);\n        _220 = CheckedSub(_95, _219);\n        assert(!move (_220.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _95, move _219) -> [success: bb90, unwind unreachable];\n    }\n    bb90: {\n        _218 = move (_220.0: u64);\n        StorageDead(_219);\n        StorageLive(_221);\n        _221 = _184;\n        _222 = CheckedMul(_218, _221);\n        assert(!move (_222.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _218, move _221) -> [success: bb91, unwind unreachable];\n    }\n    bb91: {\n        _217 = move (_222.0: u64);\n        StorageDead(_221);\n        StorageDead(_218);\n        StorageLive(_223);\n        _223 = _184;\n        _0 = num::flt2dec::strategy::grisu::format_shortest_opt::round_and_weed(_212, _117, _191, move _216, move _217, _210, move _223) -> [return: bb92, unwind unreachable];\n    }\n    bb92: {\n        StorageDead(_223);\n        StorageDead(_217);\n        StorageDead(_216);\n        StorageDead(_208);\n        StorageDead(_184);\n        StorageDead(_183);\n        StorageDead(_182);\n        goto -> bb94;\n    }\n    bb93: {\n        StorageDead(_209);\n        StorageDead(_208);\n        _182 = _191;\n        goto -> bb73;\n    }\n    bb94: {\n        StorageDead(_130);\n        StorageDead(_129);\n        StorageDead(_124);\n        StorageDead(_116);\n        StorageDead(_114);\n        StorageDead(_72);\n        StorageDead(_71);\n        StorageDead(_70);\n        return;\n    }\n}\n",
  "doc": " The shortest mode implementation for Grisu.\n\n It returns `None` when it would return an inexact representation otherwise.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}