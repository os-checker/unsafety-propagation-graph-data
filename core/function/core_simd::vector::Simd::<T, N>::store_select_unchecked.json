{
  "name": "core_simd::vector::Simd::<T, N>::store_select_unchecked",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::store_select_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Conditionally write contiguous elements starting from `ptr`.\n The `enable` mask controls which elements are written.\n When disabled, the memory location corresponding to that element is not accessed.\n\n # Safety\n\n Memory addresses for element are calculated [`pointer::wrapping_offset`] and\n each enabled element must satisfy the same conditions as [`core::ptr::write`].\n",
      "adt": {}
    }
  },
  "adts": {
    "core_simd::vector::Simd": [
      "Plain"
    ],
    "core_simd::masks::Mask": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_simd::vector::Simd::<T, N>::store_select_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:712:5: 720:6",
  "src": "pub unsafe fn store_select_unchecked(\n        self,\n        slice: &mut [T],\n        enable: Mask<<T as SimdElement>::Mask, N>,\n    ) {\n        let ptr = slice.as_mut_ptr();\n        // SAFETY: The safety of writing elements in `slice` is ensured by the caller.\n        unsafe { self.store_select_ptr(ptr, enable) }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::store_select_unchecked(_1: core_simd::vector::Simd<T, N>, _2: &mut [T], _3: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>) -> () {\n    let mut _0: ();\n    let  _4: *mut T;\n    debug self => _1;\n    debug slice => _2;\n    debug enable => _3;\n    debug ptr => _4;\n    bb0: {\n        _4 = slice::<impl [T]>::as_mut_ptr(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = core_simd::vector::Simd::<T, N>::store_select_ptr(_1, _4, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Conditionally write contiguous elements to `slice`. The `enable` mask controls\n which elements are written.\n\n # Safety\n\n Every enabled element must be in bounds for the `slice`.\n\n # Examples\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::{Simd, Mask};\n let mut arr = [0i32; 4];\n let write = Simd::from_array([-5, -4, -3, -2]);\n let enable = Mask::from_array([false, true, true, true]);\n\n unsafe { write.store_select_unchecked(&mut arr, enable) };\n assert_eq!(arr, [0, -4, -3, -2]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}