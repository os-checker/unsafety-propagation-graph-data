{
  "name": "array::drain::Drain::<'l, 'f, T, N, F>::new",
  "safe": false,
  "callees": {
    "ptr::non_null::NonNull::<T>::from_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a mutable reference to a `NonNull` pointer.\n",
      "adt": {
        "ptr::non_null::NonNull": "Constructor"
      }
    },
    "ptr::non_null::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {
        "ptr::non_null::NonNull": "Constructor"
      }
    },
    "ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "ptr::non_null::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mem::manually_drop::ManuallyDrop": [
      "MutRef"
    ],
    "ptr::non_null::NonNull": [
      "Plain"
    ],
    "array::drain::Drain": [
      "Plain"
    ]
  },
  "path": 4497,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/drain.rs:19:5: 30:6",
  "src": "pub(super) const unsafe fn new(array: &'l mut ManuallyDrop<[T; N]>, f: &'f mut F) -> Self {\n        // dont drop the array, transfers \"ownership\" to Self\n        let ptr: NonNull<T> = NonNull::from_mut(array).cast();\n        // SAFETY:\n        // Adding `slice.len()` to the starting pointer gives a pointer\n        // at the end of `slice`. `end` will never be dereferenced, only checked\n        // for direct pointer equality with `ptr` to check if the drainer is done.\n        unsafe {\n            let end = if T::IS_ZST { null_mut() } else { ptr.as_ptr().add(N) };\n            Self { ptr, end, f, l: PhantomData }\n        }\n    }",
  "mir": "fn array::drain::Drain::<'l, 'f, T, N, F>::new(_1: &mut mem::manually_drop::ManuallyDrop<[T; N]>, _2: &mut F) -> array::drain::Drain<'_, '_, T, N, F> {\n    let mut _0: array::drain::Drain<'_, '_, T, N, F>;\n    let  _3: ptr::non_null::NonNull<T>;\n    let mut _4: ptr::non_null::NonNull<mem::manually_drop::ManuallyDrop<[T; N]>>;\n    let  _5: *mut T;\n    let mut _6: *mut T;\n    let mut _7: *mut T;\n    debug array => _1;\n    debug f => _2;\n    debug ptr => _3;\n    debug end => _5;\n    bb0: {\n        StorageLive(_4);\n        _4 = ptr::non_null::NonNull::<mem::manually_drop::ManuallyDrop<[T; N]>>::from_mut(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = ptr::non_null::NonNull::<mem::manually_drop::ManuallyDrop<[T; N]>>::cast::<T>(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _5 = ptr::null_mut::<T>() -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_6);\n        _6 = ptr::non_null::NonNull::<T>::as_ptr(_3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _5 = ptr::mut_ptr::<impl *mut T>::add(move _6, N) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_7);\n        _7 = _5;\n        _0 = Drain(_3, move _7, _2, ZeroSized: marker::PhantomData<&mut [T; N]>);\n        StorageDead(_7);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " This function returns a function that lets you index the given array in const.\n As implemented it can optimize better than iterators, and can be constified.\n It acts like a sort of guard (owns the array) and iterator combined, which can be implemented\n as it is a struct that implements const fn;\n in that regard it is somewhat similar to an array::Iter implementing `UncheckedIterator`.\n The only method you're really allowed to call is `next()`,\n anything else is more or less UB, hence this function being unsafe.\n Moved elements will not be dropped.\n This will also not actually store the array.\n\n SAFETY: must only be called `N` times. Thou shalt not drop the array either.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}