{
  "name": "mem::drop_guard::DropGuard::<T, F>::dismiss",
  "safe": true,
  "callees": {
    "mem::manually_drop::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {
        "mem::manually_drop::ManuallyDrop": "Constructor"
      }
    },
    "ops::deref::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "mem::manually_drop::ManuallyDrop::<T>::take": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value from the `ManuallyDrop<T>` container out.\n\n This method is primarily intended for moving out values in drop.\n Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n you can use this method to take the value and use it however desired.\n\n Whenever possible, it is preferable to use [`into_inner`][`ManuallyDrop::into_inner`]\n instead, which prevents duplicating the content of the `ManuallyDrop<T>`.\n\n # Safety\n\n This function semantically moves out the contained value without preventing further usage,\n leaving the state of this container unchanged.\n It is your responsibility to ensure that this `ManuallyDrop` is not used again.\n\n",
      "adt": {
        "mem::manually_drop::ManuallyDrop": "MutableAsArgument"
      }
    },
    "mem::manually_drop::ManuallyDrop::<T>::drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Manually drops the contained value.\n\n This is exactly equivalent to calling [`ptr::drop_in_place`] with a\n pointer to the contained value. As such, unless the contained value is a\n packed struct, the destructor will be called in-place without moving the\n value, and thus can be used to safely drop [pinned] data.\n\n If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n\n # Safety\n\n This function runs the destructor of the contained value. Other than changes made by\n the destructor itself, the memory is left unchanged, and so as far as the compiler is\n concerned still holds a bit-pattern which is valid for the type `T`.\n\n However, this \"zombie\" value should not be exposed to safe code, and this function\n should not be called more than once. To use a value after it's been dropped, or drop\n a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n This is normally prevented by the type system, but users of `ManuallyDrop` must\n uphold those guarantees without assistance from the compiler.\n\n [pinned]: crate::pin\n",
      "adt": {
        "mem::manually_drop::ManuallyDrop": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mem::drop_guard::DropGuard": [
      "Plain",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "mem::manually_drop::ManuallyDrop": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 14400,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/drop_guard.rs:85:5: 102:6",
  "src": "pub fn dismiss(self) -> T {\n        // First we ensure that dropping the guard will not trigger\n        // its destructor\n        let mut this = ManuallyDrop::new(self);\n\n        // Next we manually read the stored value from the guard.\n        //\n        // SAFETY: this is safe because we've taken ownership of the guard.\n        let value = unsafe { ManuallyDrop::take(&mut this.inner) };\n\n        // Finally we drop the stored closure. We do this *after* having read\n        // the value, so that even if the closure's `drop` function panics,\n        // unwinding still tries to drop the value.\n        //\n        // SAFETY: this is safe because we've taken ownership of the guard.\n        unsafe { ManuallyDrop::drop(&mut this.f) };\n        value\n    }",
  "mir": "fn mem::drop_guard::DropGuard::<T, F>::dismiss(_1: mem::drop_guard::DropGuard<T, F>) -> T {\n    let mut _0: T;\n    let mut _2: mem::manually_drop::ManuallyDrop<mem::drop_guard::DropGuard<T, F>>;\n    let mut _3: &mut mem::manually_drop::ManuallyDrop<T>;\n    let mut _4: &mut mem::drop_guard::DropGuard<T, F>;\n    let mut _5: &mut mem::manually_drop::ManuallyDrop<mem::drop_guard::DropGuard<T, F>>;\n    let  _6: ();\n    let mut _7: &mut mem::manually_drop::ManuallyDrop<F>;\n    let mut _8: &mut mem::drop_guard::DropGuard<T, F>;\n    let mut _9: &mut mem::manually_drop::ManuallyDrop<mem::drop_guard::DropGuard<T, F>>;\n    debug self => _1;\n    debug this => _2;\n    debug value => _0;\n    bb0: {\n        StorageLive(_2);\n        _2 = mem::manually_drop::ManuallyDrop::<mem::drop_guard::DropGuard<T, F>>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _2;\n        _4 = <mem::manually_drop::ManuallyDrop<mem::drop_guard::DropGuard<T, F>> as ops::deref::DerefMut>::deref_mut(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = &mut ((*_4).0: mem::manually_drop::ManuallyDrop<T>);\n        _0 = mem::manually_drop::ManuallyDrop::<T>::take(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &mut _2;\n        _8 = <mem::manually_drop::ManuallyDrop<mem::drop_guard::DropGuard<T, F>> as ops::deref::DerefMut>::deref_mut(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _7 = &mut ((*_8).1: mem::manually_drop::ManuallyDrop<F>);\n        _6 = mem::manually_drop::ManuallyDrop::<F>::drop(_7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Consumes the `DropGuard`, returning the wrapped value.\n\n This will not execute the closure. It is typically preferred to call\n this function instead of `mem::forget` because it will return the stored\n value and drop variables captured by the closure instead of leaking their\n owned resources.\n\n # Example\n\n ```rust\n # #![allow(unused)]\n #![feature(drop_guard)]\n\n use std::mem::DropGuard;\n\n let value = String::from(\"Nori likes chicken\");\n let guard = DropGuard::new(value, |s| println!(\"{s}\"));\n assert_eq!(guard.dismiss(), \"Nori likes chicken\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}