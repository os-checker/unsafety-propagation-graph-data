{
  "name": "cell::Cell::<T>::swap",
  "safe": true,
  "callees": {
    "ptr::eq": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "ambiguous_wide_pointer_comparisons"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* ambiguous_wide_pointer_comparisons\n"
        ]
      },
      "doc": " Compares raw pointers for equality.\n\n This is the same as using the `==` operator, but less generic:\n the arguments have to be `*const T` raw pointers,\n not anything that implements `PartialEq`.\n\n This can be used to compare `&T` references (which coerce to `*const T` implicitly)\n by their address rather than comparing the values they point to\n (which is what the `PartialEq for &T` implementation does).\n\n When comparing wide pointers, both the address and the metadata are tested for equality.\n However, note that comparing trait object pointers (`*const dyn Trait`) is unreliable: pointers\n to values of the same underlying type can compare inequal (because vtables are duplicated in\n multiple codegen units), and pointers to values of *different* underlying type can compare equal\n (since identical vtables can be deduplicated within a codegen unit).\n\n # Examples\n\n ```\n use std::ptr;\n\n let five = 5;\n let other_five = 5;\n let five_ref = &five;\n let same_five_ref = &five;\n let other_five_ref = &other_five;\n\n assert!(five_ref == same_five_ref);\n assert!(ptr::eq(five_ref, same_five_ref));\n\n assert!(five_ref == other_five_ref);\n assert!(!ptr::eq(five_ref, other_five_ref));\n ```\n\n Slices are also compared by their length (fat pointers):\n\n ```\n let a = [1, 2, 3];\n assert!(std::ptr::eq(&a[..3], &a[..3]));\n assert!(!std::ptr::eq(&a[..2], &a[..3]));\n assert!(!std::ptr::eq(&a[0..2], &a[1..3]));\n ```\n",
      "adt": {}
    },
    "cell::Cell::<T>::swap::is_nonoverlapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "cell::UnsafeCell::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the wrapped value.\n\n This can be cast to a pointer of any kind. When creating references, you must uphold the\n aliasing rules; see [the type-level docs][UnsafeCell#aliasing-rules] for more discussion and\n caveats.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let uc = UnsafeCell::new(5);\n\n let five = uc.get();\n ```\n",
      "adt": {
        "cell::UnsafeCell": "MutableAsArgument"
      }
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "mem::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps the values at two mutable locations, without deinitializing either one.\n\n * If you want to swap with a default or dummy value, see [`take`].\n * If you want to swap with a passed value, returning the old value, see [`replace`].\n\n # Examples\n\n ```\n use std::mem;\n\n let mut x = 5;\n let mut y = 42;\n\n mem::swap(&mut x, &mut y);\n\n assert_eq!(42, x);\n assert_eq!(5, y);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "cell::Cell": [
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "cell::UnsafeCell": [
      "Ref"
    ],
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::cell::Cell::<T>::swap"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cell.rs:466:5: 492:6",
  "src": "pub fn swap(&self, other: &Self) {\n        // This function documents that it *will* panic, and intrinsics::is_nonoverlapping doesn't\n        // do the check in const, so trying to use it here would be inviting unnecessary fragility.\n        fn is_nonoverlapping<T>(src: *const T, dst: *const T) -> bool {\n            let src_usize = src.addr();\n            let dst_usize = dst.addr();\n            let diff = src_usize.abs_diff(dst_usize);\n            diff >= size_of::<T>()\n        }\n\n        if ptr::eq(self, other) {\n            // Swapping wouldn't change anything.\n            return;\n        }\n        if !is_nonoverlapping(self, other) {\n            // See <https://github.com/rust-lang/rust/issues/80778> for why we need to stop here.\n            panic!(\"`Cell::swap` on overlapping non-identical `Cell`s\");\n        }\n        // SAFETY: This can be risky if called from separate threads, but `Cell`\n        // is `!Sync` so this won't happen. This also won't invalidate any\n        // pointers since `Cell` makes sure nothing else will be pointing into\n        // either of these `Cell`s. We also excluded shenanigans like partially overlapping `Cell`s,\n        // so `swap` will just properly copy two full values of type `T` back and forth.\n        unsafe {\n            mem::swap(&mut *self.value.get(), &mut *other.value.get());\n        }\n    }",
  "mir": "fn cell::Cell::<T>::swap(_1: &cell::Cell<T>, _2: &cell::Cell<T>) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: *const cell::Cell<T>;\n    let mut _5: *const cell::Cell<T>;\n    let mut _6: bool;\n    let mut _7: *const cell::Cell<T>;\n    let mut _8: *const cell::Cell<T>;\n    let  _9: !;\n    let mut _10: fmt::Arguments<'_>;\n    let  _11: ();\n    let mut _12: &mut T;\n    let mut _13: *mut T;\n    let mut _14: &cell::UnsafeCell<T>;\n    let mut _15: &mut T;\n    let mut _16: *mut T;\n    let mut _17: &cell::UnsafeCell<T>;\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &raw const (*_1);\n        StorageLive(_5);\n        _5 = &raw const (*_2);\n        _3 = ptr::eq::<cell::Cell<T>>(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb11;\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &raw const (*_1);\n        StorageLive(_8);\n        _8 = &raw const (*_2);\n        _6 = cell::Cell::<T>::swap::is_nonoverlapping::<cell::Cell<T>>(move _7, move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _6) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &((*_1).0: cell::UnsafeCell<T>);\n        _13 = cell::UnsafeCell::<T>::get(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        _10 = fmt::Arguments::<'_>::from_str(\"`Cell::swap` on overlapping non-identical `Cell`s\") -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = panicking::panic_fmt(move _10) -> unwind unreachable;\n    }\n    bb8: {\n        StorageDead(_14);\n        _12 = &mut (*_13);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &((*_2).0: cell::UnsafeCell<T>);\n        _16 = cell::UnsafeCell::<T>::get(move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        _15 = &mut (*_16);\n        _11 = mem::swap::<T>(_12, _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        StorageDead(_13);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Swaps the values of two `Cell`s.\n\n The difference with `std::mem::swap` is that this function doesn't\n require a `&mut` reference.\n\n # Panics\n\n This function will panic if `self` and `other` are different `Cell`s that partially overlap.\n (Using just standard library methods, it is impossible to create such partially overlapping `Cell`s.\n However, unsafe code is allowed to e.g. create two `&Cell<[i32; 2]>` that partially overlap.)\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c1 = Cell::new(5i32);\n let c2 = Cell::new(10i32);\n c1.swap(&c2);\n assert_eq!(10, c1.get());\n assert_eq!(5, c2.get());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}