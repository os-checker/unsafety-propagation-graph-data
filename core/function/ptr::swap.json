{
  "name": "ptr::swap",
  "safe": false,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<Vec<u32>>`.\n // This is okay because we initialized it.\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n x_vec.push(3);\n assert_eq!(x_vec.len(), 4);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "ptr::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n\n If the source and destination will *never* overlap,\n [`copy_nonoverlapping`] can be used instead.\n\n `copy` is semantically equivalent to C's [`memmove`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n Copying takes place as if the bytes were copied from `src`\n to a temporary array and then copied from the array to `dst`.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\n   when `src` is read for `count * size_of::<T>()` bytes. (This means if the memory ranges\n   overlap, the `dst` pointer must not be invalidated by `src` reads.)\n\n * Both `src` and `dst` must be properly aligned.\n\n Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Efficiently create a Rust vector from an unsafe buffer:\n\n ```\n use std::ptr;\n\n /// # Safety\n ///\n /// * `ptr` must be correctly aligned for its type and non-zero.\n /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n /// * Those elements must not be used after calling this function unless `T: Copy`.\n # #[allow(dead_code)]\n unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     let mut dst = Vec::with_capacity(elts);\n\n     // SAFETY: Our precondition ensures the source is aligned and valid,\n     // and `Vec::with_capacity` ensures that we have usable space to write them.\n     unsafe { ptr::copy(ptr, dst.as_mut_ptr(), elts); }\n\n     // SAFETY: We created it with this much capacity earlier,\n     // and the previous `copy` has initialized these elements.\n     unsafe { dst.set_len(elts); }\n     dst\n }\n ```\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n Writing to memory that this pointer (non-transitively) points to is undefined behavior\n (except inside an `UnsafeCell<T>`).\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n let x_vec = unsafe { &*x.as_ptr() };\n assert_eq!(x_vec.len(), 3);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &*x.as_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain",
      "MutRef",
      "Ref"
    ]
  },
  "path": 16086,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1297:1: 1312:2",
  "src": "pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n    // Give ourselves some scratch space to work with.\n    // We do not have to worry about drops: `MaybeUninit` does nothing when dropped.\n    let mut tmp = MaybeUninit::<T>::uninit();\n\n    // Perform the swap\n    // SAFETY: the caller must guarantee that `x` and `y` are\n    // valid for writes and properly aligned. `tmp` cannot be\n    // overlapping either `x` or `y` because `tmp` was just allocated\n    // on the stack as a separate allocation.\n    unsafe {\n        copy_nonoverlapping(x, tmp.as_mut_ptr(), 1);\n        copy(y, x, 1); // `x` and `y` may overlap\n        copy_nonoverlapping(tmp.as_ptr(), y, 1);\n    }\n}",
  "mir": "fn ptr::swap(_1: *mut T, _2: *mut T) -> () {\n    let mut _0: ();\n    let mut _3: mem::maybe_uninit::MaybeUninit<T>;\n    let  _4: ();\n    let mut _5: *const T;\n    let mut _6: *mut T;\n    let mut _7: &mut mem::maybe_uninit::MaybeUninit<T>;\n    let  _8: ();\n    let mut _9: *const T;\n    let  _10: ();\n    let mut _11: *const T;\n    let mut _12: &mem::maybe_uninit::MaybeUninit<T>;\n    debug x => _1;\n    debug y => _2;\n    debug tmp => _3;\n    bb0: {\n        StorageLive(_3);\n        _3 = mem::maybe_uninit::MaybeUninit::<T>::uninit() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = _1 as *const T;\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _3;\n        _6 = mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _4 = ptr::copy_nonoverlapping::<T>(move _5, move _6, 1_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        _9 = _2 as *const T;\n        _8 = ptr::copy::<T>(move _9, _1, 1_usize) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_3;\n        _11 = mem::maybe_uninit::MaybeUninit::<T>::as_ptr(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _10 = ptr::copy_nonoverlapping::<T>(move _11, _2, 1_usize) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Swaps the values at two mutable locations of the same type, without\n deinitializing either.\n\n But for the following exceptions, this function is semantically\n equivalent to [`mem::swap`]:\n\n * It operates on raw pointers instead of references. When references are\n   available, [`mem::swap`] should be preferred.\n\n * The two pointed-to values may overlap. If the values do overlap, then the\n   overlapping region of memory from `x` will be used. This is demonstrated\n   in the second example below.\n\n * The operation is \"untyped\" in the sense that data may be uninitialized or otherwise violate\n   the requirements of `T`. The initialization state is preserved exactly.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * Both `x` and `y` must be [valid] for both reads and writes. They must remain valid even when the\n   other pointer is written. (This means if the memory ranges overlap, the two pointers must not\n   be subject to aliasing restrictions relative to each other.)\n\n * Both `x` and `y` must be properly aligned.\n\n Note that even if `T` has size `0`, the pointers must be properly aligned.\n\n [valid]: self#safety\n\n # Examples\n\n Swapping two non-overlapping regions:\n\n ```\n use std::ptr;\n\n let mut array = [0, 1, 2, 3];\n\n let (x, y) = array.split_at_mut(2);\n let x = x.as_mut_ptr().cast::<[u32; 2]>(); // this is `array[0..2]`\n let y = y.as_mut_ptr().cast::<[u32; 2]>(); // this is `array[2..4]`\n\n unsafe {\n     ptr::swap(x, y);\n     assert_eq!([2, 3, 0, 1], array);\n }\n ```\n\n Swapping two overlapping regions:\n\n ```\n use std::ptr;\n\n let mut array: [i32; 4] = [0, 1, 2, 3];\n\n let array_ptr: *mut i32 = array.as_mut_ptr();\n\n let x = array_ptr as *mut [i32; 3]; // this is `array[0..3]`\n let y = unsafe { array_ptr.add(1) } as *mut [i32; 3]; // this is `array[1..4]`\n\n unsafe {\n     ptr::swap(x, y);\n     // The indices `1..3` of the slice overlap between `x` and `y`.\n     // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are\n     // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`\n     // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).\n     // This implementation is defined to make the latter choice.\n     assert_eq!([1, 0, 1, 2], array);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}