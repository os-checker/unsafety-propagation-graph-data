{
  "name": "f128::<impl f128>::max",
  "safe": true,
  "callees": {
    "intrinsics::maxnumf128": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the maximum of two `f128` values, ignoring NaN.\n\n This behaves like IEEE 754-2008 maxNum. In particular:\n If one of the arguments is NaN, then the other argument is returned. If the inputs compare equal\n (such as for the case of `+0.0` and `-0.0`), either input may be returned non-deterministically.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n The stabilized version of this intrinsic is [`f128::max`].\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::f128::<impl f128>::max"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f128.rs:722:5: 724:6",
  "src": "pub const fn max(self, other: f128) -> f128 {\n        intrinsics::maxnumf128(self, other)\n    }",
  "mir": "fn f128::<impl f128>::max(_1: f128, _2: f128) -> f128 {\n    let mut _0: f128;\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        _0 = intrinsics::maxnumf128(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Returns the maximum of the two numbers, ignoring NaN.\n\n If exactly one of the arguments is NaN, then the other argument is returned. If both\n arguments are NaN, the return value is NaN, with the bit pattern picked using the usual\n [rules for arithmetic operations](f32#nan-bit-patterns). If the inputs compare equal (such\n as for the case of `+0.0` and `-0.0`), either input may be returned non-deterministically.\n\n This follows the IEEE 754-2008 semantics for `maxNum`, except for handling of signaling NaNs;\n this function handles all NaNs the same way and avoids `maxNum`'s problems with associativity.\n This also matches the behavior of libmâ€™s `fmax`.\n\n ```\n #![feature(f128)]\n # // Using aarch64 because `reliable_f128_math` is needed\n # #[cfg(all(target_arch = \"aarch64\", target_os = \"linux\"))] {\n\n let x = 1.0f128;\n let y = 2.0f128;\n\n assert_eq!(x.max(y), y);\n assert_eq!(x.max(f128::NAN), x);\n # }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}