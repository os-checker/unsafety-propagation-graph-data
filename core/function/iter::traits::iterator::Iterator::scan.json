{
  "name": "iter::traits::iterator::Iterator::scan",
  "safe": true,
  "callees": {
    "iter::adapters::scan::Scan::<I, St, F>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "iter::adapters::scan::Scan": "Constructor"
      }
    }
  },
  "adts": {
    "iter::adapters::scan::Scan": [
      "Plain"
    ]
  },
  "path": "iter::traits::iterator::Iterator::scan",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1435:5: 1441:6",
  "src": "fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n    where\n        Self: Sized,\n        F: FnMut(&mut St, Self::Item) -> Option<B>,\n    {\n        Scan::new(self, initial_state, f)\n    }",
  "mir": "fn iter::traits::iterator::Iterator::scan(_1: Self, _2: St, _3: F) -> iter::adapters::scan::Scan<Self, St, F> {\n    let mut _0: iter::adapters::scan::Scan<Self, St, F>;\n    debug self => _1;\n    debug initial_state => _2;\n    debug f => _3;\n    bb0: {\n        _0 = iter::adapters::scan::Scan::<Self, St, F>::new(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " An iterator adapter which, like [`fold`], holds internal state, but\n unlike [`fold`], produces a new iterator.\n\n [`fold`]: Iterator::fold\n\n `scan()` takes two arguments: an initial value which seeds the internal\n state, and a closure with two arguments, the first being a mutable\n reference to the internal state and the second an iterator element.\n The closure can assign to the internal state to share state between\n iterations.\n\n On iteration, the closure will be applied to each element of the\n iterator and the return value from the closure, an [`Option`], is\n returned by the `next` method. Thus the closure can return\n `Some(value)` to yield `value`, or `None` to end the iteration.\n\n # Examples\n\n ```\n let a = [1, 2, 3, 4];\n\n let mut iter = a.into_iter().scan(1, |state, x| {\n     // each iteration, we'll multiply the state by the element ...\n     *state = *state * x;\n\n     // ... and terminate if the state exceeds 6\n     if *state > 6 {\n         return None;\n     }\n     // ... else yield the negation of the state\n     Some(-*state)\n });\n\n assert_eq!(iter.next(), Some(-1));\n assert_eq!(iter.next(), Some(-2));\n assert_eq!(iter.next(), Some(-6));\n assert_eq!(iter.next(), None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}