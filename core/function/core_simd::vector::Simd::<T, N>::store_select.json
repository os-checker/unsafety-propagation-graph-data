{
  "name": "core_simd::vector::Simd::<T, N>::store_select",
  "safe": true,
  "callees": {
    "core_simd::vector::mask_up_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_simd::masks::Mask": "Constructor"
      }
    },
    "ops::bit::BitAndAssign::bitand_assign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `&=` operation.\n\n # Examples\n\n ```\n let mut x = true;\n x &= false;\n assert_eq!(x, false);\n\n let mut x = true;\n x &= true;\n assert_eq!(x, true);\n\n let mut x: u8 = 5;\n x &= 1;\n assert_eq!(x, 1);\n\n let mut x: u8 = 5;\n x &= 2;\n assert_eq!(x, 0);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::store_select_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Conditionally write contiguous elements starting from `ptr`.\n The `enable` mask controls which elements are written.\n When disabled, the memory location corresponding to that element is not accessed.\n\n # Safety\n\n Memory addresses for element are calculated [`pointer::wrapping_offset`] and\n each enabled element must satisfy the same conditions as [`core::ptr::write`].\n",
      "adt": {}
    }
  },
  "adts": {
    "core_simd::masks::Mask": [
      "MutRef",
      "Plain"
    ],
    "core_simd::vector::Simd": [
      "Plain"
    ]
  },
  "path": 12696,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:684:5: 689:6",
  "src": "pub fn store_select(self, slice: &mut [T], mut enable: Mask<<T as SimdElement>::Mask, N>) {\n        enable &= mask_up_to(slice.len());\n        // SAFETY: We performed the bounds check by updating the mask. &[T] is properly aligned to\n        // the element.\n        unsafe { self.store_select_ptr(slice.as_mut_ptr(), enable) }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::store_select(_1: core_simd::vector::Simd<T, N>, _2: &mut [T], _3: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>) -> () {\n    let mut _0: ();\n    let  _4: ();\n    let mut _5: &mut core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>;\n    let mut _6: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>;\n    let mut _7: usize;\n    let mut _8: &[T];\n    let mut _9: *mut T;\n    let mut _10: core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N>;\n    debug self => _1;\n    debug slice => _2;\n    debug enable => _3;\n    bb0: {\n        StorageLive(_5);\n        _5 = &mut _3;\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_2);\n        _7 = PtrMetadata(move _8);\n        StorageDead(_8);\n        _6 = core_simd::vector::mask_up_to::<<T as core_simd::vector::SimdElement>::Mask, N>(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _4 = <core_simd::masks::Mask<<T as core_simd::vector::SimdElement>::Mask, N> as ops::bit::BitAndAssign>::bitand_assign(move _5, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        _9 = slice::<impl [T]>::as_mut_ptr(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_10);\n        _10 = _3;\n        _0 = core_simd::vector::Simd::<T, N>::store_select_ptr(_1, move _9, move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": " Conditionally write contiguous elements to `slice`. The `enable` mask controls\n which elements are written, as long as they're in-bounds of the `slice`.\n If the element is disabled or out of bounds, no memory access to that location\n is made.\n\n # Examples\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::{Simd, Mask};\n let mut arr = [0i32; 4];\n let write = Simd::from_array([-5, -4, -3, -2]);\n let enable = Mask::from_array([false, true, true, true]);\n\n write.store_select(&mut arr[..3], enable);\n assert_eq!(arr, [0, -4, -3, 0]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}