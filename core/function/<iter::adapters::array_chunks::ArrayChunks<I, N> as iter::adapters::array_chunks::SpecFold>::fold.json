{
  "name": "<iter::adapters::array_chunks::ArrayChunks<I, N> as iter::adapters::array_chunks::SpecFold>::fold",
  "safe": true,
  "callees": {
    "iter::adapters::zip::TrustedRandomAccessNoCoerce::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "array::from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an array where each element is produced by calling `f` with\n that element's index while walking forward through the array.\n\n This is essentially the same as writing\n ```text\n [f(0), f(1), f(2), â€¦, f(N - 2), f(N - 1)]\n ```\n and is similar to `(0..i).map(f)`, just for arrays not iterators.\n\n If `N == 0`, this produces an empty array without ever calling `f`.\n\n # Example\n\n ```rust\n // type inference is helping us here, the way `from_fn` knows how many\n // elements to produce is the length of array down there: only arrays of\n // equal lengths can be compared, so the const generic parameter `N` is\n // inferred to be 5, thus creating array of 5 elements.\n\n let array = core::array::from_fn(|i| i);\n // indexes are:    0  1  2  3  4\n assert_eq!(array, [0, 1, 2, 3, 4]);\n\n let array2: [usize; 8] = core::array::from_fn(|i| i * 2);\n // indexes are:     0  1  2  3  4  5   6   7\n assert_eq!(array2, [0, 2, 4, 6, 8, 10, 12, 14]);\n\n let bool_arr = core::array::from_fn::<_, 5, _>(|i| i % 2 == 0);\n // indexes are:       0     1      2     3      4\n assert_eq!(bool_arr, [true, false, true, false, true]);\n ```\n\n You can also capture things, for example to create an array full of clones\n where you can't just use `[item; N]` because it's not `Copy`:\n ```\n # // TBH `array::repeat` would be better for this, but it's not stable yet.\n let my_string = String::from(\"Hello\");\n let clones: [String; 42] = std::array::from_fn(|_| my_string.clone());\n assert!(clones.iter().all(|x| *x == my_string));\n ```\n\n The array is generated in ascending index order, starting from the front\n and going towards the back, so you can use closures with mutable state:\n ```\n let mut state = 1;\n let a = std::array::from_fn(|_| { let x = state; state *= 2; x });\n assert_eq!(a, [1, 2, 4, 8, 16, 32]);\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::array_chunks::ArrayChunks": [
      "Unknown([Field(0, Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })])",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::array_chunks::ArrayChunks<I, N> as iter::adapters::array_chunks::SpecFold>::fold"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/array_chunks.rs:224:5: 250:6",
  "src": "fn fold<B, F>(mut self, init: B, mut f: F) -> B\n    where\n        Self: Sized,\n        F: FnMut(B, Self::Item) -> B,\n    {\n        let mut accum = init;\n        let inner_len = self.iter.size();\n        let mut i = 0;\n        // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n        while inner_len - i >= N {\n            let chunk = crate::array::from_fn(|local| {\n                // SAFETY: The method consumes the iterator and the loop condition ensures that\n                // all accesses are in bounds and only happen once.\n                unsafe {\n                    let idx = i + local;\n                    self.iter.__iterator_get_unchecked(idx)\n                }\n            });\n            accum = f(accum, chunk);\n            i += N;\n        }\n\n        // unlike try_fold this method does not need to take care of the remainder\n        // since `self` will be dropped\n\n        accum\n    }",
  "mir": "fn <iter::adapters::array_chunks::ArrayChunks<I, N> as iter::adapters::array_chunks::SpecFold>::fold(_1: iter::adapters::array_chunks::ArrayChunks<I, N>, _2: B, _3: F) -> B {\n    let mut _0: B;\n    let mut _4: B;\n    let  _5: usize;\n    let mut _6: &I;\n    let mut _7: usize;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let  _12: [<I as iter::traits::iterator::Iterator>::Item; N];\n    let mut _13: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/array_chunks.rs:234:47: 234:54};\n    let mut _14: &usize;\n    let mut _15: &mut I;\n    let mut _16: B;\n    let mut _17: &mut F;\n    let mut _18: (B, [<I as iter::traits::iterator::Iterator>::Item; N]);\n    let mut _19: B;\n    let mut _20: (usize, bool);\n    debug self => _1;\n    debug init => _2;\n    debug f => _3;\n    debug accum => _4;\n    debug inner_len => _5;\n    debug i => _7;\n    debug chunk => _12;\n    bb0: {\n        StorageLive(_4);\n        _4 = move _2;\n        StorageLive(_6);\n        _6 = &(_1.0: I);\n        _5 = <I as iter::adapters::zip::TrustedRandomAccessNoCoerce>::size(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = 0_usize;\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _7;\n        _11 = CheckedSub(_5, _10);\n        assert(!move (_11.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, move _10) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = move (_11.0: usize);\n        StorageDead(_10);\n        _8 = Ge(move _9, N);\n        switchInt(move _8) -> [0: bb8, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_7;\n        StorageLive(_15);\n        _15 = &mut (_1.0: I);\n        _13 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/array_chunks.rs:234:47: 234:54}(move _14, move _15);\n        StorageDead(_15);\n        StorageDead(_14);\n        _12 = array::from_fn::<<I as iter::traits::iterator::Iterator>::Item, N, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/array_chunks.rs:234:47: 234:54}>(move _13) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _3;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = move _4;\n        _18 = (move _19, _12);\n        _16 = <F as ops::function::FnMut<(B, [<I as iter::traits::iterator::Iterator>::Item; N])>>::call_mut(move _17, move _18) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        _4 = move _16;\n        StorageDead(_16);\n        _20 = CheckedAdd(_7, N);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _7, N) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _7 = move (_20.0: usize);\n        StorageDead(_8);\n        goto -> bb2;\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _0 = move _4;\n        StorageDead(_7);\n        StorageDead(_4);\n        drop(_3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        drop(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}