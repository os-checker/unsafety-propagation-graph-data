{
  "name": "fmt::num::imp::exp_u64",
  "safe": true,
  "callees": {
    "num::<impl u8>::is_ascii_alphabetic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks if the value is an ASCII alphabetic character:\n\n - U+0041 'A' ..= U+005A 'Z', or\n - U+0061 'a' ..= U+007A 'z'.\n\n # Examples\n\n ```\n let uppercase_a = b'A';\n let uppercase_g = b'G';\n let a = b'a';\n let g = b'g';\n let zero = b'0';\n let percent = b'%';\n let space = b' ';\n let lf = b'\\n';\n let esc = b'\\x1b';\n\n assert!(uppercase_a.is_ascii_alphabetic());\n assert!(uppercase_g.is_ascii_alphabetic());\n assert!(a.is_ascii_alphabetic());\n assert!(g.is_ascii_alphabetic());\n assert!(!zero.is_ascii_alphabetic());\n assert!(!percent.is_ascii_alphabetic());\n assert!(!space.is_ascii_alphabetic());\n assert!(!lf.is_ascii_alphabetic());\n assert!(!esc.is_ascii_alphabetic());\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::checked_ilog10": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base 10 logarithm of the number, rounded down.\n\n Returns `None` if the number is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::pow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Raises self to the power of `exp`, using exponentiation by squaring.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::precision": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the optionally specified precision for numeric types.\n Alternatively, the maximum width for string types.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(f32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if let Some(precision) = formatter.precision() {\n             // If we received a precision, we use it.\n             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n         } else {\n             // Otherwise we default to 2.\n             write!(formatter, \"Foo({:.2})\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n assert_eq!(format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n ```\n",
      "adt": {
        "option::Option": "Constructor",
        "fmt::Formatter": "ImmutableAsArgument"
      }
    },
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::<impl u64>::checked_pow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value,\n without checking that the value is not [`None`].\n\n # Safety\n\n Calling this method on [`None`] is *[undefined behavior]*.\n\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\");\n ```\n\n ```no_run\n let x: Option<&str> = None;\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\"); // Undefined behavior!\n ```\n",
      "adt": {}
    },
    "panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::skip": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that skips the first `n` elements.\n\n `skip(n)` skips elements until `n` elements are skipped or the end of the\n iterator is reached (whichever happens first). After that, all the remaining\n elements are yielded. In particular, if the original iterator is too short,\n then the returned iterator is empty.\n\n Rather than overriding this method directly, instead override the `nth` method.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().skip(2);\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::skip::Skip": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::rev::Rev": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::step_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator starting at the same point, but stepping by\n the given amount at each iteration.\n\n Note 1: The first element of the iterator will always be returned,\n regardless of the step given.\n\n Note 2: The time at which ignored elements are pulled is not fixed.\n `StepBy` behaves like the sequence `self.next()`, `self.nth(step-1)`,\n `self.nth(step-1)`, ‚Ä¶, but is also free to behave like the sequence\n `advance_n_and_return_first(&mut self, step)`,\n `advance_n_and_return_first(&mut self, step)`, ‚Ä¶\n Which way is used may change for some iterators for performance reasons.\n The second way will advance the iterator earlier and may consume more items.\n\n `advance_n_and_return_first` is the equivalent of:\n ```\n fn advance_n_and_return_first<I>(iter: &mut I, n: usize) -> Option<I::Item>\n where\n     I: Iterator,\n {\n     let next = iter.next();\n     if n > 1 {\n         iter.nth(n - 2);\n     }\n     next\n }\n ```\n\n # Panics\n\n The method will panic if the given step is `0`.\n\n # Examples\n\n ```\n let a = [0, 1, 2, 3, 4, 5];\n let mut iter = a.into_iter().step_by(2);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::step_by::StepBy": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "hint::unreachable_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Informs the compiler that the site which is calling this function is not\n reachable, possibly enabling further optimizations.\n\n # Safety\n\n Reaching this function is *Undefined Behavior*.\n\n As the compiler assumes that all forms of Undefined Behavior can never\n happen, it will eliminate all branches in the surrounding code that it can\n determine will invariably lead to a call to `unreachable_unchecked()`.\n\n If the assumptions embedded in using this function turn out to be wrong -\n that is, if the site which is calling `unreachable_unchecked()` is actually\n reachable at runtime - the compiler may have generated nonsensical machine\n instructions for this situation, including in seemingly unrelated code,\n causing difficult-to-debug problems.\n\n Use this function sparingly. Consider using the [`unreachable!`] macro,\n which may prevent some optimizations but will safely panic in case it is\n actually reached at runtime. Benchmark your code to find out if using\n `unreachable_unchecked()` comes with a performance benefit.\n\n # Examples\n\n `unreachable_unchecked()` can be used in situations where the compiler\n can't prove invariants that were previously established. Such situations\n have a higher chance of occurring if those invariants are upheld by\n external code that the compiler can't analyze.\n ```\n fn prepare_inputs(divisors: &mut Vec<u32>) {\n     // Note to future-self when making changes: The invariant established\n     // here is NOT checked in `do_computation()`; if this changes, you HAVE\n     // to change `do_computation()`.\n     divisors.retain(|divisor| *divisor != 0)\n }\n\n /// # Safety\n /// All elements of `divisor` must be non-zero.\n unsafe fn do_computation(i: u32, divisors: &[u32]) -> u32 {\n     divisors.iter().fold(i, |acc, divisor| {\n         // Convince the compiler that a division by zero can't happen here\n         // and a check is not needed below.\n         if *divisor == 0 {\n             // Safety: `divisor` can't be zero because of `prepare_inputs`,\n             // but the compiler does not know about this. We *promise*\n             // that we always call `prepare_inputs`.\n             unsafe { std::hint::unreachable_unchecked() }\n         }\n         // The compiler would normally introduce a check here that prevents\n         // a division by zero. However, if `divisor` was zero, the branch\n         // above would reach what we explicitly marked as unreachable.\n         // The compiler concludes that `divisor` can't be zero at this point\n         // and removes the - now proven useless - check.\n         acc / divisor\n     })\n }\n\n let mut divisors = vec![2, 0, 4];\n prepare_inputs(&mut divisors);\n let result = unsafe {\n     // Safety: prepare_inputs() guarantees that divisors is non-zero\n     do_computation(100, &divisors)\n };\n assert_eq!(result, 12);\n\n ```\n\n While using `unreachable_unchecked()` is perfectly sound in the following\n example, as the compiler is able to prove that a division by zero is not\n possible, benchmarking reveals that `unreachable_unchecked()` provides\n no benefit over using [`unreachable!`], while the latter does not introduce\n the possibility of Undefined Behavior.\n\n ```\n fn div_1(a: u32, b: u32) -> u32 {\n     use std::hint::unreachable_unchecked;\n\n     // `b.saturating_add(1)` is always positive (not zero),\n     // hence `checked_div` will never return `None`.\n     // Therefore, the else branch is unreachable.\n     a.checked_div(b.saturating_add(1))\n         .unwrap_or_else(|| unsafe { unreachable_unchecked() })\n }\n\n assert_eq!(div_1(7, 0), 7);\n assert_eq!(div_1(9, 1), 4);\n assert_eq!(div_1(11, u32::MAX), 0);\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "str::converts::from_utf8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.\n\n This is an alias to [`str::from_utf8_unchecked`].\n\n See the safe version, [`from_utf8`], for more information.\n\n # Safety\n\n The bytes passed in must be valid UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = unsafe {\n     str::from_utf8_unchecked(&sparkle_heart)\n };\n\n assert_eq!(\"üíñ\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad_integral": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.\n\n # Arguments\n\n * is_nonnegative - whether the original integer was either positive or zero.\n * prefix - if the '#' character (Alternate) is provided, this\n   is the prefix to put in front of the number.\n * buf - the byte array that the number has been formatted into\n\n This function will correctly account for the flags provided as well as\n the minimum width. It will not take precision into account.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo { nb: i32 }\n\n impl Foo {\n     fn new(nb: i32) -> Foo {\n         Foo {\n             nb,\n         }\n     }\n }\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // We need to remove \"-\" from the number output.\n         let tmp = self.nb.abs().to_string();\n\n         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    },
    "fmt::Formatter::<'a>::sign_plus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the `+` flag was specified.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if formatter.sign_plus() {\n             write!(formatter,\n                    \"Foo({}{})\",\n                    if self.0 < 0 { '-' } else { '+' },\n                    self.0.abs())\n         } else {\n             write!(formatter, \"Foo({})\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n assert_eq!(format!(\"{:+}\", Foo(-23)), \"Foo(-23)\");\n assert_eq!(format!(\"{}\", Foo(23)), \"Foo(23)\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument"
      }
    },
    "fmt::Formatter::<'a>::pad_formatted_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the formatted parts and applies the padding.\n\n Assumes that the caller already has rendered the parts with required precision,\n so that `self.precision` can be ignored.\n\n # Safety\n\n Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor",
        "num::fmt::Formatted": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "fmt::Arguments": [
      "Plain"
    ],
    "fmt::Formatter": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "panicking::AssertKind": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain",
      "MutRef"
    ],
    "ops::range::Range": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "iter::adapters::skip::Skip": [
      "Plain"
    ],
    "iter::adapters::rev::Rev": [
      "Plain"
    ],
    "iter::adapters::step_by::StepBy": [
      "Plain",
      "MutRef"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ],
    "num::fmt::Part": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ],
    "num::fmt::Formatted": [
      "Plain",
      "Ref"
    ]
  },
  "path": 12950,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:381:9: 550:10",
  "src": "fn $fmt_fn(\n            f: &mut fmt::Formatter<'_>,\n            n: $T,\n            is_nonnegative: bool,\n            letter_e: u8\n        ) -> fmt::Result {\n            debug_assert!(letter_e.is_ascii_alphabetic(), \"single-byte character\");\n\n            // Print the integer as a coefficient in range (-10, 10).\n            let mut exp = n.checked_ilog10().unwrap_or(0) as usize;\n            debug_assert!(n / (10 as $T).pow(exp as u32) < 10);\n\n            // Precisison is counted as the number of digits in the fraction.\n            let mut coef_prec = exp;\n            // Keep the digits as an integer (paired with its coef_prec count).\n            let mut coef = n;\n\n            // A Formatter may set the precision to a fixed number of decimals.\n            let more_prec = match f.precision() {\n                None => {\n                    // Omit any and all trailing zeroes.\n                    while coef_prec != 0 && coef % 10 == 0 {\n                        coef /= 10;\n                        coef_prec -= 1;\n                    }\n                    0\n                },\n\n                Some(fmt_prec) if fmt_prec >= coef_prec => {\n                    // Count the number of additional zeroes needed.\n                    fmt_prec - coef_prec\n                },\n\n                Some(fmt_prec) => {\n                    // Count the number of digits to drop.\n                    let less_prec = coef_prec - fmt_prec;\n                    assert!(less_prec > 0);\n                    // Scale down the coefficient/precision pair. For example,\n                    // coef 123456 gets coef_prec 5 (to make 1.23456). To format\n                    // the number with 2 decimals, i.e., fmt_prec 2, coef should\n                    // be scaled by 10‚Åµ‚Åª¬≤=1000 to get coef 123 with coef_prec 2.\n\n                    // SAFETY: Any precision less than coef_prec will cause a\n                    // power of ten below the coef value.\n                    let scale = unsafe {\n                        (10 as $T).checked_pow(less_prec as u32).unwrap_unchecked()\n                    };\n                    let floor = coef / scale;\n                    // Round half to even conform documentation.\n                    let over = coef % scale;\n                    let half = scale / 2;\n                    let round_up = if over < half {\n                        0\n                    } else if over > half {\n                        1\n                    } else {\n                        floor & 1 // round odd up to even\n                    };\n                    // Adding one to a scale down of at least 10 won't overflow.\n                    coef = floor + round_up;\n                    coef_prec = fmt_prec;\n\n                    // The round_up may have caused the coefficient to reach 10\n                    // (which is not permitted). For example, anything in range\n                    // [9.95, 10) becomes 10.0 when adjusted to precision 1.\n                    if round_up != 0 && coef.checked_ilog10().unwrap_or(0) as usize > coef_prec {\n                        debug_assert_eq!(coef, (10 as $T).pow(coef_prec as u32 + 1));\n                        coef /= 10; // drop one trailing zero\n                        exp += 1;   // one power of ten higher\n                    }\n                    0\n                },\n            };\n\n            // Allocate a text buffer with lazy initialization.\n            const MAX_DEC_N: usize = $T::MAX.ilog10() as usize + 1;\n            const MAX_COEF_LEN: usize = MAX_DEC_N + \".\".len();\n            const MAX_TEXT_LEN: usize = MAX_COEF_LEN + \"e99\".len();\n            let mut buf = [MaybeUninit::<u8>::uninit(); MAX_TEXT_LEN];\n\n            // Encode the coefficient in buf[..coef_len].\n            let (lead_dec, coef_len) = if coef_prec == 0 && more_prec == 0 {\n                (coef, 1_usize) // single digit; no fraction\n            } else {\n                buf[1].write(b'.');\n                let fraction_range = 2..(2 + coef_prec);\n\n                // Consume the least-significant decimals from a working copy.\n                let mut remain = coef;\n                #[cfg(feature = \"optimize_for_size\")] {\n                    for i in fraction_range.clone().rev() {\n                        let digit = (remain % 10) as usize;\n                        remain /= 10;\n                        buf[i].write(b'0' + digit as u8);\n                    }\n                }\n                #[cfg(not(feature = \"optimize_for_size\"))] {\n                    // Write digits per two at a time with a lookup table.\n                    for i in fraction_range.clone().skip(1).rev().step_by(2) {\n                        let pair = (remain % 100) as usize;\n                        remain /= 100;\n                        buf[i - 1].write(DECIMAL_PAIRS[pair * 2 + 0]);\n                        buf[i - 0].write(DECIMAL_PAIRS[pair * 2 + 1]);\n                    }\n                    // An odd number of digits leave one digit remaining.\n                    if coef_prec & 1 != 0 {\n                        let digit = (remain % 10) as usize;\n                        remain /= 10;\n                        buf[fraction_range.start].write(b'0' + digit as u8);\n                    }\n                }\n\n                (remain, fraction_range.end)\n            };\n            debug_assert!(lead_dec < 10);\n            debug_assert!(lead_dec != 0 || coef == 0, \"significant digits only\");\n            buf[0].write(b'0' + lead_dec as u8);\n\n            // SAFETY: The number of decimals is limited, captured by MAX.\n            unsafe { core::hint::assert_unchecked(coef_len <= MAX_COEF_LEN) }\n            // Encode the scale factor in buf[coef_len..text_len].\n            buf[coef_len].write(letter_e);\n            let text_len: usize = match exp {\n                ..10 => {\n                    buf[coef_len + 1].write(b'0' + exp as u8);\n                    coef_len + 2\n                },\n                10..100 => {\n                    #[cfg(feature = \"optimize_for_size\")] {\n                        buf[coef_len + 1].write(b'0' + (exp / 10) as u8);\n                        buf[coef_len + 2].write(b'0' + (exp % 10) as u8);\n                    }\n                    #[cfg(not(feature = \"optimize_for_size\"))] {\n                        buf[coef_len + 1].write(DECIMAL_PAIRS[exp * 2 + 0]);\n                        buf[coef_len + 2].write(DECIMAL_PAIRS[exp * 2 + 1]);\n                    }\n                    coef_len + 3\n                },\n                _ => {\n                    const { assert!($T::MAX.ilog10() < 100) };\n                    // SAFETY: A `u256::MAX` would get exponent 77.\n                    unsafe { core::hint::unreachable_unchecked() }\n                }\n            };\n            // SAFETY: All bytes up until text_len have been set.\n            let text = unsafe { buf[..text_len].assume_init_ref() };\n\n            if more_prec == 0 {\n                // SAFETY: Text is set with ASCII exclusively: either a decimal,\n                // or a LETTER_E, or a dot. ASCII implies valid UTF-8.\n                let as_str = unsafe { str::from_utf8_unchecked(text) };\n                f.pad_integral(is_nonnegative, \"\", as_str)\n            } else {\n                let parts = &[\n                    numfmt::Part::Copy(&text[..coef_len]),\n                    numfmt::Part::Zero(more_prec),\n                    numfmt::Part::Copy(&text[coef_len..]),\n                ];\n                let sign = if !is_nonnegative {\n                    \"-\"\n                } else if f.sign_plus() {\n                    \"+\"\n                } else {\n                    \"\"\n                };\n                // SAFETY: Text is set with ASCII exclusively: either a decimal,\n                // or a LETTER_E, or a dot. ASCII implies valid UTF-8.\n                unsafe { f.pad_formatted_parts(&numfmt::Formatted { sign, parts }) }\n            }\n        }",
  "mir": "fn fmt::num::imp::exp_u64(_1: &mut fmt::Formatter<'_>, _2: u64, _3: bool, _4: u8) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _5: bool;\n    let mut _6: &u8;\n    let  _7: !;\n    let mut _8: fmt::Arguments<'_>;\n    let mut _9: usize;\n    let mut _10: u32;\n    let mut _11: option::Option<u32>;\n    let mut _12: bool;\n    let mut _13: u64;\n    let mut _14: u64;\n    let mut _15: u32;\n    let mut _16: usize;\n    let mut _17: bool;\n    let mut _18: !;\n    let mut _19: usize;\n    let mut _20: u64;\n    let  _21: usize;\n    let mut _22: option::Option<usize>;\n    let mut _23: &fmt::Formatter<'_>;\n    let mut _24: isize;\n    let mut _25: usize;\n    let mut _26: u64;\n    let mut _27: u64;\n    let mut _28: bool;\n    let mut _29: bool;\n    let mut _30: (usize, bool);\n    let  _31: usize;\n    let  _32: &usize;\n    let mut _33: bool;\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: usize;\n    let mut _37: (usize, bool);\n    let  _38: usize;\n    let  _39: usize;\n    let mut _40: usize;\n    let mut _41: (usize, bool);\n    let mut _42: bool;\n    let mut _43: !;\n    let  _44: u64;\n    let mut _45: option::Option<u64>;\n    let mut _46: u32;\n    let  _47: u64;\n    let mut _48: u64;\n    let mut _49: bool;\n    let  _50: u64;\n    let mut _51: u64;\n    let mut _52: bool;\n    let  _53: u64;\n    let mut _54: bool;\n    let  _55: u64;\n    let mut _56: bool;\n    let mut _57: bool;\n    let mut _58: u64;\n    let mut _59: (u64, bool);\n    let mut _60: u64;\n    let mut _61: bool;\n    let mut _62: usize;\n    let mut _63: u32;\n    let mut _64: option::Option<u32>;\n    let mut _65: u64;\n    let mut _66: usize;\n    let mut _67: (&u64, &u64);\n    let mut _68: &u64;\n    let mut _69: &u64;\n    let  _70: u64;\n    let mut _71: u32;\n    let mut _72: u32;\n    let mut _73: usize;\n    let mut _74: (u32, bool);\n    let  _75: &u64;\n    let  _76: &u64;\n    let mut _77: bool;\n    let mut _78: u64;\n    let mut _79: u64;\n    let  _80: panicking::AssertKind;\n    let  _81: !;\n    let mut _82: option::Option<fmt::Arguments<'_>>;\n    let mut _83: bool;\n    let mut _84: (usize, bool);\n    let mut _85: [mem::maybe_uninit::MaybeUninit<u8>; 24];\n    let mut _86: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _87: u64;\n    let  _88: usize;\n    let mut _89: (u64, usize);\n    let mut _90: usize;\n    let mut _91: usize;\n    let mut _92: u64;\n    let  _93: &mut u8;\n    let mut _94: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _95: usize;\n    let mut _96: bool;\n    let  _97: ops::range::Range<usize>;\n    let mut _98: usize;\n    let mut _99: usize;\n    let mut _100: (usize, bool);\n    let mut _101: u64;\n    let mut _102: iter::adapters::step_by::StepBy<iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>>;\n    let mut _103: iter::adapters::step_by::StepBy<iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>>;\n    let mut _104: iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>;\n    let mut _105: iter::adapters::skip::Skip<ops::range::Range<usize>>;\n    let mut _106: ops::range::Range<usize>;\n    let mut _107: &ops::range::Range<usize>;\n    let mut _108: iter::adapters::step_by::StepBy<iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>>;\n    let mut _109: option::Option<usize>;\n    let mut _110: &mut iter::adapters::step_by::StepBy<iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>>;\n    let mut _111: isize;\n    let  _112: usize;\n    let  _113: usize;\n    let mut _114: u64;\n    let mut _115: u64;\n    let mut _116: bool;\n    let mut _117: bool;\n    let  _118: &mut u8;\n    let mut _119: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _120: usize;\n    let mut _121: (usize, bool);\n    let mut _122: bool;\n    let mut _123: u8;\n    let mut _124: &&[u8; 200];\n    let  _125: usize;\n    let mut _126: usize;\n    let mut _127: (usize, bool);\n    let mut _128: (usize, bool);\n    let mut _129: bool;\n    let  _130: &mut u8;\n    let mut _131: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _132: usize;\n    let mut _133: (usize, bool);\n    let mut _134: bool;\n    let mut _135: u8;\n    let mut _136: &&[u8; 200];\n    let  _137: usize;\n    let mut _138: usize;\n    let mut _139: (usize, bool);\n    let mut _140: (usize, bool);\n    let mut _141: bool;\n    let mut _142: usize;\n    let mut _143: usize;\n    let  _144: usize;\n    let mut _145: u64;\n    let mut _146: u64;\n    let mut _147: bool;\n    let mut _148: bool;\n    let  _149: &mut u8;\n    let mut _150: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _151: usize;\n    let mut _152: bool;\n    let mut _153: u8;\n    let mut _154: u8;\n    let mut _155: (u8, bool);\n    let mut _156: u64;\n    let mut _157: usize;\n    let mut _158: bool;\n    let mut _159: !;\n    let mut _160: u64;\n    let  _161: !;\n    let mut _162: fmt::Arguments<'_>;\n    let  _163: &mut u8;\n    let mut _164: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _165: usize;\n    let mut _166: bool;\n    let mut _167: u8;\n    let mut _168: u8;\n    let mut _169: (u8, bool);\n    let  _170: ();\n    let mut _171: bool;\n    let  _172: &mut u8;\n    let mut _173: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _174: bool;\n    let  _175: usize;\n    let mut _176: bool;\n    let mut _177: bool;\n    let mut _178: bool;\n    let  _179: &mut u8;\n    let mut _180: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _181: usize;\n    let mut _182: (usize, bool);\n    let mut _183: bool;\n    let mut _184: u8;\n    let mut _185: u8;\n    let mut _186: usize;\n    let mut _187: (u8, bool);\n    let mut _188: (usize, bool);\n    let  _189: &mut u8;\n    let mut _190: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _191: usize;\n    let mut _192: (usize, bool);\n    let mut _193: bool;\n    let mut _194: u8;\n    let mut _195: &&[u8; 200];\n    let  _196: usize;\n    let mut _197: usize;\n    let mut _198: usize;\n    let mut _199: (usize, bool);\n    let mut _200: (usize, bool);\n    let mut _201: bool;\n    let  _202: &mut u8;\n    let mut _203: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _204: usize;\n    let mut _205: (usize, bool);\n    let mut _206: bool;\n    let mut _207: u8;\n    let mut _208: &&[u8; 200];\n    let  _209: usize;\n    let mut _210: usize;\n    let mut _211: usize;\n    let mut _212: (usize, bool);\n    let mut _213: (usize, bool);\n    let mut _214: bool;\n    let mut _215: (usize, bool);\n    let mut _216: !;\n    let  _217: &[u8];\n    let  _218: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _219: &[mem::maybe_uninit::MaybeUninit<u8>; 24];\n    let mut _220: ops::range::RangeTo<usize>;\n    let mut _221: usize;\n    let mut _222: usize;\n    let  _223: &str;\n    let mut _224: &str;\n    let  _225: &[num::fmt::Part<'_>; 3];\n    let  _226: [num::fmt::Part<'_>; 3];\n    let mut _227: num::fmt::Part<'_>;\n    let  _228: &[u8];\n    let mut _229: ops::range::RangeTo<usize>;\n    let mut _230: num::fmt::Part<'_>;\n    let mut _231: usize;\n    let mut _232: num::fmt::Part<'_>;\n    let  _233: &[u8];\n    let mut _234: ops::range::RangeFrom<usize>;\n    let  _235: &str;\n    let  _236: &str;\n    let mut _237: bool;\n    let mut _238: &fmt::Formatter<'_>;\n    let  _239: &num::fmt::Formatted<'_>;\n    let  _240: num::fmt::Formatted<'_>;\n    let mut _241: &str;\n    let mut _242: &[num::fmt::Part<'_>];\n    let mut _243: &[u8; 200];\n    let mut _244: &[u8; 200];\n    let mut _245: &[u8; 200];\n    let mut _246: &[u8; 200];\n    debug f => _1;\n    debug n => _2;\n    debug is_nonnegative => _3;\n    debug letter_e => _4;\n    debug exp => _9;\n    debug coef_prec => _19;\n    debug coef => _20;\n    debug more_prec => _21;\n    debug fmt_prec => _31;\n    debug fmt_prec => _32;\n    debug fmt_prec => _38;\n    debug less_prec => _39;\n    debug scale => _44;\n    debug floor => _47;\n    debug over => _50;\n    debug half => _53;\n    debug round_up => _55;\n    debug left_val => _75;\n    debug right_val => _76;\n    debug kind => _80;\n    debug buf => _85;\n    debug lead_dec => _87;\n    debug coef_len => _88;\n    debug fraction_range => _97;\n    debug remain => _101;\n    debug iter => _108;\n    debug i => _112;\n    debug pair => _113;\n    debug digit => _144;\n    debug text_len => _175;\n    debug text => _217;\n    debug as_str => _223;\n    debug parts => _225;\n    debug sign => _235;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_4;\n        _5 = num::<impl u8>::is_ascii_alphabetic(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _5) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = num::<impl u64>::checked_ilog10(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = fmt::Arguments::<'_>::from_str(\"single-byte character\") -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = panicking::panic_fmt(move _8) -> unwind unreachable;\n    }\n    bb5: {\n        _10 = option::Option::<u32>::unwrap_or(move _11, 0_u32) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _9 = move _10 as usize;\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _9;\n        _15 = move _16 as u32;\n        StorageDead(_16);\n        _14 = num::<impl u64>::pow(10_u64, move _15) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_15);\n        _17 = Eq(_14, 0_u64);\n        assert(!move _17, \"attempt to divide `{}` by zero\", _2) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _13 = Div(_2, move _14);\n        StorageDead(_14);\n        _12 = Lt(move _13, 10_u64);\n        switchInt(move _12) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_19);\n        _19 = _9;\n        StorageLive(_20);\n        _20 = _2;\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &(*_1);\n        _22 = fmt::Formatter::<'_>::precision(move _23) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        _18 = panicking::panic(\"assertion failed: n / (10 as u64).pow(exp as u32) < 10\") -> unwind unreachable;\n    }\n    bb11: {\n        StorageDead(_23);\n        _24 = discriminant(_22);\n        switchInt(move _24) -> [0: bb14, 1: bb13, otherwise: bb12];\n    }\n    bb12: {\n        unreachable;\n    }\n    bb13: {\n        StorageLive(_32);\n        _32 = &((_22 as variant#1).0: usize);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = (*_32);\n        StorageLive(_35);\n        _35 = _19;\n        _33 = Ge(move _34, move _35);\n        switchInt(move _33) -> [0: bb24, otherwise: bb23];\n    }\n    bb14: {\n        StorageLive(_25);\n        _25 = _19;\n        switchInt(move _25) -> [0: bb21, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _20;\n        _28 = Eq(10_u64, 0_u64);\n        assert(!move _28, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _27) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _26 = Rem(move _27, 10_u64);\n        StorageDead(_27);\n        switchInt(move _26) -> [0: bb17, otherwise: bb20];\n    }\n    bb17: {\n        StorageDead(_26);\n        _29 = Eq(10_u64, 0_u64);\n        assert(!move _29, \"attempt to divide `{}` by zero\", _20) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _20 = Div(_20, 10_u64);\n        _30 = CheckedSub(_19, 1_usize);\n        assert(!move (_30.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _19, 1_usize) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _19 = move (_30.0: usize);\n        goto -> bb14;\n    }\n    bb20: {\n        StorageDead(_26);\n        goto -> bb22;\n    }\n    bb21: {\n        StorageDead(_25);\n        goto -> bb22;\n    }\n    bb22: {\n        _21 = 0_usize;\n        goto -> bb54;\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        _31 = ((_22 as variant#1).0: usize);\n        StorageLive(_36);\n        _36 = _19;\n        _37 = CheckedSub(_31, _36);\n        assert(!move (_37.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _31, move _36) -> [success: bb25, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_32);\n        _38 = ((_22 as variant#1).0: usize);\n        StorageLive(_40);\n        _40 = _19;\n        _41 = CheckedSub(_40, _38);\n        assert(!move (_41.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _40, _38) -> [success: bb26, unwind unreachable];\n    }\n    bb25: {\n        _21 = move (_37.0: usize);\n        StorageDead(_36);\n        StorageDead(_32);\n        goto -> bb54;\n    }\n    bb26: {\n        _39 = move (_41.0: usize);\n        StorageDead(_40);\n        StorageLive(_42);\n        _42 = Gt(_39, 0_usize);\n        switchInt(move _42) -> [0: bb28, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_42);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = _39 as u32;\n        _45 = num::<impl u64>::checked_pow(10_u64, move _46) -> [return: bb29, unwind unreachable];\n    }\n    bb28: {\n        _43 = panicking::panic(\"assertion failed: less_prec > 0\") -> unwind unreachable;\n    }\n    bb29: {\n        StorageDead(_46);\n        _44 = option::Option::<u64>::unwrap_unchecked(move _45) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_45);\n        StorageLive(_48);\n        _48 = _20;\n        _49 = Eq(_44, 0_u64);\n        assert(!move _49, \"attempt to divide `{}` by zero\", _48) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _47 = Div(move _48, _44);\n        StorageDead(_48);\n        StorageLive(_51);\n        _51 = _20;\n        _52 = Eq(_44, 0_u64);\n        assert(!move _52, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _51) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _50 = Rem(move _51, _44);\n        StorageDead(_51);\n        _54 = Eq(2_u64, 0_u64);\n        assert(!move _54, \"attempt to divide `{}` by zero\", _44) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _53 = Div(_44, 2_u64);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = Lt(_50, _53);\n        switchInt(move _56) -> [0: bb35, otherwise: bb34];\n    }\n    bb34: {\n        _55 = 0_u64;\n        goto -> bb39;\n    }\n    bb35: {\n        StorageLive(_57);\n        _57 = Gt(_50, _53);\n        switchInt(move _57) -> [0: bb37, otherwise: bb36];\n    }\n    bb36: {\n        _55 = 1_u64;\n        goto -> bb38;\n    }\n    bb37: {\n        _55 = BitAnd(_47, 1_u64);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_57);\n        goto -> bb39;\n    }\n    bb39: {\n        StorageDead(_56);\n        StorageLive(_58);\n        _58 = _55;\n        _59 = CheckedAdd(_47, _58);\n        assert(!move (_59.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _47, move _58) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _20 = move (_59.0: u64);\n        StorageDead(_58);\n        _19 = _38;\n        StorageLive(_60);\n        _60 = _55;\n        switchInt(move _60) -> [0: bb52, otherwise: bb41];\n    }\n    bb41: {\n        StorageDead(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = _20;\n        _64 = num::<impl u64>::checked_ilog10(move _65) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_65);\n        _63 = option::Option::<u32>::unwrap_or(move _64, 0_u32) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_64);\n        _62 = move _63 as usize;\n        StorageDead(_63);\n        StorageLive(_66);\n        _66 = _19;\n        _61 = Gt(move _62, move _66);\n        switchInt(move _61) -> [0: bb51, otherwise: bb44];\n    }\n    bb44: {\n        StorageDead(_66);\n        StorageDead(_62);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = &_20;\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        _73 = _19;\n        _72 = move _73 as u32;\n        StorageDead(_73);\n        _74 = CheckedAdd(_72, 1_u32);\n        assert(!move (_74.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _72, 1_u32) -> [success: bb45, unwind unreachable];\n    }\n    bb45: {\n        _71 = move (_74.0: u32);\n        StorageDead(_72);\n        _70 = num::<impl u64>::pow(10_u64, move _71) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_71);\n        _69 = &_70;\n        _67 = (move _68, move _69);\n        StorageDead(_69);\n        StorageDead(_68);\n        _75 = (_67.0: &u64);\n        _76 = (_67.1: &u64);\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = (*_75);\n        StorageLive(_79);\n        _79 = (*_76);\n        _77 = Eq(move _78, move _79);\n        switchInt(move _77) -> [0: bb48, otherwise: bb47];\n    }\n    bb47: {\n        StorageDead(_79);\n        StorageDead(_78);\n        StorageDead(_77);\n        StorageDead(_70);\n        StorageDead(_67);\n        _83 = Eq(10_u64, 0_u64);\n        assert(!move _83, \"attempt to divide `{}` by zero\", _20) -> [success: bb49, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_79);\n        StorageDead(_78);\n        _80 = panicking::AssertKind::Eq;\n        StorageLive(_82);\n        _82 = option::Option::None;\n        _81 = panicking::assert_failed::<u64, u64>(_80, _75, _76, move _82) -> unwind unreachable;\n    }\n    bb49: {\n        _20 = Div(_20, 10_u64);\n        _84 = CheckedAdd(_9, 1_usize);\n        assert(!move (_84.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _9 = move (_84.0: usize);\n        goto -> bb53;\n    }\n    bb51: {\n        StorageDead(_66);\n        StorageDead(_62);\n        goto -> bb53;\n    }\n    bb52: {\n        StorageDead(_60);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_61);\n        _21 = 0_usize;\n        StorageDead(_55);\n        goto -> bb54;\n    }\n    bb54: {\n        StorageDead(_22);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = mem::maybe_uninit::MaybeUninit::<u8>::uninit() -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        _85 = [move _86; 24];\n        StorageDead(_86);\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = _19;\n        switchInt(move _90) -> [0: bb56, otherwise: bb59];\n    }\n    bb56: {\n        StorageDead(_90);\n        StorageLive(_91);\n        _91 = _21;\n        switchInt(move _91) -> [0: bb57, otherwise: bb58];\n    }\n    bb57: {\n        StorageDead(_91);\n        StorageLive(_92);\n        _92 = _20;\n        _89 = (move _92, 1_usize);\n        StorageDead(_92);\n        goto -> bb95;\n    }\n    bb58: {\n        StorageDead(_91);\n        goto -> bb60;\n    }\n    bb59: {\n        StorageDead(_90);\n        goto -> bb60;\n    }\n    bb60: {\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = 1_usize;\n        _96 = Lt(_95, 24_usize);\n        assert(move _96, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _95) -> [success: bb61, unwind unreachable];\n    }\n    bb61: {\n        _94 = &mut _85[_95];\n        _93 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _94, 46_u8) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_94);\n        StorageDead(_95);\n        StorageDead(_93);\n        StorageLive(_97);\n        StorageLive(_98);\n        StorageLive(_99);\n        _99 = _19;\n        _100 = CheckedAdd(2_usize, _99);\n        assert(!move (_100.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 2_usize, move _99) -> [success: bb63, unwind unreachable];\n    }\n    bb63: {\n        _98 = move (_100.0: usize);\n        StorageDead(_99);\n        _97 = Range(2_usize, move _98);\n        StorageDead(_98);\n        StorageLive(_101);\n        _101 = _20;\n        StorageLive(_102);\n        StorageLive(_103);\n        StorageLive(_104);\n        StorageLive(_105);\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = &_97;\n        _106 = <ops::range::Range<usize> as clone::Clone>::clone(move _107) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_107);\n        _105 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::skip(move _106, 1_usize) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        StorageDead(_106);\n        _104 = <iter::adapters::skip::Skip<ops::range::Range<usize>> as iter::traits::iterator::Iterator>::rev(move _105) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_105);\n        _103 = <iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>> as iter::traits::iterator::Iterator>::step_by(move _104, 2_usize) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_104);\n        _102 = <iter::adapters::step_by::StepBy<iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>> as iter::traits::collect::IntoIterator>::into_iter(move _103) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_103);\n        StorageLive(_108);\n        _108 = move _102;\n        goto -> bb69;\n    }\n    bb69: {\n        StorageLive(_109);\n        _110 = &mut _108;\n        _109 = <iter::adapters::step_by::StepBy<iter::adapters::rev::Rev<iter::adapters::skip::Skip<ops::range::Range<usize>>>> as iter::traits::iterator::Iterator>::next(_110) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        _111 = discriminant(_109);\n        switchInt(move _111) -> [0: bb72, 1: bb71, otherwise: bb12];\n    }\n    bb71: {\n        _112 = ((_109 as variant#1).0: usize);\n        StorageLive(_114);\n        StorageLive(_115);\n        _115 = _101;\n        _116 = Eq(100_u64, 0_u64);\n        assert(!move _116, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _115) -> [success: bb73, unwind unreachable];\n    }\n    bb72: {\n        StorageDead(_109);\n        StorageDead(_108);\n        StorageDead(_102);\n        StorageLive(_142);\n        StorageLive(_143);\n        _143 = _19;\n        _142 = BitAnd(move _143, 1_usize);\n        StorageDead(_143);\n        switchInt(move _142) -> [0: bb88, otherwise: bb87];\n    }\n    bb73: {\n        _114 = Rem(move _115, 100_u64);\n        StorageDead(_115);\n        _113 = move _114 as usize;\n        StorageDead(_114);\n        _117 = Eq(100_u64, 0_u64);\n        assert(!move _117, \"attempt to divide `{}` by zero\", _101) -> [success: bb74, unwind unreachable];\n    }\n    bb74: {\n        _101 = Div(_101, 100_u64);\n        StorageLive(_118);\n        StorageLive(_119);\n        StorageLive(_120);\n        _121 = CheckedSub(_112, 1_usize);\n        assert(!move (_121.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _112, 1_usize) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _120 = move (_121.0: usize);\n        _122 = Lt(_120, 24_usize);\n        assert(move _122, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _120) -> [success: bb76, unwind unreachable];\n    }\n    bb76: {\n        _119 = &mut _85[_120];\n        StorageLive(_123);\n        StorageLive(_124);\n        _124 = {alloc1915: &&[u8; 200]};\n        StorageLive(_125);\n        StorageLive(_126);\n        _127 = CheckedMul(_113, 2_usize);\n        assert(!move (_127.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _113, 2_usize) -> [success: bb77, unwind unreachable];\n    }\n    bb77: {\n        _126 = move (_127.0: usize);\n        _128 = CheckedAdd(_126, 0_usize);\n        assert(!move (_128.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _126, 0_usize) -> [success: bb78, unwind unreachable];\n    }\n    bb78: {\n        _125 = move (_128.0: usize);\n        StorageDead(_126);\n        _129 = Lt(_125, 200_usize);\n        assert(move _129, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _125) -> [success: bb79, unwind unreachable];\n    }\n    bb79: {\n        _243 = (*_124);\n        _123 = (*_243)[_125];\n        _118 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _119, move _123) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_123);\n        StorageDead(_119);\n        StorageDead(_125);\n        StorageDead(_124);\n        StorageDead(_120);\n        StorageDead(_118);\n        StorageLive(_130);\n        StorageLive(_131);\n        StorageLive(_132);\n        _133 = CheckedSub(_112, 0_usize);\n        assert(!move (_133.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _112, 0_usize) -> [success: bb81, unwind unreachable];\n    }\n    bb81: {\n        _132 = move (_133.0: usize);\n        _134 = Lt(_132, 24_usize);\n        assert(move _134, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _132) -> [success: bb82, unwind unreachable];\n    }\n    bb82: {\n        _131 = &mut _85[_132];\n        StorageLive(_135);\n        StorageLive(_136);\n        _136 = {alloc1915: &&[u8; 200]};\n        StorageLive(_137);\n        StorageLive(_138);\n        _139 = CheckedMul(_113, 2_usize);\n        assert(!move (_139.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _113, 2_usize) -> [success: bb83, unwind unreachable];\n    }\n    bb83: {\n        _138 = move (_139.0: usize);\n        _140 = CheckedAdd(_138, 1_usize);\n        assert(!move (_140.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _138, 1_usize) -> [success: bb84, unwind unreachable];\n    }\n    bb84: {\n        _137 = move (_140.0: usize);\n        StorageDead(_138);\n        _141 = Lt(_137, 200_usize);\n        assert(move _141, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _137) -> [success: bb85, unwind unreachable];\n    }\n    bb85: {\n        _244 = (*_136);\n        _135 = (*_244)[_137];\n        _130 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _131, move _135) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        StorageDead(_135);\n        StorageDead(_131);\n        StorageDead(_137);\n        StorageDead(_136);\n        StorageDead(_132);\n        StorageDead(_130);\n        StorageDead(_109);\n        goto -> bb69;\n    }\n    bb87: {\n        StorageDead(_142);\n        StorageLive(_145);\n        StorageLive(_146);\n        _146 = _101;\n        _147 = Eq(10_u64, 0_u64);\n        assert(!move _147, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _146) -> [success: bb89, unwind unreachable];\n    }\n    bb88: {\n        StorageDead(_142);\n        goto -> bb94;\n    }\n    bb89: {\n        _145 = Rem(move _146, 10_u64);\n        StorageDead(_146);\n        _144 = move _145 as usize;\n        StorageDead(_145);\n        _148 = Eq(10_u64, 0_u64);\n        assert(!move _148, \"attempt to divide `{}` by zero\", _101) -> [success: bb90, unwind unreachable];\n    }\n    bb90: {\n        _101 = Div(_101, 10_u64);\n        StorageLive(_149);\n        StorageLive(_150);\n        StorageLive(_151);\n        _151 = (_97.0: usize);\n        _152 = Lt(_151, 24_usize);\n        assert(move _152, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _151) -> [success: bb91, unwind unreachable];\n    }\n    bb91: {\n        _150 = &mut _85[_151];\n        StorageLive(_153);\n        StorageLive(_154);\n        _154 = _144 as u8;\n        _155 = CheckedAdd(48_u8, _154);\n        assert(!move (_155.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _154) -> [success: bb92, unwind unreachable];\n    }\n    bb92: {\n        _153 = move (_155.0: u8);\n        StorageDead(_154);\n        _149 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _150, move _153) -> [return: bb93, unwind unreachable];\n    }\n    bb93: {\n        StorageDead(_153);\n        StorageDead(_150);\n        StorageDead(_151);\n        StorageDead(_149);\n        goto -> bb94;\n    }\n    bb94: {\n        StorageLive(_156);\n        _156 = _101;\n        StorageLive(_157);\n        _157 = (_97.1: usize);\n        _89 = (move _156, move _157);\n        StorageDead(_157);\n        StorageDead(_156);\n        StorageDead(_101);\n        StorageDead(_97);\n        goto -> bb95;\n    }\n    bb95: {\n        _87 = (_89.0: u64);\n        _88 = (_89.1: usize);\n        StorageDead(_89);\n        StorageLive(_158);\n        _158 = Lt(_87, 10_u64);\n        switchInt(move _158) -> [0: bb97, otherwise: bb96];\n    }\n    bb96: {\n        StorageDead(_158);\n        switchInt(_87) -> [0: bb99, otherwise: bb98];\n    }\n    bb97: {\n        _159 = panicking::panic(\"assertion failed: lead_dec < 10\") -> unwind unreachable;\n    }\n    bb98: {\n        goto -> bb103;\n    }\n    bb99: {\n        StorageLive(_160);\n        _160 = _20;\n        switchInt(move _160) -> [0: bb100, otherwise: bb101];\n    }\n    bb100: {\n        StorageDead(_160);\n        goto -> bb103;\n    }\n    bb101: {\n        StorageDead(_160);\n        StorageLive(_162);\n        _162 = fmt::Arguments::<'_>::from_str(\"significant digits only\") -> [return: bb102, unwind unreachable];\n    }\n    bb102: {\n        _161 = panicking::panic_fmt(move _162) -> unwind unreachable;\n    }\n    bb103: {\n        StorageLive(_163);\n        StorageLive(_164);\n        StorageLive(_165);\n        _165 = 0_usize;\n        _166 = Lt(_165, 24_usize);\n        assert(move _166, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _165) -> [success: bb104, unwind unreachable];\n    }\n    bb104: {\n        _164 = &mut _85[_165];\n        StorageLive(_167);\n        StorageLive(_168);\n        _168 = _87 as u8;\n        _169 = CheckedAdd(48_u8, _168);\n        assert(!move (_169.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _168) -> [success: bb105, unwind unreachable];\n    }\n    bb105: {\n        _167 = move (_169.0: u8);\n        StorageDead(_168);\n        _163 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _164, move _167) -> [return: bb106, unwind unreachable];\n    }\n    bb106: {\n        StorageDead(_167);\n        StorageDead(_164);\n        StorageDead(_165);\n        StorageDead(_163);\n        StorageLive(_171);\n        _171 = Le(_88, fmt::num::imp::exp_u64::MAX_COEF_LEN);\n        _170 = hint::assert_unchecked(move _171) -> [return: bb107, unwind unreachable];\n    }\n    bb107: {\n        StorageDead(_171);\n        StorageLive(_172);\n        StorageLive(_173);\n        _174 = Lt(_88, 24_usize);\n        assert(move _174, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _88) -> [success: bb108, unwind unreachable];\n    }\n    bb108: {\n        _173 = &mut _85[_88];\n        _172 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _173, _4) -> [return: bb109, unwind unreachable];\n    }\n    bb109: {\n        StorageDead(_173);\n        StorageDead(_172);\n        StorageLive(_175);\n        _178 = Lt(_9, 10_usize);\n        switchInt(move _178) -> [0: bb111, otherwise: bb114];\n    }\n    bb110: {\n        _216 = hint::unreachable_unchecked() -> unwind unreachable;\n    }\n    bb111: {\n        _176 = Le(10_usize, _9);\n        switchInt(move _176) -> [0: bb110, otherwise: bb113];\n    }\n    bb112: {\n        StorageLive(_189);\n        StorageLive(_190);\n        StorageLive(_191);\n        _192 = CheckedAdd(_88, 1_usize);\n        assert(!move (_192.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _88, 1_usize) -> [success: bb120, unwind unreachable];\n    }\n    bb113: {\n        _177 = Lt(_9, 100_usize);\n        switchInt(move _177) -> [0: bb110, otherwise: bb112];\n    }\n    bb114: {\n        StorageLive(_179);\n        StorageLive(_180);\n        StorageLive(_181);\n        _182 = CheckedAdd(_88, 1_usize);\n        assert(!move (_182.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _88, 1_usize) -> [success: bb115, unwind unreachable];\n    }\n    bb115: {\n        _181 = move (_182.0: usize);\n        _183 = Lt(_181, 24_usize);\n        assert(move _183, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _181) -> [success: bb116, unwind unreachable];\n    }\n    bb116: {\n        _180 = &mut _85[_181];\n        StorageLive(_184);\n        StorageLive(_185);\n        StorageLive(_186);\n        _186 = _9;\n        _185 = move _186 as u8;\n        StorageDead(_186);\n        _187 = CheckedAdd(48_u8, _185);\n        assert(!move (_187.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _185) -> [success: bb117, unwind unreachable];\n    }\n    bb117: {\n        _184 = move (_187.0: u8);\n        StorageDead(_185);\n        _179 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _180, move _184) -> [return: bb118, unwind unreachable];\n    }\n    bb118: {\n        StorageDead(_184);\n        StorageDead(_180);\n        StorageDead(_181);\n        StorageDead(_179);\n        _188 = CheckedAdd(_88, 2_usize);\n        assert(!move (_188.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _88, 2_usize) -> [success: bb119, unwind unreachable];\n    }\n    bb119: {\n        _175 = move (_188.0: usize);\n        goto -> bb133;\n    }\n    bb120: {\n        _191 = move (_192.0: usize);\n        _193 = Lt(_191, 24_usize);\n        assert(move _193, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _191) -> [success: bb121, unwind unreachable];\n    }\n    bb121: {\n        _190 = &mut _85[_191];\n        StorageLive(_194);\n        StorageLive(_195);\n        _195 = {alloc1915: &&[u8; 200]};\n        StorageLive(_196);\n        StorageLive(_197);\n        StorageLive(_198);\n        _198 = _9;\n        _199 = CheckedMul(_198, 2_usize);\n        assert(!move (_199.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _198, 2_usize) -> [success: bb122, unwind unreachable];\n    }\n    bb122: {\n        _197 = move (_199.0: usize);\n        StorageDead(_198);\n        _200 = CheckedAdd(_197, 0_usize);\n        assert(!move (_200.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _197, 0_usize) -> [success: bb123, unwind unreachable];\n    }\n    bb123: {\n        _196 = move (_200.0: usize);\n        StorageDead(_197);\n        _201 = Lt(_196, 200_usize);\n        assert(move _201, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _196) -> [success: bb124, unwind unreachable];\n    }\n    bb124: {\n        _245 = (*_195);\n        _194 = (*_245)[_196];\n        _189 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _190, move _194) -> [return: bb125, unwind unreachable];\n    }\n    bb125: {\n        StorageDead(_194);\n        StorageDead(_190);\n        StorageDead(_196);\n        StorageDead(_195);\n        StorageDead(_191);\n        StorageDead(_189);\n        StorageLive(_202);\n        StorageLive(_203);\n        StorageLive(_204);\n        _205 = CheckedAdd(_88, 2_usize);\n        assert(!move (_205.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _88, 2_usize) -> [success: bb126, unwind unreachable];\n    }\n    bb126: {\n        _204 = move (_205.0: usize);\n        _206 = Lt(_204, 24_usize);\n        assert(move _206, \"index out of bounds: the length is {} but the index is {}\", 24_usize, _204) -> [success: bb127, unwind unreachable];\n    }\n    bb127: {\n        _203 = &mut _85[_204];\n        StorageLive(_207);\n        StorageLive(_208);\n        _208 = {alloc1915: &&[u8; 200]};\n        StorageLive(_209);\n        StorageLive(_210);\n        StorageLive(_211);\n        _211 = _9;\n        _212 = CheckedMul(_211, 2_usize);\n        assert(!move (_212.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _211, 2_usize) -> [success: bb128, unwind unreachable];\n    }\n    bb128: {\n        _210 = move (_212.0: usize);\n        StorageDead(_211);\n        _213 = CheckedAdd(_210, 1_usize);\n        assert(!move (_213.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _210, 1_usize) -> [success: bb129, unwind unreachable];\n    }\n    bb129: {\n        _209 = move (_213.0: usize);\n        StorageDead(_210);\n        _214 = Lt(_209, 200_usize);\n        assert(move _214, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _209) -> [success: bb130, unwind unreachable];\n    }\n    bb130: {\n        _246 = (*_208);\n        _207 = (*_246)[_209];\n        _202 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _203, move _207) -> [return: bb131, unwind unreachable];\n    }\n    bb131: {\n        StorageDead(_207);\n        StorageDead(_203);\n        StorageDead(_209);\n        StorageDead(_208);\n        StorageDead(_204);\n        StorageDead(_202);\n        _215 = CheckedAdd(_88, 3_usize);\n        assert(!move (_215.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _88, 3_usize) -> [success: bb132, unwind unreachable];\n    }\n    bb132: {\n        _175 = move (_215.0: usize);\n        goto -> bb133;\n    }\n    bb133: {\n        StorageLive(_219);\n        _219 = &_85;\n        StorageLive(_220);\n        StorageLive(_221);\n        _221 = _175;\n        _220 = RangeTo(move _221);\n        StorageDead(_221);\n        _218 = <[mem::maybe_uninit::MaybeUninit<u8>; 24] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _219, move _220) -> [return: bb134, unwind unreachable];\n    }\n    bb134: {\n        StorageDead(_220);\n        StorageDead(_219);\n        _217 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_218) -> [return: bb135, unwind unreachable];\n    }\n    bb135: {\n        StorageLive(_222);\n        _222 = _21;\n        switchInt(move _222) -> [0: bb136, otherwise: bb139];\n    }\n    bb136: {\n        StorageDead(_222);\n        _223 = str::converts::from_utf8_unchecked(_217) -> [return: bb137, unwind unreachable];\n    }\n    bb137: {\n        StorageLive(_224);\n        _224 = \"\";\n        _0 = fmt::Formatter::<'_>::pad_integral(_1, _3, move _224, _223) -> [return: bb138, unwind unreachable];\n    }\n    bb138: {\n        StorageDead(_224);\n        goto -> bb150;\n    }\n    bb139: {\n        StorageDead(_222);\n        StorageLive(_226);\n        StorageLive(_227);\n        StorageLive(_229);\n        _229 = RangeTo(_88);\n        _228 = <[u8] as ops::index::Index<ops::range::RangeTo<usize>>>::index(_217, move _229) -> [return: bb140, unwind unreachable];\n    }\n    bb140: {\n        StorageDead(_229);\n        _227 = num::fmt::Part::Copy(_228);\n        StorageLive(_230);\n        StorageLive(_231);\n        _231 = _21;\n        _230 = num::fmt::Part::Zero(move _231);\n        StorageDead(_231);\n        StorageLive(_232);\n        StorageLive(_234);\n        _234 = RangeFrom(_88);\n        _233 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(_217, move _234) -> [return: bb141, unwind unreachable];\n    }\n    bb141: {\n        StorageDead(_234);\n        _232 = num::fmt::Part::Copy(_233);\n        _226 = [move _227, move _230, move _232];\n        StorageDead(_232);\n        StorageDead(_230);\n        StorageDead(_227);\n        _225 = &_226;\n        StorageLive(_235);\n        switchInt(_3) -> [0: bb142, otherwise: bb143];\n    }\n    bb142: {\n        _235 = \"-\";\n        goto -> bb148;\n    }\n    bb143: {\n        StorageLive(_236);\n        StorageLive(_237);\n        StorageLive(_238);\n        _238 = &(*_1);\n        _237 = fmt::Formatter::<'_>::sign_plus(move _238) -> [return: bb144, unwind unreachable];\n    }\n    bb144: {\n        switchInt(move _237) -> [0: bb146, otherwise: bb145];\n    }\n    bb145: {\n        StorageDead(_238);\n        _236 = \"+\";\n        goto -> bb147;\n    }\n    bb146: {\n        StorageDead(_238);\n        _236 = \"\";\n        goto -> bb147;\n    }\n    bb147: {\n        _235 = _236;\n        StorageDead(_237);\n        StorageDead(_236);\n        goto -> bb148;\n    }\n    bb148: {\n        StorageLive(_240);\n        StorageLive(_241);\n        _241 = _235;\n        StorageLive(_242);\n        _242 = _225 as &[num::fmt::Part<'_>];\n        _240 = Formatted(move _241, move _242);\n        StorageDead(_242);\n        StorageDead(_241);\n        _239 = &_240;\n        _0 = fmt::Formatter::<'_>::pad_formatted_parts(_1, _239) -> [return: bb149, unwind unreachable];\n    }\n    bb149: {\n        StorageDead(_240);\n        StorageDead(_235);\n        StorageDead(_226);\n        goto -> bb150;\n    }\n    bb150: {\n        StorageDead(_175);\n        StorageDead(_85);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}