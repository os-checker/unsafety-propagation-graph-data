{
  "name": "ops::range::IntoBounds::intersect",
  "safe": true,
  "callees": {
    "ops::range::IntoBounds::into_bounds": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert this range into the start and end bounds.\n Returns `(start_bound, end_bound)`.\n\n # Examples\n\n ```\n #![feature(range_into_bounds)]\n use std::ops::Bound::*;\n use std::ops::IntoBounds;\n\n assert_eq!((0..5).into_bounds(), (Included(0), Excluded(5)));\n assert_eq!((..=7).into_bounds(), (Unbounded, Included(7)));\n ```\n",
      "adt": {}
    },
    "cmp::Ord::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the maximum of two values.\n\n Returns the second argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.max(2), 2);\n assert_eq!(2.max(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").max(Equal(\"other\")).0, \"other\");\n ```\n",
      "adt": {}
    },
    "cmp::PartialOrd::gt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests greater than (for `self` and `other`) and is used by the `>`\n operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 > 1.0, false);\n assert_eq!(1.0 > 2.0, false);\n assert_eq!(2.0 > 1.0, true);\n ```\n",
      "adt": {}
    },
    "cmp::Ord::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.min(2), 1);\n assert_eq!(2.min(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").min(Equal(\"other\")).0, \"self\");\n ```\n",
      "adt": {}
    },
    "cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::Bound": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3499, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])",
      "Unknown([Field(1, Ty { id: 3499, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])",
      "Unknown([Field(0, Ty { id: 3499, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })])",
      "Unknown([Field(1, Ty { id: 3499, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })])",
      "Unknown([Field(0, Ty { id: 3499, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })])",
      "Unknown([Field(1, Ty { id: 3499, kind: RigidTy(Adt(AdtDef(DefId { id: 25580, name: \"ops::range::Bound\" }), GenericArgs([Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })])"
    ]
  },
  "path": {
    "type": "External",
    "path": "ops::range::IntoBounds::intersect"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/range.rs:1000:5: 1041:6",
  "src": "fn intersect<R>(self, other: R) -> (Bound<T>, Bound<T>)\n    where\n        Self: Sized,\n        T: [const] Ord + [const] Destruct,\n        R: Sized + [const] IntoBounds<T>,\n    {\n        let (self_start, self_end) = IntoBounds::into_bounds(self);\n        let (other_start, other_end) = IntoBounds::into_bounds(other);\n\n        let start = match (self_start, other_start) {\n            (Included(a), Included(b)) => Included(Ord::max(a, b)),\n            (Excluded(a), Excluded(b)) => Excluded(Ord::max(a, b)),\n            (Unbounded, Unbounded) => Unbounded,\n\n            (x, Unbounded) | (Unbounded, x) => x,\n\n            (Included(i), Excluded(e)) | (Excluded(e), Included(i)) => {\n                if i > e {\n                    Included(i)\n                } else {\n                    Excluded(e)\n                }\n            }\n        };\n        let end = match (self_end, other_end) {\n            (Included(a), Included(b)) => Included(Ord::min(a, b)),\n            (Excluded(a), Excluded(b)) => Excluded(Ord::min(a, b)),\n            (Unbounded, Unbounded) => Unbounded,\n\n            (x, Unbounded) | (Unbounded, x) => x,\n\n            (Included(i), Excluded(e)) | (Excluded(e), Included(i)) => {\n                if i < e {\n                    Included(i)\n                } else {\n                    Excluded(e)\n                }\n            }\n        };\n\n        (start, end)\n    }",
  "mir": "fn ops::range::IntoBounds::intersect(_1: Self, _2: R) -> (ops::range::Bound<T>, ops::range::Bound<T>) {\n    let mut _0: (ops::range::Bound<T>, ops::range::Bound<T>);\n    let  _3: ops::range::Bound<T>;\n    let  _4: ops::range::Bound<T>;\n    let mut _5: (ops::range::Bound<T>, ops::range::Bound<T>);\n    let  _6: ops::range::Bound<T>;\n    let  _7: ops::range::Bound<T>;\n    let mut _8: (ops::range::Bound<T>, ops::range::Bound<T>);\n    let  _9: ops::range::Bound<T>;\n    let mut _10: (ops::range::Bound<T>, ops::range::Bound<T>);\n    let mut _11: isize;\n    let mut _12: isize;\n    let mut _13: isize;\n    let mut _14: isize;\n    let mut _15: isize;\n    let mut _16: isize;\n    let mut _17: isize;\n    let mut _18: isize;\n    let  _19: T;\n    let  _20: T;\n    let mut _21: T;\n    let  _22: T;\n    let  _23: T;\n    let mut _24: T;\n    let  _25: ops::range::Bound<T>;\n    let  _26: T;\n    let  _27: T;\n    let mut _28: bool;\n    let mut _29: &T;\n    let mut _30: &T;\n    let mut _31: T;\n    let mut _32: T;\n    let  _33: ops::range::Bound<T>;\n    let mut _34: (ops::range::Bound<T>, ops::range::Bound<T>);\n    let mut _35: isize;\n    let mut _36: isize;\n    let mut _37: isize;\n    let mut _38: isize;\n    let mut _39: isize;\n    let mut _40: isize;\n    let mut _41: isize;\n    let mut _42: isize;\n    let  _43: T;\n    let  _44: T;\n    let mut _45: T;\n    let  _46: T;\n    let  _47: T;\n    let mut _48: T;\n    let  _49: ops::range::Bound<T>;\n    let  _50: T;\n    let  _51: T;\n    let mut _52: bool;\n    let mut _53: &T;\n    let mut _54: &T;\n    let mut _55: T;\n    let mut _56: T;\n    let mut _57: ops::range::Bound<T>;\n    let mut _58: ops::range::Bound<T>;\n    let mut _59: bool;\n    let mut _60: bool;\n    let mut _61: bool;\n    let mut _62: bool;\n    debug self => _1;\n    debug other => _2;\n    debug self_start => _3;\n    debug self_end => _4;\n    debug other_start => _6;\n    debug other_end => _7;\n    debug start => _9;\n    debug a => _19;\n    debug b => _20;\n    debug a => _22;\n    debug b => _23;\n    debug x => _25;\n    debug i => _26;\n    debug e => _27;\n    debug end => _33;\n    debug a => _43;\n    debug b => _44;\n    debug a => _46;\n    debug b => _47;\n    debug x => _49;\n    debug i => _50;\n    debug e => _51;\n    bb0: {\n        _60 = false;\n        _59 = false;\n        _62 = false;\n        _61 = false;\n        StorageLive(_5);\n        _5 = <Self as ops::range::IntoBounds<T>>::into_bounds(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = move (_5.0: ops::range::Bound<T>);\n        _4 = move (_5.1: ops::range::Bound<T>);\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = <R as ops::range::IntoBounds<T>>::into_bounds(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = move (_8.0: ops::range::Bound<T>);\n        _7 = move (_8.1: ops::range::Bound<T>);\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (_3, _6);\n        _14 = discriminant((_10.0: ops::range::Bound<T>));\n        switchInt(move _14) -> [0: bb4, 1: bb5, 2: bb6, otherwise: bb8];\n    }\n    bb3: {\n        _15 = discriminant((_10.1: ops::range::Bound<T>));\n        switchInt(move _15) -> [2: bb14, otherwise: bb7];\n    }\n    bb4: {\n        _11 = discriminant((_10.1: ops::range::Bound<T>));\n        switchInt(move _11) -> [0: bb17, otherwise: bb3];\n    }\n    bb5: {\n        _12 = discriminant((_10.1: ops::range::Bound<T>));\n        switchInt(move _12) -> [1: bb16, otherwise: bb3];\n    }\n    bb6: {\n        _13 = discriminant((_10.1: ops::range::Bound<T>));\n        switchInt(move _13) -> [2: bb15, otherwise: bb3];\n    }\n    bb7: {\n        _18 = discriminant((_10.0: ops::range::Bound<T>));\n        switchInt(move _18) -> [0: bb9, 1: bb10, 2: bb13, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _16 = discriminant((_10.1: ops::range::Bound<T>));\n        switchInt(move _16) -> [1: bb12, otherwise: bb8];\n    }\n    bb10: {\n        _17 = discriminant((_10.1: ops::range::Bound<T>));\n        switchInt(move _17) -> [0: bb11, otherwise: bb8];\n    }\n    bb11: {\n        StorageLive(_27);\n        _59 = true;\n        _27 = move (((_10.0: ops::range::Bound<T>) as variant#1).0: T);\n        StorageLive(_26);\n        _60 = true;\n        _26 = move (((_10.1: ops::range::Bound<T>) as variant#0).0: T);\n        goto -> bb21;\n    }\n    bb12: {\n        StorageLive(_26);\n        _60 = true;\n        _26 = move (((_10.0: ops::range::Bound<T>) as variant#0).0: T);\n        StorageLive(_27);\n        _59 = true;\n        _27 = move (((_10.1: ops::range::Bound<T>) as variant#1).0: T);\n        goto -> bb21;\n    }\n    bb13: {\n        StorageLive(_25);\n        _25 = move (_10.1: ops::range::Bound<T>);\n        goto -> bb20;\n    }\n    bb14: {\n        StorageLive(_25);\n        _25 = move (_10.0: ops::range::Bound<T>);\n        goto -> bb20;\n    }\n    bb15: {\n        _9 = ops::range::Bound::Unbounded;\n        goto -> bb28;\n    }\n    bb16: {\n        _22 = move (((_10.0: ops::range::Bound<T>) as variant#1).0: T);\n        _23 = move (((_10.1: ops::range::Bound<T>) as variant#1).0: T);\n        StorageLive(_24);\n        _24 = <T as cmp::Ord>::max(_22, _23) -> [return: bb19, unwind unreachable];\n    }\n    bb17: {\n        _19 = move (((_10.0: ops::range::Bound<T>) as variant#0).0: T);\n        _20 = move (((_10.1: ops::range::Bound<T>) as variant#0).0: T);\n        StorageLive(_21);\n        _21 = <T as cmp::Ord>::max(_19, _20) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _9 = ops::range::Bound::Included(move _21);\n        StorageDead(_21);\n        goto -> bb28;\n    }\n    bb19: {\n        _9 = ops::range::Bound::Excluded(move _24);\n        StorageDead(_24);\n        goto -> bb28;\n    }\n    bb20: {\n        _9 = move _25;\n        StorageDead(_25);\n        goto -> bb28;\n    }\n    bb21: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &_26;\n        StorageLive(_30);\n        _30 = &_27;\n        _28 = <T as cmp::PartialOrd>::gt(move _29, move _30) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _28) -> [0: bb24, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_31);\n        _60 = false;\n        _31 = move _26;\n        _9 = ops::range::Bound::Included(move _31);\n        StorageDead(_31);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_32);\n        _59 = false;\n        _32 = move _27;\n        _9 = ops::range::Bound::Excluded(move _32);\n        StorageDead(_32);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_28);\n        switchInt(_59) -> [0: bb26, otherwise: bb54];\n    }\n    bb26: {\n        _59 = false;\n        StorageDead(_27);\n        switchInt(_60) -> [0: bb27, otherwise: bb55];\n    }\n    bb27: {\n        _60 = false;\n        StorageDead(_26);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_10);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = (_4, _7);\n        _38 = discriminant((_34.0: ops::range::Bound<T>));\n        switchInt(move _38) -> [0: bb30, 1: bb31, 2: bb32, otherwise: bb8];\n    }\n    bb29: {\n        _39 = discriminant((_34.1: ops::range::Bound<T>));\n        switchInt(move _39) -> [2: bb39, otherwise: bb33];\n    }\n    bb30: {\n        _35 = discriminant((_34.1: ops::range::Bound<T>));\n        switchInt(move _35) -> [0: bb42, otherwise: bb29];\n    }\n    bb31: {\n        _36 = discriminant((_34.1: ops::range::Bound<T>));\n        switchInt(move _36) -> [1: bb41, otherwise: bb29];\n    }\n    bb32: {\n        _37 = discriminant((_34.1: ops::range::Bound<T>));\n        switchInt(move _37) -> [2: bb40, otherwise: bb29];\n    }\n    bb33: {\n        _42 = discriminant((_34.0: ops::range::Bound<T>));\n        switchInt(move _42) -> [0: bb34, 1: bb35, 2: bb38, otherwise: bb8];\n    }\n    bb34: {\n        _40 = discriminant((_34.1: ops::range::Bound<T>));\n        switchInt(move _40) -> [1: bb37, otherwise: bb8];\n    }\n    bb35: {\n        _41 = discriminant((_34.1: ops::range::Bound<T>));\n        switchInt(move _41) -> [0: bb36, otherwise: bb8];\n    }\n    bb36: {\n        StorageLive(_51);\n        _61 = true;\n        _51 = move (((_34.0: ops::range::Bound<T>) as variant#1).0: T);\n        StorageLive(_50);\n        _62 = true;\n        _50 = move (((_34.1: ops::range::Bound<T>) as variant#0).0: T);\n        goto -> bb46;\n    }\n    bb37: {\n        StorageLive(_50);\n        _62 = true;\n        _50 = move (((_34.0: ops::range::Bound<T>) as variant#0).0: T);\n        StorageLive(_51);\n        _61 = true;\n        _51 = move (((_34.1: ops::range::Bound<T>) as variant#1).0: T);\n        goto -> bb46;\n    }\n    bb38: {\n        StorageLive(_49);\n        _49 = move (_34.1: ops::range::Bound<T>);\n        goto -> bb45;\n    }\n    bb39: {\n        StorageLive(_49);\n        _49 = move (_34.0: ops::range::Bound<T>);\n        goto -> bb45;\n    }\n    bb40: {\n        _33 = ops::range::Bound::Unbounded;\n        goto -> bb53;\n    }\n    bb41: {\n        _46 = move (((_34.0: ops::range::Bound<T>) as variant#1).0: T);\n        _47 = move (((_34.1: ops::range::Bound<T>) as variant#1).0: T);\n        StorageLive(_48);\n        _48 = <T as cmp::Ord>::min(_46, _47) -> [return: bb44, unwind unreachable];\n    }\n    bb42: {\n        _43 = move (((_34.0: ops::range::Bound<T>) as variant#0).0: T);\n        _44 = move (((_34.1: ops::range::Bound<T>) as variant#0).0: T);\n        StorageLive(_45);\n        _45 = <T as cmp::Ord>::min(_43, _44) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        _33 = ops::range::Bound::Included(move _45);\n        StorageDead(_45);\n        goto -> bb53;\n    }\n    bb44: {\n        _33 = ops::range::Bound::Excluded(move _48);\n        StorageDead(_48);\n        goto -> bb53;\n    }\n    bb45: {\n        _33 = move _49;\n        StorageDead(_49);\n        goto -> bb53;\n    }\n    bb46: {\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = &_50;\n        StorageLive(_54);\n        _54 = &_51;\n        _52 = <T as cmp::PartialOrd>::lt(move _53, move _54) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        switchInt(move _52) -> [0: bb49, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageLive(_55);\n        _62 = false;\n        _55 = move _50;\n        _33 = ops::range::Bound::Included(move _55);\n        StorageDead(_55);\n        goto -> bb50;\n    }\n    bb49: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageLive(_56);\n        _61 = false;\n        _56 = move _51;\n        _33 = ops::range::Bound::Excluded(move _56);\n        StorageDead(_56);\n        goto -> bb50;\n    }\n    bb50: {\n        StorageDead(_52);\n        switchInt(_61) -> [0: bb51, otherwise: bb56];\n    }\n    bb51: {\n        _61 = false;\n        StorageDead(_51);\n        switchInt(_62) -> [0: bb52, otherwise: bb57];\n    }\n    bb52: {\n        _62 = false;\n        StorageDead(_50);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_34);\n        StorageLive(_57);\n        _57 = move _9;\n        StorageLive(_58);\n        _58 = move _33;\n        _0 = (move _57, move _58);\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageDead(_33);\n        StorageDead(_9);\n        return;\n    }\n    bb54: {\n        drop(_27) -> [return: bb26, unwind unreachable];\n    }\n    bb55: {\n        drop(_26) -> [return: bb27, unwind unreachable];\n    }\n    bb56: {\n        drop(_51) -> [return: bb51, unwind unreachable];\n    }\n    bb57: {\n        drop(_50) -> [return: bb52, unwind unreachable];\n    }\n}\n",
  "doc": " Compute the intersection of  `self` and `other`.\n\n # Examples\n\n ```\n #![feature(range_into_bounds)]\n use std::ops::Bound::*;\n use std::ops::IntoBounds;\n\n assert_eq!((3..).intersect(..5), (Included(3), Excluded(5)));\n assert_eq!((-12..387).intersect(0..256), (Included(0), Excluded(256)));\n assert_eq!((1..5).intersect(..), (Included(1), Excluded(5)));\n assert_eq!((1..=9).intersect(0..10), (Included(1), Included(9)));\n assert_eq!((7..=13).intersect(8..13), (Included(8), Excluded(13)));\n ```\n\n Combine with `is_empty` to determine if two ranges overlap.\n\n ```\n #![feature(range_into_bounds)]\n #![feature(range_bounds_is_empty)]\n use std::ops::{RangeBounds, IntoBounds};\n\n assert!(!(3..).intersect(..5).is_empty());\n assert!(!(-12..387).intersect(0..256).is_empty());\n assert!((1..5).intersect(6..).is_empty());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}