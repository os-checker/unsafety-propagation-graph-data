{
  "name": "ptr::slice_from_raw_parts",
  "safe": true,
  "callees": {
    "ptr::metadata::from_raw_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a (possibly-wide) raw pointer from a data pointer and metadata.\n\n This function is safe but the returned pointer is not necessarily safe to dereference.\n For slices, see the documentation of [`slice::from_raw_parts`] for safety requirements.\n For trait objects, the metadata must come from a pointer to the same underlying erased type.\n\n If you are attempting to deconstruct a DST in a generic context to be reconstructed later,\n a thin pointer can always be obtained by casting `*const T` to `*const ()`.\n\n [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 16084,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1172:1: 1174:2",
  "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
  "mir": "fn ptr::slice_from_raw_parts(_1: *const T, _2: usize) -> *const [T] {\n    let mut _0: *const [T];\n    debug data => _1;\n    debug len => _2;\n    bb0: {\n        _0 = ptr::metadata::from_raw_parts::<[T], T>(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Forms a raw slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n\n [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n\n # Examples\n\n ```rust\n use std::ptr;\n\n // create a slice pointer when starting out with a pointer to the first element\n let x = [5, 6, 7];\n let raw_pointer = x.as_ptr();\n let slice = ptr::slice_from_raw_parts(raw_pointer, 3);\n assert_eq!(unsafe { &*slice }[2], 7);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *const [u8] = ptr::slice_from_raw_parts(ptr::null(), 0);\n unsafe {\n     danger.as_ref().expect(\"references must not be null\");\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}