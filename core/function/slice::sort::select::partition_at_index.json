{
  "name": "slice::sort::select::partition_at_index",
  "safe": true,
  "callees": {
    "fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::rt::Argument": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "slice::sort::select::max_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Helper function that returns the index of the maximum element in the slice using the given\n comparator function\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps two elements in the slice.\n\n If `a` equals to `b`, it's guaranteed that elements won't change value.\n\n # Arguments\n\n * a - The index of the first element\n * b - The index of the second element\n\n # Panics\n\n Panics if `a` or `b` are out of bounds.\n\n # Examples\n\n ```\n let mut v = [\"a\", \"b\", \"c\", \"d\", \"e\"];\n v.swap(2, 4);\n assert!(v == [\"a\", \"b\", \"e\", \"d\", \"c\"]);\n ```\n",
      "adt": {}
    },
    "slice::sort::select::min_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Helper function that returns the index of the minimum element in the slice using the given\n comparator function\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "slice::sort::select::partition_at_index_loop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "slice::<impl [T]>::split_at_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_mut_checked`](slice::split_at_mut_checked).\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n let (left, right) = v.split_at_mut(2);\n assert_eq!(left, [1, 0]);\n assert_eq!(right, [3, 0, 5, 6]);\n left[1] = 2;\n right[1] = 4;\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::rt::Argument": [
      "Plain"
    ],
    "fmt::Arguments": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::sort::select::partition_at_index"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/select.rs:17:1: 59:2",
  "src": "pub(crate) fn partition_at_index<T, F>(\n    v: &mut [T],\n    index: usize,\n    mut is_less: F,\n) -> (&mut [T], &mut T, &mut [T])\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let len = v.len();\n\n    // Puts a lower limit of 1 on `len`.\n    if index >= len {\n        panic!(\"partition_at_index index {} greater than length of slice {}\", index, len);\n    }\n\n    if T::IS_ZST {\n        // Sorting has no meaningful behavior on zero-sized types. Do nothing.\n    } else if index == len - 1 {\n        // Find max element and place it in the last position of the array. We're free to use\n        // `unwrap()` here because we checked that `v` is not empty.\n        let max_idx = max_index(v, &mut is_less).unwrap();\n        v.swap(max_idx, index);\n    } else if index == 0 {\n        // Find min element and place it in the first position of the array. We're free to use\n        // `unwrap()` here because we checked that `v` is not empty.\n        let min_idx = min_index(v, &mut is_less).unwrap();\n        v.swap(min_idx, index);\n    } else {\n        cfg_select! {\n            feature = \"optimize_for_size\" => {\n                median_of_medians(v, &mut is_less, index);\n            }\n            _ => {\n                partition_at_index_loop(v, index, None, &mut is_less);\n            }\n        }\n    }\n\n    let (left, right) = v.split_at_mut(index);\n    let (pivot, right) = right.split_at_mut(1);\n    let pivot = &mut pivot[0];\n    (left, pivot, right)\n}",
  "mir": "fn slice::sort::select::partition_at_index(_1: &mut [T], _2: usize, _3: F) -> (&mut [T], &mut T, &mut [T]) {\n    let mut _0: (&mut [T], &mut T, &mut [T]);\n    let  _4: usize;\n    let mut _5: &[T];\n    let mut _6: bool;\n    let  _7: !;\n    let mut _8: fmt::Arguments<'_>;\n    let  _9: (&usize, &usize);\n    let mut _10: &usize;\n    let mut _11: &usize;\n    let  _12: [fmt::rt::Argument<'_>; 2];\n    let mut _13: fmt::rt::Argument<'_>;\n    let mut _14: fmt::rt::Argument<'_>;\n    let mut _15: &[u8; 60];\n    let  _16: &[fmt::rt::Argument<'_>; 2];\n    let mut _17: bool;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: usize;\n    let mut _21: option::Option<usize>;\n    let mut _22: &[T];\n    let mut _23: &mut F;\n    let  _24: ();\n    let  _25: usize;\n    let mut _26: option::Option<usize>;\n    let mut _27: &[T];\n    let mut _28: &mut F;\n    let  _29: ();\n    let  _30: ();\n    let mut _31: option::Option<&T>;\n    let mut _32: &mut F;\n    let  _33: &mut [T];\n    let  _34: &mut [T];\n    let mut _35: (&mut [T], &mut [T]);\n    let  _36: &mut [T];\n    let  _37: &mut [T];\n    let mut _38: (&mut [T], &mut [T]);\n    let  _39: &mut T;\n    let  _40: usize;\n    let mut _41: *const [T];\n    let mut _42: usize;\n    let mut _43: bool;\n    let mut _44: &usize;\n    let mut _45: &usize;\n    debug v => _1;\n    debug index => _2;\n    debug is_less => _3;\n    debug len => _4;\n    debug args => _9;\n    debug args => _12;\n    debug max_idx => _20;\n    debug min_idx => _25;\n    debug left => _33;\n    debug right => _34;\n    debug pivot => _36;\n    debug right => _37;\n    debug pivot => _39;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = Ge(_2, _4);\n        switchInt(move _6) -> [0: bb5, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        StorageLive(_11);\n        _11 = &_4;\n        _9 = (move _10, move _11);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        _44 = (_9.0: &usize);\n        _13 = fmt::rt::Argument::<'_>::new_display::<usize>(_44) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_14);\n        _45 = (_9.1: &usize);\n        _14 = fmt::rt::Argument::<'_>::new_display::<usize>(_45) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _12 = [move _13, move _14];\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = b\"\\x19partition_at_index index \\xc0\\x1e greater than length of slice \\xc0\\x00\";\n        _16 = &_12;\n        _8 = fmt::Arguments::<'_>::new::<60, 2>(move _15, _16) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_15);\n        _7 = panicking::panic_fmt(move _8) -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_6);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb6, otherwise: bb21];\n    }\n    bb6: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _19 = CheckedSub(_4, 1_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _18 = move (_19.0: usize);\n        _17 = Eq(_2, move _18);\n        switchInt(move _17) -> [0: bb12, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_18);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _23 = &mut _3;\n        _21 = slice::sort::select::max_index::<T, F>(move _22, _23) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_22);\n        _20 = option::Option::<usize>::unwrap(move _21) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_21);\n        _24 = slice::<impl [T]>::swap(_1, _20, _2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        goto -> bb20;\n    }\n    bb12: {\n        StorageDead(_18);\n        switchInt(_2) -> [0: bb13, otherwise: bb17];\n    }\n    bb13: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &(*_1);\n        _28 = &mut _3;\n        _26 = slice::sort::select::min_index::<T, F>(move _27, _28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        _25 = option::Option::<usize>::unwrap(move _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_26);\n        _29 = slice::<impl [T]>::swap(_1, _25, _2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        goto -> bb19;\n    }\n    bb17: {\n        StorageLive(_31);\n        _31 = option::Option::None;\n        _32 = &mut _3;\n        _30 = slice::sort::select::partition_at_index_loop::<T, F>(_1, _2, move _31, _32) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        goto -> bb19;\n    }\n    bb19: {\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_17);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_35);\n        _35 = slice::<impl [T]>::split_at_mut(_1, _2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _33 = move (_35.0: &mut [T]);\n        _34 = move (_35.1: &mut [T]);\n        StorageDead(_35);\n        StorageLive(_38);\n        _38 = slice::<impl [T]>::split_at_mut(_34, 1_usize) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_36);\n        _36 = move (_38.0: &mut [T]);\n        _37 = move (_38.1: &mut [T]);\n        StorageDead(_38);\n        StorageLive(_40);\n        _40 = 0_usize;\n        _41 = &raw const (fake) (*_36);\n        _42 = PtrMetadata(move _41);\n        _43 = Lt(_40, _42);\n        assert(move _43, \"index out of bounds: the length is {} but the index is {}\", move _42, _40) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _39 = &mut (*_36)[_40];\n        StorageDead(_40);\n        _0 = (_33, _39, _37);\n        StorageDead(_36);\n        drop(_3) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        return;\n    }\n}\n",
  "doc": " Reorders the slice such that the element at `index` is at its final sorted position.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}