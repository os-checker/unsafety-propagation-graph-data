{
  "name": "slice::sort::select::median_of_medians",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::insertion_sort_shift_left": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sort `v` assuming `v[..offset]` is already sorted.\n",
      "adt": {}
    },
    "slice::sort::select::max_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Helper function that returns the index of the maximum element in the slice using the given\n comparator function\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps two elements in the slice.\n\n If `a` equals to `b`, it's guaranteed that elements won't change value.\n\n # Arguments\n\n * a - The index of the first element\n * b - The index of the second element\n\n # Panics\n\n Panics if `a` or `b` are out of bounds.\n\n # Examples\n\n ```\n let mut v = [\"a\", \"b\", \"c\", \"d\", \"e\"];\n v.swap(2, 4);\n assert!(v == [\"a\", \"b\", \"e\", \"d\", \"c\"]);\n ```\n",
      "adt": {}
    },
    "slice::sort::select::min_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Helper function that returns the index of the minimum element in the slice using the given\n comparator function\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "slice::sort::select::median_of_ninthers": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::sort::select::median_of_medians"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/select.rs:168:1: 214:2",
  "src": "fn median_of_medians<T, F: FnMut(&T, &T) -> bool>(mut v: &mut [T], is_less: &mut F, mut k: usize) {\n    // Since this function isn't public, it should never be called with an out-of-bounds index.\n    debug_assert!(k < v.len());\n\n    // If T is as ZST, `partition_at_index` will already return early.\n    debug_assert!(!T::IS_ZST);\n\n    // We now know that `k < v.len() <= isize::MAX`\n    loop {\n        if v.len() <= INSERTION_SORT_THRESHOLD {\n            if v.len() >= 2 {\n                insertion_sort_shift_left(v, 1, is_less);\n            }\n\n            return;\n        }\n\n        // `median_of_{minima,maxima}` can't handle the extreme cases of the first/last element,\n        // so we catch them here and just do a linear search.\n        if k == v.len() - 1 {\n            // Find max element and place it in the last position of the array. We're free to use\n            // `unwrap()` here because we know v must not be empty.\n            let max_idx = max_index(v, is_less).unwrap();\n            v.swap(max_idx, k);\n            return;\n        } else if k == 0 {\n            // Find min element and place it in the first position of the array. We're free to use\n            // `unwrap()` here because we know v must not be empty.\n            let min_idx = min_index(v, is_less).unwrap();\n            v.swap(min_idx, k);\n            return;\n        }\n\n        let p = median_of_ninthers(v, is_less);\n\n        if p == k {\n            return;\n        } else if p > k {\n            v = &mut v[..p];\n        } else {\n            // Since `p < k < v.len()`, `p + 1` doesn't overflow and is\n            // a valid index into the slice.\n            v = &mut v[p + 1..];\n            k -= p + 1;\n        }\n    }\n}",
  "mir": "fn slice::sort::select::median_of_medians(_1: &mut [T], _2: &mut F, _3: usize) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: &[T];\n    let mut _8: !;\n    let mut _9: !;\n    let mut _10: bool;\n    let mut _11: usize;\n    let mut _12: &[T];\n    let mut _13: bool;\n    let mut _14: usize;\n    let mut _15: &[T];\n    let  _16: ();\n    let mut _17: &mut [T];\n    let mut _18: bool;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: &[T];\n    let mut _23: (usize, bool);\n    let  _24: usize;\n    let mut _25: option::Option<usize>;\n    let mut _26: &[T];\n    let  _27: ();\n    let mut _28: &mut [T];\n    let mut _29: usize;\n    let mut _30: usize;\n    let  _31: usize;\n    let mut _32: option::Option<usize>;\n    let mut _33: &[T];\n    let  _34: ();\n    let mut _35: &mut [T];\n    let mut _36: usize;\n    let  _37: usize;\n    let mut _38: &mut [T];\n    let mut _39: bool;\n    let mut _40: usize;\n    let mut _41: bool;\n    let mut _42: usize;\n    let mut _43: &mut [T];\n    let mut _44: &mut [T];\n    let mut _45: ops::range::RangeTo<usize>;\n    let mut _46: &mut [T];\n    let mut _47: &mut [T];\n    let mut _48: ops::range::RangeFrom<usize>;\n    let mut _49: usize;\n    let mut _50: (usize, bool);\n    let mut _51: usize;\n    let mut _52: (usize, bool);\n    let mut _53: (usize, bool);\n    debug v => _1;\n    debug is_less => _2;\n    debug k => _3;\n    debug max_idx => _24;\n    debug min_idx => _31;\n    debug p => _37;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = _3;\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        _4 = Lt(move _5, move _6);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _8 = panicking::panic(\"assertion failed: k < v.len()\") -> unwind unreachable;\n    }\n    bb3: {\n        _9 = panicking::panic(\"assertion failed: !T::IS_ZST\") -> unwind unreachable;\n    }\n    bb4: {\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = PtrMetadata(move _12);\n        StorageDead(_12);\n        _10 = Le(move _11, slice::sort::select::INSERTION_SORT_THRESHOLD);\n        switchInt(move _10) -> [0: bb11, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = PtrMetadata(move _15);\n        StorageDead(_15);\n        _13 = Ge(move _14, 2_usize);\n        switchInt(move _13) -> [0: bb9, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageLive(_17);\n        _17 = _1;\n        _16 = slice::sort::shared::smallsort::insertion_sort_shift_left::<T, F>(move _17, 1_usize, _2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_14);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb35;\n    }\n    bb11: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = _3;\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _21 = PtrMetadata(move _22);\n        StorageDead(_22);\n        _23 = CheckedSub(_21, 1_usize);\n        assert(!move (_23.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _21, 1_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _20 = move (_23.0: usize);\n        StorageDead(_21);\n        _18 = Eq(move _19, move _20);\n        switchInt(move _18) -> [0: bb17, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_1);\n        _25 = slice::sort::select::max_index::<T, F>(move _26, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_26);\n        _24 = option::Option::<usize>::unwrap(move _25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageLive(_28);\n        _28 = _1;\n        StorageLive(_29);\n        _29 = _3;\n        _27 = slice::<impl [T]>::swap(move _28, _24, move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        StorageDead(_28);\n        goto -> bb34;\n    }\n    bb17: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_30);\n        _30 = _3;\n        switchInt(move _30) -> [0: bb18, otherwise: bb22];\n    }\n    bb18: {\n        StorageDead(_30);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &(*_1);\n        _32 = slice::sort::select::min_index::<T, F>(move _33, _2) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_33);\n        _31 = option::Option::<usize>::unwrap(move _32) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_32);\n        StorageLive(_35);\n        _35 = _1;\n        StorageLive(_36);\n        _36 = _3;\n        _34 = slice::<impl [T]>::swap(move _35, _31, move _36) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_36);\n        StorageDead(_35);\n        goto -> bb34;\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageDead(_18);\n        StorageLive(_38);\n        _38 = _1;\n        _37 = slice::sort::select::median_of_ninthers::<T, F>(move _38, _2) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = _3;\n        _39 = Eq(_37, move _40);\n        switchInt(move _39) -> [0: bb25, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_40);\n        StorageDead(_39);\n        goto -> bb35;\n    }\n    bb25: {\n        StorageDead(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = _3;\n        _41 = Gt(_37, move _42);\n        switchInt(move _41) -> [0: bb28, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_42);\n        StorageLive(_44);\n        _44 = _1;\n        StorageLive(_45);\n        _45 = RangeTo(_37);\n        _43 = <[T] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(move _44, move _45) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_45);\n        StorageDead(_44);\n        _1 = _43;\n        goto -> bb33;\n    }\n    bb28: {\n        StorageDead(_42);\n        StorageLive(_47);\n        _47 = _1;\n        StorageLive(_48);\n        StorageLive(_49);\n        _50 = CheckedAdd(_37, 1_usize);\n        assert(!move (_50.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _37, 1_usize) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _49 = move (_50.0: usize);\n        _48 = RangeFrom(move _49);\n        StorageDead(_49);\n        _46 = <[T] as ops::index::IndexMut<ops::range::RangeFrom<usize>>>::index_mut(move _47, move _48) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_48);\n        StorageDead(_47);\n        _1 = _46;\n        StorageLive(_51);\n        _52 = CheckedAdd(_37, 1_usize);\n        assert(!move (_52.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _37, 1_usize) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _51 = move (_52.0: usize);\n        _53 = CheckedSub(_3, _51);\n        assert(!move (_53.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _51) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _3 = move (_53.0: usize);\n        StorageDead(_51);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_41);\n        StorageDead(_39);\n        goto -> bb5;\n    }\n    bb34: {\n        StorageDead(_18);\n        goto -> bb35;\n    }\n    bb35: {\n        return;\n    }\n}\n",
  "doc": " Selection algorithm to select the k-th element from the slice in guaranteed O(n) time.\n This is essentially a quickselect that uses Tukey's Ninther for pivot selection\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}