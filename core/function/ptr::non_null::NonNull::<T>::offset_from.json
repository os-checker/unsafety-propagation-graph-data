{
  "name": "ptr::non_null::NonNull::<T>::offset_from",
  "safe": false,
  "callees": {
    "ptr::non_null::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::offset_from": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the distance between two pointers within the same allocation. The returned value is in\n units of T: the distance in bytes divided by `size_of::<T>()`.\n\n This is equivalent to `(self as isize - origin as isize) / (size_of::<T>() as isize)`,\n except that it has a lot more opportunities for UB, in exchange for the compiler\n better understanding what you are doing.\n\n The primary motivation of this method is for computing the `len` of an array/slice\n of `T` that you are currently representing as a \"start\" and \"end\" pointer\n (and \"end\" is \"one past the end\" of the array).\n In that case, `end.offset_from(start)` gets you the length of the array.\n\n All of the following safety requirements are trivially satisfied for this usecase.\n\n [`offset`]: pointer#method.offset-1\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * `self` and `origin` must either\n\n   * point to the same address, or\n   * both be [derived from][crate::ptr#provenance] a pointer to the same [allocation], and the memory range between\n     the two pointers must be in bounds of that object. (See below for an example.)\n\n * The distance between the pointers, in bytes, must be an exact multiple\n   of the size of `T`.\n\n As a consequence, the absolute distance between the pointers, in bytes, computed on\n mathematical integers (without \"wrapping around\"), cannot overflow an `isize`. This is\n implied by the in-bounds requirement, and the fact that no allocation can be larger\n than `isize::MAX` bytes.\n\n The requirement for pointers to be derived from the same allocation is primarily\n needed for `const`-compatibility: the distance between pointers into *different* allocated\n objects is not known at compile-time. However, the requirement also exists at\n runtime and may be exploited by optimizations. If you wish to compute the difference between\n pointers that are not guaranteed to be from the same allocation, use `(self as isize -\n origin as isize) / size_of::<T>()`.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n Basic usage:\n\n ```\n let mut a = [0; 5];\n let ptr1: *mut i32 = &mut a[1];\n let ptr2: *mut i32 = &mut a[3];\n unsafe {\n     assert_eq!(ptr2.offset_from(ptr1), 2);\n     assert_eq!(ptr1.offset_from(ptr2), -2);\n     assert_eq!(ptr1.offset(2), ptr2);\n     assert_eq!(ptr2.offset(-2), ptr1);\n }\n ```\n\n *Incorrect* usage:\n\n ```rust,no_run\n let ptr1 = Box::into_raw(Box::new(0u8));\n let ptr2 = Box::into_raw(Box::new(1u8));\n let diff = (ptr2 as isize).wrapping_sub(ptr1 as isize);\n // Make ptr2_other an \"alias\" of ptr2.add(1), but derived from ptr1.\n let ptr2_other = (ptr1 as *mut u8).wrapping_offset(diff).wrapping_offset(1);\n assert_eq!(ptr2 as usize, ptr2_other as usize);\n // Since ptr2_other and ptr2 are derived from pointers to different objects,\n // computing their offset is undefined behavior, even though\n // they point to addresses that are in-bounds of the same object!\n unsafe {\n     let one = ptr2_other.offset_from(ptr2); // Undefined Behavior! ⚠️\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ptr::non_null::NonNull": [
      "Plain"
    ]
  },
  "path": 16029,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs:858:5: 864:6",
  "src": "pub const unsafe fn offset_from(self, origin: NonNull<T>) -> isize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset_from`.\n        unsafe { self.as_ptr().offset_from(origin.as_ptr()) }\n    }",
  "mir": "fn ptr::non_null::NonNull::<T>::offset_from(_1: ptr::non_null::NonNull<T>, _2: ptr::non_null::NonNull<T>) -> isize {\n    let mut _0: isize;\n    let mut _3: *mut T;\n    let mut _4: *const T;\n    let mut _5: *mut T;\n    debug self => _1;\n    debug origin => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = ptr::non_null::NonNull::<T>::as_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ptr::non_null::NonNull::<T>::as_ptr(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = move _5 as *const T;\n        StorageDead(_5);\n        _0 = ptr::mut_ptr::<impl *mut T>::offset_from(move _3, move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Calculates the distance between two pointers within the same allocation. The returned value is in\n units of T: the distance in bytes divided by `size_of::<T>()`.\n\n This is equivalent to `(self as isize - origin as isize) / (size_of::<T>() as isize)`,\n except that it has a lot more opportunities for UB, in exchange for the compiler\n better understanding what you are doing.\n\n The primary motivation of this method is for computing the `len` of an array/slice\n of `T` that you are currently representing as a \"start\" and \"end\" pointer\n (and \"end\" is \"one past the end\" of the array).\n In that case, `end.offset_from(start)` gets you the length of the array.\n\n All of the following safety requirements are trivially satisfied for this usecase.\n\n [`offset`]: #method.offset\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * `self` and `origin` must either\n\n   * point to the same address, or\n   * both be *derived from* a pointer to the same [allocation], and the memory range between\n     the two pointers must be in bounds of that object. (See below for an example.)\n\n * The distance between the pointers, in bytes, must be an exact multiple\n   of the size of `T`.\n\n As a consequence, the absolute distance between the pointers, in bytes, computed on\n mathematical integers (without \"wrapping around\"), cannot overflow an `isize`. This is\n implied by the in-bounds requirement, and the fact that no allocation can be larger\n than `isize::MAX` bytes.\n\n The requirement for pointers to be derived from the same allocation is primarily\n needed for `const`-compatibility: the distance between pointers into *different* allocated\n objects is not known at compile-time. However, the requirement also exists at\n runtime and may be exploited by optimizations. If you wish to compute the difference between\n pointers that are not guaranteed to be from the same allocation, use `(self as isize -\n origin as isize) / size_of::<T>()`.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n Basic usage:\n\n ```\n use std::ptr::NonNull;\n\n let a = [0; 5];\n let ptr1: NonNull<u32> = NonNull::from(&a[1]);\n let ptr2: NonNull<u32> = NonNull::from(&a[3]);\n unsafe {\n     assert_eq!(ptr2.offset_from(ptr1), 2);\n     assert_eq!(ptr1.offset_from(ptr2), -2);\n     assert_eq!(ptr1.offset(2), ptr2);\n     assert_eq!(ptr2.offset(-2), ptr1);\n }\n ```\n\n *Incorrect* usage:\n\n ```rust,no_run\n use std::ptr::NonNull;\n\n let ptr1 = NonNull::new(Box::into_raw(Box::new(0u8))).unwrap();\n let ptr2 = NonNull::new(Box::into_raw(Box::new(1u8))).unwrap();\n let diff = (ptr2.addr().get() as isize).wrapping_sub(ptr1.addr().get() as isize);\n // Make ptr2_other an \"alias\" of ptr2.add(1), but derived from ptr1.\n let diff_plus_1 = diff.wrapping_add(1);\n let ptr2_other = NonNull::new(ptr1.as_ptr().wrapping_byte_offset(diff_plus_1)).unwrap();\n assert_eq!(ptr2.addr(), ptr2_other.addr());\n // Since ptr2_other and ptr2 are derived from pointers to different objects,\n // computing their offset is undefined behavior, even though\n // they point to addresses that are in-bounds of the same object!\n\n let one = unsafe { ptr2_other.offset_from(ptr2) }; // Undefined Behavior! ⚠️\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}