{
  "name": "num::flt2dec::to_shortest_str",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::flt2dec::decoder::decode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "Constructor"
      }
    },
    "num::flt2dec::determine_sign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the static byte string corresponding to the sign to be formatted.\n It can be either `\"\"`, `\"+\"` or `\"-\"`.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "MutableAsArgument"
      }
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "num::flt2dec::digits_to_dec_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n with at least given number of fractional digits. The result is stored to\n the supplied parts array and a slice of written parts is returned.\n\n `frac_digits` can be less than the number of actual fractional digits in `buf`;\n it will be ignored and full digits will be printed. It is only used to print\n additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n it will only print given digits and nothing else.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::flt2dec::decoder::FullDecoded": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3, kind: RigidTy(Bool) })])",
      "Unknown([Field(1, Ty { id: 759, kind: RigidTy(Adt(AdtDef(DefId { id: 24675, name: \"num::flt2dec::decoder::FullDecoded\" }), GenericArgs([]))) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(3, ThreadLocalIndex)), Field(0, Ty { id: 760, kind: RigidTy(Adt(AdtDef(DefId { id: 24674, name: \"num::flt2dec::decoder::Decoded\" }), GenericArgs([]))) })])"
    ],
    "num::flt2dec::Sign": [
      "Plain"
    ],
    "num::flt2dec::decoder::Decoded": [
      "Ref"
    ],
    "num::fmt::Part": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "num::fmt::Formatted": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::to_shortest_str"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/mod.rs:344:1: 396:2",
  "src": "pub fn to_shortest_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 4);\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            if frac_digits > 0 {\n                // [0.][0000]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..2`.\n                    parts: unsafe { parts[..2].assume_init_ref() },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { parts[..1].assume_init_ref() },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let (buf, exp) = format_shortest(decoded, buf);\n            Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n        }\n    }\n}",
  "mir": "fn num::flt2dec::to_shortest_str(_1: F, _2: T, _3: num::flt2dec::Sign, _4: usize, _5: &mut [mem::maybe_uninit::MaybeUninit<u8>], _6: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]) -> num::fmt::Formatted<'_> {\n    let mut _0: num::fmt::Formatted<'_>;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _10: !;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _14: !;\n    let  _15: bool;\n    let  _16: num::flt2dec::decoder::FullDecoded;\n    let mut _17: (bool, num::flt2dec::decoder::FullDecoded);\n    let  _18: &str;\n    let  _19: &num::flt2dec::decoder::FullDecoded;\n    let mut _20: isize;\n    let mut _21: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _22: num::fmt::Part<'_>;\n    let mut _23: &[u8];\n    let mut _24: &[u8; 3];\n    let  _25: usize;\n    let mut _26: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _27: usize;\n    let mut _28: bool;\n    let  _29: &[num::fmt::Part<'_>];\n    let  _30: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _31: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _32: ops::range::RangeTo<usize>;\n    let mut _33: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _34: num::fmt::Part<'_>;\n    let mut _35: &[u8];\n    let mut _36: &[u8; 3];\n    let  _37: usize;\n    let mut _38: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _39: usize;\n    let mut _40: bool;\n    let  _41: &[num::fmt::Part<'_>];\n    let  _42: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _43: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _44: ops::range::RangeTo<usize>;\n    let mut _45: bool;\n    let mut _46: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _47: num::fmt::Part<'_>;\n    let mut _48: &[u8];\n    let mut _49: &[u8; 2];\n    let  _50: usize;\n    let mut _51: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _52: usize;\n    let mut _53: bool;\n    let mut _54: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _55: num::fmt::Part<'_>;\n    let  _56: usize;\n    let mut _57: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _58: usize;\n    let mut _59: bool;\n    let  _60: &[num::fmt::Part<'_>];\n    let  _61: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _62: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _63: ops::range::RangeTo<usize>;\n    let mut _64: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _65: num::fmt::Part<'_>;\n    let mut _66: &[u8];\n    let mut _67: &[u8; 1];\n    let  _68: usize;\n    let mut _69: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _70: usize;\n    let mut _71: bool;\n    let  _72: &[num::fmt::Part<'_>];\n    let  _73: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _74: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _75: ops::range::RangeTo<usize>;\n    let  _76: &num::flt2dec::decoder::Decoded;\n    let  _77: &[u8];\n    let  _78: i16;\n    let mut _79: (&[u8], i16);\n    let mut _80: &mut F;\n    let mut _81: (&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>]);\n    let  _82: &[num::fmt::Part<'_>];\n    debug format_shortest => _1;\n    debug v => _2;\n    debug sign => _3;\n    debug frac_digits => _4;\n    debug buf => _5;\n    debug parts => _6;\n    debug negative => _15;\n    debug full_decoded => _16;\n    debug sign => _18;\n    debug decoded => _76;\n    debug buf => _77;\n    debug exp => _78;\n    bb0: {\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_6);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        _7 = Ge(move _8, 4_usize);\n        switchInt(move _7) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &(*_5);\n        _12 = PtrMetadata(move _13);\n        StorageDead(_13);\n        _11 = Ge(move _12, num::flt2dec::MAX_SIG_DIGITS);\n        switchInt(move _11) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_8);\n        _10 = panicking::panic(\"assertion failed: parts.len() >= 4\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_17);\n        _17 = num::flt2dec::decoder::decode::<T>(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_12);\n        _14 = panicking::panic(\"assertion failed: buf.len() >= MAX_SIG_DIGITS\") -> unwind unreachable;\n    }\n    bb5: {\n        _15 = (_17.0: bool);\n        StorageLive(_16);\n        _16 = (_17.1: num::flt2dec::decoder::FullDecoded);\n        StorageDead(_17);\n        _19 = &_16;\n        _18 = num::flt2dec::determine_sign(_3, _19, _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _20 = discriminant(_16);\n        switchInt(move _20) -> [0: bb11, 1: bb10, 2: bb9, 3: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _76 = &((_16 as variant#3).0: num::flt2dec::decoder::Decoded);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = &mut _1;\n        StorageLive(_81);\n        _81 = (_76, _5);\n        _79 = <F as ops::function::FnMut<(&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>])>>::call_mut(move _80, move _81) -> [return: bb33, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_45);\n        _45 = Gt(_4, 0_usize);\n        switchInt(move _45) -> [0: bb27, otherwise: bb20];\n    }\n    bb10: {\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = b\"inf\";\n        _35 = move _36 as &[u8];\n        StorageDead(_36);\n        _34 = num::fmt::Part::Copy(move _35);\n        StorageDead(_35);\n        _33 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _34) -> [return: bb16, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = b\"NaN\";\n        _23 = move _24 as &[u8];\n        StorageDead(_24);\n        _22 = num::fmt::Part::Copy(move _23);\n        StorageDead(_23);\n        _21 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        StorageLive(_25);\n        _25 = 0_usize;\n        _26 = &raw const (fake) (*_6);\n        _27 = PtrMetadata(move _26);\n        _28 = Lt(_25, _27);\n        assert(move _28, \"index out of bounds: the length is {} but the index is {}\", move _27, _25) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        (*_6)[_25] = move _21;\n        StorageDead(_21);\n        StorageDead(_25);\n        StorageLive(_31);\n        _31 = &(*_6);\n        StorageLive(_32);\n        _32 = RangeTo(1_usize);\n        _30 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _31, move _32) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _29 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_30) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _0 = Formatted(_18, _29);\n        goto -> bb35;\n    }\n    bb16: {\n        StorageDead(_34);\n        StorageLive(_37);\n        _37 = 0_usize;\n        _38 = &raw const (fake) (*_6);\n        _39 = PtrMetadata(move _38);\n        _40 = Lt(_37, _39);\n        assert(move _40, \"index out of bounds: the length is {} but the index is {}\", move _39, _37) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        (*_6)[_37] = move _33;\n        StorageDead(_33);\n        StorageDead(_37);\n        StorageLive(_43);\n        _43 = &(*_6);\n        StorageLive(_44);\n        _44 = RangeTo(1_usize);\n        _42 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _43, move _44) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_44);\n        StorageDead(_43);\n        _41 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_42) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _0 = Formatted(_18, _41);\n        goto -> bb35;\n    }\n    bb20: {\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = b\"0.\";\n        _48 = move _49 as &[u8];\n        StorageDead(_49);\n        _47 = num::fmt::Part::Copy(move _48);\n        StorageDead(_48);\n        _46 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _47) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_47);\n        StorageLive(_50);\n        _50 = 0_usize;\n        _51 = &raw const (fake) (*_6);\n        _52 = PtrMetadata(move _51);\n        _53 = Lt(_50, _52);\n        assert(move _53, \"index out of bounds: the length is {} but the index is {}\", move _52, _50) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        (*_6)[_50] = move _46;\n        StorageDead(_46);\n        StorageDead(_50);\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = num::fmt::Part::Zero(_4);\n        _54 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _55) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_55);\n        StorageLive(_56);\n        _56 = 1_usize;\n        _57 = &raw const (fake) (*_6);\n        _58 = PtrMetadata(move _57);\n        _59 = Lt(_56, _58);\n        assert(move _59, \"index out of bounds: the length is {} but the index is {}\", move _58, _56) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        (*_6)[_56] = move _54;\n        StorageDead(_54);\n        StorageDead(_56);\n        StorageLive(_62);\n        _62 = &(*_6);\n        StorageLive(_63);\n        _63 = RangeTo(2_usize);\n        _61 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _62, move _63) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_63);\n        StorageDead(_62);\n        _60 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_61) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _0 = Formatted(_18, _60);\n        goto -> bb32;\n    }\n    bb27: {\n        StorageLive(_64);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = b\"0\";\n        _66 = move _67 as &[u8];\n        StorageDead(_67);\n        _65 = num::fmt::Part::Copy(move _66);\n        StorageDead(_66);\n        _64 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _65) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_65);\n        StorageLive(_68);\n        _68 = 0_usize;\n        _69 = &raw const (fake) (*_6);\n        _70 = PtrMetadata(move _69);\n        _71 = Lt(_68, _70);\n        assert(move _71, \"index out of bounds: the length is {} but the index is {}\", move _70, _68) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        (*_6)[_68] = move _64;\n        StorageDead(_64);\n        StorageDead(_68);\n        StorageLive(_74);\n        _74 = &(*_6);\n        StorageLive(_75);\n        _75 = RangeTo(1_usize);\n        _73 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _74, move _75) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_75);\n        StorageDead(_74);\n        _72 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_73) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _0 = Formatted(_18, _72);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_45);\n        goto -> bb35;\n    }\n    bb33: {\n        StorageDead(_81);\n        StorageDead(_80);\n        _77 = (_79.0: &[u8]);\n        _78 = (_79.1: i16);\n        StorageDead(_79);\n        _82 = num::flt2dec::digits_to_dec_str(_77, _78, _4, _6) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _0 = Formatted(_18, _82);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_16);\n        drop(_1) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        return;\n    }\n}\n",
  "doc": " Formats the given floating point number into the decimal form with at least\n given number of fractional digits. The result is stored to the supplied parts\n array while utilizing given byte buffer as a scratch. `upper` is currently\n unused but left for the future decision to change the case of non-finite values,\n i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n (which can be an empty string if no sign is rendered).\n\n `format_shortest` should be the underlying digit-generation function.\n It should return the part of the buffer that it initialized.\n You probably would want `strategy::grisu::format_shortest` for this.\n\n `frac_digits` can be less than the number of actual fractional digits in `v`;\n it will be ignored and full digits will be printed. It is only used to print\n additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n it will only print given digits and nothing else.\n\n The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n There should be at least 4 parts available, due to the worst case like\n `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}