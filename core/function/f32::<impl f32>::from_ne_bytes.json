{
  "name": "f32::<impl f32>::from_ne_bytes",
  "safe": true,
  "callees": {
    "num::<impl u32>::from_ne_bytes": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unnecessary_transmutes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unnecessary_transmutes\n"
        ]
      },
      "doc": " Creates a native endian integer value from its memory representation\n as a byte array in native endianness.\n\n As the target platform's native endianness is used, portable code\n likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n appropriate instead.\n\n [`from_be_bytes`]: Self::from_be_bytes\n [`from_le_bytes`]: Self::from_le_bytes\n\n\n # Examples\n\n ```\n } else {\n });\n ```\n\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n\n ```\n     *input = rest;\n }\n ```\n",
      "adt": {}
    },
    "f32::<impl f32>::from_bits": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unnecessary_transmutes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unnecessary_transmutes\n"
        ]
      },
      "doc": " Raw transmutation from `u32`.\n\n This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n It turns out this is incredibly portable, for two reasons:\n\n * Floats and Ints have the same endianness on all supported platforms.\n * IEEE 754 very precisely specifies the bit layout of floats.\n\n However there is one caveat: prior to the 2008 version of IEEE 754, how\n to interpret the NaN signaling bit wasn't actually specified. Most platforms\n (notably x86 and ARM) picked the interpretation that was ultimately\n standardized in 2008, but some didn't (notably MIPS). As a result, all\n signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n\n Rather than trying to preserve signaling-ness cross-platform, this\n implementation favors preserving the exact bits. This means that\n any payloads encoded in NaNs will be preserved even if the result of\n this method is sent over the network from an x86 machine to a MIPS one.\n\n If the results of this method are only manipulated by the same\n architecture that produced them, then there is no portability concern.\n\n If the input isn't NaN, then there is no portability concern.\n\n If you don't care about signalingness (very likely), then there is no\n portability concern.\n\n Note that this function is distinct from `as` casting, which attempts to\n preserve the *numeric* value, and not the bitwise value.\n\n # Examples\n\n ```\n let v = f32::from_bits(0x41480000);\n assert_eq!(v, 12.5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1735,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f32.rs:1301:5: 1303:6",
  "src": "pub const fn from_ne_bytes(bytes: [u8; 4]) -> Self {\n        Self::from_bits(u32::from_ne_bytes(bytes))\n    }",
  "mir": "fn f32::<impl f32>::from_ne_bytes(_1: [u8; 4]) -> f32 {\n    let mut _0: f32;\n    let mut _2: u32;\n    debug bytes => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = num::<impl u32>::from_ne_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = f32::<impl f32>::from_bits(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates a floating point value from its representation as a byte array in native endian.\n\n As the target platform's native endianness is used, portable code\n likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n appropriate instead.\n\n [`from_be_bytes`]: f32::from_be_bytes\n [`from_le_bytes`]: f32::from_le_bytes\n\n See [`from_bits`](Self::from_bits) for some discussion of the\n portability of this operation (there are almost no issues).\n\n # Examples\n\n ```\n let value = f32::from_ne_bytes(if cfg!(target_endian = \"big\") {\n     [0x41, 0x48, 0x00, 0x00]\n } else {\n     [0x00, 0x00, 0x48, 0x41]\n });\n assert_eq!(value, 12.5);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}