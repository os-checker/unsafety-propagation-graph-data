{
  "name": "num::<impl i16>::carrying_mul",
  "safe": true,
  "callees": {
    "num::<impl i16>::carrying_mul_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the \"full multiplication\" `self * rhs + carry + add`\n without the possibility to overflow.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order.\n\n Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n additional amount of overflow. This allows for chaining together multiple\n multiplications to create \"big integers\" which represent larger values.\n\n If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `i32` is used.\n\n ```\n #![feature(bigint_helper_methods)]\n assert_eq!(5i32.carrying_mul_add(-2, 0, 0), (4294967286, -1));\n assert_eq!(5i32.carrying_mul_add(-2, 10, 10), (10, 0));\n assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 0, 0), (2884901888, -3));\n assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 10, 10), (2884901908, -3));\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 2111,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:2731:9: 2733:10",
  "src": "pub const fn carrying_mul(self, rhs: Self, carry: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }",
  "mir": "fn num::<impl i16>::carrying_mul(_1: i16, _2: i16, _3: i16) -> (u16, i16) {\n    let mut _0: (u16, i16);\n    debug self => _1;\n    debug rhs => _2;\n    debug carry => _3;\n    bb0: {\n        _0 = num::<impl i16>::carrying_mul_add(_1, _2, _3, 0_i16) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Calculates the \"full multiplication\" `self * rhs + carry`\n without the possibility to overflow.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order.\n\n Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n additional amount of overflow. This allows for chaining together multiple\n multiplications to create \"big integers\" which represent larger values.\n\n If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `i32` is used.\n\n ```\n #![feature(bigint_helper_methods)]\n assert_eq!(5i32.carrying_mul(-2, 0), (4294967286, -1));\n assert_eq!(5i32.carrying_mul(-2, 10), (0, 0));\n assert_eq!(1_000_000_000i32.carrying_mul(-10, 0), (2884901888, -3));\n assert_eq!(1_000_000_000i32.carrying_mul(-10, 10), (2884901898, -3));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}