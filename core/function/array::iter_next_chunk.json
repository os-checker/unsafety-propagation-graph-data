{
  "name": "array::iter_next_chunk",
  "safe": true,
  "callees": {
    "array::iter_next_chunk_erased": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Version of [`iter_next_chunk`] using a passed-in slice in order to avoid\n needing to monomorphize for every array length.\n\n Unfortunately this loop has two exit conditions, the buffer filling up\n or the iterator running out of items, making it tend to optimize poorly.\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "array::iter::IntoIter::<T, N>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the elements in a partially-initialized buffer.\n\n If you have a fully-initialized array, then use [`IntoIterator`].\n But this is useful for returning partial results from unsafe code.\n\n # Safety\n\n - The `buffer[initialized]` elements must all be initialized.\n - The range must be canonical, with `initialized.start <= initialized.end`.\n - The range must be in-bounds for the buffer, with `initialized.end <= N`.\n   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n\n It's sound to have more elements initialized than mentioned, though that\n will most likely result in them being leaked.\n\n # Examples\n\n ```\n #![feature(array_into_iter_constructors)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n use std::array::IntoIter;\n use std::mem::MaybeUninit;\n\n # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n # // otherwise it could leak. A fully-general version this would need a drop\n # // guard to handle panics from the iterator, but this works for an example.\n fn next_chunk<T: Copy, const N: usize>(\n     it: &mut impl Iterator<Item = T>,\n ) -> Result<[T; N], IntoIter<T, N>> {\n     let mut buffer = [const { MaybeUninit::uninit() }; N];\n     let mut i = 0;\n     while i < N {\n         match it.next() {\n             Some(x) => {\n                 buffer[i].write(x);\n                 i += 1;\n             }\n             None => {\n                 // SAFETY: We've initialized the first `i` items\n                 unsafe {\n                     return Err(IntoIter::new_unchecked(buffer, 0..i));\n                 }\n             }\n         }\n     }\n\n     // SAFETY: We've initialized all N items\n     unsafe { Ok(buffer.transpose().assume_init()) }\n }\n\n let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n assert_eq!(r, [10, 11, 12, 13]);\n let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n ```\n",
      "adt": {
        "array::iter::IntoIter": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::array_assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the values from an array of `MaybeUninit` containers.\n\n # Safety\n\n It is up to the caller to guarantee that all elements of the array are\n in an initialized state.\n\n # Examples\n\n ```\n #![feature(maybe_uninit_array_assume_init)]\n use std::mem::MaybeUninit;\n\n let mut array: [MaybeUninit<i32>; 3] = [MaybeUninit::uninit(); 3];\n array[0].write(0);\n array[1].write(1);\n array[2].write(2);\n\n // SAFETY: Now safe as we initialised all elements\n let array = unsafe {\n     MaybeUninit::array_assume_init(array)\n };\n\n assert_eq!(array, [0, 1, 2]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "array::iter::IntoIter": [
      "Plain"
    ]
  },
  "path": 4553,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/mod.rs:980:1: 995:2",
  "src": "pub(crate) fn iter_next_chunk<T, const N: usize>(\n    iter: &mut impl Iterator<Item = T>,\n) -> Result<[T; N], IntoIter<T, N>> {\n    let mut array = [const { MaybeUninit::uninit() }; N];\n    let r = iter_next_chunk_erased(&mut array, iter);\n    match r {\n        Ok(()) => {\n            // SAFETY: All elements of `array` were populated.\n            Ok(unsafe { MaybeUninit::array_assume_init(array) })\n        }\n        Err(initialized) => {\n            // SAFETY: Only the first `initialized` elements were populated\n            Err(unsafe { IntoIter::new_unchecked(array, 0..initialized) })\n        }\n    }\n}",
  "mir": "fn array::iter_next_chunk(_1: &mut impl Iterator<Item = T>) -> result::Result<[T; N], array::iter::IntoIter<T, N>> {\n    let mut _0: result::Result<[T; N], array::iter::IntoIter<T, N>>;\n    let mut _2: [mem::maybe_uninit::MaybeUninit<T>; N];\n    let  _3: result::Result<(), usize>;\n    let mut _4: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _5: &mut [mem::maybe_uninit::MaybeUninit<T>; N];\n    let mut _6: isize;\n    let mut _7: [T; N];\n    let mut _8: [mem::maybe_uninit::MaybeUninit<T>; N];\n    let  _9: usize;\n    let mut _10: array::iter::IntoIter<T, N>;\n    let mut _11: [mem::maybe_uninit::MaybeUninit<T>; N];\n    let mut _12: ops::range::Range<usize>;\n    debug iter => _1;\n    debug array => _2;\n    debug r => _3;\n    debug initialized => _9;\n    bb0: {\n        StorageLive(_2);\n        _2 = [array::iter_next_chunk::<T, N, impl Iterator<Item = T>>::{constant#1}; N];\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = &mut _2;\n        _4 = _5 as &mut [mem::maybe_uninit::MaybeUninit<T>];\n        _3 = array::iter_next_chunk_erased::<T, impl Iterator<Item = T>>(move _4, _1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _9 = ((_3 as variant#1).0: usize);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = move _2;\n        StorageLive(_12);\n        _12 = Range(0_usize, _9);\n        _10 = array::iter::IntoIter::<T, N>::new_unchecked(move _11, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = move _2;\n        _7 = mem::maybe_uninit::MaybeUninit::<T>::array_assume_init::<N>(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _0 = result::Result::Ok(move _7);\n        StorageDead(_7);\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _0 = result::Result::Err(move _10);\n        StorageDead(_10);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Pulls `N` items from `iter` and returns them as an array. If the iterator\n yields fewer than `N` items, `Err` is returned containing an iterator over\n the already yielded items.\n\n Since the iterator is passed as a mutable reference and this function calls\n `next` at most `N` times, the iterator can still be used afterwards to\n retrieve the remaining items.\n\n If `iter.next()` panics, all items already yielded by the iterator are\n dropped.\n\n Used for [`Iterator::next_chunk`].\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}