{
  "name": "<fmt::builders::PadAdapter<'_, '_> as fmt::Write>::write_str",
  "safe": true,
  "callees": {
    "str::<impl str>::split_inclusive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over substrings of this string slice, separated by\n characters matched by a pattern.\n\n Differs from the iterator produced by `split` in that `split_inclusive`\n leaves the matched part as the terminator of the substring.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Examples\n\n ```\n let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n     .split_inclusive('\\n').collect();\n assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n ```\n\n If the last element of the string is matched,\n that element will be considered the terminator of the preceding substring.\n That substring will be the last item returned by the iterator.\n\n ```\n let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n     .split_inclusive('\\n').collect();\n assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n ```\n",
      "adt": {
        "str::iter::SplitInclusive": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "fmt::Write::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a string slice into this writer, returning whether the write\n succeeded.\n\n This method can only succeed if the entire string slice was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`std::fmt::Error`][Error] on error.\n\n The purpose of that error is to abort the formatting operation when the underlying\n destination encounters some error preventing it from accepting more text;\n in particular, it does not communicate any information about *what* error occurred.\n It should generally be propagated rather than handled, at least when implementing\n formatting traits.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n     f.write_str(s)\n }\n\n let mut buf = String::new();\n writer(&mut buf, \"hola\")?;\n assert_eq!(&buf, \"hola\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "str::<impl str>::ends_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the given pattern matches a suffix of this\n string slice.\n\n Returns `false` if it does not.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Examples\n\n ```\n let bananas = \"bananas\";\n\n assert!(bananas.ends_with(\"anas\"));\n assert!(!bananas.ends_with(\"nana\"));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "str::iter::SplitInclusive": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 81, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 84, kind: RigidTy(Str) }, Not)) })])"
    ],
    "fmt::builders::PadAdapterState": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "fmt::builders::PadAdapter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ]
  },
  "path": 12935,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/builders.rs:31:5: 42:6",
  "src": "fn write_str(&mut self, s: &str) -> fmt::Result {\n        for s in s.split_inclusive('\\n') {\n            if self.state.on_newline {\n                self.buf.write_str(\"    \")?;\n            }\n\n            self.state.on_newline = s.ends_with('\\n');\n            self.buf.write_str(s)?;\n        }\n\n        Ok(())\n    }",
  "mir": "fn <fmt::builders::PadAdapter<'_, '_> as fmt::Write>::write_str(_1: &mut fmt::builders::PadAdapter<'_, '_>, _2: &str) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: str::iter::SplitInclusive<'_, char>;\n    let mut _4: str::iter::SplitInclusive<'_, char>;\n    let mut _5: str::iter::SplitInclusive<'_, char>;\n    let mut _6: option::Option<&str>;\n    let mut _7: &mut str::iter::SplitInclusive<'_, char>;\n    let mut _8: isize;\n    let  _9: &str;\n    let mut _10: bool;\n    let mut _11: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _12: result::Result<(), fmt::Error>;\n    let mut _13: &str;\n    let mut _14: isize;\n    let mut _15: bool;\n    let mut _16: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _17: result::Result<(), fmt::Error>;\n    let mut _18: isize;\n    let mut _19: &mut fmt::builders::PadAdapterState;\n    let mut _20: &mut dyn fmt::Write;\n    let mut _21: &mut fmt::builders::PadAdapterState;\n    let mut _22: &mut dyn fmt::Write;\n    debug self => _1;\n    debug s => _2;\n    debug iter => _5;\n    debug s => _9;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = str::<impl str>::split_inclusive::<char>(_2, '\\n') -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <str::iter::SplitInclusive<'_, char> as iter::traits::collect::IntoIterator>::into_iter(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = move _3;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_6);\n        _7 = &mut _5;\n        _6 = <str::iter::SplitInclusive<'_, char> as iter::traits::iterator::Iterator>::next(_7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = discriminant(_6);\n        switchInt(move _8) -> [0: bb7, 1: bb6, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _9 = ((_6 as variant#1).0: &str);\n        StorageLive(_10);\n        _19 = ((*_1).1: &mut fmt::builders::PadAdapterState);\n        _10 = ((*_19).0: bool);\n        switchInt(move _10) -> [0: bb14, otherwise: bb8];\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_3);\n        _0 = result::Result::Ok(());\n        goto -> bb22;\n    }\n    bb8: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _20 = ((*_1).0: &mut dyn fmt::Write);\n        StorageLive(_13);\n        _13 = \"    \";\n        _12 = <dyn fmt::Write as fmt::Write>::write_str(_20, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _11 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_12);\n        _14 = discriminant(_11);\n        switchInt(move _14) -> [0: bb11, 1: bb12, otherwise: bb5];\n    }\n    bb11: {\n        StorageDead(_11);\n        goto -> bb14;\n    }\n    bb12: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb21;\n    }\n    bb14: {\n        StorageDead(_10);\n        StorageLive(_15);\n        _15 = str::<impl str>::ends_with::<char>(_9, '\\n') -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _21 = ((*_1).1: &mut fmt::builders::PadAdapterState);\n        ((*_21).0: bool) = move _15;\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _22 = ((*_1).0: &mut dyn fmt::Write);\n        _17 = <dyn fmt::Write as fmt::Write>::write_str(_22, _9) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _16 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _17) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_17);\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb18, 1: bb19, otherwise: bb5];\n    }\n    bb18: {\n        StorageDead(_16);\n        StorageDead(_6);\n        goto -> bb3;\n    }\n    bb19: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_16);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}