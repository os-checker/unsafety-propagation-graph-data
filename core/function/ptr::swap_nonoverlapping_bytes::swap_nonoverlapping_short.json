{
  "name": "ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_short",
  "safe": false,
  "callees": {
    "num::nonzero::NonZero::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained value as a primitive type.\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::swap_chunk": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "num::nonzero::NonZero": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef"
    ],
    "panicking::AssertKind": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_short"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1454:5: 1476:6",
  "src": "unsafe fn swap_nonoverlapping_short(x: *mut u8, y: *mut u8, bytes: NonZero<usize>) {\n        // Tail handling for auto-vectorized code sometimes has element-at-a-time behaviour,\n        // see <https://github.com/rust-lang/rust/issues/134946>.\n        // By swapping as different sizes, rather than as a loop over bytes,\n        // we make sure not to end up with, say, seven byte-at-a-time copies.\n\n        let bytes = bytes.get();\n        let mut i = 0;\n        macro_rules! swap_prefix {\n            ($($n:literal)+) => {$(\n                if (bytes & $n) != 0 {\n                    // SAFETY: `i` can only have the same bits set as those in bytes,\n                    // so these `add`s are in-bounds of `bytes`.  But the bit for\n                    // `$n` hasn't been set yet, so the `$n` bytes that `swap_chunk`\n                    // will read and write are within the usable range.\n                    unsafe { swap_chunk::<$n>(&mut*x.add(i).cast(), &mut*y.add(i).cast()) };\n                    i |= $n;\n                }\n            )+};\n        }\n        swap_prefix!(4 2 1);\n        debug_assert_eq!(i, bytes);\n    }",
  "mir": "fn ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_short(_1: *mut u8, _2: *mut u8, _3: num::nonzero::NonZero<usize>) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let mut _5: usize;\n    let mut _6: usize;\n    let  _7: ();\n    let mut _8: &mut mem::maybe_uninit::MaybeUninit<[u8; 4]>;\n    let mut _9: *mut mem::maybe_uninit::MaybeUninit<[u8; 4]>;\n    let mut _10: *mut u8;\n    let mut _11: usize;\n    let mut _12: &mut mem::maybe_uninit::MaybeUninit<[u8; 4]>;\n    let mut _13: *mut mem::maybe_uninit::MaybeUninit<[u8; 4]>;\n    let mut _14: *mut u8;\n    let mut _15: usize;\n    let mut _16: usize;\n    let  _17: ();\n    let mut _18: &mut mem::maybe_uninit::MaybeUninit<[u8; 2]>;\n    let mut _19: *mut mem::maybe_uninit::MaybeUninit<[u8; 2]>;\n    let mut _20: *mut u8;\n    let mut _21: usize;\n    let mut _22: &mut mem::maybe_uninit::MaybeUninit<[u8; 2]>;\n    let mut _23: *mut mem::maybe_uninit::MaybeUninit<[u8; 2]>;\n    let mut _24: *mut u8;\n    let mut _25: usize;\n    let mut _26: usize;\n    let  _27: ();\n    let mut _28: &mut mem::maybe_uninit::MaybeUninit<[u8; 1]>;\n    let mut _29: *mut mem::maybe_uninit::MaybeUninit<[u8; 1]>;\n    let mut _30: *mut u8;\n    let mut _31: usize;\n    let mut _32: &mut mem::maybe_uninit::MaybeUninit<[u8; 1]>;\n    let mut _33: *mut mem::maybe_uninit::MaybeUninit<[u8; 1]>;\n    let mut _34: *mut u8;\n    let mut _35: usize;\n    let mut _36: (&usize, &usize);\n    let mut _37: &usize;\n    let mut _38: &usize;\n    let  _39: &usize;\n    let  _40: &usize;\n    let mut _41: bool;\n    let mut _42: usize;\n    let mut _43: usize;\n    let  _44: panicking::AssertKind;\n    let  _45: !;\n    let mut _46: option::Option<fmt::Arguments<'_>>;\n    debug x => _1;\n    debug y => _2;\n    debug bytes => _3;\n    debug bytes => _4;\n    debug i => _5;\n    debug left_val => _39;\n    debug right_val => _40;\n    debug kind => _44;\n    bb0: {\n        _4 = num::nonzero::NonZero::<usize>::get(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = 0_usize;\n        StorageLive(_6);\n        _6 = BitAnd(_4, 4_usize);\n        switchInt(move _6) -> [0: bb8, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = _5;\n        _10 = ptr::mut_ptr::<impl *mut u8>::add(_1, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _9 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 4]>>(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = &mut (*_9);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _5;\n        _14 = ptr::mut_ptr::<impl *mut u8>::add(_2, move _15) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_15);\n        _13 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 4]>>(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _12 = &mut (*_13);\n        _7 = ptr::swap_chunk::<4>(_8, _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_9);\n        _5 = BitOr(_5, 4_usize);\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_6);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_16);\n        _16 = BitAnd(_4, 2_usize);\n        switchInt(move _16) -> [0: bb16, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _5;\n        _20 = ptr::mut_ptr::<impl *mut u8>::add(_1, move _21) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_21);\n        _19 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 2]>>(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        _18 = &mut (*_19);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _5;\n        _24 = ptr::mut_ptr::<impl *mut u8>::add(_2, move _25) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_25);\n        _23 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 2]>>(move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        _22 = &mut (*_23);\n        _17 = ptr::swap_chunk::<2>(_18, _22) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        StorageDead(_19);\n        _5 = BitOr(_5, 2_usize);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_16);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_26);\n        _26 = BitAnd(_4, 1_usize);\n        switchInt(move _26) -> [0: bb24, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_26);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = _5;\n        _30 = ptr::mut_ptr::<impl *mut u8>::add(_1, move _31) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_31);\n        _29 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 1]>>(move _30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_30);\n        _28 = &mut (*_29);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = _5;\n        _34 = ptr::mut_ptr::<impl *mut u8>::add(_2, move _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_35);\n        _33 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 1]>>(move _34) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_34);\n        _32 = &mut (*_33);\n        _27 = ptr::swap_chunk::<1>(_28, _32) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_33);\n        StorageDead(_29);\n        _5 = BitOr(_5, 1_usize);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_26);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &_5;\n        StorageLive(_38);\n        _38 = &_4;\n        _36 = (move _37, move _38);\n        StorageDead(_38);\n        StorageDead(_37);\n        _39 = (_36.0: &usize);\n        _40 = (_36.1: &usize);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = (*_39);\n        StorageLive(_43);\n        _43 = (*_40);\n        _41 = Eq(move _42, move _43);\n        switchInt(move _41) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_36);\n        StorageDead(_5);\n        return;\n    }\n    bb27: {\n        StorageDead(_43);\n        StorageDead(_42);\n        _44 = panicking::AssertKind::Eq;\n        StorageLive(_46);\n        _46 = option::Option::None;\n        _45 = panicking::assert_failed::<usize, usize>(_44, _39, _40, move _46) -> unwind unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}