{
  "name": "num::<impl u16>::checked_ilog",
  "safe": true,
  "callees": {
    "intrinsics::is_val_statically_known": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether the argument's value is statically known at\n compile-time.\n\n This is useful when there is a way of writing the code that will\n be *faster* when some variables have known values, but *slower*\n in the general case: an `if is_val_statically_known(var)` can be used\n to select between these two variants. The `if` will be optimized away\n and only the desired branch remains.\n\n Formally speaking, this function non-deterministically returns `true`\n or `false`, and the caller has to ensure sound behavior for both cases.\n In other words, the following code has *Undefined Behavior*:\n\n ```no_run\n #![feature(core_intrinsics)]\n # #![allow(internal_features)]\n use std::hint::unreachable_unchecked;\n use std::intrinsics::is_val_statically_known;\n\n if !is_val_statically_known(0) { unsafe { unreachable_unchecked(); } }\n ```\n\n This also means that the following code's behavior is unspecified; it\n may panic, or it may not:\n\n ```no_run\n #![feature(core_intrinsics)]\n # #![allow(internal_features)]\n use std::intrinsics::is_val_statically_known;\n\n assert_eq!(is_val_statically_known(0), is_val_statically_known(0));\n ```\n\n Unsafe code may not rely on `is_val_statically_known` returning any\n particular value, ever. However, the compiler will generally make it\n return `true` only if the value of the argument is actually known.\n\n # Stability concerns\n\n While it is safe to call, this intrinsic may behave differently in\n a `const` context than otherwise. See the [`const_eval_select()`]\n documentation for an explanation of the issues this can cause. Unlike\n `const_eval_select`, this intrinsic isn't guaranteed to behave\n deterministically even in a `const` context.\n\n # Type Requirements\n\n `T` must be either a `bool`, a `char`, a primitive numeric type (e.g. `f32`,\n but not `NonZeroISize`), or any thin pointer (e.g. `*mut String`).\n Any other argument types *may* cause a compiler error.\n\n ## Pointers\n\n When the input is a pointer, only the pointer itself is\n ever considered. The pointee has no effect. Currently, these functions\n behave identically:\n\n ```\n #![feature(core_intrinsics)]\n # #![allow(internal_features)]\n use std::intrinsics::is_val_statically_known;\n\n fn foo(x: &i32) -> bool {\n     is_val_statically_known(x)\n }\n\n fn bar(x: &i32) -> bool {\n     is_val_statically_known(\n         (x as *const i32).addr()\n     )\n }\n # _ = foo(&5_i32);\n # _ = bar(&5_i32);\n ```\n",
      "adt": {}
    },
    "num::<impl u16>::checked_ilog2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base 2 logarithm of the number, rounded down.\n\n Returns `None` if the number is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl u16>::checked_ilog10": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base 10 logarithm of the number, rounded down.\n\n Returns `None` if the number is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl u16>::ilog2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base 2 logarithm of the number, rounded down.\n\n # Panics\n\n This function will panic if `self` is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u16>::pow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Raises self to the power of `exp`, using exponentiation by squaring.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": 3443,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:1646:9: 1690:10",
  "src": "pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            // Inform compiler of optimizations when the base is known at\n            // compile time and there's a cheaper method available.\n            //\n            // Note: Like all optimizations, this is not guaranteed to be\n            // applied by the compiler. If you want those specific bases,\n            // use `.checked_ilog2()` or `.checked_ilog10()` directly.\n            if core::intrinsics::is_val_statically_known(base) {\n                if base == 2 {\n                    return self.checked_ilog2();\n                } else if base == 10 {\n                    return self.checked_ilog10();\n                }\n            }\n\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for ⌊log(base,self)⌋ because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                ≥ ⌊log(2,self)⌋ / (⌊log(2,base)⌋ + 1)\n                    //\n                    // hence\n                    //\n                    // ⌊log(base,self)⌋ ≥ ⌊ ⌊log(2,self)⌋ / (⌊log(2,base)⌋ + 1) ⌋ .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }",
  "mir": "fn num::<impl u16>::checked_ilog(_1: u16, _2: u16) -> option::Option<u32> {\n    let mut _0: option::Option<u32>;\n    let mut _3: bool;\n    let mut _4: bool;\n    let mut _5: bool;\n    let mut _6: bool;\n    let mut _7: u32;\n    let mut _8: u16;\n    let mut _9: bool;\n    let mut _10: u32;\n    let mut _11: u32;\n    let mut _12: u32;\n    let mut _13: (u32, bool);\n    let mut _14: bool;\n    let mut _15: u16;\n    let mut _16: u32;\n    let mut _17: bool;\n    let mut _18: u16;\n    let mut _19: u16;\n    let mut _20: bool;\n    let mut _21: (u32, bool);\n    let mut _22: (u16, bool);\n    let mut _23: u32;\n    debug self => _1;\n    debug base => _2;\n    debug n => _7;\n    debug r => _8;\n    bb0: {\n        StorageLive(_3);\n        _3 = intrinsics::is_val_statically_known::<u16>(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb9, otherwise: bb2];\n    }\n    bb2: {\n        switchInt(_2) -> [2: bb3, otherwise: bb5];\n    }\n    bb3: {\n        _0 = num::<impl u16>::checked_ilog2(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        goto -> bb33;\n    }\n    bb5: {\n        switchInt(_2) -> [10: bb6, otherwise: bb8];\n    }\n    bb6: {\n        _0 = num::<impl u16>::checked_ilog10(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb33;\n    }\n    bb8: {\n        goto -> bb10;\n    }\n    bb9: {\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = Le(_1, 0_u16);\n        switchInt(move _4) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        goto -> bb14;\n    }\n    bb12: {\n        StorageLive(_5);\n        _5 = Le(_2, 1_u16);\n        switchInt(move _5) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        goto -> bb14;\n    }\n    bb14: {\n        _0 = option::Option::None;\n        goto -> bb32;\n    }\n    bb15: {\n        StorageLive(_6);\n        _6 = Lt(_1, _2);\n        switchInt(move _6) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        _0 = option::Option::Some(0_u32);\n        goto -> bb31;\n    }\n    bb17: {\n        StorageLive(_7);\n        _7 = 1_u32;\n        StorageLive(_8);\n        _8 = _2;\n        StorageLive(_9);\n        _9 = Eq(num::<impl u16>::BITS, 128_u32);\n        switchInt(move _9) -> [0: bb24, otherwise: bb18];\n    }\n    bb18: {\n        StorageLive(_10);\n        _10 = num::<impl u16>::ilog2(_1) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = num::<impl u16>::ilog2(_2) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _13 = CheckedAdd(_12, 1_u32);\n        assert(!move (_13.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _12, 1_u32) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _11 = move (_13.0: u32);\n        StorageDead(_12);\n        _14 = Eq(_11, 0_u32);\n        assert(!move _14, \"attempt to divide `{}` by zero\", _10) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _7 = Div(move _10, move _11);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _7;\n        _15 = num::<impl u16>::pow(_2, move _16) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_16);\n        _8 = move _15;\n        StorageDead(_15);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_9);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _8;\n        StorageLive(_19);\n        _20 = Eq(_2, 0_u16);\n        assert(!move _20, \"attempt to divide `{}` by zero\", _1) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _19 = Div(_1, _2);\n        _17 = Le(move _18, move _19);\n        switchInt(move _17) -> [0: bb30, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_19);\n        StorageDead(_18);\n        _21 = CheckedAdd(_7, 1_u32);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _7, 1_u32) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _7 = move (_21.0: u32);\n        _22 = CheckedMul(_8, _2);\n        assert(!move (_22.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _8, _2) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _8 = move (_22.0: u16);\n        StorageDead(_17);\n        goto -> bb25;\n    }\n    bb30: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_23);\n        _23 = _7;\n        _0 = option::Option::Some(move _23);\n        StorageDead(_23);\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_6);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb34;\n    }\n    bb33: {\n        StorageDead(_3);\n        goto -> bb34;\n    }\n    bb34: {\n        return;\n    }\n}\n",
  "doc": " Returns the logarithm of the number with respect to an arbitrary base,\n rounded down.\n\n Returns `None` if the number is zero, or if the base is not at least 2.\n\n This method might not be optimized owing to implementation details;\n `checked_ilog2` can produce results more efficiently for base 2, and\n `checked_ilog10` can produce results more efficiently for base 10.\n\n # Examples\n\n ```\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}