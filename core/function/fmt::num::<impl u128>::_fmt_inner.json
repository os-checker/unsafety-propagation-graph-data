{
  "name": "fmt::num::<impl u128>::_fmt_inner",
  "safe": false,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "fmt::num::div_rem_1e16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Euclidean division plus remainder with constant 1E16 basically consumes 16\n decimals from n.\n\n The integer division algorithm is based on the following paper:\n\n   T. Granlund and P. Montgomery, “Division by Invariant Integers Using Multiplication”\n   in Proc. of the SIGPLAN94 Conference on Programming Language Design and\n   Implementation, 1994, pp. 61–72\n\n",
      "adt": {}
    },
    "fmt::num::enc_16lsd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Encodes the 16 least-significant decimals of n into `buf[OFFSET .. OFFSET +\n 16 ]`.\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef"
    ]
  },
  "path": 3221,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:655:5: 737:6",
  "src": "unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit<u8>]) -> usize {\n        // Optimize common-case zero, which would also need special treatment due to\n        // its \"leading\" zero.\n        if self == 0 {\n            let offset = buf.len() - 1;\n            buf[offset].write(b'0');\n            return offset;\n        }\n        // Take the 16 least-significant decimals.\n        let (quot_1e16, mod_1e16) = div_rem_1e16(self);\n        let (mut remain, mut offset) = if quot_1e16 == 0 {\n            (mod_1e16, U128_MAX_DEC_N)\n        } else {\n            // Write digits at buf[23..39].\n            enc_16lsd::<{ U128_MAX_DEC_N - 16 }>(buf, mod_1e16);\n\n            // Take another 16 decimals.\n            let (quot2, mod2) = div_rem_1e16(quot_1e16);\n            if quot2 == 0 {\n                (mod2, U128_MAX_DEC_N - 16)\n            } else {\n                // Write digits at buf[7..23].\n                enc_16lsd::<{ U128_MAX_DEC_N - 32 }>(buf, mod2);\n                // Quot2 has at most 7 decimals remaining after two 1e16 divisions.\n                (quot2 as u64, U128_MAX_DEC_N - 32)\n            }\n        };\n\n        // Format per four digits from the lookup table.\n        while remain > 999 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the while condition ensures at least 4 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 4) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 4;\n\n            // pull two pairs\n            let quad = remain % 1_00_00;\n            remain /= 1_00_00;\n            let pair1 = (quad / 100) as usize;\n            let pair2 = (quad % 100) as usize;\n            buf[offset + 0].write(DECIMAL_PAIRS[pair1 * 2 + 0]);\n            buf[offset + 1].write(DECIMAL_PAIRS[pair1 * 2 + 1]);\n            buf[offset + 2].write(DECIMAL_PAIRS[pair2 * 2 + 0]);\n            buf[offset + 3].write(DECIMAL_PAIRS[pair2 * 2 + 1]);\n        }\n\n        // Format per two digits from the lookup table.\n        if remain > 9 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures at least 2 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 2) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 2;\n\n            let pair = (remain % 100) as usize;\n            remain /= 100;\n            buf[offset + 0].write(DECIMAL_PAIRS[pair * 2 + 0]);\n            buf[offset + 1].write(DECIMAL_PAIRS[pair * 2 + 1]);\n        }\n\n        // Format the last remaining digit, if any.\n        if remain != 0 {\n            // SAFETY: All of the decimals fit in buf due to U128_MAX_DEC_N\n            // and the if condition ensures (at least) 1 more decimals.\n            unsafe { core::hint::assert_unchecked(offset >= 1) }\n            // SAFETY: The offset counts down from its initial buf.len()\n            // without underflow due to the previous precondition.\n            unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n            offset -= 1;\n\n            // Either the compiler sees that remain < 10, or it prevents\n            // a boundary check up next.\n            let last = (remain & 15) as usize;\n            buf[offset].write(DECIMAL_PAIRS[last * 2 + 1]);\n            // not used: remain = 0;\n        }\n        offset\n    }",
  "mir": "fn fmt::num::<impl u128>::_fmt_inner(_1: u128, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>]) -> usize {\n    let mut _0: usize;\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _6: (usize, bool);\n    let  _7: &mut u8;\n    let mut _8: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _9: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _10: usize;\n    let mut _11: bool;\n    let  _12: u128;\n    let  _13: u64;\n    let mut _14: (u128, u64);\n    let mut _15: u64;\n    let mut _16: usize;\n    let mut _17: (u64, usize);\n    let  _18: ();\n    let  _19: u128;\n    let  _20: u64;\n    let mut _21: (u128, u64);\n    let mut _22: usize;\n    let mut _23: (usize, bool);\n    let  _24: ();\n    let mut _25: u64;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let mut _28: bool;\n    let mut _29: u64;\n    let  _30: ();\n    let mut _31: bool;\n    let mut _32: usize;\n    let  _33: ();\n    let mut _34: bool;\n    let mut _35: usize;\n    let mut _36: usize;\n    let mut _37: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _38: (usize, bool);\n    let  _39: u64;\n    let mut _40: u64;\n    let mut _41: bool;\n    let mut _42: bool;\n    let  _43: usize;\n    let mut _44: u64;\n    let mut _45: bool;\n    let  _46: usize;\n    let mut _47: u64;\n    let mut _48: bool;\n    let  _49: &mut u8;\n    let mut _50: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _51: usize;\n    let mut _52: usize;\n    let mut _53: (usize, bool);\n    let mut _54: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _55: usize;\n    let mut _56: bool;\n    let mut _57: u8;\n    let mut _58: &&[u8; 200];\n    let  _59: usize;\n    let mut _60: usize;\n    let mut _61: (usize, bool);\n    let mut _62: (usize, bool);\n    let mut _63: bool;\n    let  _64: &mut u8;\n    let mut _65: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _66: usize;\n    let mut _67: usize;\n    let mut _68: (usize, bool);\n    let mut _69: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _70: usize;\n    let mut _71: bool;\n    let mut _72: u8;\n    let mut _73: &&[u8; 200];\n    let  _74: usize;\n    let mut _75: usize;\n    let mut _76: (usize, bool);\n    let mut _77: (usize, bool);\n    let mut _78: bool;\n    let  _79: &mut u8;\n    let mut _80: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _81: usize;\n    let mut _82: usize;\n    let mut _83: (usize, bool);\n    let mut _84: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _85: usize;\n    let mut _86: bool;\n    let mut _87: u8;\n    let mut _88: &&[u8; 200];\n    let  _89: usize;\n    let mut _90: usize;\n    let mut _91: (usize, bool);\n    let mut _92: (usize, bool);\n    let mut _93: bool;\n    let  _94: &mut u8;\n    let mut _95: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _96: usize;\n    let mut _97: usize;\n    let mut _98: (usize, bool);\n    let mut _99: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _100: usize;\n    let mut _101: bool;\n    let mut _102: u8;\n    let mut _103: &&[u8; 200];\n    let  _104: usize;\n    let mut _105: usize;\n    let mut _106: (usize, bool);\n    let mut _107: (usize, bool);\n    let mut _108: bool;\n    let mut _109: bool;\n    let mut _110: u64;\n    let  _111: ();\n    let mut _112: bool;\n    let mut _113: usize;\n    let  _114: ();\n    let mut _115: bool;\n    let mut _116: usize;\n    let mut _117: usize;\n    let mut _118: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _119: (usize, bool);\n    let  _120: usize;\n    let mut _121: u64;\n    let mut _122: u64;\n    let mut _123: bool;\n    let mut _124: bool;\n    let  _125: &mut u8;\n    let mut _126: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _127: usize;\n    let mut _128: usize;\n    let mut _129: (usize, bool);\n    let mut _130: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _131: usize;\n    let mut _132: bool;\n    let mut _133: u8;\n    let mut _134: &&[u8; 200];\n    let  _135: usize;\n    let mut _136: usize;\n    let mut _137: (usize, bool);\n    let mut _138: (usize, bool);\n    let mut _139: bool;\n    let  _140: &mut u8;\n    let mut _141: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _142: usize;\n    let mut _143: usize;\n    let mut _144: (usize, bool);\n    let mut _145: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _146: usize;\n    let mut _147: bool;\n    let mut _148: u8;\n    let mut _149: &&[u8; 200];\n    let  _150: usize;\n    let mut _151: usize;\n    let mut _152: (usize, bool);\n    let mut _153: (usize, bool);\n    let mut _154: bool;\n    let mut _155: u64;\n    let  _156: ();\n    let mut _157: bool;\n    let mut _158: usize;\n    let  _159: ();\n    let mut _160: bool;\n    let mut _161: usize;\n    let mut _162: usize;\n    let mut _163: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _164: (usize, bool);\n    let  _165: usize;\n    let mut _166: u64;\n    let mut _167: u64;\n    let  _168: &mut u8;\n    let mut _169: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _170: usize;\n    let mut _171: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _172: usize;\n    let mut _173: bool;\n    let mut _174: u8;\n    let mut _175: &&[u8; 200];\n    let  _176: usize;\n    let mut _177: usize;\n    let mut _178: (usize, bool);\n    let mut _179: (usize, bool);\n    let mut _180: bool;\n    let mut _181: &[u8; 200];\n    let mut _182: &[u8; 200];\n    let mut _183: &[u8; 200];\n    let mut _184: &[u8; 200];\n    let mut _185: &[u8; 200];\n    let mut _186: &[u8; 200];\n    let mut _187: &[u8; 200];\n    debug self => _1;\n    debug buf => _2;\n    debug offset => _3;\n    debug quot_1e16 => _12;\n    debug mod_1e16 => _13;\n    debug remain => _15;\n    debug offset => _16;\n    debug quot2 => _19;\n    debug mod2 => _20;\n    debug quad => _39;\n    debug pair1 => _43;\n    debug pair2 => _46;\n    debug pair => _120;\n    debug last => _165;\n    bb0: {\n        switchInt(_1) -> [0: bb1, otherwise: bb5];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_2);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _6 = CheckedSub(_4, 1_usize);\n        assert(!move (_6.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _4, 1_usize) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = move (_6.0: usize);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _9 = &raw const (fake) (*_2);\n        _10 = PtrMetadata(move _9);\n        _11 = Lt(_3, _10);\n        assert(move _11, \"index out of bounds: the length is {} but the index is {}\", move _10, _3) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &mut (*_2)[_3];\n        _7 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _8, 48_u8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _0 = _3;\n        goto -> bb83;\n    }\n    bb5: {\n        StorageLive(_14);\n        _14 = fmt::num::div_rem_1e16(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = (_14.0: u128);\n        _13 = (_14.1: u64);\n        StorageDead(_14);\n        StorageLive(_17);\n        switchInt(_12) -> [0: bb7, otherwise: bb8];\n    }\n    bb7: {\n        _17 = (_13, fmt::num::U128_MAX_DEC_N);\n        goto -> bb17;\n    }\n    bb8: {\n        _18 = fmt::num::enc_16lsd::<23>(_2, _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_21);\n        _21 = fmt::num::div_rem_1e16(_12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _19 = (_21.0: u128);\n        _20 = (_21.1: u64);\n        StorageDead(_21);\n        switchInt(_19) -> [0: bb11, otherwise: bb13];\n    }\n    bb11: {\n        StorageLive(_22);\n        _23 = CheckedSub(fmt::num::U128_MAX_DEC_N, 16_usize);\n        assert(!move (_23.1: bool), \"attempt to compute `{} - {}`, which would overflow\", fmt::num::U128_MAX_DEC_N, 16_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _22 = move (_23.0: usize);\n        _17 = (_20, move _22);\n        StorageDead(_22);\n        goto -> bb16;\n    }\n    bb13: {\n        _24 = fmt::num::enc_16lsd::<7>(_2, _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_25);\n        _25 = _19 as u64;\n        StorageLive(_26);\n        _27 = CheckedSub(fmt::num::U128_MAX_DEC_N, 32_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} - {}`, which would overflow\", fmt::num::U128_MAX_DEC_N, 32_usize) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _26 = move (_27.0: usize);\n        _17 = (move _25, move _26);\n        StorageDead(_26);\n        StorageDead(_25);\n        goto -> bb16;\n    }\n    bb16: {\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_15);\n        _15 = (_17.0: u64);\n        StorageLive(_16);\n        _16 = (_17.1: usize);\n        StorageDead(_17);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = _15;\n        _28 = Gt(move _29, 999_u64);\n        switchInt(move _28) -> [0: bb51, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _16;\n        _31 = Ge(move _32, 4_usize);\n        StorageDead(_32);\n        _30 = hint::assert_unchecked(move _31) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_31);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = _16;\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &(*_2);\n        _36 = PtrMetadata(move _37);\n        StorageDead(_37);\n        _34 = Le(move _35, move _36);\n        StorageDead(_36);\n        StorageDead(_35);\n        _33 = hint::assert_unchecked(move _34) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_34);\n        _38 = CheckedSub(_16, 4_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _16, 4_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _16 = move (_38.0: usize);\n        StorageLive(_40);\n        _40 = _15;\n        _41 = Eq(10000_u64, 0_u64);\n        assert(!move _41, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _40) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _39 = Rem(move _40, 10000_u64);\n        StorageDead(_40);\n        _42 = Eq(10000_u64, 0_u64);\n        assert(!move _42, \"attempt to divide `{}` by zero\", _15) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _15 = Div(_15, 10000_u64);\n        StorageLive(_44);\n        _45 = Eq(100_u64, 0_u64);\n        assert(!move _45, \"attempt to divide `{}` by zero\", _39) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _44 = Div(_39, 100_u64);\n        _43 = move _44 as usize;\n        StorageDead(_44);\n        StorageLive(_47);\n        _48 = Eq(100_u64, 0_u64);\n        assert(!move _48, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _39) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _47 = Rem(_39, 100_u64);\n        _46 = move _47 as usize;\n        StorageDead(_47);\n        StorageLive(_49);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = _16;\n        _53 = CheckedAdd(_52, 0_usize);\n        assert(!move (_53.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _52, 0_usize) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _51 = move (_53.0: usize);\n        StorageDead(_52);\n        _54 = &raw const (fake) (*_2);\n        _55 = PtrMetadata(move _54);\n        _56 = Lt(_51, _55);\n        assert(move _56, \"index out of bounds: the length is {} but the index is {}\", move _55, _51) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _50 = &mut (*_2)[_51];\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = {alloc1915: &&[u8; 200]};\n        StorageLive(_59);\n        StorageLive(_60);\n        _61 = CheckedMul(_43, 2_usize);\n        assert(!move (_61.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _43, 2_usize) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _60 = move (_61.0: usize);\n        _62 = CheckedAdd(_60, 0_usize);\n        assert(!move (_62.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _60, 0_usize) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _59 = move (_62.0: usize);\n        StorageDead(_60);\n        _63 = Lt(_59, 200_usize);\n        assert(move _63, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _59) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _181 = (*_58);\n        _57 = (*_181)[_59];\n        _49 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _50, move _57) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_57);\n        StorageDead(_50);\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_51);\n        StorageDead(_49);\n        StorageLive(_64);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = _16;\n        _68 = CheckedAdd(_67, 1_usize);\n        assert(!move (_68.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _67, 1_usize) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _66 = move (_68.0: usize);\n        StorageDead(_67);\n        _69 = &raw const (fake) (*_2);\n        _70 = PtrMetadata(move _69);\n        _71 = Lt(_66, _70);\n        assert(move _71, \"index out of bounds: the length is {} but the index is {}\", move _70, _66) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _65 = &mut (*_2)[_66];\n        StorageLive(_72);\n        StorageLive(_73);\n        _73 = {alloc1915: &&[u8; 200]};\n        StorageLive(_74);\n        StorageLive(_75);\n        _76 = CheckedMul(_43, 2_usize);\n        assert(!move (_76.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _43, 2_usize) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _75 = move (_76.0: usize);\n        _77 = CheckedAdd(_75, 1_usize);\n        assert(!move (_77.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _75, 1_usize) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _74 = move (_77.0: usize);\n        StorageDead(_75);\n        _78 = Lt(_74, 200_usize);\n        assert(move _78, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _74) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _182 = (*_73);\n        _72 = (*_182)[_74];\n        _64 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _65, move _72) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_72);\n        StorageDead(_65);\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageDead(_66);\n        StorageDead(_64);\n        StorageLive(_79);\n        StorageLive(_80);\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = _16;\n        _83 = CheckedAdd(_82, 2_usize);\n        assert(!move (_83.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _82, 2_usize) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _81 = move (_83.0: usize);\n        StorageDead(_82);\n        _84 = &raw const (fake) (*_2);\n        _85 = PtrMetadata(move _84);\n        _86 = Lt(_81, _85);\n        assert(move _86, \"index out of bounds: the length is {} but the index is {}\", move _85, _81) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _80 = &mut (*_2)[_81];\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = {alloc1915: &&[u8; 200]};\n        StorageLive(_89);\n        StorageLive(_90);\n        _91 = CheckedMul(_46, 2_usize);\n        assert(!move (_91.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _46, 2_usize) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _90 = move (_91.0: usize);\n        _92 = CheckedAdd(_90, 0_usize);\n        assert(!move (_92.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _90, 0_usize) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _89 = move (_92.0: usize);\n        StorageDead(_90);\n        _93 = Lt(_89, 200_usize);\n        assert(move _93, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _89) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _183 = (*_88);\n        _87 = (*_183)[_89];\n        _79 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _80, move _87) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_87);\n        StorageDead(_80);\n        StorageDead(_89);\n        StorageDead(_88);\n        StorageDead(_81);\n        StorageDead(_79);\n        StorageLive(_94);\n        StorageLive(_95);\n        StorageLive(_96);\n        StorageLive(_97);\n        _97 = _16;\n        _98 = CheckedAdd(_97, 3_usize);\n        assert(!move (_98.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _97, 3_usize) -> [success: bb45, unwind unreachable];\n    }\n    bb45: {\n        _96 = move (_98.0: usize);\n        StorageDead(_97);\n        _99 = &raw const (fake) (*_2);\n        _100 = PtrMetadata(move _99);\n        _101 = Lt(_96, _100);\n        assert(move _101, \"index out of bounds: the length is {} but the index is {}\", move _100, _96) -> [success: bb46, unwind unreachable];\n    }\n    bb46: {\n        _95 = &mut (*_2)[_96];\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = {alloc1915: &&[u8; 200]};\n        StorageLive(_104);\n        StorageLive(_105);\n        _106 = CheckedMul(_46, 2_usize);\n        assert(!move (_106.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _46, 2_usize) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _105 = move (_106.0: usize);\n        _107 = CheckedAdd(_105, 1_usize);\n        assert(!move (_107.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _105, 1_usize) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _104 = move (_107.0: usize);\n        StorageDead(_105);\n        _108 = Lt(_104, 200_usize);\n        assert(move _108, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _104) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _184 = (*_103);\n        _102 = (*_184)[_104];\n        _94 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _95, move _102) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_102);\n        StorageDead(_95);\n        StorageDead(_104);\n        StorageDead(_103);\n        StorageDead(_96);\n        StorageDead(_94);\n        StorageDead(_28);\n        goto -> bb18;\n    }\n    bb51: {\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageLive(_109);\n        StorageLive(_110);\n        _110 = _15;\n        _109 = Gt(move _110, 9_u64);\n        switchInt(move _109) -> [0: bb53, otherwise: bb52];\n    }\n    bb52: {\n        StorageDead(_110);\n        StorageLive(_112);\n        StorageLive(_113);\n        _113 = _16;\n        _112 = Ge(move _113, 2_usize);\n        StorageDead(_113);\n        _111 = hint::assert_unchecked(move _112) -> [return: bb54, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_110);\n        goto -> bb71;\n    }\n    bb54: {\n        StorageDead(_112);\n        StorageLive(_115);\n        StorageLive(_116);\n        _116 = _16;\n        StorageLive(_117);\n        StorageLive(_118);\n        _118 = &(*_2);\n        _117 = PtrMetadata(move _118);\n        StorageDead(_118);\n        _115 = Le(move _116, move _117);\n        StorageDead(_117);\n        StorageDead(_116);\n        _114 = hint::assert_unchecked(move _115) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_115);\n        _119 = CheckedSub(_16, 2_usize);\n        assert(!move (_119.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _16, 2_usize) -> [success: bb56, unwind unreachable];\n    }\n    bb56: {\n        _16 = move (_119.0: usize);\n        StorageLive(_121);\n        StorageLive(_122);\n        _122 = _15;\n        _123 = Eq(100_u64, 0_u64);\n        assert(!move _123, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _122) -> [success: bb57, unwind unreachable];\n    }\n    bb57: {\n        _121 = Rem(move _122, 100_u64);\n        StorageDead(_122);\n        _120 = move _121 as usize;\n        StorageDead(_121);\n        _124 = Eq(100_u64, 0_u64);\n        assert(!move _124, \"attempt to divide `{}` by zero\", _15) -> [success: bb58, unwind unreachable];\n    }\n    bb58: {\n        _15 = Div(_15, 100_u64);\n        StorageLive(_125);\n        StorageLive(_126);\n        StorageLive(_127);\n        StorageLive(_128);\n        _128 = _16;\n        _129 = CheckedAdd(_128, 0_usize);\n        assert(!move (_129.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _128, 0_usize) -> [success: bb59, unwind unreachable];\n    }\n    bb59: {\n        _127 = move (_129.0: usize);\n        StorageDead(_128);\n        _130 = &raw const (fake) (*_2);\n        _131 = PtrMetadata(move _130);\n        _132 = Lt(_127, _131);\n        assert(move _132, \"index out of bounds: the length is {} but the index is {}\", move _131, _127) -> [success: bb60, unwind unreachable];\n    }\n    bb60: {\n        _126 = &mut (*_2)[_127];\n        StorageLive(_133);\n        StorageLive(_134);\n        _134 = {alloc1915: &&[u8; 200]};\n        StorageLive(_135);\n        StorageLive(_136);\n        _137 = CheckedMul(_120, 2_usize);\n        assert(!move (_137.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _120, 2_usize) -> [success: bb61, unwind unreachable];\n    }\n    bb61: {\n        _136 = move (_137.0: usize);\n        _138 = CheckedAdd(_136, 0_usize);\n        assert(!move (_138.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _136, 0_usize) -> [success: bb62, unwind unreachable];\n    }\n    bb62: {\n        _135 = move (_138.0: usize);\n        StorageDead(_136);\n        _139 = Lt(_135, 200_usize);\n        assert(move _139, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _135) -> [success: bb63, unwind unreachable];\n    }\n    bb63: {\n        _185 = (*_134);\n        _133 = (*_185)[_135];\n        _125 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _126, move _133) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_133);\n        StorageDead(_126);\n        StorageDead(_135);\n        StorageDead(_134);\n        StorageDead(_127);\n        StorageDead(_125);\n        StorageLive(_140);\n        StorageLive(_141);\n        StorageLive(_142);\n        StorageLive(_143);\n        _143 = _16;\n        _144 = CheckedAdd(_143, 1_usize);\n        assert(!move (_144.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _143, 1_usize) -> [success: bb65, unwind unreachable];\n    }\n    bb65: {\n        _142 = move (_144.0: usize);\n        StorageDead(_143);\n        _145 = &raw const (fake) (*_2);\n        _146 = PtrMetadata(move _145);\n        _147 = Lt(_142, _146);\n        assert(move _147, \"index out of bounds: the length is {} but the index is {}\", move _146, _142) -> [success: bb66, unwind unreachable];\n    }\n    bb66: {\n        _141 = &mut (*_2)[_142];\n        StorageLive(_148);\n        StorageLive(_149);\n        _149 = {alloc1915: &&[u8; 200]};\n        StorageLive(_150);\n        StorageLive(_151);\n        _152 = CheckedMul(_120, 2_usize);\n        assert(!move (_152.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _120, 2_usize) -> [success: bb67, unwind unreachable];\n    }\n    bb67: {\n        _151 = move (_152.0: usize);\n        _153 = CheckedAdd(_151, 1_usize);\n        assert(!move (_153.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _151, 1_usize) -> [success: bb68, unwind unreachable];\n    }\n    bb68: {\n        _150 = move (_153.0: usize);\n        StorageDead(_151);\n        _154 = Lt(_150, 200_usize);\n        assert(move _154, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _150) -> [success: bb69, unwind unreachable];\n    }\n    bb69: {\n        _186 = (*_149);\n        _148 = (*_186)[_150];\n        _140 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _141, move _148) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_148);\n        StorageDead(_141);\n        StorageDead(_150);\n        StorageDead(_149);\n        StorageDead(_142);\n        StorageDead(_140);\n        goto -> bb71;\n    }\n    bb71: {\n        StorageDead(_109);\n        StorageLive(_155);\n        _155 = _15;\n        switchInt(move _155) -> [0: bb81, otherwise: bb72];\n    }\n    bb72: {\n        StorageDead(_155);\n        StorageLive(_157);\n        StorageLive(_158);\n        _158 = _16;\n        _157 = Ge(move _158, 1_usize);\n        StorageDead(_158);\n        _156 = hint::assert_unchecked(move _157) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        StorageDead(_157);\n        StorageLive(_160);\n        StorageLive(_161);\n        _161 = _16;\n        StorageLive(_162);\n        StorageLive(_163);\n        _163 = &(*_2);\n        _162 = PtrMetadata(move _163);\n        StorageDead(_163);\n        _160 = Le(move _161, move _162);\n        StorageDead(_162);\n        StorageDead(_161);\n        _159 = hint::assert_unchecked(move _160) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_160);\n        _164 = CheckedSub(_16, 1_usize);\n        assert(!move (_164.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _16, 1_usize) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _16 = move (_164.0: usize);\n        StorageLive(_166);\n        StorageLive(_167);\n        _167 = _15;\n        _166 = BitAnd(move _167, 15_u64);\n        StorageDead(_167);\n        _165 = move _166 as usize;\n        StorageDead(_166);\n        StorageLive(_168);\n        StorageLive(_169);\n        StorageLive(_170);\n        _170 = _16;\n        _171 = &raw const (fake) (*_2);\n        _172 = PtrMetadata(move _171);\n        _173 = Lt(_170, _172);\n        assert(move _173, \"index out of bounds: the length is {} but the index is {}\", move _172, _170) -> [success: bb76, unwind unreachable];\n    }\n    bb76: {\n        _169 = &mut (*_2)[_170];\n        StorageLive(_174);\n        StorageLive(_175);\n        _175 = {alloc1915: &&[u8; 200]};\n        StorageLive(_176);\n        StorageLive(_177);\n        _178 = CheckedMul(_165, 2_usize);\n        assert(!move (_178.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _165, 2_usize) -> [success: bb77, unwind unreachable];\n    }\n    bb77: {\n        _177 = move (_178.0: usize);\n        _179 = CheckedAdd(_177, 1_usize);\n        assert(!move (_179.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _177, 1_usize) -> [success: bb78, unwind unreachable];\n    }\n    bb78: {\n        _176 = move (_179.0: usize);\n        StorageDead(_177);\n        _180 = Lt(_176, 200_usize);\n        assert(move _180, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _176) -> [success: bb79, unwind unreachable];\n    }\n    bb79: {\n        _187 = (*_175);\n        _174 = (*_187)[_176];\n        _168 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _169, move _174) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_174);\n        StorageDead(_169);\n        StorageDead(_176);\n        StorageDead(_175);\n        StorageDead(_170);\n        StorageDead(_168);\n        goto -> bb82;\n    }\n    bb81: {\n        StorageDead(_155);\n        goto -> bb82;\n    }\n    bb82: {\n        _0 = _16;\n        StorageDead(_16);\n        StorageDead(_15);\n        goto -> bb83;\n    }\n    bb83: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}