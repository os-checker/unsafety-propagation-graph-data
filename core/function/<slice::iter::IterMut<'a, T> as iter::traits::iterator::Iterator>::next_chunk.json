{
  "name": "<slice::iter::IterMut<'a, T> as iter::traits::iterator::Iterator>::next_chunk",
  "safe": true,
  "callees": {
    "array::iter_next_chunk": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Pulls `N` items from `iter` and returns them as an array. If the iterator\n yields fewer than `N` items, `Err` is returned containing an iterator over\n the already yielded items.\n\n Since the iterator is passed as a mutable reference and this function calls\n `next` at most `N` times, the iterator can still be used afterwards to\n retrieve the remaining items.\n\n If `iter.next()` panics, all items already yielded by the iterator are\n dropped.\n\n Used for [`Iterator::next_chunk`].\n",
      "adt": {
        "result::Result": "Constructor",
        "array::iter::IntoIter": "Constructor"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n [without_provenance]: without_provenance_mut\n",
      "adt": {}
    },
    "ptr::non_null::NonNull::<T>::offset_from_unsigned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the distance between two pointers within the same allocation, *where it's known that\n `self` is equal to or greater than `origin`*. The returned value is in\n units of T: the distance in bytes is divided by `size_of::<T>()`.\n\n This computes the same value that [`offset_from`](#method.offset_from)\n would compute, but with the added precondition that the offset is\n guaranteed to be non-negative.  This method is equivalent to\n `usize::try_from(self.offset_from(origin)).unwrap_unchecked()`,\n but it provides slightly more information to the optimizer, which can\n sometimes allow it to optimize slightly better with some backends.\n\n This method can be though of as recovering the `count` that was passed\n to [`add`](#method.add) (or, with the parameters in the other order,\n to [`sub`](#method.sub)).  The following are all equivalent, assuming\n that their safety preconditions are met:\n ```rust\n # unsafe fn blah(ptr: std::ptr::NonNull<u32>, origin: std::ptr::NonNull<u32>, count: usize) -> bool { unsafe {\n ptr.offset_from_unsigned(origin) == count\n # &&\n origin.add(count) == ptr\n # &&\n ptr.sub(count) == origin\n # } }\n ```\n\n # Safety\n\n - The distance between the pointers must be non-negative (`self >= origin`)\n\n - *All* the safety conditions of [`offset_from`](#method.offset_from)\n   apply to this method as well; see it for the full details.\n\n Importantly, despite the return type of this method being able to represent\n a larger offset, it's still *not permitted* to pass pointers which differ\n by more than `isize::MAX` *bytes*.  As such, the result of this method will\n always be less than or equal to `isize::MAX as usize`.\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let a = [0; 5];\n let ptr1: NonNull<u32> = NonNull::from(&a[1]);\n let ptr2: NonNull<u32> = NonNull::from(&a[3]);\n unsafe {\n     assert_eq!(ptr2.offset_from_unsigned(ptr1), 2);\n     assert_eq!(ptr1.add(2), ptr2);\n     assert_eq!(ptr2.sub(2), ptr1);\n     assert_eq!(ptr2.offset_from_unsigned(ptr2), 0);\n }\n\n // This would be incorrect, as the pointers are not correctly ordered:\n // ptr1.offset_from_unsigned(ptr2)\n ```\n",
      "adt": {}
    },
    "slice::iter::IterMut::<'a, T>::post_inc_start": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "slice::iter::IterMut": "MutableAsArgument",
        "ptr::non_null::NonNull": "Constructor"
      }
    },
    "ptr::non_null::NonNull::<T>::cast_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a pointer-to-`T` to a pointer-to-`[T; N]`.\n",
      "adt": {
        "ptr::non_null::NonNull": "Constructor"
      }
    },
    "ptr::non_null::NonNull::<T>::as_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n must be used instead.\n\n For the shared counterpart see [`as_ref`].\n\n [`as_uninit_mut`]: NonNull::as_uninit_mut\n [`as_ref`]: NonNull::as_ref\n\n # Safety\n\n When calling this method, you have to ensure that\n the pointer is [convertible to a reference](crate::ptr#pointer-to-reference-conversion).\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let mut ptr = NonNull::new(&mut x).expect(\"null pointer\");\n\n let x_ref = unsafe { ptr.as_mut() };\n assert_eq!(*x_ref, 0);\n *x_ref += 2;\n assert_eq!(*x_ref, 2);\n ```\n\n [the module documentation]: crate::ptr#safety\n",
      "adt": {
        "ptr::non_null::NonNull": "MutableAsArgument"
      }
    },
    "array::<impl [T; N]>::each_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows each element mutably and returns an array of mutable references\n with the same size as `self`.\n\n\n # Example\n\n ```\n\n let mut floats = [3.1, 2.7, -1.0];\n let float_refs: [&mut f64; 3] = floats.each_mut();\n *float_refs[0] = 0.0;\n assert_eq!(float_refs, [&mut 0.0, &mut 2.7, &mut -1.0]);\n assert_eq!(floats, [0.0, 2.7, -1.0]);\n ```\n",
      "adt": {}
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that yields the first `n` elements, or fewer\n if the underlying iterator ends sooner.\n\n `take(n)` yields elements until `n` elements are yielded or the end of\n the iterator is reached (whichever happens first).\n The returned iterator is a prefix of length `n` if the original iterator\n contains at least `n` elements, otherwise it contains all of the\n (fewer than `n`) elements of the original iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().take(2);\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n `take()` is often used with an infinite iterator, to make it finite:\n\n ```\n let mut iter = (0..).take(3);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n If less than `n` elements are available,\n `take` will limit itself to the size of the underlying iterator:\n\n ```\n let v = [1, 2];\n let mut iter = v.into_iter().take(5);\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Use [`by_ref`] to take from the iterator without consuming it, and then\n continue using the original iterator:\n\n ```\n let mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();\n\n // Take the first two words.\n let hello_world: Vec<_> = words.by_ref().take(2).collect();\n assert_eq!(hello_world, vec![\"hello\", \"world\"]);\n\n // Collect the rest of the words.\n // We can only do this because we used `by_ref` earlier.\n let of_rust: Vec<_> = words.collect();\n assert_eq!(of_rust, vec![\"of\", \"Rust\"]);\n ```\n\n [`by_ref`]: Iterator::by_ref\n",
      "adt": {
        "iter::adapters::take::Take": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "array::iter::IntoIter::<T, N>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the elements in a partially-initialized buffer.\n\n If you have a fully-initialized array, then use [`IntoIterator`].\n But this is useful for returning partial results from unsafe code.\n\n # Safety\n\n - The `buffer[initialized]` elements must all be initialized.\n - The range must be canonical, with `initialized.start <= initialized.end`.\n - The range must be in-bounds for the buffer, with `initialized.end <= N`.\n   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n\n It's sound to have more elements initialized than mentioned, though that\n will most likely result in them being leaked.\n\n # Examples\n\n ```\n #![feature(array_into_iter_constructors)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n use std::array::IntoIter;\n use std::mem::MaybeUninit;\n\n # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n # // otherwise it could leak. A fully-general version this would need a drop\n # // guard to handle panics from the iterator, but this works for an example.\n fn next_chunk<T: Copy, const N: usize>(\n     it: &mut impl Iterator<Item = T>,\n ) -> Result<[T; N], IntoIter<T, N>> {\n     let mut buffer = [const { MaybeUninit::uninit() }; N];\n     let mut i = 0;\n     while i < N {\n         match it.next() {\n             Some(x) => {\n                 buffer[i].write(x);\n                 i += 1;\n             }\n             None => {\n                 // SAFETY: We've initialized the first `i` items\n                 unsafe {\n                     return Err(IntoIter::new_unchecked(buffer, 0..i));\n                 }\n             }\n         }\n     }\n\n     // SAFETY: We've initialized all N items\n     unsafe { Ok(buffer.transpose().assume_init()) }\n }\n\n let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n assert_eq!(r, [10, 11, 12, 13]);\n let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n ```\n",
      "adt": {
        "array::iter::IntoIter": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "slice::iter::IterMut": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ],
    "ptr::non_null::NonNull": [
      "Plain",
      "MutRef"
    ],
    "iter::adapters::take::Take": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47372, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 47368, kind: RigidTy(Adt(AdtDef(DefId { id: 24704, name: \"mem::maybe_uninit::MaybeUninit\" }), GenericArgs([Type(Ty { id: 2012, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) }, Mut)) })]))) }, Mut)) })])"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "array::iter::IntoIter": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<slice::iter::IterMut<'a, T> as iter::traits::iterator::Iterator>::next_chunk"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:194:13: 215:14",
  "src": "fn next_chunk<const N:usize>(&mut self) -> Result<[$elem; N], crate::array::IntoIter<$elem, N>> {\n                if T::IS_ZST {\n                    return crate::array::iter_next_chunk(self);\n                }\n                let len = len!(self);\n                if len >= N {\n                    // SAFETY: we are just getting an array of [T; N] and moving the pointer over a little\n                    let r = unsafe { self.post_inc_start(N).cast_array().$into_ref() }\n                        .$array_ref(); // must convert &[T; N] to [&T; N]\n                    Ok(r)\n                } else {\n                    // cant use $array_ref because theres no builtin for &mut [MU<T>; N] -> [&mut MU<T>; N]\n                    // cant use copy_nonoverlapping as the $elem is of type &{mut} T instead of T\n                    let mut a = [const { crate::mem::MaybeUninit::<$elem>::uninit() }; N];\n                    for into in (&mut a).into_iter().take(len) {\n                        // SAFETY: take(n) limits to remainder (slice produces worse codegen)\n                        into.write(unsafe { self.post_inc_start(1).$into_ref() });\n                    }\n                    // SAFETY: we just initialized elements 0..len\n                    unsafe { Err(crate::array::IntoIter::new_unchecked(a, 0..len)) }\n                }\n            }",
  "mir": "fn <slice::iter::IterMut<'a, T> as iter::traits::iterator::Iterator>::next_chunk(_1: &mut slice::iter::IterMut<'_, T>) -> result::Result<[&mut T; N], array::iter::IntoIter<&mut T, N>> {\n    let mut _0: result::Result<[&mut T; N], array::iter::IntoIter<&mut T, N>>;\n    let  _2: usize;\n    let  _3: usize;\n    let mut _4: *mut T;\n    let  _5: ptr::non_null::NonNull<T>;\n    let mut _6: *const T;\n    let mut _7: *mut T;\n    let mut _8: ptr::non_null::NonNull<T>;\n    let mut _9: bool;\n    let mut _10: usize;\n    let  _11: [&mut T; N];\n    let mut _12: &mut [T; N];\n    let mut _13: &mut ptr::non_null::NonNull<[T; N]>;\n    let mut _14: ptr::non_null::NonNull<[T; N]>;\n    let mut _15: ptr::non_null::NonNull<T>;\n    let mut _16: [mem::maybe_uninit::MaybeUninit<&mut T>; N];\n    let mut _17: iter::adapters::take::Take<slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>>;\n    let mut _18: iter::adapters::take::Take<slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>>;\n    let mut _19: slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>;\n    let mut _20: &mut [mem::maybe_uninit::MaybeUninit<&mut T>; N];\n    let mut _21: usize;\n    let mut _22: iter::adapters::take::Take<slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>>;\n    let mut _23: option::Option<&mut mem::maybe_uninit::MaybeUninit<&mut T>>;\n    let mut _24: &mut iter::adapters::take::Take<slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>>;\n    let mut _25: isize;\n    let  _26: &mut mem::maybe_uninit::MaybeUninit<&mut T>;\n    let  _27: &mut &mut T;\n    let mut _28: &mut T;\n    let mut _29: &mut ptr::non_null::NonNull<T>;\n    let mut _30: ptr::non_null::NonNull<T>;\n    let mut _31: array::iter::IntoIter<&mut T, N>;\n    let mut _32: [mem::maybe_uninit::MaybeUninit<&mut T>; N];\n    let mut _33: ops::range::Range<usize>;\n    let mut _34: usize;\n    debug self => _1;\n    debug len => _2;\n    debug len => _3;\n    debug end => _5;\n    debug r => _11;\n    debug a => _16;\n    debug iter => _22;\n    debug into => _26;\n    bb0: {\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb3, otherwise: bb1];\n    }\n    bb1: {\n        _0 = array::iter_next_chunk::<&mut T, N, slice::iter::IterMut<'_, T>>(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        goto -> bb28;\n    }\n    bb3: {\n        StorageLive(_2);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).1: *mut T);\n        _3 = ptr::mut_ptr::<impl *mut T>::addr(move _4) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = ((*_1).1: *mut T);\n        _6 = move _7 as *const T;\n        StorageDead(_7);\n        _5 = move _6 as ptr::non_null::NonNull<T>;\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = ((*_1).0: ptr::non_null::NonNull<T>);\n        _2 = ptr::non_null::NonNull::<T>::offset_from_unsigned(_5, move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        _2 = _3;\n        StorageDead(_3);\n        goto -> bb8;\n    }\n    bb7: {\n        StorageDead(_8);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _2;\n        _9 = Ge(move _10, N);\n        switchInt(move _9) -> [0: bb14, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = slice::iter::IterMut::<'_, T>::post_inc_start(_1, N) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _14 = ptr::non_null::NonNull::<T>::cast_array::<N>(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _13 = &mut _14;\n        StorageDead(_15);\n        _12 = ptr::non_null::NonNull::<[T; N]>::as_mut::<'_>(move _13) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _11 = array::<impl [T; N]>::each_mut(_12) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _0 = result::Result::Ok(_11);\n        goto -> bb27;\n    }\n    bb14: {\n        StorageDead(_10);\n        StorageLive(_16);\n        _16 = [<slice::iter::IterMut<'_, T> as iter::traits::iterator::Iterator>::next_chunk::<N>::{constant#1}; N];\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = &mut _16;\n        _19 = <&mut [mem::maybe_uninit::MaybeUninit<&mut T>; N] as iter::traits::collect::IntoIterator>::into_iter(_20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_21);\n        _21 = _2;\n        _18 = <slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>> as iter::traits::iterator::Iterator>::take(move _19, move _21) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_21);\n        StorageDead(_19);\n        _17 = <iter::adapters::take::Take<slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>> as iter::traits::collect::IntoIterator>::into_iter(move _18) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_18);\n        StorageLive(_22);\n        _22 = move _17;\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_23);\n        _24 = &mut _22;\n        _23 = <iter::adapters::take::Take<slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<&mut T>>> as iter::traits::iterator::Iterator>::next(_24) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _25 = discriminant(_23);\n        switchInt(move _25) -> [0: bb22, 1: bb21, otherwise: bb20];\n    }\n    bb20: {\n        unreachable;\n    }\n    bb21: {\n        _26 = move ((_23 as variant#1).0: &mut mem::maybe_uninit::MaybeUninit<&mut T>);\n        StorageLive(_27);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = slice::iter::IterMut::<'_, T>::post_inc_start(_1, 1_usize) -> [return: bb23, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_17);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = move _16;\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = _2;\n        _33 = Range(0_usize, move _34);\n        StorageDead(_34);\n        _31 = array::iter::IntoIter::<&mut T, N>::new_unchecked(move _32, move _33) -> [return: bb26, unwind unreachable];\n    }\n    bb23: {\n        _29 = &mut _30;\n        _28 = ptr::non_null::NonNull::<T>::as_mut::<'_>(move _29) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_30);\n        StorageDead(_29);\n        _27 = mem::maybe_uninit::MaybeUninit::<&mut T>::write(_26, _28) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_27);\n        StorageDead(_23);\n        goto -> bb18;\n    }\n    bb26: {\n        StorageDead(_33);\n        StorageDead(_32);\n        _0 = result::Result::Err(move _31);\n        StorageDead(_31);\n        StorageDead(_16);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_9);\n        StorageDead(_2);\n        goto -> bb28;\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}