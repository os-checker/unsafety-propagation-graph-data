{
  "name": "num::int_sqrt::u16",
  "safe": true,
  "callees": {
    "num::int_sqrt::u8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [integer square root](\n https://en.wikipedia.org/wiki/Integer_square_root) of any [`u8`](prim@u8)\n input.\n",
      "adt": {}
    },
    "num::<impl u16>::leading_zeros": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of leading zeros in the binary representation of `self`.\n\n Depending on what you're doing with the value, you might also be interested in the\n [`ilog2`] function which returns a consistent number, even if the type widens.\n\n # Examples\n\n ```\n assert_eq!(n.leading_zeros(), 2);\n\n\n assert_eq!(max.leading_zeros(), 0);\n ```\n",
      "adt": {}
    },
    "num::int_sqrt::u16_stages": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the normalized [`u16`](prim@u16) input and gets its normalized\n [integer square root](https://en.wikipedia.org/wiki/Integer_square_root).\n\n # Safety\n\n `n` must be nonzero.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 14923,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_sqrt.rs:86:9: 129:10",
  "src": "pub(super) const fn $UnsignedT(mut n: $UnsignedT) -> $UnsignedT {\n            if n <= <$HalfBitsT>::MAX as $UnsignedT {\n                $HalfBitsT(n as $HalfBitsT) as $UnsignedT\n            } else {\n                // The normalization shift satisfies the Karatsuba square root\n                // algorithm precondition \"a₃ ≥ b/4\" where a₃ is the most\n                // significant quarter of `n`'s bits and b is the number of\n                // values that can be represented by that quarter of the bits.\n                //\n                // b/4 would then be all 0s except the second most significant\n                // bit (010...0) in binary. Since a₃ must be at least b/4, a₃'s\n                // most significant bit or its neighbor must be a 1. Since a₃'s\n                // most significant bits are `n`'s most significant bits, the\n                // same applies to `n`.\n                //\n                // The reason to shift by an even number of bits is because an\n                // even number of bits produces the square root shifted to the\n                // left by half of the normalization shift:\n                //\n                // sqrt(n << (2 * p))\n                // sqrt(2.pow(2 * p) * n)\n                // sqrt(2.pow(2 * p)) * sqrt(n)\n                // 2.pow(p) * sqrt(n)\n                // sqrt(n) << p\n                //\n                // Shifting by an odd number of bits leaves an ugly sqrt(2)\n                // multiplied in:\n                //\n                // sqrt(n << (2 * p + 1))\n                // sqrt(2.pow(2 * p + 1) * n)\n                // sqrt(2 * 2.pow(2 * p) * n)\n                // sqrt(2) * sqrt(2.pow(2 * p)) * sqrt(n)\n                // sqrt(2) * 2.pow(p) * sqrt(n)\n                // sqrt(2) * (sqrt(n) << p)\n                const EVEN_MAKING_BITMASK: u32 = !1;\n                let normalization_shift = n.leading_zeros() & EVEN_MAKING_BITMASK;\n                n <<= normalization_shift;\n\n                let s = $stages(n);\n\n                let denormalization_shift = normalization_shift >> 1;\n                s >> denormalization_shift\n            }\n        }",
  "mir": "fn num::int_sqrt::u16(_1: u16) -> u16 {\n    let mut _0: u16;\n    let mut _2: bool;\n    let mut _3: u16;\n    let mut _4: u16;\n    let mut _5: u8;\n    let mut _6: u8;\n    let mut _7: u16;\n    let  _8: u32;\n    let mut _9: u32;\n    let mut _10: u16;\n    let mut _11: bool;\n    let  _12: u16;\n    let mut _13: u16;\n    let  _14: u32;\n    let mut _15: u32;\n    let mut _16: bool;\n    let mut _17: bool;\n    debug n => _1;\n    debug normalization_shift => _8;\n    debug s => _12;\n    debug denormalization_shift => _14;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = _1;\n        StorageLive(_4);\n        _4 = num::<impl u8>::MAX as u16;\n        _2 = Le(move _3, move _4);\n        switchInt(move _2) -> [0: bb3, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _1;\n        _6 = move _7 as u8;\n        StorageDead(_7);\n        _5 = num::int_sqrt::u8(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _0 = move _5 as u16;\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _1;\n        _9 = num::<impl u16>::leading_zeros(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = BitAnd(move _9, num::int_sqrt::u16::EVEN_MAKING_BITMASK);\n        StorageDead(_9);\n        _11 = Lt(_8, 16_u32);\n        assert(move _11, \"attempt to shift left by `{}`, which would overflow\", _8) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _1 = Shl(_1, _8);\n        StorageLive(_13);\n        _13 = _1;\n        _12 = num::int_sqrt::u16_stages(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _15 = 1_i32 as u32;\n        _16 = Lt(move _15, 32_u32);\n        assert(move _16, \"attempt to shift right by `{}`, which would overflow\", 1_i32) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = Shr(_8, 1_i32);\n        _17 = Lt(_14, 16_u32);\n        assert(move _17, \"attempt to shift right by `{}`, which would overflow\", _14) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _0 = Shr(_12, _14);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns the [integer square root](\n https://en.wikipedia.org/wiki/Integer_square_root) of any\n input.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}