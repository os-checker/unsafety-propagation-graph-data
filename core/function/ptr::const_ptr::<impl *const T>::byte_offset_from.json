{
  "name": "ptr::const_ptr::<impl *const T>::byte_offset_from",
  "safe": false,
  "callees": {
    "ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::offset_from": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the distance between two pointers within the same allocation. The returned value is in\n units of T: the distance in bytes divided by `size_of::<T>()`.\n\n This is equivalent to `(self as isize - origin as isize) / (size_of::<T>() as isize)`,\n except that it has a lot more opportunities for UB, in exchange for the compiler\n better understanding what you are doing.\n\n The primary motivation of this method is for computing the `len` of an array/slice\n of `T` that you are currently representing as a \"start\" and \"end\" pointer\n (and \"end\" is \"one past the end\" of the array).\n In that case, `end.offset_from(start)` gets you the length of the array.\n\n All of the following safety requirements are trivially satisfied for this usecase.\n\n [`offset`]: #method.offset\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * `self` and `origin` must either\n\n   * point to the same address, or\n   * both be [derived from][crate::ptr#provenance] a pointer to the same [allocation], and the memory range between\n     the two pointers must be in bounds of that object. (See below for an example.)\n\n * The distance between the pointers, in bytes, must be an exact multiple\n   of the size of `T`.\n\n As a consequence, the absolute distance between the pointers, in bytes, computed on\n mathematical integers (without \"wrapping around\"), cannot overflow an `isize`. This is\n implied by the in-bounds requirement, and the fact that no allocation can be larger\n than `isize::MAX` bytes.\n\n The requirement for pointers to be derived from the same allocation is primarily\n needed for `const`-compatibility: the distance between pointers into *different* allocated\n objects is not known at compile-time. However, the requirement also exists at\n runtime and may be exploited by optimizations. If you wish to compute the difference between\n pointers that are not guaranteed to be from the same allocation, use `(self as isize -\n origin as isize) / size_of::<T>()`.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0; 5];\n let ptr1: *const i32 = &a[1];\n let ptr2: *const i32 = &a[3];\n unsafe {\n     assert_eq!(ptr2.offset_from(ptr1), 2);\n     assert_eq!(ptr1.offset_from(ptr2), -2);\n     assert_eq!(ptr1.offset(2), ptr2);\n     assert_eq!(ptr2.offset(-2), ptr1);\n }\n ```\n\n *Incorrect* usage:\n\n ```rust,no_run\n let ptr1 = Box::into_raw(Box::new(0u8)) as *const u8;\n let ptr2 = Box::into_raw(Box::new(1u8)) as *const u8;\n let diff = (ptr2 as isize).wrapping_sub(ptr1 as isize);\n // Make ptr2_other an \"alias\" of ptr2.add(1), but derived from ptr1.\n let ptr2_other = (ptr1 as *const u8).wrapping_offset(diff).wrapping_offset(1);\n assert_eq!(ptr2 as usize, ptr2_other as usize);\n // Since ptr2_other and ptr2 are derived from pointers to different objects,\n // computing their offset is undefined behavior, even though\n // they point to addresses that are in-bounds of the same object!\n unsafe {\n     let one = ptr2_other.offset_from(ptr2); // Undefined Behavior! ⚠️\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::ptr::const_ptr::<impl *const T>::byte_offset_from"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:635:5: 638:6",
  "src": "pub const unsafe fn byte_offset_from<U: ?Sized>(self, origin: *const U) -> isize {\n        // SAFETY: the caller must uphold the safety contract for `offset_from`.\n        unsafe { self.cast::<u8>().offset_from(origin.cast::<u8>()) }\n    }",
  "mir": "fn ptr::const_ptr::<impl *const T>::byte_offset_from(_1: *const T, _2: *const U) -> isize {\n    let mut _0: isize;\n    let mut _3: *const u8;\n    let mut _4: *const u8;\n    debug self => _1;\n    debug origin => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = ptr::const_ptr::<impl *const T>::cast::<u8>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = ptr::const_ptr::<impl *const U>::cast::<u8>(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = ptr::const_ptr::<impl *const u8>::offset_from(move _3, move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Calculates the distance between two pointers within the same allocation. The returned value is in\n units of **bytes**.\n\n This is purely a convenience for casting to a `u8` pointer and\n using [`offset_from`][pointer::offset_from] on it. See that method for\n documentation and safety requirements.\n\n For non-`Sized` pointees this operation considers only the data pointers,\n ignoring the metadata.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}