{
  "name": "num::flt2dec::decoder::decode",
  "safe": true,
  "callees": {
    "num::dec2flt::float::RawFloat::integer_decode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the mantissa, exponent and sign as integers.\n\n This returns `(m, p, s)` such that `s * m * 2^p` represents the original float. For 0, the\n exponent will be `-(EXP_BIAS + SIG_BITS)`, which is the minimum subnormal power. For\n infinity or NaN, the exponent will be `EXP_SAT - EXP_BIAS - SIG_BITS`.\n\n If subnormal, the mantissa will be shifted one bit to the left. Otherwise, it is returned\n with the explicit bit set but otherwise unshifted\n\n `s` is only ever +/-1.\n",
      "adt": {}
    },
    "num::dec2flt::float::RawFloat::classify": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the category that this number falls into.\n",
      "adt": {}
    },
    "num::flt2dec::decoder::DecodableFloat::min_pos_norm_value": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum positive normalized value.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::FpCategory": [
      "Plain"
    ],
    "num::flt2dec::decoder::Decoded": [
      "Plain"
    ],
    "num::flt2dec::decoder::FullDecoded": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::decoder::decode"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/decoder.rs:69:1: 107:2",
  "src": "pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n    let (mant, exp, sign) = v.integer_decode();\n    let even = (mant & 1) == 0;\n    let decoded = match v.classify() {\n        FpCategory::Nan => FullDecoded::Nan,\n        FpCategory::Infinite => FullDecoded::Infinite,\n        FpCategory::Zero => FullDecoded::Zero,\n        FpCategory::Subnormal => {\n            // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n            // Float::integer_decode always preserves the exponent,\n            // so the mantissa is scaled for subnormals.\n            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1, exp, inclusive: even })\n        }\n        FpCategory::Normal => {\n            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n            if mant == minnorm.0 {\n                // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n                // where maxmant = minnormmant * 2 - 1\n                FullDecoded::Finite(Decoded {\n                    mant: mant << 2,\n                    minus: 1,\n                    plus: 2,\n                    exp: exp - 2,\n                    inclusive: even,\n                })\n            } else {\n                // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n                FullDecoded::Finite(Decoded {\n                    mant: mant << 1,\n                    minus: 1,\n                    plus: 1,\n                    exp: exp - 1,\n                    inclusive: even,\n                })\n            }\n        }\n    };\n    (sign < 0, decoded)\n}",
  "mir": "fn num::flt2dec::decoder::decode(_1: T) -> (bool, num::flt2dec::decoder::FullDecoded) {\n    let mut _0: (bool, num::flt2dec::decoder::FullDecoded);\n    let  _2: u64;\n    let  _3: i16;\n    let  _4: i8;\n    let mut _5: (u64, i16, i8);\n    let  _6: bool;\n    let mut _7: u64;\n    let  _8: num::flt2dec::decoder::FullDecoded;\n    let mut _9: num::FpCategory;\n    let mut _10: isize;\n    let mut _11: num::flt2dec::decoder::Decoded;\n    let  _12: (u64, i16, i8);\n    let mut _13: T;\n    let mut _14: bool;\n    let mut _15: u64;\n    let mut _16: num::flt2dec::decoder::Decoded;\n    let mut _17: u64;\n    let mut _18: u32;\n    let mut _19: bool;\n    let mut _20: i16;\n    let mut _21: (i16, bool);\n    let mut _22: num::flt2dec::decoder::Decoded;\n    let mut _23: u64;\n    let mut _24: u32;\n    let mut _25: bool;\n    let mut _26: i16;\n    let mut _27: (i16, bool);\n    let mut _28: bool;\n    let mut _29: num::flt2dec::decoder::FullDecoded;\n    debug v => _1;\n    debug mant => _2;\n    debug exp => _3;\n    debug sign => _4;\n    debug even => _6;\n    debug decoded => _8;\n    debug minnorm => _12;\n    bb0: {\n        StorageLive(_5);\n        _5 = <T as num::dec2flt::float::RawFloat>::integer_decode(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = (_5.0: u64);\n        _3 = (_5.1: i16);\n        _4 = (_5.2: i8);\n        StorageDead(_5);\n        StorageLive(_7);\n        _7 = BitAnd(_2, 1_u64);\n        _6 = Eq(move _7, 0_u64);\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = <T as num::dec2flt::float::RawFloat>::classify(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _10 = discriminant(_9);\n        switchInt(move _10) -> [0: bb8, 1: bb7, 2: bb6, 3: bb5, 4: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = <T as num::flt2dec::decoder::DecodableFloat>::min_pos_norm_value() -> [return: bb9, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_11);\n        _11 = Decoded(_2, 1_u64, 1_u64, _3, _6);\n        _8 = num::flt2dec::decoder::FullDecoded::Finite(move _11);\n        StorageDead(_11);\n        goto -> bb18;\n    }\n    bb6: {\n        _8 = num::flt2dec::decoder::FullDecoded::Zero;\n        goto -> bb18;\n    }\n    bb7: {\n        _8 = num::flt2dec::decoder::FullDecoded::Infinite;\n        goto -> bb18;\n    }\n    bb8: {\n        _8 = num::flt2dec::decoder::FullDecoded::Nan;\n        goto -> bb18;\n    }\n    bb9: {\n        _12 = <T as num::dec2flt::float::RawFloat>::integer_decode(move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (_12.0: u64);\n        _14 = Eq(_2, move _15);\n        switchInt(move _14) -> [0: bb14, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _18 = 2_i32 as u32;\n        _19 = Lt(move _18, 64_u32);\n        assert(move _19, \"attempt to shift left by `{}`, which would overflow\", 2_i32) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _17 = Shl(_2, 2_i32);\n        StorageLive(_20);\n        _21 = CheckedSub(_3, 2_i16);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 2_i16) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_21.0: i16);\n        _16 = Decoded(move _17, 1_u64, 2_u64, move _20, _6);\n        StorageDead(_20);\n        StorageDead(_17);\n        _8 = num::flt2dec::decoder::FullDecoded::Finite(move _16);\n        StorageDead(_16);\n        goto -> bb17;\n    }\n    bb14: {\n        StorageDead(_15);\n        StorageLive(_22);\n        StorageLive(_23);\n        _24 = 1_i32 as u32;\n        _25 = Lt(move _24, 64_u32);\n        assert(move _25, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _23 = Shl(_2, 1_i32);\n        StorageLive(_26);\n        _27 = CheckedSub(_3, 1_i16);\n        assert(!move (_27.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 1_i16) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _26 = move (_27.0: i16);\n        _22 = Decoded(move _23, 1_u64, 1_u64, move _26, _6);\n        StorageDead(_26);\n        StorageDead(_23);\n        _8 = num::flt2dec::decoder::FullDecoded::Finite(move _22);\n        StorageDead(_22);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_14);\n        StorageDead(_12);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_9);\n        StorageLive(_28);\n        _28 = Lt(_4, 0_i8);\n        StorageLive(_29);\n        _29 = _8;\n        _0 = (move _28, move _29);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}