{
  "name": "alloc::global::GlobalAlloc::realloc",
  "safe": false,
  "callees": {
    "alloc::layout::Layout::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum byte alignment for a memory block of this layout.\n\n The returned alignment is guaranteed to be a power of two.\n",
      "adt": {
        "alloc::layout::Layout": "ImmutableAsArgument"
      }
    },
    "alloc::layout::Layout::from_size_align_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout, bypassing all checks.\n\n # Safety\n\n This function is unsafe as it does not verify the preconditions from\n [`Layout::from_size_align`].\n",
      "adt": {
        "alloc::layout::Layout": "Constructor"
      }
    },
    "alloc::global::GlobalAlloc::alloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates memory as described by the given `layout`.\n\n Returns a pointer to newly-allocated memory,\n or null to indicate allocation failure.\n\n # Safety\n\n `layout` must have non-zero size. Attempting to allocate for a zero-sized `layout` will\n result in undefined behavior.\n\n (Extension subtraits might provide more specific bounds on\n behavior, e.g., guarantee a sentinel address or a null pointer\n in response to a zero-size allocation request.)\n\n The allocated block of memory may or may not be initialized.\n\n # Errors\n\n Returning a null pointer indicates that either memory is exhausted\n or `layout` does not meet this allocator's size or alignment constraints.\n\n Implementations are encouraged to return null on memory\n exhaustion rather than aborting, but this is not\n a strict requirement. (Specifically: it is *legal* to\n implement this trait atop an underlying native allocation\n library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an\n allocation error are encouraged to call the [`handle_alloc_error`] function,\n rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "alloc::layout::Layout::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum size in bytes for a memory block of this layout.\n",
      "adt": {
        "alloc::layout::Layout": "ImmutableAsArgument"
      }
    },
    "cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "alloc::global::GlobalAlloc::dealloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Deallocates the block of memory at the given `ptr` pointer with the given `layout`.\n\n # Safety\n\n The caller must ensure:\n\n * `ptr` is a block of memory currently allocated via this allocator and,\n\n * `layout` is the same layout that was used to allocate that block of\n   memory.\n\n Otherwise the behavior is undefined.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc::layout::Layout": [
      "Ref",
      "Plain"
    ]
  },
  "path": {
    "type": "External",
    "path": "alloc::global::GlobalAlloc::realloc"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/alloc/global.rs:286:5: 301:6",
  "src": "unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n        // SAFETY: the caller must ensure that the `new_size` does not overflow.\n        // `layout.align()` comes from a `Layout` and is thus guaranteed to be valid.\n        let new_layout = unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n        // SAFETY: the caller must ensure that `new_layout` is greater than zero.\n        let new_ptr = unsafe { self.alloc(new_layout) };\n        if !new_ptr.is_null() {\n            // SAFETY: the previously allocated block cannot overlap the newly allocated block.\n            // The safety contract for `dealloc` must be upheld by the caller.\n            unsafe {\n                ptr::copy_nonoverlapping(ptr, new_ptr, cmp::min(layout.size(), new_size));\n                self.dealloc(ptr, layout);\n            }\n        }\n        new_ptr\n    }",
  "mir": "fn alloc::global::GlobalAlloc::realloc(_1: &Self, _2: *mut u8, _3: alloc::layout::Layout, _4: usize) -> *mut u8 {\n    let mut _0: *mut u8;\n    let  _5: alloc::layout::Layout;\n    let mut _6: usize;\n    let mut _7: &alloc::layout::Layout;\n    let mut _8: bool;\n    let  _9: ();\n    let mut _10: *const u8;\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: &alloc::layout::Layout;\n    let  _14: ();\n    debug self => _1;\n    debug ptr => _2;\n    debug layout => _3;\n    debug new_size => _4;\n    debug new_layout => _5;\n    debug new_ptr => _0;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_3;\n        _6 = alloc::layout::Layout::align(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _5 = alloc::layout::Layout::from_size_align_unchecked(_4, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _0 = <Self as alloc::global::GlobalAlloc>::alloc(_1, _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_8);\n        _8 = ptr::mut_ptr::<impl *mut u8>::is_null(_0) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _8) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        goto -> bb11;\n    }\n    bb6: {\n        StorageLive(_10);\n        _10 = _2 as *const u8;\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_3;\n        _12 = alloc::layout::Layout::size(move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        _11 = cmp::min::<usize>(move _12, _4) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        _9 = ptr::copy_nonoverlapping::<u8>(move _10, _0, move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _14 = <Self as alloc::global::GlobalAlloc>::dealloc(_1, _2, _3) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Shrinks or grows a block of memory to the given `new_size` in bytes.\n The block is described by the given `ptr` pointer and `layout`.\n\n If this returns a non-null pointer, then ownership of the memory block\n referenced by `ptr` has been transferred to this allocator.\n Any access to the old `ptr` is Undefined Behavior, even if the\n allocation remained in-place. The newly returned pointer is the only valid pointer\n for accessing this memory now.\n\n The new memory block is allocated with `layout`,\n but with the `size` updated to `new_size` in bytes.\n This new layout must be used when deallocating the new memory block with `dealloc`.\n The range `0..min(layout.size(), new_size)` of the new memory block is\n guaranteed to have the same values as the original block.\n\n If this method returns null, then ownership of the memory\n block has not been transferred to this allocator, and the\n contents of the memory block are unaltered.\n\n # Safety\n\n The caller must ensure that:\n\n * `ptr` is allocated via this allocator,\n\n * `layout` is the same layout that was used\n   to allocate that block of memory,\n\n * `new_size` is greater than zero.\n\n * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n   does not overflow `isize` (i.e., the rounded value must be less than or\n   equal to `isize::MAX`).\n\n If these are not followed, the behavior is undefined.\n\n (Extension subtraits might provide more specific bounds on\n behavior, e.g., guarantee a sentinel address or a null pointer\n in response to a zero-size allocation request.)\n\n # Errors\n\n Returns null if the new layout does not meet the size\n and alignment constraints of the allocator, or if reallocation\n otherwise fails.\n\n Implementations are encouraged to return null on memory\n exhaustion rather than panicking or aborting, but this is not\n a strict requirement. (Specifically: it is *legal* to\n implement this trait atop an underlying native allocation\n library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to a\n reallocation error are encouraged to call the [`handle_alloc_error`] function,\n rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}