{
  "name": "iter::traits::iterator::iter_eq",
  "safe": true,
  "callees": {
    "iter::traits::iterator::iter_compare": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares two iterators element-wise using the given function.\n\n If `ControlFlow::Continue(())` is returned from the function, the comparison moves on to the next\n elements of both iterators. Returning `ControlFlow::Break(x)` short-circuits the iteration and\n returns `ControlFlow::Break(x)`. If one of the iterators runs out of elements,\n `ControlFlow::Continue(ord)` is returned where `ord` is the result of comparing the lengths of\n the iterators.\n\n Isolates the logic shared by ['cmp_by'](Iterator::cmp_by),\n ['partial_cmp_by'](Iterator::partial_cmp_by), and ['eq_by'](Iterator::eq_by).\n",
      "adt": {
        "ops::control_flow::ControlFlow": "Constructor"
      }
    },
    "ops::control_flow::ControlFlow::<B, C>::continue_value": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the `ControlFlow` into an `Option` which is `Some` if the\n `ControlFlow` was `Continue` and `None` otherwise.\n\n # Examples\n\n ```\n use std::ops::ControlFlow;\n\n assert_eq!(ControlFlow::<&str, i32>::Break(\"Stop right there!\").continue_value(), None);\n assert_eq!(ControlFlow::<&str, i32>::Continue(3).continue_value(), Some(3));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_some_and": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] and the value inside of it matches a predicate.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some_and(|x| x > 1), true);\n\n let x: Option<u32> = Some(0);\n assert_eq!(x.is_some_and(|x| x > 1), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some_and(|x| x > 1), false);\n\n let x: Option<String> = Some(\"ownership\".to_string());\n assert_eq!(x.as_ref().is_some_and(|x| x.len() > 1), true);\n println!(\"still alive {:?}\", x);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::control_flow::ControlFlow": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": 14280,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:4116:1: 4123:2",
  "src": "fn iter_eq<A, B, F>(a: A, b: B, f: F) -> bool\nwhere\n    A: Iterator,\n    B: Iterator,\n    F: FnMut(A::Item, B::Item) -> ControlFlow<()>,\n{\n    iter_compare(a, b, f).continue_value().is_some_and(|ord| ord == Ordering::Equal)\n}",
  "mir": "fn iter::traits::iterator::iter_eq(_1: A, _2: B, _3: F) -> bool {\n    let mut _0: bool;\n    let mut _4: option::Option<cmp::Ordering>;\n    let mut _5: ops::control_flow::ControlFlow<(), cmp::Ordering>;\n    debug a => _1;\n    debug b => _2;\n    debug f => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = iter::traits::iterator::iter_compare::<A, B, F, ()>(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = ops::control_flow::ControlFlow::<(), cmp::Ordering>::continue_value(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _0 = option::Option::<cmp::Ordering>::is_some_and::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:4122:56: 4122:61}>(move _4, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:4122:56: 4122:61}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}