{
  "name": "result::Result::<T, E>::as_deref_mut",
  "safe": true,
  "callees": {
    "result::Result::<T, E>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Result<T, E>` to `Result<&mut T, &mut E>`.\n\n # Examples\n\n ```\n fn mutate(r: &mut Result<i32, i32>) {\n     match r.as_mut() {\n         Ok(v) => *v = 42,\n         Err(e) => *e = 0,\n     }\n }\n\n let mut x: Result<i32, i32> = Ok(2);\n mutate(&mut x);\n assert_eq!(x.unwrap(), 42);\n\n let mut x: Result<i32, i32> = Err(13);\n mutate(&mut x);\n assert_eq!(x.unwrap_err(), 0);\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "ops::deref::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "MutRef",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::result::Result::<T, E>::as_deref_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1074:5: 1079:6",
  "src": "pub const fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E>\n    where\n        T: [const] DerefMut,\n    {\n        self.as_mut().map(DerefMut::deref_mut)\n    }",
  "mir": "fn result::Result::<T, E>::as_deref_mut(_1: &mut result::Result<T, E>) -> result::Result<&mut <T as ops::deref::Deref>::Target, &mut E> {\n    let mut _0: result::Result<&mut <T as ops::deref::Deref>::Target, &mut E>;\n    let mut _2: result::Result<&mut T, &mut E>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = result::Result::<T, E>::as_mut(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = result::Result::<&mut T, &mut E>::map::<&mut <T as ops::deref::Deref>::Target, for<'a> fn(&'a mut T) -> &'a mut <T as ops::deref::Deref>::Target {<T as ops::deref::DerefMut>::deref_mut}>(move _2, <T as ops::deref::DerefMut>::deref_mut) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n\n Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n and returns the new [`Result`].\n\n # Examples\n\n ```\n let mut s = \"HELLO\".to_string();\n let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n let y: Result<&mut str, &mut u32> = Ok(&mut s);\n assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n\n let mut i = 42;\n let mut x: Result<String, u32> = Err(42);\n let y: Result<&mut str, &mut u32> = Err(&mut i);\n assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}