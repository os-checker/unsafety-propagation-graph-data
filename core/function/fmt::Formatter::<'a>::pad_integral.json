{
  "name": "fmt::Formatter::<'a>::pad_integral",
  "safe": true,
  "callees": {
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::sign_plus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the `+` flag was specified.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if formatter.sign_plus() {\n             write!(formatter,\n                    \"Foo({}{})\",\n                    if self.0 < 0 { '-' } else { '+' },\n                    self.0.abs())\n         } else {\n             write!(formatter, \"Foo({})\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:+}\", Foo(23)), \"Foo(+23)\");\n assert_eq!(format!(\"{:+}\", Foo(-23)), \"Foo(-23)\");\n assert_eq!(format!(\"{}\", Foo(23)), \"Foo(23)\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument"
      }
    },
    "fmt::Formatter::<'a>::alternate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the `#` flag was specified.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if formatter.alternate() {\n             write!(formatter, \"Foo({})\", self.0)\n         } else {\n             write!(formatter, \"{}\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n assert_eq!(format!(\"{}\", Foo(23)), \"23\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument"
      }
    },
    "str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"y̆\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'y̆'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {
        "str::iter::Chars": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the iterator, counting the number of iterations and returning it.\n\n This method will call [`next`] repeatedly until [`None`] is encountered,\n returning the number of times it saw [`Some`]. Note that [`next`] has to be\n called at least once even if the iterator does not have any elements.\n\n [`next`]: Iterator::next\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so counting elements of\n an iterator with more than [`usize::MAX`] elements either produces the\n wrong result or panics. If overflow checks are enabled, a panic is\n guaranteed.\n\n # Panics\n\n This function might panic if the iterator has more than [`usize::MAX`]\n elements.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().count(), 3);\n\n let a = [1, 2, 3, 4, 5];\n assert_eq!(a.iter().count(), 5);\n ```\n",
      "adt": {}
    },
    "convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad_integral::write_prefix": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fmt::Write::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a string slice into this writer, returning whether the write\n succeeded.\n\n This method can only succeed if the entire string slice was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`std::fmt::Error`][Error] on error.\n\n The purpose of that error is to abort the formatting operation when the underlying\n destination encounters some error preventing it from accepting more text;\n in particular, it does not communicate any information about *what* error occurred.\n It should generally be propagated rather than handled, at least when implementing\n formatting traits.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n     f.write_str(s)\n }\n\n let mut buf = String::new();\n writer(&mut buf, \"hola\")?;\n assert_eq!(&buf, \"hola\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::sign_aware_zero_pad": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the `0` flag was specified.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         assert!(formatter.sign_aware_zero_pad());\n         assert_eq!(formatter.width(), Some(4));\n         // We ignore the formatter's options.\n         write!(formatter, \"{}\", self.0)\n     }\n }\n\n assert_eq!(format!(\"{:04}\", Foo(23)), \"23\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument"
      }
    },
    "fmt::FormattingOptions::fill": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the fill character.\n\n The optional fill character and alignment is provided normally in\n conjunction with the width parameter. This indicates that if the value\n being formatted is smaller than width some extra characters will be\n printed around it.\n",
      "adt": {
        "fmt::FormattingOptions": "MutableAsArgument"
      }
    },
    "fmt::FormattingOptions::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets or removes the alignment.\n\n The alignment specifies how the value being formatted should be\n positioned if it is smaller than the width of the formatter.\n",
      "adt": {
        "fmt::FormattingOptions": "MutableAsArgument"
      }
    },
    "fmt::Formatter::<'a>::padding": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes the pre-padding and returns the unwritten post-padding.\n\n Callers are responsible for ensuring post-padding is written after the\n thing that is being padded.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor",
        "fmt::PostPadding": "Constructor"
      }
    },
    "fmt::PostPadding::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes this post padding.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ],
    "fmt::Formatter": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "str::iter::Chars": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11599, kind: RigidTy(Adt(AdtDef(DefId { id: 27980, name: \"fmt::PostPadding\" }), GenericArgs([]))) })])"
    ],
    "fmt::FormattingOptions": [
      "Plain",
      "MutRef"
    ],
    "fmt::Alignment": [
      "Plain"
    ],
    "fmt::PostPadding": [
      "Plain"
    ]
  },
  "path": 13035,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1825:5: 1877:6",
  "src": "pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-');\n            width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+');\n            width += 1;\n        }\n\n        let prefix = if self.alternate() {\n            width += prefix.chars().count();\n            Some(prefix)\n        } else {\n            None\n        };\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        #[inline(never)]\n        fn write_prefix(f: &mut Formatter<'_>, sign: Option<char>, prefix: Option<&str>) -> Result {\n            if let Some(c) = sign {\n                f.buf.write_char(c)?;\n            }\n            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n        }\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        let min = self.options.width;\n        if width >= usize::from(min) {\n            // We're over the minimum width, so then we can just write the bytes.\n            write_prefix(self, sign, prefix)?;\n            self.buf.write_str(buf)\n        } else if self.sign_aware_zero_pad() {\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            let old_options = self.options;\n            self.options.fill('0').align(Some(Alignment::Right));\n            write_prefix(self, sign, prefix)?;\n            let post_padding = self.padding(min - width as u16, Alignment::Right)?;\n            self.buf.write_str(buf)?;\n            post_padding.write(self)?;\n            self.options = old_options;\n            Ok(())\n        } else {\n            // Otherwise, the sign and prefix goes after the padding\n            let post_padding = self.padding(min - width as u16, Alignment::Right)?;\n            write_prefix(self, sign, prefix)?;\n            self.buf.write_str(buf)?;\n            post_padding.write(self)\n        }\n    }",
  "mir": "fn fmt::Formatter::<'a>::pad_integral(_1: &mut fmt::Formatter<'_>, _2: bool, _3: &str, _4: &str) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _5: usize;\n    let mut _6: option::Option<char>;\n    let mut _7: option::Option<char>;\n    let mut _8: (usize, bool);\n    let mut _9: bool;\n    let mut _10: &fmt::Formatter<'_>;\n    let mut _11: option::Option<char>;\n    let mut _12: (usize, bool);\n    let  _13: option::Option<&str>;\n    let mut _14: bool;\n    let mut _15: &fmt::Formatter<'_>;\n    let mut _16: usize;\n    let mut _17: str::iter::Chars<'_>;\n    let mut _18: (usize, bool);\n    let  _19: u16;\n    let mut _20: bool;\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _24: result::Result<(), fmt::Error>;\n    let mut _25: option::Option<char>;\n    let mut _26: option::Option<&str>;\n    let mut _27: isize;\n    let mut _28: bool;\n    let mut _29: &fmt::Formatter<'_>;\n    let  _30: fmt::FormattingOptions;\n    let  _31: &mut fmt::FormattingOptions;\n    let mut _32: &mut fmt::FormattingOptions;\n    let mut _33: &mut fmt::FormattingOptions;\n    let mut _34: option::Option<fmt::Alignment>;\n    let mut _35: fmt::Alignment;\n    let mut _36: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _37: result::Result<(), fmt::Error>;\n    let mut _38: option::Option<char>;\n    let mut _39: option::Option<&str>;\n    let mut _40: isize;\n    let mut _41: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>, fmt::PostPadding>;\n    let mut _42: result::Result<fmt::PostPadding, fmt::Error>;\n    let mut _43: u16;\n    let mut _44: u16;\n    let mut _45: usize;\n    let mut _46: (u16, bool);\n    let mut _47: fmt::Alignment;\n    let mut _48: isize;\n    let  _49: fmt::PostPadding;\n    let mut _50: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _51: result::Result<(), fmt::Error>;\n    let mut _52: isize;\n    let mut _53: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _54: result::Result<(), fmt::Error>;\n    let mut _55: isize;\n    let mut _56: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>, fmt::PostPadding>;\n    let mut _57: result::Result<fmt::PostPadding, fmt::Error>;\n    let mut _58: u16;\n    let mut _59: u16;\n    let mut _60: usize;\n    let mut _61: (u16, bool);\n    let mut _62: fmt::Alignment;\n    let mut _63: isize;\n    let  _64: fmt::PostPadding;\n    let mut _65: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _66: result::Result<(), fmt::Error>;\n    let mut _67: option::Option<char>;\n    let mut _68: option::Option<&str>;\n    let mut _69: isize;\n    let mut _70: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _71: result::Result<(), fmt::Error>;\n    let mut _72: isize;\n    let mut _73: &mut dyn fmt::Write;\n    let mut _74: &mut dyn fmt::Write;\n    let mut _75: &mut dyn fmt::Write;\n    debug self => _1;\n    debug is_nonnegative => _2;\n    debug prefix => _3;\n    debug buf => _4;\n    debug width => _5;\n    debug sign => _6;\n    debug prefix => _13;\n    debug min => _19;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug old_options => _30;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug post_padding => _49;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => _49;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug post_padding => _64;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => _64;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_5);\n        _5 = str::<impl str>::len(_4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = option::Option::None;\n        switchInt(_2) -> [0: bb2, otherwise: bb4];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = option::Option::Some('-');\n        _6 = move _7;\n        StorageDead(_7);\n        _8 = CheckedAdd(_5, 1_usize);\n        assert(!move (_8.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, 1_usize) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = move (_8.0: usize);\n        goto -> bb10;\n    }\n    bb4: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_1);\n        _9 = fmt::Formatter::<'_>::sign_plus(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _9) -> [0: bb8, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = option::Option::Some('+');\n        _6 = move _11;\n        StorageDead(_11);\n        _12 = CheckedAdd(_5, 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _5 = move (_12.0: usize);\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_10);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_9);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = fmt::Formatter::<'_>::alternate(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _14) -> [0: bb16, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = str::<impl str>::chars(_3) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _16 = <str::iter::Chars<'_> as iter::traits::iterator::Iterator>::count(move _17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        _18 = CheckedAdd(_5, _16);\n        assert(!move (_18.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, move _16) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _5 = move (_18.0: usize);\n        StorageDead(_16);\n        _13 = option::Option::Some(_3);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_15);\n        _13 = option::Option::None;\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_14);\n        _19 = (((*_1).0: fmt::FormattingOptions).1: u16);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _5;\n        StorageLive(_22);\n        _22 = <usize as convert::From<u16>>::from(_19) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _20 = Ge(move _21, move _22);\n        switchInt(move _20) -> [0: bb27, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _6;\n        StorageLive(_26);\n        _26 = _13;\n        _24 = fmt::Formatter::<'a>::pad_integral::write_prefix(_1, move _25, move _26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_26);\n        StorageDead(_25);\n        _23 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _24) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_24);\n        _27 = discriminant(_23);\n        switchInt(move _27) -> [0: bb23, 1: bb24, otherwise: bb22];\n    }\n    bb22: {\n        unreachable;\n    }\n    bb23: {\n        StorageDead(_23);\n        _73 = ((*_1).1: &mut dyn fmt::Write);\n        _0 = <dyn fmt::Write as fmt::Write>::write_str(_73, _4) -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_23);\n        goto -> bb77;\n    }\n    bb26: {\n        goto -> bb72;\n    }\n    bb27: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &(*_1);\n        _28 = fmt::Formatter::<'_>::sign_aware_zero_pad(move _29) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        switchInt(move _28) -> [0: bb53, otherwise: bb29];\n    }\n    bb29: {\n        StorageDead(_29);\n        _30 = ((*_1).0: fmt::FormattingOptions);\n        StorageLive(_31);\n        StorageLive(_33);\n        _33 = &mut ((*_1).0: fmt::FormattingOptions);\n        _32 = fmt::FormattingOptions::fill(move _33, '0') -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = fmt::Alignment::Right;\n        _34 = option::Option::Some(move _35);\n        StorageDead(_35);\n        _31 = fmt::FormattingOptions::align(_32, move _34) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_34);\n        StorageDead(_31);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _6;\n        StorageLive(_39);\n        _39 = _13;\n        _37 = fmt::Formatter::<'a>::pad_integral::write_prefix(_1, move _38, move _39) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _36 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _37) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_37);\n        _40 = discriminant(_36);\n        switchInt(move _40) -> [0: bb34, 1: bb35, otherwise: bb22];\n    }\n    bb34: {\n        StorageDead(_36);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = _5;\n        _44 = move _45 as u16;\n        StorageDead(_45);\n        _46 = CheckedSub(_19, _44);\n        assert(!move (_46.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _19, move _44) -> [success: bb37, unwind unreachable];\n    }\n    bb35: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_36);\n        goto -> bb75;\n    }\n    bb37: {\n        _43 = move (_46.0: u16);\n        StorageDead(_44);\n        StorageLive(_47);\n        _47 = fmt::Alignment::Right;\n        _42 = fmt::Formatter::<'_>::padding(_1, move _43, move _47) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_47);\n        StorageDead(_43);\n        _41 = <result::Result<fmt::PostPadding, fmt::Error> as ops::try_trait::Try>::branch(move _42) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_42);\n        _48 = discriminant(_41);\n        switchInt(move _48) -> [0: bb40, 1: bb41, otherwise: bb22];\n    }\n    bb40: {\n        _49 = move ((_41 as variant#0).0: fmt::PostPadding);\n        StorageDead(_41);\n        StorageLive(_50);\n        StorageLive(_51);\n        _74 = ((*_1).1: &mut dyn fmt::Write);\n        _51 = <dyn fmt::Write as fmt::Write>::write_str(_74, _4) -> [return: bb43, unwind unreachable];\n    }\n    bb41: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_41);\n        goto -> bb74;\n    }\n    bb43: {\n        _50 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _51) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_51);\n        _52 = discriminant(_50);\n        switchInt(move _52) -> [0: bb45, 1: bb46, otherwise: bb22];\n    }\n    bb45: {\n        StorageDead(_50);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = fmt::PostPadding::write(_49, _1) -> [return: bb48, unwind unreachable];\n    }\n    bb46: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_50);\n        goto -> bb74;\n    }\n    bb48: {\n        _53 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _54) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_54);\n        _55 = discriminant(_53);\n        switchInt(move _55) -> [0: bb50, 1: bb51, otherwise: bb22];\n    }\n    bb50: {\n        StorageDead(_53);\n        ((*_1).0: fmt::FormattingOptions) = _30;\n        _0 = result::Result::Ok(());\n        goto -> bb71;\n    }\n    bb51: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_53);\n        goto -> bb74;\n    }\n    bb53: {\n        StorageDead(_29);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = _5;\n        _59 = move _60 as u16;\n        StorageDead(_60);\n        _61 = CheckedSub(_19, _59);\n        assert(!move (_61.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _19, move _59) -> [success: bb54, unwind unreachable];\n    }\n    bb54: {\n        _58 = move (_61.0: u16);\n        StorageDead(_59);\n        StorageLive(_62);\n        _62 = fmt::Alignment::Right;\n        _57 = fmt::Formatter::<'_>::padding(_1, move _58, move _62) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_62);\n        StorageDead(_58);\n        _56 = <result::Result<fmt::PostPadding, fmt::Error> as ops::try_trait::Try>::branch(move _57) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_57);\n        _63 = discriminant(_56);\n        switchInt(move _63) -> [0: bb57, 1: bb58, otherwise: bb22];\n    }\n    bb57: {\n        _64 = move ((_56 as variant#0).0: fmt::PostPadding);\n        StorageDead(_56);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = _6;\n        StorageLive(_68);\n        _68 = _13;\n        _66 = fmt::Formatter::<'a>::pad_integral::write_prefix(_1, move _67, move _68) -> [return: bb60, unwind unreachable];\n    }\n    bb58: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_56);\n        goto -> bb73;\n    }\n    bb60: {\n        StorageDead(_68);\n        StorageDead(_67);\n        _65 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _66) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_66);\n        _69 = discriminant(_65);\n        switchInt(move _69) -> [0: bb62, 1: bb63, otherwise: bb22];\n    }\n    bb62: {\n        StorageDead(_65);\n        StorageLive(_70);\n        StorageLive(_71);\n        _75 = ((*_1).1: &mut dyn fmt::Write);\n        _71 = <dyn fmt::Write as fmt::Write>::write_str(_75, _4) -> [return: bb65, unwind unreachable];\n    }\n    bb63: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_65);\n        goto -> bb73;\n    }\n    bb65: {\n        _70 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _71) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_71);\n        _72 = discriminant(_70);\n        switchInt(move _72) -> [0: bb67, 1: bb68, otherwise: bb22];\n    }\n    bb67: {\n        StorageDead(_70);\n        _0 = fmt::PostPadding::write(_64, _1) -> [return: bb70, unwind unreachable];\n    }\n    bb68: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        StorageDead(_70);\n        goto -> bb73;\n    }\n    bb70: {\n        goto -> bb71;\n    }\n    bb71: {\n        StorageDead(_28);\n        goto -> bb72;\n    }\n    bb72: {\n        StorageDead(_20);\n        StorageDead(_13);\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb78;\n    }\n    bb73: {\n        goto -> bb76;\n    }\n    bb74: {\n        goto -> bb75;\n    }\n    bb75: {\n        goto -> bb76;\n    }\n    bb76: {\n        StorageDead(_28);\n        goto -> bb77;\n    }\n    bb77: {\n        StorageDead(_20);\n        StorageDead(_13);\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb78;\n    }\n    bb78: {\n        return;\n    }\n}\n",
  "doc": " Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.\n\n # Arguments\n\n * is_nonnegative - whether the original integer was either positive or zero.\n * prefix - if the '#' character (Alternate) is provided, this\n   is the prefix to put in front of the number.\n * buf - the byte array that the number has been formatted into\n\n This function will correctly account for the flags provided as well as\n the minimum width. It will not take precision into account.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo { nb: i32 }\n\n impl Foo {\n     fn new(nb: i32) -> Foo {\n         Foo {\n             nb,\n         }\n     }\n }\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // We need to remove \"-\" from the number output.\n         let tmp = self.nb.abs().to_string();\n\n         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}