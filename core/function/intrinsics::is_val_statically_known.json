{
  "name": "intrinsics::is_val_statically_known",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::intrinsics::is_val_statically_known"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2548:1: 2550:2",
  "src": "pub const fn is_val_statically_known<T: Copy>(_arg: T) -> bool {\n    false\n}",
  "mir": "fn intrinsics::is_val_statically_known(_1: T) -> bool {\n    let mut _0: bool;\n    debug _arg => _1;\n    bb0: {\n        _0 = false;\n        return;\n    }\n}\n",
  "doc": " Returns whether the argument's value is statically known at\n compile-time.\n\n This is useful when there is a way of writing the code that will\n be *faster* when some variables have known values, but *slower*\n in the general case: an `if is_val_statically_known(var)` can be used\n to select between these two variants. The `if` will be optimized away\n and only the desired branch remains.\n\n Formally speaking, this function non-deterministically returns `true`\n or `false`, and the caller has to ensure sound behavior for both cases.\n In other words, the following code has *Undefined Behavior*:\n\n ```no_run\n #![feature(core_intrinsics)]\n # #![allow(internal_features)]\n use std::hint::unreachable_unchecked;\n use std::intrinsics::is_val_statically_known;\n\n if !is_val_statically_known(0) { unsafe { unreachable_unchecked(); } }\n ```\n\n This also means that the following code's behavior is unspecified; it\n may panic, or it may not:\n\n ```no_run\n #![feature(core_intrinsics)]\n # #![allow(internal_features)]\n use std::intrinsics::is_val_statically_known;\n\n assert_eq!(is_val_statically_known(0), is_val_statically_known(0));\n ```\n\n Unsafe code may not rely on `is_val_statically_known` returning any\n particular value, ever. However, the compiler will generally make it\n return `true` only if the value of the argument is actually known.\n\n # Stability concerns\n\n While it is safe to call, this intrinsic may behave differently in\n a `const` context than otherwise. See the [`const_eval_select()`]\n documentation for an explanation of the issues this can cause. Unlike\n `const_eval_select`, this intrinsic isn't guaranteed to behave\n deterministically even in a `const` context.\n\n # Type Requirements\n\n `T` must be either a `bool`, a `char`, a primitive numeric type (e.g. `f32`,\n but not `NonZeroISize`), or any thin pointer (e.g. `*mut String`).\n Any other argument types *may* cause a compiler error.\n\n ## Pointers\n\n When the input is a pointer, only the pointer itself is\n ever considered. The pointee has no effect. Currently, these functions\n behave identically:\n\n ```\n #![feature(core_intrinsics)]\n # #![allow(internal_features)]\n use std::intrinsics::is_val_statically_known;\n\n fn foo(x: &i32) -> bool {\n     is_val_statically_known(x)\n }\n\n fn bar(x: &i32) -> bool {\n     is_val_statically_known(\n         (x as *const i32).addr()\n     )\n }\n # _ = foo(&5_i32);\n # _ = bar(&5_i32);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}