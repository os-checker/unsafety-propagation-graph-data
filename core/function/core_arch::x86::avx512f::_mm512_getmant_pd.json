{
  "name": "core_arch::x86::avx512f::_mm512_getmant_pd",
  "safe": false,
  "callees": {
    "core_arch::x86::__m512d::as_f64x8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_arch::simd::f64x8": "Constructor"
      }
    },
    "core_arch::x86::avx512f::vgetmantpd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m512d": [
      "Plain"
    ],
    "core_arch::simd::f64x8": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::avx512f::_mm512_getmant_pd"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512f.rs:7357:1: 7374:2",
  "src": "pub fn _mm512_getmant_pd<const NORM: _MM_MANTISSA_NORM_ENUM, const SIGN: _MM_MANTISSA_SIGN_ENUM>(\n    a: __m512d,\n) -> __m512d {\n    unsafe {\n        static_assert_uimm_bits!(NORM, 4);\n        static_assert_uimm_bits!(SIGN, 2);\n        let a = a.as_f64x8();\n        let zero = f64x8::ZERO;\n        let r = vgetmantpd(\n            a,\n            SIGN << 2 | NORM,\n            zero,\n            0b11111111,\n            _MM_FROUND_CUR_DIRECTION,\n        );\n        transmute(r)\n    }\n}",
  "mir": "fn core_arch::x86::avx512f::_mm512_getmant_pd(_1: core_arch::x86::__m512d) -> core_arch::x86::__m512d {\n    let mut _0: core_arch::x86::__m512d;\n    let  _2: core_arch::simd::f64x8;\n    let  _3: core_arch::simd::f64x8;\n    let mut _4: i32;\n    let mut _5: i32;\n    let mut _6: u32;\n    let mut _7: bool;\n    let mut _8: core_arch::simd::f64x8;\n    debug a => _1;\n    debug a => _2;\n    debug zero => core_arch::simd::f64x8::ZERO;\n    debug r => _3;\n    bb0: {\n        _2 = core_arch::x86::__m512d::as_f64x8(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _6 = 2_i32 as u32;\n        _7 = Lt(move _6, 32_u32);\n        assert(move _7, \"attempt to shift left by `{}`, which would overflow\", 2_i32) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = Shl(SIGN, 2_i32);\n        _4 = BitOr(move _5, NORM);\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = core_arch::simd::f64x8::ZERO;\n        _3 = core_arch::x86::avx512f::vgetmantpd(_2, move _4, move _8, u8::MAX, core_arch::x86::sse41::_MM_FROUND_CUR_DIRECTION) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_4);\n        _0 = _3 as core_arch::x86::__m512d;\n        return;\n    }\n}\n",
  "doc": " Normalize the mantissas of packed double-precision (64-bit) floating-point elements in a, and store the results in dst. This intrinsic essentially calculates Â±(2^k)*|x.significand|, where k depends on the interval range defined by interv and the sign depends on sc and the source sign.\\\n The mantissa is normalized to the interval specified by interv, which can take the following values:\\\n    _MM_MANT_NORM_1_2     // interval [1, 2)\\\n    _MM_MANT_NORM_p5_2    // interval [0.5, 2)\\\n    _MM_MANT_NORM_p5_1    // interval [0.5, 1)\\\n    _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)\\\n The sign is determined by sc which can take the following values:\\\n    _MM_MANT_SIGN_src     // sign = sign(src)\\\n    _MM_MANT_SIGN_zero    // sign = 0\\\n    _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm512_getmant_pd&expand=2871)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}