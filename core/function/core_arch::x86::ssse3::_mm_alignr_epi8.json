{
  "name": "core_arch::x86::ssse3::_mm_alignr_epi8",
  "safe": false,
  "callees": {
    "core_arch::x86::sse2::_mm_setzero_si128": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a vector with all elements set to zero.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_setzero_si128)\n",
      "adt": {
        "core_arch::x86::__m128i": "Constructor"
      }
    },
    "core_arch::x86::__m128i::as_i8x16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_arch::simd::i8x16": "Constructor"
      }
    },
    "intrinsics::simd::simd_shuffle": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shuffles two vectors by const indices.\n\n `T` must be a vector.\n\n `U` must be a **const** vector of `u32`s. This means it must either refer to a named\n const or be given as an inline const expression (`const { ... }`).\n\n `V` must be a vector with the same element type as `T` and the same length as `U`.\n\n Returns a new vector such that element `i` is selected from `xy[idx[i]]`, where `xy`\n is the concatenation of `x` and `y`. It is a compile-time error if `idx[i]` is out-of-bounds\n of `xy`.\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128i": [
      "Plain",
      "Unknown([Field(0, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])"
    ],
    "core_arch::simd::i8x16": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::ssse3::_mm_alignr_epi8"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/ssse3.rs:107:1: 156:2",
  "src": "pub fn _mm_alignr_epi8<const IMM8: i32>(a: __m128i, b: __m128i) -> __m128i {\n    static_assert_uimm_bits!(IMM8, 8);\n    // If palignr is shifting the pair of vectors more than the size of two\n    // lanes, emit zero.\n    if IMM8 > 32 {\n        return _mm_setzero_si128();\n    }\n    // If palignr is shifting the pair of input vectors more than one lane,\n    // but less than two lanes, convert to shifting in zeroes.\n    let (a, b) = if IMM8 > 16 {\n        (_mm_setzero_si128(), a)\n    } else {\n        (a, b)\n    };\n    const fn mask(shift: u32, i: u32) -> u32 {\n        if shift > 32 {\n            // Unused, but needs to be a valid index.\n            i\n        } else if shift > 16 {\n            shift - 16 + i\n        } else {\n            shift + i\n        }\n    }\n    unsafe {\n        let r: i8x16 = simd_shuffle!(\n            b.as_i8x16(),\n            a.as_i8x16(),\n            [\n                mask(IMM8 as u32, 0),\n                mask(IMM8 as u32, 1),\n                mask(IMM8 as u32, 2),\n                mask(IMM8 as u32, 3),\n                mask(IMM8 as u32, 4),\n                mask(IMM8 as u32, 5),\n                mask(IMM8 as u32, 6),\n                mask(IMM8 as u32, 7),\n                mask(IMM8 as u32, 8),\n                mask(IMM8 as u32, 9),\n                mask(IMM8 as u32, 10),\n                mask(IMM8 as u32, 11),\n                mask(IMM8 as u32, 12),\n                mask(IMM8 as u32, 13),\n                mask(IMM8 as u32, 14),\n                mask(IMM8 as u32, 15),\n            ],\n        );\n        transmute(r)\n    }\n}",
  "mir": "fn core_arch::x86::ssse3::_mm_alignr_epi8(_1: core_arch::x86::__m128i, _2: core_arch::x86::__m128i) -> core_arch::x86::__m128i {\n    let mut _0: core_arch::x86::__m128i;\n    let mut _3: bool;\n    let  _4: core_arch::x86::__m128i;\n    let  _5: core_arch::x86::__m128i;\n    let mut _6: (core_arch::x86::__m128i, core_arch::x86::__m128i);\n    let mut _7: bool;\n    let mut _8: core_arch::x86::__m128i;\n    let  _9: core_arch::simd::i8x16;\n    let mut _10: core_arch::simd::i8x16;\n    let mut _11: core_arch::simd::i8x16;\n    debug a => _1;\n    debug b => _2;\n    debug a => _4;\n    debug b => _5;\n    debug r => _9;\n    bb0: {\n        StorageLive(_3);\n        _3 = Gt(IMM8, 32_i32);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = core_arch::x86::sse2::_mm_setzero_si128() -> [return: bb10, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = Gt(IMM8, 16_i32);\n        switchInt(move _7) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_8);\n        _8 = core_arch::x86::sse2::_mm_setzero_si128() -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        _6 = (_1, _2);\n        goto -> bb6;\n    }\n    bb5: {\n        _6 = (move _8, _1);\n        StorageDead(_8);\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_7);\n        _4 = (_6.0: core_arch::x86::__m128i);\n        _5 = (_6.1: core_arch::x86::__m128i);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = core_arch::x86::__m128i::as_i8x16(_5) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_11);\n        _11 = core_arch::x86::__m128i::as_i8x16(_4) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _9 = intrinsics::simd::simd_shuffle::<core_arch::simd::i8x16, core_arch::macros::SimdShuffleIdx<16>, core_arch::simd::i8x16>(move _10, move _11, core_arch::x86::ssse3::_mm_alignr_epi8::<IMM8>::{constant#1}) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _0 = _9 as core_arch::x86::__m128i;\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_3);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Concatenate 16-byte blocks in `a` and `b` into a 32-byte temporary result,\n shift the result right by `n` bytes, and returns the low 16 bytes.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_alignr_epi8)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}