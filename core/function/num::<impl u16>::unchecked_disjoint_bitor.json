{
  "name": "num::<impl u16>::unchecked_disjoint_bitor",
  "safe": false,
  "callees": {
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "num::<impl u16>::unchecked_disjoint_bitor::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "intrinsics::disjoint_bitor": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Combine two values which have no bits in common.\n\n This allows the backend to implement it as `a + b` *or* `a | b`,\n depending which is easier to implement on a specific target.\n\n # Safety\n\n Requires that `(a & b) == 0`, or equivalently that `(a | b) == (a + b)`.\n\n Otherwise it's immediate UB.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl u16>::unchecked_disjoint_bitor"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:1532:9: 1544:10",
  "src": "pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }",
  "mir": "fn num::<impl u16>::unchecked_disjoint_bitor(_1: u16, _2: u16) -> u16 {\n    let mut _0: u16;\n    let mut _3: bool;\n    let  _4: ();\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = ub_checks::check_language_ub() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        _4 = num::<impl u16>::unchecked_disjoint_bitor::precondition_check(_1, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = intrinsics::disjoint_bitor::<u16>(_1, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": " Same value as `self | other`, but UB if any bit position is set in both inputs.\n\n This is a situational micro-optimization for places where you'd rather\n use addition on some platforms and bitwise or on other platforms, based\n on exactly which instructions combine better with whatever else you're\n doing.  Note that there's no reason to bother using this for places\n where it's clear from the operations involved that they can't overlap.\n For example, if you're combining `u16`s into a `u32` with\n `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n know those sides of the `|` are disjoint without needing help.\n\n # Examples\n\n ```\n #![feature(disjoint_bitor)]\n\n // SAFETY: `1` and `4` have no bits in common.\n unsafe {\n }\n ```\n\n # Safety\n\n Requires that `(self & other) == 0`, otherwise it's immediate UB.\n\n Equivalently, requires that `(self | other) == (self + other)`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}