{
  "name": "slice::<impl [T]>::split_last_chunk_mut",
  "safe": true,
  "callees": {
    "num::<impl usize>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "slice::<impl [T]>::split_at_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_mut_checked`](slice::split_at_mut_checked).\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n let (left, right) = v.split_at_mut(2);\n assert_eq!(left, [1, 0]);\n assert_eq!(right, [3, 0, 5, 6]);\n left[1] = 2;\n right[1] = 4;\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a pointer-to-`T` to a pointer-to-`[T; N]`.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": 1317,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:477:5: 487:6",
  "src": "pub const fn split_last_chunk_mut<const N: usize>(\n        &mut self,\n    ) -> Option<(&mut [T], &mut [T; N])> {\n        let Some(index) = self.len().checked_sub(N) else { return None };\n        let (init, last) = self.split_at_mut(index);\n\n        // SAFETY: We explicitly check for the correct number of elements,\n        //   do not let the reference outlive the slice,\n        //   and enforce exclusive mutability of the chunk by the split.\n        Some((init, unsafe { &mut *(last.as_mut_ptr().cast_array()) }))\n    }",
  "mir": "fn slice::<impl [T]>::split_last_chunk_mut(_1: &mut [T]) -> option::Option<(&mut [T], &mut [T; N])> {\n    let mut _0: option::Option<(&mut [T], &mut [T; N])>;\n    let  _2: usize;\n    let mut _3: option::Option<usize>;\n    let mut _4: usize;\n    let mut _5: &[T];\n    let mut _6: isize;\n    let  _7: &mut [T];\n    let  _8: &mut [T];\n    let mut _9: (&mut [T], &mut [T]);\n    let mut _10: (&mut [T], &mut [T; N]);\n    let mut _11: &mut [T; N];\n    let mut _12: *mut [T; N];\n    let mut _13: *mut T;\n    debug self => _1;\n    debug index => _2;\n    debug init => _7;\n    debug last => _8;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _3 = num::<impl usize>::checked_sub(move _4, N) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [1: bb2, 0: bb3, otherwise: bb8];\n    }\n    bb2: {\n        _2 = ((_3 as variant#1).0: usize);\n        StorageDead(_3);\n        StorageLive(_9);\n        _9 = slice::<impl [T]>::split_at_mut(_1, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        _0 = option::Option::None;\n        goto -> bb7;\n    }\n    bb4: {\n        _7 = move (_9.0: &mut [T]);\n        _8 = move (_9.1: &mut [T]);\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = slice::<impl [T]>::as_mut_ptr(_8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = ptr::mut_ptr::<impl *mut T>::cast_array::<N>(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _11 = &mut (*_12);\n        StorageDead(_12);\n        _10 = (_7, _11);\n        _0 = option::Option::Some(move _10);\n        StorageDead(_10);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n    bb8: {\n        unreachable;\n    }\n}\n",
  "doc": " Returns a mutable array reference to the last `N` items in the slice and the remaining\n slice.\n\n If the slice is not at least `N` in length, this will return `None`.\n\n # Examples\n\n ```\n let x = &mut [0, 1, 2];\n\n if let Some((elements, last)) = x.split_last_chunk_mut::<2>() {\n     last[0] = 3;\n     last[1] = 4;\n     elements[0] = 5;\n }\n assert_eq!(x, &[5, 3, 4]);\n\n assert_eq!(None, x.split_last_chunk_mut::<4>());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}