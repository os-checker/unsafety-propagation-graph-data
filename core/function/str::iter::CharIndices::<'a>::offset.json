{
  "name": "str::iter::CharIndices::<'a>::offset",
  "safe": true,
  "callees": {},
  "adts": {
    "str::iter::CharIndices": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": 16824,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs:273:5: 275:6",
  "src": "pub fn offset(&self) -> usize {\n        self.front_offset\n    }",
  "mir": "fn str::iter::CharIndices::<'a>::offset(_1: &str::iter::CharIndices<'_>) -> usize {\n    let mut _0: usize;\n    debug self => _1;\n    bb0: {\n        _0 = ((*_1).0: usize);\n        return;\n    }\n}\n",
  "doc": " Returns the byte position of the next character, or the length\n of the underlying string if there are no more characters.\n\n This means that, when the iterator has not been fully consumed,\n the returned value will match the index that will be returned\n by the next call to [`next()`](Self::next).\n\n # Examples\n\n ```\n let mut chars = \"a楽\".char_indices();\n\n // `next()` has not been called yet, so `offset()` returns the byte\n // index of the first character of the string, which is always 0.\n assert_eq!(chars.offset(), 0);\n // As expected, the first call to `next()` also returns 0 as index.\n assert_eq!(chars.next(), Some((0, 'a')));\n\n // `next()` has been called once, so `offset()` returns the byte index\n // of the second character ...\n assert_eq!(chars.offset(), 1);\n // ... which matches the index returned by the next call to `next()`.\n assert_eq!(chars.next(), Some((1, '楽')));\n\n // Once the iterator has been consumed, `offset()` returns the length\n // in bytes of the string.\n assert_eq!(chars.offset(), 4);\n assert_eq!(chars.next(), None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}