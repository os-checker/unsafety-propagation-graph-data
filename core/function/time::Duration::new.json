{
  "name": "time::Duration::new",
  "safe": true,
  "callees": {
    "num::niche_types::Nanoseconds::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs an instance of this type from the underlying integer\n primitive without checking whether its zero.\n\n # Safety\n Immediate language UB if `val` is not within the valid range for this\n type, as it violates the validity invariant.\n",
      "adt": {
        "num::niche_types::Nanoseconds": "Constructor"
      }
    },
    "num::<impl u64>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::niche_types::Nanoseconds": [
      "Plain"
    ],
    "time::Duration": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::time::Duration::new"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:194:5: 206:6",
  "src": "pub const fn new(secs: u64, nanos: u32) -> Duration {\n        if nanos < NANOS_PER_SEC {\n            // SAFETY: nanos < NANOS_PER_SEC, therefore nanos is within the valid range\n            Duration { secs, nanos: unsafe { Nanoseconds::new_unchecked(nanos) } }\n        } else {\n            let secs = secs\n                .checked_add((nanos / NANOS_PER_SEC) as u64)\n                .expect(\"overflow in Duration::new\");\n            let nanos = nanos % NANOS_PER_SEC;\n            // SAFETY: nanos % NANOS_PER_SEC < NANOS_PER_SEC, therefore nanos is within the valid range\n            Duration { secs, nanos: unsafe { Nanoseconds::new_unchecked(nanos) } }\n        }\n    }",
  "mir": "fn time::Duration::new(_1: u64, _2: u32) -> time::Duration {\n    let mut _0: time::Duration;\n    let mut _3: bool;\n    let mut _4: num::niche_types::Nanoseconds;\n    let  _5: u64;\n    let mut _6: option::Option<u64>;\n    let mut _7: u64;\n    let mut _8: u32;\n    let mut _9: bool;\n    let mut _10: &str;\n    let  _11: u32;\n    let mut _12: bool;\n    let mut _13: num::niche_types::Nanoseconds;\n    debug secs => _1;\n    debug nanos => _2;\n    debug secs => _5;\n    debug nanos => _11;\n    bb0: {\n        StorageLive(_3);\n        _3 = Lt(_2, time::NANOS_PER_SEC);\n        switchInt(move _3) -> [0: bb3, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = num::niche_types::Nanoseconds::new_unchecked(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = Duration(_1, move _4);\n        StorageDead(_4);\n        goto -> bb9;\n    }\n    bb3: {\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _9 = Eq(time::NANOS_PER_SEC, 0_u32);\n        assert(!move _9, \"attempt to divide `{}` by zero\", _2) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = Div(_2, time::NANOS_PER_SEC);\n        _7 = move _8 as u64;\n        StorageDead(_8);\n        _6 = num::<impl u64>::checked_add(_1, move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageLive(_10);\n        _10 = \"overflow in Duration::new\";\n        _5 = option::Option::<u64>::expect(move _6, move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_6);\n        _12 = Eq(time::NANOS_PER_SEC, 0_u32);\n        assert(!move _12, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _2) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = Rem(_2, time::NANOS_PER_SEC);\n        StorageLive(_13);\n        _13 = num::niche_types::Nanoseconds::new_unchecked(_11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _0 = Duration(_5, move _13);\n        StorageDead(_13);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Creates a new `Duration` from the specified number of whole seconds and\n additional nanoseconds.\n\n If the number of nanoseconds is greater than 1 billion (the number of\n nanoseconds in a second), then it will carry over into the seconds provided.\n\n # Panics\n\n This constructor will panic if the carry from the nanoseconds overflows\n the seconds counter.\n\n # Examples\n\n ```\n use std::time::Duration;\n\n let five_seconds = Duration::new(5, 0);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}