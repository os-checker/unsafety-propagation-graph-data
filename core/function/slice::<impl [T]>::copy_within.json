{
  "name": "slice::<impl [T]>::copy_within",
  "safe": true,
  "callees": {
    "slice::index::range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs bounds checking of a range.\n\n This method is similar to [`Index::index`] for slices, but it returns a\n [`Range`] equivalent to `range`. You can use this method to turn any range\n into `start` and `end` values.\n\n `bounds` is the range of the slice to use for bounds checking. It should\n be a [`RangeTo`] range that ends at the length of the slice.\n\n The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and\n [`slice::get_unchecked_mut`] for slices with the given range.\n\n [`Range`]: ops::Range\n [`RangeTo`]: ops::RangeTo\n [`slice::get_unchecked`]: slice::get_unchecked\n [`slice::get_unchecked_mut`]: slice::get_unchecked_mut\n\n # Panics\n\n Panics if `range` would be out of bounds.\n\n # Examples\n\n ```\n #![feature(slice_range)]\n\n use std::slice;\n\n let v = [10, 40, 30];\n assert_eq!(1..2, slice::range(1..2, ..v.len()));\n assert_eq!(0..2, slice::range(..2, ..v.len()));\n assert_eq!(1..3, slice::range(1.., ..v.len()));\n ```\n\n Panics when [`Index::index`] would panic:\n\n ```should_panic\n #![feature(slice_range)]\n\n use std::slice;\n\n let _ = slice::range(2..1, ..3);\n ```\n\n ```should_panic\n #![feature(slice_range)]\n\n use std::slice;\n\n let _ = slice::range(1..4, ..3);\n ```\n\n ```should_panic\n #![feature(slice_range)]\n\n use std::slice;\n\n let _ = slice::range(1..=usize::MAX, ..3);\n ```\n\n [`Index::index`]: ops::Index::index\n",
      "adt": {
        "ops::range::Range": "Constructor"
      }
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ptr::copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination may overlap.\n\n If the source and destination will *never* overlap,\n [`copy_nonoverlapping`] can be used instead.\n\n `copy` is semantically equivalent to C's [`memmove`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n Copying takes place as if the bytes were copied from `src`\n to a temporary array and then copied from the array to `dst`.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memmove`]: https://en.cppreference.com/w/c/string/byte/memmove\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes, and must remain valid even\n   when `src` is read for `count * size_of::<T>()` bytes. (This means if the memory ranges\n   overlap, the `dst` pointer must not be invalidated by `src` reads.)\n\n * Both `src` and `dst` must be properly aligned.\n\n Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Efficiently create a Rust vector from an unsafe buffer:\n\n ```\n use std::ptr;\n\n /// # Safety\n ///\n /// * `ptr` must be correctly aligned for its type and non-zero.\n /// * `ptr` must be valid for reads of `elts` contiguous elements of type `T`.\n /// * Those elements must not be used after calling this function unless `T: Copy`.\n # #[allow(dead_code)]\n unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     let mut dst = Vec::with_capacity(elts);\n\n     // SAFETY: Our precondition ensures the source is aligned and valid,\n     // and `Vec::with_capacity` ensures that we have usable space to write them.\n     unsafe { ptr::copy(ptr, dst.as_mut_ptr(), elts); }\n\n     // SAFETY: We created it with this much capacity earlier,\n     // and the previous `copy` has initialized these elements.\n     unsafe { dst.set_len(elts); }\n     dst\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::RangeTo": [
      "Plain"
    ],
    "ops::range::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 1254,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3924:5: 3940:6",
  "src": "pub fn copy_within<R: RangeBounds<usize>>(&mut self, src: R, dest: usize)\n    where\n        T: Copy,\n    {\n        let Range { start: src_start, end: src_end } = slice::range(src, ..self.len());\n        let count = src_end - src_start;\n        assert!(dest <= self.len() - count, \"dest is out of bounds\");\n        // SAFETY: the conditions for `ptr::copy` have all been checked above,\n        // as have those for `ptr::add`.\n        unsafe {\n            // Derive both `src_ptr` and `dest_ptr` from the same loan\n            let ptr = self.as_mut_ptr();\n            let src_ptr = ptr.add(src_start);\n            let dest_ptr = ptr.add(dest);\n            ptr::copy(src_ptr, dest_ptr, count);\n        }\n    }",
  "mir": "fn slice::<impl [T]>::copy_within(_1: &mut [T], _2: R, _3: usize) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let  _5: usize;\n    let mut _6: ops::range::Range<usize>;\n    let mut _7: ops::range::RangeTo<usize>;\n    let mut _8: usize;\n    let mut _9: &[T];\n    let  _10: usize;\n    let mut _11: (usize, bool);\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: &[T];\n    let mut _16: (usize, bool);\n    let  _17: !;\n    let mut _18: fmt::Arguments<'_>;\n    let  _19: *mut T;\n    let  _20: *mut T;\n    let  _21: *mut T;\n    let  _22: ();\n    let mut _23: *const T;\n    debug self => _1;\n    debug src => _2;\n    debug dest => _3;\n    debug src_start => _4;\n    debug src_end => _5;\n    debug count => _10;\n    debug ptr => _19;\n    debug src_ptr => _20;\n    debug dest_ptr => _21;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_1);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        _7 = RangeTo(move _8);\n        StorageDead(_8);\n        _6 = slice::index::range::<R>(_2, move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _4 = (_6.0: usize);\n        _5 = (_6.1: usize);\n        StorageDead(_6);\n        _11 = CheckedSub(_5, _4);\n        assert(!move (_11.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _4) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _10 = move (_11.0: usize);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = PtrMetadata(move _15);\n        StorageDead(_15);\n        _16 = CheckedSub(_14, _10);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _14, _10) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _13 = move (_16.0: usize);\n        StorageDead(_14);\n        _12 = Le(_3, move _13);\n        switchInt(move _12) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _19 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        StorageLive(_18);\n        _18 = fmt::Arguments::<'_>::from_str(\"dest is out of bounds\") -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _17 = panicking::panic_fmt(move _18) -> unwind unreachable;\n    }\n    bb7: {\n        _20 = ptr::mut_ptr::<impl *mut T>::add(_19, _4) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _21 = ptr::mut_ptr::<impl *mut T>::add(_19, _3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_23);\n        _23 = _20 as *const T;\n        _22 = ptr::copy::<T>(move _23, _21, _10) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_23);\n        return;\n    }\n}\n",
  "doc": " Copies elements from one part of the slice to another part of itself,\n using a memmove.\n\n `src` is the range within `self` to copy from. `dest` is the starting\n index of the range within `self` to copy to, which will have the same\n length as `src`. The two ranges may overlap. The ends of the two ranges\n must be less than or equal to `self.len()`.\n\n # Panics\n\n This function will panic if either range exceeds the end of the slice,\n or if the end of `src` is before the start.\n\n # Examples\n\n Copying four bytes within a slice:\n\n ```\n let mut bytes = *b\"Hello, World!\";\n\n bytes.copy_within(1..5, 8);\n\n assert_eq!(&bytes, b\"Hello, Wello!\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}