{
  "name": "iter::traits::iterator::Iterator::is_sorted_by_key",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {
        "iter::adapters::map::Map": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::is_sorted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks if the elements of this iterator are sorted.\n\n That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n iterator yields exactly zero or one element, `true` is returned.\n\n Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n implies that this function returns `false` if any two consecutive items are not\n comparable.\n\n # Examples\n\n ```\n assert!([1, 2, 2, 9].iter().is_sorted());\n assert!(![1, 3, 2, 4].iter().is_sorted());\n assert!([0].iter().is_sorted());\n assert!(std::iter::empty::<i32>().is_sorted());\n assert!(![0.0, 1.0, f32::NAN].iter().is_sorted());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::map::Map": [
      "Plain"
    ]
  },
  "path": {
    "type": "External",
    "path": "iter::traits::iterator::Iterator::is_sorted_by_key"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:4016:5: 4023:6",
  "src": "fn is_sorted_by_key<F, K>(self, f: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> K,\n        K: PartialOrd,\n    {\n        self.map(f).is_sorted()\n    }",
  "mir": "fn iter::traits::iterator::Iterator::is_sorted_by_key(_1: Self, _2: F) -> bool {\n    let mut _0: bool;\n    let mut _3: iter::adapters::map::Map<Self, F>;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = <Self as iter::traits::iterator::Iterator>::map::<K, F>(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = <iter::adapters::map::Map<Self, F> as iter::traits::iterator::Iterator>::is_sorted(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Checks if the elements of this iterator are sorted using the given key extraction\n function.\n\n Instead of comparing the iterator's elements directly, this function compares the keys of\n the elements, as determined by `f`. Apart from that, it's equivalent to [`is_sorted`]; see\n its documentation for more information.\n\n [`is_sorted`]: Iterator::is_sorted\n\n # Examples\n\n ```\n assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\n assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}