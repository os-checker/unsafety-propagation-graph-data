{
  "name": "<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByBackImpl<I>>::spec_rfold",
  "safe": true,
  "callees": {
    "iter::traits::double_ended::DoubleEndedIterator::next_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes and returns an element from the end of the iterator.\n\n Returns `None` when there are no more elements.\n\n The [trait-level] docs contain more details.\n\n [trait-level]: DoubleEndedIterator\n\n # Examples\n\n Basic usage:\n\n ```\n let numbers = vec![1, 2, 3, 4, 5, 6];\n\n let mut iter = numbers.iter();\n\n assert_eq!(Some(&1), iter.next());\n assert_eq!(Some(&6), iter.next_back());\n assert_eq!(Some(&5), iter.next_back());\n assert_eq!(Some(&2), iter.next());\n assert_eq!(Some(&3), iter.next());\n assert_eq!(Some(&4), iter.next());\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next_back());\n ```\n\n # Remarks\n\n The elements yielded by `DoubleEndedIterator`'s methods may differ from\n the ones yielded by [`Iterator`]'s methods:\n\n ```\n let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];\n let uniq_by_fst_comp = || {\n     let mut seen = std::collections::HashSet::new();\n     vec.iter().copied().filter(move |x| seen.insert(x.0))\n };\n\n assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));\n assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));\n\n assert_eq!(\n     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(1, 'a'), (2, 'a')]\n );\n assert_eq!(\n     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(2, 'b'), (1, 'c')]\n );\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByBackImpl<I>>::spec_rfold::nth_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "iter::sources::from_fn::from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator with the provided closure\n `F: FnMut() -> Option<T>` as its [`next`](Iterator::next) method.\n\n The iterator will yield the `T`s returned from the closure.\n\n This allows creating a custom iterator with any behavior\n without using the more verbose syntax of creating a dedicated type\n and implementing the [`Iterator`] trait for it.\n\n Note that the `FromFn` iterator doesn’t make assumptions about the behavior of the closure,\n and therefore conservatively does not implement [`FusedIterator`],\n or override [`Iterator::size_hint()`] from its default `(0, None)`.\n\n The closure can use captures and its environment to track state across iterations. Depending on\n how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n\n [`move`]: ../../std/keyword.move.html\n [`FusedIterator`]: crate::iter::FusedIterator\n\n # Examples\n\n Let’s re-implement the counter iterator from [module-level documentation]:\n\n [module-level documentation]: crate::iter\n\n ```\n let mut count = 0;\n let counter = std::iter::from_fn(move || {\n     // Increment our count. This is why we started at zero.\n     count += 1;\n\n     // Check to see if we've finished counting or not.\n     if count < 6 {\n         Some(count)\n     } else {\n         None\n     }\n });\n assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n ```\n",
      "adt": {
        "iter::sources::from_fn::FromFn": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Folds every element into an accumulator by applying an operation,\n returning the final result.\n\n `fold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `fold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `fold()`, and similar methods that traverse the entire iterator,\n might not terminate for infinite iterators, even on traits for which a\n result is determinable in finite time.\n\n Note: [`reduce()`] can be used to use the first element as the initial\n value, if the accumulator type and item type is the same.\n\n Note: `fold()` combines elements in a *left-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `fold()` on the internal parts\n from which this iterator is composed.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of the array\n let sum = a.iter().fold(0, |acc, x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n Let's walk through each step of the iteration here:\n\n | element | acc | x | result |\n |---------|-----|---|--------|\n |         | 0   |   |        |\n | 1       | 0   | 1 | 1      |\n | 2       | 1   | 2 | 3      |\n | 3       | 3   | 3 | 6      |\n\n And so, our final result, `6`.\n\n This example demonstrates the left-associative nature of `fold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the front until the back:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().fold(zero, |acc, &x| {\n     format!(\"({acc} + {x})\")\n });\n\n assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n ```\n It's common for people who haven't used iterators a lot to\n use a `for` loop with a list of things to build up a result. Those\n can be turned into `fold()`s:\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let mut result = 0;\n\n // for loop:\n for i in &numbers {\n     result = result + i;\n }\n\n // fold:\n let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n // they're the same\n assert_eq!(result, result2);\n ```\n\n [`reduce()`]: Iterator::reduce\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::step_by::StepBy": [
      "MutRef",
      "Plain",
      "Unknown([Field(0, Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })])",
      "Unknown([Field(1, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4671, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25924, name: \"iter::traits::iterator::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })]) }) })])"
    ],
    "iter::sources::from_fn::FromFn": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByBackImpl<I>>::spec_rfold"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:383:5: 403:6",
  "src": "default fn spec_rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n    where\n        Self: Sized,\n        F: FnMut(Acc, I::Item) -> Acc,\n    {\n        #[inline]\n        fn nth_back<I: DoubleEndedIterator>(\n            iter: &mut I,\n            step_minus_one: usize,\n        ) -> impl FnMut() -> Option<I::Item> + '_ {\n            move || iter.nth_back(step_minus_one)\n        }\n\n        match self.next_back() {\n            None => init,\n            Some(x) => {\n                let acc = f(init, x);\n                from_fn(nth_back(&mut self.iter, self.step_minus_one)).fold(acc, f)\n            }\n        }\n    }",
  "mir": "fn <iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByBackImpl<I>>::spec_rfold(_1: iter::adapters::step_by::StepBy<I>, _2: Acc, _3: F) -> Acc {\n    let mut _0: Acc;\n    let mut _4: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _5: &mut iter::adapters::step_by::StepBy<I>;\n    let mut _6: isize;\n    let  _7: <I as iter::traits::iterator::Iterator>::Item;\n    let  _8: Acc;\n    let mut _9: &mut F;\n    let mut _10: (Acc, <I as iter::traits::iterator::Iterator>::Item);\n    let mut _11: iter::sources::from_fn::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:393:13: 393:20}>;\n    let mut _12: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:393:13: 393:20};\n    let mut _13: &mut I;\n    let mut _14: usize;\n    let mut _15: F;\n    let mut _16: bool;\n    debug self => _1;\n    debug init => _2;\n    debug f => _3;\n    debug x => _7;\n    debug acc => _8;\n    bb0: {\n        _16 = false;\n        _16 = true;\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _1;\n        _4 = <iter::adapters::step_by::StepBy<I> as iter::traits::double_ended::DoubleEndedIterator>::next_back(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _7 = move ((_4 as variant#1).0: <I as iter::traits::iterator::Iterator>::Item);\n        StorageLive(_9);\n        _9 = &mut _3;\n        StorageLive(_10);\n        _10 = (_2, _7);\n        _8 = <F as ops::function::FnMut<(Acc, <I as iter::traits::iterator::Iterator>::Item)>>::call_mut(move _9, move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        _0 = _2;\n        goto -> bb9;\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _13 = &mut (_1.0: I);\n        StorageLive(_14);\n        _14 = (_1.1: usize);\n        _12 = <iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByBackImpl<I>>::spec_rfold::nth_back::<I>(_13, move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _11 = iter::sources::from_fn::from_fn::<<I as iter::traits::iterator::Iterator>::Item, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:393:13: 393:20}>(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageLive(_15);\n        _16 = false;\n        _15 = move _3;\n        _0 = <iter::sources::from_fn::FromFn<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:393:13: 393:20}> as iter::traits::iterator::Iterator>::fold::<Acc, F>(move _11, _8, move _15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        StorageDead(_11);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_4);\n        switchInt(_16) -> [0: bb10, otherwise: bb12];\n    }\n    bb10: {\n        drop(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        return;\n    }\n    bb12: {\n        drop(_3) -> [return: bb10, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}