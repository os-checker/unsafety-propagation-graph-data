{
  "name": "num::wrapping::Wrapping::<i64>::abs",
  "safe": true,
  "callees": {
    "num::<impl i64>::wrapping_abs": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n the boundary of the type.\n\n The only case where such wrapping can occur is when one takes the absolute value of the negative\n minimal value for the type; this is a positive value that is too large to represent in the type. In\n such a case, this function returns `MIN` itself.\n\n # Examples\n\n ```\n assert_eq!((-128i8).wrapping_abs() as u8, 128);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "num::wrapping::Wrapping": [
      "Unknown([Field(0, Ty { id: 369, kind: RigidTy(Int(I64)) })])",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::wrapping::Wrapping::<i64>::abs"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/wrapping.rs:991:13: 993:14",
  "src": "pub fn abs(self) -> Wrapping<$t> {\n                Wrapping(self.0.wrapping_abs())\n            }",
  "mir": "fn num::wrapping::Wrapping::<i64>::abs(_1: num::wrapping::Wrapping<i64>) -> num::wrapping::Wrapping<i64> {\n    let mut _0: num::wrapping::Wrapping<i64>;\n    let mut _2: i64;\n    let mut _3: i64;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = (_1.0: i64);\n        _2 = num::<impl i64>::wrapping_abs(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = Wrapping(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Computes the absolute value of `self`, wrapping around at\n the boundary of the type.\n\n The only case where such wrapping can occur is when one takes the absolute value of the negative\n minimal value for the type this is a positive value that is too large to represent in the type. In\n such a case, this function returns `MIN` itself.\n\n # Examples\n\n Basic usage:\n\n ```\n #![feature(wrapping_int_impl)]\n use std::num::Wrapping;\n\n assert_eq!(Wrapping(-128i8).abs().0 as u8, 128u8);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}