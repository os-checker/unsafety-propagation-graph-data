{
  "name": "fmt::Write::write_char",
  "safe": true,
  "callees": {
    "char::methods::<impl char>::encode_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Encodes this character as UTF-8 into the provided byte buffer,\n and then returns the subslice of the buffer that contains the encoded character.\n\n # Panics\n\n Panics if the buffer is not large enough.\n A buffer of length four is large enough to encode any `char`.\n\n # Examples\n\n In both of these examples, 'ß' takes two bytes to encode.\n\n ```\n let mut b = [0; 2];\n\n let result = 'ß'.encode_utf8(&mut b);\n\n assert_eq!(result, \"ß\");\n\n assert_eq!(result.len(), 2);\n ```\n\n A buffer that's too small:\n\n ```should_panic\n let mut b = [0; 1];\n\n // this panics\n 'ß'.encode_utf8(&mut b);\n ```\n",
      "adt": {}
    },
    "fmt::Write::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a string slice into this writer, returning whether the write\n succeeded.\n\n This method can only succeed if the entire string slice was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`std::fmt::Error`][Error] on error.\n\n The purpose of that error is to abort the formatting operation when the underlying\n destination encounters some error preventing it from accepting more text;\n in particular, it does not communicate any information about *what* error occurred.\n It should generally be propagated rather than handled, at least when implementing\n formatting traits.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n     f.write_str(s)\n }\n\n let mut buf = String::new();\n writer(&mut buf, \"hola\")?;\n assert_eq!(&buf, \"hola\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "External",
    "path": "fmt::Write::write_char"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:183:5: 185:6",
  "src": "fn write_char(&mut self, c: char) -> Result {\n        self.write_str(c.encode_utf8(&mut [0; char::MAX_LEN_UTF8]))\n    }",
  "mir": "fn fmt::Write::write_char(_1: &mut Self, _2: char) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: &str;\n    let  _4: &mut str;\n    let mut _5: &mut [u8];\n    let mut _6: &mut [u8; 4];\n    let mut _7: [u8; 4];\n    debug self => _1;\n    debug c => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = [0_u8; 4];\n        _6 = &mut _7;\n        _5 = _6 as &mut [u8];\n        _4 = char::methods::<impl char>::encode_utf8(_2, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &(*_4);\n        StorageDead(_5);\n        _0 = <Self as fmt::Write>::write_str(_1, move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}