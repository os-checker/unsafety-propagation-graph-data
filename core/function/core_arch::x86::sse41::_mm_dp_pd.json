{
  "name": "core_arch::x86::sse41::_mm_dp_pd",
  "safe": false,
  "callees": {
    "core_arch::x86::sse41::dppd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128d": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::sse41::_mm_dp_pd"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/sse41.rs:655:1: 660:2",
  "src": "pub fn _mm_dp_pd<const IMM8: i32>(a: __m128d, b: __m128d) -> __m128d {\n    unsafe {\n        static_assert_uimm_bits!(IMM8, 8);\n        dppd(a, b, IMM8 as u8)\n    }\n}",
  "mir": "fn core_arch::x86::sse41::_mm_dp_pd(_1: core_arch::x86::__m128d, _2: core_arch::x86::__m128d) -> core_arch::x86::__m128d {\n    let mut _0: core_arch::x86::__m128d;\n    let mut _3: u8;\n    debug a => _1;\n    debug b => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = IMM8 as u8;\n        _0 = core_arch::x86::sse41::dppd(_1, _2, move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns the dot product of two __m128d vectors.\n\n `IMM8[1:0]` is the broadcast mask, and `IMM8[5:4]` is the condition mask.\n If a condition mask bit is zero, the corresponding multiplication is\n replaced by a value of `0.0`. If a broadcast mask bit is one, the result of\n the dot product will be stored in the return value component. Otherwise if\n the broadcast mask bit is zero then the return component will be zero.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_dp_pd)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}