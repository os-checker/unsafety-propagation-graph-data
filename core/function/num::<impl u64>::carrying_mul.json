{
  "name": "num::<impl u64>::carrying_mul",
  "safe": true,
  "callees": {
    "num::<impl u64>::carrying_mul_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the \"full multiplication\" `self * rhs + carry + add`.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order.\n\n This cannot overflow, as the double-width result has exactly enough\n space for the largest possible result. This is equivalent to how, in\n decimal, 9 × 9 + 9 + 9 = 81 + 18 = 99 = 9×10⁰ + 9×10¹ = 10² - 1.\n\n Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n additional amount of overflow. This allows for chaining together multiple\n multiplications to create \"big integers\" which represent larger values.\n\n If you don't need the `add` part, then you can use [`Self::carrying_mul`] instead.\n\n # Examples\n\n Please note that this example is shared between integer types,\n which explains why `u32` is used here.\n\n ```\n assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n ```\n\n This is the core per-digit operation for \"grade school\" O(n²) multiplication.\n\n Please note that this example is shared between integer types,\n using `u8` for simplicity of the demonstration.\n\n ```\n fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n     let mut out = [0; N];\n     for j in 0..N {\n         let mut carry = 0;\n         for i in 0..(N - j) {\n             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n         }\n     }\n     out\n }\n\n // -1 * -1 == 1\n assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n\n assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xcffc982d);\n assert_eq!(\n     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n     u32::to_le_bytes(0xcffc982d)\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl u64>::carrying_mul"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:3077:9: 3079:10",
  "src": "pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }",
  "mir": "fn num::<impl u64>::carrying_mul(_1: u64, _2: u64, _3: u64) -> (u64, u64) {\n    let mut _0: (u64, u64);\n    debug self => _1;\n    debug rhs => _2;\n    debug carry => _3;\n    bb0: {\n        _0 = num::<impl u64>::carrying_mul_add(_1, _2, _3, 0_u64) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Calculates the \"full multiplication\" `self * rhs + carry`\n without the possibility to overflow.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order.\n\n Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n additional amount of overflow. This allows for chaining together multiple\n multiplications to create \"big integers\" which represent larger values.\n\n If you also need to add a value, then use [`Self::carrying_mul_add`].\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u32` is used.\n\n ```\n assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n ```\n\n This is the core operation needed for scalar multiplication when\n implementing it for wider-than-native types.\n\n ```\n #![feature(bigint_helper_methods)]\n fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n     let mut carry = 0;\n     for d in little_endian_digits.iter_mut() {\n         (*d, carry) = d.carrying_mul(multiplicand, carry);\n     }\n     if carry != 0 {\n         little_endian_digits.push(carry);\n     }\n }\n\n let mut v = vec![10, 20];\n scalar_mul_eq(&mut v, 3);\n assert_eq!(v, [30, 60]);\n\n assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n let mut v = vec![0x4321, 0x8765];\n scalar_mul_eq(&mut v, 0xFEED);\n assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n ```\n\n If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n except that it gives the value of the overflow instead of just whether one happened:\n\n ```\n #![feature(bigint_helper_methods)]\n let r = u8::carrying_mul(7, 13, 0);\n assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n let r = u8::carrying_mul(13, 42, 0);\n assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n ```\n\n The value of the first field in the returned tuple matches what you'd get\n by combining the [`wrapping_mul`](Self::wrapping_mul) and\n [`wrapping_add`](Self::wrapping_add) methods:\n\n ```\n #![feature(bigint_helper_methods)]\n assert_eq!(\n     789_u16.carrying_mul(456, 123).0,\n     789_u16.wrapping_mul(456).wrapping_add(123),\n );\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}