{
  "name": "num::flt2dec::to_exact_fixed_str",
  "safe": true,
  "callees": {
    "num::flt2dec::decoder::decode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "Constructor"
      }
    },
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::flt2dec::determine_sign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the static byte string corresponding to the sign to be formatted.\n It can be either `\"\"`, `\"+\"` or `\"-\"`.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "MutableAsArgument"
      }
    },
    "num::flt2dec::estimate_max_buf_len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a rather crude approximation (upper bound) for the maximum buffer size\n calculated from the given decoded exponent.\n\n The exact limit is:\n\n - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n\n `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n enough for our purposes.\n\n Why do we need this? `format_exact` functions will fill the entire buffer\n unless limited by the last digit restriction, but it is possible that\n the number of digits requested is ridiculously large (say, 30,000 digits).\n The vast majority of buffer will be filled with zeroes, so we don't want to\n allocate all the buffer beforehand. Consequently, for any given arguments,\n 826 bytes of buffer should be sufficient for `f64`. Compare this with\n the actual number for the worst case: 770 bytes (when `exp = -1074`).\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "num::flt2dec::digits_to_dec_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n with at least given number of fractional digits. The result is stored to\n the supplied parts array and a slice of written parts is returned.\n\n `frac_digits` can be less than the number of actual fractional digits in `buf`;\n it will be ignored and full digits will be printed. It is only used to print\n additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n it will only print given digits and nothing else.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::flt2dec::decoder::FullDecoded": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3, kind: RigidTy(Bool) })])",
      "Unknown([Field(1, Ty { id: 759, kind: RigidTy(Adt(AdtDef(DefId { id: 24675, name: \"num::flt2dec::decoder::FullDecoded\" }), GenericArgs([]))) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(3, ThreadLocalIndex)), Field(0, Ty { id: 760, kind: RigidTy(Adt(AdtDef(DefId { id: 24674, name: \"num::flt2dec::decoder::Decoded\" }), GenericArgs([]))) })])"
    ],
    "num::flt2dec::Sign": [
      "Plain"
    ],
    "num::flt2dec::decoder::Decoded": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "num::fmt::Part": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "num::fmt::Formatted": [
      "Plain"
    ],
    "panicking::AssertKind": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::to_exact_fixed_str"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/mod.rs:586:1: 668:2",
  "src": "pub fn to_exact_fixed_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 4);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            if frac_digits > 0 {\n                // [0.][0000]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..2`.\n                    parts: unsafe { parts[..2].assume_init_ref() },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { parts[..1].assume_init_ref() },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let maxlen = estimate_max_buf_len(decoded.exp);\n            assert!(buf.len() >= maxlen);\n\n            // it *is* possible that `frac_digits` is ridiculously large.\n            // `format_exact` will end rendering digits much earlier in this case,\n            // because we are strictly limited by `maxlen`.\n            let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n            let (buf, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n            if exp <= limit {\n                // the restriction couldn't been met, so this should render like zero no matter\n                // `exp` was. this does not include the case that the restriction has been met\n                // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                debug_assert_eq!(buf.len(), 0);\n                if frac_digits > 0 {\n                    // [0.][0000]\n                    parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                    parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                    Formatted {\n                        sign,\n                        // SAFETY: we just initialized the elements `..2`.\n                        parts: unsafe { parts[..2].assume_init_ref() },\n                    }\n                } else {\n                    parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                    Formatted {\n                        sign,\n                        // SAFETY: we just initialized the elements `..1`.\n                        parts: unsafe { parts[..1].assume_init_ref() },\n                    }\n                }\n            } else {\n                Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n            }\n        }\n    }\n}",
  "mir": "fn num::flt2dec::to_exact_fixed_str(_1: F, _2: T, _3: num::flt2dec::Sign, _4: usize, _5: &mut [mem::maybe_uninit::MaybeUninit<u8>], _6: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]) -> num::fmt::Formatted<'_> {\n    let mut _0: num::fmt::Formatted<'_>;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _10: !;\n    let  _11: bool;\n    let  _12: num::flt2dec::decoder::FullDecoded;\n    let mut _13: (bool, num::flt2dec::decoder::FullDecoded);\n    let  _14: &str;\n    let  _15: &num::flt2dec::decoder::FullDecoded;\n    let mut _16: isize;\n    let mut _17: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _18: num::fmt::Part<'_>;\n    let mut _19: &[u8];\n    let mut _20: &[u8; 3];\n    let  _21: usize;\n    let mut _22: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _23: usize;\n    let mut _24: bool;\n    let  _25: &[num::fmt::Part<'_>];\n    let  _26: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _27: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _28: ops::range::RangeTo<usize>;\n    let mut _29: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _30: num::fmt::Part<'_>;\n    let mut _31: &[u8];\n    let mut _32: &[u8; 3];\n    let  _33: usize;\n    let mut _34: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _35: usize;\n    let mut _36: bool;\n    let  _37: &[num::fmt::Part<'_>];\n    let  _38: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _39: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _40: ops::range::RangeTo<usize>;\n    let mut _41: bool;\n    let mut _42: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _43: num::fmt::Part<'_>;\n    let mut _44: &[u8];\n    let mut _45: &[u8; 2];\n    let  _46: usize;\n    let mut _47: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _48: usize;\n    let mut _49: bool;\n    let mut _50: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _51: num::fmt::Part<'_>;\n    let  _52: usize;\n    let mut _53: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _54: usize;\n    let mut _55: bool;\n    let  _56: &[num::fmt::Part<'_>];\n    let  _57: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _58: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _59: ops::range::RangeTo<usize>;\n    let mut _60: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _61: num::fmt::Part<'_>;\n    let mut _62: &[u8];\n    let mut _63: &[u8; 1];\n    let  _64: usize;\n    let mut _65: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _66: usize;\n    let mut _67: bool;\n    let  _68: &[num::fmt::Part<'_>];\n    let  _69: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _70: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _71: ops::range::RangeTo<usize>;\n    let  _72: &num::flt2dec::decoder::Decoded;\n    let  _73: usize;\n    let mut _74: i16;\n    let mut _75: bool;\n    let mut _76: usize;\n    let mut _77: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _78: !;\n    let  _79: i16;\n    let mut _80: bool;\n    let mut _81: i16;\n    let mut _82: bool;\n    let  _83: &[u8];\n    let  _84: i16;\n    let mut _85: (&[u8], i16);\n    let mut _86: &mut F;\n    let mut _87: (&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>], i16);\n    let mut _88: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _89: ops::range::RangeTo<usize>;\n    let mut _90: i16;\n    let mut _91: bool;\n    let mut _92: i16;\n    let mut _93: (&usize, &usize);\n    let mut _94: &usize;\n    let  _95: usize;\n    let mut _96: &usize;\n    let  _97: &usize;\n    let  _98: &usize;\n    let mut _99: bool;\n    let mut _100: usize;\n    let mut _101: usize;\n    let  _102: panicking::AssertKind;\n    let  _103: !;\n    let mut _104: option::Option<fmt::Arguments<'_>>;\n    let mut _105: bool;\n    let mut _106: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _107: num::fmt::Part<'_>;\n    let mut _108: &[u8];\n    let mut _109: &[u8; 2];\n    let  _110: usize;\n    let mut _111: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _112: usize;\n    let mut _113: bool;\n    let mut _114: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _115: num::fmt::Part<'_>;\n    let  _116: usize;\n    let mut _117: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _118: usize;\n    let mut _119: bool;\n    let  _120: &[num::fmt::Part<'_>];\n    let  _121: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _122: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _123: ops::range::RangeTo<usize>;\n    let mut _124: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _125: num::fmt::Part<'_>;\n    let mut _126: &[u8];\n    let mut _127: &[u8; 1];\n    let  _128: usize;\n    let mut _129: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _130: usize;\n    let mut _131: bool;\n    let  _132: &[num::fmt::Part<'_>];\n    let  _133: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _134: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _135: ops::range::RangeTo<usize>;\n    let  _136: &[num::fmt::Part<'_>];\n    debug format_exact => _1;\n    debug v => _2;\n    debug sign => _3;\n    debug frac_digits => _4;\n    debug buf => _5;\n    debug parts => _6;\n    debug negative => _11;\n    debug full_decoded => _12;\n    debug sign => _14;\n    debug decoded => _72;\n    debug maxlen => _73;\n    debug limit => _79;\n    debug buf => _83;\n    debug exp => _84;\n    debug left_val => _97;\n    debug right_val => _98;\n    debug kind => _102;\n    bb0: {\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_6);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        _7 = Ge(move _8, 4_usize);\n        switchInt(move _7) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_13);\n        _13 = num::flt2dec::decoder::decode::<T>(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _10 = panicking::panic(\"assertion failed: parts.len() >= 4\") -> unwind unreachable;\n    }\n    bb3: {\n        _11 = (_13.0: bool);\n        StorageLive(_12);\n        _12 = (_13.1: num::flt2dec::decoder::FullDecoded);\n        StorageDead(_13);\n        _15 = &_12;\n        _14 = num::flt2dec::determine_sign(_3, _15, _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _16 = discriminant(_12);\n        switchInt(move _16) -> [0: bb9, 1: bb8, 2: bb7, 3: bb6, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _72 = &((_12 as variant#3).0: num::flt2dec::decoder::Decoded);\n        StorageLive(_74);\n        _74 = ((*_72).3: i16);\n        _73 = num::flt2dec::estimate_max_buf_len(move _74) -> [return: bb31, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_41);\n        _41 = Gt(_4, 0_usize);\n        switchInt(move _41) -> [0: bb25, otherwise: bb18];\n    }\n    bb8: {\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = b\"inf\";\n        _31 = move _32 as &[u8];\n        StorageDead(_32);\n        _30 = num::fmt::Part::Copy(move _31);\n        StorageDead(_31);\n        _29 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _30) -> [return: bb14, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = b\"NaN\";\n        _19 = move _20 as &[u8];\n        StorageDead(_20);\n        _18 = num::fmt::Part::Copy(move _19);\n        StorageDead(_19);\n        _17 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        StorageLive(_21);\n        _21 = 0_usize;\n        _22 = &raw const (fake) (*_6);\n        _23 = PtrMetadata(move _22);\n        _24 = Lt(_21, _23);\n        assert(move _24, \"index out of bounds: the length is {} but the index is {}\", move _23, _21) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        (*_6)[_21] = move _17;\n        StorageDead(_17);\n        StorageDead(_21);\n        StorageLive(_27);\n        _27 = &(*_6);\n        StorageLive(_28);\n        _28 = RangeTo(1_usize);\n        _26 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _27, move _28) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_28);\n        StorageDead(_27);\n        _25 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_26) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _0 = Formatted(_14, _25);\n        goto -> bb59;\n    }\n    bb14: {\n        StorageDead(_30);\n        StorageLive(_33);\n        _33 = 0_usize;\n        _34 = &raw const (fake) (*_6);\n        _35 = PtrMetadata(move _34);\n        _36 = Lt(_33, _35);\n        assert(move _36, \"index out of bounds: the length is {} but the index is {}\", move _35, _33) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        (*_6)[_33] = move _29;\n        StorageDead(_29);\n        StorageDead(_33);\n        StorageLive(_39);\n        _39 = &(*_6);\n        StorageLive(_40);\n        _40 = RangeTo(1_usize);\n        _38 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _39, move _40) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_40);\n        StorageDead(_39);\n        _37 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_38) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _0 = Formatted(_14, _37);\n        goto -> bb59;\n    }\n    bb18: {\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = b\"0.\";\n        _44 = move _45 as &[u8];\n        StorageDead(_45);\n        _43 = num::fmt::Part::Copy(move _44);\n        StorageDead(_44);\n        _42 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _43) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_43);\n        StorageLive(_46);\n        _46 = 0_usize;\n        _47 = &raw const (fake) (*_6);\n        _48 = PtrMetadata(move _47);\n        _49 = Lt(_46, _48);\n        assert(move _49, \"index out of bounds: the length is {} but the index is {}\", move _48, _46) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        (*_6)[_46] = move _42;\n        StorageDead(_42);\n        StorageDead(_46);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = num::fmt::Part::Zero(_4);\n        _50 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _51) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_51);\n        StorageLive(_52);\n        _52 = 1_usize;\n        _53 = &raw const (fake) (*_6);\n        _54 = PtrMetadata(move _53);\n        _55 = Lt(_52, _54);\n        assert(move _55, \"index out of bounds: the length is {} but the index is {}\", move _54, _52) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        (*_6)[_52] = move _50;\n        StorageDead(_50);\n        StorageDead(_52);\n        StorageLive(_58);\n        _58 = &(*_6);\n        StorageLive(_59);\n        _59 = RangeTo(2_usize);\n        _57 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _58, move _59) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_59);\n        StorageDead(_58);\n        _56 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_57) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _0 = Formatted(_14, _56);\n        goto -> bb30;\n    }\n    bb25: {\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = b\"0\";\n        _62 = move _63 as &[u8];\n        StorageDead(_63);\n        _61 = num::fmt::Part::Copy(move _62);\n        StorageDead(_62);\n        _60 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _61) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_61);\n        StorageLive(_64);\n        _64 = 0_usize;\n        _65 = &raw const (fake) (*_6);\n        _66 = PtrMetadata(move _65);\n        _67 = Lt(_64, _66);\n        assert(move _67, \"index out of bounds: the length is {} but the index is {}\", move _66, _64) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        (*_6)[_64] = move _60;\n        StorageDead(_60);\n        StorageDead(_64);\n        StorageLive(_70);\n        _70 = &(*_6);\n        StorageLive(_71);\n        _71 = RangeTo(1_usize);\n        _69 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _70, move _71) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_71);\n        StorageDead(_70);\n        _68 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_69) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _0 = Formatted(_14, _68);\n        goto -> bb30;\n    }\n    bb30: {\n        StorageDead(_41);\n        goto -> bb59;\n    }\n    bb31: {\n        StorageDead(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = &(*_5);\n        _76 = PtrMetadata(move _77);\n        StorageDead(_77);\n        _75 = Ge(move _76, _73);\n        switchInt(move _75) -> [0: bb33, otherwise: bb32];\n    }\n    bb32: {\n        StorageDead(_76);\n        StorageDead(_75);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = Lt(_4, 32768_usize);\n        switchInt(move _80) -> [0: bb35, otherwise: bb34];\n    }\n    bb33: {\n        StorageDead(_76);\n        _78 = panicking::panic(\"assertion failed: buf.len() >= maxlen\") -> unwind unreachable;\n    }\n    bb34: {\n        StorageLive(_81);\n        _81 = _4 as i16;\n        _82 = Eq(_81, i16::MIN);\n        assert(!move _82, \"attempt to negate `{}`, which would overflow\", _81) -> [success: bb36, unwind unreachable];\n    }\n    bb35: {\n        _79 = num::<impl i16>::MIN;\n        goto -> bb37;\n    }\n    bb36: {\n        _79 = Neg(move _81);\n        StorageDead(_81);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_80);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = &mut _1;\n        StorageLive(_87);\n        StorageLive(_89);\n        _89 = RangeTo(_73);\n        _88 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_5, move _89) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_89);\n        StorageLive(_90);\n        _90 = _79;\n        _87 = (_72, _88, move _90);\n        _85 = <F as ops::function::FnMut<(&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>], i16)>>::call_mut(move _86, move _87) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_90);\n        StorageDead(_87);\n        StorageDead(_86);\n        _83 = (_85.0: &[u8]);\n        _84 = (_85.1: i16);\n        StorageDead(_85);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = _79;\n        _91 = Le(_84, move _92);\n        switchInt(move _91) -> [0: bb56, otherwise: bb40];\n    }\n    bb40: {\n        StorageDead(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = PtrMetadata(_83);\n        _94 = &_95;\n        StorageLive(_96);\n        _96 = num::flt2dec::to_exact_fixed_str::<'_, T, F>::promoted[0];\n        _93 = (move _94, move _96);\n        StorageDead(_96);\n        StorageDead(_94);\n        _97 = (_93.0: &usize);\n        _98 = (_93.1: &usize);\n        StorageLive(_99);\n        StorageLive(_100);\n        _100 = (*_97);\n        StorageLive(_101);\n        _101 = (*_98);\n        _99 = Eq(move _100, move _101);\n        switchInt(move _99) -> [0: bb42, otherwise: bb41];\n    }\n    bb41: {\n        StorageDead(_101);\n        StorageDead(_100);\n        StorageDead(_99);\n        StorageDead(_95);\n        StorageDead(_93);\n        StorageLive(_105);\n        _105 = Gt(_4, 0_usize);\n        switchInt(move _105) -> [0: bb50, otherwise: bb43];\n    }\n    bb42: {\n        StorageDead(_101);\n        StorageDead(_100);\n        _102 = panicking::AssertKind::Eq;\n        StorageLive(_104);\n        _104 = option::Option::None;\n        _103 = panicking::assert_failed::<usize, usize>(_102, _97, _98, move _104) -> unwind unreachable;\n    }\n    bb43: {\n        StorageLive(_106);\n        StorageLive(_107);\n        StorageLive(_108);\n        StorageLive(_109);\n        _109 = b\"0.\";\n        _108 = move _109 as &[u8];\n        StorageDead(_109);\n        _107 = num::fmt::Part::Copy(move _108);\n        StorageDead(_108);\n        _106 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _107) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_107);\n        StorageLive(_110);\n        _110 = 0_usize;\n        _111 = &raw const (fake) (*_6);\n        _112 = PtrMetadata(move _111);\n        _113 = Lt(_110, _112);\n        assert(move _113, \"index out of bounds: the length is {} but the index is {}\", move _112, _110) -> [success: bb45, unwind unreachable];\n    }\n    bb45: {\n        (*_6)[_110] = move _106;\n        StorageDead(_106);\n        StorageDead(_110);\n        StorageLive(_114);\n        StorageLive(_115);\n        _115 = num::fmt::Part::Zero(_4);\n        _114 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _115) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_115);\n        StorageLive(_116);\n        _116 = 1_usize;\n        _117 = &raw const (fake) (*_6);\n        _118 = PtrMetadata(move _117);\n        _119 = Lt(_116, _118);\n        assert(move _119, \"index out of bounds: the length is {} but the index is {}\", move _118, _116) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        (*_6)[_116] = move _114;\n        StorageDead(_114);\n        StorageDead(_116);\n        StorageLive(_122);\n        _122 = &(*_6);\n        StorageLive(_123);\n        _123 = RangeTo(2_usize);\n        _121 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _122, move _123) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_123);\n        StorageDead(_122);\n        _120 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_121) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _0 = Formatted(_14, _120);\n        goto -> bb55;\n    }\n    bb50: {\n        StorageLive(_124);\n        StorageLive(_125);\n        StorageLive(_126);\n        StorageLive(_127);\n        _127 = b\"0\";\n        _126 = move _127 as &[u8];\n        StorageDead(_127);\n        _125 = num::fmt::Part::Copy(move _126);\n        StorageDead(_126);\n        _124 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _125) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_125);\n        StorageLive(_128);\n        _128 = 0_usize;\n        _129 = &raw const (fake) (*_6);\n        _130 = PtrMetadata(move _129);\n        _131 = Lt(_128, _130);\n        assert(move _131, \"index out of bounds: the length is {} but the index is {}\", move _130, _128) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        (*_6)[_128] = move _124;\n        StorageDead(_124);\n        StorageDead(_128);\n        StorageLive(_134);\n        _134 = &(*_6);\n        StorageLive(_135);\n        _135 = RangeTo(1_usize);\n        _133 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _134, move _135) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_135);\n        StorageDead(_134);\n        _132 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_133) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        _0 = Formatted(_14, _132);\n        goto -> bb55;\n    }\n    bb55: {\n        StorageDead(_105);\n        goto -> bb58;\n    }\n    bb56: {\n        StorageDead(_92);\n        _136 = num::flt2dec::digits_to_dec_str(_83, _84, _4, _6) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        _0 = Formatted(_14, _136);\n        goto -> bb58;\n    }\n    bb58: {\n        StorageDead(_91);\n        StorageDead(_79);\n        goto -> bb59;\n    }\n    bb59: {\n        StorageDead(_12);\n        drop(_1) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        return;\n    }\n}\n",
  "doc": " Formats given floating point number into the decimal form with exactly\n given number of fractional digits. The result is stored to the supplied parts\n array while utilizing given byte buffer as a scratch. `upper` is currently\n unused but left for the future decision to change the case of non-finite values,\n i.e., `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n (which can be an empty string if no sign is rendered).\n\n `format_exact` should be the underlying digit-generation function.\n It should return the part of the buffer that it initialized.\n You probably would want `strategy::grisu::format_exact` for this.\n\n The byte buffer should be enough for the output unless `frac_digits` is\n so large that only the fixed number of digits will be ever written.\n (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n There should be at least 4 parts available, due to the worst case like\n `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}