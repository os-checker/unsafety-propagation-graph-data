{
  "name": "iter::traits::iterator::Iterator::try_collect",
  "safe": true,
  "callees": {
    "iter::adapters::try_process": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Process the given iterator as if it yielded the item's `Try::Output`\n type instead. Any `Try::Residual`s encountered will stop the inner iterator\n and be propagated back to the overall result.\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::by_ref_sized::ByRefSized": [
      "Plain"
    ]
  },
  "path": "iter::traits::iterator::Iterator::try_collect",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2102:5: 2109:6",
  "src": "fn try_collect<B>(&mut self) -> ChangeOutputType<Self::Item, B>\n    where\n        Self: Sized,\n        Self::Item: Try<Residual: Residual<B>>,\n        B: FromIterator<<Self::Item as Try>::Output>,\n    {\n        try_process(ByRefSized(self), |i| i.collect())\n    }",
  "mir": "fn iter::traits::iterator::Iterator::try_collect(_1: &mut Self) -> <<<Self as iter::traits::iterator::Iterator>::Item as ops::try_trait::Try>::Residual as ops::try_trait::Residual<B>>::TryType {\n    let mut _0: <<<Self as iter::traits::iterator::Iterator>::Item as ops::try_trait::Try>::Residual as ops::try_trait::Residual<B>>::TryType;\n    let mut _2: iter::adapters::by_ref_sized::ByRefSized<'_, Self>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = ByRefSized(_1);\n        _0 = iter::adapters::try_process::<iter::adapters::by_ref_sized::ByRefSized<'_, Self>, <<Self as iter::traits::iterator::Iterator>::Item as ops::try_trait::Try>::Output, <<Self as iter::traits::iterator::Iterator>::Item as ops::try_trait::Try>::Residual, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2108:39: 2108:42}, B>(move _2, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2108:39: 2108:42}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Fallibly transforms an iterator into a collection, short circuiting if\n a failure is encountered.\n\n `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible\n conversions during collection. Its main use case is simplifying conversions from\n iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]\n types (e.g. [`Result`]).\n\n Importantly, `try_collect()` doesn't require that the outer [`Try`] type also implements [`FromIterator`];\n only the inner type produced on `Try::Output` must implement it. Concretely,\n this means that collecting into `ControlFlow<_, Vec<i32>>` is valid because `Vec<i32>` implements\n [`FromIterator`], even though [`ControlFlow`] doesn't.\n\n Also, if a failure is encountered during `try_collect()`, the iterator is still valid and\n may continue to be used, in which case it will continue iterating starting after the element that\n triggered the failure. See the last example below for an example of how this works.\n\n # Examples\n Successfully collecting an iterator of `Option<i32>` into `Option<Vec<i32>>`:\n ```\n #![feature(iterator_try_collect)]\n\n let u = vec![Some(1), Some(2), Some(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, Some(vec![1, 2, 3]));\n ```\n\n Failing to collect in the same way:\n ```\n #![feature(iterator_try_collect)]\n\n let u = vec![Some(1), Some(2), None, Some(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, None);\n ```\n\n A similar example, but with `Result`:\n ```\n #![feature(iterator_try_collect)]\n\n let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, Ok(vec![1, 2, 3]));\n\n let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, Err(()));\n ```\n\n Finally, even [`ControlFlow`] works, despite the fact that it\n doesn't implement [`FromIterator`]. Note also that the iterator can\n continue to be used, even if a failure is encountered:\n\n ```\n #![feature(iterator_try_collect)]\n\n use core::ops::ControlFlow::{Break, Continue};\n\n let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\n let mut it = u.into_iter();\n\n let v = it.try_collect::<Vec<_>>();\n assert_eq!(v, Break(3));\n\n let v = it.try_collect::<Vec<_>>();\n assert_eq!(v, Continue(vec![4, 5]));\n ```\n\n [`collect`]: Iterator::collect\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}