{
  "name": "slice::sort::stable::merge::merge",
  "safe": true,
  "callees": {
    "cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut mem::maybe_uninit::MaybeUninit<T>>::cast_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a maybe-uninitialized type to its initialized version.\n\n This is always safe, since UB can only occur if the pointer is read\n before being initialized.\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "slice::sort::stable::merge::MergeState::<T>::merge_up": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n The caller MUST guarantee that `self` is initialized in a way where `start -> end` is\n the longer sub-slice and so that `dst` can be written to at least the shorter sub-slice\n length times. In addition `start -> end` and `right -> right_end` MUST be valid to be\n read. This function MUST only be called once.\n",
      "adt": {
        "slice::sort::stable::merge::MergeState": "MutableAsArgument"
      }
    },
    "slice::sort::stable::merge::MergeState::<T>::merge_down": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n The caller MUST guarantee that `self` is initialized in a way where `left_end <- dst` is\n the shorter sub-slice and so that `out` can be written to at least the shorter sub-slice\n length times. In addition `left_end <- dst` and `right_end <- end` MUST be valid to be\n read. This function MUST only be called once.\n",
      "adt": {
        "slice::sort::stable::merge::MergeState": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "slice::sort::stable::merge::MergeState": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::sort::stable::merge::merge"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/stable/merge.rs:8:1: 63:2",
  "src": "pub fn merge<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    mid: usize,\n    is_less: &mut F,\n) {\n    let len = v.len();\n\n    if mid == 0 || mid >= len || scratch.len() < cmp::min(mid, len - mid) {\n        return;\n    }\n\n    // SAFETY: We checked that the two slices are non-empty and `mid` is in-bounds.\n    // We checked that the buffer `scratch` has enough capacity to hold a copy of\n    // the shorter slice. `merge_up` and `merge_down` are written in such a way that\n    // they uphold the contract described in `MergeState::drop`.\n    unsafe {\n        // The merge process first copies the shorter run into `buf`. Then it traces\n        // the newly copied run and the longer run forwards (or backwards), comparing\n        // their next unconsumed elements and copying the lesser (or greater) one into `v`.\n        //\n        // As soon as the shorter run is fully consumed, the process is done. If the\n        // longer run gets consumed first, then we must copy whatever is left of the\n        // shorter run into the remaining gap in `v`.\n        //\n        // Intermediate state of the process is always tracked by `gap`, which serves\n        // two purposes:\n        //  1. Protects integrity of `v` from panics in `is_less`.\n        //  2. Fills the remaining gap in `v` if the longer run gets consumed first.\n\n        let buf = scratch.as_mut_ptr().cast_init();\n\n        let v_base = v.as_mut_ptr();\n        let v_mid = v_base.add(mid);\n        let v_end = v_base.add(len);\n\n        let left_len = mid;\n        let right_len = len - mid;\n\n        let left_is_shorter = left_len <= right_len;\n        let save_base = if left_is_shorter { v_base } else { v_mid };\n        let save_len = if left_is_shorter { left_len } else { right_len };\n\n        ptr::copy_nonoverlapping(save_base, buf, save_len);\n\n        let mut merge_state = MergeState { start: buf, end: buf.add(save_len), dst: save_base };\n\n        if left_is_shorter {\n            merge_state.merge_up(v_mid, v_end, is_less);\n        } else {\n            merge_state.merge_down(v_base, buf, v_end, is_less);\n        }\n        // Finally, `merge_state` gets dropped. If the shorter run was not fully\n        // consumed, whatever remains of it will now be copied into the hole in `v`.\n    }\n}",
  "mir": "fn slice::sort::stable::merge::merge(_1: &mut [T], _2: &mut [mem::maybe_uninit::MaybeUninit<T>], _3: usize, _4: &mut F) -> () {\n    let mut _0: ();\n    let  _5: usize;\n    let mut _6: &[T];\n    let mut _7: bool;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: &[mem::maybe_uninit::MaybeUninit<T>];\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: (usize, bool);\n    let  _14: *mut T;\n    let mut _15: *mut mem::maybe_uninit::MaybeUninit<T>;\n    let  _16: *mut T;\n    let  _17: *mut T;\n    let  _18: *mut T;\n    let  _19: usize;\n    let mut _20: (usize, bool);\n    let  _21: bool;\n    let  _22: *mut T;\n    let  _23: usize;\n    let  _24: ();\n    let mut _25: *const T;\n    let mut _26: *mut T;\n    let mut _27: usize;\n    let mut _28: slice::sort::stable::merge::MergeState<T>;\n    let mut _29: *mut T;\n    let mut _30: usize;\n    let mut _31: *mut T;\n    let  _32: ();\n    let mut _33: &mut slice::sort::stable::merge::MergeState<T>;\n    let mut _34: *const T;\n    let mut _35: *const T;\n    let  _36: ();\n    let mut _37: &mut slice::sort::stable::merge::MergeState<T>;\n    let mut _38: *const T;\n    let mut _39: *const T;\n    debug v => _1;\n    debug scratch => _2;\n    debug mid => _3;\n    debug is_less => _4;\n    debug len => _5;\n    debug buf => _14;\n    debug v_base => _16;\n    debug v_mid => _17;\n    debug v_end => _18;\n    debug left_len => _3;\n    debug right_len => _19;\n    debug left_is_shorter => _21;\n    debug save_base => _22;\n    debug save_len => _23;\n    debug merge_state => _28;\n    bb0: {\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = PtrMetadata(move _6);\n        StorageDead(_6);\n        switchInt(_3) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        goto -> bb8;\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = Ge(_3, _5);\n        switchInt(move _7) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        goto -> bb8;\n    }\n    bb4: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_2);\n        _9 = PtrMetadata(move _10);\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _13 = CheckedSub(_5, _3);\n        assert(!move (_13.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _3) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = move (_13.0: usize);\n        _11 = cmp::min::<usize>(_3, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        _8 = Lt(move _9, move _11);\n        switchInt(move _8) -> [0: bb9, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_11);\n        StorageDead(_9);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb30;\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_15);\n        _15 = slice::<impl [mem::maybe_uninit::MaybeUninit<T>]>::as_mut_ptr(_2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _14 = ptr::mut_ptr::<impl *mut mem::maybe_uninit::MaybeUninit<T>>::cast_init(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _16 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _17 = ptr::mut_ptr::<impl *mut T>::add(_16, _3) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = ptr::mut_ptr::<impl *mut T>::add(_16, _5) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _20 = CheckedSub(_5, _3);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _3) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _19 = move (_20.0: usize);\n        _21 = Le(_3, _19);\n        StorageLive(_22);\n        switchInt(_21) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        _22 = _16;\n        goto -> bb18;\n    }\n    bb17: {\n        _22 = _17;\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_23);\n        switchInt(_21) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        _23 = _3;\n        goto -> bb21;\n    }\n    bb20: {\n        _23 = _19;\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = _22;\n        _25 = move _26 as *const T;\n        StorageDead(_26);\n        StorageLive(_27);\n        _27 = _23;\n        _24 = ptr::copy_nonoverlapping::<T>(move _25, _14, move _27) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        StorageDead(_25);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _23;\n        _29 = ptr::mut_ptr::<impl *mut T>::add(_14, move _30) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_30);\n        StorageLive(_31);\n        _31 = _22;\n        _28 = MergeState(_14, move _29, move _31);\n        StorageDead(_31);\n        StorageDead(_29);\n        switchInt(_21) -> [0: bb26, otherwise: bb24];\n    }\n    bb24: {\n        StorageLive(_33);\n        _33 = &mut _28;\n        StorageLive(_34);\n        _34 = _17 as *const T;\n        StorageLive(_35);\n        _35 = _18 as *const T;\n        _32 = slice::sort::stable::merge::MergeState::<T>::merge_up::<F>(move _33, move _34, move _35, _4) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb28;\n    }\n    bb26: {\n        StorageLive(_37);\n        _37 = &mut _28;\n        StorageLive(_38);\n        _38 = _16 as *const T;\n        StorageLive(_39);\n        _39 = _14 as *const T;\n        _36 = slice::sort::stable::merge::MergeState::<T>::merge_down::<F>(move _37, move _38, move _39, _18, _4) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb28;\n    }\n    bb28: {\n        drop(_28) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_28);\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb30;\n    }\n    bb30: {\n        return;\n    }\n}\n",
  "doc": " Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `scratch` as\n temporary storage, and stores the result into `v[..]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}