{
  "name": "slice::<impl [T]>::as_rchunks",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_chunks_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the slice into a slice of `N`-element arrays,\n assuming that there's no remainder.\n\n This is the inverse operation to [`as_flattened`].\n\n [`as_flattened`]: slice::as_flattened\n\n As this is `unsafe`, consider whether you could use [`as_chunks`] or\n [`as_rchunks`] instead, perhaps via something like\n `if let (chunks, []) = slice.as_chunks()` or\n `let (chunks, []) = slice.as_chunks() else { unreachable!() };`.\n\n [`as_chunks`]: slice::as_chunks\n [`as_rchunks`]: slice::as_rchunks\n\n # Safety\n\n This may only be called when\n - The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).\n - `N != 0`.\n\n # Examples\n\n ```\n let slice: &[char] = &['l', 'o', 'r', 'e', 'm', '!'];\n let chunks: &[[char; 1]] =\n     // SAFETY: 1-element chunks never have remainder\n     unsafe { slice.as_chunks_unchecked() };\n assert_eq!(chunks, &[['l'], ['o'], ['r'], ['e'], ['m'], ['!']]);\n let chunks: &[[char; 3]] =\n     // SAFETY: The slice length (6) is a multiple of 3\n     unsafe { slice.as_chunks_unchecked() };\n assert_eq!(chunks, &[['l', 'o', 'r'], ['e', 'm', '!']]);\n\n // These would be unsound:\n // let chunks: &[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5\n // let chunks: &[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 1238,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:1442:5: 1450:6",
  "src": "pub const fn as_rchunks<const N: usize>(&self) -> (&[T], &[[T; N]]) {\n        assert!(N != 0, \"chunk size must be non-zero\");\n        let len = self.len() / N;\n        let (remainder, multiple_of_n) = self.split_at(self.len() - len * N);\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (remainder, array_slice)\n    }",
  "mir": "fn slice::<impl [T]>::as_rchunks(_1: &[T]) -> (&[T], &[[T; N]]) {\n    let mut _0: (&[T], &[[T; N]]);\n    let mut _2: bool;\n    let  _3: !;\n    let mut _4: fmt::Arguments<'_>;\n    let  _5: usize;\n    let mut _6: usize;\n    let mut _7: bool;\n    let  _8: &[T];\n    let  _9: &[T];\n    let mut _10: (&[T], &[T]);\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let mut _15: (usize, bool);\n    let  _16: &[[T; N]];\n    debug self => _1;\n    debug len => _5;\n    debug remainder => _8;\n    debug multiple_of_n => _9;\n    debug array_slice => _16;\n    bb0: {\n        StorageLive(_2);\n        _2 = Ne(N, 0_usize);\n        switchInt(move _2) -> [0: bb1, otherwise: bb3];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = fmt::Arguments::<'_>::from_str(\"chunk size must be non-zero\") -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = panicking::panic_fmt(move _4) -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_2);\n        StorageLive(_6);\n        _6 = PtrMetadata(_1);\n        _7 = Eq(N, 0_usize);\n        assert(!move _7, \"attempt to divide `{}` by zero\", _6) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _5 = Div(move _6, N);\n        StorageDead(_6);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = PtrMetadata(_1);\n        StorageLive(_13);\n        _14 = CheckedMul(_5, N);\n        assert(!move (_14.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _5, N) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _13 = move (_14.0: usize);\n        _15 = CheckedSub(_12, _13);\n        assert(!move (_15.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _12, move _13) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = move (_15.0: usize);\n        StorageDead(_13);\n        StorageDead(_12);\n        _10 = slice::<impl [T]>::split_at(_1, move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _8 = (_10.0: &[T]);\n        _9 = (_10.1: &[T]);\n        StorageDead(_10);\n        _16 = slice::<impl [T]>::as_chunks_unchecked::<N>(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _0 = (_8, _16);\n        return;\n    }\n}\n",
  "doc": " Splits the slice into a slice of `N`-element arrays,\n starting at the end of the slice,\n and a remainder slice with length strictly less than `N`.\n\n The remainder is meaningful in the division sense.  Given\n `let (remainder, chunks) = slice.as_rchunks()`, then:\n - `remainder.len()` equals `slice.len() % N`,\n - `chunks.len()` equals `slice.len() / N`, and\n - `slice.len()` equals `chunks.len() * N + remainder.len()`.\n\n You can flatten the chunks back into a slice-of-`T` with [`as_flattened`].\n\n [`as_flattened`]: slice::as_flattened\n\n # Panics\n\n Panics if `N` is zero.\n\n Note that this check is against a const generic parameter, not a runtime\n value, and thus a particular monomorphization will either always panic\n or it will never panic.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let (remainder, chunks) = slice.as_rchunks();\n assert_eq!(remainder, &['l']);\n assert_eq!(chunks, &[['o', 'r'], ['e', 'm']]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}