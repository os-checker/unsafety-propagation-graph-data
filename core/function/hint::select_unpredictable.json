{
  "name": "hint::select_unpredictable",
  "safe": true,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<Vec<u32>>`.\n // This is okay because we initialized it.\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n x_vec.push(3);\n assert_eq!(x_vec.len(), 4);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "intrinsics::select_unpredictable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns either `true_val` or `false_val` depending on condition `b` with a\n hint to the compiler that this condition is unlikely to be correctly\n predicted by a CPU's branch predictor (e.g. a binary search).\n\n This is otherwise functionally equivalent to `if b { true_val } else { false_val }`.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n The public form of this intrinsic is [`core::hint::select_unpredictable`].\n However unlike the public form, the intrinsic will not drop the value that\n is not selected.\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n See [`ptr::drop_in_place`] for safety concerns and examples.\n\n [`ptr::drop_in_place`]: crate::ptr::drop_in_place()\n",
      "adt": {}
    },
    "mem::forget": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes ownership and \"forgets\" about the value **without running its destructor**.\n\n Any resources the value manages, such as heap memory or a file handle, will linger\n forever in an unreachable state. However, it does not guarantee that pointers\n to this memory will remain valid.\n\n * If you want to leak memory, see [`Box::leak`].\n * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n * If you want to dispose of a value properly, running its destructor, see\n   [`mem::drop`].\n\n # Safety\n\n `forget` is not marked as `unsafe`, because Rust's safety guarantees\n do not include a guarantee that destructors will always run. For example,\n a program can create a reference cycle using [`Rc`][rc], or call\n [`process::exit`][exit] to exit without running destructors. Thus, allowing\n `mem::forget` from safe code does not fundamentally change Rust's safety\n guarantees.\n\n That said, leaking resources such as memory or I/O objects is usually undesirable.\n The need comes up in some specialized use cases for FFI or unsafe code, but even\n then, [`ManuallyDrop`] is typically preferred.\n\n Because forgetting a value is allowed, any `unsafe` code you write must\n allow for this possibility. You cannot return a value and expect that the\n caller will necessarily run the value's destructor.\n\n [rc]: ../../std/rc/struct.Rc.html\n [exit]: ../../std/process/fn.exit.html\n\n # Examples\n\n The canonical safe use of `mem::forget` is to circumvent a value's destructor\n implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n the space taken by the variable but never close the underlying system resource:\n\n ```no_run\n use std::mem;\n use std::fs::File;\n\n let file = File::open(\"foo.txt\").unwrap();\n mem::forget(file);\n ```\n\n This is useful when the ownership of the underlying resource was previously\n transferred to code outside of Rust, for example by transmitting the raw\n file descriptor to C code.\n\n # Relationship with `ManuallyDrop`\n\n While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n\n ```\n use std::mem;\n\n let mut v = vec![65, 122];\n // Build a `String` using the contents of `v`\n let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n // leak `v` because its memory is now managed by `s`\n mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n There are two issues with the above example:\n\n * If more code were added between the construction of `String` and the invocation of\n   `mem::forget()`, a panic within it would cause a double free because the same memory\n   is handled by both `v` and `s`.\n * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n   inspect it), some types have strict requirements on their values that\n   make them invalid when dangling or no longer owned. Using invalid values in any\n   way, including passing them to or returning them from functions, constitutes\n   undefined behavior and may break the assumptions made by the compiler.\n\n Switching to `ManuallyDrop` avoids both issues:\n\n ```\n use std::mem::ManuallyDrop;\n\n let v = vec![65, 122];\n // Before we disassemble `v` into its raw parts, make sure it\n // does not get dropped!\n let mut v = ManuallyDrop::new(v);\n // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n // Finally, build a `String`.\n let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n argument, forcing us to call it only after extracting anything we need from `v`. Even\n if a panic were introduced between construction of `ManuallyDrop` and building the\n string (which cannot happen in the code as shown), it would result in a leak and not a\n double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n erring on the side of (double-)dropping.\n\n Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n ownership to `s` — the final step of interacting with `v` to dispose of it without\n running its destructor is entirely avoided.\n\n [`Box`]: ../../std/boxed/struct.Box.html\n [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n [`mem::drop`]: drop\n [ub]: ../../reference/behavior-considered-undefined.html\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the value from the `MaybeUninit<T>` container. This is a great way\n to ensure that the data will get dropped, because the resulting `T` is\n subject to the usual drop handling.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes immediate undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n [inv]: #initialization-invariant\n\n On top of that, remember that most types have additional invariants beyond merely\n being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n is considered initialized (under the current implementation; this does not constitute\n a stable guarantee) because the only requirement the compiler knows about it\n is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n *immediate* undefined behavior, but will cause undefined behavior with most\n safe operations (including dropping it).\n\n [`Vec<T>`]: ../../std/vec/struct.Vec.html\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<bool>::uninit();\n x.write(true);\n let x_init = unsafe { x.assume_init() };\n assert_eq!(x_init, true);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_init = unsafe { x.assume_init() };\n // `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain",
      "MutRef"
    ],
    "hint::select_unpredictable::DropOnPanic": [
      "Plain"
    ]
  },
  "path": 13204,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hint.rs:776:1: 825:2",
  "src": "pub const fn select_unpredictable<T>(condition: bool, true_val: T, false_val: T) -> T\nwhere\n    T: [const] Destruct,\n{\n    // FIXME(https://github.com/rust-lang/unsafe-code-guidelines/issues/245):\n    // Change this to use ManuallyDrop instead.\n    let mut true_val = MaybeUninit::new(true_val);\n    let mut false_val = MaybeUninit::new(false_val);\n\n    struct DropOnPanic<T> {\n        // Invariant: valid pointer and points to an initialized value that is not further used,\n        // i.e. it can be dropped by this guard.\n        inner: *mut T,\n    }\n\n    impl<T> Drop for DropOnPanic<T> {\n        fn drop(&mut self) {\n            // SAFETY: Must be guaranteed on construction of local type `DropOnPanic`.\n            unsafe { self.inner.drop_in_place() }\n        }\n    }\n\n    let true_ptr = true_val.as_mut_ptr();\n    let false_ptr = false_val.as_mut_ptr();\n\n    // SAFETY: The value that is not selected is dropped, and the selected one\n    // is returned. This is necessary because the intrinsic doesn't drop the\n    // value that is  not selected.\n    unsafe {\n        // Extract the selected value first, ensure it is dropped as well if dropping the unselected\n        // value panics. We construct a temporary by-pointer guard around the selected value while\n        // dropping the unselected value. Arguments overlap here, so we can not use mutable\n        // reference for these arguments.\n        let guard = crate::intrinsics::select_unpredictable(condition, true_ptr, false_ptr);\n        let drop = crate::intrinsics::select_unpredictable(condition, false_ptr, true_ptr);\n\n        // SAFETY: both pointers are well-aligned and point to initialized values inside a\n        // `MaybeUninit` each. In both possible values for `condition` the pointer `guard` and\n        // `drop` do not alias (even though the two argument pairs we have selected from did alias\n        // each other).\n        let guard = DropOnPanic { inner: guard };\n        drop.drop_in_place();\n        crate::mem::forget(guard);\n\n        // Note that it is important to use the values here. Reading from the pointer we got makes\n        // LLVM forget the !unpredictable annotation sometimes (in tests, integer sized values in\n        // particular seemed to confuse it, also observed in llvm/llvm-project #82340).\n        crate::intrinsics::select_unpredictable(condition, true_val, false_val).assume_init()\n    }\n}",
  "mir": "fn hint::select_unpredictable(_1: bool, _2: T, _3: T) -> T {\n    let mut _0: T;\n    let mut _4: mem::maybe_uninit::MaybeUninit<T>;\n    let mut _5: mem::maybe_uninit::MaybeUninit<T>;\n    let  _6: *mut T;\n    let mut _7: &mut mem::maybe_uninit::MaybeUninit<T>;\n    let  _8: *mut T;\n    let mut _9: &mut mem::maybe_uninit::MaybeUninit<T>;\n    let  _10: *mut T;\n    let  _11: *mut T;\n    let  _12: hint::select_unpredictable::DropOnPanic<T>;\n    let  _13: ();\n    let  _14: ();\n    let mut _15: mem::maybe_uninit::MaybeUninit<T>;\n    let mut _16: mem::maybe_uninit::MaybeUninit<T>;\n    let mut _17: mem::maybe_uninit::MaybeUninit<T>;\n    debug condition => _1;\n    debug true_val => _2;\n    debug false_val => _3;\n    debug true_val => _4;\n    debug false_val => _5;\n    debug true_ptr => _6;\n    debug false_ptr => _8;\n    debug guard => _10;\n    debug drop => _11;\n    debug guard => _12;\n    bb0: {\n        StorageLive(_4);\n        _4 = mem::maybe_uninit::MaybeUninit::<T>::new(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = mem::maybe_uninit::MaybeUninit::<T>::new(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = &mut _4;\n        _6 = mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = &mut _5;\n        _8 = mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _10 = intrinsics::select_unpredictable::<*mut T>(_1, _6, _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _11 = intrinsics::select_unpredictable::<*mut T>(_1, _8, _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = DropOnPanic(_10);\n        _13 = ptr::mut_ptr::<impl *mut T>::drop_in_place(_11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = mem::forget::<hint::select_unpredictable::DropOnPanic<T>>(_12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = move _4;\n        StorageLive(_17);\n        _17 = move _5;\n        _15 = intrinsics::select_unpredictable::<mem::maybe_uninit::MaybeUninit<T>>(_1, move _16, move _17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _0 = mem::maybe_uninit::MaybeUninit::<T>::assume_init(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Returns either `true_val` or `false_val` depending on the value of\n `condition`, with a hint to the compiler that `condition` is unlikely to be\n correctly predicted by a CPU’s branch predictor.\n\n This method is functionally equivalent to\n ```ignore (this is just for illustrative purposes)\n fn select_unpredictable<T>(b: bool, true_val: T, false_val: T) -> T {\n     if b { true_val } else { false_val }\n }\n ```\n but might generate different assembly. In particular, on platforms with\n a conditional move or select instruction (like `cmov` on x86 or `csel`\n on ARM) the optimizer might use these instructions to avoid branches,\n which can benefit performance if the branch predictor is struggling\n with predicting `condition`, such as in an implementation of binary\n search.\n\n Note however that this lowering is not guaranteed (on any platform) and\n should not be relied upon when trying to write cryptographic constant-time\n code. Also be aware that this lowering might *decrease* performance if\n `condition` is well-predictable. It is advisable to perform benchmarks to\n tell if this function is useful.\n\n # Examples\n\n Distribute values evenly between two buckets:\n ```\n use std::hash::BuildHasher;\n use std::hint;\n\n fn append<H: BuildHasher>(hasher: &H, v: i32, bucket_one: &mut Vec<i32>, bucket_two: &mut Vec<i32>) {\n     let hash = hasher.hash_one(&v);\n     let bucket = hint::select_unpredictable(hash % 2 == 0, bucket_one, bucket_two);\n     bucket.push(v);\n }\n # let hasher = std::collections::hash_map::RandomState::new();\n # let mut bucket_one = Vec::new();\n # let mut bucket_two = Vec::new();\n # append(&hasher, 42, &mut bucket_one, &mut bucket_two);\n # assert_eq!(bucket_one.len() + bucket_two.len(), 1);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}