{
  "name": "core_arch::x86::kl::_mm_encodekey256_u32",
  "safe": false,
  "callees": {
    "core_arch::x86::kl::encodekey256": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::write_unaligned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Overwrites a memory location with the given value without reading or\n dropping the old value.\n\n Unlike [`write()`], the pointer may be unaligned.\n\n `write_unaligned` does not drop the contents of `dst`. This is safe, but it\n could leak allocations or resources, so care should be taken not to overwrite\n an object that should be dropped.\n\n Additionally, it does not drop `src`. Semantically, `src` is moved into the\n location pointed to by `dst`.\n\n This is appropriate for initializing uninitialized memory, or overwriting\n memory that has previously been read with [`read_unaligned`].\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be [valid] for writes.\n\n [valid]: self#safety\n\n ## On `packed` structs\n\n Attempting to create a raw pointer to an `unaligned` struct field with\n an expression such as `&packed.unaligned as *const FieldType` creates an\n intermediate unaligned reference before converting that to a raw pointer.\n That this reference is temporary and immediately cast is inconsequential\n as the compiler always expects references to be properly aligned.\n As a result, using `&packed.unaligned as *const FieldType` causes immediate\n *undefined behavior* in your program.\n\n Instead, you must use the `&raw mut` syntax to create the pointer.\n You may use that constructed pointer together with this function.\n\n An example of how to do it and how this relates to `write_unaligned` is:\n\n ```\n #[repr(packed, C)]\n struct Packed {\n     _padding: u8,\n     unaligned: u32,\n }\n\n let mut packed: Packed = unsafe { std::mem::zeroed() };\n\n // Take the address of a 32-bit integer which is not aligned.\n // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.\n let unaligned = &raw mut packed.unaligned;\n\n unsafe { std::ptr::write_unaligned(unaligned, 42) };\n\n assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.\n ```\n\n Accessing unaligned fields directly with e.g. `packed.unaligned` is safe however\n (as can be seen in the `assert_eq!` above).\n\n # Examples\n\n Write a `usize` value to a byte buffer:\n\n ```\n fn write_usize(x: &mut [u8], val: usize) {\n     assert!(x.len() >= size_of::<usize>());\n\n     let ptr = x.as_mut_ptr() as *mut usize;\n\n     unsafe { ptr.write_unaligned(val) }\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128i": [
      "Plain"
    ],
    "core_arch::x86::kl::EncodeKey256Output": [
      "Plain",
      "Unknown([Field(0, Ty { id: 20, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(1, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(2, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(3, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])",
      "Unknown([Field(4, Ty { id: 16230, kind: RigidTy(Adt(AdtDef(DefId { id: 29801, name: \"core_arch::x86::__m128i\" }), GenericArgs([]))) })])"
    ]
  },
  "path": 11514,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/kl.rs:181:1: 191:2",
  "src": "pub unsafe fn _mm_encodekey256_u32(\n    key_params: u32,\n    key_lo: __m128i,\n    key_hi: __m128i,\n    handle: *mut u8,\n) -> u32 {\n    let EncodeKey256Output(control, key0, key1, key2, key3, _, _, _) =\n        encodekey256(key_params, key_lo, key_hi);\n    ptr::write_unaligned(handle.cast(), [key0, key1, key2, key3]);\n    control\n}",
  "mir": "fn core_arch::x86::kl::_mm_encodekey256_u32(_1: u32, _2: core_arch::x86::__m128i, _3: core_arch::x86::__m128i, _4: *mut u8) -> u32 {\n    let mut _0: u32;\n    let  _5: core_arch::x86::__m128i;\n    let  _6: core_arch::x86::__m128i;\n    let  _7: core_arch::x86::__m128i;\n    let  _8: core_arch::x86::__m128i;\n    let mut _9: core_arch::x86::kl::EncodeKey256Output;\n    let  _10: ();\n    let mut _11: *mut [core_arch::x86::__m128i; 4];\n    let mut _12: [core_arch::x86::__m128i; 4];\n    debug key_params => _1;\n    debug key_lo => _2;\n    debug key_hi => _3;\n    debug handle => _4;\n    debug control => _0;\n    debug key0 => _5;\n    debug key1 => _6;\n    debug key2 => _7;\n    debug key3 => _8;\n    bb0: {\n        StorageLive(_9);\n        _9 = core_arch::x86::kl::encodekey256(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = (_9.0: u32);\n        _5 = (_9.1: core_arch::x86::__m128i);\n        _6 = (_9.2: core_arch::x86::__m128i);\n        _7 = (_9.3: core_arch::x86::__m128i);\n        _8 = (_9.4: core_arch::x86::__m128i);\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = ptr::mut_ptr::<impl *mut u8>::cast::<[core_arch::x86::__m128i; 4]>(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_12);\n        _12 = [_5, _6, _7, _8];\n        _10 = ptr::write_unaligned::<[core_arch::x86::__m128i; 4]>(move _11, move _12) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_12);\n        StorageDead(_11);\n        return;\n    }\n}\n",
  "doc": " Wrap a 256-bit AES key into a 512-bit key handle and stores it in `handle`. Returns the `control`\n parameter used to create the IWKey.\n\n  - `key_params[0]`: If set, this key can only be used by the Kernel.\n  - `key_params[1]`: If set, this key can not be used to encrypt.\n  - `key_params[2]`: If set, this key can not be used to decrypt.\n  - `key_params[31:3]`: Reserved for future use, must be set to `0`.\n\n Note that these restrictions need hardware support, and the supported restrictions can be found by\n calling `__cpuid(0x19)` and checking the `EAX[0:2]` bits. Failing to follow these restrictions may\n result in a General Protection Exception.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_encodekey256_u32)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}