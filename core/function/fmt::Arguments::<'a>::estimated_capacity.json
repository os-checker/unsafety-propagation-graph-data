{
  "name": "fmt::Arguments::<'a>::estimated_capacity",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::as_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the formatted string, if it has no arguments to be formatted at runtime.\n\n This can be used to avoid allocations in some cases.\n\n # Guarantees\n\n For `format_args!(\"just a literal\")`, this function is guaranteed to\n return `Some(\"just a literal\")`.\n\n For most cases with placeholders, this function will return `None`.\n\n However, the compiler may perform optimizations that can cause this\n function to return `Some(_)` even if the format string contains\n placeholders. For example, `format_args!(\"Hello, {}!\", \"world\")` may be\n optimized to `format_args!(\"Hello, world!\")`, such that `as_str()`\n returns `Some(\"Hello, world!\")`.\n\n The behavior for anything but the trivial case (without placeholders)\n is not guaranteed, and should not be relied upon for anything other\n than optimization.\n\n # Examples\n\n ```rust\n use std::fmt::Arguments;\n\n fn write_str(_: &str) { /* ... */ }\n\n fn write_fmt(args: &Arguments<'_>) {\n     if let Some(s) = args.as_str() {\n         write_str(s)\n     } else {\n         write_str(&args.to_string());\n     }\n }\n ```\n\n ```rust\n assert_eq!(format_args!(\"hello\").as_str(), Some(\"hello\"));\n assert_eq!(format_args!(\"\").as_str(), Some(\"\"));\n assert_eq!(format_args!(\"{:?}\", std::env::current_dir()).as_str(), None);\n ```\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "ptr::non_null::NonNull::<T>::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from `self` without moving it. This leaves the\n memory in `self` unchanged.\n\n See [`ptr::read`] for safety concerns and examples.\n\n [`ptr::read`]: crate::ptr::read()\n",
      "adt": {}
    },
    "ptr::non_null::NonNull::<T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an offset to a pointer (convenience for `.offset(count as isize)`).\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let s: &str = \"123\";\n let ptr: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap();\n\n unsafe {\n     println!(\"{}\", ptr.add(1).read() as char);\n     println!(\"{}\", ptr.add(2).read() as char);\n }\n ```\n",
      "adt": {
        "ptr::non_null::NonNull": "Constructor"
      }
    },
    "ptr::non_null::NonNull::<T>::cast_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a pointer-to-`T` to a pointer-to-`[T; N]`.\n",
      "adt": {
        "ptr::non_null::NonNull": "Constructor"
      }
    },
    "num::<impl u16>::from_le_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a native endian integer value from its representation\n as a byte array in little endian.\n\n\n # Examples\n\n ```\n ```\n\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n\n ```\n     *input = rest;\n }\n ```\n",
      "adt": {}
    },
    "convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "num::<impl usize>::wrapping_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) multiplication. Computes `self *\n rhs`, wrapping around at the boundary of the type.\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u8` is used.\n\n ```\n assert_eq!(10u8.wrapping_mul(12), 120);\n assert_eq!(25u8.wrapping_mul(12), 44);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 81, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 84, kind: RigidTy(Str) }, Not)) })])"
    ],
    "ptr::non_null::NonNull": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::fmt::Arguments::<'a>::estimated_capacity"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:754:5: 806:6",
  "src": "pub fn estimated_capacity(&self) -> usize {\n        if let Some(s) = self.as_str() {\n            return s.len();\n        }\n        // Iterate over the template, counting the length of literal pieces.\n        let mut length = 0usize;\n        let mut starts_with_placeholder = false;\n        let mut template = self.template;\n        loop {\n            // SAFETY: We can assume the template is valid.\n            unsafe {\n                let n = template.read();\n                template = template.add(1);\n                if n == 0 {\n                    // End of template.\n                    break;\n                } else if n < 128 {\n                    // Short literal string piece.\n                    length += n as usize;\n                    template = template.add(n as usize);\n                } else if n == 128 {\n                    // Long literal string piece.\n                    let len = usize::from(u16::from_le_bytes(template.cast_array().read()));\n                    length += len;\n                    template = template.add(2 + len);\n                } else {\n                    assert_unchecked(n >= 0xC0);\n                    // Placeholder piece.\n                    if length == 0 {\n                        starts_with_placeholder = true;\n                    }\n                    // Skip remainder of placeholder:\n                    let skip = (n & 1 != 0) as usize * 4 // flags (32 bit)\n                        + (n & 2 != 0) as usize * 2  // width     (16 bit)\n                        + (n & 4 != 0) as usize * 2  // precision (16 bit)\n                        + (n & 8 != 0) as usize * 2; // arg_index (16 bit)\n                    template = template.add(skip as usize);\n                }\n            }\n        }\n\n        if starts_with_placeholder && length < 16 {\n            // If the format string starts with a placeholder,\n            // don't preallocate anything, unless length\n            // of literal pieces is significant.\n            0\n        } else {\n            // There are some placeholders, so any additional push\n            // will reallocate the string. To avoid that,\n            // we're \"pre-doubling\" the capacity here.\n            length.wrapping_mul(2)\n        }\n    }",
  "mir": "fn fmt::Arguments::<'a>::estimated_capacity(_1: &fmt::Arguments<'_>) -> usize {\n    let mut _0: usize;\n    let mut _2: option::Option<&str>;\n    let mut _3: isize;\n    let  _4: &str;\n    let mut _5: usize;\n    let mut _6: bool;\n    let mut _7: ptr::non_null::NonNull<u8>;\n    let  _8: u8;\n    let mut _9: ptr::non_null::NonNull<u8>;\n    let mut _10: ptr::non_null::NonNull<u8>;\n    let mut _11: ptr::non_null::NonNull<u8>;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let mut _15: ptr::non_null::NonNull<u8>;\n    let mut _16: ptr::non_null::NonNull<u8>;\n    let mut _17: usize;\n    let  _18: usize;\n    let mut _19: u16;\n    let mut _20: [u8; 2];\n    let mut _21: ptr::non_null::NonNull<[u8; 2]>;\n    let mut _22: ptr::non_null::NonNull<u8>;\n    let mut _23: (usize, bool);\n    let mut _24: ptr::non_null::NonNull<u8>;\n    let mut _25: ptr::non_null::NonNull<u8>;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let  _28: ();\n    let mut _29: bool;\n    let mut _30: usize;\n    let  _31: usize;\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: bool;\n    let mut _37: u8;\n    let mut _38: (usize, bool);\n    let mut _39: usize;\n    let mut _40: usize;\n    let mut _41: bool;\n    let mut _42: u8;\n    let mut _43: (usize, bool);\n    let mut _44: (usize, bool);\n    let mut _45: usize;\n    let mut _46: usize;\n    let mut _47: bool;\n    let mut _48: u8;\n    let mut _49: (usize, bool);\n    let mut _50: (usize, bool);\n    let mut _51: usize;\n    let mut _52: usize;\n    let mut _53: bool;\n    let mut _54: u8;\n    let mut _55: (usize, bool);\n    let mut _56: (usize, bool);\n    let mut _57: ptr::non_null::NonNull<u8>;\n    let mut _58: ptr::non_null::NonNull<u8>;\n    let mut _59: bool;\n    let mut _60: bool;\n    let mut _61: usize;\n    let mut _62: usize;\n    debug self => _1;\n    debug s => _4;\n    debug length => _5;\n    debug starts_with_placeholder => _6;\n    debug template => _7;\n    debug n => _8;\n    debug len => _18;\n    debug skip => _31;\n    bb0: {\n        StorageLive(_2);\n        _2 = fmt::Arguments::<'_>::as_str(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = discriminant(_2);\n        switchInt(move _3) -> [1: bb2, 0: bb4, otherwise: bb44];\n    }\n    bb2: {\n        _4 = ((_2 as variant#1).0: &str);\n        _0 = str::<impl str>::len(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        goto -> bb43;\n    }\n    bb4: {\n        StorageDead(_2);\n        StorageLive(_5);\n        _5 = 0_usize;\n        StorageLive(_6);\n        _6 = false;\n        StorageLive(_7);\n        _7 = ((*_1).0: ptr::non_null::NonNull<u8>);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_9);\n        _9 = _7;\n        _8 = ptr::non_null::NonNull::<u8>::read(move _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = _7;\n        _10 = ptr::non_null::NonNull::<u8>::add(move _11, 1_usize) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _7 = move _10;\n        StorageDead(_10);\n        switchInt(_8) -> [0: bb8, otherwise: bb9];\n    }\n    bb8: {\n        StorageLive(_59);\n        _59 = _6;\n        switchInt(move _59) -> [0: bb40, otherwise: bb37];\n    }\n    bb9: {\n        StorageLive(_12);\n        _12 = Lt(_8, 128_u8);\n        switchInt(move _12) -> [0: bb13, otherwise: bb10];\n    }\n    bb10: {\n        StorageLive(_13);\n        _13 = _8 as usize;\n        _14 = CheckedAdd(_5, _13);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, move _13) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _5 = move (_14.0: usize);\n        StorageDead(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _7;\n        StorageLive(_17);\n        _17 = _8 as usize;\n        _15 = ptr::non_null::NonNull::<u8>::add(move _16, move _17) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _7 = move _15;\n        StorageDead(_15);\n        goto -> bb36;\n    }\n    bb13: {\n        switchInt(_8) -> [128: bb14, otherwise: bb22];\n    }\n    bb14: {\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _7;\n        _21 = ptr::non_null::NonNull::<u8>::cast_array::<2>(move _22) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        _20 = ptr::non_null::NonNull::<[u8; 2]>::read(move _21) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_21);\n        _19 = num::<impl u16>::from_le_bytes(move _20) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_20);\n        _18 = <usize as convert::From<u16>>::from(move _19) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_19);\n        _23 = CheckedAdd(_5, _18);\n        assert(!move (_23.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _5, _18) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _5 = move (_23.0: usize);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _7;\n        StorageLive(_26);\n        _27 = CheckedAdd(2_usize, _18);\n        assert(!move (_27.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 2_usize, _18) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _26 = move (_27.0: usize);\n        _24 = ptr::non_null::NonNull::<u8>::add(move _25, move _26) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_26);\n        StorageDead(_25);\n        _7 = move _24;\n        StorageDead(_24);\n        goto -> bb35;\n    }\n    bb22: {\n        StorageLive(_29);\n        _29 = Ge(_8, 192_u8);\n        _28 = hint::assert_unchecked(move _29) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_29);\n        StorageLive(_30);\n        _30 = _5;\n        switchInt(move _30) -> [0: bb24, otherwise: bb25];\n    }\n    bb24: {\n        StorageDead(_30);\n        _6 = true;\n        goto -> bb26;\n    }\n    bb25: {\n        StorageDead(_30);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = BitAnd(_8, 1_u8);\n        _36 = Ne(move _37, 0_u8);\n        StorageDead(_37);\n        _35 = move _36 as usize;\n        StorageDead(_36);\n        _38 = CheckedMul(_35, 4_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _35, 4_usize) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _34 = move (_38.0: usize);\n        StorageDead(_35);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = BitAnd(_8, 2_u8);\n        _41 = Ne(move _42, 0_u8);\n        StorageDead(_42);\n        _40 = move _41 as usize;\n        StorageDead(_41);\n        _43 = CheckedMul(_40, 2_usize);\n        assert(!move (_43.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _40, 2_usize) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _39 = move (_43.0: usize);\n        StorageDead(_40);\n        _44 = CheckedAdd(_34, _39);\n        assert(!move (_44.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _34, move _39) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _33 = move (_44.0: usize);\n        StorageDead(_39);\n        StorageDead(_34);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = BitAnd(_8, 4_u8);\n        _47 = Ne(move _48, 0_u8);\n        StorageDead(_48);\n        _46 = move _47 as usize;\n        StorageDead(_47);\n        _49 = CheckedMul(_46, 2_usize);\n        assert(!move (_49.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _46, 2_usize) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _45 = move (_49.0: usize);\n        StorageDead(_46);\n        _50 = CheckedAdd(_33, _45);\n        assert(!move (_50.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _33, move _45) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _32 = move (_50.0: usize);\n        StorageDead(_45);\n        StorageDead(_33);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = BitAnd(_8, 8_u8);\n        _53 = Ne(move _54, 0_u8);\n        StorageDead(_54);\n        _52 = move _53 as usize;\n        StorageDead(_53);\n        _55 = CheckedMul(_52, 2_usize);\n        assert(!move (_55.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _52, 2_usize) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _51 = move (_55.0: usize);\n        StorageDead(_52);\n        _56 = CheckedAdd(_32, _51);\n        assert(!move (_56.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _32, move _51) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _31 = move (_56.0: usize);\n        StorageDead(_51);\n        StorageDead(_32);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = _7;\n        _57 = ptr::non_null::NonNull::<u8>::add(move _58, _31) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_58);\n        _7 = move _57;\n        StorageDead(_57);\n        goto -> bb35;\n    }\n    bb35: {\n        goto -> bb36;\n    }\n    bb36: {\n        StorageDead(_12);\n        goto -> bb5;\n    }\n    bb37: {\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = _5;\n        _60 = Lt(move _61, 16_usize);\n        switchInt(move _60) -> [0: bb39, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_61);\n        _0 = 0_usize;\n        goto -> bb42;\n    }\n    bb39: {\n        StorageDead(_61);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageLive(_62);\n        _62 = _5;\n        _0 = num::<impl usize>::wrapping_mul(move _62, 2_usize) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_62);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb43;\n    }\n    bb43: {\n        return;\n    }\n    bb44: {\n        unreachable;\n    }\n}\n",
  "doc": " Estimates the length of the formatted text.\n\n This is intended to be used for setting initial `String` capacity\n when using `format!`. Note: this is neither the lower nor upper bound.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}