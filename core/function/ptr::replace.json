{
  "name": "ptr::replace",
  "safe": false,
  "callees": {
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "ptr::replace::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mem::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves `src` into the referenced `dest`, returning the previous `dest` value.\n\n Neither value is dropped.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a default value, see [`take`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n assert_eq!(vec![1, 2], old_v);\n assert_eq!(vec![3, 4, 5], v);\n ```\n\n `replace` allows consumption of a struct field by replacing it with another value.\n Without `replace` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let t = self.buf[i];\n         self.buf[i] = v;\n         t\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n avoid the move. But `replace` can be used to disassociate the original value at that index from\n `self`, allowing it to be returned:\n\n ```\n # #![allow(dead_code)]\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         mem::replace(&mut self.buf[i], v)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf[0], 0);\n\n assert_eq!(buffer.replace_index(0, 2), 0);\n assert_eq!(buffer.buf[0], 2);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 16082,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1540:1: 1557:2",
  "src": "pub const unsafe fn replace<T>(dst: *mut T, src: T) -> T {\n    // SAFETY: the caller must guarantee that `dst` is valid to be\n    // cast to a mutable reference (valid for writes, aligned, initialized),\n    // and cannot overlap `src` since `dst` must point to a distinct\n    // allocation.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::replace requires that the pointer argument is aligned and non-null\",\n            (\n                addr: *const () = dst as *const (),\n                align: usize = align_of::<T>(),\n                is_zst: bool = T::IS_ZST,\n            ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, is_zst)\n        );\n        mem::replace(&mut *dst, src)\n    }\n}",
  "mir": "fn ptr::replace(_1: *mut T, _2: T) -> T {\n    let mut _0: T;\n    let mut _3: bool;\n    let  _4: ();\n    let mut _5: *const ();\n    let mut _6: usize;\n    let mut _7: &mut T;\n    debug dst => _1;\n    debug src => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = ub_checks::check_language_ub() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = _1 as *const ();\n        StorageLive(_6);\n        _6 = mem::align_of::<T>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = ptr::replace::precondition_check(move _5, move _6, <T as mem::SizedTypeProperties>::IS_ZST) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_3);\n        _7 = &mut (*_1);\n        _0 = mem::replace::<T>(_7, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Moves `src` into the pointed `dst`, returning the previous `dst` value.\n\n Neither value is dropped.\n\n This function is semantically equivalent to [`mem::replace`] except that it\n operates on raw pointers instead of references. When references are\n available, [`mem::replace`] should be preferred.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be [valid] for both reads and writes.\n\n * `dst` must be properly aligned.\n\n * `dst` must point to a properly initialized value of type `T`.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n [valid]: self#safety\n\n # Examples\n\n ```\n use std::ptr;\n\n let mut rust = vec!['b', 'u', 's', 't'];\n\n // `mem::replace` would have the same effect without requiring the unsafe\n // block.\n let b = unsafe {\n     ptr::replace(&mut rust[0], 'r')\n };\n\n assert_eq!(b, 'b');\n assert_eq!(rust, &['r', 'u', 's', 't']);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}