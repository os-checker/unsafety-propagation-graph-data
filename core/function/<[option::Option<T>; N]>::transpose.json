{
  "name": "<[option::Option<T>; N]>::transpose",
  "safe": true,
  "callees": {
    "array::<impl [T; N]>::try_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A fallible function `f` applied to each element on array `self` in order to\n return an array the same size as `self` or the first error encountered.\n\n The return type of this function depends on the return type of the closure.\n If you return `Result<T, E>` from the closure, you'll get a `Result<[T; N], E>`.\n If you return `Option<T>` from the closure, you'll get an `Option<[T; N]>`.\n\n # Examples\n\n ```\n #![feature(array_try_map)]\n\n let a = [\"1\", \"2\", \"3\"];\n let b = a.try_map(|v| v.parse::<u32>()).unwrap().map(|v| v + 1);\n assert_eq!(b, [2, 3, 4]);\n\n let a = [\"1\", \"2a\", \"3\"];\n let b = a.try_map(|v| v.parse::<u32>());\n assert!(b.is_err());\n\n use std::num::NonZero;\n\n let z = [1, 2, 0, 3, 4];\n assert_eq!(z.try_map(NonZero::new), None);\n\n let a = [1, 2, 3];\n let b = a.try_map(NonZero::new);\n let c = b.map(|x| x.map(NonZero::get));\n assert_eq!(c, Some(a));\n ```\n",
      "adt": {}
    },
    "convert::identity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The identity function.\n\n Two things are important to note about this function:\n\n - It is not always equivalent to a closure like `|x| x`, since the\n   closure may coerce `x` into a different type.\n\n - It moves the input `x` passed to the function.\n\n While it might seem strange to have a function that just returns back the\n input, there are some interesting uses.\n\n # Examples\n\n Using `identity` to do nothing in a sequence of other, interesting,\n functions:\n\n ```rust\n use std::convert::identity;\n\n fn manipulation(x: u32) -> u32 {\n     // Let's pretend that adding one is an interesting function.\n     x + 1\n }\n\n let _arr = &[identity, manipulation];\n ```\n\n Using `identity` as a \"do nothing\" base case in a conditional:\n\n ```rust\n use std::convert::identity;\n\n # let condition = true;\n #\n # fn manipulation(x: u32) -> u32 { x + 1 }\n #\n let do_stuff = if condition { manipulation } else { identity };\n\n // Do more interesting stuff...\n\n let _results = do_stuff(42);\n ```\n\n Using `identity` to keep the `Some` variants of an iterator of `Option<T>`:\n\n ```rust\n use std::convert::identity;\n\n let iter = [Some(1), None, Some(3)].into_iter();\n let filtered = iter.filter_map(identity).collect::<Vec<_>>();\n assert_eq!(vec![1, 3], filtered);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": 1375,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:2759:5: 2761:6",
  "src": "pub fn transpose(self) -> Option<[T; N]> {\n        self.try_map(core::convert::identity)\n    }",
  "mir": "fn <[option::Option<T>; N]>::transpose(_1: [option::Option<T>; N]) -> option::Option<[T; N]> {\n    let mut _0: option::Option<[T; N]>;\n    debug self => _1;\n    bb0: {\n        _0 = array::<impl [option::Option<T>; N]>::try_map::<option::Option<T>, fn(option::Option<T>) -> option::Option<T> {convert::identity::<option::Option<T>>}>(_1, convert::identity::<option::Option<T>>) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Transposes a `[Option<T>; N]` into a `Option<[T; N]>`.\n\n # Examples\n\n ```\n #![feature(option_array_transpose)]\n # use std::option::Option;\n\n let data = [Some(0); 1000];\n let data: Option<[u8; 1000]> = data.transpose();\n assert_eq!(data, Some([0; 1000]));\n\n let data = [Some(0), None];\n let data: Option<[u8; 2]> = data.transpose();\n assert_eq!(data, None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}