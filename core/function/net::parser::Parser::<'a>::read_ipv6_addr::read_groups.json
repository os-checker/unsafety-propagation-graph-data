{
  "name": "net::parser::Parser::<'a>::read_ipv6_addr::read_groups",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {
        "slice::iter::IterMut": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::enumerate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which gives the current iteration count as well as\n the next value.\n\n The iterator returned yields pairs `(i, val)`, where `i` is the\n current index of iteration and `val` is the value returned by the\n iterator.\n\n `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n different sized integer, the [`zip`] function provides similar\n functionality.\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so enumerating more than\n [`usize::MAX`] elements either produces the wrong result or panics. If\n overflow checks are enabled, a panic is guaranteed.\n\n # Panics\n\n The returned iterator might panic if the to-be-returned index would\n overflow a [`usize`].\n\n [`zip`]: Iterator::zip\n\n # Examples\n\n ```\n let a = ['a', 'b', 'c'];\n\n let mut iter = a.into_iter().enumerate();\n\n assert_eq!(iter.next(), Some((0, 'a')));\n assert_eq!(iter.next(), Some((1, 'b')));\n assert_eq!(iter.next(), Some((2, 'c')));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::enumerate::Enumerate": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "net::parser::Parser::<'a>::read_separator": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Helper for reading separators in an indexed loop. Reads the separator\n character iff index > 0, then runs the parser. When used in a loop,\n the separator character will only be read on index > 0 (see\n read_ipv4_addr for an example)\n",
      "adt": {
        "option::Option": "Constructor",
        "net::parser::Parser": "MutableAsArgument"
      }
    },
    "net::ip_addr::Ipv4Addr::octets": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the four eight-bit integers that make up this address.\n\n # Examples\n\n ```\n use std::net::Ipv4Addr;\n\n let addr = Ipv4Addr::new(127, 0, 0, 1);\n assert_eq!(addr.octets(), [127, 0, 0, 1]);\n ```\n",
      "adt": {
        "net::ip_addr::Ipv4Addr": "ImmutableAsArgument"
      }
    },
    "num::<impl u16>::from_be_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a native endian integer value from its representation\n as a byte array in big endian.\n\n\n # Examples\n\n ```\n ```\n\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n\n ```\n     *input = rest;\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::iter::IterMut": [
      "Plain"
    ],
    "iter::adapters::enumerate::Enumerate": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 9542, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 5569, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 136, kind: RigidTy(Uint(U16)) }, Mut)) }])) }), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 9542, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 5569, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 136, kind: RigidTy(Uint(U16)) }, Mut)) }])) }), Field(1, Ty { id: 5569, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 136, kind: RigidTy(Uint(U16)) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8184, kind: RigidTy(Adt(AdtDef(DefId { id: 26930, name: \"net::ip_addr::Ipv4Addr\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 136, kind: RigidTy(Uint(U16)) })])"
    ],
    "net::parser::Parser": [
      "MutRef"
    ],
    "net::ip_addr::Ipv4Addr": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::net::parser::Parser::<'a>::read_ipv6_addr::read_groups"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/net/parser.rs:184:9: 209:10",
  "src": "fn read_groups(p: &mut Parser<'_>, groups: &mut [u16]) -> (usize, bool) {\n            let limit = groups.len();\n\n            for (i, slot) in groups.iter_mut().enumerate() {\n                // Try to read a trailing embedded IPv4 address. There must be\n                // at least two groups left.\n                if i < limit - 1 {\n                    let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n\n                    if let Some(v4_addr) = ipv4 {\n                        let [one, two, three, four] = v4_addr.octets();\n                        groups[i + 0] = u16::from_be_bytes([one, two]);\n                        groups[i + 1] = u16::from_be_bytes([three, four]);\n                        return (i + 2, true);\n                    }\n                }\n\n                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4), true));\n\n                match group {\n                    Some(g) => *slot = g,\n                    None => return (i, false),\n                }\n            }\n            (groups.len(), false)\n        }",
  "mir": "fn net::parser::Parser::<'a>::read_ipv6_addr::read_groups(_1: &mut net::parser::Parser<'_>, _2: &mut [u16]) -> (usize, bool) {\n    let mut _0: (usize, bool);\n    let  _3: usize;\n    let mut _4: &[u16];\n    let mut _5: iter::adapters::enumerate::Enumerate<slice::iter::IterMut<'_, u16>>;\n    let mut _6: iter::adapters::enumerate::Enumerate<slice::iter::IterMut<'_, u16>>;\n    let mut _7: slice::iter::IterMut<'_, u16>;\n    let mut _8: iter::adapters::enumerate::Enumerate<slice::iter::IterMut<'_, u16>>;\n    let mut _9: option::Option<(usize, &mut u16)>;\n    let mut _10: &mut iter::adapters::enumerate::Enumerate<slice::iter::IterMut<'_, u16>>;\n    let mut _11: isize;\n    let  _12: usize;\n    let  _13: &mut u16;\n    let mut _14: bool;\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let  _17: option::Option<net::ip_addr::Ipv4Addr>;\n    let mut _18: isize;\n    let  _19: net::ip_addr::Ipv4Addr;\n    let  _20: u8;\n    let  _21: u8;\n    let  _22: u8;\n    let  _23: u8;\n    let mut _24: [u8; 4];\n    let mut _25: &net::ip_addr::Ipv4Addr;\n    let mut _26: u16;\n    let mut _27: [u8; 2];\n    let  _28: usize;\n    let mut _29: (usize, bool);\n    let mut _30: *const [u16];\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: u16;\n    let mut _34: [u8; 2];\n    let  _35: usize;\n    let mut _36: (usize, bool);\n    let mut _37: *const [u16];\n    let mut _38: usize;\n    let mut _39: bool;\n    let mut _40: usize;\n    let mut _41: (usize, bool);\n    let  _42: option::Option<u16>;\n    let mut _43: isize;\n    let  _44: u16;\n    let mut _45: usize;\n    let mut _46: &[u16];\n    debug p => _1;\n    debug groups => _2;\n    debug limit => _3;\n    debug iter => _8;\n    debug i => _12;\n    debug slot => _13;\n    debug ipv4 => _17;\n    debug v4_addr => _19;\n    debug one => _20;\n    debug two => _21;\n    debug three => _22;\n    debug four => _23;\n    debug group => _42;\n    debug g => _44;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_2);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = slice::<impl [u16]>::iter_mut(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = <slice::iter::IterMut<'_, u16> as iter::traits::iterator::Iterator>::enumerate(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = <iter::adapters::enumerate::Enumerate<slice::iter::IterMut<'_, u16>> as iter::traits::collect::IntoIterator>::into_iter(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = move _5;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_9);\n        _10 = &mut _8;\n        _9 = <iter::adapters::enumerate::Enumerate<slice::iter::IterMut<'_, u16>> as iter::traits::iterator::Iterator>::next(_10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _12 = (((_9 as variant#1).0: (usize, &mut u16)).0: usize);\n        StorageLive(_13);\n        _13 = move (((_9 as variant#1).0: (usize, &mut u16)).1: &mut u16);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = CheckedSub(_3, 1_usize);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 1_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &(*_2);\n        _45 = PtrMetadata(move _46);\n        StorageDead(_46);\n        _0 = (move _45, false);\n        StorageDead(_45);\n        goto -> bb28;\n    }\n    bb9: {\n        _15 = move (_16.0: usize);\n        _14 = Lt(_12, move _15);\n        switchInt(move _14) -> [0: bb22, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageLive(_17);\n        _17 = net::parser::Parser::<'_>::read_separator::<net::ip_addr::Ipv4Addr, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/net/parser.rs:191:57: 191:60}>(_1, ':', _12, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/net/parser.rs:191:57: 191:60}) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = discriminant(_17);\n        switchInt(move _18) -> [1: bb12, 0: bb21, otherwise: bb6];\n    }\n    bb12: {\n        StorageLive(_19);\n        _19 = ((_17 as variant#1).0: net::ip_addr::Ipv4Addr);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &_19;\n        _24 = net::ip_addr::Ipv4Addr::octets(move _25) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_25);\n        _20 = _24[0 of 4];\n        _21 = _24[1 of 4];\n        _22 = _24[2 of 4];\n        _23 = _24[3 of 4];\n        StorageDead(_24);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = [_20, _21];\n        _26 = num::<impl u16>::from_be_bytes(move _27) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        StorageLive(_28);\n        _29 = CheckedAdd(_12, 0_usize);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _12, 0_usize) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _28 = move (_29.0: usize);\n        _30 = &raw const (fake) (*_2);\n        _31 = PtrMetadata(move _30);\n        _32 = Lt(_28, _31);\n        assert(move _32, \"index out of bounds: the length is {} but the index is {}\", move _31, _28) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        (*_2)[_28] = move _26;\n        StorageDead(_26);\n        StorageDead(_28);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = [_22, _23];\n        _33 = num::<impl u16>::from_be_bytes(move _34) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_34);\n        StorageLive(_35);\n        _36 = CheckedAdd(_12, 1_usize);\n        assert(!move (_36.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _12, 1_usize) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _35 = move (_36.0: usize);\n        _37 = &raw const (fake) (*_2);\n        _38 = PtrMetadata(move _37);\n        _39 = Lt(_35, _38);\n        assert(move _39, \"index out of bounds: the length is {} but the index is {}\", move _38, _35) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        (*_2)[_35] = move _33;\n        StorageDead(_33);\n        StorageDead(_35);\n        StorageLive(_40);\n        _41 = CheckedAdd(_12, 2_usize);\n        assert(!move (_41.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _12, 2_usize) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _40 = move (_41.0: usize);\n        _0 = (move _40, true);\n        StorageDead(_40);\n        StorageDead(_19);\n        StorageDead(_17);\n        StorageDead(_14);\n        goto -> bb27;\n    }\n    bb21: {\n        StorageDead(_17);\n        goto -> bb23;\n    }\n    bb22: {\n        StorageDead(_15);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_14);\n        StorageLive(_42);\n        _42 = net::parser::Parser::<'_>::read_separator::<u16, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/net/parser.rs:201:54: 201:57}>(_1, ':', _12, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/net/parser.rs:201:54: 201:57}) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _43 = discriminant(_42);\n        switchInt(move _43) -> [0: bb25, 1: bb26, otherwise: bb6];\n    }\n    bb25: {\n        _0 = (_12, false);\n        StorageDead(_42);\n        goto -> bb27;\n    }\n    bb26: {\n        _44 = ((_42 as variant#1).0: u16);\n        (*_13) = _44;\n        StorageDead(_42);\n        StorageDead(_13);\n        StorageDead(_9);\n        goto -> bb4;\n    }\n    bb27: {\n        StorageDead(_13);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_5);\n        goto -> bb28;\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": " Read a chunk of an IPv6 address into `groups`. Returns the number\n of groups read, along with a bool indicating if an embedded\n trailing IPv4 address was read. Specifically, read a series of\n colon-separated IPv6 groups (0x0000 - 0xFFFF), with an optional\n trailing embedded IPv4 address.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}