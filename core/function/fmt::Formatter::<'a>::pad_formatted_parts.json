{
  "name": "fmt::Formatter::<'a>::pad_formatted_parts",
  "safe": false,
  "callees": {
    "fmt::Formatter::<'a>::write_formatted_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "num::fmt::Formatted": "ImmutableAsArgument",
        "result::Result": "Constructor"
      }
    },
    "clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::sign_aware_zero_pad": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the `0` flag was specified.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         assert!(formatter.sign_aware_zero_pad());\n         assert_eq!(formatter.width(), Some(4));\n         // We ignore the formatter's options.\n         write!(formatter, \"{}\", self.0)\n     }\n }\n\n assert_eq!(format!(\"{:04}\", Foo(23)), \"23\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument"
      }
    },
    "fmt::Write::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a string slice into this writer, returning whether the write\n succeeded.\n\n This method can only succeed if the entire string slice was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`std::fmt::Error`][Error] on error.\n\n The purpose of that error is to abort the formatting operation when the underlying\n destination encounters some error preventing it from accepting more text;\n in particular, it does not communicate any information about *what* error occurred.\n It should generally be propagated rather than handled, at least when implementing\n formatting traits.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n     f.write_str(s)\n }\n\n let mut buf = String::new();\n writer(&mut buf, \"hola\")?;\n assert_eq!(&buf, \"hola\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "num::<impl u16>::saturating_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer subtraction. Computes `self - rhs`, saturating\n at the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "fmt::FormattingOptions::fill": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the fill character.\n\n The optional fill character and alignment is provided normally in\n conjunction with the width parameter. This indicates that if the value\n being formatted is smaller than width some extra characters will be\n printed around it.\n",
      "adt": {
        "fmt::FormattingOptions": "MutableAsArgument"
      }
    },
    "fmt::FormattingOptions::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets or removes the alignment.\n\n The alignment specifies how the value being formatted should be\n positioned if it is smaller than the width of the formatter.\n",
      "adt": {
        "fmt::FormattingOptions": "MutableAsArgument"
      }
    },
    "num::fmt::Formatted::<'a>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact byte length of combined formatted result.\n",
      "adt": {
        "num::fmt::Formatted": "ImmutableAsArgument"
      }
    },
    "convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::padding": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes the pre-padding and returns the unwritten post-padding.\n\n Callers are responsible for ensuring post-padding is written after the\n thing that is being padded.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor",
        "fmt::PostPadding": "Constructor"
      }
    },
    "fmt::PostPadding::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes this post padding.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "fmt::Formatter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "num::fmt::Formatted": [
      "Ref",
      "Plain",
      "Unknown([Field(0, Ty { id: 81, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 84, kind: RigidTy(Str) }, Not)) })])"
    ],
    "result::Result": [
      "Plain"
    ],
    "fmt::FormattingOptions": [
      "Plain",
      "MutRef"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11599, kind: RigidTy(Adt(AdtDef(DefId { id: 27980, name: \"fmt::PostPadding\" }), GenericArgs([]))) })])"
    ],
    "fmt::Alignment": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ],
    "fmt::PostPadding": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::fmt::Formatter::<'a>::pad_formatted_parts"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:1980:5: 2019:6",
  "src": "unsafe fn pad_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n        if self.options.width == 0 {\n            // this is the common case and we take a shortcut\n            // SAFETY: Per the precondition.\n            unsafe { self.write_formatted_parts(formatted) }\n        } else {\n            // for the sign-aware zero padding, we render the sign first and\n            // behave as if we had no sign from the beginning.\n            let mut formatted = formatted.clone();\n            let mut width = self.options.width;\n            let old_options = self.options;\n            if self.sign_aware_zero_pad() {\n                // a sign always goes first\n                let sign = formatted.sign;\n                self.buf.write_str(sign)?;\n\n                // remove the sign from the formatted parts\n                formatted.sign = \"\";\n                width = width.saturating_sub(sign.len() as u16);\n                self.options.fill('0').align(Some(Alignment::Right));\n            }\n\n            // remaining parts go through the ordinary padding process.\n            let len = formatted.len();\n            let ret = if usize::from(width) <= len {\n                // no padding\n                // SAFETY: Per the precondition.\n                unsafe { self.write_formatted_parts(&formatted) }\n            } else {\n                let post_padding = self.padding(width - len as u16, Alignment::Right)?;\n                // SAFETY: Per the precondition.\n                unsafe {\n                    self.write_formatted_parts(&formatted)?;\n                }\n                post_padding.write(self)\n            };\n            self.options = old_options;\n            ret\n        }\n    }",
  "mir": "fn fmt::Formatter::<'a>::pad_formatted_parts(_1: &mut fmt::Formatter<'_>, _2: &num::fmt::Formatted<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: u16;\n    let mut _4: num::fmt::Formatted<'_>;\n    let mut _5: u16;\n    let  _6: fmt::FormattingOptions;\n    let mut _7: bool;\n    let mut _8: &fmt::Formatter<'_>;\n    let  _9: &str;\n    let mut _10: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _11: result::Result<(), fmt::Error>;\n    let mut _12: isize;\n    let mut _13: u16;\n    let mut _14: u16;\n    let mut _15: u16;\n    let mut _16: usize;\n    let  _17: &mut fmt::FormattingOptions;\n    let mut _18: &mut fmt::FormattingOptions;\n    let mut _19: &mut fmt::FormattingOptions;\n    let mut _20: option::Option<fmt::Alignment>;\n    let mut _21: fmt::Alignment;\n    let  _22: usize;\n    let mut _23: &num::fmt::Formatted<'_>;\n    let  _24: result::Result<(), fmt::Error>;\n    let mut _25: bool;\n    let mut _26: usize;\n    let mut _27: u16;\n    let  _28: &num::fmt::Formatted<'_>;\n    let mut _29: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>, fmt::PostPadding>;\n    let mut _30: result::Result<fmt::PostPadding, fmt::Error>;\n    let mut _31: u16;\n    let mut _32: u16;\n    let mut _33: u16;\n    let mut _34: (u16, bool);\n    let mut _35: fmt::Alignment;\n    let mut _36: isize;\n    let  _37: fmt::PostPadding;\n    let mut _38: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _39: result::Result<(), fmt::Error>;\n    let  _40: &num::fmt::Formatted<'_>;\n    let mut _41: isize;\n    let mut _42: &mut dyn fmt::Write;\n    debug self => _1;\n    debug formatted => _2;\n    debug formatted => _4;\n    debug width => _5;\n    debug old_options => _6;\n    debug sign => _9;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug len => _22;\n    debug ret => _24;\n    debug post_padding => _37;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => _37;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        _3 = (((*_1).0: fmt::FormattingOptions).1: u16);\n        switchInt(move _3) -> [0: bb1, otherwise: bb3];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = fmt::Formatter::<'_>::write_formatted_parts(_1, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        goto -> bb37;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = <num::fmt::Formatted<'_> as clone::Clone>::clone(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_5);\n        _5 = (((*_1).0: fmt::FormattingOptions).1: u16);\n        _6 = ((*_1).0: fmt::FormattingOptions);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_1);\n        _7 = fmt::Formatter::<'_>::sign_aware_zero_pad(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _7) -> [0: bb17, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_8);\n        _9 = (_4.0: &str);\n        StorageLive(_10);\n        StorageLive(_11);\n        _42 = ((*_1).1: &mut dyn fmt::Write);\n        _11 = <dyn fmt::Write as fmt::Write>::write_str(_42, _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb10, 1: bb11, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        StorageDead(_10);\n        (_4.0: &str) = \"\";\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _5;\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = str::<impl str>::len(_9) -> [return: bb13, unwind unreachable];\n    }\n    bb11: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_10);\n        StorageDead(_7);\n        goto -> bb39;\n    }\n    bb13: {\n        _15 = move _16 as u16;\n        StorageDead(_16);\n        _13 = num::<impl u16>::saturating_sub(move _14, move _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _5 = move _13;\n        StorageDead(_13);\n        StorageLive(_17);\n        StorageLive(_19);\n        _19 = &mut ((*_1).0: fmt::FormattingOptions);\n        _18 = fmt::FormattingOptions::fill(move _19, '0') -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = fmt::Alignment::Right;\n        _20 = option::Option::Some(move _21);\n        StorageDead(_21);\n        _17 = fmt::FormattingOptions::align(_18, move _20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_20);\n        StorageDead(_17);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_8);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_7);\n        StorageLive(_23);\n        _23 = &_4;\n        _22 = num::fmt::Formatted::<'_>::len(move _23) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _5;\n        _26 = <usize as convert::From<u16>>::from(move _27) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_27);\n        _25 = Le(move _26, _22);\n        switchInt(move _25) -> [0: bb23, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_26);\n        _28 = &_4;\n        _24 = fmt::Formatter::<'_>::write_formatted_parts(_1, _28) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        goto -> bb36;\n    }\n    bb23: {\n        StorageDead(_26);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _5;\n        StorageLive(_33);\n        _33 = _22 as u16;\n        _34 = CheckedSub(_32, _33);\n        assert(!move (_34.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _32, move _33) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _31 = move (_34.0: u16);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_35);\n        _35 = fmt::Alignment::Right;\n        _30 = fmt::Formatter::<'_>::padding(_1, move _31, move _35) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageDead(_31);\n        _29 = <result::Result<fmt::PostPadding, fmt::Error> as ops::try_trait::Try>::branch(move _30) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_30);\n        _36 = discriminant(_29);\n        switchInt(move _36) -> [0: bb27, 1: bb28, otherwise: bb9];\n    }\n    bb27: {\n        _37 = move ((_29 as variant#0).0: fmt::PostPadding);\n        StorageDead(_29);\n        StorageLive(_38);\n        StorageLive(_39);\n        _40 = &_4;\n        _39 = fmt::Formatter::<'_>::write_formatted_parts(_1, _40) -> [return: bb30, unwind unreachable];\n    }\n    bb28: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_29);\n        goto -> bb38;\n    }\n    bb30: {\n        _38 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _39) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_39);\n        _41 = discriminant(_38);\n        switchInt(move _41) -> [0: bb32, 1: bb33, otherwise: bb9];\n    }\n    bb32: {\n        StorageDead(_38);\n        _24 = fmt::PostPadding::write(_37, _1) -> [return: bb35, unwind unreachable];\n    }\n    bb33: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_38);\n        goto -> bb38;\n    }\n    bb35: {\n        goto -> bb36;\n    }\n    bb36: {\n        StorageDead(_25);\n        ((*_1).0: fmt::FormattingOptions) = _6;\n        _0 = _24;\n        StorageDead(_24);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb37;\n    }\n    bb37: {\n        goto -> bb40;\n    }\n    bb38: {\n        StorageDead(_25);\n        StorageDead(_24);\n        goto -> bb39;\n    }\n    bb39: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb40;\n    }\n    bb40: {\n        return;\n    }\n}\n",
  "doc": " Takes the formatted parts and applies the padding.\n\n Assumes that the caller already has rendered the parts with required precision,\n so that `self.precision` can be ignored.\n\n # Safety\n\n Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}