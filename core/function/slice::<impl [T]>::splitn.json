{
  "name": "slice::<impl [T]>::splitn",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over subslices separated by elements that match\n `pred`. The matched element is not contained in the subslices.\n\n # Examples\n\n ```\n let slice = [10, 40, 33, 20];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10, 40]);\n assert_eq!(iter.next().unwrap(), &[20]);\n assert!(iter.next().is_none());\n ```\n\n If the first element is matched, an empty slice will be the first item\n returned by the iterator. Similarly, if the last element in the slice\n is matched, an empty slice will be the last item returned by the\n iterator:\n\n ```\n let slice = [10, 40, 33];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10, 40]);\n assert_eq!(iter.next().unwrap(), &[]);\n assert!(iter.next().is_none());\n ```\n\n If two matched elements are directly adjacent, an empty slice will be\n present between them:\n\n ```\n let slice = [10, 6, 33, 20];\n let mut iter = slice.split(|num| num % 3 == 0);\n\n assert_eq!(iter.next().unwrap(), &[10]);\n assert_eq!(iter.next().unwrap(), &[]);\n assert_eq!(iter.next().unwrap(), &[20]);\n assert!(iter.next().is_none());\n ```\n",
      "adt": {
        "slice::iter::Split": "Constructor"
      }
    },
    "slice::iter::SplitN::<'a, T, P>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "slice::iter::SplitN": "Constructor"
      }
    }
  },
  "adts": {
    "slice::iter::Split": [
      "Plain"
    ],
    "slice::iter::SplitN": [
      "Plain"
    ]
  },
  "path": 1327,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:2413:5: 2418:6",
  "src": "pub fn splitn<F>(&self, n: usize, pred: F) -> SplitN<'_, T, F>\n    where\n        F: FnMut(&T) -> bool,\n    {\n        SplitN::new(self.split(pred), n)\n    }",
  "mir": "fn slice::<impl [T]>::splitn(_1: &[T], _2: usize, _3: F) -> slice::iter::SplitN<'_, T, F> {\n    let mut _0: slice::iter::SplitN<'_, T, F>;\n    let mut _4: slice::iter::Split<'_, T, F>;\n    debug self => _1;\n    debug n => _2;\n    debug pred => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = slice::<impl [T]>::split::<F>(_1, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = slice::iter::SplitN::<'_, T, F>::new(move _4, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Returns an iterator over subslices separated by elements that match\n `pred`, limited to returning at most `n` items. The matched element is\n not contained in the subslices.\n\n The last element returned, if any, will contain the remainder of the\n slice.\n\n # Examples\n\n Print the slice split once by numbers divisible by 3 (i.e., `[10, 40]`,\n `[20, 60, 50]`):\n\n ```\n let v = [10, 40, 30, 20, 60, 50];\n\n for group in v.splitn(2, |num| *num % 3 == 0) {\n     println!(\"{group:?}\");\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}