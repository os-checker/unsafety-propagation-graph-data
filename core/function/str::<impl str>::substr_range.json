{
  "name": "str::<impl str>::substr_range",
  "safe": true,
  "callees": {
    "str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::subslice_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the range of indices that a subslice points to.\n\n Returns `None` if `subslice` does not point within the slice or if it is not aligned with the\n elements in the slice.\n\n This method **does not compare elements**. Instead, this method finds the location in the slice that\n `subslice` was obtained from. To find the index of a subslice via comparison, instead use\n [`.windows()`](slice::windows)[`.position()`](crate::iter::Iterator::position).\n\n This method is useful for extending slice iterators like [`slice::split`].\n\n Note that this may return a false positive (either `Some(0..0)` or `Some(self.len()..self.len())`)\n if `subslice` has a length of zero and points to the beginning or end of another, separate, slice.\n\n # Panics\n Panics if `T` is zero-sized.\n\n # Examples\n Basic usage:\n ```\n #![feature(substr_range)]\n\n let nums = &[0, 5, 10, 0, 0, 5];\n\n let mut iter = nums\n     .split(|t| *t == 0)\n     .map(|n| nums.subslice_range(n).unwrap());\n\n assert_eq!(iter.next(), Some(0..0));\n assert_eq!(iter.next(), Some(1..3));\n assert_eq!(iter.next(), Some(4..4));\n assert_eq!(iter.next(), Some(5..6));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": 3142,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:3114:5: 3116:6",
  "src": "pub fn substr_range(&self, substr: &str) -> Option<Range<usize>> {\n        self.as_bytes().subslice_range(substr.as_bytes())\n    }",
  "mir": "fn str::<impl str>::substr_range(_1: &str, _2: &str) -> option::Option<ops::range::Range<usize>> {\n    let mut _0: option::Option<ops::range::Range<usize>>;\n    let  _3: &[u8];\n    let  _4: &[u8];\n    debug self => _1;\n    debug substr => _2;\n    bb0: {\n        _3 = str::<impl str>::as_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = str::<impl str>::as_bytes(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = slice::<impl [u8]>::subslice_range(_3, _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        return;\n    }\n}\n",
  "doc": " Returns the range that a substring points to.\n\n Returns `None` if `substr` does not point within `self`.\n\n Unlike [`str::find`], **this does not search through the string**.\n Instead, it uses pointer arithmetic to find where in the string\n `substr` is derived from.\n\n This is useful for extending [`str::split`] and similar methods.\n\n Note that this method may return false positives (typically either\n `Some(0..0)` or `Some(self.len()..self.len())`) if `substr` is a\n zero-length `str` that points at the beginning or end of another,\n independent, `str`.\n\n # Examples\n ```\n #![feature(substr_range)]\n\n let data = \"a, b, b, a\";\n let mut iter = data.split(\", \").map(|s| data.substr_range(s).unwrap());\n\n assert_eq!(iter.next(), Some(0..1));\n assert_eq!(iter.next(), Some(3..4));\n assert_eq!(iter.next(), Some(6..7));\n assert_eq!(iter.next(), Some(9..10));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}