{
  "name": "array::<impl [T; N]>::map",
  "safe": true,
  "callees": {
    "ops::try_trait::NeverShortCircuit::<T>::wrap_mut_1": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a unary function to produce one that wraps the output into a `NeverShortCircuit`.\n\n This is useful for implementing infallible functions in terms of the `try_` ones,\n without accidentally capturing extra generic parameters in a closure.\n",
      "adt": {
        "ops::try_trait::Wrapped": "Constructor"
      }
    },
    "array::<impl [T; N]>::try_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A fallible function `f` applied to each element on array `self` in order to\n return an array the same size as `self` or the first error encountered.\n\n The return type of this function depends on the return type of the closure.\n If you return `Result<T, E>` from the closure, you'll get a `Result<[T; N], E>`.\n If you return `Option<T>` from the closure, you'll get an `Option<[T; N]>`.\n\n # Examples\n\n ```\n #![feature(array_try_map)]\n\n let a = [\"1\", \"2\", \"3\"];\n let b = a.try_map(|v| v.parse::<u32>()).unwrap().map(|v| v + 1);\n assert_eq!(b, [2, 3, 4]);\n\n let a = [\"1\", \"2a\", \"3\"];\n let b = a.try_map(|v| v.parse::<u32>());\n assert!(b.is_err());\n\n use std::num::NonZero;\n\n let z = [1, 2, 0, 3, 4];\n assert_eq!(z.try_map(NonZero::new), None);\n\n let a = [1, 2, 3];\n let b = a.try_map(NonZero::new);\n let c = b.map(|x| x.map(NonZero::get));\n assert_eq!(c, Some(a));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::try_trait::Wrapped": [
      "Plain"
    ],
    "ops::try_trait::NeverShortCircuit": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4318, kind: RigidTy(Array(Ty { id: 3822, kind: Param(ParamTy { index: 3, name: \"U\" }) }, TyConst { kind: Param(ParamConst { index: 1, name: \"N\" }), id: TyConstId(37, ThreadLocalIndex) })) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::array::<impl [T; N]>::map"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/mod.rs:554:5: 561:6",
  "src": "pub const fn map<F, U>(self, f: F) -> [U; N]\n    where\n        F: [const] FnMut(T) -> U + [const] Destruct,\n        U: [const] Destruct,\n        T: [const] Destruct,\n    {\n        self.try_map(NeverShortCircuit::wrap_mut_1(f)).0\n    }",
  "mir": "fn array::<impl [T; N]>::map(_1: [T; N], _2: F) -> [U; N] {\n    let mut _0: [U; N];\n    let mut _3: ops::try_trait::NeverShortCircuit<[U; N]>;\n    let mut _4: ops::try_trait::Wrapped<U, T, F>;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ops::try_trait::NeverShortCircuit::<U>::wrap_mut_1::<T, F>(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = array::<impl [T; N]>::try_map::<ops::try_trait::NeverShortCircuit<U>, ops::try_trait::Wrapped<U, T, F>>(_1, move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _0 = move (_3.0: [U; N]);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns an array of the same size as `self`, with function `f` applied to each element\n in order.\n\n If you don't necessarily need a new fixed-size array, consider using\n [`Iterator::map`] instead.\n\n\n # Note on performance and stack usage\n\n Unfortunately, usages of this method are currently not always optimized\n as well as they could be. This mainly concerns large arrays, as mapping\n over small arrays seem to be optimized just fine. Also note that in\n debug mode (i.e. without any optimizations), this method can use a lot\n of stack space (a few times the size of the array or more).\n\n Therefore, in performance-critical code, try to avoid using this method\n on large arrays or check the emitted code. Also try to avoid chained\n maps (e.g. `arr.map(...).map(...)`).\n\n In many cases, you can instead use [`Iterator::map`] by calling `.iter()`\n or `.into_iter()` on your array. `[T; N]::map` is only necessary if you\n really need a new array of the same size as the result. Rust's lazy\n iterators tend to get optimized very well.\n\n\n # Examples\n\n ```\n let x = [1, 2, 3];\n let y = x.map(|v| v + 1);\n assert_eq!(y, [2, 3, 4]);\n\n let x = [1, 2, 3];\n let mut temp = 0;\n let y = x.map(|v| { temp += 1; v * temp });\n assert_eq!(y, [1, 4, 9]);\n\n let x = [\"Ferris\", \"Bueller's\", \"Day\", \"Off\"];\n let y = x.map(|v| v.len());\n assert_eq!(y, [6, 9, 3, 3]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}