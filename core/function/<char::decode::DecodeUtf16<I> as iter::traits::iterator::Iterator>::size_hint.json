{
  "name": "<char::decode::DecodeUtf16<I> as iter::traits::iterator::Iterator>::size_hint",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::size_hint": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the bounds on the remaining length of the iterator.\n\n Specifically, `size_hint()` returns a tuple where the first element\n is the lower bound, and the second element is the upper bound.\n\n The second half of the tuple that is returned is an <code>[Option]<[usize]></code>.\n A [`None`] here means that either there is no known upper bound, or the\n upper bound is larger than [`usize`].\n\n # Implementation notes\n\n It is not enforced that an iterator implementation yields the declared\n number of elements. A buggy iterator may yield less than the lower bound\n or more than the upper bound of elements.\n\n `size_hint()` is primarily intended to be used for optimizations such as\n reserving space for the elements of the iterator, but must not be\n trusted to e.g., omit bounds checks in unsafe code. An incorrect\n implementation of `size_hint()` should not lead to memory safety\n violations.\n\n That said, the implementation should provide a correct estimation,\n because otherwise it would be a violation of the trait's protocol.\n\n The default implementation returns <code>(0, [None])</code> which is correct for any\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n let mut iter = a.iter();\n\n assert_eq!((3, Some(3)), iter.size_hint());\n let _ = iter.next();\n assert_eq!((2, Some(2)), iter.size_hint());\n ```\n\n A more complex example:\n\n ```\n // The even numbers in the range of zero to nine.\n let iter = (0..10).filter(|x| x % 2 == 0);\n\n // We might iterate from zero to ten times. Knowing that it's five\n // exactly wouldn't be possible without executing filter().\n assert_eq!((0, Some(10)), iter.size_hint());\n\n // Let's add five more numbers with chain()\n let iter = (0..10).filter(|x| x % 2 == 0).chain(15..20);\n\n // now both bounds are increased by five\n assert_eq!((5, Some(15)), iter.size_hint());\n ```\n\n Returning `None` for an upper bound:\n\n ```\n // an infinite iterator has no upper bound\n // and the maximum possible lower bound\n let iter = 0..;\n\n assert_eq!((usize::MAX, None), iter.size_hint());\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl u16>::is_utf16_surrogate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks if the value is a Unicode surrogate code point, which are disallowed values for [`char`].\n\n # Examples\n\n ```\n #![feature(utf16_extra)]\n\n let low_non_surrogate = 0xA000u16;\n let low_surrogate = 0xD800u16;\n let high_surrogate = 0xDC00u16;\n let high_non_surrogate = 0xE000u16;\n\n assert!(!low_non_surrogate.is_utf16_surrogate());\n assert!(low_surrogate.is_utf16_surrogate());\n assert!(high_surrogate.is_utf16_surrogate());\n assert!(!high_non_surrogate.is_utf16_surrogate());\n ```\n",
      "adt": {}
    },
    "cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "num::<impl usize>::div_ceil": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::and_then": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n wrapped value and returns the result.\n\n Some languages call this operation flatmap.\n\n # Examples\n\n ```\n fn sq_then_to_string(x: u32) -> Option<String> {\n     x.checked_mul(x).map(|sq| sq.to_string())\n }\n\n assert_eq!(Some(2).and_then(sq_then_to_string), Some(4.to_string()));\n assert_eq!(Some(1_000_000).and_then(sq_then_to_string), None); // overflowed!\n assert_eq!(None.and_then(sq_then_to_string), None);\n ```\n\n Often used to chain fallible operations that may return [`None`].\n\n ```\n let arr_2d = [[\"A0\", \"A1\"], [\"B0\", \"B1\"]];\n\n let item_0_1 = arr_2d.get(0).and_then(|row| row.get(1));\n assert_eq!(item_0_1, Some(&\"A1\"));\n\n let item_2_0 = arr_2d.get(2).and_then(|row| row.get(0));\n assert_eq!(item_2_0, None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "char::decode::DecodeUtf16": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 518, kind: RigidTy(Adt(AdtDef(DefId { id: 24532, name: \"option::Option\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Ref"
    ]
  },
  "path": 4865,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/decode.rs:76:5: 106:6",
  "src": "fn size_hint(&self) -> (usize, Option<usize>) {\n        let (low, high) = self.iter.size_hint();\n\n        let (low_buf, high_buf) = match self.buf {\n            // buf is empty, no additional elements from it.\n            None => (0, 0),\n            // `u` is a non surrogate, so it's always an additional character.\n            Some(u) if !u.is_utf16_surrogate() => (1, 1),\n            // `u` is a leading surrogate (it can never be a trailing surrogate and\n            // it's a surrogate due to the previous branch) and `self.iter` is empty.\n            //\n            // `u` can't be paired, since the `self.iter` is empty,\n            // so it will always become an additional element (error).\n            Some(_u) if high == Some(0) => (1, 1),\n            // `u` is a leading surrogate and `iter` may be non-empty.\n            //\n            // `u` can either pair with a trailing surrogate, in which case no additional elements\n            // are produced, or it can become an error, in which case it's an additional character (error).\n            Some(_u) => (0, 1),\n        };\n\n        // `self.iter` could contain entirely valid surrogates (2 elements per\n        // char), or entirely non-surrogates (1 element per char).\n        //\n        // On odd lower bound, at least one element must stay unpaired\n        // (with other elements from `self.iter`), so we round up.\n        let low = low.div_ceil(2) + low_buf;\n        let high = high.and_then(|h| h.checked_add(high_buf));\n\n        (low, high)\n    }",
  "mir": "fn <char::decode::DecodeUtf16<I> as iter::traits::iterator::Iterator>::size_hint(_1: &char::decode::DecodeUtf16<I>) -> (usize, option::Option<usize>) {\n    let mut _0: (usize, option::Option<usize>);\n    let  _2: usize;\n    let  _3: option::Option<usize>;\n    let mut _4: (usize, option::Option<usize>);\n    let mut _5: &I;\n    let  _6: usize;\n    let  _7: usize;\n    let mut _8: (usize, usize);\n    let mut _9: isize;\n    let  _10: u16;\n    let  _11: &u16;\n    let mut _12: bool;\n    let mut _13: u16;\n    let  _14: u16;\n    let  _15: &u16;\n    let mut _16: bool;\n    let mut _17: &option::Option<usize>;\n    let mut _18: &option::Option<usize>;\n    let  _19: u16;\n    let  _20: usize;\n    let mut _21: usize;\n    let mut _22: (usize, bool);\n    let  _23: option::Option<usize>;\n    let mut _24: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/decode.rs:103:34: 103:37};\n    let mut _25: &usize;\n    debug self => _1;\n    debug low => _2;\n    debug high => _3;\n    debug low_buf => _6;\n    debug high_buf => _7;\n    debug u => _10;\n    debug u => _11;\n    debug _u => _14;\n    debug _u => _15;\n    debug _u => _19;\n    debug low => _20;\n    debug high => _23;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: I);\n        _4 = <I as iter::traits::iterator::Iterator>::size_hint(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _2 = (_4.0: usize);\n        _3 = (_4.1: option::Option<usize>);\n        StorageDead(_4);\n        StorageLive(_8);\n        _9 = discriminant(((*_1).1: option::Option<u16>));\n        switchInt(move _9) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_11);\n        _11 = &((((*_1).1: option::Option<u16>) as variant#1).0: u16);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (*_11);\n        _12 = num::<impl u16>::is_utf16_surrogate(move _13) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        _8 = (0_usize, 0_usize);\n        goto -> bb11;\n    }\n    bb5: {\n        switchInt(move _12) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = &((((*_1).1: option::Option<u16>) as variant#1).0: u16);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_3;\n        StorageLive(_18);\n        _18 = <char::decode::DecodeUtf16<I> as iter::traits::iterator::Iterator>::size_hint::promoted[0];\n        _16 = <option::Option<usize> as cmp::PartialEq>::eq(move _17, move _18) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_10);\n        _10 = ((((*_1).1: option::Option<u16>) as variant#1).0: u16);\n        _8 = (1_usize, 1_usize);\n        StorageDead(_10);\n        StorageDead(_11);\n        goto -> bb11;\n    }\n    bb8: {\n        switchInt(move _16) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_14);\n        _14 = ((((*_1).1: option::Option<u16>) as variant#1).0: u16);\n        _8 = (1_usize, 1_usize);\n        StorageDead(_14);\n        StorageDead(_15);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_19);\n        _19 = ((((*_1).1: option::Option<u16>) as variant#1).0: u16);\n        _8 = (0_usize, 1_usize);\n        StorageDead(_19);\n        goto -> bb11;\n    }\n    bb11: {\n        _6 = (_8.0: usize);\n        StorageLive(_7);\n        _7 = (_8.1: usize);\n        StorageDead(_8);\n        StorageLive(_21);\n        _21 = num::<impl usize>::div_ceil(_2, 2_usize) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _22 = CheckedAdd(_21, _6);\n        assert(!move (_22.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _21, _6) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_22.0: usize);\n        StorageDead(_21);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &_7;\n        _24 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/decode.rs:103:34: 103:37}(move _25);\n        StorageDead(_25);\n        _23 = option::Option::<usize>::and_then::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/decode.rs:103:34: 103:37}>(_3, move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        _0 = (_20, _23);\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}