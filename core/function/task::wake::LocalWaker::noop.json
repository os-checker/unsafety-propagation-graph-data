{
  "name": "task::wake::LocalWaker::noop",
  "safe": true,
  "callees": {},
  "adts": {
    "task::wake::LocalWaker": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::task::wake::LocalWaker::noop"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/task/wake.rs:884:5: 887:6",
  "src": "pub const fn noop() -> &'static LocalWaker {\n        const WAKER: &LocalWaker = &LocalWaker { waker: RawWaker::NOOP };\n        WAKER\n    }",
  "mir": "fn task::wake::LocalWaker::noop() -> &task::wake::LocalWaker {\n    let mut _0: &task::wake::LocalWaker;\n    bb0: {\n        _0 = task::wake::LocalWaker::noop::WAKER;\n        return;\n    }\n}\n",
  "doc": " Returns a reference to a `LocalWaker` that does nothing when used.\n\n This is mostly useful for writing tests that need a [`Context`] to poll\n some futures, but are not expecting those futures to wake the waker or\n do not need to do anything specific if it happens.\n\n More generally, using `LocalWaker::noop()` to poll a future\n means discarding the notification of when the future should be polled again,\n So it should only be used when such a notification will not be needed to make progress.\n\n If an owned `LocalWaker` is needed, `clone()` this one.\n\n # Examples\n\n ```\n #![feature(local_waker)]\n use std::future::Future;\n use std::task::{ContextBuilder, LocalWaker, Waker, Poll};\n\n let mut cx = ContextBuilder::from_waker(Waker::noop())\n     .local_waker(LocalWaker::noop())\n     .build();\n\n let mut future = Box::pin(async { 10 });\n assert_eq!(future.as_mut().poll(&mut cx), Poll::Ready(10));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}