{
  "name": "<escape::EscapeIterInner<N, escape::MaybeEscaped> as fmt::Display>::fmt",
  "safe": true,
  "callees": {
    "escape::EscapeIterInner::<N, ESCAPING>::to_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a `char` if `self.data` contains one in its `literal` variant.\n",
      "adt": {
        "escape::EscapeIterInner": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "fmt::Write::write_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "escape::EscapeIterInner::<N, ESCAPING>::to_str_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the printable ASCII characters in the `escape_seq` variant of `self.data`\n as a string.\n\n # Safety\n\n - `self.data` must contain printable ASCII characters in its `escape_seq` variant.\n - `self.alive` must be a valid range for `self.data.escape_seq`.\n",
      "adt": {
        "escape::EscapeIterInner": "ImmutableAsArgument"
      }
    },
    "fmt::Formatter::<'a>::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data to the underlying buffer contained within this\n formatter.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_str(\"Foo\")\n         // This is equivalent to:\n         // write!(formatter, \"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo}\"), \"Foo\");\n assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "escape::EscapeIterInner": [
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4458, kind: RigidTy(Char) })])"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<escape::EscapeIterInner<N, escape::MaybeEscaped> as fmt::Display>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/escape.rs:349:5: 358:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        if let Some(c) = self.to_char() {\n            return f.write_char(c);\n        }\n\n        // SAFETY: At this point, `self.data` must contain printable ASCII\n        //         characters in its `escape_seq` variant, and `self.alive`\n        //         is guaranteed to be a valid range for `self.data`.\n        f.write_str(unsafe { self.to_str_unchecked() })\n    }",
  "mir": "fn <escape::EscapeIterInner<N, escape::MaybeEscaped> as fmt::Display>::fmt(_1: &escape::EscapeIterInner<N, escape::MaybeEscaped>, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: option::Option<char>;\n    let mut _4: isize;\n    let  _5: char;\n    let  _6: &str;\n    debug self => _1;\n    debug f => _2;\n    debug c => _5;\n    bb0: {\n        StorageLive(_3);\n        _3 = escape::EscapeIterInner::<N, escape::MaybeEscaped>::to_char(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = discriminant(_3);\n        switchInt(move _4) -> [1: bb2, 0: bb4, otherwise: bb8];\n    }\n    bb2: {\n        _5 = ((_3 as variant#1).0: char);\n        _0 = <fmt::Formatter<'_> as fmt::Write>::write_char(_2, _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        goto -> bb7;\n    }\n    bb4: {\n        StorageDead(_3);\n        _6 = escape::EscapeIterInner::<N, escape::MaybeEscaped>::to_str_unchecked(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = fmt::Formatter::<'_>::write_str(_2, _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n    bb8: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}