{
  "name": "num::<impl i8>::wrapping_abs",
  "safe": true,
  "callees": {
    "num::<impl i8>::is_negative": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is negative and `false` if the number is zero or\n positive.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl i8>::wrapping_neg": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n of the type.\n\n The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n is the negative minimal value for the type); this is a positive value that is too large to represent\n in the type. In such a case, this function returns `MIN` itself.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl i8>::wrapping_abs"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:2363:9: 2369:10",
  "src": "pub const fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n             } else {\n                 self\n             }\n        }",
  "mir": "fn num::<impl i8>::wrapping_abs(_1: i8) -> i8 {\n    let mut _0: i8;\n    let mut _2: bool;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = num::<impl i8>::is_negative(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        _0 = num::<impl i8>::wrapping_neg(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        goto -> bb5;\n    }\n    bb4: {\n        _0 = _1;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n the boundary of the type.\n\n The only case where such wrapping can occur is when one takes the absolute value of the negative\n minimal value for the type; this is a positive value that is too large to represent in the type. In\n such a case, this function returns `MIN` itself.\n\n # Examples\n\n ```\n assert_eq!((-128i8).wrapping_abs() as u8, 128);\n ```\n",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "unused_attributes"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* unused_attributes\n"
    ]
  }
}