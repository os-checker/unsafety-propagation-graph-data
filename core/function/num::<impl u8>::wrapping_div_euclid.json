{
  "name": "num::<impl u8>::wrapping_div_euclid",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl u8>::wrapping_div_euclid"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:2507:9: 2509:10",
  "src": "pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }",
  "mir": "fn num::<impl u8>::wrapping_div_euclid(_1: u8, _2: u8) -> u8 {\n    let mut _0: u8;\n    let mut _3: bool;\n    debug self => _1;\n    debug rhs => _2;\n    bb0: {\n        _3 = Eq(_2, 0_u8);\n        assert(!move _3, \"attempt to divide `{}` by zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Div(_1, _2);\n        return;\n    }\n}\n",
  "doc": " Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n\n Wrapped division on unsigned types is just normal division. There's\n no way wrapping could ever happen. This function exists so that all\n operations are accounted for in the wrapping operations. Since, for\n the positive integers, all common definitions of division are equal,\n this is exactly equal to `self.wrapping_div(rhs)`.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}