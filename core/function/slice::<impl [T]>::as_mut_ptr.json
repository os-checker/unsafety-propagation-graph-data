{
  "name": "slice::<impl [T]>::as_mut_ptr",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": 1234,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:756:5: 758:6",
  "src": "pub const fn as_mut_ptr(&mut self) -> *mut T {\n        self as *mut [T] as *mut T\n    }",
  "mir": "fn slice::<impl [T]>::as_mut_ptr(_1: &mut [T]) -> *mut T {\n    let mut _0: *mut T;\n    let mut _2: *mut [T];\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = &raw mut (*_1);\n        _0 = move _2 as *mut T;\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}