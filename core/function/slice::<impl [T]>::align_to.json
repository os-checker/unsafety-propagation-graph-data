{
  "name": "slice::<impl [T]>::align_to",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "ptr::align_offset": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "ptr_to_integer_transmute_in_consts"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* ptr_to_integer_transmute_in_consts\n"
        ]
      },
      "doc": " Calculate an element-offset that increases a pointer's alignment.\n\n Calculate an element-offset (not byte-offset) that when added to a given pointer `p`, increases `p`'s alignment to at least the given alignment `a`.\n\n # Safety\n `a` must be a power of two.\n\n # Notes\n This implementation has been carefully tailored to not panic. It is UB for this to panic.\n The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n constants.\n\n If we ever decide to make it possible to call the intrinsic with `a` that is not a\n power-of-two, it will probably be more prudent to just change to a naive implementation rather\n than trying to adapt this to accommodate that change.\n\n Any questions go to @nagisa.\n",
      "adt": {}
    },
    "slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::align_to_offsets": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Function to calculate lengths of the middle and trailing slice for `align_to{,_mut}`.\n",
      "adt": {}
    },
    "slice::raw::from_raw_parts": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for reads for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations. See [below](#incorrect-usage)\n       for an example incorrectly not taking this into account.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be mutated for the duration\n   of lifetime `'a`, except inside an `UnsafeCell`.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To\n prevent accidental misuse, it's suggested to tie the lifetime to whichever\n source lifetime is safe in the context, such as by providing a helper\n function taking the lifetime of a host value for the slice, or by explicit\n annotation.\n\n # Examples\n\n ```\n use std::slice;\n\n // manifest a slice for a single element\n let x = 42;\n let ptr = &x as *const _;\n let slice = unsafe { slice::from_raw_parts(ptr, 1) };\n assert_eq!(slice[0], 42);\n ```\n\n ### Incorrect usage\n\n The following `join_slices` function is **unsound** ⚠️\n\n ```rust,no_run\n use std::slice;\n\n fn join_slices<'a, T>(fst: &'a [T], snd: &'a [T]) -> &'a [T] {\n     let fst_end = fst.as_ptr().wrapping_add(fst.len());\n     let snd_start = snd.as_ptr();\n     assert_eq!(fst_end, snd_start, \"Slices must be contiguous!\");\n     unsafe {\n         // The assertion above ensures `fst` and `snd` are contiguous, but they might\n         // still be contained within _different allocations_, in which case\n         // creating this slice is undefined behavior.\n         slice::from_raw_parts(fst.as_ptr(), fst.len() + snd.len())\n     }\n }\n\n fn main() {\n     // `a` and `b` are different allocations...\n     let a = 42;\n     let b = 27;\n     // ... which may nevertheless be laid out contiguously in memory: | a | b |\n     let _ = join_slices(slice::from_ref(&a), slice::from_ref(&b)); // UB\n }\n ```\n\n ### FFI: Handling null pointers\n\n In languages such as C++, pointers to empty collections are not guaranteed to be non-null.\n When accepting such pointers, they have to be checked for null-ness to avoid undefined\n behavior.\n\n ```\n use std::slice;\n\n /// Sum the elements of an FFI slice.\n ///\n /// # Safety\n ///\n /// If ptr is not NULL, it must be correctly aligned and\n /// point to `len` initialized items of type `f32`.\n unsafe extern \"C\" fn sum_slice(ptr: *const f32, len: usize) -> f32 {\n     let data = if ptr.is_null() {\n         // `len` is assumed to be 0.\n         &[]\n     } else {\n         // SAFETY: see function docstring.\n         unsafe { slice::from_raw_parts(ptr, len) }\n     };\n     data.into_iter().sum()\n }\n\n // This could be the result of C++'s std::vector::data():\n let ptr = std::ptr::null();\n // And this could be std::vector::size():\n let len = 0;\n assert_eq!(unsafe { sum_slice(ptr, len) }, 0.0);\n ```\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1224,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4069:5: 4102:6",
  "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is – don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
  "mir": "fn slice::<impl [T]>::align_to(_1: &[T]) -> (&[T], &[U], &[T]) {\n    let mut _0: (&[T], &[U], &[T]);\n    let mut _2: &[U];\n    let  _3: &[U; 0];\n    let mut _4: &[T];\n    let  _5: &[T; 0];\n    let  _6: *const T;\n    let  _7: usize;\n    let mut _8: usize;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: &[U];\n    let  _12: &[U; 0];\n    let mut _13: &[T];\n    let  _14: &[T; 0];\n    let  _15: &[T];\n    let  _16: &[T];\n    let mut _17: (&[T], &[T]);\n    let  _18: usize;\n    let  _19: usize;\n    let mut _20: (usize, usize);\n    let  _21: &[U];\n    let mut _22: *const U;\n    let mut _23: *const T;\n    let  _24: &[T];\n    let mut _25: *const T;\n    let mut _26: *const T;\n    let mut _27: usize;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    debug self => _1;\n    debug ptr => _6;\n    debug offset => _7;\n    debug left => _15;\n    debug rest => _16;\n    debug us_len => _18;\n    debug ts_len => _19;\n    bb0: {\n        switchInt(<U as mem::SizedTypeProperties>::IS_ZST) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_2);\n        _3 = slice::<impl [T]>::align_to::<U>::promoted[1];\n        _2 = _3 as &[U];\n        StorageLive(_4);\n        _5 = slice::<impl [T]>::align_to::<U>::promoted[0];\n        _4 = _5 as &[T];\n        _0 = (_1, move _2, move _4);\n        StorageDead(_4);\n        StorageDead(_2);\n        goto -> bb18;\n    }\n    bb3: {\n        _6 = slice::<impl [T]>::as_ptr(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = mem::align_of::<U>() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _7 = ptr::align_offset::<T>(_6, move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = PtrMetadata(_1);\n        _9 = Gt(_7, move _10);\n        switchInt(move _9) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _12 = slice::<impl [T]>::align_to::<U>::promoted[3];\n        _11 = _12 as &[U];\n        StorageLive(_13);\n        _14 = slice::<impl [T]>::align_to::<U>::promoted[2];\n        _13 = _14 as &[T];\n        _0 = (_1, move _11, move _13);\n        StorageDead(_13);\n        StorageDead(_11);\n        goto -> bb17;\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_17);\n        _17 = slice::<impl [T]>::split_at(_1, _7) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _15 = (_17.0: &[T]);\n        _16 = (_17.1: &[T]);\n        StorageDead(_17);\n        StorageLive(_20);\n        _20 = slice::<impl [T]>::align_to_offsets::<U>(_16) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _18 = (_20.0: usize);\n        _19 = (_20.1: usize);\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = slice::<impl [T]>::as_ptr(_16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _22 = move _23 as *const U;\n        StorageDead(_23);\n        _21 = slice::raw::from_raw_parts::<'_, U>(move _22, _18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = slice::<impl [T]>::as_ptr(_16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = PtrMetadata(_16);\n        _29 = CheckedSub(_28, _19);\n        assert(!move (_29.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _28, _19) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _27 = move (_29.0: usize);\n        StorageDead(_28);\n        _25 = ptr::const_ptr::<impl *const T>::add(move _26, move _27) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_27);\n        StorageDead(_26);\n        _24 = slice::raw::from_raw_parts::<'_, T>(move _25, _19) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_25);\n        _0 = (_15, _21, _24);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_9);\n        goto -> bb18;\n    }\n    bb18: {\n        return;\n    }\n}\n",
  "doc": " Transmutes the slice to a slice of another type, ensuring alignment of the types is\n maintained.\n\n This method splits the slice into three distinct slices: prefix, correctly aligned middle\n slice of a new type, and the suffix slice. The middle part will be as big as possible under\n the given alignment constraint and element size.\n\n This method has no purpose when either input element `T` or output element `U` are\n zero-sized and will return the original slice without splitting anything.\n\n # Safety\n\n This method is essentially a `transmute` with respect to the elements in the returned\n middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n\n # Examples\n\n Basic usage:\n\n ```\n unsafe {\n     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n     // less_efficient_algorithm_for_bytes(prefix);\n     // more_efficient_algorithm_for_aligned_shorts(shorts);\n     // less_efficient_algorithm_for_bytes(suffix);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}