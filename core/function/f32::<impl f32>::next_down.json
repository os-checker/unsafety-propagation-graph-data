{
  "name": "f32::<impl f32>::next_down",
  "safe": true,
  "callees": {
    "f32::<impl f32>::to_bits": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unnecessary_transmutes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unnecessary_transmutes\n"
        ]
      },
      "doc": " Raw transmutation to `u32`.\n\n This is currently identical to `transmute::<f32, u32>(self)` on all platforms.\n\n See [`from_bits`](Self::from_bits) for some discussion of the\n portability of this operation (there are almost no issues).\n\n Note that this function is distinct from `as` casting, which attempts to\n preserve the *numeric* value, and not the bitwise value.\n\n # Examples\n\n ```\n assert_ne!((1f32).to_bits(), 1f32 as u32); // to_bits() is not casting!\n assert_eq!((12.5f32).to_bits(), 0x41480000);\n\n ```\n",
      "adt": {}
    },
    "f32::<impl f32>::is_nan": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this value is NaN.\n\n ```\n let nan = f32::NAN;\n let f = 7.0_f32;\n\n assert!(nan.is_nan());\n assert!(!f.is_nan());\n ```\n",
      "adt": {}
    },
    "f32::<impl f32>::from_bits": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unnecessary_transmutes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unnecessary_transmutes\n"
        ]
      },
      "doc": " Raw transmutation from `u32`.\n\n This is currently identical to `transmute::<u32, f32>(v)` on all platforms.\n It turns out this is incredibly portable, for two reasons:\n\n * Floats and Ints have the same endianness on all supported platforms.\n * IEEE 754 very precisely specifies the bit layout of floats.\n\n However there is one caveat: prior to the 2008 version of IEEE 754, how\n to interpret the NaN signaling bit wasn't actually specified. Most platforms\n (notably x86 and ARM) picked the interpretation that was ultimately\n standardized in 2008, but some didn't (notably MIPS). As a result, all\n signaling NaNs on MIPS are quiet NaNs on x86, and vice-versa.\n\n Rather than trying to preserve signaling-ness cross-platform, this\n implementation favors preserving the exact bits. This means that\n any payloads encoded in NaNs will be preserved even if the result of\n this method is sent over the network from an x86 machine to a MIPS one.\n\n If the results of this method are only manipulated by the same\n architecture that produced them, then there is no portability concern.\n\n If the input isn't NaN, then there is no portability concern.\n\n If you don't care about signalingness (very likely), then there is no\n portability concern.\n\n Note that this function is distinct from `as` casting, which attempts to\n preserve the *numeric* value, and not the bitwise value.\n\n # Examples\n\n ```\n let v = f32::from_bits(0x41480000);\n assert_eq!(v, 12.5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::f32::<impl f32>::next_down"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f32.rs:805:5: 823:6",
  "src": "pub const fn next_down(self) -> Self {\n        // Some targets violate Rust's assumption of IEEE semantics, e.g. by flushing\n        // denormals to zero. This is in general unsound and unsupported, but here\n        // we do our best to still produce the correct result on such targets.\n        let bits = self.to_bits();\n        if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {\n            return self;\n        }\n\n        let abs = bits & !Self::SIGN_MASK;\n        let next_bits = if abs == 0 {\n            Self::NEG_TINY_BITS\n        } else if bits == abs {\n            bits - 1\n        } else {\n            bits + 1\n        };\n        Self::from_bits(next_bits)\n    }",
  "mir": "fn f32::<impl f32>::next_down(_1: f32) -> f32 {\n    let mut _0: f32;\n    let  _2: u32;\n    let mut _3: bool;\n    let mut _4: bool;\n    let mut _5: u32;\n    let  _6: u32;\n    let mut _7: u32;\n    let  _8: u32;\n    let mut _9: bool;\n    let mut _10: (u32, bool);\n    let mut _11: (u32, bool);\n    let mut _12: u32;\n    debug self => _1;\n    debug bits => _2;\n    debug abs => _6;\n    debug next_bits => _8;\n    bb0: {\n        _2 = f32::<impl f32>::to_bits(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = f32::<impl f32>::is_nan(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        goto -> bb7;\n    }\n    bb4: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = f32::<impl f32>::to_bits(f32::<impl f32>::NEG_INFINITY) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _4 = Eq(_2, move _5);\n        switchInt(move _4) -> [0: bb8, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_5);\n        goto -> bb7;\n    }\n    bb7: {\n        _0 = _1;\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb18;\n    }\n    bb8: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_7);\n        _7 = Not(f32::<impl f32>::SIGN_MASK);\n        _6 = BitAnd(_2, move _7);\n        StorageDead(_7);\n        StorageLive(_8);\n        switchInt(_6) -> [0: bb9, otherwise: bb10];\n    }\n    bb9: {\n        _8 = f32::<impl f32>::NEG_TINY_BITS;\n        goto -> bb16;\n    }\n    bb10: {\n        StorageLive(_9);\n        _9 = Eq(_2, _6);\n        switchInt(move _9) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        _10 = CheckedSub(_2, 1_u32);\n        assert(!move (_10.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_u32) -> [success: bb13, unwind unreachable];\n    }\n    bb12: {\n        _11 = CheckedAdd(_2, 1_u32);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_u32) -> [success: bb14, unwind unreachable];\n    }\n    bb13: {\n        _8 = move (_10.0: u32);\n        goto -> bb15;\n    }\n    bb14: {\n        _8 = move (_11.0: u32);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_9);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageLive(_12);\n        _12 = _8;\n        _0 = f32::<impl f32>::from_bits(move _12) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_12);\n        StorageDead(_8);\n        goto -> bb18;\n    }\n    bb18: {\n        return;\n    }\n}\n",
  "doc": " Returns the greatest number less than `self`.\n\n Let `TINY` be the smallest representable positive `f32`. Then,\n  - if `self.is_nan()`, this returns `self`;\n  - if `self` is [`INFINITY`], this returns [`MAX`];\n  - if `self` is `TINY`, this returns 0.0;\n  - if `self` is -0.0 or +0.0, this returns `-TINY`;\n  - if `self` is [`MIN`] or [`NEG_INFINITY`], this returns [`NEG_INFINITY`];\n  - otherwise the unique greatest value less than `self` is returned.\n\n The identity `x.next_down() == -(-x).next_up()` holds for all non-NaN `x`. When `x`\n is finite `x == x.next_down().next_up()` also holds.\n\n ```rust\n let x = 1.0f32;\n // Clamp value into range [0, 1).\n let clamped = x.clamp(0.0, 1.0f32.next_down());\n assert!(clamped < 1.0);\n assert_eq!(clamped.next_up(), 1.0);\n ```\n\n This operation corresponds to IEEE-754 `nextDown`.\n\n [`NEG_INFINITY`]: Self::NEG_INFINITY\n [`INFINITY`]: Self::INFINITY\n [`MIN`]: Self::MIN\n [`MAX`]: Self::MAX\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}