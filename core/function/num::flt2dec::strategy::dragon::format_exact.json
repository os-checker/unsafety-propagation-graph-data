{
  "name": "num::flt2dec::strategy::dragon::format_exact",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::<impl u64>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {
        "option::Option": "MutableAsArgument"
      }
    },
    "num::<impl u64>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::flt2dec::estimator::estimate_scaling_factor": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.\n\n This is used to approximate `k = ceil(log_10 (mant * 2^exp))`;\n the true `k` is either `k_0` or `k_0+1`.\n",
      "adt": {}
    },
    "num::bignum::Big32x40::from_u64": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a bignum from `u64` value.\n",
      "adt": {
        "num::bignum::Big32x40": "Constructor"
      }
    },
    "num::bignum::Big32x40::from_small": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a bignum from one digit.\n",
      "adt": {
        "num::bignum::Big32x40": "Constructor"
      }
    },
    "num::bignum::Big32x40::mul_pow2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiplies itself by `2^bits` and returns its own mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "num::flt2dec::strategy::dragon::mul_pow10": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": "",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "num::flt2dec::strategy::dragon::div_2pow10": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "num::bignum::Big32x40::add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds `other` to itself and returns its own mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "cmp::PartialOrd::ge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests greater than or equal to (for `self` and `other`) and is used by\n the `>=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 >= 1.0, true);\n assert_eq!(1.0 >= 2.0, false);\n assert_eq!(2.0 >= 1.0, true);\n ```\n",
      "adt": {}
    },
    "num::bignum::Big32x40::mul_small": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiplies itself by a digit-sized `other` and returns its own\n mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "num::bignum::Big32x40::is_zero": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the bignum is zero.\n",
      "adt": {
        "num::bignum::Big32x40": "ImmutableAsArgument"
      }
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "num::bignum::Big32x40::sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Subtracts `other` from itself and returns its own mutable reference.\n",
      "adt": {
        "num::bignum::Big32x40": "MutableAsArgument"
      }
    },
    "cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    },
    "cmp::Ord::cmp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This method returns an [`Ordering`] between `self` and `other`.\n\n By convention, `self.cmp(&other)` returns the ordering matching the expression\n `self <operator> other` if true.\n\n # Examples\n\n ```\n use std::cmp::Ordering;\n\n assert_eq!(5.cmp(&10), Ordering::Less);\n assert_eq!(10.cmp(&5), Ordering::Greater);\n assert_eq!(5.cmp(&5), Ordering::Equal);\n ```\n",
      "adt": {}
    },
    "cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the value from the `MaybeUninit<T>` container. This is a great way\n to ensure that the data will get dropped, because the resulting `T` is\n subject to the usual drop handling.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes immediate undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n [inv]: #initialization-invariant\n\n On top of that, remember that most types have additional invariants beyond merely\n being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n is considered initialized (under the current implementation; this does not constitute\n a stable guarantee) because the only requirement the compiler knows about it\n is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n *immediate* undefined behavior, but will cause undefined behavior with most\n safe operations (including dropping it).\n\n [`Vec<T>`]: ../../std/vec/struct.Vec.html\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<bool>::uninit();\n x.write(true);\n let x_init = unsafe { x.assume_init() };\n assert_eq!(x_init, true);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_init = unsafe { x.assume_init() };\n // `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️\n ```\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable (unique) reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in the\n slice really is in an initialized state. For instance, `.assume_init_mut()` cannot\n be used to initialize a `MaybeUninit` slice.\n",
      "adt": {}
    },
    "num::flt2dec::round_up": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " When `d` contains decimal digits, increase the last digit and propagate carry.\n Returns a next digit when it causes the length to change.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "num::flt2dec::decoder::Decoded": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 862, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 835, kind: RigidTy(Adt(AdtDef(DefId { id: 24704, name: \"mem::maybe_uninit::MaybeUninit\" }), GenericArgs([Type(Ty { id: 46, kind: RigidTy(Uint(U8)) })]))) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 46, kind: RigidTy(Uint(U8)) })])"
    ],
    "num::bignum::Big32x40": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "ops::range::Range": [
      "Plain",
      "MutRef"
    ],
    "slice::iter::IterMut": [
      "Plain",
      "MutRef"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef",
      "Plain",
      "Deref"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "cmp::Ordering": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::strategy::dragon::format_exact"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/strategy/dragon.rs:262:1: 389:2",
  "src": "pub fn format_exact<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n    limit: i16,\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n\n    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < v <= 10^(k_0+1)`.\n    let mut k = estimate_scaling_factor(d.mant, d.exp);\n\n    // `v = mant / scale`.\n    let mut mant = Big::from_u64(d.mant);\n    let mut scale = Big::from_small(1);\n    if d.exp < 0 {\n        scale.mul_pow2(-d.exp as usize);\n    } else {\n        mant.mul_pow2(d.exp as usize);\n    }\n\n    // divide `mant` by `10^k`. now `scale / 10 < mant <= scale * 10`.\n    if k >= 0 {\n        mul_pow10(&mut scale, k as usize);\n    } else {\n        mul_pow10(&mut mant, -k as usize);\n    }\n\n    // fixup when `mant + plus >= scale`, where `plus / scale = 10^-buf.len() / 2`.\n    // in order to keep the fixed-size bignum, we actually use `mant + floor(plus) >= scale`.\n    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n    // again with the shortest algorithm, `d[0]` can be zero but will be eventually rounded up.\n    if *div_2pow10(&mut scale.clone(), buf.len()).add(&mant) >= scale {\n        // equivalent to scaling `scale` by 10\n        k += 1;\n    } else {\n        mant.mul_small(10);\n    }\n\n    // if we are working with the last-digit limitation, we need to shorten the buffer\n    // before the actual rendering in order to avoid double rounding.\n    // note that we have to enlarge the buffer again when rounding up happens!\n    let mut len = if k < limit {\n        // oops, we cannot even produce *one* digit.\n        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n        // we return an empty buffer, with an exception of the later rounding-up case\n        // which occurs when `k == limit` and has to produce exactly one digit.\n        0\n    } else if ((k as i32 - limit as i32) as usize) < buf.len() {\n        (k - limit) as usize\n    } else {\n        buf.len()\n    };\n\n    if len > 0 {\n        // cache `(2, 4, 8) * scale` for digit generation.\n        // (this can be expensive, so do not calculate them when the buffer is empty.)\n        let mut scale2 = scale.clone();\n        scale2.mul_pow2(1);\n        let mut scale4 = scale.clone();\n        scale4.mul_pow2(2);\n        let mut scale8 = scale.clone();\n        scale8.mul_pow2(3);\n\n        for i in 0..len {\n            if mant.is_zero() {\n                // following digits are all zeroes, we stop here\n                // do *not* try to perform rounding! rather, fill remaining digits.\n                for c in &mut buf[i..len] {\n                    *c = MaybeUninit::new(b'0');\n                }\n                // SAFETY: we initialized that memory above.\n                return (unsafe { buf[..len].assume_init_ref() }, k);\n            }\n\n            let mut d = 0;\n            if mant >= scale8 {\n                mant.sub(&scale8);\n                d += 8;\n            }\n            if mant >= scale4 {\n                mant.sub(&scale4);\n                d += 4;\n            }\n            if mant >= scale2 {\n                mant.sub(&scale2);\n                d += 2;\n            }\n            if mant >= scale {\n                mant.sub(&scale);\n                d += 1;\n            }\n            debug_assert!(mant < scale);\n            debug_assert!(d < 10);\n            buf[i] = MaybeUninit::new(b'0' + d);\n            mant.mul_small(10);\n        }\n    }\n\n    // rounding up if we stop in the middle of digits\n    // if the following digits are exactly 5000..., check the prior digit and try to\n    // round to even (i.e., avoid rounding up when the prior digit is even).\n    let order = mant.cmp(scale.mul_small(5));\n    if order == Ordering::Greater\n        || (order == Ordering::Equal\n            // SAFETY: `buf[len-1]` is initialized.\n            && len > 0 && unsafe { buf[len - 1].assume_init() } & 1 == 1)\n    {\n        // if rounding up changes the length, the exponent should also change.\n        // but we've been requested a fixed number of digits, so do not alter the buffer...\n        // SAFETY: we initialized that memory above.\n        if let Some(c) = round_up(unsafe { buf[..len].assume_init_mut() }) {\n            // ...unless we've been requested the fixed precision instead.\n            // we also need to check that, if the original buffer was empty,\n            // the additional digit can only be added when `k == limit` (edge case).\n            k += 1;\n            if k > limit && len < buf.len() {\n                buf[len] = MaybeUninit::new(c);\n                len += 1;\n            }\n        }\n    }\n\n    // SAFETY: we initialized that memory above.\n    (unsafe { buf[..len].assume_init_ref() }, k)\n}",
  "mir": "fn num::flt2dec::strategy::dragon::format_exact(_1: &num::flt2dec::decoder::Decoded, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>], _3: i16) -> (&[u8], i16) {\n    let mut _0: (&[u8], i16);\n    let mut _4: bool;\n    let mut _5: u64;\n    let mut _6: !;\n    let mut _7: bool;\n    let mut _8: u64;\n    let mut _9: !;\n    let mut _10: bool;\n    let mut _11: u64;\n    let mut _12: !;\n    let mut _13: bool;\n    let mut _14: &option::Option<u64>;\n    let  _15: option::Option<u64>;\n    let mut _16: u64;\n    let mut _17: u64;\n    let mut _18: !;\n    let mut _19: bool;\n    let mut _20: &option::Option<u64>;\n    let  _21: option::Option<u64>;\n    let mut _22: u64;\n    let mut _23: u64;\n    let mut _24: !;\n    let mut _25: i16;\n    let mut _26: u64;\n    let mut _27: i16;\n    let mut _28: num::bignum::Big32x40;\n    let mut _29: u64;\n    let mut _30: num::bignum::Big32x40;\n    let mut _31: bool;\n    let mut _32: i16;\n    let  _33: &mut num::bignum::Big32x40;\n    let mut _34: &mut num::bignum::Big32x40;\n    let mut _35: usize;\n    let mut _36: i16;\n    let mut _37: i16;\n    let mut _38: bool;\n    let  _39: &mut num::bignum::Big32x40;\n    let mut _40: &mut num::bignum::Big32x40;\n    let mut _41: usize;\n    let mut _42: i16;\n    let mut _43: bool;\n    let mut _44: i16;\n    let  _45: &mut num::bignum::Big32x40;\n    let mut _46: &mut num::bignum::Big32x40;\n    let mut _47: usize;\n    let mut _48: i16;\n    let  _49: &mut num::bignum::Big32x40;\n    let mut _50: &mut num::bignum::Big32x40;\n    let mut _51: usize;\n    let mut _52: i16;\n    let mut _53: i16;\n    let mut _54: bool;\n    let mut _55: bool;\n    let mut _56: &num::bignum::Big32x40;\n    let  _57: &mut num::bignum::Big32x40;\n    let mut _58: &mut num::bignum::Big32x40;\n    let mut _59: &mut num::bignum::Big32x40;\n    let mut _60: num::bignum::Big32x40;\n    let mut _61: &num::bignum::Big32x40;\n    let mut _62: usize;\n    let mut _63: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let  _64: &num::bignum::Big32x40;\n    let mut _65: &num::bignum::Big32x40;\n    let mut _66: (i16, bool);\n    let  _67: &mut num::bignum::Big32x40;\n    let mut _68: &mut num::bignum::Big32x40;\n    let mut _69: usize;\n    let mut _70: bool;\n    let mut _71: i16;\n    let mut _72: bool;\n    let mut _73: usize;\n    let mut _74: i32;\n    let mut _75: i32;\n    let mut _76: i16;\n    let mut _77: i32;\n    let mut _78: (i32, bool);\n    let mut _79: usize;\n    let mut _80: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _81: i16;\n    let mut _82: i16;\n    let mut _83: (i16, bool);\n    let mut _84: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _85: bool;\n    let mut _86: usize;\n    let mut _87: num::bignum::Big32x40;\n    let mut _88: &num::bignum::Big32x40;\n    let  _89: &mut num::bignum::Big32x40;\n    let mut _90: &mut num::bignum::Big32x40;\n    let mut _91: num::bignum::Big32x40;\n    let mut _92: &num::bignum::Big32x40;\n    let  _93: &mut num::bignum::Big32x40;\n    let mut _94: &mut num::bignum::Big32x40;\n    let mut _95: num::bignum::Big32x40;\n    let mut _96: &num::bignum::Big32x40;\n    let  _97: &mut num::bignum::Big32x40;\n    let mut _98: &mut num::bignum::Big32x40;\n    let mut _99: ops::range::Range<usize>;\n    let mut _100: ops::range::Range<usize>;\n    let mut _101: usize;\n    let mut _102: ops::range::Range<usize>;\n    let mut _103: option::Option<usize>;\n    let mut _104: &mut ops::range::Range<usize>;\n    let mut _105: isize;\n    let  _106: usize;\n    let mut _107: bool;\n    let mut _108: &num::bignum::Big32x40;\n    let mut _109: slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _110: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _111: ops::range::Range<usize>;\n    let mut _112: usize;\n    let mut _113: slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _114: option::Option<&mut mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _115: &mut slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>>;\n    let mut _116: isize;\n    let  _117: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _118: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _119: &[u8];\n    let  _120: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _121: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _122: ops::range::RangeTo<usize>;\n    let mut _123: usize;\n    let mut _124: i16;\n    let mut _125: u8;\n    let mut _126: bool;\n    let mut _127: &num::bignum::Big32x40;\n    let mut _128: &num::bignum::Big32x40;\n    let  _129: &mut num::bignum::Big32x40;\n    let mut _130: &mut num::bignum::Big32x40;\n    let  _131: &num::bignum::Big32x40;\n    let mut _132: (u8, bool);\n    let mut _133: bool;\n    let mut _134: &num::bignum::Big32x40;\n    let mut _135: &num::bignum::Big32x40;\n    let  _136: &mut num::bignum::Big32x40;\n    let mut _137: &mut num::bignum::Big32x40;\n    let  _138: &num::bignum::Big32x40;\n    let mut _139: (u8, bool);\n    let mut _140: bool;\n    let mut _141: &num::bignum::Big32x40;\n    let mut _142: &num::bignum::Big32x40;\n    let  _143: &mut num::bignum::Big32x40;\n    let mut _144: &mut num::bignum::Big32x40;\n    let  _145: &num::bignum::Big32x40;\n    let mut _146: (u8, bool);\n    let mut _147: bool;\n    let mut _148: &num::bignum::Big32x40;\n    let mut _149: &num::bignum::Big32x40;\n    let  _150: &mut num::bignum::Big32x40;\n    let mut _151: &mut num::bignum::Big32x40;\n    let  _152: &num::bignum::Big32x40;\n    let mut _153: (u8, bool);\n    let mut _154: bool;\n    let mut _155: &num::bignum::Big32x40;\n    let mut _156: &num::bignum::Big32x40;\n    let mut _157: !;\n    let mut _158: bool;\n    let mut _159: u8;\n    let mut _160: !;\n    let mut _161: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _162: u8;\n    let mut _163: u8;\n    let mut _164: (u8, bool);\n    let mut _165: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _166: usize;\n    let mut _167: bool;\n    let  _168: &mut num::bignum::Big32x40;\n    let mut _169: &mut num::bignum::Big32x40;\n    let  _170: cmp::Ordering;\n    let mut _171: &num::bignum::Big32x40;\n    let mut _172: &num::bignum::Big32x40;\n    let  _173: &mut num::bignum::Big32x40;\n    let mut _174: &mut num::bignum::Big32x40;\n    let mut _175: bool;\n    let mut _176: &cmp::Ordering;\n    let mut _177: &cmp::Ordering;\n    let mut _178: bool;\n    let mut _179: &cmp::Ordering;\n    let mut _180: &cmp::Ordering;\n    let mut _181: bool;\n    let mut _182: usize;\n    let mut _183: u8;\n    let mut _184: u8;\n    let mut _185: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _186: usize;\n    let mut _187: usize;\n    let mut _188: (usize, bool);\n    let mut _189: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _190: usize;\n    let mut _191: bool;\n    let mut _192: option::Option<u8>;\n    let mut _193: &mut [u8];\n    let mut _194: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _195: ops::range::RangeTo<usize>;\n    let mut _196: usize;\n    let mut _197: isize;\n    let  _198: u8;\n    let mut _199: (i16, bool);\n    let mut _200: bool;\n    let mut _201: i16;\n    let mut _202: bool;\n    let mut _203: usize;\n    let mut _204: usize;\n    let mut _205: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _206: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _207: usize;\n    let mut _208: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _209: usize;\n    let mut _210: bool;\n    let mut _211: (usize, bool);\n    let  _212: &[u8];\n    let  _213: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _214: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _215: ops::range::RangeTo<usize>;\n    let mut _216: usize;\n    let mut _217: i16;\n    debug d => _1;\n    debug buf => _2;\n    debug limit => _3;\n    debug k => _25;\n    debug mant => _28;\n    debug scale => _30;\n    debug len => _69;\n    debug scale2 => _87;\n    debug scale4 => _91;\n    debug scale8 => _95;\n    debug iter => _102;\n    debug i => _106;\n    debug iter => _113;\n    debug c => _117;\n    debug d => _125;\n    debug order => _170;\n    debug c => _198;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).0: u64);\n        _4 = Gt(move _5, 0_u64);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = ((*_1).1: u64);\n        _7 = Gt(move _8, 0_u64);\n        switchInt(move _7) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = panicking::panic(\"assertion failed: d.mant > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = ((*_1).2: u64);\n        _10 = Gt(move _11, 0_u64);\n        switchInt(move _10) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_8);\n        _9 = panicking::panic(\"assertion failed: d.minus > 0\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = ((*_1).0: u64);\n        StorageLive(_17);\n        _17 = ((*_1).2: u64);\n        _15 = num::<impl u64>::checked_add(move _16, move _17) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _12 = panicking::panic(\"assertion failed: d.plus > 0\") -> unwind unreachable;\n    }\n    bb7: {\n        _14 = &_15;\n        StorageDead(_17);\n        StorageDead(_16);\n        _13 = option::Option::<u64>::is_some(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _13) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = ((*_1).0: u64);\n        StorageLive(_23);\n        _23 = ((*_1).1: u64);\n        _21 = num::<impl u64>::checked_sub(move _22, move _23) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageDead(_15);\n        _18 = panicking::panic(\"assertion failed: d.mant.checked_add(d.plus).is_some()\") -> unwind unreachable;\n    }\n    bb11: {\n        _20 = &_21;\n        StorageDead(_23);\n        StorageDead(_22);\n        _19 = option::Option::<u64>::is_some(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _19) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_20);\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = ((*_1).0: u64);\n        StorageLive(_27);\n        _27 = ((*_1).3: i16);\n        _25 = num::flt2dec::estimator::estimate_scaling_factor(move _26, move _27) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_21);\n        _24 = panicking::panic(\"assertion failed: d.mant.checked_sub(d.minus).is_some()\") -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = ((*_1).0: u64);\n        _28 = num::bignum::Big32x40::from_u64(move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        StorageLive(_30);\n        _30 = num::bignum::Big32x40::from_small(1_u32) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = ((*_1).3: i16);\n        _31 = Lt(move _32, 0_i16);\n        switchInt(move _31) -> [0: bb21, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _30;\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = ((*_1).3: i16);\n        _38 = Eq(_37, i16::MIN);\n        assert(!move _38, \"attempt to negate `{}`, which would overflow\", _37) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _36 = Neg(move _37);\n        StorageDead(_37);\n        _35 = move _36 as usize;\n        StorageDead(_36);\n        _33 = num::bignum::Big32x40::mul_pow2(move _34, move _35) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb23;\n    }\n    bb21: {\n        StorageDead(_32);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &mut _28;\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = ((*_1).3: i16);\n        _41 = move _42 as usize;\n        StorageDead(_42);\n        _39 = num::bignum::Big32x40::mul_pow2(move _40, move _41) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_31);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = _25;\n        _43 = Ge(move _44, 0_i16);\n        switchInt(move _43) -> [0: bb26, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_44);\n        StorageLive(_45);\n        _46 = &mut _30;\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _25;\n        _47 = move _48 as usize;\n        StorageDead(_48);\n        _45 = num::flt2dec::strategy::dragon::mul_pow10(_46, move _47) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_47);\n        StorageDead(_45);\n        goto -> bb29;\n    }\n    bb26: {\n        StorageDead(_44);\n        StorageLive(_49);\n        _50 = &mut _28;\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = _25;\n        _54 = Eq(_53, i16::MIN);\n        assert(!move _54, \"attempt to negate `{}`, which would overflow\", _53) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _52 = Neg(move _53);\n        StorageDead(_53);\n        _51 = move _52 as usize;\n        StorageDead(_52);\n        _49 = num::flt2dec::strategy::dragon::mul_pow10(_50, move _51) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_51);\n        StorageDead(_49);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_43);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &_30;\n        _60 = <num::bignum::Big32x40 as clone::Clone>::clone(move _61) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_61);\n        _59 = &mut _60;\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = &(*_2);\n        _62 = PtrMetadata(move _63);\n        StorageDead(_63);\n        _58 = num::flt2dec::strategy::dragon::div_2pow10(_59, move _62) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_62);\n        _64 = &_28;\n        _57 = num::bignum::Big32x40::add(_58, _64) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _56 = &(*_57);\n        StorageLive(_65);\n        _65 = &_30;\n        _55 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _56, move _65) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        switchInt(move _55) -> [0: bb36, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_65);\n        StorageDead(_60);\n        StorageDead(_57);\n        StorageDead(_56);\n        _66 = CheckedAdd(_25, 1_i16);\n        assert(!move (_66.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, 1_i16) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _25 = move (_66.0: i16);\n        goto -> bb38;\n    }\n    bb36: {\n        StorageDead(_65);\n        StorageDead(_60);\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = &mut _28;\n        _67 = num::bignum::Big32x40::mul_small(move _68, 10_u32) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_68);\n        StorageDead(_67);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_55);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = _25;\n        _70 = Lt(move _71, _3);\n        switchInt(move _70) -> [0: bb40, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_71);\n        _69 = 0_usize;\n        goto -> bb46;\n    }\n    bb40: {\n        StorageDead(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = _25;\n        _75 = move _76 as i32;\n        StorageDead(_76);\n        StorageLive(_77);\n        _77 = _3 as i32;\n        _78 = CheckedSub(_75, _77);\n        assert(!move (_78.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _75, move _77) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _74 = move (_78.0: i32);\n        StorageDead(_77);\n        StorageDead(_75);\n        _73 = move _74 as usize;\n        StorageDead(_74);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = &(*_2);\n        _79 = PtrMetadata(move _80);\n        StorageDead(_80);\n        _72 = Lt(move _73, move _79);\n        switchInt(move _72) -> [0: bb44, otherwise: bb42];\n    }\n    bb42: {\n        StorageDead(_79);\n        StorageDead(_73);\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = _25;\n        _83 = CheckedSub(_82, _3);\n        assert(!move (_83.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _82, _3) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _81 = move (_83.0: i16);\n        StorageDead(_82);\n        _69 = move _81 as usize;\n        StorageDead(_81);\n        goto -> bb45;\n    }\n    bb44: {\n        StorageDead(_79);\n        StorageDead(_73);\n        StorageLive(_84);\n        _84 = &(*_2);\n        _69 = PtrMetadata(move _84);\n        StorageDead(_84);\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_72);\n        goto -> bb46;\n    }\n    bb46: {\n        StorageDead(_70);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = _69;\n        _85 = Gt(move _86, 0_usize);\n        switchInt(move _85) -> [0: bb105, otherwise: bb47];\n    }\n    bb47: {\n        StorageDead(_86);\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = &_30;\n        _87 = <num::bignum::Big32x40 as clone::Clone>::clone(move _88) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_88);\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = &mut _87;\n        _89 = num::bignum::Big32x40::mul_pow2(move _90, 1_usize) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_90);\n        StorageDead(_89);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = &_30;\n        _91 = <num::bignum::Big32x40 as clone::Clone>::clone(move _92) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        _94 = &mut _91;\n        _93 = num::bignum::Big32x40::mul_pow2(move _94, 2_usize) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_94);\n        StorageDead(_93);\n        StorageLive(_95);\n        StorageLive(_96);\n        _96 = &_30;\n        _95 = <num::bignum::Big32x40 as clone::Clone>::clone(move _96) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_96);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = &mut _95;\n        _97 = num::bignum::Big32x40::mul_pow2(move _98, 3_usize) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_98);\n        StorageDead(_97);\n        StorageLive(_99);\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = _69;\n        _100 = Range(0_usize, move _101);\n        StorageDead(_101);\n        _99 = <ops::range::Range<usize> as iter::traits::collect::IntoIterator>::into_iter(move _100) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_100);\n        StorageLive(_102);\n        _102 = move _99;\n        goto -> bb55;\n    }\n    bb55: {\n        StorageLive(_103);\n        _104 = &mut _102;\n        _103 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::next(_104) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        _105 = discriminant(_103);\n        switchInt(move _105) -> [0: bb59, 1: bb58, otherwise: bb57];\n    }\n    bb57: {\n        unreachable;\n    }\n    bb58: {\n        _106 = ((_103 as variant#1).0: usize);\n        StorageLive(_107);\n        StorageLive(_108);\n        _108 = &_28;\n        _107 = num::bignum::Big32x40::is_zero(move _108) -> [return: bb60, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_103);\n        StorageDead(_102);\n        StorageDead(_99);\n        StorageDead(_95);\n        StorageDead(_91);\n        StorageDead(_87);\n        goto -> bb106;\n    }\n    bb60: {\n        switchInt(move _107) -> [0: bb71, otherwise: bb61];\n    }\n    bb61: {\n        StorageDead(_108);\n        StorageLive(_109);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = _69;\n        _111 = Range(_106, move _112);\n        StorageDead(_112);\n        _110 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::Range<usize>>>::index_mut(_2, move _111) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_111);\n        _109 = <&mut [mem::maybe_uninit::MaybeUninit<u8>] as iter::traits::collect::IntoIterator>::into_iter(_110) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageLive(_113);\n        _113 = move _109;\n        goto -> bb64;\n    }\n    bb64: {\n        StorageLive(_114);\n        _115 = &mut _113;\n        _114 = <slice::iter::IterMut<'_, mem::maybe_uninit::MaybeUninit<u8>> as iter::traits::iterator::Iterator>::next(_115) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        _116 = discriminant(_114);\n        switchInt(move _116) -> [0: bb67, 1: bb66, otherwise: bb57];\n    }\n    bb66: {\n        StorageLive(_117);\n        _117 = move ((_114 as variant#1).0: &mut mem::maybe_uninit::MaybeUninit<u8>);\n        StorageLive(_118);\n        _118 = mem::maybe_uninit::MaybeUninit::<u8>::new(48_u8) -> [return: bb68, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_114);\n        StorageDead(_113);\n        StorageDead(_109);\n        StorageLive(_121);\n        _121 = &(*_2);\n        StorageLive(_122);\n        StorageLive(_123);\n        _123 = _69;\n        _122 = RangeTo(move _123);\n        StorageDead(_123);\n        _120 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _121, move _122) -> [return: bb69, unwind unreachable];\n    }\n    bb68: {\n        (*_117) = move _118;\n        StorageDead(_118);\n        StorageDead(_117);\n        StorageDead(_114);\n        goto -> bb64;\n    }\n    bb69: {\n        StorageDead(_122);\n        StorageDead(_121);\n        _119 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_120) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageLive(_124);\n        _124 = _25;\n        _0 = (_119, move _124);\n        StorageDead(_124);\n        StorageDead(_107);\n        StorageDead(_103);\n        StorageDead(_102);\n        StorageDead(_99);\n        StorageDead(_95);\n        StorageDead(_91);\n        StorageDead(_87);\n        StorageDead(_85);\n        StorageDead(_69);\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageDead(_25);\n        goto -> bb140;\n    }\n    bb71: {\n        StorageDead(_108);\n        StorageDead(_107);\n        StorageLive(_125);\n        _125 = 0_u8;\n        StorageLive(_126);\n        StorageLive(_127);\n        _127 = &_28;\n        StorageLive(_128);\n        _128 = &_95;\n        _126 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _127, move _128) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        switchInt(move _126) -> [0: bb76, otherwise: bb73];\n    }\n    bb73: {\n        StorageDead(_128);\n        StorageDead(_127);\n        StorageLive(_129);\n        StorageLive(_130);\n        _130 = &mut _28;\n        _131 = &_95;\n        _129 = num::bignum::Big32x40::sub(move _130, _131) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_130);\n        StorageDead(_129);\n        _132 = CheckedAdd(_125, 8_u8);\n        assert(!move (_132.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 8_u8) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _125 = move (_132.0: u8);\n        goto -> bb77;\n    }\n    bb76: {\n        StorageDead(_128);\n        StorageDead(_127);\n        goto -> bb77;\n    }\n    bb77: {\n        StorageDead(_126);\n        StorageLive(_133);\n        StorageLive(_134);\n        _134 = &_28;\n        StorageLive(_135);\n        _135 = &_91;\n        _133 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _134, move _135) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        switchInt(move _133) -> [0: bb82, otherwise: bb79];\n    }\n    bb79: {\n        StorageDead(_135);\n        StorageDead(_134);\n        StorageLive(_136);\n        StorageLive(_137);\n        _137 = &mut _28;\n        _138 = &_91;\n        _136 = num::bignum::Big32x40::sub(move _137, _138) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_137);\n        StorageDead(_136);\n        _139 = CheckedAdd(_125, 4_u8);\n        assert(!move (_139.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 4_u8) -> [success: bb81, unwind unreachable];\n    }\n    bb81: {\n        _125 = move (_139.0: u8);\n        goto -> bb83;\n    }\n    bb82: {\n        StorageDead(_135);\n        StorageDead(_134);\n        goto -> bb83;\n    }\n    bb83: {\n        StorageDead(_133);\n        StorageLive(_140);\n        StorageLive(_141);\n        _141 = &_28;\n        StorageLive(_142);\n        _142 = &_87;\n        _140 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _141, move _142) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        switchInt(move _140) -> [0: bb88, otherwise: bb85];\n    }\n    bb85: {\n        StorageDead(_142);\n        StorageDead(_141);\n        StorageLive(_143);\n        StorageLive(_144);\n        _144 = &mut _28;\n        _145 = &_87;\n        _143 = num::bignum::Big32x40::sub(move _144, _145) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        StorageDead(_144);\n        StorageDead(_143);\n        _146 = CheckedAdd(_125, 2_u8);\n        assert(!move (_146.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 2_u8) -> [success: bb87, unwind unreachable];\n    }\n    bb87: {\n        _125 = move (_146.0: u8);\n        goto -> bb89;\n    }\n    bb88: {\n        StorageDead(_142);\n        StorageDead(_141);\n        goto -> bb89;\n    }\n    bb89: {\n        StorageDead(_140);\n        StorageLive(_147);\n        StorageLive(_148);\n        _148 = &_28;\n        StorageLive(_149);\n        _149 = &_30;\n        _147 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _148, move _149) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        switchInt(move _147) -> [0: bb94, otherwise: bb91];\n    }\n    bb91: {\n        StorageDead(_149);\n        StorageDead(_148);\n        StorageLive(_150);\n        StorageLive(_151);\n        _151 = &mut _28;\n        _152 = &_30;\n        _150 = num::bignum::Big32x40::sub(move _151, _152) -> [return: bb92, unwind unreachable];\n    }\n    bb92: {\n        StorageDead(_151);\n        StorageDead(_150);\n        _153 = CheckedAdd(_125, 1_u8);\n        assert(!move (_153.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _125, 1_u8) -> [success: bb93, unwind unreachable];\n    }\n    bb93: {\n        _125 = move (_153.0: u8);\n        goto -> bb95;\n    }\n    bb94: {\n        StorageDead(_149);\n        StorageDead(_148);\n        goto -> bb95;\n    }\n    bb95: {\n        StorageDead(_147);\n        StorageLive(_154);\n        StorageLive(_155);\n        _155 = &_28;\n        StorageLive(_156);\n        _156 = &_30;\n        _154 = <num::bignum::Big32x40 as cmp::PartialOrd>::lt(move _155, move _156) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        switchInt(move _154) -> [0: bb98, otherwise: bb97];\n    }\n    bb97: {\n        StorageDead(_156);\n        StorageDead(_155);\n        StorageDead(_154);\n        StorageLive(_158);\n        StorageLive(_159);\n        _159 = _125;\n        _158 = Lt(move _159, 10_u8);\n        switchInt(move _158) -> [0: bb100, otherwise: bb99];\n    }\n    bb98: {\n        StorageDead(_156);\n        StorageDead(_155);\n        _157 = panicking::panic(\"assertion failed: mant < scale\") -> unwind unreachable;\n    }\n    bb99: {\n        StorageDead(_159);\n        StorageDead(_158);\n        StorageLive(_161);\n        StorageLive(_162);\n        StorageLive(_163);\n        _163 = _125;\n        _164 = CheckedAdd(48_u8, _163);\n        assert(!move (_164.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _163) -> [success: bb101, unwind unreachable];\n    }\n    bb100: {\n        StorageDead(_159);\n        _160 = panicking::panic(\"assertion failed: d < 10\") -> unwind unreachable;\n    }\n    bb101: {\n        _162 = move (_164.0: u8);\n        StorageDead(_163);\n        _161 = mem::maybe_uninit::MaybeUninit::<u8>::new(move _162) -> [return: bb102, unwind unreachable];\n    }\n    bb102: {\n        StorageDead(_162);\n        _165 = &raw const (fake) (*_2);\n        _166 = PtrMetadata(move _165);\n        _167 = Lt(_106, _166);\n        assert(move _167, \"index out of bounds: the length is {} but the index is {}\", move _166, _106) -> [success: bb103, unwind unreachable];\n    }\n    bb103: {\n        (*_2)[_106] = move _161;\n        StorageDead(_161);\n        StorageLive(_168);\n        StorageLive(_169);\n        _169 = &mut _28;\n        _168 = num::bignum::Big32x40::mul_small(move _169, 10_u32) -> [return: bb104, unwind unreachable];\n    }\n    bb104: {\n        StorageDead(_169);\n        StorageDead(_168);\n        StorageDead(_125);\n        StorageDead(_103);\n        goto -> bb55;\n    }\n    bb105: {\n        StorageDead(_86);\n        goto -> bb106;\n    }\n    bb106: {\n        StorageDead(_85);\n        StorageLive(_170);\n        StorageLive(_171);\n        _171 = &_28;\n        StorageLive(_172);\n        StorageLive(_173);\n        StorageLive(_174);\n        _174 = &mut _30;\n        _173 = num::bignum::Big32x40::mul_small(move _174, 5_u32) -> [return: bb107, unwind unreachable];\n    }\n    bb107: {\n        _172 = &(*_173);\n        StorageDead(_174);\n        _170 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _171, move _172) -> [return: bb108, unwind unreachable];\n    }\n    bb108: {\n        StorageDead(_172);\n        StorageDead(_171);\n        StorageDead(_173);\n        StorageLive(_175);\n        StorageLive(_176);\n        _176 = &_170;\n        StorageLive(_177);\n        _177 = num::flt2dec::strategy::dragon::format_exact::promoted[1];\n        _175 = <cmp::Ordering as cmp::PartialEq>::eq(move _176, move _177) -> [return: bb109, unwind unreachable];\n    }\n    bb109: {\n        switchInt(move _175) -> [0: bb111, otherwise: bb110];\n    }\n    bb110: {\n        StorageDead(_177);\n        StorageDead(_176);\n        goto -> bb119;\n    }\n    bb111: {\n        StorageDead(_177);\n        StorageDead(_176);\n        StorageLive(_178);\n        StorageLive(_179);\n        _179 = &_170;\n        StorageLive(_180);\n        _180 = num::flt2dec::strategy::dragon::format_exact::promoted[0];\n        _178 = <cmp::Ordering as cmp::PartialEq>::eq(move _179, move _180) -> [return: bb112, unwind unreachable];\n    }\n    bb112: {\n        switchInt(move _178) -> [0: bb136, otherwise: bb113];\n    }\n    bb113: {\n        StorageDead(_180);\n        StorageDead(_179);\n        StorageLive(_181);\n        StorageLive(_182);\n        _182 = _69;\n        _181 = Gt(move _182, 0_usize);\n        switchInt(move _181) -> [0: bb135, otherwise: bb114];\n    }\n    bb114: {\n        StorageDead(_182);\n        StorageLive(_183);\n        StorageLive(_184);\n        StorageLive(_185);\n        StorageLive(_186);\n        StorageLive(_187);\n        _187 = _69;\n        _188 = CheckedSub(_187, 1_usize);\n        assert(!move (_188.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _187, 1_usize) -> [success: bb115, unwind unreachable];\n    }\n    bb115: {\n        _186 = move (_188.0: usize);\n        StorageDead(_187);\n        _189 = &raw const (fake) (*_2);\n        _190 = PtrMetadata(move _189);\n        _191 = Lt(_186, _190);\n        assert(move _191, \"index out of bounds: the length is {} but the index is {}\", move _190, _186) -> [success: bb116, unwind unreachable];\n    }\n    bb116: {\n        _185 = (*_2)[_186];\n        _184 = mem::maybe_uninit::MaybeUninit::<u8>::assume_init(move _185) -> [return: bb117, unwind unreachable];\n    }\n    bb117: {\n        StorageDead(_186);\n        StorageDead(_185);\n        _183 = BitAnd(move _184, 1_u8);\n        StorageDead(_184);\n        switchInt(move _183) -> [1: bb118, otherwise: bb134];\n    }\n    bb118: {\n        StorageDead(_183);\n        goto -> bb119;\n    }\n    bb119: {\n        StorageLive(_192);\n        StorageLive(_195);\n        StorageLive(_196);\n        _196 = _69;\n        _195 = RangeTo(move _196);\n        StorageDead(_196);\n        _194 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_2, move _195) -> [return: bb120, unwind unreachable];\n    }\n    bb120: {\n        StorageDead(_195);\n        _193 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_194) -> [return: bb121, unwind unreachable];\n    }\n    bb121: {\n        _192 = num::flt2dec::round_up(_193) -> [return: bb122, unwind unreachable];\n    }\n    bb122: {\n        _197 = discriminant(_192);\n        switchInt(move _197) -> [1: bb123, 0: bb133, otherwise: bb57];\n    }\n    bb123: {\n        _198 = ((_192 as variant#1).0: u8);\n        _199 = CheckedAdd(_25, 1_i16);\n        assert(!move (_199.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, 1_i16) -> [success: bb124, unwind unreachable];\n    }\n    bb124: {\n        _25 = move (_199.0: i16);\n        StorageLive(_200);\n        StorageLive(_201);\n        _201 = _25;\n        _200 = Gt(move _201, _3);\n        switchInt(move _200) -> [0: bb131, otherwise: bb125];\n    }\n    bb125: {\n        StorageDead(_201);\n        StorageLive(_202);\n        StorageLive(_203);\n        _203 = _69;\n        StorageLive(_204);\n        StorageLive(_205);\n        _205 = &(*_2);\n        _204 = PtrMetadata(move _205);\n        StorageDead(_205);\n        _202 = Lt(move _203, move _204);\n        switchInt(move _202) -> [0: bb130, otherwise: bb126];\n    }\n    bb126: {\n        StorageDead(_204);\n        StorageDead(_203);\n        StorageLive(_206);\n        _206 = mem::maybe_uninit::MaybeUninit::<u8>::new(_198) -> [return: bb127, unwind unreachable];\n    }\n    bb127: {\n        StorageLive(_207);\n        _207 = _69;\n        _208 = &raw const (fake) (*_2);\n        _209 = PtrMetadata(move _208);\n        _210 = Lt(_207, _209);\n        assert(move _210, \"index out of bounds: the length is {} but the index is {}\", move _209, _207) -> [success: bb128, unwind unreachable];\n    }\n    bb128: {\n        (*_2)[_207] = move _206;\n        StorageDead(_206);\n        StorageDead(_207);\n        _211 = CheckedAdd(_69, 1_usize);\n        assert(!move (_211.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _69, 1_usize) -> [success: bb129, unwind unreachable];\n    }\n    bb129: {\n        _69 = move (_211.0: usize);\n        goto -> bb132;\n    }\n    bb130: {\n        StorageDead(_204);\n        StorageDead(_203);\n        goto -> bb132;\n    }\n    bb131: {\n        StorageDead(_201);\n        goto -> bb132;\n    }\n    bb132: {\n        StorageDead(_202);\n        StorageDead(_200);\n        StorageDead(_192);\n        goto -> bb137;\n    }\n    bb133: {\n        StorageDead(_192);\n        goto -> bb137;\n    }\n    bb134: {\n        StorageDead(_183);\n        goto -> bb137;\n    }\n    bb135: {\n        StorageDead(_182);\n        goto -> bb137;\n    }\n    bb136: {\n        StorageDead(_180);\n        StorageDead(_179);\n        goto -> bb137;\n    }\n    bb137: {\n        StorageDead(_181);\n        StorageDead(_178);\n        StorageDead(_175);\n        StorageLive(_214);\n        _214 = &(*_2);\n        StorageLive(_215);\n        StorageLive(_216);\n        _216 = _69;\n        _215 = RangeTo(move _216);\n        StorageDead(_216);\n        _213 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _214, move _215) -> [return: bb138, unwind unreachable];\n    }\n    bb138: {\n        StorageDead(_215);\n        StorageDead(_214);\n        _212 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_213) -> [return: bb139, unwind unreachable];\n    }\n    bb139: {\n        StorageLive(_217);\n        _217 = _25;\n        _0 = (_212, move _217);\n        StorageDead(_217);\n        StorageDead(_170);\n        StorageDead(_69);\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageDead(_25);\n        goto -> bb140;\n    }\n    bb140: {\n        return;\n    }\n}\n",
  "doc": " The exact and fixed mode implementation for Dragon.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}