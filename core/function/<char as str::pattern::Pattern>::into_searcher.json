{
  "name": "<char as str::pattern::Pattern>::into_searcher",
  "safe": true,
  "callees": {
    "char::methods::<impl char>::encode_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Encodes this character as UTF-8 into the provided byte buffer,\n and then returns the subslice of the buffer that contains the encoded character.\n\n # Panics\n\n Panics if the buffer is not large enough.\n A buffer of length four is large enough to encode any `char`.\n\n # Examples\n\n In both of these examples, 'ß' takes two bytes to encode.\n\n ```\n let mut b = [0; 2];\n\n let result = 'ß'.encode_utf8(&mut b);\n\n assert_eq!(result, \"ß\");\n\n assert_eq!(result.len(), 2);\n ```\n\n A buffer that's too small:\n\n ```should_panic\n let mut b = [0; 1];\n\n // this panics\n 'ß'.encode_utf8(&mut b);\n ```\n",
      "adt": {}
    },
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ],
    "str::pattern::CharSearcher": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<char as str::pattern::Pattern>::into_searcher"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs:564:5: 580:6",
  "src": "fn into_searcher<'a>(self, haystack: &'a str) -> Self::Searcher<'a> {\n        let mut utf8_encoded = [0; char::MAX_LEN_UTF8];\n        let utf8_size = self\n            .encode_utf8(&mut utf8_encoded)\n            .len()\n            .try_into()\n            .expect(\"char len should be less than 255\");\n\n        CharSearcher {\n            haystack,\n            finger: 0,\n            finger_back: haystack.len(),\n            needle: self,\n            utf8_size,\n            utf8_encoded,\n        }\n    }",
  "mir": "fn <char as str::pattern::Pattern>::into_searcher(_1: char, _2: &str) -> str::pattern::CharSearcher<'_> {\n    let mut _0: str::pattern::CharSearcher<'_>;\n    let mut _3: [u8; 4];\n    let  _4: u8;\n    let mut _5: result::Result<u8, num::error::TryFromIntError>;\n    let mut _6: usize;\n    let mut _7: &str;\n    let  _8: &mut str;\n    let mut _9: &mut [u8];\n    let mut _10: &mut [u8; 4];\n    let mut _11: &str;\n    let mut _12: usize;\n    let mut _13: [u8; 4];\n    debug self => _1;\n    debug haystack => _2;\n    debug utf8_encoded => _3;\n    debug utf8_size => _4;\n    bb0: {\n        StorageLive(_3);\n        _3 = [0_u8; 4];\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _10 = &mut _3;\n        _9 = _10 as &mut [u8];\n        _8 = char::methods::<impl char>::encode_utf8(_1, move _9) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = &(*_8);\n        StorageDead(_9);\n        _6 = str::<impl str>::len(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = <usize as convert::TryInto<u8>>::try_into(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_11);\n        _11 = \"char len should be less than 255\";\n        _4 = result::Result::<u8, num::error::TryFromIntError>::expect(move _5, move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageDead(_5);\n        StorageDead(_8);\n        StorageLive(_12);\n        _12 = str::<impl str>::len(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_13);\n        _13 = _3;\n        _0 = CharSearcher(_2, 0_usize, move _12, _1, _4, move _13);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}