{
  "name": "<array::iter::IntoIter<T, N> as ops::drop::Drop>::drop",
  "safe": true,
  "callees": {
    "mem::needs_drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if dropping values of type `T` matters.\n\n This is purely an optimization hint, and may be implemented conservatively:\n it may return `true` for types that don't actually need to be dropped.\n As such always returning `true` would be a valid implementation of\n this function. However if this function actually returns `false`, then you\n can be certain dropping `T` has no side effect.\n\n Low level implementations of things like collections, which need to manually\n drop their data, should use this function to avoid unnecessarily\n trying to drop all their contents when they are destroyed. This might not\n make a difference in release builds (where a loop that has no side-effects\n is easily detected and eliminated), but is often a big win for debug builds.\n\n Note that [`drop_in_place`] already performs this check, so if your workload\n can be reduced to some small number of [`drop_in_place`] calls, using this is\n unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n will do a single needs_drop check for all the values.\n\n Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n values one at a time and should use this API.\n\n [`drop_in_place`]: crate::ptr::drop_in_place\n [`HashMap`]: ../../std/collections/struct.HashMap.html\n\n # Examples\n\n Here's an example of how a collection might make use of `needs_drop`:\n\n ```\n use std::{mem, ptr};\n\n pub struct MyCollection<T> {\n #   data: [T; 1],\n     /* ... */\n }\n # impl<T> MyCollection<T> {\n #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n #   fn free_buffer(&mut self) {}\n # }\n\n impl<T> Drop for MyCollection<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // drop the data\n             if mem::needs_drop::<T>() {\n                 for x in self.iter_mut() {\n                     ptr::drop_in_place(x);\n                 }\n             }\n             self.free_buffer();\n         }\n     }\n }\n ```\n",
      "adt": {}
    },
    "mem::manually_drop::ManuallyDrop::<T>::drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Manually drops the contained value.\n\n This is exactly equivalent to calling [`ptr::drop_in_place`] with a\n pointer to the contained value. As such, unless the contained value is a\n packed struct, the destructor will be called in-place without moving the\n value, and thus can be used to safely drop [pinned] data.\n\n If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n\n # Safety\n\n This function runs the destructor of the contained value. Other than changes made by\n the destructor itself, the memory is left unchanged, and so as far as the compiler is\n concerned still holds a bit-pattern which is valid for the type `T`.\n\n However, this \"zombie\" value should not be exposed to safe code, and this function\n should not be called more than once. To use a value after it's been dropped, or drop\n a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n This is normally prevented by the type system, but users of `ManuallyDrop` must\n uphold those guarantees without assistance from the compiler.\n\n [pinned]: crate::pin\n",
      "adt": {
        "mem::manually_drop::ManuallyDrop": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mem::manually_drop::ManuallyDrop": [
      "MutRef"
    ],
    "array::iter::IntoIter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 4540,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/iter.rs:332:5: 337:6",
  "src": "fn drop(&mut self) {\n        if crate::mem::needs_drop::<T>() {\n            // SAFETY: This is the only place where we drop this field.\n            unsafe { ManuallyDrop::drop(&mut self.inner) }\n        }\n    }",
  "mir": "fn <array::iter::IntoIter<T, N> as ops::drop::Drop>::drop(_1: &mut array::iter::IntoIter<T, N>) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: &mut mem::manually_drop::ManuallyDrop<array::iter::iter_inner::PolymorphicIter<[mem::maybe_uninit::MaybeUninit<T>; N]>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = mem::needs_drop::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        _3 = &mut ((*_1).0: mem::manually_drop::ManuallyDrop<array::iter::iter_inner::PolymorphicIter<[mem::maybe_uninit::MaybeUninit<T>; N]>>);\n        _0 = mem::manually_drop::ManuallyDrop::<array::iter::iter_inner::PolymorphicIter<[mem::maybe_uninit::MaybeUninit<T>; N]>>::drop(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}