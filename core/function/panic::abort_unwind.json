{
  "name": "panic::abort_unwind",
  "safe": true,
  "callees": {
    "ops::function::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 15811,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic.rs:119:1: 121:2",
  "src": "pub fn abort_unwind<F: FnOnce() -> R, R>(f: F) -> R {\n    f()\n}",
  "mir": "fn panic::abort_unwind(_1: F) -> R {\n    let mut _0: R;\n    debug f => _1;\n    bb0: {\n        _0 = <F as ops::function::FnOnce<()>>::call_once(_1, ()) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Invokes a closure, aborting if the closure unwinds.\n\n When compiled with aborting panics, this function is effectively a no-op.\n With unwinding panics, an unwind results in another call into the panic\n hook followed by a process abort.\n\n # Notes\n\n Instead of using this function, code should attempt to support unwinding.\n Implementing [`Drop`] allows you to restore invariants uniformly in both\n return and unwind paths.\n\n If an unwind can lead to logical issues but not soundness issues, you\n should allow the unwind. Opting out of [`UnwindSafe`] indicates to your\n consumers that they need to consider correctness in the face of unwinds.\n\n If an unwind would be unsound, then this function should be used in order\n to prevent unwinds. However, note that `extern \"C\" fn` will automatically\n convert unwinds to aborts, so using this function isn't necessary for FFI.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}