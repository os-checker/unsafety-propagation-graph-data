{
  "name": "task::wake::Waker::noop",
  "safe": true,
  "callees": {},
  "adts": {
    "task::wake::Waker": [
      "Ref"
    ]
  },
  "path": 17630,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/task/wake.rs:567:5: 570:6",
  "src": "pub const fn noop() -> &'static Waker {\n        const WAKER: &Waker = &Waker { waker: RawWaker::NOOP };\n        WAKER\n    }",
  "mir": "fn task::wake::Waker::noop() -> &task::wake::Waker {\n    let mut _0: &task::wake::Waker;\n    bb0: {\n        _0 = task::wake::Waker::noop::WAKER;\n        return;\n    }\n}\n",
  "doc": " Returns a reference to a `Waker` that does nothing when used.\n\n This is mostly useful for writing tests that need a [`Context`] to poll\n some futures, but are not expecting those futures to wake the waker or\n do not need to do anything specific if it happens.\n\n More generally, using `Waker::noop()` to poll a future\n means discarding the notification of when the future should be polled again.\n So it should only be used when such a notification will not be needed to make progress.\n\n If an owned `Waker` is needed, `clone()` this one.\n\n # Examples\n\n ```\n use std::future::Future;\n use std::task;\n\n let mut cx = task::Context::from_waker(task::Waker::noop());\n\n let mut future = Box::pin(async { 10 });\n assert_eq!(future.as_mut().poll(&mut cx), task::Poll::Ready(10));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}