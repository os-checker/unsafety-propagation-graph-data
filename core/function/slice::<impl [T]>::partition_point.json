{
  "name": "slice::<impl [T]>::partition_point",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::binary_search_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Binary searches this slice with a comparator function.\n\n The comparator function should return an order code that indicates\n whether its argument is `Less`, `Equal` or `Greater` the desired\n target.\n If the slice is not sorted or if the comparator function does not\n implement an order consistent with the sort order of the underlying\n slice, the returned result is unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search`]: slice::binary_search\n [`binary_search_by_key`]: slice::binary_search_by_key\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n let seek = 13;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Ok(9));\n let seek = 4;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(7));\n let seek = 100;\n assert_eq!(s.binary_search_by(|probe| probe.cmp(&seek)), Err(13));\n let seek = 1;\n let r = s.binary_search_by(|probe| probe.cmp(&seek));\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ]
  },
  "path": 1283,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4426:5: 4431:6",
  "src": "pub fn partition_point<P>(&self, mut pred: P) -> usize\n    where\n        P: FnMut(&T) -> bool,\n    {\n        self.binary_search_by(|x| if pred(x) { Less } else { Greater }).unwrap_or_else(|i| i)\n    }",
  "mir": "fn slice::<impl [T]>::partition_point(_1: &[T], _2: P) -> usize {\n    let mut _0: usize;\n    let mut _3: result::Result<usize, usize>;\n    let mut _4: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4430:31: 4430:34};\n    let mut _5: &mut P;\n    debug self => _1;\n    debug pred => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _2;\n        _4 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4430:31: 4430:34}(move _5);\n        StorageDead(_5);\n        _3 = slice::<impl [T]>::binary_search_by::<'_, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4430:31: 4430:34}>(_1, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = result::Result::<usize, usize>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4430:88: 4430:91}>(move _3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4430:88: 4430:91}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        return;\n    }\n}\n",
  "doc": " Returns the index of the partition point according to the given predicate\n (the index of the first element of the second partition).\n\n The slice is assumed to be partitioned according to the given predicate.\n This means that all elements for which the predicate returns true are at the start of the slice\n and all elements for which the predicate returns false are at the end.\n For example, `[7, 15, 3, 5, 4, 12, 6]` is partitioned under the predicate `x % 2 != 0`\n (all odd numbers are at the start, all even at the end).\n\n If this slice is not partitioned, the returned result is unspecified and meaningless,\n as this method performs a kind of binary search.\n\n See also [`binary_search`], [`binary_search_by`], and [`binary_search_by_key`].\n\n [`binary_search`]: slice::binary_search\n [`binary_search_by`]: slice::binary_search_by\n [`binary_search_by_key`]: slice::binary_search_by_key\n\n # Examples\n\n ```\n let v = [1, 2, 3, 3, 5, 6, 7];\n let i = v.partition_point(|&x| x < 5);\n\n assert_eq!(i, 4);\n assert!(v[..i].iter().all(|&x| x < 5));\n assert!(v[i..].iter().all(|&x| !(x < 5)));\n ```\n\n If all elements of the slice match the predicate, including if the slice\n is empty, then the length of the slice will be returned:\n\n ```\n let a = [2, 4, 8];\n assert_eq!(a.partition_point(|x| x < &100), a.len());\n let a: [i32; 0] = [];\n assert_eq!(a.partition_point(|x| x < &100), 0);\n ```\n\n If you want to insert an item to a sorted vector, while maintaining\n sort order:\n\n ```\n let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n let num = 42;\n let idx = s.partition_point(|&x| x <= num);\n s.insert(idx, num);\n assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}