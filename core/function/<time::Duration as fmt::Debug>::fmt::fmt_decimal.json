{
  "name": "<time::Duration as fmt::Debug>::fmt::fmt_decimal",
  "safe": true,
  "callees": {
    "fmt::Formatter::<'a>::precision": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the optionally specified precision for numeric types.\n Alternatively, the maximum width for string types.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(f32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if let Some(precision) = formatter.precision() {\n             // If we received a precision, we use it.\n             write!(formatter, \"Foo({1:.*})\", precision, self.0)\n         } else {\n             // Otherwise we default to 2.\n             write!(formatter, \"Foo({:.2})\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:.4}\", Foo(23.2)), \"Foo(23.2000)\");\n assert_eq!(format!(\"{}\", Foo(23.2)), \"Foo(23.20)\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "fmt::Formatter::<'a>::width": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the optionally specified integer width that the output should be.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if let Some(width) = formatter.width() {\n             // If we received a width, we use it\n             write!(formatter, \"{:width$}\", format!(\"Foo({})\", self.0), width = width)\n         } else {\n             // Otherwise we do nothing special\n             write!(formatter, \"Foo({})\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:10}\", Foo(23)), \"Foo(23)   \");\n assert_eq!(format!(\"{}\", Foo(23)), \"Foo(23)\");\n ```\n",
      "adt": {
        "fmt::Formatter": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "ops::function::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"y̆\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'y̆'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {
        "str::iter::Chars": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the iterator, counting the number of iterations and returning it.\n\n This method will call [`next`] repeatedly until [`None`] is encountered,\n returning the number of times it saw [`Some`]. Note that [`next`] has to be\n called at least once even if the iterator does not have any elements.\n\n [`next`]: Iterator::next\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so counting elements of\n an iterator with more than [`usize::MAX`] elements either produces the\n wrong result or panics. If overflow checks are enabled, a panic is\n guaranteed.\n\n # Panics\n\n This function might panic if the iterator has more than [`usize::MAX`]\n elements.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().count(), 3);\n\n let a = [1, 2, 3, 4, 5];\n assert_eq!(a.iter().count(), 5);\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::checked_ilog10": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base 10 logarithm of the number, rounded down.\n\n Returns `None` if the number is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "fmt::Formatter::<'a>::padding": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes the pre-padding and returns the unwritten post-padding.\n\n Callers are responsible for ensuring post-padding is written after the\n thing that is being padded.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor",
        "fmt::PostPadding": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "fmt::PostPadding::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes this post padding.\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "fmt::Formatter": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 325, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Uint(U32)) })])"
    ],
    "result::Result": [
      "Plain"
    ],
    "str::iter::Chars": [
      "Plain"
    ],
    "fmt::Alignment": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11599, kind: RigidTy(Adt(AdtDef(DefId { id: 27980, name: \"fmt::PostPadding\" }), GenericArgs([]))) })])"
    ],
    "fmt::PostPadding": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<time::Duration as fmt::Debug>::fmt::fmt_decimal"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1286:9: 1431:10",
  "src": "fn fmt_decimal(\n            f: &mut fmt::Formatter<'_>,\n            integer_part: u64,\n            mut fractional_part: u32,\n            mut divisor: u32,\n            prefix: &str,\n            postfix: &str,\n        ) -> fmt::Result {\n            // Encode the fractional part into a temporary buffer. The buffer\n            // only need to hold 9 elements, because `fractional_part` has to\n            // be smaller than 10^9. The buffer is prefilled with '0' digits\n            // to simplify the code below.\n            let mut buf = [b'0'; 9];\n\n            // The next digit is written at this position\n            let mut pos = 0;\n\n            // We keep writing digits into the buffer while there are non-zero\n            // digits left and we haven't written enough digits yet.\n            while fractional_part > 0 && pos < f.precision().unwrap_or(9) {\n                // Write new digit into the buffer\n                buf[pos] = b'0' + (fractional_part / divisor) as u8;\n\n                fractional_part %= divisor;\n                divisor /= 10;\n                pos += 1;\n            }\n\n            // If a precision < 9 was specified, there may be some non-zero\n            // digits left that weren't written into the buffer. In that case we\n            // need to perform rounding to match the semantics of printing\n            // normal floating point numbers. However, we only need to do work\n            // when rounding up. This happens if the first digit of the\n            // remaining ones is >= 5.\n            let integer_part = if fractional_part > 0 && fractional_part >= divisor * 5 {\n                // Round up the number contained in the buffer. We go through\n                // the buffer backwards and keep track of the carry.\n                let mut rev_pos = pos;\n                let mut carry = true;\n                while carry && rev_pos > 0 {\n                    rev_pos -= 1;\n\n                    // If the digit in the buffer is not '9', we just need to\n                    // increment it and can stop then (since we don't have a\n                    // carry anymore). Otherwise, we set it to '0' (overflow)\n                    // and continue.\n                    if buf[rev_pos] < b'9' {\n                        buf[rev_pos] += 1;\n                        carry = false;\n                    } else {\n                        buf[rev_pos] = b'0';\n                    }\n                }\n\n                // If we still have the carry bit set, that means that we set\n                // the whole buffer to '0's and need to increment the integer\n                // part.\n                if carry {\n                    // If `integer_part == u64::MAX` and precision < 9, any\n                    // carry of the overflow during rounding of the\n                    // `fractional_part` into the `integer_part` will cause the\n                    // `integer_part` itself to overflow. Avoid this by using an\n                    // `Option<u64>`, with `None` representing `u64::MAX + 1`.\n                    integer_part.checked_add(1)\n                } else {\n                    Some(integer_part)\n                }\n            } else {\n                Some(integer_part)\n            };\n\n            // Determine the end of the buffer: if precision is set, we just\n            // use as many digits from the buffer (capped to 9). If it isn't\n            // set, we only use all digits up to the last non-zero one.\n            let end = f.precision().map(|p| crate::cmp::min(p, 9)).unwrap_or(pos);\n\n            // This closure emits the formatted duration without emitting any\n            // padding (padding is calculated below).\n            let emit_without_padding = |f: &mut fmt::Formatter<'_>| {\n                if let Some(integer_part) = integer_part {\n                    write!(f, \"{}{}\", prefix, integer_part)?;\n                } else {\n                    // u64::MAX + 1 == 18446744073709551616\n                    write!(f, \"{}18446744073709551616\", prefix)?;\n                }\n\n                // Write the decimal point and the fractional part (if any).\n                if end > 0 {\n                    // SAFETY: We are only writing ASCII digits into the buffer and\n                    // it was initialized with '0's, so it contains valid UTF8.\n                    let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n\n                    // If the user request a precision > 9, we pad '0's at the end.\n                    let w = f.precision().unwrap_or(pos);\n                    write!(f, \".{:0<width$}\", s, width = w)?;\n                }\n\n                write!(f, \"{}\", postfix)\n            };\n\n            match f.width() {\n                None => {\n                    // No `width` specified. There's no need to calculate the\n                    // length of the output in this case, just emit it.\n                    emit_without_padding(f)\n                }\n                Some(requested_w) => {\n                    // A `width` was specified. Calculate the actual width of\n                    // the output in order to calculate the required padding.\n                    // It consists of 4 parts:\n                    // 1. The prefix: is either \"+\" or \"\", so we can just use len().\n                    // 2. The postfix: can be \"µs\" so we have to count UTF8 characters.\n                    let mut actual_w = prefix.len() + postfix.chars().count();\n                    // 3. The integer part:\n                    if let Some(integer_part) = integer_part {\n                        if let Some(log) = integer_part.checked_ilog10() {\n                            // integer_part is > 0, so has length log10(x)+1\n                            actual_w += 1 + log as usize;\n                        } else {\n                            // integer_part is 0, so has length 1.\n                            actual_w += 1;\n                        }\n                    } else {\n                        // integer_part is u64::MAX + 1, so has length 20\n                        actual_w += 20;\n                    }\n                    // 4. The fractional part (if any):\n                    if end > 0 {\n                        let frac_part_w = f.precision().unwrap_or(pos);\n                        actual_w += 1 + frac_part_w;\n                    }\n\n                    if requested_w <= actual_w {\n                        // Output is already longer than `width`, so don't pad.\n                        emit_without_padding(f)\n                    } else {\n                        // We need to add padding. Use the `Formatter::padding` helper function.\n                        let default_align = fmt::Alignment::Left;\n                        let post_padding =\n                            f.padding((requested_w - actual_w) as u16, default_align)?;\n                        emit_without_padding(f)?;\n                        post_padding.write(f)\n                    }\n                }\n            }\n        }",
  "mir": "fn <time::Duration as fmt::Debug>::fmt::fmt_decimal(_1: &mut fmt::Formatter<'_>, _2: u64, _3: u32, _4: u32, _5: &str, _6: &str) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _7: [u8; 9];\n    let mut _8: usize;\n    let mut _9: bool;\n    let mut _10: u32;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: option::Option<usize>;\n    let mut _15: &fmt::Formatter<'_>;\n    let mut _16: u8;\n    let mut _17: u32;\n    let mut _18: u32;\n    let mut _19: u32;\n    let mut _20: bool;\n    let mut _21: (u8, bool);\n    let  _22: usize;\n    let mut _23: bool;\n    let mut _24: u32;\n    let mut _25: bool;\n    let mut _26: bool;\n    let mut _27: (usize, bool);\n    let  _28: option::Option<u64>;\n    let mut _29: bool;\n    let mut _30: u32;\n    let mut _31: bool;\n    let mut _32: u32;\n    let mut _33: u32;\n    let mut _34: u32;\n    let mut _35: (u32, bool);\n    let mut _36: usize;\n    let mut _37: bool;\n    let mut _38: bool;\n    let mut _39: bool;\n    let mut _40: usize;\n    let mut _41: (usize, bool);\n    let mut _42: bool;\n    let mut _43: u8;\n    let  _44: usize;\n    let mut _45: bool;\n    let  _46: usize;\n    let mut _47: bool;\n    let mut _48: (u8, bool);\n    let  _49: usize;\n    let mut _50: bool;\n    let mut _51: bool;\n    let  _52: usize;\n    let mut _53: option::Option<usize>;\n    let mut _54: option::Option<usize>;\n    let mut _55: &fmt::Formatter<'_>;\n    let mut _56: usize;\n    let  _57: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68};\n    let mut _58: &option::Option<u64>;\n    let mut _59: &&str;\n    let mut _60: &usize;\n    let mut _61: &[u8; 9];\n    let mut _62: &usize;\n    let mut _63: &&str;\n    let mut _64: option::Option<usize>;\n    let mut _65: &fmt::Formatter<'_>;\n    let mut _66: isize;\n    let mut _67: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68};\n    let mut _68: (&mut fmt::Formatter<'_>,);\n    let  _69: usize;\n    let mut _70: usize;\n    let mut _71: usize;\n    let mut _72: usize;\n    let mut _73: str::iter::Chars<'_>;\n    let mut _74: (usize, bool);\n    let mut _75: isize;\n    let  _76: u64;\n    let mut _77: option::Option<u32>;\n    let mut _78: isize;\n    let  _79: u32;\n    let mut _80: usize;\n    let mut _81: usize;\n    let mut _82: (usize, bool);\n    let mut _83: (usize, bool);\n    let mut _84: (usize, bool);\n    let mut _85: (usize, bool);\n    let mut _86: bool;\n    let  _87: usize;\n    let mut _88: option::Option<usize>;\n    let mut _89: &fmt::Formatter<'_>;\n    let mut _90: usize;\n    let mut _91: usize;\n    let mut _92: (usize, bool);\n    let mut _93: (usize, bool);\n    let mut _94: bool;\n    let mut _95: usize;\n    let mut _96: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68};\n    let mut _97: (&mut fmt::Formatter<'_>,);\n    let  _98: fmt::Alignment;\n    let mut _99: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>, fmt::PostPadding>;\n    let mut _100: result::Result<fmt::PostPadding, fmt::Error>;\n    let mut _101: u16;\n    let mut _102: usize;\n    let mut _103: usize;\n    let mut _104: (usize, bool);\n    let mut _105: isize;\n    let  _106: fmt::PostPadding;\n    let mut _107: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _108: result::Result<(), fmt::Error>;\n    let mut _109: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68};\n    let mut _110: (&mut fmt::Formatter<'_>,);\n    let mut _111: isize;\n    debug f => _1;\n    debug integer_part => _2;\n    debug fractional_part => _3;\n    debug divisor => _4;\n    debug prefix => _5;\n    debug postfix => _6;\n    debug buf => _7;\n    debug pos => _8;\n    debug integer_part => _28;\n    debug rev_pos => _36;\n    debug carry => _37;\n    debug end => _52;\n    debug emit_without_padding => _57;\n    debug requested_w => _69;\n    debug actual_w => _70;\n    debug integer_part => _76;\n    debug log => _79;\n    debug frac_part_w => _87;\n    debug default_align => _98;\n    debug post_padding => _106;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => _106;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_7);\n        _7 = [48_u8; 9];\n        StorageLive(_8);\n        _8 = 0_usize;\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _3;\n        _9 = Gt(move _10, 0_u32);\n        switchInt(move _9) -> [0: bb13, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _8;\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = fmt::Formatter::<'_>::precision(move _15) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_15);\n        _13 = option::Option::<usize>::unwrap_or(move _14, 9_usize) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_14);\n        _11 = Lt(move _12, move _13);\n        switchInt(move _11) -> [0: bb12, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _3;\n        StorageLive(_19);\n        _19 = _4;\n        _20 = Eq(_19, 0_u32);\n        assert(!move _20, \"attempt to divide `{}` by zero\", _18) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _17 = Div(move _18, move _19);\n        StorageDead(_19);\n        StorageDead(_18);\n        _16 = move _17 as u8;\n        StorageDead(_17);\n        _21 = CheckedAdd(48_u8, _16);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _16) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_22);\n        _22 = _8;\n        _23 = Lt(_22, 9_usize);\n        assert(move _23, \"index out of bounds: the length is {} but the index is {}\", 9_usize, _22) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _7[_22] = move (_21.0: u8);\n        StorageDead(_16);\n        StorageDead(_22);\n        StorageLive(_24);\n        _24 = _4;\n        _25 = Eq(_24, 0_u32);\n        assert(!move _25, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _3) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _3 = Rem(_3, move _24);\n        StorageDead(_24);\n        _26 = Eq(10_u32, 0_u32);\n        assert(!move _26, \"attempt to divide `{}` by zero\", _4) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _4 = Div(_4, 10_u32);\n        _27 = CheckedAdd(_8, 1_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _8, 1_usize) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _8 = move (_27.0: usize);\n        StorageDead(_11);\n        StorageDead(_9);\n        goto -> bb1;\n    }\n    bb12: {\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_10);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _3;\n        _29 = Gt(move _30, 0_u32);\n        switchInt(move _29) -> [0: bb16, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _3;\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = _4;\n        _35 = CheckedMul(_34, 5_u32);\n        assert(!move (_35.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _34, 5_u32) -> [success: bb17, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_30);\n        goto -> bb37;\n    }\n    bb17: {\n        _33 = move (_35.0: u32);\n        StorageDead(_34);\n        _31 = Ge(move _32, move _33);\n        switchInt(move _31) -> [0: bb36, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_36);\n        _36 = _8;\n        StorageLive(_37);\n        _37 = true;\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_38);\n        _38 = _37;\n        switchInt(move _38) -> [0: bb31, otherwise: bb20];\n    }\n    bb20: {\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = _36;\n        _39 = Gt(move _40, 0_usize);\n        switchInt(move _39) -> [0: bb30, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_40);\n        _41 = CheckedSub(_36, 1_usize);\n        assert(!move (_41.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _36, 1_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _36 = move (_41.0: usize);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = _36;\n        _45 = Lt(_44, 9_usize);\n        assert(move _45, \"index out of bounds: the length is {} but the index is {}\", 9_usize, _44) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _43 = _7[_44];\n        _42 = Lt(move _43, 57_u8);\n        switchInt(move _42) -> [0: bb27, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageLive(_46);\n        _46 = _36;\n        _47 = Lt(_46, 9_usize);\n        assert(move _47, \"index out of bounds: the length is {} but the index is {}\", 9_usize, _46) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _48 = CheckedAdd(_7[_46], 1_u8);\n        assert(!move (_48.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _7[_46], 1_u8) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _7[_46] = move (_48.0: u8);\n        StorageDead(_46);\n        _37 = false;\n        goto -> bb29;\n    }\n    bb27: {\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageLive(_49);\n        _49 = _36;\n        _50 = Lt(_49, 9_usize);\n        assert(move _50, \"index out of bounds: the length is {} but the index is {}\", 9_usize, _49) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _7[_49] = 48_u8;\n        StorageDead(_49);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_42);\n        StorageDead(_39);\n        StorageDead(_38);\n        goto -> bb19;\n    }\n    bb30: {\n        StorageDead(_40);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_51);\n        _51 = _37;\n        switchInt(move _51) -> [0: bb33, otherwise: bb32];\n    }\n    bb32: {\n        _28 = num::<impl u64>::checked_add(_2, 1_u64) -> [return: bb34, unwind unreachable];\n    }\n    bb33: {\n        _28 = option::Option::Some(_2);\n        goto -> bb35;\n    }\n    bb34: {\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_51);\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb38;\n    }\n    bb36: {\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb37;\n    }\n    bb37: {\n        _28 = option::Option::Some(_2);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_31);\n        StorageDead(_29);\n        StorageLive(_53);\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = &(*_1);\n        _54 = fmt::Formatter::<'_>::precision(move _55) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_55);\n        _53 = option::Option::<usize>::map::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1360:41: 1360:44}>(move _54, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1360:41: 1360:44}) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_54);\n        StorageLive(_56);\n        _56 = _8;\n        _52 = option::Option::<usize>::unwrap_or(move _53, move _56) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_56);\n        StorageDead(_53);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = &_28;\n        StorageLive(_59);\n        _59 = &_5;\n        StorageLive(_60);\n        _60 = &_52;\n        StorageLive(_61);\n        _61 = &_7;\n        StorageLive(_62);\n        _62 = &_8;\n        StorageLive(_63);\n        _63 = &_6;\n        _57 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68}(move _58, move _59, move _60, move _61, move _62, move _63);\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageDead(_61);\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = &(*_1);\n        _64 = fmt::Formatter::<'_>::width(move _65) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_65);\n        _66 = discriminant(_64);\n        switchInt(move _66) -> [0: bb45, 1: bb44, otherwise: bb43];\n    }\n    bb43: {\n        unreachable;\n    }\n    bb44: {\n        _69 = ((_64 as variant#1).0: usize);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = str::<impl str>::len(_5) -> [return: bb47, unwind unreachable];\n    }\n    bb45: {\n        StorageLive(_67);\n        _67 = &_57;\n        StorageLive(_68);\n        _68 = (_1);\n        _0 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68} as ops::function::Fn<(&mut fmt::Formatter<'_>,)>>::call(move _67, move _68) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_68);\n        StorageDead(_67);\n        goto -> bb85;\n    }\n    bb47: {\n        StorageLive(_72);\n        StorageLive(_73);\n        _73 = str::<impl str>::chars(_6) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        _72 = <str::iter::Chars<'_> as iter::traits::iterator::Iterator>::count(move _73) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_73);\n        _74 = CheckedAdd(_71, _72);\n        assert(!move (_74.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _71, move _72) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _70 = move (_74.0: usize);\n        StorageDead(_72);\n        StorageDead(_71);\n        _75 = discriminant(_28);\n        switchInt(move _75) -> [1: bb51, 0: bb59, otherwise: bb43];\n    }\n    bb51: {\n        _76 = ((_28 as variant#1).0: u64);\n        StorageLive(_77);\n        _77 = num::<impl u64>::checked_ilog10(_76) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        _78 = discriminant(_77);\n        switchInt(move _78) -> [1: bb53, 0: bb56, otherwise: bb43];\n    }\n    bb53: {\n        _79 = ((_77 as variant#1).0: u32);\n        StorageLive(_80);\n        StorageLive(_81);\n        _81 = _79 as usize;\n        _82 = CheckedAdd(1_usize, _81);\n        assert(!move (_82.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 1_usize, move _81) -> [success: bb54, unwind unreachable];\n    }\n    bb54: {\n        _80 = move (_82.0: usize);\n        StorageDead(_81);\n        _83 = CheckedAdd(_70, _80);\n        assert(!move (_83.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _70, move _80) -> [success: bb55, unwind unreachable];\n    }\n    bb55: {\n        _70 = move (_83.0: usize);\n        StorageDead(_80);\n        StorageDead(_77);\n        goto -> bb58;\n    }\n    bb56: {\n        StorageDead(_77);\n        _84 = CheckedAdd(_70, 1_usize);\n        assert(!move (_84.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _70, 1_usize) -> [success: bb57, unwind unreachable];\n    }\n    bb57: {\n        _70 = move (_84.0: usize);\n        goto -> bb58;\n    }\n    bb58: {\n        goto -> bb61;\n    }\n    bb59: {\n        _85 = CheckedAdd(_70, 20_usize);\n        assert(!move (_85.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _70, 20_usize) -> [success: bb60, unwind unreachable];\n    }\n    bb60: {\n        _70 = move (_85.0: usize);\n        goto -> bb61;\n    }\n    bb61: {\n        StorageLive(_86);\n        _86 = Gt(_52, 0_usize);\n        switchInt(move _86) -> [0: bb67, otherwise: bb62];\n    }\n    bb62: {\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = &(*_1);\n        _88 = fmt::Formatter::<'_>::precision(move _89) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_89);\n        StorageLive(_90);\n        _90 = _8;\n        _87 = option::Option::<usize>::unwrap_or(move _88, move _90) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_90);\n        StorageDead(_88);\n        StorageLive(_91);\n        _92 = CheckedAdd(1_usize, _87);\n        assert(!move (_92.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 1_usize, _87) -> [success: bb65, unwind unreachable];\n    }\n    bb65: {\n        _91 = move (_92.0: usize);\n        _93 = CheckedAdd(_70, _91);\n        assert(!move (_93.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _70, move _91) -> [success: bb66, unwind unreachable];\n    }\n    bb66: {\n        _70 = move (_93.0: usize);\n        StorageDead(_91);\n        goto -> bb68;\n    }\n    bb67: {\n        goto -> bb68;\n    }\n    bb68: {\n        StorageDead(_86);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = _70;\n        _94 = Le(_69, move _95);\n        switchInt(move _94) -> [0: bb71, otherwise: bb69];\n    }\n    bb69: {\n        StorageDead(_95);\n        StorageLive(_96);\n        _96 = &_57;\n        StorageLive(_97);\n        _97 = (_1);\n        _0 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68} as ops::function::Fn<(&mut fmt::Formatter<'_>,)>>::call(move _96, move _97) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_97);\n        StorageDead(_96);\n        goto -> bb84;\n    }\n    bb71: {\n        StorageDead(_95);\n        _98 = fmt::Alignment::Left;\n        StorageLive(_99);\n        StorageLive(_100);\n        StorageLive(_101);\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = _70;\n        _104 = CheckedSub(_69, _103);\n        assert(!move (_104.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _69, move _103) -> [success: bb72, unwind unreachable];\n    }\n    bb72: {\n        _102 = move (_104.0: usize);\n        StorageDead(_103);\n        _101 = move _102 as u16;\n        StorageDead(_102);\n        _100 = fmt::Formatter::<'_>::padding(_1, move _101, _98) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        StorageDead(_101);\n        _99 = <result::Result<fmt::PostPadding, fmt::Error> as ops::try_trait::Try>::branch(move _100) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_100);\n        _105 = discriminant(_99);\n        switchInt(move _105) -> [0: bb75, 1: bb76, otherwise: bb43];\n    }\n    bb75: {\n        _106 = move ((_99 as variant#0).0: fmt::PostPadding);\n        StorageDead(_99);\n        StorageLive(_107);\n        StorageLive(_108);\n        StorageLive(_109);\n        _109 = &_57;\n        StorageLive(_110);\n        _110 = (_1);\n        _108 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:1364:40: 1364:68} as ops::function::Fn<(&mut fmt::Formatter<'_>,)>>::call(move _109, move _110) -> [return: bb78, unwind unreachable];\n    }\n    bb76: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_99);\n        goto -> bb86;\n    }\n    bb78: {\n        StorageDead(_110);\n        StorageDead(_109);\n        _107 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _108) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_108);\n        _111 = discriminant(_107);\n        switchInt(move _111) -> [0: bb80, 1: bb81, otherwise: bb43];\n    }\n    bb80: {\n        StorageDead(_107);\n        _0 = fmt::PostPadding::write(_106, _1) -> [return: bb83, unwind unreachable];\n    }\n    bb81: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        StorageDead(_107);\n        goto -> bb86;\n    }\n    bb83: {\n        goto -> bb84;\n    }\n    bb84: {\n        StorageDead(_94);\n        StorageDead(_70);\n        goto -> bb85;\n    }\n    bb85: {\n        StorageDead(_64);\n        StorageDead(_57);\n        StorageDead(_28);\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb87;\n    }\n    bb86: {\n        StorageDead(_94);\n        StorageDead(_70);\n        StorageDead(_64);\n        StorageDead(_57);\n        StorageDead(_28);\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb87;\n    }\n    bb87: {\n        return;\n    }\n}\n",
  "doc": " Formats a floating point number in decimal notation.\n\n The number is given as the `integer_part` and a fractional part.\n The value of the fractional part is `fractional_part / divisor`. So\n `integer_part` = 3, `fractional_part` = 12 and `divisor` = 100\n represents the number `3.012`. Trailing zeros are omitted.\n\n `divisor` must not be above 100_000_000. It also should be a power\n of 10, everything else doesn't make sense. `fractional_part` has\n to be less than `10 * divisor`!\n\n A prefix and postfix may be added. The whole thing is padded\n to the formatter's `width`, if specified.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}