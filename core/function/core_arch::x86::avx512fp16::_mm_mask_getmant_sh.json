{
  "name": "core_arch::x86::avx512fp16::_mm_mask_getmant_sh",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::_mm_mask_getmant_round_sh": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Normalize the mantissas of the lower half-precision (16-bit) floating-point element in b, store\n the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set),\n and copy the upper 7 packed elements from a to the upper elements of dst. This intrinsic essentially calculates\n `±(2^k)*|x.significand|`, where k depends on the interval range defined by norm and the sign depends on sign and\n the source sign. Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter\n\n The mantissa is normalized to the interval specified by interv, which can take the following values:\n\n     _MM_MANT_NORM_1_2     // interval [1, 2)\n     _MM_MANT_NORM_p5_2    // interval [0.5, 2)\n     _MM_MANT_NORM_p5_1    // interval [0.5, 1)\n     _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)\n\n The sign is determined by sc which can take the following values:\n\n     _MM_MANT_SIGN_src     // sign = sign(src)\n     _MM_MANT_SIGN_zero    // sign = 0\n     _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1\n\n Exceptions can be suppressed by passing _MM_FROUND_NO_EXC in the sae parameter\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_getmant_round_sh)\n",
      "adt": {
        "core_arch::x86::__m128h": "Constructor"
      }
    }
  },
  "adts": {
    "core_arch::x86::__m128h": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::avx512fp16::_mm_mask_getmant_sh"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:9707:1: 9719:2",
  "src": "pub fn _mm_mask_getmant_sh<\n    const NORM: _MM_MANTISSA_NORM_ENUM,\n    const SIGN: _MM_MANTISSA_SIGN_ENUM,\n>(\n    src: __m128h,\n    k: __mmask8,\n    a: __m128h,\n    b: __m128h,\n) -> __m128h {\n    static_assert_uimm_bits!(NORM, 4);\n    static_assert_uimm_bits!(SIGN, 2);\n    _mm_mask_getmant_round_sh::<NORM, SIGN, _MM_FROUND_CUR_DIRECTION>(src, k, a, b)\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm_mask_getmant_sh(_1: core_arch::x86::__m128h, _2: u8, _3: core_arch::x86::__m128h, _4: core_arch::x86::__m128h) -> core_arch::x86::__m128h {\n    let mut _0: core_arch::x86::__m128h;\n    debug src => _1;\n    debug k => _2;\n    debug a => _3;\n    debug b => _4;\n    bb0: {\n        _0 = core_arch::x86::avx512fp16::_mm_mask_getmant_round_sh::<NORM, SIGN, 4>(_1, _2, _3, _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Normalize the mantissas of the lower half-precision (16-bit) floating-point element in b, store\n the result in the lower element of dst using writemask k (the element is copied from src when mask bit 0 is not set),\n and copy the upper 7 packed elements from a to the upper elements of dst. This intrinsic essentially calculates\n `±(2^k)*|x.significand|`, where k depends on the interval range defined by norm and the sign depends on sign and\n the source sign.\n\n The mantissa is normalized to the interval specified by interv, which can take the following values:\n\n     _MM_MANT_NORM_1_2     // interval [1, 2)\n     _MM_MANT_NORM_p5_2    // interval [0.5, 2)\n     _MM_MANT_NORM_p5_1    // interval [0.5, 1)\n     _MM_MANT_NORM_p75_1p5 // interval [0.75, 1.5)\n\n The sign is determined by sc which can take the following values:\n\n     _MM_MANT_SIGN_src     // sign = sign(src)\n     _MM_MANT_SIGN_zero    // sign = 0\n     _MM_MANT_SIGN_nan     // dst = NaN if sign(src) = 1\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_getmant_sh)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}