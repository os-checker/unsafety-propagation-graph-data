{
  "name": "num::flt2dec::to_shortest_exp_str",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "num::flt2dec::decoder::decode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a sign (true when negative) and `FullDecoded` value\n from given floating point number.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "Constructor"
      }
    },
    "num::flt2dec::determine_sign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the static byte string corresponding to the sign to be formatted.\n It can be either `\"\"`, `\"+\"` or `\"-\"`.\n",
      "adt": {
        "num::flt2dec::decoder::FullDecoded": "MutableAsArgument"
      }
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a shared reference to the contained value.\n\n # Safety\n\n Calling this when the content is not yet fully initialized causes undefined\n behavior: it is up to the caller to guarantee that every `MaybeUninit<T>` in\n the slice really is in an initialized state.\n",
      "adt": {}
    },
    "num::flt2dec::digits_to_dec_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n with at least given number of fractional digits. The result is stored to\n the supplied parts array and a slice of written parts is returned.\n\n `frac_digits` can be less than the number of actual fractional digits in `buf`;\n it will be ignored and full digits will be printed. It is only used to print\n additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n it will only print given digits and nothing else.\n",
      "adt": {}
    },
    "num::flt2dec::digits_to_exp_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Formats the given decimal digits `0.<...buf...> * 10^exp` into the exponential\n form with at least the given number of significant digits. When `upper` is `true`,\n the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n stored to the supplied parts array and a slice of written parts is returned.\n\n `min_digits` can be less than the number of actual significant digits in `buf`;\n it will be ignored and full digits will be printed. It is only used to print\n additional zeroes after rendered digits. Thus, `min_digits == 0` means that\n it will only print the given digits and nothing else.\n",
      "adt": {}
    }
  },
  "adts": {
    "num::flt2dec::decoder::FullDecoded": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3, kind: RigidTy(Bool) })])",
      "Unknown([Field(1, Ty { id: 759, kind: RigidTy(Adt(AdtDef(DefId { id: 24675, name: \"num::flt2dec::decoder::FullDecoded\" }), GenericArgs([]))) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(3, ThreadLocalIndex)), Field(0, Ty { id: 760, kind: RigidTy(Adt(AdtDef(DefId { id: 24674, name: \"num::flt2dec::decoder::Decoded\" }), GenericArgs([]))) })])"
    ],
    "num::flt2dec::Sign": [
      "Plain"
    ],
    "num::flt2dec::decoder::Decoded": [
      "Ref"
    ],
    "num::fmt::Part": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "num::fmt::Formatted": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::flt2dec::to_shortest_exp_str"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/flt2dec/mod.rs:418:1: 468:2",
  "src": "pub fn to_shortest_exp_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    dec_bounds: (i16, i16),\n    upper: bool,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 6);\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n    assert!(dec_bounds.0 <= dec_bounds.1);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n                MaybeUninit::new(Part::Copy(b\"0\"))\n            } else {\n                MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }))\n            };\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let (buf, exp) = format_shortest(decoded, buf);\n            let vis_exp = exp as i32 - 1;\n            let parts = if dec_bounds.0 as i32 <= vis_exp && vis_exp < dec_bounds.1 as i32 {\n                digits_to_dec_str(buf, exp, 0, parts)\n            } else {\n                digits_to_exp_str(buf, exp, 0, upper, parts)\n            };\n            Formatted { sign, parts }\n        }\n    }\n}",
  "mir": "fn num::flt2dec::to_shortest_exp_str(_1: F, _2: T, _3: num::flt2dec::Sign, _4: (i16, i16), _5: bool, _6: &mut [mem::maybe_uninit::MaybeUninit<u8>], _7: &mut [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]) -> num::fmt::Formatted<'_> {\n    let mut _0: num::fmt::Formatted<'_>;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _15: !;\n    let mut _16: bool;\n    let mut _17: i16;\n    let mut _18: i16;\n    let mut _19: !;\n    let  _20: bool;\n    let  _21: num::flt2dec::decoder::FullDecoded;\n    let mut _22: (bool, num::flt2dec::decoder::FullDecoded);\n    let  _23: &str;\n    let  _24: &num::flt2dec::decoder::FullDecoded;\n    let mut _25: isize;\n    let mut _26: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _27: num::fmt::Part<'_>;\n    let mut _28: &[u8];\n    let mut _29: &[u8; 3];\n    let  _30: usize;\n    let mut _31: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _32: usize;\n    let mut _33: bool;\n    let  _34: &[num::fmt::Part<'_>];\n    let  _35: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _36: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _37: ops::range::RangeTo<usize>;\n    let mut _38: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _39: num::fmt::Part<'_>;\n    let mut _40: &[u8];\n    let mut _41: &[u8; 3];\n    let  _42: usize;\n    let mut _43: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _44: usize;\n    let mut _45: bool;\n    let  _46: &[num::fmt::Part<'_>];\n    let  _47: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _48: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _49: ops::range::RangeTo<usize>;\n    let mut _50: mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>;\n    let mut _51: bool;\n    let mut _52: i16;\n    let mut _53: bool;\n    let mut _54: i16;\n    let mut _55: num::fmt::Part<'_>;\n    let mut _56: &[u8];\n    let mut _57: &[u8; 1];\n    let mut _58: num::fmt::Part<'_>;\n    let mut _59: &[u8];\n    let mut _60: &[u8; 3];\n    let mut _61: &[u8; 3];\n    let  _62: usize;\n    let mut _63: *const [mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _64: usize;\n    let mut _65: bool;\n    let  _66: &[num::fmt::Part<'_>];\n    let  _67: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _68: &[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>];\n    let mut _69: ops::range::RangeTo<usize>;\n    let  _70: &num::flt2dec::decoder::Decoded;\n    let  _71: &[u8];\n    let  _72: i16;\n    let mut _73: (&[u8], i16);\n    let mut _74: &mut F;\n    let mut _75: (&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>]);\n    let  _76: i32;\n    let mut _77: i32;\n    let mut _78: (i32, bool);\n    let  _79: &[num::fmt::Part<'_>];\n    let mut _80: bool;\n    let mut _81: i32;\n    let mut _82: i16;\n    let mut _83: bool;\n    let mut _84: i32;\n    let mut _85: i16;\n    let  _86: &[num::fmt::Part<'_>];\n    let mut _87: &[num::fmt::Part<'_>];\n    debug format_shortest => _1;\n    debug v => _2;\n    debug sign => _3;\n    debug dec_bounds => _4;\n    debug upper => _5;\n    debug buf => _6;\n    debug parts => _7;\n    debug negative => _20;\n    debug full_decoded => _21;\n    debug sign => _23;\n    debug decoded => _70;\n    debug buf => _71;\n    debug exp => _72;\n    debug vis_exp => _76;\n    debug parts => _79;\n    bb0: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_7);\n        _9 = PtrMetadata(move _10);\n        StorageDead(_10);\n        _8 = Ge(move _9, 6_usize);\n        switchInt(move _8) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_6);\n        _13 = PtrMetadata(move _14);\n        StorageDead(_14);\n        _12 = Ge(move _13, num::flt2dec::MAX_SIG_DIGITS);\n        switchInt(move _12) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_9);\n        _11 = panicking::panic(\"assertion failed: parts.len() >= 6\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (_4.0: i16);\n        StorageLive(_18);\n        _18 = (_4.1: i16);\n        _16 = Le(move _17, move _18);\n        switchInt(move _16) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_13);\n        _15 = panicking::panic(\"assertion failed: buf.len() >= MAX_SIG_DIGITS\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_22);\n        _22 = num::flt2dec::decoder::decode::<T>(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _19 = panicking::panic(\"assertion failed: dec_bounds.0 <= dec_bounds.1\") -> unwind unreachable;\n    }\n    bb7: {\n        _20 = (_22.0: bool);\n        StorageLive(_21);\n        _21 = (_22.1: num::flt2dec::decoder::FullDecoded);\n        StorageDead(_22);\n        _24 = &_21;\n        _23 = num::flt2dec::determine_sign(_3, _24, _20) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _25 = discriminant(_21);\n        switchInt(move _25) -> [0: bb13, 1: bb12, 2: bb11, 3: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        _70 = &((_21 as variant#3).0: num::flt2dec::decoder::Decoded);\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = &mut _1;\n        StorageLive(_75);\n        _75 = (_70, _6);\n        _73 = <F as ops::function::FnMut<(&num::flt2dec::decoder::Decoded, &mut [mem::maybe_uninit::MaybeUninit<u8>])>>::call_mut(move _74, move _75) -> [return: bb36, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = (_4.0: i16);\n        _51 = Le(move _52, 0_i16);\n        switchInt(move _51) -> [0: bb26, otherwise: bb22];\n    }\n    bb12: {\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = b\"inf\";\n        _40 = move _41 as &[u8];\n        StorageDead(_41);\n        _39 = num::fmt::Part::Copy(move _40);\n        StorageDead(_40);\n        _38 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _39) -> [return: bb18, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = b\"NaN\";\n        _28 = move _29 as &[u8];\n        StorageDead(_29);\n        _27 = num::fmt::Part::Copy(move _28);\n        StorageDead(_28);\n        _26 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _27) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        StorageLive(_30);\n        _30 = 0_usize;\n        _31 = &raw const (fake) (*_7);\n        _32 = PtrMetadata(move _31);\n        _33 = Lt(_30, _32);\n        assert(move _33, \"index out of bounds: the length is {} but the index is {}\", move _32, _30) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        (*_7)[_30] = move _26;\n        StorageDead(_26);\n        StorageDead(_30);\n        StorageLive(_36);\n        _36 = &(*_7);\n        StorageLive(_37);\n        _37 = RangeTo(1_usize);\n        _35 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _36, move _37) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_37);\n        StorageDead(_36);\n        _34 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_35) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _0 = Formatted(_23, _34);\n        goto -> bb46;\n    }\n    bb18: {\n        StorageDead(_39);\n        StorageLive(_42);\n        _42 = 0_usize;\n        _43 = &raw const (fake) (*_7);\n        _44 = PtrMetadata(move _43);\n        _45 = Lt(_42, _44);\n        assert(move _45, \"index out of bounds: the length is {} but the index is {}\", move _44, _42) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        (*_7)[_42] = move _38;\n        StorageDead(_38);\n        StorageDead(_42);\n        StorageLive(_48);\n        _48 = &(*_7);\n        StorageLive(_49);\n        _49 = RangeTo(1_usize);\n        _47 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _48, move _49) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_49);\n        StorageDead(_48);\n        _46 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_47) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _0 = Formatted(_23, _46);\n        goto -> bb46;\n    }\n    bb22: {\n        StorageDead(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = (_4.1: i16);\n        _53 = Lt(0_i16, move _54);\n        switchInt(move _53) -> [0: bb25, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = b\"0\";\n        _56 = move _57 as &[u8];\n        StorageDead(_57);\n        _55 = num::fmt::Part::Copy(move _56);\n        StorageDead(_56);\n        _50 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _55) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_55);\n        goto -> bb32;\n    }\n    bb25: {\n        StorageDead(_54);\n        goto -> bb27;\n    }\n    bb26: {\n        StorageDead(_52);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageLive(_58);\n        StorageLive(_59);\n        switchInt(_5) -> [0: bb29, otherwise: bb28];\n    }\n    bb28: {\n        StorageLive(_60);\n        _60 = b\"0E0\";\n        _59 = move _60 as &[u8];\n        StorageDead(_60);\n        goto -> bb30;\n    }\n    bb29: {\n        StorageLive(_61);\n        _61 = b\"0e0\";\n        _59 = move _61 as &[u8];\n        StorageDead(_61);\n        goto -> bb30;\n    }\n    bb30: {\n        _58 = num::fmt::Part::Copy(move _59);\n        StorageDead(_59);\n        _50 = mem::maybe_uninit::MaybeUninit::<num::fmt::Part<'_>>::new(move _58) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_58);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_53);\n        StorageDead(_51);\n        StorageLive(_62);\n        _62 = 0_usize;\n        _63 = &raw const (fake) (*_7);\n        _64 = PtrMetadata(move _63);\n        _65 = Lt(_62, _64);\n        assert(move _65, \"index out of bounds: the length is {} but the index is {}\", move _64, _62) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        (*_7)[_62] = move _50;\n        StorageDead(_50);\n        StorageDead(_62);\n        StorageLive(_68);\n        _68 = &(*_7);\n        StorageLive(_69);\n        _69 = RangeTo(1_usize);\n        _67 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _68, move _69) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_69);\n        StorageDead(_68);\n        _66 = <[mem::maybe_uninit::MaybeUninit<num::fmt::Part<'_>>]>::assume_init_ref(_67) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _0 = Formatted(_23, _66);\n        goto -> bb46;\n    }\n    bb36: {\n        StorageDead(_75);\n        StorageDead(_74);\n        _71 = (_73.0: &[u8]);\n        _72 = (_73.1: i16);\n        StorageDead(_73);\n        StorageLive(_77);\n        _77 = _72 as i32;\n        _78 = CheckedSub(_77, 1_i32);\n        assert(!move (_78.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _77, 1_i32) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _76 = move (_78.0: i32);\n        StorageDead(_77);\n        StorageLive(_79);\n        StorageLive(_80);\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = (_4.0: i16);\n        _81 = move _82 as i32;\n        StorageDead(_82);\n        _80 = Le(move _81, _76);\n        switchInt(move _80) -> [0: bb42, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_81);\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = (_4.1: i16);\n        _84 = move _85 as i32;\n        StorageDead(_85);\n        _83 = Lt(_76, move _84);\n        switchInt(move _83) -> [0: bb41, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_84);\n        _79 = num::flt2dec::digits_to_dec_str(_71, _72, 0_usize, _7) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        goto -> bb45;\n    }\n    bb41: {\n        StorageDead(_84);\n        goto -> bb43;\n    }\n    bb42: {\n        StorageDead(_81);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageLive(_86);\n        _86 = num::flt2dec::digits_to_exp_str(_71, _72, 0_usize, _5, _7) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _79 = _86;\n        StorageDead(_86);\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_83);\n        StorageDead(_80);\n        StorageLive(_87);\n        _87 = _79;\n        _0 = Formatted(_23, move _87);\n        StorageDead(_87);\n        StorageDead(_79);\n        goto -> bb46;\n    }\n    bb46: {\n        StorageDead(_21);\n        drop(_1) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        return;\n    }\n}\n",
  "doc": " Formats the given floating point number into the decimal form or\n the exponential form, depending on the resulting exponent. The result is\n stored to the supplied parts array while utilizing given byte buffer\n as a scratch. `upper` is used to determine the case of non-finite values\n (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n The first part to be rendered is always a `Part::Sign` (which can be\n an empty string if no sign is rendered).\n\n `format_shortest` should be the underlying digit-generation function.\n It should return the part of the buffer that it initialized.\n You probably would want `strategy::grisu::format_shortest` for this.\n\n The `dec_bounds` is a tuple `(lo, hi)` such that the number is formatted\n as decimal only when `10^lo <= V < 10^hi`. Note that this is the *apparent* `V`\n instead of the actual `v`! Thus any printed exponent in the exponential form\n cannot be in this range, avoiding any confusion.\n\n The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n There should be at least 6 parts available, due to the worst case like\n `[+][1][.][2345][e][-][6]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}