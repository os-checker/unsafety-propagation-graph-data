{
  "name": "cmp::max_by",
  "safe": true,
  "callees": {
    "ops::function::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "cmp::Ordering::is_gt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the ordering is the `Greater` variant.\n\n # Examples\n\n ```\n use std::cmp::Ordering;\n\n assert_eq!(Ordering::Less.is_gt(), false);\n assert_eq!(Ordering::Equal.is_gt(), false);\n assert_eq!(Ordering::Greater.is_gt(), true);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "cmp::Ordering": [
      "Plain"
    ]
  },
  "path": 4996,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1700:1: 1706:2",
  "src": "pub const fn max_by<T: [const] Destruct, F: [const] FnOnce(&T, &T) -> Ordering>(\n    v1: T,\n    v2: T,\n    compare: F,\n) -> T {\n    if compare(&v1, &v2).is_gt() { v1 } else { v2 }\n}",
  "mir": "fn cmp::max_by(_1: T, _2: T, _3: F) -> T {\n    let mut _0: T;\n    let mut _4: bool;\n    let mut _5: cmp::Ordering;\n    let mut _6: (&T, &T);\n    let  _7: &T;\n    let  _8: &T;\n    let mut _9: bool;\n    let mut _10: bool;\n    debug v1 => _1;\n    debug v2 => _2;\n    debug compare => _3;\n    bb0: {\n        _10 = false;\n        _9 = false;\n        _10 = true;\n        _9 = true;\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _7 = &_1;\n        _8 = &_2;\n        _6 = (_7, _8);\n        _5 = <F as ops::function::FnOnce<(&T, &T)>>::call_once(_3, move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _4 = cmp::Ordering::is_gt(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        _10 = false;\n        _0 = move _1;\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_5);\n        _9 = false;\n        _0 = move _2;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_4);\n        switchInt(_9) -> [0: bb6, otherwise: bb8];\n    }\n    bb6: {\n        switchInt(_10) -> [0: bb7, otherwise: bb9];\n    }\n    bb7: {\n        return;\n    }\n    bb8: {\n        drop(_2) -> [return: bb6, unwind unreachable];\n    }\n    bb9: {\n        drop(_1) -> [return: bb7, unwind unreachable];\n    }\n}\n",
  "doc": " Returns the maximum of two values with respect to the specified comparison function.\n\n Returns the second argument if the comparison determines them to be equal.\n\n The parameter order is preserved when calling the `compare` function, i.e. `v1` is\n always passed as the first argument and `v2` as the second.\n\n # Examples\n\n ```\n use std::cmp;\n\n let abs_cmp = |x: &i32, y: &i32| x.abs().cmp(&y.abs());\n\n let result = cmp::max_by(3, -2, abs_cmp) ;\n assert_eq!(result, 3);\n\n let result = cmp::max_by(1, -2, abs_cmp);\n assert_eq!(result, -2);\n\n let result = cmp::max_by(1, -1, abs_cmp);\n assert_eq!(result, -1);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}