{
  "name": "<array::Guard<'_, T> as ops::drop::Drop>::drop",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::get_unchecked_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to an element or subslice, without doing\n bounds checking.\n\n For a safe alternative see [`get_mut`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get_mut(index).unwrap_unchecked()`.  It's\n UB to call `.get_unchecked_mut(len)`, even if you immediately convert\n to a pointer.  And it's UB to call `.get_unchecked_mut(..len + 1)`,\n `.get_unchecked_mut(..=len)`, or similar.\n\n [`get_mut`]: slice::get_mut\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n\n unsafe {\n     let elem = x.get_unchecked_mut(1);\n     *elem = 13;\n }\n assert_eq!(x, &[1, 13, 4]);\n ```\n",
      "adt": {}
    },
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Drops the contained values in place.\n\n # Safety\n\n It is up to the caller to guarantee that every `MaybeUninit<T>` in the slice\n really is in an initialized state. Calling this when the content is not yet\n fully initialized causes undefined behavior.\n\n On top of that, all additional invariants of the type `T` must be\n satisfied, as the `Drop` implementation of `T` (or its members) may\n rely on this. For example, setting a `Vec<T>` to an invalid but\n non-null address makes it initialized (under the current implementation;\n this does not constitute a stable guarantee), because the only\n requirement the compiler knows about it is that the data pointer must be\n non-null. Dropping such a `Vec<T>` however will cause undefined\n behaviour.\n",
      "adt": {}
    }
  },
  "adts": {
    "array::Guard": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<array::Guard<'_, T> as ops::drop::Drop>::drop"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/mod.rs:958:5: 964:6",
  "src": "fn drop(&mut self) {\n        debug_assert!(self.initialized <= self.array_mut.len());\n        // SAFETY: this slice will contain only initialized objects.\n        unsafe {\n            self.array_mut.get_unchecked_mut(..self.initialized).assume_init_drop();\n        }\n    }",
  "mir": "fn <array::Guard<'_, T> as ops::drop::Drop>::drop(_1: &mut array::Guard<'_, T>) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: usize;\n    let mut _5: &[mem::maybe_uninit::MaybeUninit<T>];\n    let mut _6: !;\n    let  _7: ();\n    let mut _8: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _9: ops::range::RangeTo<usize>;\n    let mut _10: usize;\n    let mut _11: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _12: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).1: usize);\n        StorageLive(_4);\n        StorageLive(_5);\n        _11 = ((*_1).0: &mut [mem::maybe_uninit::MaybeUninit<T>]);\n        _5 = &(*_11);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _2 = Le(move _3, move _4);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        _12 = ((*_1).0: &mut [mem::maybe_uninit::MaybeUninit<T>]);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).1: usize);\n        _9 = RangeTo(move _10);\n        StorageDead(_10);\n        _8 = slice::<impl [mem::maybe_uninit::MaybeUninit<T>]>::get_unchecked_mut::<ops::range::RangeTo<usize>>(_12, move _9) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        _6 = panicking::panic(\"assertion failed: self.initialized <= self.array_mut.len()\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_9);\n        _7 = <[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_drop(_8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}