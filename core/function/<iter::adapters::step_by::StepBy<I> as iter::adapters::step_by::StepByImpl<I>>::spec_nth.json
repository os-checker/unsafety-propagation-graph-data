{
  "name": "<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_nth",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::adapters::step_by::StepBy::<I>::original_step": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The `step` that was originally passed to `Iterator::step_by(step)`,\n aka `self.step_minus_one + 1`.\n",
      "adt": {
        "iter::adapters::step_by::StepBy": "ImmutableAsArgument",
        "num::nonzero::NonZero": "Constructor"
      }
    },
    "num::nonzero::NonZero::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained value as a primitive type.\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::nth": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element of the iterator.\n\n Like most indexing operations, the count starts from zero, so `nth(0)`\n returns the first value, `nth(1)` the second, and so on.\n\n Note that all preceding elements, as well as the returned element, will be\n consumed from the iterator. That means that the preceding elements will be\n discarded, and also that calling `nth(0)` multiple times on the same iterator\n will return different elements.\n\n `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(1), Some(2));\n ```\n\n Calling `nth()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.nth(1), Some(2));\n assert_eq!(iter.nth(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(10), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl usize>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {
        "option::Option": "MutableAsArgument"
      }
    },
    "intrinsics::likely": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Hints to the compiler that branch condition is likely to be true.\n Returns the value passed to it.\n\n Any use other than with `if` statements will probably not have an effect.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n This intrinsic does not have a stable counterpart.\n",
      "adt": {}
    },
    "option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::step_by::StepBy": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref",
      "Deref",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Ref"
    ],
    "num::nonzero::NonZero": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_nth"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/step_by.rs:253:5: 294:6",
  "src": "default fn spec_nth(&mut self, mut n: usize) -> Option<I::Item> {\n        if self.first_take {\n            self.first_take = false;\n            let first = self.iter.next();\n            if n == 0 {\n                return first;\n            }\n            n -= 1;\n        }\n        // n and self.step_minus_one are indices, we need to add 1 to get the amount of elements\n        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n        let mut step = self.original_step().get();\n        // n + 1 could overflow\n        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n        if n == usize::MAX {\n            self.iter.nth(step - 1);\n        } else {\n            n += 1;\n        }\n\n        // overflow handling\n        loop {\n            let mul = n.checked_mul(step);\n            {\n                if intrinsics::likely(mul.is_some()) {\n                    return self.iter.nth(mul.unwrap() - 1);\n                }\n            }\n            let div_n = usize::MAX / n;\n            let div_step = usize::MAX / step;\n            let nth_n = div_n * n;\n            let nth_step = div_step * step;\n            let nth = if nth_n > nth_step {\n                step -= div_n;\n                nth_n\n            } else {\n                n -= div_step;\n                nth_step\n            };\n            self.iter.nth(nth - 1);\n        }\n    }",
  "mir": "fn <iter::adapters::step_by::StepBy<I> as iter::adapters::step_by::StepByImpl<I>>::spec_nth(_1: &mut iter::adapters::step_by::StepBy<I>, _2: usize) -> option::Option<<I as iter::traits::iterator::Iterator>::Item> {\n    let mut _0: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _3: bool;\n    let  _4: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _5: &mut I;\n    let mut _6: usize;\n    let mut _7: (usize, bool);\n    let mut _8: usize;\n    let mut _9: num::nonzero::NonZero<usize>;\n    let mut _10: &iter::adapters::step_by::StepBy<I>;\n    let mut _11: bool;\n    let mut _12: usize;\n    let  _13: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _14: &mut I;\n    let mut _15: usize;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: (usize, bool);\n    let  _19: option::Option<usize>;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: bool;\n    let mut _23: bool;\n    let mut _24: &option::Option<usize>;\n    let mut _25: &mut I;\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let  _29: usize;\n    let mut _30: usize;\n    let mut _31: bool;\n    let  _32: usize;\n    let mut _33: usize;\n    let mut _34: bool;\n    let  _35: usize;\n    let mut _36: usize;\n    let mut _37: (usize, bool);\n    let  _38: usize;\n    let mut _39: usize;\n    let mut _40: (usize, bool);\n    let  _41: usize;\n    let mut _42: bool;\n    let mut _43: (usize, bool);\n    let mut _44: (usize, bool);\n    let  _45: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _46: &mut I;\n    let mut _47: usize;\n    let mut _48: usize;\n    let mut _49: (usize, bool);\n    debug self => _1;\n    debug n => _2;\n    debug first => _4;\n    debug step => _8;\n    debug mul => _19;\n    debug div_n => _29;\n    debug div_step => _32;\n    debug nth_n => _35;\n    debug nth_step => _38;\n    debug nth => _41;\n    bb0: {\n        StorageLive(_3);\n        _3 = ((*_1).2: bool);\n        switchInt(move _3) -> [0: bb7, otherwise: bb1];\n    }\n    bb1: {\n        ((*_1).2: bool) = false;\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: I);\n        _4 = <I as iter::traits::iterator::Iterator>::next(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = _2;\n        switchInt(move _6) -> [0: bb3, otherwise: bb4];\n    }\n    bb3: {\n        StorageDead(_6);\n        _0 = move _4;\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb38;\n    }\n    bb4: {\n        StorageDead(_6);\n        _7 = CheckedSub(_2, 1_usize);\n        assert(!move (_7.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _2 = move (_7.0: usize);\n        drop(_4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &(*_1);\n        _9 = iter::adapters::step_by::StepBy::<I>::original_step(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        _8 = num::nonzero::NonZero::<usize>::get(move _9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _2;\n        _11 = Eq(move _12, num::<impl usize>::MAX);\n        switchInt(move _11) -> [0: bb14, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &mut ((*_1).0: I);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _8;\n        _17 = CheckedSub(_16, 1_usize);\n        assert(!move (_17.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _16, 1_usize) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _15 = move (_17.0: usize);\n        StorageDead(_16);\n        _13 = <I as iter::traits::iterator::Iterator>::nth(move _14, move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageDead(_14);\n        drop(_13) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_13);\n        goto -> bb16;\n    }\n    bb14: {\n        StorageDead(_12);\n        _18 = CheckedAdd(_2, 1_usize);\n        assert(!move (_18.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _2 = move (_18.0: usize);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_11);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_20);\n        _20 = _2;\n        StorageLive(_21);\n        _21 = _8;\n        _19 = num::<impl usize>::checked_mul(move _20, move _21) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_19;\n        _23 = option::Option::<usize>::is_some(move _24) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_24);\n        _22 = intrinsics::likely(move _23) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        switchInt(move _22) -> [0: bb25, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_23);\n        StorageLive(_25);\n        _25 = &mut ((*_1).0: I);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = option::Option::<usize>::unwrap(_19) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _28 = CheckedSub(_27, 1_usize);\n        assert(!move (_28.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _27, 1_usize) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _26 = move (_28.0: usize);\n        StorageDead(_27);\n        _0 = <I as iter::traits::iterator::Iterator>::nth(move _25, move _26) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_22);\n        StorageDead(_8);\n        goto -> bb38;\n    }\n    bb25: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_30);\n        _30 = _2;\n        _31 = Eq(_30, 0_usize);\n        assert(!move _31, \"attempt to divide `{}` by zero\", num::<impl usize>::MAX) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _29 = Div(num::<impl usize>::MAX, move _30);\n        StorageDead(_30);\n        StorageLive(_33);\n        _33 = _8;\n        _34 = Eq(_33, 0_usize);\n        assert(!move _34, \"attempt to divide `{}` by zero\", num::<impl usize>::MAX) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _32 = Div(num::<impl usize>::MAX, move _33);\n        StorageDead(_33);\n        StorageLive(_36);\n        _36 = _2;\n        _37 = CheckedMul(_29, _36);\n        assert(!move (_37.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _29, move _36) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _35 = move (_37.0: usize);\n        StorageDead(_36);\n        StorageLive(_39);\n        _39 = _8;\n        _40 = CheckedMul(_32, _39);\n        assert(!move (_40.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _32, move _39) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _38 = move (_40.0: usize);\n        StorageDead(_39);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = Gt(_35, _38);\n        switchInt(move _42) -> [0: bb32, otherwise: bb30];\n    }\n    bb30: {\n        _43 = CheckedSub(_8, _29);\n        assert(!move (_43.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _8, _29) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _8 = move (_43.0: usize);\n        _41 = _35;\n        goto -> bb34;\n    }\n    bb32: {\n        _44 = CheckedSub(_2, _32);\n        assert(!move (_44.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, _32) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _2 = move (_44.0: usize);\n        _41 = _38;\n        goto -> bb34;\n    }\n    bb34: {\n        StorageDead(_42);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &mut ((*_1).0: I);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _41;\n        _49 = CheckedSub(_48, 1_usize);\n        assert(!move (_49.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _48, 1_usize) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _47 = move (_49.0: usize);\n        StorageDead(_48);\n        _45 = <I as iter::traits::iterator::Iterator>::nth(move _46, move _47) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_47);\n        StorageDead(_46);\n        drop(_45) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_45);\n        StorageDead(_41);\n        goto -> bb17;\n    }\n    bb38: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}