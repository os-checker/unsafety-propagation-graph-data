{
  "name": "<[A] as slice::cmp::SlicePartialEq<B>>::equal",
  "safe": true,
  "callees": {
    "mem::size_of_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the pointed-to value in bytes.\n\n This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\n statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n then `size_of_val` can be used to get the dynamically-known size.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n\n # Examples\n\n ```\n assert_eq!(4, size_of_val(&5i32));\n\n let x: [u8; 13] = [0; 13];\n let y: &[u8] = &x;\n assert_eq!(13, size_of_val(y));\n ```\n\n [`size_of::<T>()`]: size_of\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "intrinsics::compare_bytes": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Lexicographically compare `[left, left + bytes)` and `[right, right + bytes)`\n as unsigned bytes, returning negative if `left` is less, zero if all the\n bytes match, or positive if `left` is greater.\n\n This underlies things like `<[u8]>::cmp`, and will usually lower to `memcmp`.\n\n # Safety\n\n `left` and `right` must each be [valid] for reads of `bytes` bytes.\n\n Note that this applies to the whole range, not just until the first byte\n that differs.  That allows optimizations that can read in large chunks.\n\n [valid]: crate::ptr#safety\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1154,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:143:5: 154:6",
  "src": "fn equal(&self, other: &[B]) -> bool {\n        if self.len() != other.len() {\n            return false;\n        }\n\n        // SAFETY: `self` and `other` are references and are thus guaranteed to be valid.\n        // The two slices have been checked to have the same size above.\n        unsafe {\n            let size = size_of_val(self);\n            compare_bytes(self.as_ptr() as *const u8, other.as_ptr() as *const u8, size) == 0\n        }\n    }",
  "mir": "fn <[A] as slice::cmp::SlicePartialEq<B>>::equal(_1: &[A], _2: &[B]) -> bool {\n    let mut _0: bool;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let  _6: usize;\n    let mut _7: i32;\n    let mut _8: *const u8;\n    let mut _9: *const A;\n    let mut _10: *const u8;\n    let mut _11: *const B;\n    debug self => _1;\n    debug other => _2;\n    debug size => _6;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = PtrMetadata(_1);\n        StorageLive(_5);\n        _5 = PtrMetadata(_2);\n        _3 = Ne(move _4, move _5);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = false;\n        StorageDead(_3);\n        goto -> bb7;\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        _6 = mem::size_of_val::<[A]>(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = slice::<impl [A]>::as_ptr(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = move _9 as *const u8;\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = slice::<impl [B]>::as_ptr(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = move _11 as *const u8;\n        StorageDead(_11);\n        _7 = intrinsics::compare_bytes(move _8, move _10, _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_8);\n        _0 = Eq(move _7, 0_i32);\n        StorageDead(_7);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}