{
  "name": "ptr::swap_nonoverlapping::runtime",
  "safe": true,
  "callees": {
    "ptr::slice_from_raw_parts_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a raw mutable slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n Performs the same functionality as [`slice_from_raw_parts`], except that a\n raw mutable slice is returned, as opposed to a raw immutable slice.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.\n\n [`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut\n\n # Examples\n\n ```rust\n use std::ptr;\n\n let x = &mut [5, 6, 7];\n let raw_pointer = x.as_mut_ptr();\n let slice = ptr::slice_from_raw_parts_mut(raw_pointer, 3);\n\n unsafe {\n     (*slice)[2] = 99; // assign a value at an index in the slice\n };\n\n assert_eq!(unsafe { &*slice }[2], 99);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *mut [u8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 0);\n unsafe {\n     danger.as_mut().expect(\"references must not be null\");\n }\n ```\n",
      "adt": {}
    },
    "mem::size_of_val_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the pointed-to value in bytes.\n\n This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\n statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n then `size_of_val_raw` can be used to get the dynamically-known size.\n\n # Safety\n\n This function is only safe to call if the following conditions hold:\n\n - If `T` is `Sized`, this function is always safe to call.\n - If the unsized tail of `T` is:\n     - a [slice], then the length of the slice tail must be an initialized\n       integer, and the size of the *entire value*\n       (dynamic tail length + statically sized prefix) must fit in `isize`.\n       For the special case where the dynamic tail length is 0, this function\n       is safe to call.\n     - a [trait object], then the vtable part of the pointer must point\n       to a valid vtable acquired by an unsizing coercion, and the size\n       of the *entire value* (dynamic tail length + statically sized prefix)\n       must fit in `isize`.\n     - an (unstable) [extern type], then this function is always safe to\n       call, but may panic or otherwise return the wrong value, as the\n       extern type's layout is not known. This is the same behavior as\n       [`size_of_val`] on a reference to a type with an extern type tail.\n     - otherwise, it is conservatively not allowed to call this function.\n\n [`size_of::<T>()`]: size_of\n [trait object]: ../../book/ch17-02-trait-objects.html\n [extern type]: ../../unstable-book/language-features/extern-types.html\n\n # Examples\n\n ```\n #![feature(layout_for_ptr)]\n use std::mem;\n\n assert_eq!(4, size_of_val(&5i32));\n\n let x: [u8; 13] = [0; 13];\n let y: &[u8] = &x;\n assert_eq!(13, unsafe { mem::size_of_val_raw(y) });\n ```\n",
      "adt": {}
    },
    "num::nonzero::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {
        "option::Option": "Constructor",
        "num::nonzero::NonZero": "Constructor"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::swap_nonoverlapping_bytes": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1742, kind: RigidTy(Adt(AdtDef(DefId { id: 24832, name: \"num::nonzero::NonZero\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "num::nonzero::NonZero": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::ptr::swap_nonoverlapping::runtime"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2437:9: 2439:10",
  "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
  "mir": "fn ptr::swap_nonoverlapping::runtime(_1: *mut T, _2: *mut T, _3: usize) -> () {\n    let mut _0: ();\n    let  _4: *mut [T];\n    let  _5: usize;\n    let mut _6: *const [T];\n    let mut _7: option::Option<num::nonzero::NonZero<usize>>;\n    let mut _8: isize;\n    let  _9: num::nonzero::NonZero<usize>;\n    let  _10: ();\n    let mut _11: *mut u8;\n    let mut _12: *mut u8;\n    debug x => _1;\n    debug y => _2;\n    debug count => _3;\n    debug slice => _4;\n    debug bytes => _5;\n    debug bytes => _9;\n    bb0: {\n        _4 = ptr::slice_from_raw_parts_mut::<T>(_1, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = _4 as *const [T];\n        _5 = mem::size_of_val_raw::<[T]>(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = num::nonzero::NonZero::<usize>::new(_5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = discriminant(_7);\n        switchInt(move _8) -> [1: bb4, 0: bb8, otherwise: bb10];\n    }\n    bb4: {\n        _9 = ((_7 as variant#1).0: num::nonzero::NonZero<usize>);\n        StorageLive(_11);\n        _11 = ptr::mut_ptr::<impl *mut T>::cast::<u8>(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_12);\n        _12 = ptr::mut_ptr::<impl *mut T>::cast::<u8>(_2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _10 = ptr::swap_nonoverlapping_bytes(move _11, move _12, _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_7);\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_7);\n        goto -> bb9;\n    }\n    bb9: {\n        return;\n    }\n    bb10: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}