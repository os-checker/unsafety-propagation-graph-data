{
  "name": "ptr::const_ptr::<impl *const T>::guaranteed_eq",
  "safe": true,
  "callees": {
    "intrinsics::ptr_guaranteed_cmp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " See documentation of `<*const T>::guaranteed_eq` for details.\n Returns `2` if the result is unknown.\n Returns `1` if the pointers are guaranteed equal.\n Returns `0` if the pointers are guaranteed inequal.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::ptr::const_ptr::<impl *const T>::guaranteed_eq"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:771:5: 779:6",
  "src": "pub const fn guaranteed_eq(self, other: *const T) -> Option<bool>\n    where\n        T: Sized,\n    {\n        match intrinsics::ptr_guaranteed_cmp(self, other) {\n            2 => None,\n            other => Some(other == 1),\n        }\n    }",
  "mir": "fn ptr::const_ptr::<impl *const T>::guaranteed_eq(_1: *const T, _2: *const T) -> option::Option<bool> {\n    let mut _0: option::Option<bool>;\n    let mut _3: u8;\n    let mut _4: bool;\n    debug self => _1;\n    debug other => _2;\n    debug other => _3;\n    bb0: {\n        _3 = intrinsics::ptr_guaranteed_cmp::<T>(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(_3) -> [2: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = Eq(_3, 1_u8);\n        _0 = option::Option::Some(move _4);\n        StorageDead(_4);\n        goto -> bb4;\n    }\n    bb3: {\n        _0 = option::Option::None;\n        goto -> bb4;\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": " Returns whether two pointers are guaranteed to be equal.\n\n At runtime this function behaves like `Some(self == other)`.\n However, in some contexts (e.g., compile-time evaluation),\n it is not always possible to determine equality of two pointers, so this function may\n spuriously return `None` for pointers that later actually turn out to have its equality known.\n But when it returns `Some`, the pointers' equality is guaranteed to be known.\n\n The return value may change from `Some` to `None` and vice versa depending on the compiler\n version and unsafe code must not\n rely on the result of this function for soundness. It is suggested to only use this function\n for performance optimizations where spurious `None` return values by this function do not\n affect the outcome, but just the performance.\n The consequences of using this method to make runtime and compile-time code behave\n differently have not been explored. This method should not be used to introduce such\n differences, and it should also not be stabilized before we have a better understanding\n of this issue.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}