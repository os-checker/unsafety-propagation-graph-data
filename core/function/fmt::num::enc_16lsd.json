{
  "name": "fmt::num::enc_16lsd",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::rev::Rev": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "ops::range::Range": [
      "Plain"
    ],
    "iter::adapters::rev::Rev": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef"
    ]
  },
  "path": 12952,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:821:1: 837:2",
  "src": "fn enc_16lsd<const OFFSET: usize>(buf: &mut [MaybeUninit<u8>], n: u64) {\n    // Consume the least-significant decimals from a working copy.\n    let mut remain = n;\n\n    // Format per four digits from the lookup table.\n    for quad_index in (0..4).rev() {\n        // pull two pairs\n        let quad = remain % 1_00_00;\n        remain /= 1_00_00;\n        let pair1 = (quad / 100) as usize;\n        let pair2 = (quad % 100) as usize;\n        buf[quad_index * 4 + OFFSET + 0].write(DECIMAL_PAIRS[pair1 * 2 + 0]);\n        buf[quad_index * 4 + OFFSET + 1].write(DECIMAL_PAIRS[pair1 * 2 + 1]);\n        buf[quad_index * 4 + OFFSET + 2].write(DECIMAL_PAIRS[pair2 * 2 + 0]);\n        buf[quad_index * 4 + OFFSET + 3].write(DECIMAL_PAIRS[pair2 * 2 + 1]);\n    }\n}",
  "mir": "fn fmt::num::enc_16lsd(_1: &mut [mem::maybe_uninit::MaybeUninit<u8>], _2: u64) -> () {\n    let mut _0: ();\n    let mut _3: u64;\n    let mut _4: iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _5: iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _6: ops::range::Range<usize>;\n    let mut _7: iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _8: option::Option<usize>;\n    let mut _9: &mut iter::adapters::rev::Rev<ops::range::Range<usize>>;\n    let mut _10: isize;\n    let  _11: usize;\n    let  _12: u64;\n    let mut _13: u64;\n    let mut _14: bool;\n    let mut _15: bool;\n    let  _16: usize;\n    let mut _17: u64;\n    let mut _18: bool;\n    let  _19: usize;\n    let mut _20: u64;\n    let mut _21: bool;\n    let  _22: &mut u8;\n    let mut _23: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _24: usize;\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let mut _28: (usize, bool);\n    let mut _29: (usize, bool);\n    let mut _30: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: u8;\n    let mut _34: &&[u8; 200];\n    let  _35: usize;\n    let mut _36: usize;\n    let mut _37: (usize, bool);\n    let mut _38: (usize, bool);\n    let mut _39: bool;\n    let  _40: &mut u8;\n    let mut _41: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _42: usize;\n    let mut _43: usize;\n    let mut _44: usize;\n    let mut _45: (usize, bool);\n    let mut _46: (usize, bool);\n    let mut _47: (usize, bool);\n    let mut _48: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _49: usize;\n    let mut _50: bool;\n    let mut _51: u8;\n    let mut _52: &&[u8; 200];\n    let  _53: usize;\n    let mut _54: usize;\n    let mut _55: (usize, bool);\n    let mut _56: (usize, bool);\n    let mut _57: bool;\n    let  _58: &mut u8;\n    let mut _59: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _60: usize;\n    let mut _61: usize;\n    let mut _62: usize;\n    let mut _63: (usize, bool);\n    let mut _64: (usize, bool);\n    let mut _65: (usize, bool);\n    let mut _66: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _67: usize;\n    let mut _68: bool;\n    let mut _69: u8;\n    let mut _70: &&[u8; 200];\n    let  _71: usize;\n    let mut _72: usize;\n    let mut _73: (usize, bool);\n    let mut _74: (usize, bool);\n    let mut _75: bool;\n    let  _76: &mut u8;\n    let mut _77: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _78: usize;\n    let mut _79: usize;\n    let mut _80: usize;\n    let mut _81: (usize, bool);\n    let mut _82: (usize, bool);\n    let mut _83: (usize, bool);\n    let mut _84: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _85: usize;\n    let mut _86: bool;\n    let mut _87: u8;\n    let mut _88: &&[u8; 200];\n    let  _89: usize;\n    let mut _90: usize;\n    let mut _91: (usize, bool);\n    let mut _92: (usize, bool);\n    let mut _93: bool;\n    let mut _94: &[u8; 200];\n    let mut _95: &[u8; 200];\n    let mut _96: &[u8; 200];\n    let mut _97: &[u8; 200];\n    debug buf => _1;\n    debug n => _2;\n    debug remain => _3;\n    debug iter => _7;\n    debug quad_index => _11;\n    debug quad => _12;\n    debug pair1 => _16;\n    debug pair2 => _19;\n    bb0: {\n        StorageLive(_3);\n        _3 = _2;\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = Range(0_usize, 4_usize);\n        _5 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::rev(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _4 = <iter::adapters::rev::Rev<ops::range::Range<usize>> as iter::traits::collect::IntoIterator>::into_iter(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_7);\n        _7 = move _4;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_8);\n        _9 = &mut _7;\n        _8 = <iter::adapters::rev::Rev<ops::range::Range<usize>> as iter::traits::iterator::Iterator>::next(_9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = discriminant(_8);\n        switchInt(move _10) -> [0: bb7, 1: bb6, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _11 = ((_8 as variant#1).0: usize);\n        StorageLive(_13);\n        _13 = _3;\n        _14 = Eq(10000_u64, 0_u64);\n        assert(!move _14, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _13) -> [success: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n    bb8: {\n        _12 = Rem(move _13, 10000_u64);\n        StorageDead(_13);\n        _15 = Eq(10000_u64, 0_u64);\n        assert(!move _15, \"attempt to divide `{}` by zero\", _3) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _3 = Div(_3, 10000_u64);\n        StorageLive(_17);\n        _18 = Eq(100_u64, 0_u64);\n        assert(!move _18, \"attempt to divide `{}` by zero\", _12) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _17 = Div(_12, 100_u64);\n        _16 = move _17 as usize;\n        StorageDead(_17);\n        StorageLive(_20);\n        _21 = Eq(100_u64, 0_u64);\n        assert(!move _21, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _12) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _20 = Rem(_12, 100_u64);\n        _19 = move _20 as usize;\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _27 = CheckedMul(_11, 4_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _11, 4_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _26 = move (_27.0: usize);\n        _28 = CheckedAdd(_26, OFFSET);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _26, OFFSET) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _25 = move (_28.0: usize);\n        StorageDead(_26);\n        _29 = CheckedAdd(_25, 0_usize);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _25, 0_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _24 = move (_29.0: usize);\n        StorageDead(_25);\n        _30 = &raw const (fake) (*_1);\n        _31 = PtrMetadata(move _30);\n        _32 = Lt(_24, _31);\n        assert(move _32, \"index out of bounds: the length is {} but the index is {}\", move _31, _24) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _23 = &mut (*_1)[_24];\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = {alloc1915: &&[u8; 200]};\n        StorageLive(_35);\n        StorageLive(_36);\n        _37 = CheckedMul(_16, 2_usize);\n        assert(!move (_37.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _16, 2_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _36 = move (_37.0: usize);\n        _38 = CheckedAdd(_36, 0_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _36, 0_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _35 = move (_38.0: usize);\n        StorageDead(_36);\n        _39 = Lt(_35, 200_usize);\n        assert(move _39, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _35) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _94 = (*_34);\n        _33 = (*_94)[_35];\n        _22 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _23, move _33) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_33);\n        StorageDead(_23);\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_24);\n        StorageDead(_22);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _45 = CheckedMul(_11, 4_usize);\n        assert(!move (_45.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _11, 4_usize) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _44 = move (_45.0: usize);\n        _46 = CheckedAdd(_44, OFFSET);\n        assert(!move (_46.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _44, OFFSET) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _43 = move (_46.0: usize);\n        StorageDead(_44);\n        _47 = CheckedAdd(_43, 1_usize);\n        assert(!move (_47.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _43, 1_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _42 = move (_47.0: usize);\n        StorageDead(_43);\n        _48 = &raw const (fake) (*_1);\n        _49 = PtrMetadata(move _48);\n        _50 = Lt(_42, _49);\n        assert(move _50, \"index out of bounds: the length is {} but the index is {}\", move _49, _42) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _41 = &mut (*_1)[_42];\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = {alloc1915: &&[u8; 200]};\n        StorageLive(_53);\n        StorageLive(_54);\n        _55 = CheckedMul(_16, 2_usize);\n        assert(!move (_55.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _16, 2_usize) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _54 = move (_55.0: usize);\n        _56 = CheckedAdd(_54, 1_usize);\n        assert(!move (_56.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _54, 1_usize) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _53 = move (_56.0: usize);\n        StorageDead(_54);\n        _57 = Lt(_53, 200_usize);\n        assert(move _57, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _53) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _95 = (*_52);\n        _51 = (*_95)[_53];\n        _40 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _41, move _51) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_51);\n        StorageDead(_41);\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageDead(_42);\n        StorageDead(_40);\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        _63 = CheckedMul(_11, 4_usize);\n        assert(!move (_63.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _11, 4_usize) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _62 = move (_63.0: usize);\n        _64 = CheckedAdd(_62, OFFSET);\n        assert(!move (_64.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _62, OFFSET) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _61 = move (_64.0: usize);\n        StorageDead(_62);\n        _65 = CheckedAdd(_61, 2_usize);\n        assert(!move (_65.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _61, 2_usize) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _60 = move (_65.0: usize);\n        StorageDead(_61);\n        _66 = &raw const (fake) (*_1);\n        _67 = PtrMetadata(move _66);\n        _68 = Lt(_60, _67);\n        assert(move _68, \"index out of bounds: the length is {} but the index is {}\", move _67, _60) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _59 = &mut (*_1)[_60];\n        StorageLive(_69);\n        StorageLive(_70);\n        _70 = {alloc1915: &&[u8; 200]};\n        StorageLive(_71);\n        StorageLive(_72);\n        _73 = CheckedMul(_19, 2_usize);\n        assert(!move (_73.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _19, 2_usize) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _72 = move (_73.0: usize);\n        _74 = CheckedAdd(_72, 0_usize);\n        assert(!move (_74.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _72, 0_usize) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _71 = move (_74.0: usize);\n        StorageDead(_72);\n        _75 = Lt(_71, 200_usize);\n        assert(move _75, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _71) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _96 = (*_70);\n        _69 = (*_96)[_71];\n        _58 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _59, move _69) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_69);\n        StorageDead(_59);\n        StorageDead(_71);\n        StorageDead(_70);\n        StorageDead(_60);\n        StorageDead(_58);\n        StorageLive(_76);\n        StorageLive(_77);\n        StorageLive(_78);\n        StorageLive(_79);\n        StorageLive(_80);\n        _81 = CheckedMul(_11, 4_usize);\n        assert(!move (_81.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _11, 4_usize) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _80 = move (_81.0: usize);\n        _82 = CheckedAdd(_80, OFFSET);\n        assert(!move (_82.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _80, OFFSET) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _79 = move (_82.0: usize);\n        StorageDead(_80);\n        _83 = CheckedAdd(_79, 3_usize);\n        assert(!move (_83.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _79, 3_usize) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        _78 = move (_83.0: usize);\n        StorageDead(_79);\n        _84 = &raw const (fake) (*_1);\n        _85 = PtrMetadata(move _84);\n        _86 = Lt(_78, _85);\n        assert(move _86, \"index out of bounds: the length is {} but the index is {}\", move _85, _78) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _77 = &mut (*_1)[_78];\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = {alloc1915: &&[u8; 200]};\n        StorageLive(_89);\n        StorageLive(_90);\n        _91 = CheckedMul(_19, 2_usize);\n        assert(!move (_91.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _19, 2_usize) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _90 = move (_91.0: usize);\n        _92 = CheckedAdd(_90, 1_usize);\n        assert(!move (_92.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _90, 1_usize) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _89 = move (_92.0: usize);\n        StorageDead(_90);\n        _93 = Lt(_89, 200_usize);\n        assert(move _93, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _89) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _97 = (*_88);\n        _87 = (*_97)[_89];\n        _76 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _77, move _87) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_87);\n        StorageDead(_77);\n        StorageDead(_89);\n        StorageDead(_88);\n        StorageDead(_78);\n        StorageDead(_76);\n        StorageDead(_8);\n        goto -> bb3;\n    }\n}\n",
  "doc": " Encodes the 16 least-significant decimals of n into `buf[OFFSET .. OFFSET +\n 16 ]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}