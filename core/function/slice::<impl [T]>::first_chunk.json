{
  "name": "slice::<impl [T]>::first_chunk",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::cast_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a pointer-to-`T` to a pointer-to-`[T; N]`.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": 1260,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:326:5: 334:6",
  "src": "pub const fn first_chunk<const N: usize>(&self) -> Option<&[T; N]> {\n        if self.len() < N {\n            None\n        } else {\n            // SAFETY: We explicitly check for the correct number of elements,\n            //   and do not let the reference outlive the slice.\n            Some(unsafe { &*(self.as_ptr().cast_array()) })\n        }\n    }",
  "mir": "fn slice::<impl [T]>::first_chunk(_1: &[T]) -> option::Option<&[T; N]> {\n    let mut _0: option::Option<&[T; N]>;\n    let mut _2: bool;\n    let mut _3: usize;\n    let  _4: &[T; N];\n    let  _5: *const [T; N];\n    let mut _6: *const T;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        _2 = Lt(move _3, N);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = option::Option::None;\n        goto -> bb5;\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = slice::<impl [T]>::as_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = ptr::const_ptr::<impl *const T>::cast_array::<N>(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        _4 = &(*_5);\n        StorageDead(_5);\n        _0 = option::Option::Some(_4);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns an array reference to the first `N` items in the slice.\n\n If the slice is not at least `N` in length, this will return `None`.\n\n # Examples\n\n ```\n let u = [10, 40, 30];\n assert_eq!(Some(&[10, 40]), u.first_chunk::<2>());\n\n let v: &[i32] = &[10];\n assert_eq!(None, v.first_chunk::<2>());\n\n let w: &[i32] = &[];\n assert_eq!(Some(&[]), w.first_chunk::<0>());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}