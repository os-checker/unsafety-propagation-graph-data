{
  "name": "num::dec2flt::decimal::Decimal::try_fast_path",
  "safe": true,
  "callees": {
    "num::dec2flt::fpu::fpu_precision::set_precision": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "num::dec2flt::decimal::Decimal::can_use_fast_path": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Detect if the float can be accurately reconstructed from native floats.\n",
      "adt": {
        "num::dec2flt::decimal::Decimal": "ImmutableAsArgument"
      }
    },
    "num::dec2flt::float::RawFloat::from_u64": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts integer into float through an as cast.\n This is only called in the fast-path algorithm, and therefore\n will not lose precision, since the value will always have\n only if the value is <= Self::MAX_MANTISSA_FAST_PATH.\n",
      "adt": {}
    },
    "num::dec2flt::float::RawFloat::pow10_fast_path": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a small power-of-ten for fast-path multiplication.\n",
      "adt": {}
    },
    "ops::arith::Div::div": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `/` operation.\n\n # Example\n\n ```\n assert_eq!(12 / 2, 6);\n ```\n",
      "adt": {}
    },
    "ops::arith::Mul::mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `*` operation.\n\n # Example\n\n ```\n assert_eq!(12 * 2, 24);\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "ops::arith::Neg::neg": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the unary `-` operation.\n\n # Example\n\n ```\n let x: i32 = 12;\n assert_eq!(-x, -12);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "num::dec2flt::decimal::Decimal": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "option::Option": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 325, kind: RigidTy(Uint(U64)) })])"
    ]
  },
  "path": 14762,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/decimal.rs:54:5: 86:6",
  "src": "pub fn try_fast_path<F: RawFloat>(&self) -> Option<F> {\n        // Here we need to work around <https://github.com/rust-lang/rust/issues/114479>.\n        // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n        // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n        // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n        // The `set_precision` function takes care of setting the precision on architectures which\n        // require setting it by changing the global state (like the control word of the x87 FPU).\n        let _cw = set_precision::<F>();\n\n        if !self.can_use_fast_path::<F>() {\n            return None;\n        }\n\n        let value = if self.exponent <= F::MAX_EXPONENT_FAST_PATH {\n            // normal fast path\n            let value = F::from_u64(self.mantissa);\n            if self.exponent < 0 {\n                value / F::pow10_fast_path((-self.exponent) as _)\n            } else {\n                value * F::pow10_fast_path(self.exponent as _)\n            }\n        } else {\n            // disguised fast path\n            let shift = self.exponent - F::MAX_EXPONENT_FAST_PATH;\n            let mantissa = self.mantissa.checked_mul(INT_POW10[shift as usize])?;\n            if mantissa > F::MAX_MANTISSA_FAST_PATH {\n                return None;\n            }\n            F::from_u64(mantissa) * F::pow10_fast_path(F::MAX_EXPONENT_FAST_PATH as _)\n        };\n\n        if self.negative { Some(-value) } else { Some(value) }\n    }",
  "mir": "fn num::dec2flt::decimal::Decimal::try_fast_path(_1: &num::dec2flt::decimal::Decimal) -> option::Option<F> {\n    let mut _0: option::Option<F>;\n    let  _2: ();\n    let mut _3: bool;\n    let  _4: F;\n    let mut _5: bool;\n    let mut _6: i64;\n    let  _7: F;\n    let mut _8: u64;\n    let mut _9: bool;\n    let mut _10: i64;\n    let mut _11: F;\n    let mut _12: usize;\n    let mut _13: i64;\n    let mut _14: i64;\n    let mut _15: bool;\n    let mut _16: F;\n    let mut _17: usize;\n    let mut _18: i64;\n    let  _19: i64;\n    let mut _20: i64;\n    let mut _21: (i64, bool);\n    let mut _22: ops::control_flow::ControlFlow<option::Option<convert::Infallible>, u64>;\n    let mut _23: option::Option<u64>;\n    let mut _24: u64;\n    let mut _25: u64;\n    let mut _26: [u64; 16];\n    let  _27: usize;\n    let mut _28: bool;\n    let mut _29: isize;\n    let  _30: u64;\n    let mut _31: bool;\n    let mut _32: F;\n    let mut _33: F;\n    let mut _34: usize;\n    let mut _35: bool;\n    let mut _36: F;\n    let mut _37: F;\n    let mut _38: F;\n    debug self => _1;\n    debug _cw => ();\n    debug value => _4;\n    debug value => _7;\n    debug shift => _19;\n    debug mantissa => _30;\n    debug residual => option::Option::<convert::Infallible>::None;\n    debug val => _30;\n    bb0: {\n        _2 = num::dec2flt::fpu::fpu_precision::set_precision::<F>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = num::dec2flt::decimal::Decimal::can_use_fast_path::<F>(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = ((*_1).0: i64);\n        _5 = Le(move _6, <F as num::dec2flt::float::RawFloat>::MAX_EXPONENT_FAST_PATH);\n        switchInt(move _5) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        _0 = option::Option::None;\n        StorageDead(_3);\n        goto -> bb35;\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = ((*_1).1: u64);\n        _7 = <F as num::dec2flt::float::RawFloat>::from_u64(move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageLive(_20);\n        _20 = ((*_1).0: i64);\n        _21 = CheckedSub(_20, <F as num::dec2flt::float::RawFloat>::MAX_EXPONENT_FAST_PATH);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _20, <F as num::dec2flt::float::RawFloat>::MAX_EXPONENT_FAST_PATH) -> [success: bb16, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).0: i64);\n        _9 = Lt(move _10, 0_i64);\n        switchInt(move _9) -> [0: bb12, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ((*_1).0: i64);\n        _15 = Eq(_14, i64::MIN);\n        assert(!move _15, \"attempt to negate `{}`, which would overflow\", _14) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _13 = Neg(move _14);\n        StorageDead(_14);\n        _12 = move _13 as usize;\n        StorageDead(_13);\n        _11 = <F as num::dec2flt::float::RawFloat>::pow10_fast_path(_12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _4 = <F as ops::arith::Div>::div(_7, move _11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_11);\n        goto -> bb15;\n    }\n    bb12: {\n        StorageDead(_10);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = ((*_1).0: i64);\n        _17 = move _18 as usize;\n        StorageDead(_18);\n        _16 = <F as num::dec2flt::float::RawFloat>::pow10_fast_path(_17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _4 = <F as ops::arith::Mul>::mul(_7, move _16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_16);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_9);\n        goto -> bb29;\n    }\n    bb16: {\n        _19 = move (_21.0: i64);\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = ((*_1).1: u64);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = num::dec2flt::decimal::INT_POW10;\n        StorageLive(_27);\n        _27 = _19 as usize;\n        _28 = Lt(_27, 16_usize);\n        assert(move _28, \"index out of bounds: the length is {} but the index is {}\", 16_usize, _27) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _25 = _26[_27];\n        _23 = num::<impl u64>::checked_mul(move _24, move _25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_25);\n        StorageDead(_24);\n        _22 = <option::Option<u64> as ops::try_trait::Try>::branch(move _23) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_23);\n        _29 = discriminant(_22);\n        switchInt(move _29) -> [0: bb21, 1: bb22, otherwise: bb20];\n    }\n    bb20: {\n        unreachable;\n    }\n    bb21: {\n        _30 = ((_22 as variant#0).0: u64);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_22);\n        StorageLive(_31);\n        _31 = Gt(_30, <F as num::dec2flt::float::RawFloat>::MAX_MANTISSA_FAST_PATH);\n        switchInt(move _31) -> [0: bb25, otherwise: bb24];\n    }\n    bb22: {\n        _0 = <option::Option<F> as ops::try_trait::FromResidual<option::Option<convert::Infallible>>>::from_residual(option::Option::<convert::Infallible>::None) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_22);\n        goto -> bb34;\n    }\n    bb24: {\n        _0 = option::Option::None;\n        StorageDead(_31);\n        goto -> bb34;\n    }\n    bb25: {\n        StorageDead(_31);\n        StorageLive(_32);\n        _32 = <F as num::dec2flt::float::RawFloat>::from_u64(_30) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_33);\n        _34 = <F as num::dec2flt::float::RawFloat>::MAX_EXPONENT_FAST_PATH as usize;\n        _33 = <F as num::dec2flt::float::RawFloat>::pow10_fast_path(_34) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _4 = <F as ops::arith::Mul>::mul(move _32, move _33) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_5);\n        StorageLive(_35);\n        _35 = ((*_1).2: bool);\n        switchInt(move _35) -> [0: bb32, otherwise: bb30];\n    }\n    bb30: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = _4;\n        _36 = <F as ops::arith::Neg>::neg(move _37) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_37);\n        _0 = option::Option::Some(move _36);\n        StorageDead(_36);\n        goto -> bb33;\n    }\n    bb32: {\n        StorageLive(_38);\n        _38 = _4;\n        _0 = option::Option::Some(move _38);\n        StorageDead(_38);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_35);\n        StorageDead(_4);\n        goto -> bb35;\n    }\n    bb34: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb35;\n    }\n    bb35: {\n        return;\n    }\n}\n",
  "doc": " Try turning the decimal into an exact float representation, using machine-sized integers\n and floats.\n\n This is extracted into a separate function so that it can be attempted before constructing\n a Decimal. This only works if both the mantissa and the exponent\n can be exactly represented as a machine float, since IEE-754 guarantees\n no rounding will occur.\n\n There is an exception: disguised fast-path cases, where we can shift\n powers-of-10 from the exponent to the significant digits.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}