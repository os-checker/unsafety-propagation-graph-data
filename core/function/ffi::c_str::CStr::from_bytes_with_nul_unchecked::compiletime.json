{
  "name": "ffi::c_str::CStr::from_bytes_with_nul_unchecked::compiletime",
  "safe": true,
  "callees": {
    "num::<impl usize>::saturating_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer subtraction. Computes `self - rhs`, saturating\n at the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ],
    "ffi::c_str::CStr": [
      "Ref"
    ]
  },
  "path": 12819,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2442:9: 2447:10",
  "src": "const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }",
  "mir": "fn ffi::c_str::CStr::from_bytes_with_nul_unchecked::compiletime(_1: &[u8]) -> &ffi::c_str::CStr {\n    let mut _0: &ffi::c_str::CStr;\n    let mut _2: usize;\n    let mut _3: usize;\n    let mut _4: bool;\n    let mut _5: u8;\n    let  _6: usize;\n    let mut _7: usize;\n    let mut _8: bool;\n    let  _9: !;\n    let mut _10: fmt::Arguments<'_>;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let  _13: u8;\n    let  _14: usize;\n    let mut _15: usize;\n    let mut _16: bool;\n    let  _17: !;\n    let mut _18: fmt::Arguments<'_>;\n    let  _19: *const ffi::c_str::CStr;\n    let mut _20: *const [u8];\n    debug bytes => _1;\n    debug i => _2;\n    debug byte => _13;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        _2 = num::<impl usize>::saturating_sub(move _3, 1_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = slice::<impl [u8]>::is_empty(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        goto -> bb8;\n    }\n    bb4: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = _2;\n        _7 = PtrMetadata(_1);\n        _8 = Lt(_6, _7);\n        assert(move _8, \"index out of bounds: the length is {} but the index is {}\", move _7, _6) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _5 = (*_1)[_6];\n        switchInt(move _5) -> [0: bb6, otherwise: bb7];\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_10);\n        _10 = fmt::Arguments::<'_>::from_str(\"input was not nul-terminated\") -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _9 = panicking::panic_fmt(move _10) -> unwind unreachable;\n    }\n    bb10: {\n        StorageLive(_11);\n        _11 = _2;\n        switchInt(move _11) -> [0: bb17, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_11);\n        _12 = CheckedSub(_2, 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 1_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _2 = move (_12.0: usize);\n        StorageLive(_14);\n        _14 = _2;\n        _15 = PtrMetadata(_1);\n        _16 = Lt(_14, _15);\n        assert(move _16, \"index out of bounds: the length is {} but the index is {}\", move _15, _14) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _13 = (*_1)[_14];\n        StorageDead(_14);\n        switchInt(_13) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        goto -> bb10;\n    }\n    bb15: {\n        StorageLive(_18);\n        _18 = fmt::Arguments::<'_>::from_str(\"input contained interior nul\") -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _17 = panicking::panic_fmt(move _18) -> unwind unreachable;\n    }\n    bb17: {\n        StorageDead(_11);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &raw const (*_1);\n        _19 = move _20 as *const ffi::c_str::CStr;\n        StorageDead(_20);\n        _0 = &(*_19);\n        StorageDead(_19);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}