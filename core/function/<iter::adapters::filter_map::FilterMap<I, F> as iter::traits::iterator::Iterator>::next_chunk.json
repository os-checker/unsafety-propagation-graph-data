{
  "name": "<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::try_for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that applies a fallible function to each item in the\n iterator, stopping at the first error and returning that error.\n\n This can also be thought of as the fallible form of [`for_each()`]\n or as the stateless version of [`try_fold()`].\n\n [`for_each()`]: Iterator::for_each\n [`try_fold()`]: Iterator::try_fold\n\n # Examples\n\n ```\n use std::fs::rename;\n use std::io::{stdout, Write};\n use std::path::Path;\n\n let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n\n let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{x}\"));\n assert!(res.is_ok());\n\n let mut it = data.iter().cloned();\n let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\n assert!(res.is_err());\n // It short-circuited, so the remaining items are still in the iterator:\n assert_eq!(it.next(), Some(\"stale_bread.json\"));\n ```\n\n The [`ControlFlow`] type can be used with this method for the situations\n in which you'd use `break` and `continue` in a normal loop:\n\n ```\n use std::ops::ControlFlow;\n\n let r = (2..100).try_for_each(|x| {\n     if 323 % x == 0 {\n         return ControlFlow::Break(x)\n     }\n\n     ControlFlow::Continue(())\n });\n assert_eq!(r, ControlFlow::Break(17));\n ```\n",
      "adt": {}
    },
    "mem::manually_drop::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {
        "mem::manually_drop::ManuallyDrop": "Constructor"
      }
    },
    "ops::deref::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::array_assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the values from an array of `MaybeUninit` containers.\n\n # Safety\n\n It is up to the caller to guarantee that all elements of the array are\n in an initialized state.\n\n # Examples\n\n ```\n #![feature(maybe_uninit_array_assume_init)]\n use std::mem::MaybeUninit;\n\n let mut array: [MaybeUninit<i32>; 3] = [MaybeUninit::uninit(); 3];\n array[0].write(0);\n array[1].write(1);\n array[2].write(2);\n\n // SAFETY: Now safe as we initialised all elements\n let array = unsafe {\n     MaybeUninit::array_assume_init(array)\n };\n\n assert_eq!(array, [0, 1, 2]);\n ```\n",
      "adt": {}
    },
    "array::iter::IntoIter::<T, N>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the elements in a partially-initialized buffer.\n\n If you have a fully-initialized array, then use [`IntoIterator`].\n But this is useful for returning partial results from unsafe code.\n\n # Safety\n\n - The `buffer[initialized]` elements must all be initialized.\n - The range must be canonical, with `initialized.start <= initialized.end`.\n - The range must be in-bounds for the buffer, with `initialized.end <= N`.\n   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n\n It's sound to have more elements initialized than mentioned, though that\n will most likely result in them being leaked.\n\n # Examples\n\n ```\n #![feature(array_into_iter_constructors)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n use std::array::IntoIter;\n use std::mem::MaybeUninit;\n\n # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n # // otherwise it could leak. A fully-general version this would need a drop\n # // guard to handle panics from the iterator, but this works for an example.\n fn next_chunk<T: Copy, const N: usize>(\n     it: &mut impl Iterator<Item = T>,\n ) -> Result<[T; N], IntoIter<T, N>> {\n     let mut buffer = [const { MaybeUninit::uninit() }; N];\n     let mut i = 0;\n     while i < N {\n         match it.next() {\n             Some(x) => {\n                 buffer[i].write(x);\n                 i += 1;\n             }\n             None => {\n                 // SAFETY: We've initialized the first `i` items\n                 unsafe {\n                     return Err(IntoIter::new_unchecked(buffer, 0..i));\n                 }\n             }\n         }\n     }\n\n     // SAFETY: We've initialized all N items\n     unsafe { Ok(buffer.transpose().assume_init()) }\n }\n\n let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n assert_eq!(r, [10, 11, 12, 13]);\n let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n ```\n",
      "adt": {
        "array::iter::IntoIter": "Constructor"
      }
    }
  },
  "adts": {
    "<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6645, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 6662, kind: RigidTy(Slice(Ty { id: 6644, kind: RigidTy(Adt(AdtDef(DefId { id: 24704, name: \"mem::maybe_uninit::MaybeUninit\" }), GenericArgs([Type(Ty { id: 3241, kind: Param(ParamTy { index: 0, name: \"B\" }) })]))) })) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "iter::adapters::filter_map::FilterMap": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ],
    "mem::manually_drop::ManuallyDrop": [
      "Plain",
      "Ref"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "array::iter::IntoIter": [
      "Plain"
    ]
  },
  "path": 13777,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter_map.rs:68:5: 123:6",
  "src": "fn next_chunk<const N: usize>(\n        &mut self,\n    ) -> Result<[Self::Item; N], array::IntoIter<Self::Item, N>> {\n        let mut array: [MaybeUninit<Self::Item>; N] = [const { MaybeUninit::uninit() }; N];\n\n        struct Guard<'a, T> {\n            array: &'a mut [MaybeUninit<T>],\n            initialized: usize,\n        }\n\n        impl<T> Drop for Guard<'_, T> {\n            #[inline]\n            fn drop(&mut self) {\n                if const { crate::mem::needs_drop::<T>() } {\n                    // SAFETY: self.initialized is always <= N, which also is the length of the array.\n                    unsafe {\n                        self.array.get_unchecked_mut(..self.initialized).assume_init_drop();\n                    }\n                }\n            }\n        }\n\n        let mut guard = Guard { array: &mut array, initialized: 0 };\n\n        let result = self.iter.try_for_each(|element| {\n            let idx = guard.initialized;\n            let val = (self.f)(element);\n            guard.initialized = idx + val.is_some() as usize;\n\n            // SAFETY: Loop conditions ensure the index is in bounds.\n\n            unsafe {\n                let opt_payload_at: *const MaybeUninit<B> =\n                    (&raw const val).byte_add(core::mem::offset_of!(Option<B>, Some.0)).cast();\n                let dst = guard.array.as_mut_ptr().add(idx);\n                crate::ptr::copy_nonoverlapping(opt_payload_at, dst, 1);\n                crate::mem::forget(val);\n            };\n\n            if guard.initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n        });\n\n        let guard = ManuallyDrop::new(guard);\n\n        match result {\n            ControlFlow::Break(()) => {\n                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n            }\n            ControlFlow::Continue(()) => {\n                let initialized = guard.initialized;\n                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n            }\n        }\n    }",
  "mir": "fn <iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk(_1: &mut iter::adapters::filter_map::FilterMap<I, F>) -> result::Result<[B; N], array::iter::IntoIter<B, N>> {\n    let mut _0: result::Result<[B; N], array::iter::IntoIter<B, N>>;\n    let mut _2: [mem::maybe_uninit::MaybeUninit<B>; N];\n    let mut _3: <iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>;\n    let mut _4: &mut [mem::maybe_uninit::MaybeUninit<B>];\n    let mut _5: &mut [mem::maybe_uninit::MaybeUninit<B>; N];\n    let  _6: ops::control_flow::ControlFlow<()>;\n    let mut _7: &mut I;\n    let mut _8: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter_map.rs:92:45: 92:54};\n    let mut _9: &mut usize;\n    let mut _10: &mut F;\n    let  _11: mem::manually_drop::ManuallyDrop<<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>>;\n    let mut _12: <iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>;\n    let mut _13: isize;\n    let mut _14: [B; N];\n    let mut _15: [mem::maybe_uninit::MaybeUninit<B>; N];\n    let  _16: usize;\n    let mut _17: &<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>;\n    let mut _18: &mem::manually_drop::ManuallyDrop<<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>>;\n    let mut _19: array::iter::IntoIter<B, N>;\n    let mut _20: [mem::maybe_uninit::MaybeUninit<B>; N];\n    let mut _21: ops::range::Range<usize>;\n    let mut _22: &mut [mem::maybe_uninit::MaybeUninit<B>];\n    debug self => _1;\n    debug array => _2;\n    debug guard => _3;\n    debug result => _6;\n    debug guard => _11;\n    debug initialized => _16;\n    bb0: {\n        StorageLive(_2);\n        _2 = [<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::<N>::{constant#2}; N];\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = &mut _2;\n        _4 = _5 as &mut [mem::maybe_uninit::MaybeUninit<B>];\n        _3 = Guard(move _4, 0_usize);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut ((*_1).0: I);\n        StorageLive(_8);\n        _22 = (_3.0: &mut [mem::maybe_uninit::MaybeUninit<B>]);\n        StorageLive(_9);\n        _9 = &mut (_3.1: usize);\n        StorageLive(_10);\n        _10 = &mut ((*_1).1: F);\n        _8 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter_map.rs:92:45: 92:54}(_22, move _9, move _10);\n        StorageDead(_10);\n        StorageDead(_9);\n        _6 = <I as iter::traits::iterator::Iterator>::try_for_each::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter_map.rs:92:45: 92:54}, ops::control_flow::ControlFlow<()>>(move _7, move _8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = move _3;\n        _11 = mem::manually_drop::ManuallyDrop::<<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>>::new(move _12) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_12);\n        _13 = discriminant(_6);\n        switchInt(move _13) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_11;\n        _17 = <mem::manually_drop::ManuallyDrop<<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk::Guard<'_, B>> as ops::deref::Deref>::deref(move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = move _2;\n        _14 = mem::maybe_uninit::MaybeUninit::<B>::array_assume_init::<N>(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _0 = result::Result::Ok(move _14);\n        StorageDead(_14);\n        goto -> bb9;\n    }\n    bb7: {\n        StorageDead(_18);\n        _16 = ((*_17).1: usize);\n        StorageDead(_17);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = move _2;\n        StorageLive(_21);\n        _21 = Range(0_usize, _16);\n        _19 = array::iter::IntoIter::<B, N>::new_unchecked(move _20, move _21) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_21);\n        StorageDead(_20);\n        _0 = result::Result::Err(move _19);\n        StorageDead(_19);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}