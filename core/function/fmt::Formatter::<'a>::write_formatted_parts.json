{
  "name": "fmt::Formatter::<'a>::write_formatted_parts",
  "safe": false,
  "callees": {
    "str::<impl str>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` has a length of zero bytes.\n\n # Examples\n\n ```\n let s = \"\";\n assert!(s.is_empty());\n\n let s = \"not empty\";\n assert!(!s.is_empty());\n ```\n",
      "adt": {}
    },
    "fmt::Write::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a string slice into this writer, returning whether the write\n succeeded.\n\n This method can only succeed if the entire string slice was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`std::fmt::Error`][Error] on error.\n\n The purpose of that error is to abort the formatting operation when the underlying\n destination encounters some error preventing it from accepting more text;\n in particular, it does not communicate any information about *what* error occurred.\n It should generally be propagated rather than handled, at least when implementing\n formatting traits.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n     f.write_str(s)\n }\n\n let mut buf = String::new();\n writer(&mut buf, \"hola\")?;\n assert_eq!(&buf, \"hola\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::write_formatted_parts::write_bytes": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "num::fmt::Part::<'a>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact byte length of given part.\n",
      "adt": {
        "num::fmt::Part": "MutableAsArgument"
      }
    },
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"ƒoo\".len(), 4); // fancy f!\n assert_eq!(\"ƒoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {
        "slice::iter::IterMut": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::rev::Rev": "Constructor"
      }
    }
  },
  "adts": {
    "num::fmt::Formatted": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "fmt::Formatter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ],
    "slice::iter::Iter": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 982, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 943, kind: RigidTy(Adt(AdtDef(DefId { id: 24751, name: \"num::fmt::Part\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 898, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Mut)) })])"
    ],
    "num::fmt::Part": [
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 419, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 423, kind: RigidTy(Slice(Ty { id: 46, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 136, kind: RigidTy(Uint(U16)) })])",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ],
    "slice::iter::IterMut": [
      "Plain"
    ],
    "iter::adapters::rev::Rev": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::fmt::Formatter::<'a>::write_formatted_parts"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:2024:5: 2068:6",
  "src": "unsafe fn write_formatted_parts(&mut self, formatted: &numfmt::Formatted<'_>) -> Result {\n        unsafe fn write_bytes(buf: &mut dyn Write, s: &[u8]) -> Result {\n            // SAFETY: This is used for `numfmt::Part::Num` and `numfmt::Part::Copy`.\n            // It's safe to use for `numfmt::Part::Num` since every char `c` is between\n            // `b'0'` and `b'9'`, which means `s` is valid UTF-8. It's safe to use for\n            // `numfmt::Part::Copy` due to this function's precondition.\n            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n        }\n\n        if !formatted.sign.is_empty() {\n            self.buf.write_str(formatted.sign)?;\n        }\n        for part in formatted.parts {\n            match *part {\n                numfmt::Part::Zero(mut nzeroes) => {\n                    const ZEROES: &str = // 64 zeroes\n                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n                    while nzeroes > ZEROES.len() {\n                        self.buf.write_str(ZEROES)?;\n                        nzeroes -= ZEROES.len();\n                    }\n                    if nzeroes > 0 {\n                        self.buf.write_str(&ZEROES[..nzeroes])?;\n                    }\n                }\n                numfmt::Part::Num(mut v) => {\n                    let mut s = [0; 5];\n                    let len = part.len();\n                    for c in s[..len].iter_mut().rev() {\n                        *c = b'0' + (v % 10) as u8;\n                        v /= 10;\n                    }\n                    // SAFETY: Per the precondition.\n                    unsafe {\n                        write_bytes(self.buf, &s[..len])?;\n                    }\n                }\n                // SAFETY: Per the precondition.\n                numfmt::Part::Copy(buf) => unsafe {\n                    write_bytes(self.buf, buf)?;\n                },\n            }\n        }\n        Ok(())\n    }",
  "mir": "fn fmt::Formatter::<'a>::write_formatted_parts(_1: &mut fmt::Formatter<'_>, _2: &num::fmt::Formatted<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: bool;\n    let mut _4: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _5: result::Result<(), fmt::Error>;\n    let mut _6: isize;\n    let mut _7: slice::iter::Iter<'_, num::fmt::Part<'_>>;\n    let mut _8: &[num::fmt::Part<'_>];\n    let mut _9: slice::iter::Iter<'_, num::fmt::Part<'_>>;\n    let mut _10: option::Option<&num::fmt::Part<'_>>;\n    let mut _11: &mut slice::iter::Iter<'_, num::fmt::Part<'_>>;\n    let mut _12: isize;\n    let  _13: &num::fmt::Part<'_>;\n    let mut _14: isize;\n    let mut _15: usize;\n    let mut _16: bool;\n    let mut _17: usize;\n    let mut _18: usize;\n    let mut _19: &str;\n    let mut _20: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _21: result::Result<(), fmt::Error>;\n    let mut _22: &str;\n    let mut _23: isize;\n    let mut _24: usize;\n    let mut _25: &str;\n    let mut _26: (usize, bool);\n    let mut _27: bool;\n    let mut _28: usize;\n    let mut _29: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _30: result::Result<(), fmt::Error>;\n    let  _31: &str;\n    let mut _32: &str;\n    let mut _33: ops::range::RangeTo<usize>;\n    let mut _34: usize;\n    let mut _35: isize;\n    let mut _36: u16;\n    let mut _37: [u8; 5];\n    let  _38: usize;\n    let mut _39: iter::adapters::rev::Rev<slice::iter::IterMut<'_, u8>>;\n    let mut _40: iter::adapters::rev::Rev<slice::iter::IterMut<'_, u8>>;\n    let mut _41: slice::iter::IterMut<'_, u8>;\n    let mut _42: &mut [u8];\n    let mut _43: &mut [u8; 5];\n    let mut _44: ops::range::RangeTo<usize>;\n    let mut _45: iter::adapters::rev::Rev<slice::iter::IterMut<'_, u8>>;\n    let mut _46: option::Option<&mut u8>;\n    let mut _47: &mut iter::adapters::rev::Rev<slice::iter::IterMut<'_, u8>>;\n    let mut _48: isize;\n    let  _49: &mut u8;\n    let mut _50: u8;\n    let mut _51: u16;\n    let mut _52: u16;\n    let mut _53: bool;\n    let mut _54: (u8, bool);\n    let mut _55: bool;\n    let mut _56: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _57: result::Result<(), fmt::Error>;\n    let  _58: &[u8];\n    let mut _59: &[u8; 5];\n    let mut _60: ops::range::RangeTo<usize>;\n    let mut _61: isize;\n    let  _62: &[u8];\n    let mut _63: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _64: result::Result<(), fmt::Error>;\n    let mut _65: isize;\n    let mut _66: &str;\n    let mut _67: &mut dyn fmt::Write;\n    let mut _68: &str;\n    let mut _69: &mut dyn fmt::Write;\n    let mut _70: &mut dyn fmt::Write;\n    let mut _71: &mut dyn fmt::Write;\n    let mut _72: &mut dyn fmt::Write;\n    debug self => _1;\n    debug formatted => _2;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug iter => _9;\n    debug part => _13;\n    debug nzeroes => _15;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug v => _36;\n    debug s => _37;\n    debug len => _38;\n    debug iter => _45;\n    debug c => _49;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug buf => _62;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        _66 = ((*_2).0: &str);\n        _3 = str::<impl str>::is_empty(_66) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        goto -> bb10;\n    }\n    bb3: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _67 = ((*_1).1: &mut dyn fmt::Write);\n        _68 = ((*_2).0: &str);\n        _5 = <dyn fmt::Write as fmt::Write>::write_str(_67, _68) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _4 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb8: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb65;\n    }\n    bb10: {\n        StorageDead(_3);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = ((*_2).1: &[num::fmt::Part<'_>]);\n        _7 = <&[num::fmt::Part<'_>] as iter::traits::collect::IntoIterator>::into_iter(move _8) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_8);\n        StorageLive(_9);\n        _9 = move _7;\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_10);\n        _11 = &mut _9;\n        _10 = <slice::iter::Iter<'_, num::fmt::Part<'_>> as iter::traits::iterator::Iterator>::next(_11) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb15, 1: bb14, otherwise: bb6];\n    }\n    bb14: {\n        _13 = ((_10 as variant#1).0: &num::fmt::Part<'_>);\n        _14 = discriminant((*_13));\n        switchInt(move _14) -> [0: bb18, 1: bb17, 2: bb16, otherwise: bb6];\n    }\n    bb15: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_7);\n        _0 = result::Result::Ok(());\n        goto -> bb65;\n    }\n    bb16: {\n        _62 = (((*_13) as variant#2).0: &[u8]);\n        StorageLive(_63);\n        StorageLive(_64);\n        _69 = ((*_1).1: &mut dyn fmt::Write);\n        _64 = fmt::Formatter::<'a>::write_formatted_parts::write_bytes(_69, _62) -> [return: bb57, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_36);\n        _36 = (((*_13) as variant#1).0: u16);\n        StorageLive(_37);\n        _37 = [0_u8; 5];\n        _38 = num::fmt::Part::<'_>::len(_13) -> [return: bb39, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_15);\n        _15 = (((*_13) as variant#0).0: usize);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _15;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = fmt::Formatter::<'a>::write_formatted_parts::ZEROES;\n        _18 = str::<impl str>::len(move _19) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_19);\n        _16 = Gt(move _17, move _18);\n        switchInt(move _16) -> [0: bb29, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_20);\n        StorageLive(_21);\n        _70 = ((*_1).1: &mut dyn fmt::Write);\n        StorageLive(_22);\n        _22 = fmt::Formatter::<'a>::write_formatted_parts::ZEROES;\n        _21 = <dyn fmt::Write as fmt::Write>::write_str(_70, move _22) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_22);\n        _20 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _21) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_21);\n        _23 = discriminant(_20);\n        switchInt(move _23) -> [0: bb24, 1: bb25, otherwise: bb6];\n    }\n    bb24: {\n        StorageDead(_20);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = fmt::Formatter::<'a>::write_formatted_parts::ZEROES;\n        _24 = str::<impl str>::len(move _25) -> [return: bb27, unwind unreachable];\n    }\n    bb25: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_20);\n        StorageDead(_16);\n        goto -> bb63;\n    }\n    bb27: {\n        StorageDead(_25);\n        _26 = CheckedSub(_15, _24);\n        assert(!move (_26.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _15, move _24) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _15 = move (_26.0: usize);\n        StorageDead(_24);\n        StorageDead(_16);\n        goto -> bb19;\n    }\n    bb29: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _15;\n        _27 = Gt(move _28, 0_usize);\n        switchInt(move _27) -> [0: bb31, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _71 = ((*_1).1: &mut dyn fmt::Write);\n        StorageLive(_32);\n        _32 = fmt::Formatter::<'a>::write_formatted_parts::ZEROES;\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = _15;\n        _33 = RangeTo(move _34);\n        StorageDead(_34);\n        _31 = <str as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _32, move _33) -> [return: bb32, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_28);\n        goto -> bb38;\n    }\n    bb32: {\n        StorageDead(_33);\n        StorageDead(_32);\n        _30 = <dyn fmt::Write as fmt::Write>::write_str(_71, _31) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        _29 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _30) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_30);\n        _35 = discriminant(_29);\n        switchInt(move _35) -> [0: bb35, 1: bb36, otherwise: bb6];\n    }\n    bb35: {\n        StorageDead(_29);\n        goto -> bb38;\n    }\n    bb36: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_29);\n        StorageDead(_27);\n        goto -> bb63;\n    }\n    bb38: {\n        StorageDead(_27);\n        StorageDead(_15);\n        goto -> bb62;\n    }\n    bb39: {\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_43);\n        _43 = &mut _37;\n        StorageLive(_44);\n        _44 = RangeTo(_38);\n        _42 = <[u8; 5] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(move _43, move _44) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_44);\n        StorageDead(_43);\n        _41 = slice::<impl [u8]>::iter_mut(_42) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _40 = <slice::iter::IterMut<'_, u8> as iter::traits::iterator::Iterator>::rev(move _41) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_41);\n        _39 = <iter::adapters::rev::Rev<slice::iter::IterMut<'_, u8>> as iter::traits::collect::IntoIterator>::into_iter(move _40) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_40);\n        StorageLive(_45);\n        _45 = move _39;\n        goto -> bb44;\n    }\n    bb44: {\n        StorageLive(_46);\n        _47 = &mut _45;\n        _46 = <iter::adapters::rev::Rev<slice::iter::IterMut<'_, u8>> as iter::traits::iterator::Iterator>::next(_47) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        _48 = discriminant(_46);\n        switchInt(move _48) -> [0: bb47, 1: bb46, otherwise: bb6];\n    }\n    bb46: {\n        StorageLive(_49);\n        _49 = move ((_46 as variant#1).0: &mut u8);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = _36;\n        _53 = Eq(10_u16, 0_u16);\n        assert(!move _53, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _52) -> [success: bb48, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_46);\n        StorageDead(_45);\n        StorageDead(_39);\n        StorageLive(_56);\n        StorageLive(_57);\n        _72 = ((*_1).1: &mut dyn fmt::Write);\n        StorageLive(_59);\n        _59 = &_37;\n        StorageLive(_60);\n        _60 = RangeTo(_38);\n        _58 = <[u8; 5] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _59, move _60) -> [return: bb51, unwind unreachable];\n    }\n    bb48: {\n        _51 = Rem(move _52, 10_u16);\n        StorageDead(_52);\n        _50 = move _51 as u8;\n        StorageDead(_51);\n        _54 = CheckedAdd(48_u8, _50);\n        assert(!move (_54.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, move _50) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        (*_49) = move (_54.0: u8);\n        StorageDead(_50);\n        _55 = Eq(10_u16, 0_u16);\n        assert(!move _55, \"attempt to divide `{}` by zero\", _36) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _36 = Div(_36, 10_u16);\n        StorageDead(_49);\n        StorageDead(_46);\n        goto -> bb44;\n    }\n    bb51: {\n        StorageDead(_60);\n        StorageDead(_59);\n        _57 = fmt::Formatter::<'a>::write_formatted_parts::write_bytes(_72, _58) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        _56 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _57) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_57);\n        _61 = discriminant(_56);\n        switchInt(move _61) -> [0: bb54, 1: bb55, otherwise: bb6];\n    }\n    bb54: {\n        StorageDead(_56);\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb62;\n    }\n    bb55: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_56);\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb64;\n    }\n    bb57: {\n        _63 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _64) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_64);\n        _65 = discriminant(_63);\n        switchInt(move _65) -> [0: bb59, 1: bb60, otherwise: bb6];\n    }\n    bb59: {\n        StorageDead(_63);\n        goto -> bb62;\n    }\n    bb60: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_63);\n        goto -> bb64;\n    }\n    bb62: {\n        StorageDead(_10);\n        goto -> bb12;\n    }\n    bb63: {\n        StorageDead(_15);\n        goto -> bb64;\n    }\n    bb64: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_7);\n        goto -> bb65;\n    }\n    bb65: {\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n Any `numfmt::Part::Copy` parts in `formatted` must contain valid UTF-8.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}