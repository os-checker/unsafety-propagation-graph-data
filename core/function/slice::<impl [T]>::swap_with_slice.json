{
  "name": "slice::<impl [T]>::swap_with_slice",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "ptr::swap_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps `count * size_of::<T>()` bytes between the two regions of memory\n beginning at `x` and `y`. The two regions must *not* overlap.\n\n The operation is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * Both `x` and `y` must be [valid] for both reads and writes of `count *\n   size_of::<T>()` bytes.\n\n * Both `x` and `y` must be properly aligned.\n\n * The region of memory beginning at `x` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `y` with the same size.\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is `0`,\n the pointers must be properly aligned.\n\n [valid]: self#safety\n\n # Examples\n\n Basic usage:\n\n ```\n use std::ptr;\n\n let mut x = [1, 2, 3, 4];\n let mut y = [7, 8, 9];\n\n unsafe {\n     ptr::swap_nonoverlapping(x.as_mut_ptr(), y.as_mut_ptr(), 2);\n }\n\n assert_eq!(x, [7, 8, 3, 4]);\n assert_eq!(y, [1, 2, 9]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::swap_with_slice"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3992:5: 4000:6",
  "src": "pub const fn swap_with_slice(&mut self, other: &mut [T]) {\n        assert!(self.len() == other.len(), \"destination and source slices have different lengths\");\n        // SAFETY: `self` is valid for `self.len()` elements by definition, and `src` was\n        // checked to have the same length. The slices cannot overlap because\n        // mutable references are exclusive.\n        unsafe {\n            ptr::swap_nonoverlapping(self.as_mut_ptr(), other.as_mut_ptr(), self.len());\n        }\n    }",
  "mir": "fn slice::<impl [T]>::swap_with_slice(_1: &mut [T], _2: &mut [T]) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &[T];\n    let mut _6: usize;\n    let mut _7: &[T];\n    let  _8: !;\n    let mut _9: fmt::Arguments<'_>;\n    let  _10: ();\n    let mut _11: *mut T;\n    let mut _12: *mut T;\n    let mut _13: usize;\n    let mut _14: &[T];\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_2);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        _3 = Eq(move _4, move _6);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_11);\n        _11 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_9);\n        _9 = fmt::Arguments::<'_>::from_str(\"destination and source slices have different lengths\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = panicking::panic_fmt(move _9) -> unwind unreachable;\n    }\n    bb4: {\n        StorageLive(_12);\n        _12 = slice::<impl [T]>::as_mut_ptr(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_1);\n        _13 = PtrMetadata(move _14);\n        StorageDead(_14);\n        _10 = ptr::swap_nonoverlapping::<T>(move _11, move _12, move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        return;\n    }\n}\n",
  "doc": " Swaps all elements in `self` with those in `other`.\n\n The length of `other` must be the same as `self`.\n\n # Panics\n\n This function will panic if the two slices have different lengths.\n\n # Example\n\n Swapping two elements across slices:\n\n ```\n let mut slice1 = [0, 0];\n let mut slice2 = [1, 2, 3, 4];\n\n slice1.swap_with_slice(&mut slice2[2..]);\n\n assert_eq!(slice1, [3, 4]);\n assert_eq!(slice2, [1, 2, 0, 0]);\n ```\n\n Rust enforces that there can only be one mutable reference to a\n particular piece of data in a particular scope. Because of this,\n attempting to use `swap_with_slice` on a single slice will result in\n a compile failure:\n\n ```compile_fail\n let mut slice = [1, 2, 3, 4, 5];\n slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n ```\n\n To work around this, we can use [`split_at_mut`] to create two distinct\n mutable sub-slices from a slice:\n\n ```\n let mut slice = [1, 2, 3, 4, 5];\n\n {\n     let (left, right) = slice.split_at_mut(2);\n     left.swap_with_slice(&mut right[1..]);\n }\n\n assert_eq!(slice, [4, 5, 3, 1, 2]);\n ```\n\n [`split_at_mut`]: slice::split_at_mut\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}