{
  "name": "<iter::adapters::cloned::Cloned<I> as iter::traits::double_ended::DoubleEndedIterator>::rfold",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {
        "iter::adapters::map::Map": "Constructor"
      }
    },
    "clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "iter::traits::double_ended::DoubleEndedIterator::rfold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that reduces the iterator's elements to a single,\n final value, starting from the back.\n\n This is the reverse version of [`Iterator::fold()`]: it takes elements\n starting from the back of the iterator.\n\n `rfold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `rfold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `rfold()` combines elements in a *right-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *left-associative* version of `rfold()`, see [`Iterator::fold()`].\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of a\n let sum = a.iter()\n            .rfold(0, |acc, &x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n This example demonstrates the right-associative nature of `rfold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the back until the front:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().rfold(zero, |acc, &x| {\n     format!(\"({x} + {acc})\")\n });\n\n assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::cloned::Cloned": [
      "Unknown([Field(0, Ty { id: 1037, kind: Param(ParamTy { index: 1, name: \"I\" }) })])",
      "Plain"
    ],
    "iter::adapters::map::Map": [
      "Plain"
    ]
  },
  "path": 13671,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/cloned.rs:93:5: 98:6",
  "src": "fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n    where\n        F: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.it.map(T::clone).rfold(init, f)\n    }",
  "mir": "fn <iter::adapters::cloned::Cloned<I> as iter::traits::double_ended::DoubleEndedIterator>::rfold(_1: iter::adapters::cloned::Cloned<I>, _2: Acc, _3: F) -> Acc {\n    let mut _0: Acc;\n    let mut _4: iter::adapters::map::Map<I, for<'a> fn(&'a T) -> T {<T as clone::Clone>::clone}>;\n    let mut _5: I;\n    debug self => _1;\n    debug init => _2;\n    debug f => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = move (_1.0: I);\n        _4 = <I as iter::traits::iterator::Iterator>::map::<T, for<'a> fn(&'a T) -> T {<T as clone::Clone>::clone}>(move _5, <T as clone::Clone>::clone) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _0 = <iter::adapters::map::Map<I, for<'a> fn(&'a T) -> T {<T as clone::Clone>::clone}> as iter::traits::double_ended::DoubleEndedIterator>::rfold::<Acc, F>(move _4, _2, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}