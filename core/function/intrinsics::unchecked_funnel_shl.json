{
  "name": "intrinsics::unchecked_funnel_shl",
  "safe": false,
  "callees": {
    "intrinsics::fallback::FunnelShift::unchecked_funnel_shl": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " See [`super::unchecked_funnel_shl`]; we just need the trait indirection to handle\n different types since calling intrinsics with generics doesn't work.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::intrinsics::unchecked_funnel_shl"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2137:1: 2144:2",
  "src": "pub const unsafe fn unchecked_funnel_shl<T: [const] fallback::FunnelShift>(\n    a: T,\n    b: T,\n    shift: u32,\n) -> T {\n    // SAFETY: caller ensures that `shift` is in-range\n    unsafe { a.unchecked_funnel_shl(b, shift) }\n}",
  "mir": "fn intrinsics::unchecked_funnel_shl(_1: T, _2: T, _3: u32) -> T {\n    let mut _0: T;\n    debug a => _1;\n    debug b => _2;\n    debug shift => _3;\n    bb0: {\n        _0 = <T as intrinsics::fallback::FunnelShift>::unchecked_funnel_shl(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Funnel Shift left.\n\n Concatenates `a` and `b` (with `a` in the most significant half),\n creating an integer twice as wide. Then shift this integer left\n by `shift`), and extract the most significant half. If `a` and `b`\n are the same, this is equivalent to a rotate left operation.\n\n It is undefined behavior if `shift` is greater than or equal to the\n bit size of `T`.\n\n Safe versions of this intrinsic are available on the integer primitives\n via the `funnel_shl` method. For example, [`u32::funnel_shl`].\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}