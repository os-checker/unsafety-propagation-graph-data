{
  "name": "ascii::ascii_char::AsciiChar::digit_unchecked",
  "safe": false,
  "callees": {
    "ascii::ascii_char::AsciiChar::digit_unchecked::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "num::<impl u8>::unchecked_add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unchecked integer addition. Computes `self + rhs`, assuming overflow\n cannot occur.\n\n Calling `x.unchecked_add(y)` is semantically equivalent to calling\n `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n\n If you're just trying to avoid the panic in debug mode, then **do not**\n use this.  Instead, you're looking for [`wrapping_add`].\n\n # Safety\n\n This results in undefined behavior when\n i.e. when [`checked_add`] would return `None`.\n\n [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n",
      "adt": {}
    },
    "ascii::ascii_char::AsciiChar::from_u8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an ASCII character from the byte `b`,\n without checking whether it's valid.\n\n # Safety\n\n `b` must be in `0..=127`, or else this is UB.\n",
      "adt": {
        "ascii::ascii_char::AsciiChar": "Constructor"
      }
    }
  },
  "adts": {
    "ascii::ascii_char::AsciiChar": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::ascii::ascii_char::AsciiChar::digit_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ascii/ascii_char.rs:516:5: 530:6",
  "src": "pub const unsafe fn digit_unchecked(d: u8) -> Self {\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"`ascii::Char::digit_unchecked` input cannot exceed 9.\",\n            (d: u8 = d) => d < 10\n        );\n\n        // SAFETY: `'0'` through `'9'` are U+00030 through U+0039,\n        // so because `d` must be 64 or less the addition can return at most\n        // 112 (0x70), which doesn't overflow and is within the ASCII range.\n        unsafe {\n            let byte = b'0'.unchecked_add(d);\n            Self::from_u8_unchecked(byte)\n        }\n    }",
  "mir": "fn ascii::ascii_char::AsciiChar::digit_unchecked(_1: u8) -> ascii::ascii_char::AsciiChar {\n    let mut _0: ascii::ascii_char::AsciiChar;\n    let mut _2: bool;\n    let  _3: ();\n    let  _4: u8;\n    debug d => _1;\n    debug byte => _4;\n    bb0: {\n        StorageLive(_2);\n        _2 = RuntimeChecks(UbChecks)() \" \";\n        switchInt(move _2) -> [0: bb3, otherwise: bb1];\n    }\n    bb1: {\n        _3 = ascii::ascii_char::AsciiChar::digit_unchecked::precondition_check(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        goto -> bb3;\n    }\n    bb3: {\n        StorageDead(_2);\n        _4 = num::<impl u8>::unchecked_add(48_u8, _1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _0 = ascii::ascii_char::AsciiChar::from_u8_unchecked(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": " When passed the *number* `0`, `1`, …, `9`, returns the *character*\n `'0'`, `'1'`, …, `'9'` respectively, without checking that it's in-range.\n\n # Safety\n\n This is immediate UB if called with `d > 64`.\n\n If `d >= 10` and `d <= 64`, this is allowed to return any value or panic.\n Notably, it should not be expected to return hex digits, or any other\n reasonable extension of the decimal digits.\n\n (This loose safety condition is intended to simplify soundness proofs\n when writing code using this method, since the implementation doesn't\n need something really specific, not to make those other arguments do\n something useful. It might be tightened before stabilization.)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}