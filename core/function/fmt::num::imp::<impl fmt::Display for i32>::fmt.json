{
  "name": "fmt::num::imp::<impl fmt::Display for i32>::fmt",
  "safe": true,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "num::<impl i32>::unsigned_abs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes the absolute value of `self` without any wrapping\n or panicking.\n\n\n # Examples\n\n ```\n assert_eq!((-128i8).unsigned_abs(), 128u8);\n ```\n",
      "adt": {}
    },
    "fmt::num::imp::<impl u32>::_fmt": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": "",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad_integral": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.\n\n # Arguments\n\n * is_nonnegative - whether the original integer was either positive or zero.\n * prefix - if the '#' character (Alternate) is provided, this\n   is the prefix to put in front of the number.\n * buf - the byte array that the number has been formatted into\n\n This function will correctly account for the flags provided as well as\n the minimum width. It will not take precision into account.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo { nb: i32 }\n\n impl Foo {\n     fn new(nb: i32) -> Foo {\n         Foo {\n             nb,\n         }\n     }\n }\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // We need to remove \"-\" from the number output.\n         let tmp = self.nb.abs().to_string();\n\n         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": 2268,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:156:13: 172:14",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                #[cfg(not(feature = \"optimize_for_size\"))]\n                {\n                    const MAX_DEC_N: usize = $Unsigned::MAX.ilog10() as usize + 1;\n                    // Buffer decimals for self with right alignment.\n                    let mut buf = [MaybeUninit::<u8>::uninit(); MAX_DEC_N];\n\n                    // SAFETY: `buf` is always big enough to contain all the digits.\n                    unsafe { f.pad_integral(*self >= 0, \"\", self.unsigned_abs()._fmt(&mut buf)) }\n                }\n                #[cfg(feature = \"optimize_for_size\")]\n                {\n                    // Lossless conversion (with as) is asserted at the top of\n                    // this macro.\n                    return ${concat($fmt_fn, _small)}(self.unsigned_abs() as $T, *self >= 0, f);\n                }\n            }",
  "mir": "fn fmt::num::imp::<impl fmt::Display for i32>::fmt(_1: &i32, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: [mem::maybe_uninit::MaybeUninit<u8>; 10];\n    let mut _4: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _5: bool;\n    let mut _6: i32;\n    let mut _7: &str;\n    let  _8: &str;\n    let mut _9: u32;\n    let mut _10: i32;\n    let mut _11: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _12: &mut [mem::maybe_uninit::MaybeUninit<u8>; 10];\n    debug self => _1;\n    debug f => _2;\n    debug buf => _3;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = mem::maybe_uninit::MaybeUninit::<u8>::uninit() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = [move _4; 10];\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = (*_1);\n        _5 = Ge(move _6, 0_i32);\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = \"\";\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (*_1);\n        _9 = num::<impl i32>::unsigned_abs(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _12 = &mut _3;\n        _11 = _12 as &mut [mem::maybe_uninit::MaybeUninit<u8>];\n        _8 = fmt::num::imp::<impl u32>::_fmt(move _9, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        StorageDead(_9);\n        _0 = fmt::Formatter::<'_>::pad_integral(_2, move _5, move _7, _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}