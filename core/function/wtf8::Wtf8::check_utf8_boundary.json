{
  "name": "wtf8::Wtf8::check_utf8_boundary",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice depending on the type of\n index.\n\n - If given a position, returns a reference to the element at that\n   position or `None` if out of bounds.\n - If given a range, returns the subslice corresponding to that range,\n   or `None` if out of bounds.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&40), v.get(1));\n assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n assert_eq!(None, v.get(3));\n assert_eq!(None, v.get(0..4));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "wtf8::Wtf8::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length, in WTF-8 bytes.\n",
      "adt": {
        "wtf8::Wtf8": "ImmutableAsArgument"
      }
    },
    "fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::rt::Argument": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "wtf8::Wtf8": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) })])"
    ],
    "fmt::rt::Argument": [
      "Plain"
    ],
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::wtf8::Wtf8::check_utf8_boundary"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/wtf8.rs:456:5: 473:6",
  "src": "pub fn check_utf8_boundary(&self, index: usize) {\n        if index == 0 {\n            return;\n        }\n        match self.bytes.get(index) {\n            Some(0xED) => (), // Might be a surrogate\n            Some(&b) if (b as i8) >= -0x40 => return,\n            Some(_) => panic!(\"byte index {index} is not a codepoint boundary\"),\n            None if index == self.len() => return,\n            None => panic!(\"byte index {index} is out of bounds\"),\n        }\n        if self.bytes[index + 1] >= 0xA0 {\n            // There's a surrogate after index. Now check before index.\n            if index >= 3 && self.bytes[index - 3] == 0xED && self.bytes[index - 2] >= 0xA0 {\n                panic!(\"byte index {index} lies between surrogate codepoints\");\n            }\n        }\n    }",
  "mir": "fn wtf8::Wtf8::check_utf8_boundary(_1: &wtf8::Wtf8, _2: usize) -> () {\n    let mut _0: ();\n    let mut _3: option::Option<&u8>;\n    let mut _4: &[u8];\n    let mut _5: isize;\n    let  _6: u8;\n    let mut _7: bool;\n    let mut _8: i8;\n    let mut _9: u8;\n    let  _10: !;\n    let mut _11: fmt::Arguments<'_>;\n    let  _12: (&usize,);\n    let mut _13: &usize;\n    let  _14: [fmt::rt::Argument<'_>; 1];\n    let mut _15: fmt::rt::Argument<'_>;\n    let mut _16: &[u8; 43];\n    let  _17: &[fmt::rt::Argument<'_>; 1];\n    let mut _18: bool;\n    let mut _19: usize;\n    let  _20: !;\n    let mut _21: fmt::Arguments<'_>;\n    let  _22: (&usize,);\n    let mut _23: &usize;\n    let  _24: [fmt::rt::Argument<'_>; 1];\n    let mut _25: fmt::rt::Argument<'_>;\n    let mut _26: &[u8; 32];\n    let  _27: &[fmt::rt::Argument<'_>; 1];\n    let mut _28: bool;\n    let mut _29: u8;\n    let  _30: usize;\n    let mut _31: (usize, bool);\n    let mut _32: *const [u8];\n    let mut _33: usize;\n    let mut _34: bool;\n    let mut _35: bool;\n    let mut _36: u8;\n    let  _37: usize;\n    let mut _38: (usize, bool);\n    let mut _39: *const [u8];\n    let mut _40: usize;\n    let mut _41: bool;\n    let mut _42: bool;\n    let mut _43: u8;\n    let  _44: usize;\n    let mut _45: (usize, bool);\n    let mut _46: *const [u8];\n    let mut _47: usize;\n    let mut _48: bool;\n    let  _49: !;\n    let mut _50: fmt::Arguments<'_>;\n    let  _51: (&usize,);\n    let mut _52: &usize;\n    let  _53: [fmt::rt::Argument<'_>; 1];\n    let mut _54: fmt::rt::Argument<'_>;\n    let mut _55: &[u8; 49];\n    let  _56: &[fmt::rt::Argument<'_>; 1];\n    let mut _57: &u8;\n    let mut _58: &u8;\n    let mut _59: &u8;\n    let mut _60: &usize;\n    let mut _61: &usize;\n    let mut _62: &usize;\n    debug self => _1;\n    debug index => _2;\n    debug b => _6;\n    debug b => _58;\n    debug args => _12;\n    debug args => _14;\n    debug args => _22;\n    debug args => _24;\n    debug args => _51;\n    debug args => _53;\n    bb0: {\n        switchInt(_2) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        goto -> bb37;\n    }\n    bb2: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: [u8]);\n        _3 = slice::<impl [u8]>::get::<usize>(move _4, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb6, 1: bb5, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _57 = ((_3 as variant#1).0: &u8);\n        switchInt((*_57)) -> [237: bb8, otherwise: bb7];\n    }\n    bb6: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = wtf8::Wtf8::len(_1) -> [return: bb13, unwind unreachable];\n    }\n    bb7: {\n        _58 = ((_3 as variant#1).0: &u8);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = (*_58);\n        _8 = move _9 as i8;\n        StorageDead(_9);\n        _7 = Ge(move _8, -64_i8);\n        switchInt(move _7) -> [0: bb10, otherwise: bb9];\n    }\n    bb8: {\n        StorageDead(_3);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _31 = CheckedAdd(_2, 1_usize);\n        assert(!move (_31.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb18, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_6);\n        _59 = ((_3 as variant#1).0: &u8);\n        _6 = (*_59);\n        StorageDead(_6);\n        goto -> bb36;\n    }\n    bb10: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_2;\n        _12 = (move _13);\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _60 = (_12.0: &usize);\n        _15 = fmt::rt::Argument::<'_>::new_display::<usize>(_60) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _14 = [move _15];\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = b\"\\x0bbyte index \\xc0\\x1c is not a codepoint boundary\\x00\";\n        _17 = &_14;\n        _11 = fmt::Arguments::<'_>::new::<43, 1>(move _16, _17) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        _10 = panicking::panic_fmt(move _11) -> unwind unreachable;\n    }\n    bb13: {\n        _18 = Eq(_2, move _19);\n        switchInt(move _18) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb36;\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_2;\n        _22 = (move _23);\n        StorageDead(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _61 = (_22.0: &usize);\n        _25 = fmt::rt::Argument::<'_>::new_display::<usize>(_61) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _24 = [move _25];\n        StorageDead(_25);\n        StorageLive(_26);\n        _26 = b\"\\x0bbyte index \\xc0\\x11 is out of bounds\\x00\";\n        _27 = &_24;\n        _21 = fmt::Arguments::<'_>::new::<32, 1>(move _26, _27) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_26);\n        _20 = panicking::panic_fmt(move _21) -> unwind unreachable;\n    }\n    bb18: {\n        _30 = move (_31.0: usize);\n        _32 = &raw const (fake) ((*_1).0: [u8]);\n        _33 = PtrMetadata(move _32);\n        _34 = Lt(_30, _33);\n        assert(move _34, \"index out of bounds: the length is {} but the index is {}\", move _33, _30) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _29 = ((*_1).0: [u8])[_30];\n        _28 = Ge(move _29, 160_u8);\n        switchInt(move _28) -> [0: bb34, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_35);\n        _35 = Ge(_2, 3_usize);\n        switchInt(move _35) -> [0: bb32, otherwise: bb21];\n    }\n    bb21: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _38 = CheckedSub(_2, 3_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 3_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _37 = move (_38.0: usize);\n        _39 = &raw const (fake) ((*_1).0: [u8]);\n        _40 = PtrMetadata(move _39);\n        _41 = Lt(_37, _40);\n        assert(move _41, \"index out of bounds: the length is {} but the index is {}\", move _40, _37) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _36 = ((*_1).0: [u8])[_37];\n        switchInt(move _36) -> [237: bb24, otherwise: bb31];\n    }\n    bb24: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _45 = CheckedSub(_2, 2_usize);\n        assert(!move (_45.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, 2_usize) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _44 = move (_45.0: usize);\n        _46 = &raw const (fake) ((*_1).0: [u8]);\n        _47 = PtrMetadata(move _46);\n        _48 = Lt(_44, _47);\n        assert(move _48, \"index out of bounds: the length is {} but the index is {}\", move _47, _44) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _43 = ((*_1).0: [u8])[_44];\n        _42 = Ge(move _43, 160_u8);\n        switchInt(move _42) -> [0: bb30, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &_2;\n        _51 = (move _52);\n        StorageDead(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _62 = (_51.0: &usize);\n        _54 = fmt::rt::Argument::<'_>::new_display::<usize>(_62) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _53 = [move _54];\n        StorageDead(_54);\n        StorageLive(_55);\n        _55 = b\"\\x0bbyte index \\xc0\\\" lies between surrogate codepoints\\x00\";\n        _56 = &_53;\n        _50 = fmt::Arguments::<'_>::new::<49, 1>(move _55, _56) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_55);\n        _49 = panicking::panic_fmt(move _50) -> unwind unreachable;\n    }\n    bb30: {\n        StorageDead(_44);\n        StorageDead(_43);\n        goto -> bb33;\n    }\n    bb31: {\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb33;\n    }\n    bb32: {\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_42);\n        StorageDead(_35);\n        goto -> bb35;\n    }\n    bb34: {\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_28);\n        goto -> bb37;\n    }\n    bb36: {\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb37: {\n        return;\n    }\n}\n",
  "doc": " Verify that `index` is at the edge of either a valid UTF-8 codepoint\n (i.e. a codepoint that's not a surrogate) or of the whole string.\n\n These are the cases currently permitted by `OsStr::self_encoded_bytes`.\n Splitting between surrogates is valid as far as WTF-8 is concerned, but\n we do not permit it in the public API because WTF-8 is considered an\n implementation detail.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}