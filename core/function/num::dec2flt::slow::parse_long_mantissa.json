{
  "name": "num::dec2flt::slow::parse_long_mantissa",
  "safe": true,
  "callees": {
    "num::dec2flt::common::BiasedFp::zero_pow2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Represent `0 ^ p`\n",
      "adt": {
        "num::dec2flt::common::BiasedFp": "Constructor"
      }
    },
    "num::dec2flt::decimal_seq::parse_decimal_seq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Parse a big integer representation of the float as a decimal.\n",
      "adt": {
        "num::dec2flt::decimal_seq::DecimalSeq": "Constructor"
      }
    },
    "ops::function::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "num::dec2flt::decimal_seq::DecimalSeq::right_shift": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes decimal * 2^-shift.\n",
      "adt": {
        "num::dec2flt::decimal_seq::DecimalSeq": "MutableAsArgument"
      }
    },
    "num::dec2flt::decimal_seq::DecimalSeq::left_shift": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes decimal * 2^shift.\n",
      "adt": {
        "num::dec2flt::decimal_seq::DecimalSeq": "MutableAsArgument"
      }
    },
    "num::dec2flt::decimal_seq::DecimalSeq::round": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "num::dec2flt::decimal_seq::DecimalSeq": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "num::dec2flt::common::BiasedFp": [
      "Plain"
    ],
    "num::dec2flt::decimal_seq::DecimalSeq": [
      "Plain",
      "Unknown([Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 19, kind: RigidTy(Int(I32)) })])",
      "MutRef",
      "Unknown([Field(3, Ty { id: 505, kind: RigidTy(Array(Ty { id: 46, kind: RigidTy(Uint(U8)) }, TyConst { kind: Value(Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(0), Some(3), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(4, ThreadLocalIndex) })) }), Index(31)])",
      "Ref"
    ]
  },
  "path": 14798,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:26:1: 109:2",
  "src": "pub(crate) fn parse_long_mantissa<F: RawFloat>(s: &[u8]) -> BiasedFp {\n    const MAX_SHIFT: usize = 60;\n    const NUM_POWERS: usize = 19;\n    const POWERS: [u8; 19] =\n        [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59];\n\n    let get_shift = |n| {\n        if n < NUM_POWERS { POWERS[n] as usize } else { MAX_SHIFT }\n    };\n\n    let fp_zero = BiasedFp::zero_pow2(0);\n    let fp_inf = BiasedFp::zero_pow2(F::INFINITE_POWER);\n\n    let mut d = parse_decimal_seq(s);\n\n    // Short-circuit if the value can only be a literal 0 or infinity.\n    if d.num_digits == 0 || d.decimal_point < -324 {\n        return fp_zero;\n    } else if d.decimal_point >= 310 {\n        return fp_inf;\n    }\n    let mut exp2 = 0_i32;\n    // Shift right toward (1/2 ... 1].\n    while d.decimal_point > 0 {\n        let n = d.decimal_point as usize;\n        let shift = get_shift(n);\n        d.right_shift(shift);\n        if d.decimal_point < -DecimalSeq::DECIMAL_POINT_RANGE {\n            return fp_zero;\n        }\n        exp2 += shift as i32;\n    }\n    // Shift left toward (1/2 ... 1].\n    while d.decimal_point <= 0 {\n        let shift = if d.decimal_point == 0 {\n            match d.digits[0] {\n                digit if digit >= 5 => break,\n                0 | 1 => 2,\n                _ => 1,\n            }\n        } else {\n            get_shift((-d.decimal_point) as _)\n        };\n        d.left_shift(shift);\n        if d.decimal_point > DecimalSeq::DECIMAL_POINT_RANGE {\n            return fp_inf;\n        }\n        exp2 -= shift as i32;\n    }\n    // We are now in the range [1/2 ... 1] but the binary format uses [1 ... 2].\n    exp2 -= 1;\n    while F::EXP_MIN > exp2 {\n        let mut n = (F::EXP_MIN - exp2) as usize;\n        if n > MAX_SHIFT {\n            n = MAX_SHIFT;\n        }\n        d.right_shift(n);\n        exp2 += n as i32;\n    }\n    if (exp2 - F::EXP_MIN + 1) >= F::INFINITE_POWER {\n        return fp_inf;\n    }\n    // Shift the decimal to the hidden bit, and then round the value\n    // to get the high mantissa+1 bits.\n    d.left_shift(F::SIG_BITS as usize + 1);\n    let mut mantissa = d.round();\n    if mantissa >= (1_u64 << (F::SIG_BITS + 1)) {\n        // Rounding up overflowed to the carry bit, need to\n        // shift back to the hidden bit.\n        d.right_shift(1);\n        exp2 += 1;\n        mantissa = d.round();\n        if (exp2 - F::EXP_MIN + 1) >= F::INFINITE_POWER {\n            return fp_inf;\n        }\n    }\n    let mut power2 = exp2 - F::EXP_MIN + 1;\n    if mantissa < (1_u64 << F::SIG_BITS) {\n        power2 -= 1;\n    }\n    // Zero out all the bits above the explicit mantissa bits.\n    mantissa &= (1_u64 << F::SIG_BITS) - 1;\n    BiasedFp { m: mantissa, p_biased: power2 }\n}",
  "mir": "fn num::dec2flt::slow::parse_long_mantissa(_1: &[u8]) -> num::dec2flt::common::BiasedFp {\n    let mut _0: num::dec2flt::common::BiasedFp;\n    let  _2: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:32:21: 32:24};\n    let  _3: num::dec2flt::common::BiasedFp;\n    let  _4: num::dec2flt::common::BiasedFp;\n    let mut _5: num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _6: usize;\n    let mut _7: bool;\n    let mut _8: i32;\n    let mut _9: bool;\n    let mut _10: i32;\n    let mut _11: i32;\n    let mut _12: bool;\n    let mut _13: i32;\n    let  _14: usize;\n    let mut _15: i32;\n    let  _16: usize;\n    let mut _17: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:32:21: 32:24};\n    let mut _18: (usize,);\n    let  _19: ();\n    let mut _20: &mut num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _21: bool;\n    let mut _22: i32;\n    let mut _23: i32;\n    let mut _24: bool;\n    let mut _25: i32;\n    let mut _26: (i32, bool);\n    let mut _27: bool;\n    let mut _28: i32;\n    let  _29: usize;\n    let mut _30: i32;\n    let  _31: usize;\n    let mut _32: bool;\n    let  _33: u8;\n    let  _34: &u8;\n    let mut _35: bool;\n    let mut _36: u8;\n    let mut _37: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:32:21: 32:24};\n    let mut _38: (usize,);\n    let mut _39: usize;\n    let mut _40: i32;\n    let mut _41: i32;\n    let mut _42: bool;\n    let  _43: ();\n    let mut _44: &mut num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _45: usize;\n    let mut _46: bool;\n    let mut _47: i32;\n    let mut _48: i32;\n    let mut _49: usize;\n    let mut _50: (i32, bool);\n    let mut _51: (i32, bool);\n    let mut _52: bool;\n    let mut _53: i32;\n    let mut _54: usize;\n    let mut _55: i32;\n    let mut _56: i32;\n    let mut _57: (i32, bool);\n    let mut _58: bool;\n    let mut _59: usize;\n    let  _60: ();\n    let mut _61: &mut num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _62: usize;\n    let mut _63: i32;\n    let mut _64: usize;\n    let mut _65: (i32, bool);\n    let mut _66: bool;\n    let mut _67: i32;\n    let mut _68: i32;\n    let mut _69: i32;\n    let mut _70: (i32, bool);\n    let mut _71: (i32, bool);\n    let  _72: ();\n    let mut _73: &mut num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _74: usize;\n    let mut _75: usize;\n    let mut _76: (usize, bool);\n    let mut _77: u64;\n    let mut _78: &num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _79: bool;\n    let mut _80: u64;\n    let mut _81: u64;\n    let mut _82: u32;\n    let mut _83: (u32, bool);\n    let mut _84: bool;\n    let  _85: ();\n    let mut _86: &mut num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _87: (i32, bool);\n    let mut _88: u64;\n    let mut _89: &num::dec2flt::decimal_seq::DecimalSeq;\n    let mut _90: bool;\n    let mut _91: i32;\n    let mut _92: i32;\n    let mut _93: i32;\n    let mut _94: (i32, bool);\n    let mut _95: (i32, bool);\n    let mut _96: i32;\n    let mut _97: i32;\n    let mut _98: i32;\n    let mut _99: (i32, bool);\n    let mut _100: (i32, bool);\n    let mut _101: bool;\n    let mut _102: u64;\n    let mut _103: u64;\n    let mut _104: bool;\n    let mut _105: (i32, bool);\n    let mut _106: u64;\n    let mut _107: u64;\n    let mut _108: bool;\n    let mut _109: (u64, bool);\n    let mut _110: u64;\n    let mut _111: i32;\n    debug s => _1;\n    debug get_shift => ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:32:21: 32:24};\n    debug fp_zero => _3;\n    debug fp_inf => _4;\n    debug d => _5;\n    debug exp2 => _11;\n    debug n => _14;\n    debug shift => _16;\n    debug shift => _29;\n    debug digit => _33;\n    debug digit => _34;\n    debug n => _54;\n    debug mantissa => _77;\n    debug power2 => _96;\n    bb0: {\n        StorageLive(_3);\n        _3 = num::dec2flt::common::BiasedFp::zero_pow2(0_i32) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = num::dec2flt::common::BiasedFp::zero_pow2(<F as num::dec2flt::float::RawFloat>::INFINITE_POWER) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = num::dec2flt::decimal_seq::parse_decimal_seq(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_6);\n        _6 = (_5.0: usize);\n        switchInt(move _6) -> [0: bb4, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = (_5.1: i32);\n        _7 = Lt(move _8, -324_i32);\n        switchInt(move _7) -> [0: bb8, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_8);\n        goto -> bb7;\n    }\n    bb7: {\n        _0 = _3;\n        goto -> bb78;\n    }\n    bb8: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (_5.1: i32);\n        _9 = Ge(move _10, 310_i32);\n        switchInt(move _9) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_10);\n        _0 = _4;\n        StorageDead(_9);\n        goto -> bb78;\n    }\n    bb10: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageLive(_11);\n        _11 = 0_i32;\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (_5.1: i32);\n        _12 = Gt(move _13, 0_i32);\n        switchInt(move _12) -> [0: bb19, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = (_5.1: i32);\n        _14 = move _15 as usize;\n        StorageDead(_15);\n        StorageLive(_17);\n        _17 = &_2;\n        StorageLive(_18);\n        _18 = (_14);\n        _16 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:32:21: 32:24} as ops::function::Fn<(usize,)>>::call(move _17, move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_20);\n        _20 = &mut _5;\n        _19 = num::dec2flt::decimal_seq::DecimalSeq::right_shift(move _20, _16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = (_5.1: i32);\n        StorageLive(_23);\n        _24 = Eq(num::dec2flt::decimal_seq::DecimalSeq::DECIMAL_POINT_RANGE, i32::MIN);\n        assert(!move _24, \"attempt to negate `{}`, which would overflow\", num::dec2flt::decimal_seq::DecimalSeq::DECIMAL_POINT_RANGE) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _23 = Neg(num::dec2flt::decimal_seq::DecimalSeq::DECIMAL_POINT_RANGE);\n        _21 = Lt(move _22, move _23);\n        switchInt(move _21) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageDead(_22);\n        _0 = _3;\n        StorageDead(_21);\n        StorageDead(_12);\n        goto -> bb77;\n    }\n    bb17: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_25);\n        _25 = _16 as i32;\n        _26 = CheckedAdd(_11, _25);\n        assert(!move (_26.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _11, move _25) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _11 = move (_26.0: i32);\n        StorageDead(_25);\n        StorageDead(_12);\n        goto -> bb11;\n    }\n    bb19: {\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = (_5.1: i32);\n        _27 = Le(move _28, 0_i32);\n        switchInt(move _27) -> [0: bb37, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = (_5.1: i32);\n        switchInt(move _30) -> [0: bb22, otherwise: bb29];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageLive(_31);\n        _31 = 0_usize;\n        _32 = Lt(_31, 768_usize);\n        assert(move _32, \"index out of bounds: the length is {} but the index is {}\", 768_usize, _31) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_34);\n        _34 = &(_5.3: [u8; 768])[_31];\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = (*_34);\n        _35 = Ge(move _36, 5_u8);\n        switchInt(move _35) -> [0: bb27, otherwise: bb26];\n    }\n    bb24: {\n        _29 = 1_usize;\n        goto -> bb28;\n    }\n    bb25: {\n        _29 = 2_usize;\n        goto -> bb28;\n    }\n    bb26: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_33);\n        _33 = (_5.3: [u8; 768])[_31];\n        StorageDead(_33);\n        StorageDead(_34);\n        StorageDead(_31);\n        StorageDead(_29);\n        goto -> bb38;\n    }\n    bb27: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        switchInt((_5.3: [u8; 768])[_31]) -> [0: bb25, 1: bb25, otherwise: bb24];\n    }\n    bb28: {\n        StorageDead(_31);\n        goto -> bb32;\n    }\n    bb29: {\n        StorageDead(_30);\n        StorageLive(_37);\n        _37 = &_2;\n        StorageLive(_38);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = (_5.1: i32);\n        _42 = Eq(_41, i32::MIN);\n        assert(!move _42, \"attempt to negate `{}`, which would overflow\", _41) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _40 = Neg(move _41);\n        StorageDead(_41);\n        _39 = move _40 as usize;\n        StorageDead(_40);\n        _38 = (_39);\n        _29 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/slow.rs:32:21: 32:24} as ops::function::Fn<(usize,)>>::call(move _37, move _38) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageLive(_44);\n        _44 = &mut _5;\n        StorageLive(_45);\n        _45 = _29;\n        _43 = num::dec2flt::decimal_seq::DecimalSeq::left_shift(move _44, move _45) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_45);\n        StorageDead(_44);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = (_5.1: i32);\n        _46 = Gt(move _47, num::dec2flt::decimal_seq::DecimalSeq::DECIMAL_POINT_RANGE);\n        switchInt(move _46) -> [0: bb35, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_47);\n        _0 = _4;\n        StorageDead(_46);\n        StorageDead(_29);\n        StorageDead(_27);\n        goto -> bb77;\n    }\n    bb35: {\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = _29;\n        _48 = move _49 as i32;\n        StorageDead(_49);\n        _50 = CheckedSub(_11, _48);\n        assert(!move (_50.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _11, move _48) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _11 = move (_50.0: i32);\n        StorageDead(_48);\n        StorageDead(_29);\n        StorageDead(_27);\n        goto -> bb20;\n    }\n    bb37: {\n        StorageDead(_28);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_27);\n        _51 = CheckedSub(_11, 1_i32);\n        assert(!move (_51.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _11, 1_i32) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _11 = move (_51.0: i32);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = _11;\n        _52 = Gt(<F as num::dec2flt::float::RawFloat>::EXP_MIN, move _53);\n        switchInt(move _52) -> [0: bb48, otherwise: bb41];\n    }\n    bb41: {\n        StorageDead(_53);\n        StorageLive(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = _11;\n        _57 = CheckedSub(<F as num::dec2flt::float::RawFloat>::EXP_MIN, _56);\n        assert(!move (_57.1: bool), \"attempt to compute `{} - {}`, which would overflow\", <F as num::dec2flt::float::RawFloat>::EXP_MIN, move _56) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _55 = move (_57.0: i32);\n        StorageDead(_56);\n        _54 = move _55 as usize;\n        StorageDead(_55);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = _54;\n        _58 = Gt(move _59, num::dec2flt::slow::parse_long_mantissa::MAX_SHIFT);\n        switchInt(move _58) -> [0: bb44, otherwise: bb43];\n    }\n    bb43: {\n        StorageDead(_59);\n        _54 = num::dec2flt::slow::parse_long_mantissa::MAX_SHIFT;\n        goto -> bb45;\n    }\n    bb44: {\n        StorageDead(_59);\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_58);\n        StorageLive(_61);\n        _61 = &mut _5;\n        StorageLive(_62);\n        _62 = _54;\n        _60 = num::dec2flt::decimal_seq::DecimalSeq::right_shift(move _61, move _62) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_62);\n        StorageDead(_61);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _54;\n        _63 = move _64 as i32;\n        StorageDead(_64);\n        _65 = CheckedAdd(_11, _63);\n        assert(!move (_65.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _11, move _63) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _11 = move (_65.0: i32);\n        StorageDead(_63);\n        StorageDead(_54);\n        StorageDead(_52);\n        goto -> bb40;\n    }\n    bb48: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageLive(_66);\n        StorageLive(_67);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = _11;\n        _70 = CheckedSub(_69, <F as num::dec2flt::float::RawFloat>::EXP_MIN);\n        assert(!move (_70.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _69, <F as num::dec2flt::float::RawFloat>::EXP_MIN) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _68 = move (_70.0: i32);\n        StorageDead(_69);\n        _71 = CheckedAdd(_68, 1_i32);\n        assert(!move (_71.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _68, 1_i32) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _67 = move (_71.0: i32);\n        StorageDead(_68);\n        _66 = Ge(move _67, <F as num::dec2flt::float::RawFloat>::INFINITE_POWER);\n        switchInt(move _66) -> [0: bb52, otherwise: bb51];\n    }\n    bb51: {\n        StorageDead(_67);\n        _0 = _4;\n        StorageDead(_66);\n        goto -> bb77;\n    }\n    bb52: {\n        StorageDead(_67);\n        StorageDead(_66);\n        StorageLive(_73);\n        _73 = &mut _5;\n        StorageLive(_74);\n        StorageLive(_75);\n        _75 = <F as num::dec2flt::float::RawFloat>::SIG_BITS as usize;\n        _76 = CheckedAdd(_75, 1_usize);\n        assert(!move (_76.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _75, 1_usize) -> [success: bb53, unwind unreachable];\n    }\n    bb53: {\n        _74 = move (_76.0: usize);\n        StorageDead(_75);\n        _72 = num::dec2flt::decimal_seq::DecimalSeq::left_shift(move _73, move _74) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = &_5;\n        _77 = num::dec2flt::decimal_seq::DecimalSeq::round(move _78) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_78);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = _77;\n        StorageLive(_81);\n        StorageLive(_82);\n        _83 = CheckedAdd(<F as num::dec2flt::float::RawFloat>::SIG_BITS, 1_u32);\n        assert(!move (_83.1: bool), \"attempt to compute `{} + {}`, which would overflow\", <F as num::dec2flt::float::RawFloat>::SIG_BITS, 1_u32) -> [success: bb56, unwind unreachable];\n    }\n    bb56: {\n        _82 = move (_83.0: u32);\n        _84 = Lt(_82, 64_u32);\n        assert(move _84, \"attempt to shift left by `{}`, which would overflow\", _82) -> [success: bb57, unwind unreachable];\n    }\n    bb57: {\n        _81 = Shl(1_u64, move _82);\n        StorageDead(_82);\n        _79 = Ge(move _80, move _81);\n        switchInt(move _79) -> [0: bb66, otherwise: bb58];\n    }\n    bb58: {\n        StorageDead(_81);\n        StorageDead(_80);\n        StorageLive(_86);\n        _86 = &mut _5;\n        _85 = num::dec2flt::decimal_seq::DecimalSeq::right_shift(move _86, 1_usize) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_86);\n        _87 = CheckedAdd(_11, 1_i32);\n        assert(!move (_87.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _11, 1_i32) -> [success: bb60, unwind unreachable];\n    }\n    bb60: {\n        _11 = move (_87.0: i32);\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = &_5;\n        _88 = num::dec2flt::decimal_seq::DecimalSeq::round(move _89) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_89);\n        _77 = move _88;\n        StorageDead(_88);\n        StorageLive(_90);\n        StorageLive(_91);\n        StorageLive(_92);\n        StorageLive(_93);\n        _93 = _11;\n        _94 = CheckedSub(_93, <F as num::dec2flt::float::RawFloat>::EXP_MIN);\n        assert(!move (_94.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _93, <F as num::dec2flt::float::RawFloat>::EXP_MIN) -> [success: bb62, unwind unreachable];\n    }\n    bb62: {\n        _92 = move (_94.0: i32);\n        StorageDead(_93);\n        _95 = CheckedAdd(_92, 1_i32);\n        assert(!move (_95.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _92, 1_i32) -> [success: bb63, unwind unreachable];\n    }\n    bb63: {\n        _91 = move (_95.0: i32);\n        StorageDead(_92);\n        _90 = Ge(move _91, <F as num::dec2flt::float::RawFloat>::INFINITE_POWER);\n        switchInt(move _90) -> [0: bb65, otherwise: bb64];\n    }\n    bb64: {\n        StorageDead(_91);\n        _0 = _4;\n        StorageDead(_90);\n        StorageDead(_79);\n        StorageDead(_77);\n        goto -> bb77;\n    }\n    bb65: {\n        StorageDead(_91);\n        StorageDead(_90);\n        goto -> bb67;\n    }\n    bb66: {\n        StorageDead(_81);\n        StorageDead(_80);\n        goto -> bb67;\n    }\n    bb67: {\n        StorageDead(_79);\n        StorageLive(_96);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = _11;\n        _99 = CheckedSub(_98, <F as num::dec2flt::float::RawFloat>::EXP_MIN);\n        assert(!move (_99.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _98, <F as num::dec2flt::float::RawFloat>::EXP_MIN) -> [success: bb68, unwind unreachable];\n    }\n    bb68: {\n        _97 = move (_99.0: i32);\n        StorageDead(_98);\n        _100 = CheckedAdd(_97, 1_i32);\n        assert(!move (_100.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _97, 1_i32) -> [success: bb69, unwind unreachable];\n    }\n    bb69: {\n        _96 = move (_100.0: i32);\n        StorageDead(_97);\n        StorageLive(_101);\n        StorageLive(_102);\n        _102 = _77;\n        StorageLive(_103);\n        _104 = Lt(<F as num::dec2flt::float::RawFloat>::SIG_BITS, 64_u32);\n        assert(move _104, \"attempt to shift left by `{}`, which would overflow\", <F as num::dec2flt::float::RawFloat>::SIG_BITS) -> [success: bb70, unwind unreachable];\n    }\n    bb70: {\n        _103 = Shl(1_u64, <F as num::dec2flt::float::RawFloat>::SIG_BITS);\n        _101 = Lt(move _102, move _103);\n        switchInt(move _101) -> [0: bb73, otherwise: bb71];\n    }\n    bb71: {\n        StorageDead(_103);\n        StorageDead(_102);\n        _105 = CheckedSub(_96, 1_i32);\n        assert(!move (_105.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _96, 1_i32) -> [success: bb72, unwind unreachable];\n    }\n    bb72: {\n        _96 = move (_105.0: i32);\n        goto -> bb74;\n    }\n    bb73: {\n        StorageDead(_103);\n        StorageDead(_102);\n        goto -> bb74;\n    }\n    bb74: {\n        StorageDead(_101);\n        StorageLive(_106);\n        StorageLive(_107);\n        _108 = Lt(<F as num::dec2flt::float::RawFloat>::SIG_BITS, 64_u32);\n        assert(move _108, \"attempt to shift left by `{}`, which would overflow\", <F as num::dec2flt::float::RawFloat>::SIG_BITS) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _107 = Shl(1_u64, <F as num::dec2flt::float::RawFloat>::SIG_BITS);\n        _109 = CheckedSub(_107, 1_u64);\n        assert(!move (_109.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _107, 1_u64) -> [success: bb76, unwind unreachable];\n    }\n    bb76: {\n        _106 = move (_109.0: u64);\n        StorageDead(_107);\n        _77 = BitAnd(_77, move _106);\n        StorageDead(_106);\n        StorageLive(_110);\n        _110 = _77;\n        StorageLive(_111);\n        _111 = _96;\n        _0 = BiasedFp(move _110, move _111);\n        StorageDead(_111);\n        StorageDead(_110);\n        StorageDead(_96);\n        StorageDead(_77);\n        StorageDead(_11);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb80;\n    }\n    bb77: {\n        StorageDead(_11);\n        goto -> bb79;\n    }\n    bb78: {\n        StorageDead(_7);\n        goto -> bb79;\n    }\n    bb79: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb80;\n    }\n    bb80: {\n        return;\n    }\n}\n",
  "doc": " Parse the significant digits and biased, binary exponent of a float.\n\n This is a fallback algorithm that uses a big-integer representation\n of the float, and therefore is considerably slower than faster\n approximations. However, it will always determine how to round\n the significant digits to the nearest machine float, allowing\n use to handle near half-way cases.\n\n Near half-way cases are halfway between two consecutive machine floats.\n For example, the float `16777217.0` has a bitwise representation of\n `100000000000000000000000 1`. Rounding to a single-precision float,\n the trailing `1` is truncated. Using round-nearest, tie-even, any\n value above `16777217.0` must be rounded up to `16777218.0`, while\n any value before or equal to `16777217.0` must be rounded down\n to `16777216.0`. These near-halfway conversions therefore may require\n a large number of digits to unambiguously determine how to round.\n\n The algorithms described here are based on \"Processing Long Numbers Quickly\",\n available here: <https://arxiv.org/pdf/2101.11408.pdf#section.11>.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}