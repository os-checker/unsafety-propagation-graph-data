{
  "name": "<&mut W as fmt::Write::write_fmt::SpecWriteFmt>::spec_write_fmt",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::as_statically_known_str": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Same as [`Arguments::as_str`], but will only return `Some(s)` if it can be determined at compile time.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "fmt::Write::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a string slice into this writer, returning whether the write\n succeeded.\n\n This method can only succeed if the entire string slice was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`std::fmt::Error`][Error] on error.\n\n The purpose of that error is to abort the formatting operation when the underlying\n destination encounters some error preventing it from accepting more text;\n in particular, it does not communicate any information about *what* error occurred.\n It should generally be propagated rather than handled, at least when implementing\n formatting traits.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n     f.write_str(s)\n }\n\n let mut buf = String::new();\n writer(&mut buf, \"hola\")?;\n assert_eq!(&buf, \"hola\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "fmt::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes an output stream and an `Arguments` struct that can be precompiled with\n the `format_args!` macro.\n\n The arguments will be formatted according to the specified format string\n into the output stream provided.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::fmt;\n\n let mut output = String::new();\n fmt::write(&mut output, format_args!(\"Hello {}!\", \"world\"))\n     .expect(\"Error occurred while trying to write in String\");\n assert_eq!(output, \"Hello world!\");\n ```\n\n Please note that using [`write!`] might be preferable. Example:\n\n ```\n use std::fmt::Write;\n\n let mut output = String::new();\n write!(&mut output, \"Hello {}!\", \"world\")\n     .expect(\"Error occurred while trying to write in String\");\n assert_eq!(output, \"Hello world!\");\n ```\n\n [`write!`]: crate::write!\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Ref",
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 81, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 84, kind: RigidTy(Str) }, Not)) })])"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": 310,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs:232:13: 238:14",
  "src": "fn spec_write_fmt(self, args: Arguments<'_>) -> Result {\n                if let Some(s) = args.as_statically_known_str() {\n                    self.write_str(s)\n                } else {\n                    write(self, args)\n                }\n            }",
  "mir": "fn <&mut W as fmt::Write::write_fmt::SpecWriteFmt>::spec_write_fmt(_1: &mut W, _2: fmt::Arguments<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: option::Option<&str>;\n    let mut _4: &fmt::Arguments<'_>;\n    let mut _5: isize;\n    let  _6: &str;\n    let mut _7: &mut dyn fmt::Write;\n    debug self => _1;\n    debug args => _2;\n    debug s => _6;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_2;\n        _3 = fmt::Arguments::<'_>::as_statically_known_str(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [1: bb2, 0: bb4, otherwise: bb7];\n    }\n    bb2: {\n        _6 = ((_3 as variant#1).0: &str);\n        _0 = <W as fmt::Write>::write_str(_1, _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        goto -> bb6;\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_7);\n        _7 = _1 as &mut dyn fmt::Write;\n        _0 = fmt::write(move _7, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        goto -> bb6;\n    }\n    bb6: {\n        return;\n    }\n    bb7: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}