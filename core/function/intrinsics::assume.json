{
  "name": "intrinsics::assume",
  "safe": false,
  "callees": {},
  "adts": {},
  "path": 13361,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:397:1: 402:2",
  "src": "pub const unsafe fn assume(b: bool) {\n    if !b {\n        // SAFETY: the caller must guarantee the argument is never `false`\n        unsafe { unreachable() }\n    }\n}",
  "mir": "fn intrinsics::assume(_1: bool) -> () {\n    let mut _0: ();\n    debug b => _1;\n    bb0: {\n        switchInt(_1) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Informs the optimizer that a condition is always true.\n If the condition is false, the behavior is undefined.\n\n No code is generated for this intrinsic, but the optimizer will try\n to preserve it (and its condition) between passes, which may interfere\n with optimization of surrounding code and reduce performance. It should\n not be used if the invariant can be discovered by the optimizer on its\n own, or if it does not enable any significant optimizations.\n\n The stabilized version of this intrinsic is [`core::hint::assert_unchecked`].\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}