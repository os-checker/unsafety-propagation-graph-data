{
  "name": "mem::discriminant",
  "safe": true,
  "callees": {},
  "adts": {
    "mem::Discriminant": [
      "Plain"
    ]
  },
  "path": 14458,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:1195:1: 1197:2",
  "src": "pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n    Discriminant(intrinsics::discriminant_value(v))\n}",
  "mir": "fn mem::discriminant(_1: &T) -> mem::Discriminant<T> {\n    let mut _0: mem::Discriminant<T>;\n    let mut _2: <T as marker::DiscriminantKind>::Discriminant;\n    debug v => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = discriminant((*_1));\n        _0 = Discriminant(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a value uniquely identifying the enum variant in `v`.\n\n If `T` is not an enum, calling this function will not result in undefined behavior, but the\n return value is unspecified.\n\n # Stability\n\n The discriminant of an enum variant may change if the enum definition changes. A discriminant\n of some variant will not change between compilations with the same compiler. See the [Reference]\n for more information.\n\n [Reference]: ../../reference/items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations\n\n The value of a [`Discriminant<T>`] is independent of any *free lifetimes* in `T`. As such,\n reading or writing a `Discriminant<Foo<'a>>` as a `Discriminant<Foo<'b>>` (whether via\n [`transmute`] or otherwise) is always sound. Note that this is **not** true for other kinds\n of generic parameters and for higher-ranked lifetimes; `Discriminant<Foo<A>>` and\n `Discriminant<Foo<B>>` as well as `Discriminant<Bar<dyn for<'a> Trait<'a>>>` and\n `Discriminant<Bar<dyn Trait<'static>>>` may be incompatible.\n\n # Examples\n\n This can be used to compare enums that carry data, while disregarding\n the actual data:\n\n ```\n use std::mem;\n\n enum Foo { A(&'static str), B(i32), C(i32) }\n\n assert_eq!(mem::discriminant(&Foo::A(\"bar\")), mem::discriminant(&Foo::A(\"baz\")));\n assert_eq!(mem::discriminant(&Foo::B(1)), mem::discriminant(&Foo::B(2)));\n assert_ne!(mem::discriminant(&Foo::B(3)), mem::discriminant(&Foo::C(3)));\n ```\n\n ## Accessing the numeric value of the discriminant\n\n Note that it is *undefined behavior* to [`transmute`] from [`Discriminant`] to a primitive!\n\n If an enum has only unit variants, then the numeric value of the discriminant can be accessed\n with an [`as`] cast:\n\n ```\n enum Enum {\n     Foo,\n     Bar,\n     Baz,\n }\n\n assert_eq!(0, Enum::Foo as isize);\n assert_eq!(1, Enum::Bar as isize);\n assert_eq!(2, Enum::Baz as isize);\n ```\n\n If an enum has opted-in to having a [primitive representation] for its discriminant,\n then it's possible to use pointers to read the memory location storing the discriminant.\n That **cannot** be done for enums using the [default representation], however, as it's\n undefined what layout the discriminant has and where it's stored — it might not even be\n stored at all!\n\n [`as`]: ../../std/keyword.as.html\n [primitive representation]: ../../reference/type-layout.html#primitive-representations\n [default representation]: ../../reference/type-layout.html#the-default-representation\n ```\n #[repr(u8)]\n enum Enum {\n     Unit,\n     Tuple(bool),\n     Struct { a: bool },\n }\n\n impl Enum {\n     fn discriminant(&self) -> u8 {\n         // SAFETY: Because `Self` is marked `repr(u8)`, its layout is a `repr(C)` `union`\n         // between `repr(C)` structs, each of which has the `u8` discriminant as its first\n         // field, so we can read the discriminant without offsetting the pointer.\n         unsafe { *<*const _>::from(self).cast::<u8>() }\n     }\n }\n\n let unit_like = Enum::Unit;\n let tuple_like = Enum::Tuple(true);\n let struct_like = Enum::Struct { a: false };\n assert_eq!(0, unit_like.discriminant());\n assert_eq!(1, tuple_like.discriminant());\n assert_eq!(2, struct_like.discriminant());\n\n // ⚠️ This is undefined behavior. Don't do this. ⚠️\n // assert_eq!(0, unsafe { std::mem::transmute::<_, u8>(std::mem::discriminant(&unit_like)) });\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}