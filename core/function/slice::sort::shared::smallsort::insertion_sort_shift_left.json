{
  "name": "slice::sort::shared::smallsort::insertion_sort_shift_left",
  "safe": true,
  "callees": {
    "intrinsics::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the execution of the process.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n as its behavior is more user-friendly and more stable.\n\n The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n on most platforms.\n On Unix, the\n process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n `SIGBUS`.  The precise behavior is not guaranteed and not stable.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::insert_tail": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts range [begin, tail] assuming [begin, tail) is already sorted.\n\n # Safety\n begin < tail and p must be valid and initialized for all begin <= p <= tail.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 16671,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:580:1: 608:2",
  "src": "pub fn insertion_sort_shift_left<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    offset: usize,\n    is_less: &mut F,\n) {\n    let len = v.len();\n    if offset == 0 || offset > len {\n        intrinsics::abort();\n    }\n\n    // SAFETY: see individual comments.\n    unsafe {\n        // We write this basic loop directly using pointers, as when we use a\n        // for loop LLVM likes to unroll this loop which we do not want.\n        // SAFETY: v_end is the one-past-end pointer, and we checked that\n        // offset <= len, thus tail is also in-bounds.\n        let v_base = v.as_mut_ptr();\n        let v_end = v_base.add(len);\n        let mut tail = v_base.add(offset);\n        while tail != v_end {\n            // SAFETY: v_base and tail are both valid pointers to elements, and\n            // v_base < tail since we checked offset != 0.\n            insert_tail(v_base, tail, is_less);\n\n            // SAFETY: we checked that tail is not yet the one-past-end pointer.\n            tail = tail.add(1);\n        }\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::insertion_sort_shift_left(_1: &mut [T], _2: usize, _3: &mut F) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let mut _5: &[T];\n    let mut _6: bool;\n    let  _7: !;\n    let  _8: *mut T;\n    let  _9: *mut T;\n    let mut _10: *mut T;\n    let mut _11: bool;\n    let mut _12: *mut T;\n    let  _13: ();\n    let mut _14: *mut T;\n    let mut _15: *mut T;\n    let mut _16: *mut T;\n    debug v => _1;\n    debug offset => _2;\n    debug is_less => _3;\n    debug len => _4;\n    debug v_base => _8;\n    debug v_end => _9;\n    debug tail => _10;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        switchInt(_2) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        goto -> bb4;\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = Gt(_2, _4);\n        switchInt(move _6) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        _7 = intrinsics::abort() -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_6);\n        _8 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = ptr::mut_ptr::<impl *mut T>::add(_8, _4) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_10);\n        _10 = ptr::mut_ptr::<impl *mut T>::add(_8, _2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _10;\n        _11 = Ne(move _12, _9);\n        switchInt(move _11) -> [0: bb13, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_12);\n        StorageLive(_14);\n        _14 = _10;\n        _13 = slice::sort::shared::smallsort::insert_tail::<T, F>(_8, move _14, _3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _10;\n        _15 = ptr::mut_ptr::<impl *mut T>::add(move _16, 1_usize) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        _10 = move _15;\n        StorageDead(_15);\n        StorageDead(_11);\n        goto -> bb9;\n    }\n    bb13: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        return;\n    }\n}\n",
  "doc": " Sort `v` assuming `v[..offset]` is already sorted.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}