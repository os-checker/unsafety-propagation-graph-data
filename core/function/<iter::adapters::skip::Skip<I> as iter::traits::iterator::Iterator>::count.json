{
  "name": "<iter::adapters::skip::Skip<I> as iter::traits::iterator::Iterator>::count",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::nth": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element of the iterator.\n\n Like most indexing operations, the count starts from zero, so `nth(0)`\n returns the first value, `nth(1)` the second, and so on.\n\n Note that all preceding elements, as well as the returned element, will be\n consumed from the iterator. That means that the preceding elements will be\n discarded, and also that calling `nth(0)` multiple times on the same iterator\n will return different elements.\n\n `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(1), Some(2));\n ```\n\n Calling `nth()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.nth(1), Some(2));\n assert_eq!(iter.nth(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(10), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {
        "option::Option": "ImmutableAsArgument"
      }
    },
    "iter::traits::iterator::Iterator::count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the iterator, counting the number of iterations and returning it.\n\n This method will call [`next`] repeatedly until [`None`] is encountered,\n returning the number of times it saw [`Some`]. Note that [`next`] has to be\n called at least once even if the iterator does not have any elements.\n\n [`next`]: Iterator::next\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so counting elements of\n an iterator with more than [`usize::MAX`] elements either produces the\n wrong result or panics. If overflow checks are enabled, a panic is\n guaranteed.\n\n # Panics\n\n This function might panic if the iterator has more than [`usize::MAX`]\n elements.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().count(), 3);\n\n let a = [1, 2, 3, 4, 5];\n assert_eq!(a.iter().count(), 5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::skip::Skip": [
      "Unknown([Field(1, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(0, Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })])",
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<iter::adapters::skip::Skip<I> as iter::traits::iterator::Iterator>::count"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/skip.rs:71:5: 79:6",
  "src": "fn count(mut self) -> usize {\n        if self.n > 0 {\n            // nth(n) skips n+1\n            if self.iter.nth(self.n - 1).is_none() {\n                return 0;\n            }\n        }\n        self.iter.count()\n    }",
  "mir": "fn <iter::adapters::skip::Skip<I> as iter::traits::iterator::Iterator>::count(_1: iter::adapters::skip::Skip<I>) -> usize {\n    let mut _0: usize;\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: bool;\n    let mut _5: &option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let  _6: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _7: &mut I;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: (usize, bool);\n    let mut _11: I;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = (_1.1: usize);\n        _2 = Gt(move _3, 0_usize);\n        switchInt(move _2) -> [0: bb9, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut (_1.0: I);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = (_1.1: usize);\n        _10 = CheckedSub(_9, 1_usize);\n        assert(!move (_10.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _9, 1_usize) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = move (_10.0: usize);\n        StorageDead(_9);\n        _6 = <I as iter::traits::iterator::Iterator>::nth(move _7, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = &_6;\n        StorageDead(_8);\n        StorageDead(_7);\n        _4 = option::Option::<<I as iter::traits::iterator::Iterator>::Item>::is_none(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _4) -> [0: bb7, otherwise: bb5];\n    }\n    bb5: {\n        drop(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _0 = 0_usize;\n        StorageDead(_4);\n        StorageDead(_2);\n        drop(_1) -> [return: bb12, unwind unreachable];\n    }\n    bb7: {\n        drop(_6) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_3);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_2);\n        StorageLive(_11);\n        _11 = move (_1.0: I);\n        _0 = <I as iter::traits::iterator::Iterator>::count(move _11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_11);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}