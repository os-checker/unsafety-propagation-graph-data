{
  "name": "<wtf8::Wtf8 as fmt::Display>::fmt",
  "safe": true,
  "callees": {
    "wtf8::Wtf8::next_surrogate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "wtf8::Wtf8": "ImmutableAsArgument",
        "option::Option": "Constructor"
      }
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "str::converts::from_utf8_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string slice without checking\n that the string contains valid UTF-8.\n\n This is an alias to [`str::from_utf8_unchecked`].\n\n See the safe version, [`from_utf8`], for more information.\n\n # Safety\n\n The bytes passed in must be valid UTF-8.\n\n # Examples\n\n Basic usage:\n\n ```\n use std::str;\n\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = unsafe {\n     str::from_utf8_unchecked(&sparkle_heart)\n };\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n ```\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data to the underlying buffer contained within this\n formatter.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_str(\"Foo\")\n         // This is equivalent to:\n         // write!(formatter, \"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo}\"), \"Foo\");\n assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fmt::Write::write_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "fmt::Display::fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n use std::fmt;\n\n struct Position {\n     longitude: f32,\n     latitude: f32,\n }\n\n impl fmt::Display for Position {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"({}, {})\", self.longitude, self.latitude)\n     }\n }\n\n assert_eq!(\n     \"(1.987, 2.983)\",\n     format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "wtf8::Wtf8": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15531, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 136, kind: RigidTy(Uint(U16)) }])) }), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ]
  },
  "path": 17791,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/wtf8.rs:180:5: 200:6",
  "src": "fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let wtf8_bytes = &self.bytes;\n        let mut pos = 0;\n        loop {\n            match self.next_surrogate(pos) {\n                Some((surrogate_pos, _)) => {\n                    // SAFETY: next_surrogate provides an index for a range of valid UTF-8 bytes.\n                    formatter.write_str(unsafe {\n                        str::from_utf8_unchecked(&wtf8_bytes[pos..surrogate_pos])\n                    })?;\n                    formatter.write_char(char::REPLACEMENT_CHARACTER)?;\n                    pos = surrogate_pos + 3;\n                }\n                None => {\n                    // SAFETY: after next_surrogate returns None, the remainder is valid UTF-8.\n                    let s = unsafe { str::from_utf8_unchecked(&wtf8_bytes[pos..]) };\n                    if pos == 0 { return s.fmt(formatter) } else { return formatter.write_str(s) }\n                }\n            }\n        }\n    }",
  "mir": "fn <wtf8::Wtf8 as fmt::Display>::fmt(_1: &wtf8::Wtf8, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let  _3: &[u8];\n    let mut _4: usize;\n    let mut _5: option::Option<(usize, u16)>;\n    let mut _6: usize;\n    let mut _7: isize;\n    let  _8: usize;\n    let mut _9: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _10: result::Result<(), fmt::Error>;\n    let  _11: &str;\n    let  _12: &[u8];\n    let mut _13: ops::range::Range<usize>;\n    let mut _14: usize;\n    let mut _15: isize;\n    let mut _16: ops::control_flow::ControlFlow<result::Result<convert::Infallible, fmt::Error>>;\n    let mut _17: result::Result<(), fmt::Error>;\n    let mut _18: isize;\n    let mut _19: (usize, bool);\n    let  _20: &str;\n    let  _21: &[u8];\n    let mut _22: ops::range::RangeFrom<usize>;\n    let mut _23: usize;\n    let mut _24: usize;\n    debug self => _1;\n    debug formatter => _2;\n    debug wtf8_bytes => _3;\n    debug pos => _4;\n    debug surrogate_pos => _8;\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug residual => result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error);\n    debug val => ();\n    debug s => _20;\n    bb0: {\n        _3 = &((*_1).0: [u8]);\n        StorageLive(_4);\n        _4 = 0_usize;\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = _4;\n        _5 = wtf8::Wtf8::next_surrogate(_1, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = _4;\n        _22 = RangeFrom(move _23);\n        StorageDead(_23);\n        _21 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(_3, move _22) -> [return: bb19, unwind unreachable];\n    }\n    bb5: {\n        _8 = (((_5 as variant#1).0: (usize, u16)).0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _4;\n        _13 = Range(move _14, _8);\n        StorageDead(_14);\n        _12 = <[u8] as ops::index::Index<ops::range::Range<usize>>>::index(_3, move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _11 = str::converts::from_utf8_unchecked(_12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = fmt::Formatter::<'_>::write_str(_2, _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _9 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        _15 = discriminant(_9);\n        switchInt(move _15) -> [0: bb10, 1: bb11, otherwise: bb3];\n    }\n    bb10: {\n        StorageDead(_9);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = <fmt::Formatter<'_> as fmt::Write>::write_char(_2, char::methods::<impl char>::REPLACEMENT_CHARACTER) -> [return: bb13, unwind unreachable];\n    }\n    bb11: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_9);\n        goto -> bb26;\n    }\n    bb13: {\n        _16 = <result::Result<(), fmt::Error> as ops::try_trait::Try>::branch(move _17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb15, 1: bb16, otherwise: bb3];\n    }\n    bb15: {\n        StorageDead(_16);\n        _19 = CheckedAdd(_8, 3_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _8, 3_usize) -> [success: bb18, unwind unreachable];\n    }\n    bb16: {\n        _0 = <result::Result<(), fmt::Error> as ops::try_trait::FromResidual<result::Result<convert::Infallible, fmt::Error>>>::from_residual(result::Result::<convert::Infallible, fmt::Error>::Err(fmt::Error)) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_16);\n        goto -> bb26;\n    }\n    bb18: {\n        _4 = move (_19.0: usize);\n        StorageDead(_5);\n        goto -> bb1;\n    }\n    bb19: {\n        StorageDead(_22);\n        _20 = str::converts::from_utf8_unchecked(_21) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_24);\n        _24 = _4;\n        switchInt(move _24) -> [0: bb21, otherwise: bb23];\n    }\n    bb21: {\n        StorageDead(_24);\n        _0 = <str as fmt::Display>::fmt(_20, _2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        goto -> bb25;\n    }\n    bb23: {\n        StorageDead(_24);\n        _0 = fmt::Formatter::<'_>::write_str(_2, _20) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        goto -> bb25;\n    }\n    bb25: {\n        goto -> bb27;\n    }\n    bb26: {\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}