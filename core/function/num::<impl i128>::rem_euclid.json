{
  "name": "num::<impl i128>::rem_euclid",
  "safe": true,
  "callees": {
    "num::<impl i128>::wrapping_abs": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n the boundary of the type.\n\n The only case where such wrapping can occur is when one takes the absolute value of the negative\n minimal value for the type; this is a positive value that is too large to represent in the type. In\n such a case, this function returns `MIN` itself.\n\n # Examples\n\n ```\n assert_eq!((-128i8).wrapping_abs() as u8, 128);\n ```\n",
      "adt": {}
    },
    "num::<impl i128>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl i128>::rem_euclid"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:3184:9: 3199:10",
  "src": "pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n                // and is clearly equivalent, because `r` is negative.\n                // Otherwise, `rhs` is `Self::MIN`, then we have\n                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n                // `r - Self::MIN`, which is what we wanted (and will not overflow\n                // for negative `r`).\n                r.wrapping_add(rhs.wrapping_abs())\n            } else {\n                r\n            }\n        }",
  "mir": "fn num::<impl i128>::rem_euclid(_1: i128, _2: i128) -> i128 {\n    let mut _0: i128;\n    let  _3: i128;\n    let mut _4: bool;\n    let mut _5: bool;\n    let mut _6: bool;\n    let mut _7: bool;\n    let mut _8: bool;\n    let mut _9: i128;\n    debug self => _1;\n    debug rhs => _2;\n    debug r => _3;\n    bb0: {\n        _4 = Eq(_2, 0_i128);\n        assert(!move _4, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = Eq(_2, -1_i128);\n        _6 = Eq(_1, i128::MIN);\n        _7 = BitAnd(move _5, move _6);\n        assert(!move _7, \"attempt to compute `{} % {}`, which would overflow\", _1, _2) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = Rem(_1, _2);\n        StorageLive(_8);\n        _8 = Lt(_3, 0_i128);\n        switchInt(move _8) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = num::<impl i128>::wrapping_abs(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _0 = num::<impl i128>::wrapping_add(_3, move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        goto -> bb7;\n    }\n    bb6: {\n        _0 = _3;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Calculates the least nonnegative remainder of `self (mod rhs)`.\n\n This is done as if by the Euclidean division algorithm -- given\n `r = self.rem_euclid(rhs)`, the result satisfies\n `self = rhs * self.div_euclid(rhs) + r` and `0 <= r < abs(rhs)`.\n\n # Panics\n\n This function will panic if `rhs` is zero or if `self` is `Self::MIN` and\n `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n\n # Examples\n\n ```\n let b = 4;\n\n assert_eq!(a.rem_euclid(b), 3);\n assert_eq!((-a).rem_euclid(b), 1);\n assert_eq!(a.rem_euclid(-b), 3);\n assert_eq!((-a).rem_euclid(-b), 1);\n ```\n\n This will panic:\n ```should_panic\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}