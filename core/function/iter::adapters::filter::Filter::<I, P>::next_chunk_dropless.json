{
  "name": "iter::adapters::filter::Filter::<I, P>::next_chunk_dropless",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::try_for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that applies a fallible function to each item in the\n iterator, stopping at the first error and returning that error.\n\n This can also be thought of as the fallible form of [`for_each()`]\n or as the stateless version of [`try_fold()`].\n\n [`for_each()`]: Iterator::for_each\n [`try_fold()`]: Iterator::try_fold\n\n # Examples\n\n ```\n use std::fs::rename;\n use std::io::{stdout, Write};\n use std::path::Path;\n\n let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n\n let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{x}\"));\n assert!(res.is_ok());\n\n let mut it = data.iter().cloned();\n let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\n assert!(res.is_err());\n // It short-circuited, so the remaining items are still in the iterator:\n assert_eq!(it.next(), Some(\"stale_bread.json\"));\n ```\n\n The [`ControlFlow`] type can be used with this method for the situations\n in which you'd use `break` and `continue` in a normal loop:\n\n ```\n use std::ops::ControlFlow;\n\n let r = (2..100).try_for_each(|x| {\n     if 323 % x == 0 {\n         return ControlFlow::Break(x)\n     }\n\n     ControlFlow::Continue(())\n });\n assert_eq!(r, ControlFlow::Break(17));\n ```\n",
      "adt": {}
    },
    "array::iter::IntoIter::<T, N>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the elements in a partially-initialized buffer.\n\n If you have a fully-initialized array, then use [`IntoIterator`].\n But this is useful for returning partial results from unsafe code.\n\n # Safety\n\n - The `buffer[initialized]` elements must all be initialized.\n - The range must be canonical, with `initialized.start <= initialized.end`.\n - The range must be in-bounds for the buffer, with `initialized.end <= N`.\n   (Like how indexing `[0][100..100]` fails despite the range being empty.)\n\n It's sound to have more elements initialized than mentioned, though that\n will most likely result in them being leaked.\n\n # Examples\n\n ```\n #![feature(array_into_iter_constructors)]\n #![feature(maybe_uninit_uninit_array_transpose)]\n use std::array::IntoIter;\n use std::mem::MaybeUninit;\n\n # // Hi!  Thanks for reading the code. This is restricted to `Copy` because\n # // otherwise it could leak. A fully-general version this would need a drop\n # // guard to handle panics from the iterator, but this works for an example.\n fn next_chunk<T: Copy, const N: usize>(\n     it: &mut impl Iterator<Item = T>,\n ) -> Result<[T; N], IntoIter<T, N>> {\n     let mut buffer = [const { MaybeUninit::uninit() }; N];\n     let mut i = 0;\n     while i < N {\n         match it.next() {\n             Some(x) => {\n                 buffer[i].write(x);\n                 i += 1;\n             }\n             None => {\n                 // SAFETY: We've initialized the first `i` items\n                 unsafe {\n                     return Err(IntoIter::new_unchecked(buffer, 0..i));\n                 }\n             }\n         }\n     }\n\n     // SAFETY: We've initialized all N items\n     unsafe { Ok(buffer.transpose().assume_init()) }\n }\n\n let r: [_; 4] = next_chunk(&mut (10..16)).unwrap();\n assert_eq!(r, [10, 11, 12, 13]);\n let r: IntoIter<_, 40> = next_chunk(&mut (10..16)).unwrap_err();\n assert_eq!(r.collect::<Vec<_>>(), vec![10, 11, 12, 13, 14, 15]);\n ```\n",
      "adt": {
        "array::iter::IntoIter": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::array_assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the values from an array of `MaybeUninit` containers.\n\n # Safety\n\n It is up to the caller to guarantee that all elements of the array are\n in an initialized state.\n\n # Examples\n\n ```\n #![feature(maybe_uninit_array_assume_init)]\n use std::mem::MaybeUninit;\n\n let mut array: [MaybeUninit<i32>; 3] = [MaybeUninit::uninit(); 3];\n array[0].write(0);\n array[1].write(1);\n array[2].write(2);\n\n // SAFETY: Now safe as we initialised all elements\n let array = unsafe {\n     MaybeUninit::array_assume_init(array)\n };\n\n assert_eq!(array, [0, 1, 2]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::filter::Filter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "array::iter::IntoIter": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::iter::adapters::filter::Filter::<I, P>::next_chunk_dropless"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter.rs:38:5: 65:6",
  "src": "fn next_chunk_dropless<const N: usize>(\n        &mut self,\n    ) -> Result<[I::Item; N], array::IntoIter<I::Item, N>> {\n        let mut array: [MaybeUninit<I::Item>; N] = [const { MaybeUninit::uninit() }; N];\n        let mut initialized = 0;\n\n        let result = self.iter.try_for_each(|element| {\n            let idx = initialized;\n            // branchless index update combined with unconditionally copying the value even when\n            // it is filtered reduces branching and dependencies in the loop.\n            initialized = idx + (self.predicate)(&element) as usize;\n            // SAFETY: Loop conditions ensure the index is in bounds.\n            unsafe { array.get_unchecked_mut(idx) }.write(element);\n\n            if initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n        });\n\n        match result {\n            ControlFlow::Break(()) => {\n                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n            }\n            ControlFlow::Continue(()) => {\n                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n            }\n        }\n    }",
  "mir": "fn iter::adapters::filter::Filter::<I, P>::next_chunk_dropless(_1: &mut iter::adapters::filter::Filter<I, P>) -> result::Result<[<I as iter::traits::iterator::Iterator>::Item; N], array::iter::IntoIter<<I as iter::traits::iterator::Iterator>::Item, N>> {\n    let mut _0: result::Result<[<I as iter::traits::iterator::Iterator>::Item; N], array::iter::IntoIter<<I as iter::traits::iterator::Iterator>::Item, N>>;\n    let mut _2: [mem::maybe_uninit::MaybeUninit<<I as iter::traits::iterator::Iterator>::Item>; N];\n    let mut _3: usize;\n    let  _4: ops::control_flow::ControlFlow<()>;\n    let mut _5: &mut I;\n    let mut _6: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter.rs:44:45: 44:54};\n    let mut _7: &mut usize;\n    let mut _8: &mut P;\n    let mut _9: &mut [mem::maybe_uninit::MaybeUninit<<I as iter::traits::iterator::Iterator>::Item>; N];\n    let mut _10: isize;\n    let mut _11: [<I as iter::traits::iterator::Iterator>::Item; N];\n    let mut _12: [mem::maybe_uninit::MaybeUninit<<I as iter::traits::iterator::Iterator>::Item>; N];\n    let mut _13: array::iter::IntoIter<<I as iter::traits::iterator::Iterator>::Item, N>;\n    let mut _14: [mem::maybe_uninit::MaybeUninit<<I as iter::traits::iterator::Iterator>::Item>; N];\n    let mut _15: ops::range::Range<usize>;\n    let mut _16: usize;\n    debug self => _1;\n    debug array => _2;\n    debug initialized => _3;\n    debug result => _4;\n    bb0: {\n        StorageLive(_2);\n        _2 = [iter::adapters::filter::Filter::<I, P>::next_chunk_dropless::<N>::{constant#2}; N];\n        StorageLive(_3);\n        _3 = 0_usize;\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: I);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _3;\n        StorageLive(_8);\n        _8 = &mut ((*_1).1: P);\n        StorageLive(_9);\n        _9 = &mut _2;\n        _6 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter.rs:44:45: 44:54}(move _7, move _8, move _9);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        _4 = <I as iter::traits::iterator::Iterator>::try_for_each::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/filter.rs:44:45: 44:54}, ops::control_flow::ControlFlow<()>>(move _5, move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _10 = discriminant(_4);\n        switchInt(move _10) -> [0: bb3, 1: bb4, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = move _2;\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _3;\n        _15 = Range(0_usize, move _16);\n        StorageDead(_16);\n        _13 = array::iter::IntoIter::<<I as iter::traits::iterator::Iterator>::Item, N>::new_unchecked(move _14, move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = move _2;\n        _11 = mem::maybe_uninit::MaybeUninit::<<I as iter::traits::iterator::Iterator>::Item>::array_assume_init::<N>(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _0 = result::Result::Ok(move _11);\n        StorageDead(_11);\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _0 = result::Result::Err(move _13);\n        StorageDead(_13);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}