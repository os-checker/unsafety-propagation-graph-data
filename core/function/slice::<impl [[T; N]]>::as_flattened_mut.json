{
  "name": "slice::<impl [[T; N]]>::as_flattened_mut",
  "safe": true,
  "callees": {
    "num::<impl usize>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "num::<impl usize>::unchecked_mul": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n cannot occur.\n\n Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n\n If you're just trying to avoid the panic in debug mode, then **do not**\n use this.  Instead, you're looking for [`wrapping_mul`].\n\n # Safety\n\n This results in undefined behavior when\n i.e. when [`checked_mul`] would return `None`.\n\n [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "slice::raw::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [[T; N]]>::as_flattened_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:5036:5: 5046:6",
  "src": "pub const fn as_flattened_mut(&mut self) -> &mut [T] {\n        let len = if T::IS_ZST {\n            self.len().checked_mul(N).expect(\"slice len overflow\")\n        } else {\n            // SAFETY: `self.len() * N` cannot overflow because `self` is\n            // already in the address space.\n            unsafe { self.len().unchecked_mul(N) }\n        };\n        // SAFETY: `[T]` is layout-identical to `[T; N]`\n        unsafe { from_raw_parts_mut(self.as_mut_ptr().cast(), len) }\n    }",
  "mir": "fn slice::<impl [[T; N]]>::as_flattened_mut(_1: &mut [[T; N]]) -> &mut [T] {\n    let mut _0: &mut [T];\n    let  _2: usize;\n    let mut _3: option::Option<usize>;\n    let mut _4: usize;\n    let mut _5: &[[T; N]];\n    let mut _6: &str;\n    let mut _7: usize;\n    let mut _8: &[[T; N]];\n    let mut _9: *mut T;\n    let mut _10: *mut [T; N];\n    let mut _11: usize;\n    debug self => _1;\n    debug len => _2;\n    bb0: {\n        StorageLive(_2);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb4, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _3 = num::<impl usize>::checked_mul(move _4, N) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = \"slice len overflow\";\n        _2 = option::Option::<usize>::expect(move _3, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb6;\n    }\n    bb4: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_1);\n        _7 = PtrMetadata(move _8);\n        StorageDead(_8);\n        _2 = num::<impl usize>::unchecked_mul(move _7, N) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = slice::<impl [[T; N]]>::as_mut_ptr(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = ptr::mut_ptr::<impl *mut [T; N]>::cast::<T>(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = _2;\n        _0 = slice::raw::from_raw_parts_mut::<'_, T>(move _9, move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Takes a `&mut [[T; N]]`, and flattens it to a `&mut [T]`.\n\n For the opposite operation, see [`as_chunks_mut`] and [`as_rchunks_mut`].\n\n [`as_chunks_mut`]: slice::as_chunks_mut\n [`as_rchunks_mut`]: slice::as_rchunks_mut\n\n # Panics\n\n This panics if the length of the resulting slice would overflow a `usize`.\n\n This is only possible when flattening a slice of arrays of zero-sized\n types, and thus tends to be irrelevant in practice. If\n `size_of::<T>() > 0`, this will never panic.\n\n # Examples\n\n ```\n fn add_5_to_all(slice: &mut [i32]) {\n     for i in slice {\n         *i += 5;\n     }\n }\n\n let mut array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n add_5_to_all(array.as_flattened_mut());\n assert_eq!(array, [[6, 7, 8], [9, 10, 11], [12, 13, 14]]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}