{
  "name": "iter::sources::once_with::once_with",
  "safe": true,
  "callees": {},
  "adts": {
    "option::Option": [
      "Plain"
    ],
    "iter::sources::once_with::OnceWith": [
      "Plain"
    ]
  },
  "path": 14195,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/sources/once_with.rs:61:1: 63:2",
  "src": "pub fn once_with<A, F: FnOnce() -> A>(make: F) -> OnceWith<F> {\n    OnceWith { make: Some(make) }\n}",
  "mir": "fn iter::sources::once_with::once_with(_1: F) -> iter::sources::once_with::OnceWith<F> {\n    let mut _0: iter::sources::once_with::OnceWith<F>;\n    let mut _2: option::Option<F>;\n    debug make => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = option::Option::Some(_1);\n        _0 = OnceWith(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates an iterator that lazily generates a value exactly once by invoking\n the provided closure.\n\n This is commonly used to adapt a single value coroutine into a [`chain()`] of\n other kinds of iteration. Maybe you have an iterator that covers almost\n everything, but you need an extra special case. Maybe you have a function\n which works on iterators, but you only need to process one value.\n\n Unlike [`once()`], this function will lazily generate the value on request.\n\n [`chain()`]: Iterator::chain\n [`once()`]: crate::iter::once\n\n # Examples\n\n Basic usage:\n\n ```\n use std::iter;\n\n // one is the loneliest number\n let mut one = iter::once_with(|| 1);\n\n assert_eq!(Some(1), one.next());\n\n // just one, that's all we get\n assert_eq!(None, one.next());\n ```\n\n Chaining together with another iterator. Let's say that we want to iterate\n over each file of the `.foo` directory, but also a configuration file,\n `.foorc`:\n\n ```no_run\n use std::iter;\n use std::fs;\n use std::path::PathBuf;\n\n let dirs = fs::read_dir(\".foo\").unwrap();\n\n // we need to convert from an iterator of DirEntry-s to an iterator of\n // PathBufs, so we use map\n let dirs = dirs.map(|file| file.unwrap().path());\n\n // now, our iterator just for our config file\n let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n\n // chain the two iterators together into one big iterator\n let files = dirs.chain(config);\n\n // this will give us all of the files in .foo as well as .foorc\n for f in files {\n     println!(\"{f:?}\");\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}