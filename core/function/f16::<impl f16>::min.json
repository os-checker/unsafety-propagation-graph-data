{
  "name": "f16::<impl f16>::min",
  "safe": true,
  "callees": {
    "intrinsics::minnumf16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the minimum of two `f16` values, ignoring NaN.\n\n This behaves like IEEE 754-2008 minNum. In particular:\n If one of the arguments is NaN, then the other argument is returned. If the inputs compare equal\n (such as for the case of `+0.0` and `-0.0`), either input may be returned non-deterministically.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n The stabilized version of this intrinsic is [`f16::min`].\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::f16::<impl f16>::min"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f16.rs:744:5: 746:6",
  "src": "pub const fn min(self, other: f16) -> f16 {\n        intrinsics::minnumf16(self, other)\n    }",
  "mir": "fn f16::<impl f16>::min(_1: f16, _2: f16) -> f16 {\n    let mut _0: f16;\n    debug self => _1;\n    debug other => _2;\n    bb0: {\n        _0 = intrinsics::minnumf16(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Returns the minimum of the two numbers, ignoring NaN.\n\n If exactly one of the arguments is NaN, then the other argument is returned. If both\n arguments are NaN, the return value is NaN, with the bit pattern picked using the usual\n [rules for arithmetic operations](f32#nan-bit-patterns). If the inputs compare equal (such\n as for the case of `+0.0` and `-0.0`), either input may be returned non-deterministically.\n\n This follows the IEEE 754-2008 semantics for `minNum`, except for handling of signaling NaNs;\n this function handles all NaNs the same way and avoids `minNum`'s problems with associativity.\n This also matches the behavior of libmâ€™s `fmin`.\n\n ```\n #![feature(f16)]\n # #[cfg(target_arch = \"aarch64\")] { // FIXME(f16_F128): rust-lang/rust#123885\n\n let x = 1.0f16;\n let y = 2.0f16;\n\n assert_eq!(x.min(y), x);\n assert_eq!(x.min(f16::NAN), x);\n # }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}