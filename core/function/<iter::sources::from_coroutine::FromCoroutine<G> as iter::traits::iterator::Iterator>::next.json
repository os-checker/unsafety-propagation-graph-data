{
  "name": "<iter::sources::from_coroutine::FromCoroutine<G> as iter::traits::iterator::Iterator>::next",
  "safe": true,
  "callees": {
    "pin::Pin::<Ptr>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Pin<Ptr>` around a pointer to some data of a type that\n implements [`Unpin`].\n\n Unlike `Pin::new_unchecked`, this method is safe because the pointer\n `Ptr` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.\n\n # Examples\n\n ```\n use std::pin::Pin;\n\n let mut val: u8 = 5;\n\n // Since `val` doesn't care about being moved, we can safely create a \"facade\" `Pin`\n // which will allow `val` to participate in `Pin`-bound apis  without checking that\n // pinning guarantees are actually upheld.\n let mut pinned: Pin<&mut u8> = Pin::new(&mut val);\n ```\n",
      "adt": {
        "pin::Pin": "Constructor"
      }
    },
    "ops::coroutine::Coroutine::resume": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Resumes the execution of this coroutine.\n\n This function will resume execution of the coroutine or start execution\n if it hasn't already. This call will return back into the coroutine's\n last suspension point, resuming execution from the latest `yield`. The\n coroutine will continue executing until it either yields or returns, at\n which point this function will return.\n\n # Return value\n\n The `CoroutineState` enum returned from this function indicates what\n state the coroutine is in upon returning. If the `Yielded` variant is\n returned then the coroutine has reached a suspension point and a value\n has been yielded out. Coroutines in this state are available for\n resumption at a later point.\n\n If `Complete` is returned then the coroutine has completely finished\n with the value provided. It is invalid for the coroutine to be resumed\n again.\n\n # Panics\n\n This function may panic if it is called after the `Complete` variant has\n been returned previously. While coroutine literals in the language are\n guaranteed to panic on resuming after `Complete`, this is not guaranteed\n for all implementations of the `Coroutine` trait.\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::sources::from_coroutine::FromCoroutine": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "pin::Pin": [
      "Plain"
    ],
    "ops::coroutine::CoroutineState": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8400, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25507, name: \"ops::coroutine::Coroutine::Yield\" }), args: GenericArgs([Type(Ty { id: 8395, kind: Param(ParamTy { index: 0, name: \"G\" }) }), Type(Ty { id: 420, kind: RigidTy(Tuple([])) })]) }) })])"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": 14178,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/sources/from_coroutine.rs:45:5: 50:6",
  "src": "fn next(&mut self) -> Option<Self::Item> {\n        match Pin::new(&mut self.0).resume(()) {\n            CoroutineState::Yielded(n) => Some(n),\n            CoroutineState::Complete(()) => None,\n        }\n    }",
  "mir": "fn <iter::sources::from_coroutine::FromCoroutine<G> as iter::traits::iterator::Iterator>::next(_1: &mut iter::sources::from_coroutine::FromCoroutine<G>) -> option::Option<<G as ops::coroutine::Coroutine>::Yield> {\n    let mut _0: option::Option<<G as ops::coroutine::Coroutine>::Yield>;\n    let mut _2: ops::coroutine::CoroutineState<<G as ops::coroutine::Coroutine>::Yield, ()>;\n    let mut _3: pin::Pin<&mut G>;\n    let mut _4: &mut G;\n    let mut _5: isize;\n    let  _6: <G as ops::coroutine::Coroutine>::Yield;\n    debug self => _1;\n    debug n => _6;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: G);\n        _3 = pin::Pin::<&mut G>::new(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = <G as ops::coroutine::Coroutine>::resume(move _3, ()) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _5 = discriminant(_2);\n        switchInt(move _5) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _0 = option::Option::None;\n        goto -> bb6;\n    }\n    bb5: {\n        _6 = move ((_2 as variant#0).0: <G as ops::coroutine::Coroutine>::Yield);\n        _0 = option::Option::Some(_6);\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}