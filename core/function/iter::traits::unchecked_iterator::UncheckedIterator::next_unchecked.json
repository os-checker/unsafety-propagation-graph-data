{
  "name": "iter::traits::unchecked_iterator::UncheckedIterator::next_unchecked",
  "safe": false,
  "callees": {
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::unwrap_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value,\n without checking that the value is not [`None`].\n\n # Safety\n\n Calling this method on [`None`] is *[undefined behavior]*.\n\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\");\n ```\n\n ```no_run\n let x: Option<&str> = None;\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\"); // Undefined behavior!\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain"
    ]
  },
  "path": "iter::traits::unchecked_iterator::UncheckedIterator::next_unchecked",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/unchecked_iterator.rs:30:5: 35:6",
  "src": "unsafe fn next_unchecked(&mut self) -> Self::Item {\n        let opt = self.next();\n        // SAFETY: The caller promised that we're not empty, and\n        // `Self: TrustedLen` so we can actually trust the `size_hint`.\n        unsafe { opt.unwrap_unchecked() }\n    }",
  "mir": "fn iter::traits::unchecked_iterator::UncheckedIterator::next_unchecked(_1: &mut Self) -> <Self as iter::traits::iterator::Iterator>::Item {\n    let mut _0: <Self as iter::traits::iterator::Iterator>::Item;\n    let  _2: option::Option<<Self as iter::traits::iterator::Iterator>::Item>;\n    debug self => _1;\n    debug opt => _2;\n    bb0: {\n        _2 = <Self as iter::traits::iterator::Iterator>::next(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = option::Option::<<Self as iter::traits::iterator::Iterator>::Item>::unwrap_unchecked(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Gets the next item from a non-empty iterator.\n\n Because there's always a value to return, that means it can return\n the `Item` type directly, without wrapping it in an `Option`.\n\n # Safety\n\n This can only be called if `size_hint().0 != 0`, guaranteeing that\n there's at least one item available.\n\n Otherwise (aka when `size_hint().1 == Some(0)`), this is UB.\n\n # Note to Implementers\n\n This has a default implementation using [`Option::unwrap_unchecked`].\n That's probably sufficient if your `next` *always* returns `Some`,\n such as for infinite iterators.  In more complicated situations, however,\n sometimes there can still be `insertvalue`/`assume`/`extractvalue`\n instructions remaining in the IR from the `Option` handling, at which\n point you might want to implement this manually instead.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}