{
  "name": "iter::traits::iterator::Iterator::flatten",
  "safe": true,
  "callees": {
    "iter::adapters::flatten::Flatten::<I>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "iter::adapters::flatten::Flatten": "Constructor"
      }
    }
  },
  "adts": {
    "iter::adapters::flatten::Flatten": [
      "Plain"
    ]
  },
  "path": "iter::traits::iterator::Iterator::flatten",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1557:5: 1563:6",
  "src": "fn flatten(self) -> Flatten<Self>\n    where\n        Self: Sized,\n        Self::Item: IntoIterator,\n    {\n        Flatten::new(self)\n    }",
  "mir": "fn iter::traits::iterator::Iterator::flatten(_1: Self) -> iter::adapters::flatten::Flatten<Self> {\n    let mut _0: iter::adapters::flatten::Flatten<Self>;\n    debug self => _1;\n    bb0: {\n        _0 = iter::adapters::flatten::Flatten::<Self>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Creates an iterator that flattens nested structure.\n\n This is useful when you have an iterator of iterators or an iterator of\n things that can be turned into iterators and you want to remove one\n level of indirection.\n\n # Examples\n\n Basic usage:\n\n ```\n let data = vec![vec![1, 2, 3, 4], vec![5, 6]];\n let flattened: Vec<_> = data.into_iter().flatten().collect();\n assert_eq!(flattened, [1, 2, 3, 4, 5, 6]);\n ```\n\n Mapping and then flattening:\n\n ```\n let words = [\"alpha\", \"beta\", \"gamma\"];\n\n // chars() returns an iterator\n let merged: String = words.iter()\n                           .map(|s| s.chars())\n                           .flatten()\n                           .collect();\n assert_eq!(merged, \"alphabetagamma\");\n ```\n\n You can also rewrite this in terms of [`flat_map()`], which is preferable\n in this case since it conveys intent more clearly:\n\n ```\n let words = [\"alpha\", \"beta\", \"gamma\"];\n\n // chars() returns an iterator\n let merged: String = words.iter()\n                           .flat_map(|s| s.chars())\n                           .collect();\n assert_eq!(merged, \"alphabetagamma\");\n ```\n\n Flattening works on any `IntoIterator` type, including `Option` and `Result`:\n\n ```\n let options = vec![Some(123), Some(321), None, Some(231)];\n let flattened_options: Vec<_> = options.into_iter().flatten().collect();\n assert_eq!(flattened_options, [123, 321, 231]);\n\n let results = vec![Ok(123), Ok(321), Err(456), Ok(231)];\n let flattened_results: Vec<_> = results.into_iter().flatten().collect();\n assert_eq!(flattened_results, [123, 321, 231]);\n ```\n\n Flattening only removes one level of nesting at a time:\n\n ```\n let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];\n\n let d2: Vec<_> = d3.into_iter().flatten().collect();\n assert_eq!(d2, [[1, 2], [3, 4], [5, 6], [7, 8]]);\n\n let d1: Vec<_> = d3.into_iter().flatten().flatten().collect();\n assert_eq!(d1, [1, 2, 3, 4, 5, 6, 7, 8]);\n ```\n\n Here we see that `flatten()` does not perform a \"deep\" flatten.\n Instead, only one level of nesting is removed. That is, if you\n `flatten()` a three-dimensional array, the result will be\n two-dimensional and not one-dimensional. To get a one-dimensional\n structure, you have to `flatten()` again.\n\n [`flat_map()`]: Iterator::flat_map\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}