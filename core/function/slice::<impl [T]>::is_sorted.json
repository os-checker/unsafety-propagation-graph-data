{
  "name": "slice::<impl [T]>::is_sorted",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::windows": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over all contiguous windows of length\n `size`. The windows overlap. If the slice is shorter than\n `size`, the iterator returns no values.\n\n # Panics\n\n Panics if `size` is zero.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let mut iter = slice.windows(3);\n assert_eq!(iter.next().unwrap(), &['l', 'o', 'r']);\n assert_eq!(iter.next().unwrap(), &['o', 'r', 'e']);\n assert_eq!(iter.next().unwrap(), &['r', 'e', 'm']);\n assert!(iter.next().is_none());\n ```\n\n If the slice is shorter than `size`:\n\n ```\n let slice = ['f', 'o', 'o'];\n let mut iter = slice.windows(4);\n assert!(iter.next().is_none());\n ```\n\n Because the [Iterator] trait cannot represent the required lifetimes,\n there is no `windows_mut` analog to `windows`;\n `[0,1,2].windows_mut(2).collect()` would violate [the rules of references]\n (though a [LendingIterator] analog is possible). You can sometimes use\n [`Cell::as_slice_of_cells`](crate::cell::Cell::as_slice_of_cells) in\n conjunction with `windows` instead:\n\n [the rules of references]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references\n [LendingIterator]: https://blog.rust-lang.org/2022/10/28/gats-stabilization.html\n ```\n use std::cell::Cell;\n\n let mut array = ['R', 'u', 's', 't', ' ', '2', '0', '1', '5'];\n let slice = &mut array[..];\n let slice_of_cells: &[Cell<char>] = Cell::from_mut(slice).as_slice_of_cells();\n for w in slice_of_cells.windows(3) {\n     Cell::swap(&w[0], &w[2]);\n }\n assert_eq!(array, ['s', 't', ' ', '2', '0', '1', '5', 'u', 'R']);\n ```\n",
      "adt": {
        "slice::iter::Windows": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests if every element of the iterator matches a predicate.\n\n `all()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if they all return\n `true`, then so does `all()`. If any of them return `false`, it\n returns `false`.\n\n `all()` is short-circuiting; in other words, it will stop processing\n as soon as it finds a `false`, given that no matter what else happens,\n the result will also be `false`.\n\n An empty iterator returns `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert!(a.into_iter().all(|x| x > 0));\n\n assert!(!a.into_iter().all(|x| x > 2));\n ```\n\n Stopping at the first `false`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert!(!iter.all(|x| x != 2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Folds every element into an accumulator by applying an operation,\n returning the final result.\n\n `fold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `fold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `fold()`, and similar methods that traverse the entire iterator,\n might not terminate for infinite iterators, even on traits for which a\n result is determinable in finite time.\n\n Note: [`reduce()`] can be used to use the first element as the initial\n value, if the accumulator type and item type is the same.\n\n Note: `fold()` combines elements in a *left-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `fold()` on the internal parts\n from which this iterator is composed.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of the array\n let sum = a.iter().fold(0, |acc, x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n Let's walk through each step of the iteration here:\n\n | element | acc | x | result |\n |---------|-----|---|--------|\n |         | 0   |   |        |\n | 1       | 0   | 1 | 1      |\n | 2       | 1   | 2 | 3      |\n | 3       | 3   | 3 | 6      |\n\n And so, our final result, `6`.\n\n This example demonstrates the left-associative nature of `fold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the front until the back:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().fold(zero, |acc, &x| {\n     format!(\"({acc} + {x})\")\n });\n\n assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n ```\n It's common for people who haven't used iterators a lot to\n use a `for` loop with a list of things to build up a result. Those\n can be turned into `fold()`s:\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let mut result = 0;\n\n // for loop:\n for i in &numbers {\n     result = result + i;\n }\n\n // fold:\n let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n // they're the same\n assert_eq!(result, result2);\n ```\n\n [`reduce()`]: Iterator::reduce\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::iter::Windows": [
      "Plain",
      "MutRef"
    ],
    "ops::range::Range": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ]
  },
  "path": 1270,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4300:5: 4321:6",
  "src": "pub fn is_sorted(&self) -> bool\n    where\n        T: PartialOrd,\n    {\n        // This odd number works the best. 32 + 1 extra due to overlapping chunk boundaries.\n        const CHUNK_SIZE: usize = 33;\n        if self.len() < CHUNK_SIZE {\n            return self.windows(2).all(|w| w[0] <= w[1]);\n        }\n        let mut i = 0;\n        // Check in chunks for autovectorization.\n        while i < self.len() - CHUNK_SIZE {\n            let chunk = &self[i..i + CHUNK_SIZE];\n            if !chunk.windows(2).fold(true, |acc, w| acc & (w[0] <= w[1])) {\n                return false;\n            }\n            // We need to ensure that chunk boundaries are also sorted.\n            // Overlap the next chunk with the last element of our last chunk.\n            i += CHUNK_SIZE - 1;\n        }\n        self[i..].windows(2).all(|w| w[0] <= w[1])\n    }",
  "mir": "fn slice::<impl [T]>::is_sorted(_1: &[T]) -> bool {\n    let mut _0: bool;\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: &mut slice::iter::Windows<'_, T>;\n    let mut _5: slice::iter::Windows<'_, T>;\n    let mut _6: usize;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let  _12: &[T];\n    let mut _13: ops::range::Range<usize>;\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: bool;\n    let mut _19: slice::iter::Windows<'_, T>;\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: (usize, bool);\n    let mut _23: &mut slice::iter::Windows<'_, T>;\n    let mut _24: slice::iter::Windows<'_, T>;\n    let  _25: &[T];\n    let mut _26: ops::range::RangeFrom<usize>;\n    let mut _27: usize;\n    debug self => _1;\n    debug i => _6;\n    debug chunk => _12;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = PtrMetadata(_1);\n        _2 = Lt(move _3, slice::<impl [T]>::is_sorted::CHUNK_SIZE);\n        switchInt(move _2) -> [0: bb4, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = slice::<impl [T]>::windows(_1, 2_usize) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = &mut _5;\n        _0 = <slice::iter::Windows<'_, T> as iter::traits::iterator::Iterator>::all::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4307:40: 4307:43}>(move _4, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4307:40: 4307:43}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_5);\n        StorageDead(_2);\n        goto -> bb20;\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_6);\n        _6 = 0_usize;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = _6;\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = PtrMetadata(_1);\n        _11 = CheckedSub(_10, slice::<impl [T]>::is_sorted::CHUNK_SIZE);\n        assert(!move (_11.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _10, slice::<impl [T]>::is_sorted::CHUNK_SIZE) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = move (_11.0: usize);\n        StorageDead(_10);\n        _7 = Lt(move _8, move _9);\n        switchInt(move _7) -> [0: bb16, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _6;\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = _6;\n        _17 = CheckedAdd(_16, slice::<impl [T]>::is_sorted::CHUNK_SIZE);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _16, slice::<impl [T]>::is_sorted::CHUNK_SIZE) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = move (_17.0: usize);\n        StorageDead(_16);\n        _13 = Range(move _14, move _15);\n        StorageDead(_15);\n        StorageDead(_14);\n        _12 = <[T] as ops::index::Index<ops::range::Range<usize>>>::index(_1, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = slice::<impl [T]>::windows(_12, 2_usize) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _18 = <slice::iter::Windows<'_, T> as iter::traits::iterator::Iterator>::fold::<bool, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4313:45: 4313:53}>(move _19, true, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4313:45: 4313:53}) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _18) -> [0: bb13, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_20);\n        _21 = CheckedSub(slice::<impl [T]>::is_sorted::CHUNK_SIZE, 1_usize);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", slice::<impl [T]>::is_sorted::CHUNK_SIZE, 1_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        _0 = false;\n        StorageDead(_18);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb20;\n    }\n    bb14: {\n        _20 = move (_21.0: usize);\n        _22 = CheckedAdd(_6, _20);\n        assert(!move (_22.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, move _20) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _6 = move (_22.0: usize);\n        StorageDead(_20);\n        StorageDead(_7);\n        goto -> bb5;\n    }\n    bb16: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _6;\n        _26 = RangeFrom(move _27);\n        StorageDead(_27);\n        _25 = <[T] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(_1, move _26) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_26);\n        _24 = slice::<impl [T]>::windows(_25, 2_usize) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _23 = &mut _24;\n        _0 = <slice::iter::Windows<'_, T> as iter::traits::iterator::Iterator>::all::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4320:34: 4320:37}>(move _23, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4320:34: 4320:37}) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_6);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": " Checks if the elements of this slice are sorted.\n\n That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n slice yields exactly zero or one element, `true` is returned.\n\n Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n implies that this function returns `false` if any two consecutive items are not\n comparable.\n\n # Examples\n\n ```\n let empty: [i32; 0] = [];\n\n assert!([1, 2, 2, 9].is_sorted());\n assert!(![1, 3, 2, 4].is_sorted());\n assert!([0].is_sorted());\n assert!(empty.is_sorted());\n assert!(![0.0, 1.0, f32::NAN].is_sorted());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}