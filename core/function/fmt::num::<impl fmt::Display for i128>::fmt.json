{
  "name": "fmt::num::<impl fmt::Display for i128>::fmt",
  "safe": true,
  "callees": {
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "num::<impl i128>::unsigned_abs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Computes the absolute value of `self` without any wrapping\n or panicking.\n\n\n # Examples\n\n ```\n assert_eq!((-128i8).unsigned_abs(), 128u8);\n ```\n",
      "adt": {}
    },
    "fmt::num::<impl u128>::_fmt": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Format optimized for u128. Computation of 128 bits is limited by processing\n in batches of 16 decimals at a time.\n",
      "adt": {}
    },
    "fmt::Formatter::<'a>::pad_integral": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.\n\n # Arguments\n\n * is_nonnegative - whether the original integer was either positive or zero.\n * prefix - if the '#' character (Alternate) is provided, this\n   is the prefix to put in front of the number.\n * buf - the byte array that the number has been formatted into\n\n This function will correctly account for the flags provided as well as\n the minimum width. It will not take precision into account.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo { nb: i32 }\n\n impl Foo {\n     fn new(nb: i32) -> Foo {\n         Foo {\n             nb,\n         }\n     }\n }\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // We need to remove \"-\" from the number output.\n         let tmp = self.nb.abs().to_string();\n\n         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n ```\n",
      "adt": {
        "fmt::Formatter": "MutableAsArgument",
        "result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain"
    ],
    "fmt::Formatter": [
      "MutRef"
    ],
    "result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::fmt::num::<impl fmt::Display for i128>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:628:5: 636:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // This is not a typo, we use the maximum number of digits of `u128`, hence why we use\n        // `U128_MAX_DEC_N`.\n        let mut buf = [MaybeUninit::<u8>::uninit(); U128_MAX_DEC_N];\n\n        let is_nonnegative = *self >= 0;\n        // SAFETY: `buf` is always big enough to contain all the digits.\n        unsafe { f.pad_integral(is_nonnegative, \"\", self.unsigned_abs()._fmt(&mut buf)) }\n    }",
  "mir": "fn fmt::num::<impl fmt::Display for i128>::fmt(_1: &i128, _2: &mut fmt::Formatter<'_>) -> result::Result<(), fmt::Error> {\n    let mut _0: result::Result<(), fmt::Error>;\n    let mut _3: [mem::maybe_uninit::MaybeUninit<u8>; 39];\n    let mut _4: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _5: bool;\n    let mut _6: i128;\n    let mut _7: &str;\n    let  _8: &str;\n    let mut _9: u128;\n    let mut _10: i128;\n    let mut _11: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _12: &mut [mem::maybe_uninit::MaybeUninit<u8>; 39];\n    debug self => _1;\n    debug f => _2;\n    debug buf => _3;\n    debug is_nonnegative => _5;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = mem::maybe_uninit::MaybeUninit::<u8>::uninit() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = [move _4; 39];\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = (*_1);\n        _5 = Ge(move _6, 0_i128);\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = \"\";\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (*_1);\n        _9 = num::<impl i128>::unsigned_abs(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageLive(_11);\n        _12 = &mut _3;\n        _11 = _12 as &mut [mem::maybe_uninit::MaybeUninit<u8>];\n        _8 = fmt::num::<impl u128>::_fmt(move _9, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        StorageDead(_9);\n        _0 = fmt::Formatter::<'_>::pad_integral(_2, _5, move _7, _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}