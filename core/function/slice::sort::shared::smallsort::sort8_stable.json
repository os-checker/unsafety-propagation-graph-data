{
  "name": "slice::sort::shared::smallsort::sort8_stable",
  "safe": false,
  "callees": {
    "slice::sort::shared::smallsort::sort4_stable": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " SAFETY: The caller MUST guarantee that `v_base` is valid for 4 reads and\n `dst` is valid for 4 writes. The result will be stored in `dst[0..4]`.\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ptr::slice_from_raw_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a raw slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n\n [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n\n # Examples\n\n ```rust\n use std::ptr;\n\n // create a slice pointer when starting out with a pointer to the first element\n let x = [5, 6, 7];\n let raw_pointer = x.as_ptr();\n let slice = ptr::slice_from_raw_parts(raw_pointer, 3);\n assert_eq!(unsafe { &*slice }[2], 7);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *const [u8] = ptr::slice_from_raw_parts(ptr::null(), 0);\n unsafe {\n     danger.as_ref().expect(\"references must not be null\");\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::bidirectional_merge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Merge v assuming v[..len / 2] and v[len / 2..] are sorted.\n\n Original idea for bi-directional merging by Igor van den Hoven (quadsort),\n adapted to only use merge up and down. In contrast to the original\n parity_merge function, it performs 2 writes instead of 4 per iteration.\n\n # Safety\n The caller must guarantee that `dst` is valid for v.len() writes.\n Also `v.as_ptr()` and `dst` must not alias and v.len() must be >= 2.\n\n Note that T must be Freeze, the comparison function is evaluated on outdated\n temporary 'copies' that may not end up in the final array.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::sort::shared::smallsort::sort8_stable"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:663:1: 680:2",
  "src": "unsafe fn sort8_stable<T: FreezeMarker, F: FnMut(&T, &T) -> bool>(\n    v_base: *mut T,\n    dst: *mut T,\n    scratch_base: *mut T,\n    is_less: &mut F,\n) {\n    // SAFETY: these pointers are all in-bounds by the precondition of our function.\n    unsafe {\n        sort4_stable(v_base, scratch_base, is_less);\n        sort4_stable(v_base.add(4), scratch_base.add(4), is_less);\n    }\n\n    // SAFETY: scratch_base[0..8] is now initialized, allowing us to merge back\n    // into dst.\n    unsafe {\n        bidirectional_merge(&*ptr::slice_from_raw_parts(scratch_base, 8), dst, is_less);\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::sort8_stable(_1: *mut T, _2: *mut T, _3: *mut T, _4: &mut F) -> () {\n    let mut _0: ();\n    let  _5: ();\n    let mut _6: *const T;\n    let  _7: ();\n    let mut _8: *const T;\n    let mut _9: *mut T;\n    let mut _10: *mut T;\n    let  _11: ();\n    let  _12: &[T];\n    let  _13: *const [T];\n    let mut _14: *const T;\n    debug v_base => _1;\n    debug dst => _2;\n    debug scratch_base => _3;\n    debug is_less => _4;\n    bb0: {\n        StorageLive(_6);\n        _6 = _1 as *const T;\n        _5 = slice::sort::shared::smallsort::sort4_stable::<T, F>(move _6, _3, _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = ptr::mut_ptr::<impl *mut T>::add(_1, 4_usize) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = move _9 as *const T;\n        StorageDead(_9);\n        StorageLive(_10);\n        _10 = ptr::mut_ptr::<impl *mut T>::add(_3, 4_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = slice::sort::shared::smallsort::sort4_stable::<T, F>(move _8, move _10, _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = _3 as *const T;\n        _13 = ptr::slice_from_raw_parts::<T>(move _14, 8_usize) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        _12 = &(*_13);\n        _11 = slice::sort::shared::smallsort::bidirectional_merge::<T, F>(_12, _2, _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " SAFETY: The caller MUST guarantee that `v_base` is valid for 8 reads and\n writes, `scratch_base` and `dst` MUST be valid for 8 writes. The result will\n be stored in `dst[0..8]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}