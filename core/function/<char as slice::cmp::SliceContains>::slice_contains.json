{
  "name": "<char as slice::cmp::SliceContains>::slice_contains",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::chunks_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n beginning of the slice.\n\n The chunks are slices and do not overlap. If `chunk_size` does not divide the length of the\n slice, then the last up to `chunk_size-1` elements will be omitted and can be retrieved\n from the `remainder` function of the iterator.\n\n Due to each chunk having exactly `chunk_size` elements, the compiler can often optimize the\n resulting code better than in the case of [`chunks`].\n\n See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller\n chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice.\n\n If your `chunk_size` is a constant, consider using [`as_chunks`] instead, which will\n give references to arrays of exactly that length, rather than slices.\n\n # Panics\n\n Panics if `chunk_size` is zero.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let mut iter = slice.chunks_exact(2);\n assert_eq!(iter.next().unwrap(), &['l', 'o']);\n assert_eq!(iter.next().unwrap(), &['r', 'e']);\n assert!(iter.next().is_none());\n assert_eq!(iter.remainder(), &['m']);\n ```\n\n [`chunks`]: slice::chunks\n [`rchunks_exact`]: slice::rchunks_exact\n [`as_chunks`]: slice::as_chunks\n",
      "adt": {
        "slice::iter::ChunksExact": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {
        "slice::iter::Iter": "Constructor"
      }
    },
    "slice::iter::ChunksExact::<'a, T>::remainder": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the remainder of the original slice that is not going to be\n returned by the iterator. The returned slice has at most `chunk_size-1`\n elements.\n\n # Example\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let mut iter = slice.chunks_exact(2);\n assert_eq!(iter.remainder(), &['m'][..]);\n assert_eq!(iter.next(), Some(&['l', 'o'][..]));\n assert_eq!(iter.remainder(), &['m'][..]);\n assert_eq!(iter.next(), Some(&['r', 'e'][..]));\n assert_eq!(iter.remainder(), &['m'][..]);\n assert_eq!(iter.next(), None);\n assert_eq!(iter.remainder(), &['m'][..]);\n ```\n",
      "adt": {
        "slice::iter::ChunksExact": "ImmutableAsArgument"
      }
    },
    "iter::traits::iterator::Iterator::fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Folds every element into an accumulator by applying an operation,\n returning the final result.\n\n `fold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `fold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `fold()`, and similar methods that traverse the entire iterator,\n might not terminate for infinite iterators, even on traits for which a\n result is determinable in finite time.\n\n Note: [`reduce()`] can be used to use the first element as the initial\n value, if the accumulator type and item type is the same.\n\n Note: `fold()` combines elements in a *left-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `fold()` on the internal parts\n from which this iterator is composed.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of the array\n let sum = a.iter().fold(0, |acc, x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n Let's walk through each step of the iteration here:\n\n | element | acc | x | result |\n |---------|-----|---|--------|\n |         | 0   |   |        |\n | 1       | 0   | 1 | 1      |\n | 2       | 1   | 2 | 3      |\n | 3       | 3   | 3 | 6      |\n\n And so, our final result, `6`.\n\n This example demonstrates the left-associative nature of `fold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the front until the back:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().fold(zero, |acc, &x| {\n     format!(\"({acc} + {x})\")\n });\n\n assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n ```\n It's common for people who haven't used iterators a lot to\n use a `for` loop with a list of things to build up a result. Those\n can be turned into `fold()`s:\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let mut result = 0;\n\n // for loop:\n for i in &numbers {\n     result = result + i;\n }\n\n // fold:\n let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n // they're the same\n assert_eq!(result, result2);\n ```\n\n [`reduce()`]: Iterator::reduce\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::any": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests if any element of the iterator matches a predicate.\n\n `any()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then so does `any()`. If they all return `false`, it\n returns `false`.\n\n `any()` is short-circuiting; in other words, it will stop processing\n as soon as it finds a `true`, given that no matter what else happens,\n the result will also be `true`.\n\n An empty iterator returns `false`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert!(a.into_iter().any(|x| x > 0));\n\n assert!(!a.into_iter().any(|x| x > 5));\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert!(iter.any(|x| x != 2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(2));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::iter::ChunksExact": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14923, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 14926, kind: RigidTy(Slice(Ty { id: 4458, kind: RigidTy(Char) })) }, Not)) })])"
    ],
    "slice::iter::Iter": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 1459,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:403:17: 416:18",
  "src": "fn slice_contains(&self, arr: &[$t]) -> bool {\n                    // Make our LANE_COUNT 4x the normal lane count (aiming for 128 bit vectors).\n                    // The compiler will nicely unroll it.\n                    const LANE_COUNT: usize = 4 * (128 / (size_of::<$t>() * 8));\n                    // SIMD\n                    let mut chunks = arr.chunks_exact(LANE_COUNT);\n                    for chunk in &mut chunks {\n                        if chunk.iter().fold(false, |acc, x| acc | (*x == *self)) {\n                            return true;\n                        }\n                    }\n                    // Scalar remainder\n                    return chunks.remainder().iter().any(|x| *x == *self);\n                }",
  "mir": "fn <char as slice::cmp::SliceContains>::slice_contains(_1: &char, _2: &[char]) -> bool {\n    let mut _0: bool;\n    let mut _3: slice::iter::ChunksExact<'_, char>;\n    let mut _4: &mut slice::iter::ChunksExact<'_, char>;\n    let mut _5: &mut slice::iter::ChunksExact<'_, char>;\n    let mut _6: &mut slice::iter::ChunksExact<'_, char>;\n    let mut _7: option::Option<&[char]>;\n    let mut _8: &mut &mut slice::iter::ChunksExact<'_, char>;\n    let mut _9: isize;\n    let  _10: &[char];\n    let mut _11: bool;\n    let mut _12: slice::iter::Iter<'_, char>;\n    let mut _13: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:410:53: 410:61};\n    let mut _14: &mut slice::iter::Iter<'_, char>;\n    let mut _15: slice::iter::Iter<'_, char>;\n    let  _16: &[char];\n    let mut _17: &slice::iter::ChunksExact<'_, char>;\n    let mut _18: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:415:58: 415:61};\n    debug self => _1;\n    debug arr => _2;\n    debug chunks => _3;\n    debug iter => _6;\n    debug chunk => _10;\n    bb0: {\n        StorageLive(_3);\n        _3 = slice::<impl [char]>::chunks_exact(_2, <char as slice::cmp::SliceContains>::slice_contains::LANE_COUNT) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _3;\n        _4 = <&mut slice::iter::ChunksExact<'_, char> as iter::traits::collect::IntoIterator>::into_iter(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = move _4;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_7);\n        _8 = &mut _6;\n        _7 = <&mut slice::iter::ChunksExact<'_, char> as iter::traits::iterator::Iterator>::next(_8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb7, 1: bb6, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _10 = ((_7 as variant#1).0: &[char]);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = slice::<impl [char]>::iter(_10) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_17);\n        _17 = &_3;\n        _16 = slice::iter::ChunksExact::<'_, char>::remainder(move _17) -> [return: bb12, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_13);\n        _13 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:410:53: 410:61}(_1);\n        _11 = <slice::iter::Iter<'_, char> as iter::traits::iterator::Iterator>::fold::<bool, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:410:53: 410:61}>(move _12, false, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _11) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _0 = true;\n        StorageDead(_11);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb15;\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_7);\n        goto -> bb3;\n    }\n    bb12: {\n        StorageDead(_17);\n        _15 = slice::<impl [char]>::iter(_16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _14 = &mut _15;\n        StorageLive(_18);\n        _18 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:415:58: 415:61}(_1);\n        _0 = <slice::iter::Iter<'_, char> as iter::traits::iterator::Iterator>::any::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:415:58: 415:61}>(move _14, move _18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageDead(_14);\n        StorageDead(_15);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}