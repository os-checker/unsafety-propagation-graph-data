{
  "name": "future::poll_fn::poll_fn",
  "safe": true,
  "callees": {},
  "adts": {
    "future::poll_fn::PollFn": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::future::poll_fn::poll_fn"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/future/poll_fn.rs:115:1: 120:2",
  "src": "pub fn poll_fn<T, F>(f: F) -> PollFn<F>\nwhere\n    F: FnMut(&mut Context<'_>) -> Poll<T>,\n{\n    PollFn { f }\n}",
  "mir": "fn future::poll_fn::poll_fn(_1: F) -> future::poll_fn::PollFn<F> {\n    let mut _0: future::poll_fn::PollFn<F>;\n    debug f => _1;\n    bb0: {\n        _0 = PollFn(_1);\n        return;\n    }\n}\n",
  "doc": " Creates a future that wraps a function returning [`Poll`].\n\n Polling the future delegates to the wrapped function. If the returned future is pinned, then the\n captured environment of the wrapped function is also pinned in-place, so as long as the closure\n does not move out of its captures it can soundly create pinned references to them.\n\n # Examples\n\n ```\n # async fn run() {\n use core::future::poll_fn;\n use std::task::{Context, Poll};\n\n fn read_line(_cx: &mut Context<'_>) -> Poll<String> {\n     Poll::Ready(\"Hello, World!\".into())\n }\n\n let read_future = poll_fn(read_line);\n assert_eq!(read_future.await, \"Hello, World!\".to_owned());\n # }\n ```\n\n ## Capturing a pinned state\n\n Example of a closure wrapping inner futures:\n\n ```\n # async fn run() {\n use core::future::{self, Future};\n use core::task::Poll;\n\n /// Resolves to the first future that completes. In the event of a tie, `a` wins.\n fn naive_select<T>(\n     a: impl Future<Output = T>,\n     b: impl Future<Output = T>,\n ) -> impl Future<Output = T>\n {\n     let (mut a, mut b) = (Box::pin(a), Box::pin(b));\n     future::poll_fn(move |cx| {\n         if let Poll::Ready(r) = a.as_mut().poll(cx) {\n             Poll::Ready(r)\n         } else if let Poll::Ready(r) = b.as_mut().poll(cx) {\n             Poll::Ready(r)\n         } else {\n             Poll::Pending\n         }\n     })\n }\n\n let a = async { 42 };\n let b = future::pending();\n let v = naive_select(a, b).await;\n assert_eq!(v, 42);\n\n let a = future::pending();\n let b = async { 27 };\n let v = naive_select(a, b).await;\n assert_eq!(v, 27);\n\n let a = async { 42 };\n let b = async { 27 };\n let v = naive_select(a, b).await;\n assert_eq!(v, 42); // biased towards `a` in case of tie!\n # }\n ```\n\n This time without [`Box::pin`]ning:\n\n [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin\n\n ```\n # async fn run() {\n use core::future::{self, Future};\n use core::pin::pin;\n use core::task::Poll;\n\n /// Resolves to the first future that completes. In the event of a tie, `a` wins.\n fn naive_select<T>(\n     a: impl Future<Output = T>,\n     b: impl Future<Output = T>,\n ) -> impl Future<Output = T>\n {\n     async {\n         let (mut a, mut b) = (pin!(a), pin!(b));\n         future::poll_fn(move |cx| {\n             if let Poll::Ready(r) = a.as_mut().poll(cx) {\n                 Poll::Ready(r)\n             } else if let Poll::Ready(r) = b.as_mut().poll(cx) {\n                 Poll::Ready(r)\n             } else {\n                 Poll::Pending\n             }\n         }).await\n     }\n }\n\n let a = async { 42 };\n let b = future::pending();\n let v = naive_select(a, b).await;\n assert_eq!(v, 42);\n # }\n ```\n\n   - Notice how, by virtue of being in an `async` context, we have been able to make the [`pin!`]\n     macro work, thereby avoiding any need for the `unsafe`\n     <code>[Pin::new_unchecked](&mut fut)</code> constructor.\n\n [`pin!`]: crate::pin::pin!\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}