{
  "name": "slice::<impl [T]>::select_nth_unstable",
  "safe": true,
  "callees": {
    "slice::sort::select::partition_at_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reorders the slice such that the element at `index` is at its final sorted position.\n",
      "adt": {}
    },
    "cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::select_nth_unstable"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3300:5: 3305:6",
  "src": "pub fn select_nth_unstable(&mut self, index: usize) -> (&mut [T], &mut T, &mut [T])\n    where\n        T: Ord,\n    {\n        sort::select::partition_at_index(self, index, T::lt)\n    }",
  "mir": "fn slice::<impl [T]>::select_nth_unstable(_1: &mut [T], _2: usize) -> (&mut [T], &mut T, &mut [T]) {\n    let mut _0: (&mut [T], &mut T, &mut [T]);\n    debug self => _1;\n    debug index => _2;\n    bb0: {\n        _0 = slice::sort::select::partition_at_index::<T, for<'a, 'b> fn(&'a T, &'b T) -> bool {<T as cmp::PartialOrd>::lt}>(_1, _2, <T as cmp::PartialOrd>::lt) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Reorders the slice such that the element at `index` is at a sort-order position. All\n elements before `index` will be `<=` to this value, and all elements after will be `>=` to\n it.\n\n This reordering is unstable (i.e. any element that compares equal to the nth element may end\n up at that position), in-place (i.e.  does not allocate), and runs in *O*(*n*) time. This\n function is also known as \"kth element\" in other libraries.\n\n Returns a triple that partitions the reordered slice:\n\n * The unsorted subslice before `index`, whose elements all satisfy `x <= self[index]`.\n\n * The element at `index`.\n\n * The unsorted subslice after `index`, whose elements all satisfy `x >= self[index]`.\n\n # Current implementation\n\n The current algorithm is an introselect implementation based on [ipnsort] by Lukas Bergdoll\n and Orson Peters, which is also the basis for [`sort_unstable`]. The fallback algorithm is\n Median of Medians using Tukey's Ninther for pivot selection, which guarantees linear runtime\n for all inputs.\n\n [`sort_unstable`]: slice::sort_unstable\n\n # Panics\n\n Panics when `index >= len()`, and so always panics on empty slices.\n\n May panic if the implementation of [`Ord`] for `T` does not implement a [total order].\n\n # Examples\n\n ```\n let mut v = [-5i32, 4, 2, -3, 1];\n\n // Find the items `<=` to the median, the median itself, and the items `>=` to it.\n let (lesser, median, greater) = v.select_nth_unstable(2);\n\n assert!(lesser == [-3, -5] || lesser == [-5, -3]);\n assert_eq!(median, &mut 1);\n assert!(greater == [4, 2] || greater == [2, 4]);\n\n // We are only guaranteed the slice will be one of the following, based on the way we sort\n // about the specified index.\n assert!(v == [-3, -5, 1, 2, 4] ||\n         v == [-5, -3, 1, 2, 4] ||\n         v == [-3, -5, 1, 4, 2] ||\n         v == [-5, -3, 1, 4, 2]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}