{
  "name": "slice::sort::shared::smallsort::sort9_optimal",
  "safe": true,
  "callees": {
    "intrinsics::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the execution of the process.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n as its behavior is more user-friendly and more stable.\n\n The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n on most platforms.\n On Unix, the\n process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n `SIGBUS`.  The precise behavior is not guaranteed and not stable.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::swap_if_less": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swap two values in the slice pointed to by `v_base` at the position `a_pos` and `b_pos` if the\n value at position `b_pos` is less than the one at position `a_pos`.\n\n Purposefully not marked `#[inline]`, despite us wanting it to be inlined for integers like\n types. `is_less` could be a huge function and we want to give the compiler an option to\n not inline this function. For the same reasons that this function is very perf critical\n it should be in the same module as the functions that use it.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 16682,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:426:1: 467:2",
  "src": "fn sort9_optimal<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    if v.len() < 9 {\n        intrinsics::abort();\n    }\n\n    let v_base = v.as_mut_ptr();\n\n    // Optimal sorting network see:\n    // https://bertdobbelaere.github.io/sorting_networks.html.\n\n    // SAFETY: We checked the len.\n    unsafe {\n        swap_if_less(v_base, 0, 3, is_less);\n        swap_if_less(v_base, 1, 7, is_less);\n        swap_if_less(v_base, 2, 5, is_less);\n        swap_if_less(v_base, 4, 8, is_less);\n        swap_if_less(v_base, 0, 7, is_less);\n        swap_if_less(v_base, 2, 4, is_less);\n        swap_if_less(v_base, 3, 8, is_less);\n        swap_if_less(v_base, 5, 6, is_less);\n        swap_if_less(v_base, 0, 2, is_less);\n        swap_if_less(v_base, 1, 3, is_less);\n        swap_if_less(v_base, 4, 5, is_less);\n        swap_if_less(v_base, 7, 8, is_less);\n        swap_if_less(v_base, 1, 4, is_less);\n        swap_if_less(v_base, 3, 6, is_less);\n        swap_if_less(v_base, 5, 7, is_less);\n        swap_if_less(v_base, 0, 1, is_less);\n        swap_if_less(v_base, 2, 4, is_less);\n        swap_if_less(v_base, 3, 5, is_less);\n        swap_if_less(v_base, 6, 8, is_less);\n        swap_if_less(v_base, 2, 3, is_less);\n        swap_if_less(v_base, 4, 5, is_less);\n        swap_if_less(v_base, 6, 7, is_less);\n        swap_if_less(v_base, 1, 2, is_less);\n        swap_if_less(v_base, 3, 4, is_less);\n        swap_if_less(v_base, 5, 6, is_less);\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::sort9_optimal(_1: &mut [T], _2: &mut F) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &[T];\n    let  _6: !;\n    let  _7: *mut T;\n    let  _8: ();\n    let  _9: ();\n    let  _10: ();\n    let  _11: ();\n    let  _12: ();\n    let  _13: ();\n    let  _14: ();\n    let  _15: ();\n    let  _16: ();\n    let  _17: ();\n    let  _18: ();\n    let  _19: ();\n    let  _20: ();\n    let  _21: ();\n    let  _22: ();\n    let  _23: ();\n    let  _24: ();\n    let  _25: ();\n    let  _26: ();\n    let  _27: ();\n    let  _28: ();\n    let  _29: ();\n    let  _30: ();\n    let  _31: ();\n    let  _32: ();\n    debug v => _1;\n    debug is_less => _2;\n    debug v_base => _7;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _3 = Lt(move _4, 9_usize);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        _6 = intrinsics::abort() -> unwind unreachable;\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        _7 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 0_usize, 3_usize, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 1_usize, 7_usize, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 2_usize, 5_usize, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 4_usize, 8_usize, _2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 0_usize, 7_usize, _2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _13 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 2_usize, 4_usize, _2) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _14 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 3_usize, 8_usize, _2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _15 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 5_usize, 6_usize, _2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _16 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 0_usize, 2_usize, _2) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _17 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 1_usize, 3_usize, _2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 4_usize, 5_usize, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _19 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 7_usize, 8_usize, _2) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 1_usize, 4_usize, _2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _21 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 3_usize, 6_usize, _2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _22 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 5_usize, 7_usize, _2) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _23 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 0_usize, 1_usize, _2) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _24 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 2_usize, 4_usize, _2) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _25 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 3_usize, 5_usize, _2) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _26 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 6_usize, 8_usize, _2) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _27 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 2_usize, 3_usize, _2) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _28 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 4_usize, 5_usize, _2) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _29 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 6_usize, 7_usize, _2) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _30 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 1_usize, 2_usize, _2) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _31 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 3_usize, 4_usize, _2) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _32 = slice::sort::shared::smallsort::swap_if_less::<T, F>(_7, 5_usize, 6_usize, _2) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": " Sorts the first 9 elements of `v` with a fast fixed function.\n\n Should `is_less` generate substantial amounts of code the compiler can choose to not inline\n `swap_if_less`. If the code of a sort impl changes so as to call this function in multiple\n places, `#[inline(never)]` is recommended to keep binary-size in check. The current design of\n `small_sort_network` makes sure to only call this once.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}