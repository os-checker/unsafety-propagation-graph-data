{
  "name": "num::dec2flt::decimal_seq::number_of_digits_decimal_left_shift",
  "safe": true,
  "callees": {
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {
        "slice::iter::Iter": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::enumerate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which gives the current iteration count as well as\n the next value.\n\n The iterator returned yields pairs `(i, val)`, where `i` is the\n current index of iteration and `val` is the value returned by the\n iterator.\n\n `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n different sized integer, the [`zip`] function provides similar\n functionality.\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so enumerating more than\n [`usize::MAX`] elements either produces the wrong result or panics. If\n overflow checks are enabled, a panic is guaranteed.\n\n # Panics\n\n The returned iterator might panic if the to-be-returned index would\n overflow a [`usize`].\n\n [`zip`]: Iterator::zip\n\n # Examples\n\n ```\n let a = ['a', 'b', 'c'];\n\n let mut iter = a.into_iter().enumerate();\n\n assert_eq!(iter.next(), Some((0, 'a')));\n assert_eq!(iter.next(), Some((1, 'b')));\n assert_eq!(iter.next(), Some((2, 'c')));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {
        "iter::adapters::enumerate::Enumerate": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that yields the first `n` elements, or fewer\n if the underlying iterator ends sooner.\n\n `take(n)` yields elements until `n` elements are yielded or the end of\n the iterator is reached (whichever happens first).\n The returned iterator is a prefix of length `n` if the original iterator\n contains at least `n` elements, otherwise it contains all of the\n (fewer than `n`) elements of the original iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().take(2);\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n `take()` is often used with an infinite iterator, to make it finite:\n\n ```\n let mut iter = (0..).take(3);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n If less than `n` elements are available,\n `take` will limit itself to the size of the underlying iterator:\n\n ```\n let v = [1, 2];\n let mut iter = v.into_iter().take(5);\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Use [`by_ref`] to take from the iterator without consuming it, and then\n continue using the original iterator:\n\n ```\n let mut words = [\"hello\", \"world\", \"of\", \"Rust\"].into_iter();\n\n // Take the first two words.\n let hello_world: Vec<_> = words.by_ref().take(2).collect();\n assert_eq!(hello_world, vec![\"hello\", \"world\"]);\n\n // Collect the rest of the words.\n // We can only do this because we used `by_ref` earlier.\n let of_rust: Vec<_> = words.collect();\n assert_eq!(of_rust, vec![\"of\", \"Rust\"]);\n ```\n\n [`by_ref`]: Iterator::by_ref\n",
      "adt": {
        "iter::adapters::take::Take": "Constructor"
      }
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::RangeFrom": [
      "Plain"
    ],
    "slice::iter::Iter": [
      "Plain"
    ],
    "iter::adapters::enumerate::Enumerate": [
      "Plain"
    ],
    "iter::adapters::take::Take": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 581, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) }])) }), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 581, kind: RigidTy(Tuple([Ty { id: 47, kind: RigidTy(Uint(Usize)) }, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) }])) }), Field(1, Ty { id: 447, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 46, kind: RigidTy(Uint(U8)) }, Not)) })])"
    ],
    "num::dec2flt::decimal_seq::DecimalSeq": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::dec2flt::decimal_seq::number_of_digits_decimal_left_shift"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/dec2flt/decimal_seq.rs:300:1: 379:2",
  "src": "fn number_of_digits_decimal_left_shift(d: &DecimalSeq, mut shift: usize) -> usize {\n    #[rustfmt::skip]\n    const TABLE: [u16; 65] = [\n        0x0000, 0x0800, 0x0801, 0x0803, 0x1006, 0x1009, 0x100D, 0x1812, 0x1817, 0x181D, 0x2024,\n        0x202B, 0x2033, 0x203C, 0x2846, 0x2850, 0x285B, 0x3067, 0x3073, 0x3080, 0x388E, 0x389C,\n        0x38AB, 0x38BB, 0x40CC, 0x40DD, 0x40EF, 0x4902, 0x4915, 0x4929, 0x513E, 0x5153, 0x5169,\n        0x5180, 0x5998, 0x59B0, 0x59C9, 0x61E3, 0x61FD, 0x6218, 0x6A34, 0x6A50, 0x6A6D, 0x6A8B,\n        0x72AA, 0x72C9, 0x72E9, 0x7B0A, 0x7B2B, 0x7B4D, 0x8370, 0x8393, 0x83B7, 0x83DC, 0x8C02,\n        0x8C28, 0x8C4F, 0x9477, 0x949F, 0x94C8, 0x9CF2, 0x051C, 0x051C, 0x051C, 0x051C,\n    ];\n    #[rustfmt::skip]\n    const TABLE_POW5: [u8; 0x051C] = [\n        5, 2, 5, 1, 2, 5, 6, 2, 5, 3, 1, 2, 5, 1, 5, 6, 2, 5, 7, 8, 1, 2, 5, 3, 9, 0, 6, 2, 5, 1,\n        9, 5, 3, 1, 2, 5, 9, 7, 6, 5, 6, 2, 5, 4, 8, 8, 2, 8, 1, 2, 5, 2, 4, 4, 1, 4, 0, 6, 2, 5,\n        1, 2, 2, 0, 7, 0, 3, 1, 2, 5, 6, 1, 0, 3, 5, 1, 5, 6, 2, 5, 3, 0, 5, 1, 7, 5, 7, 8, 1, 2,\n        5, 1, 5, 2, 5, 8, 7, 8, 9, 0, 6, 2, 5, 7, 6, 2, 9, 3, 9, 4, 5, 3, 1, 2, 5, 3, 8, 1, 4, 6,\n        9, 7, 2, 6, 5, 6, 2, 5, 1, 9, 0, 7, 3, 4, 8, 6, 3, 2, 8, 1, 2, 5, 9, 5, 3, 6, 7, 4, 3, 1,\n        6, 4, 0, 6, 2, 5, 4, 7, 6, 8, 3, 7, 1, 5, 8, 2, 0, 3, 1, 2, 5, 2, 3, 8, 4, 1, 8, 5, 7, 9,\n        1, 0, 1, 5, 6, 2, 5, 1, 1, 9, 2, 0, 9, 2, 8, 9, 5, 5, 0, 7, 8, 1, 2, 5, 5, 9, 6, 0, 4, 6,\n        4, 4, 7, 7, 5, 3, 9, 0, 6, 2, 5, 2, 9, 8, 0, 2, 3, 2, 2, 3, 8, 7, 6, 9, 5, 3, 1, 2, 5, 1,\n        4, 9, 0, 1, 1, 6, 1, 1, 9, 3, 8, 4, 7, 6, 5, 6, 2, 5, 7, 4, 5, 0, 5, 8, 0, 5, 9, 6, 9, 2,\n        3, 8, 2, 8, 1, 2, 5, 3, 7, 2, 5, 2, 9, 0, 2, 9, 8, 4, 6, 1, 9, 1, 4, 0, 6, 2, 5, 1, 8, 6,\n        2, 6, 4, 5, 1, 4, 9, 2, 3, 0, 9, 5, 7, 0, 3, 1, 2, 5, 9, 3, 1, 3, 2, 2, 5, 7, 4, 6, 1, 5,\n        4, 7, 8, 5, 1, 5, 6, 2, 5, 4, 6, 5, 6, 6, 1, 2, 8, 7, 3, 0, 7, 7, 3, 9, 2, 5, 7, 8, 1, 2,\n        5, 2, 3, 2, 8, 3, 0, 6, 4, 3, 6, 5, 3, 8, 6, 9, 6, 2, 8, 9, 0, 6, 2, 5, 1, 1, 6, 4, 1, 5,\n        3, 2, 1, 8, 2, 6, 9, 3, 4, 8, 1, 4, 4, 5, 3, 1, 2, 5, 5, 8, 2, 0, 7, 6, 6, 0, 9, 1, 3, 4,\n        6, 7, 4, 0, 7, 2, 2, 6, 5, 6, 2, 5, 2, 9, 1, 0, 3, 8, 3, 0, 4, 5, 6, 7, 3, 3, 7, 0, 3, 6,\n        1, 3, 2, 8, 1, 2, 5, 1, 4, 5, 5, 1, 9, 1, 5, 2, 2, 8, 3, 6, 6, 8, 5, 1, 8, 0, 6, 6, 4, 0,\n        6, 2, 5, 7, 2, 7, 5, 9, 5, 7, 6, 1, 4, 1, 8, 3, 4, 2, 5, 9, 0, 3, 3, 2, 0, 3, 1, 2, 5, 3,\n        6, 3, 7, 9, 7, 8, 8, 0, 7, 0, 9, 1, 7, 1, 2, 9, 5, 1, 6, 6, 0, 1, 5, 6, 2, 5, 1, 8, 1, 8,\n        9, 8, 9, 4, 0, 3, 5, 4, 5, 8, 5, 6, 4, 7, 5, 8, 3, 0, 0, 7, 8, 1, 2, 5, 9, 0, 9, 4, 9, 4,\n        7, 0, 1, 7, 7, 2, 9, 2, 8, 2, 3, 7, 9, 1, 5, 0, 3, 9, 0, 6, 2, 5, 4, 5, 4, 7, 4, 7, 3, 5,\n        0, 8, 8, 6, 4, 6, 4, 1, 1, 8, 9, 5, 7, 5, 1, 9, 5, 3, 1, 2, 5, 2, 2, 7, 3, 7, 3, 6, 7, 5,\n        4, 4, 3, 2, 3, 2, 0, 5, 9, 4, 7, 8, 7, 5, 9, 7, 6, 5, 6, 2, 5, 1, 1, 3, 6, 8, 6, 8, 3, 7,\n        7, 2, 1, 6, 1, 6, 0, 2, 9, 7, 3, 9, 3, 7, 9, 8, 8, 2, 8, 1, 2, 5, 5, 6, 8, 4, 3, 4, 1, 8,\n        8, 6, 0, 8, 0, 8, 0, 1, 4, 8, 6, 9, 6, 8, 9, 9, 4, 1, 4, 0, 6, 2, 5, 2, 8, 4, 2, 1, 7, 0,\n        9, 4, 3, 0, 4, 0, 4, 0, 0, 7, 4, 3, 4, 8, 4, 4, 9, 7, 0, 7, 0, 3, 1, 2, 5, 1, 4, 2, 1, 0,\n        8, 5, 4, 7, 1, 5, 2, 0, 2, 0, 0, 3, 7, 1, 7, 4, 2, 2, 4, 8, 5, 3, 5, 1, 5, 6, 2, 5, 7, 1,\n        0, 5, 4, 2, 7, 3, 5, 7, 6, 0, 1, 0, 0, 1, 8, 5, 8, 7, 1, 1, 2, 4, 2, 6, 7, 5, 7, 8, 1, 2,\n        5, 3, 5, 5, 2, 7, 1, 3, 6, 7, 8, 8, 0, 0, 5, 0, 0, 9, 2, 9, 3, 5, 5, 6, 2, 1, 3, 3, 7, 8,\n        9, 0, 6, 2, 5, 1, 7, 7, 6, 3, 5, 6, 8, 3, 9, 4, 0, 0, 2, 5, 0, 4, 6, 4, 6, 7, 7, 8, 1, 0,\n        6, 6, 8, 9, 4, 5, 3, 1, 2, 5, 8, 8, 8, 1, 7, 8, 4, 1, 9, 7, 0, 0, 1, 2, 5, 2, 3, 2, 3, 3,\n        8, 9, 0, 5, 3, 3, 4, 4, 7, 2, 6, 5, 6, 2, 5, 4, 4, 4, 0, 8, 9, 2, 0, 9, 8, 5, 0, 0, 6, 2,\n        6, 1, 6, 1, 6, 9, 4, 5, 2, 6, 6, 7, 2, 3, 6, 3, 2, 8, 1, 2, 5, 2, 2, 2, 0, 4, 4, 6, 0, 4,\n        9, 2, 5, 0, 3, 1, 3, 0, 8, 0, 8, 4, 7, 2, 6, 3, 3, 3, 6, 1, 8, 1, 6, 4, 0, 6, 2, 5, 1, 1,\n        1, 0, 2, 2, 3, 0, 2, 4, 6, 2, 5, 1, 5, 6, 5, 4, 0, 4, 2, 3, 6, 3, 1, 6, 6, 8, 0, 9, 0, 8,\n        2, 0, 3, 1, 2, 5, 5, 5, 5, 1, 1, 1, 5, 1, 2, 3, 1, 2, 5, 7, 8, 2, 7, 0, 2, 1, 1, 8, 1, 5,\n        8, 3, 4, 0, 4, 5, 4, 1, 0, 1, 5, 6, 2, 5, 2, 7, 7, 5, 5, 5, 7, 5, 6, 1, 5, 6, 2, 8, 9, 1,\n        3, 5, 1, 0, 5, 9, 0, 7, 9, 1, 7, 0, 2, 2, 7, 0, 5, 0, 7, 8, 1, 2, 5, 1, 3, 8, 7, 7, 7, 8,\n        7, 8, 0, 7, 8, 1, 4, 4, 5, 6, 7, 5, 5, 2, 9, 5, 3, 9, 5, 8, 5, 1, 1, 3, 5, 2, 5, 3, 9, 0,\n        6, 2, 5, 6, 9, 3, 8, 8, 9, 3, 9, 0, 3, 9, 0, 7, 2, 2, 8, 3, 7, 7, 6, 4, 7, 6, 9, 7, 9, 2,\n        5, 5, 6, 7, 6, 2, 6, 9, 5, 3, 1, 2, 5, 3, 4, 6, 9, 4, 4, 6, 9, 5, 1, 9, 5, 3, 6, 1, 4, 1,\n        8, 8, 8, 2, 3, 8, 4, 8, 9, 6, 2, 7, 8, 3, 8, 1, 3, 4, 7, 6, 5, 6, 2, 5, 1, 7, 3, 4, 7, 2,\n        3, 4, 7, 5, 9, 7, 6, 8, 0, 7, 0, 9, 4, 4, 1, 1, 9, 2, 4, 4, 8, 1, 3, 9, 1, 9, 0, 6, 7, 3,\n        8, 2, 8, 1, 2, 5, 8, 6, 7, 3, 6, 1, 7, 3, 7, 9, 8, 8, 4, 0, 3, 5, 4, 7, 2, 0, 5, 9, 6, 2,\n        2, 4, 0, 6, 9, 5, 9, 5, 3, 3, 6, 9, 1, 4, 0, 6, 2, 5,\n    ];\n\n    shift &= 63;\n    let x_a = TABLE[shift];\n    let x_b = TABLE[shift + 1];\n    let num_new_digits = (x_a >> 11) as _;\n    let pow5_a = (0x7FF & x_a) as usize;\n    let pow5_b = (0x7FF & x_b) as usize;\n    let pow5 = &TABLE_POW5[pow5_a..];\n\n    for (i, &p5) in pow5.iter().enumerate().take(pow5_b - pow5_a) {\n        if i >= d.num_digits {\n            return num_new_digits - 1;\n        } else if d.digits[i] == p5 {\n            continue;\n        } else if d.digits[i] < p5 {\n            return num_new_digits - 1;\n        } else {\n            return num_new_digits;\n        }\n    }\n\n    num_new_digits\n}",
  "mir": "fn num::dec2flt::decimal_seq::number_of_digits_decimal_left_shift(_1: &num::dec2flt::decimal_seq::DecimalSeq, _2: usize) -> usize {\n    let mut _0: usize;\n    let  _3: u16;\n    let mut _4: [u16; 65];\n    let  _5: usize;\n    let mut _6: bool;\n    let  _7: u16;\n    let mut _8: [u16; 65];\n    let  _9: usize;\n    let mut _10: usize;\n    let mut _11: (usize, bool);\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: u16;\n    let mut _15: u32;\n    let mut _16: bool;\n    let  _17: usize;\n    let mut _18: u16;\n    let  _19: usize;\n    let mut _20: u16;\n    let  _21: &[u8];\n    let mut _22: &[u8; 1308];\n    let mut _23: ops::range::RangeFrom<usize>;\n    let mut _24: iter::adapters::take::Take<iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>>;\n    let mut _25: iter::adapters::take::Take<iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>>;\n    let mut _26: iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>;\n    let mut _27: slice::iter::Iter<'_, u8>;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let mut _30: iter::adapters::take::Take<iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>>;\n    let mut _31: option::Option<(usize, &u8)>;\n    let mut _32: &mut iter::adapters::take::Take<iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>>;\n    let mut _33: isize;\n    let  _34: usize;\n    let  _35: u8;\n    let mut _36: bool;\n    let mut _37: usize;\n    let mut _38: (usize, bool);\n    let mut _39: bool;\n    let mut _40: u8;\n    let mut _41: bool;\n    let mut _42: bool;\n    let mut _43: u8;\n    let mut _44: bool;\n    let mut _45: (usize, bool);\n    let mut _46: &u8;\n    debug d => _1;\n    debug shift => _2;\n    debug x_a => _3;\n    debug x_b => _7;\n    debug num_new_digits => _13;\n    debug pow5_a => _17;\n    debug pow5_b => _19;\n    debug pow5 => _21;\n    debug iter => _30;\n    debug i => _34;\n    debug p5 => _35;\n    bb0: {\n        _2 = BitAnd(_2, 63_usize);\n        StorageLive(_4);\n        _4 = num::dec2flt::decimal_seq::number_of_digits_decimal_left_shift::TABLE;\n        StorageLive(_5);\n        _5 = _2;\n        _6 = Lt(_5, 65_usize);\n        assert(move _6, \"index out of bounds: the length is {} but the index is {}\", 65_usize, _5) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = _4[_5];\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_8);\n        _8 = num::dec2flt::decimal_seq::number_of_digits_decimal_left_shift::TABLE;\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _2;\n        _11 = CheckedAdd(_10, 1_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _10, 1_usize) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _9 = move (_11.0: usize);\n        StorageDead(_10);\n        _12 = Lt(_9, 65_usize);\n        assert(move _12, \"index out of bounds: the length is {} but the index is {}\", 65_usize, _9) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = _8[_9];\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_14);\n        _15 = 11_i32 as u32;\n        _16 = Lt(move _15, 16_u32);\n        assert(move _16, \"attempt to shift right by `{}`, which would overflow\", 11_i32) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _14 = Shr(_3, 11_i32);\n        _13 = move _14 as usize;\n        StorageDead(_14);\n        StorageLive(_18);\n        _18 = BitAnd(2047_u16, _3);\n        _17 = move _18 as usize;\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = BitAnd(2047_u16, _7);\n        _19 = move _20 as usize;\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = num::dec2flt::decimal_seq::number_of_digits_decimal_left_shift::promoted[0];\n        StorageLive(_23);\n        _23 = RangeFrom(_17);\n        _21 = <[u8; 1308] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(move _22, move _23) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = slice::<impl [u8]>::iter(_21) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _26 = <slice::iter::Iter<'_, u8> as iter::traits::iterator::Iterator>::enumerate(move _27) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_27);\n        StorageLive(_28);\n        _29 = CheckedSub(_19, _17);\n        assert(!move (_29.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _19, _17) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _28 = move (_29.0: usize);\n        _25 = <iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>> as iter::traits::iterator::Iterator>::take(move _26, move _28) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_28);\n        StorageDead(_26);\n        _24 = <iter::adapters::take::Take<iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>> as iter::traits::collect::IntoIterator>::into_iter(move _25) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_25);\n        StorageLive(_30);\n        _30 = move _24;\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_31);\n        _32 = &mut _30;\n        _31 = <iter::adapters::take::Take<iter::adapters::enumerate::Enumerate<slice::iter::Iter<'_, u8>>> as iter::traits::iterator::Iterator>::next(_32) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _33 = discriminant(_31);\n        switchInt(move _33) -> [0: bb15, 1: bb14, otherwise: bb13];\n    }\n    bb13: {\n        unreachable;\n    }\n    bb14: {\n        _34 = (((_31 as variant#1).0: (usize, &u8)).0: usize);\n        _46 = (((_31 as variant#1).0: (usize, &u8)).1: &u8);\n        _35 = (*_46);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = ((*_1).0: usize);\n        _36 = Ge(_34, move _37);\n        switchInt(move _36) -> [0: bb18, otherwise: bb16];\n    }\n    bb15: {\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_24);\n        _0 = _13;\n        goto -> bb28;\n    }\n    bb16: {\n        StorageDead(_37);\n        _38 = CheckedSub(_13, 1_usize);\n        assert(!move (_38.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _13, 1_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _0 = move (_38.0: usize);\n        goto -> bb27;\n    }\n    bb18: {\n        StorageDead(_37);\n        StorageLive(_39);\n        StorageLive(_40);\n        _41 = Lt(_34, 768_usize);\n        assert(move _41, \"index out of bounds: the length is {} but the index is {}\", 768_usize, _34) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _40 = ((*_1).3: [u8; 768])[_34];\n        _39 = Eq(move _40, _35);\n        switchInt(move _39) -> [0: bb21, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_36);\n        StorageDead(_31);\n        goto -> bb11;\n    }\n    bb21: {\n        StorageDead(_40);\n        StorageLive(_42);\n        StorageLive(_43);\n        _44 = Lt(_34, 768_usize);\n        assert(move _44, \"index out of bounds: the length is {} but the index is {}\", 768_usize, _34) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _43 = ((*_1).3: [u8; 768])[_34];\n        _42 = Lt(move _43, _35);\n        switchInt(move _42) -> [0: bb25, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_43);\n        _45 = CheckedSub(_13, 1_usize);\n        assert(!move (_45.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _13, 1_usize) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _0 = move (_45.0: usize);\n        goto -> bb26;\n    }\n    bb25: {\n        StorageDead(_43);\n        _0 = _13;\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_42);\n        StorageDead(_39);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_36);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_24);\n        goto -> bb28;\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}