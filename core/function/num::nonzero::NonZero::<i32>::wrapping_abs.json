{
  "name": "num::nonzero::NonZero::<i32>::wrapping_abs",
  "safe": true,
  "callees": {
    "num::nonzero::NonZero::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained value as a primitive type.\n",
      "adt": {}
    },
    "num::<impl i32>::wrapping_abs": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n the boundary of the type.\n\n The only case where such wrapping can occur is when one takes the absolute value of the negative\n minimal value for the type; this is a positive value that is too large to represent in the type. In\n such a case, this function returns `MIN` itself.\n\n # Examples\n\n ```\n assert_eq!((-128i8).wrapping_abs() as u8, 128);\n ```\n",
      "adt": {}
    },
    "num::nonzero::NonZero::<T>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero without checking whether the value is non-zero.\n This results in undefined behavior if the value is zero.\n\n # Safety\n\n The value must not be zero.\n",
      "adt": {
        "num::nonzero::NonZero": "Constructor"
      }
    }
  },
  "adts": {
    "num::nonzero::NonZero": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::nonzero::NonZero::<i32>::wrapping_abs"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/nonzero.rs:2014:9: 2017:10",
  "src": "pub const fn wrapping_abs(self) -> Self {\n            // SAFETY: absolute value of nonzero cannot yield zero values.\n            unsafe { Self::new_unchecked(self.get().wrapping_abs()) }\n        }",
  "mir": "fn num::nonzero::NonZero::<i32>::wrapping_abs(_1: num::nonzero::NonZero<i32>) -> num::nonzero::NonZero<i32> {\n    let mut _0: num::nonzero::NonZero<i32>;\n    let mut _2: i32;\n    let mut _3: i32;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = num::nonzero::NonZero::<i32>::get(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = num::<impl i32>::wrapping_abs(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = num::nonzero::NonZero::<i32>::new_unchecked(move _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Wrapping absolute value, see\n\n # Example\n\n ```\n # use std::num::NonZero;\n #\n # fn main() { test().unwrap(); }\n # fn test() -> Option<()> {\n\n assert_eq!(pos, pos.wrapping_abs());\n assert_eq!(pos, neg.wrapping_abs());\n assert_eq!(min, min.wrapping_abs());\n assert_eq!(max, (-max).wrapping_abs());\n # Some(())\n # }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}