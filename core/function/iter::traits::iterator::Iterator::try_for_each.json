{
  "name": "iter::traits::iterator::Iterator::try_for_each",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::try_for_each::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::try_fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that applies a function as long as it returns\n successfully, producing a single, final value.\n\n `try_fold()` takes two arguments: an initial value, and a closure with\n two arguments: an 'accumulator', and an element. The closure either\n returns successfully, with the value that the accumulator should have\n for the next iteration, or it returns failure, with an error value that\n is propagated back to the caller immediately (short-circuiting).\n\n The initial value is the value the accumulator will have on the first\n call. If applying the closure succeeded against every element of the\n iterator, `try_fold()` returns the final accumulator as success.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `try_fold()` on the internal parts\n from which this iterator is composed. If multiple calls are needed,\n the `?` operator may be convenient for chaining the accumulator value\n along, but beware any invariants that need to be upheld before those\n early returns. This is a `&mut self` method, so iteration needs to be\n resumable after hitting an error here.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the checked sum of all of the elements of the array\n let sum = a.into_iter().try_fold(0i8, |acc, x| acc.checked_add(x));\n\n assert_eq!(sum, Some(6));\n ```\n\n Short-circuiting:\n\n ```\n let a = [10, 20, 30, 100, 40, 50];\n let mut iter = a.into_iter();\n\n // This sum overflows when adding the 100 element\n let sum = iter.try_fold(0i8, |acc, x| acc.checked_add(x));\n assert_eq!(sum, None);\n\n // Because it short-circuited, the remaining elements are still\n // available through the iterator.\n assert_eq!(iter.len(), 2);\n assert_eq!(iter.next(), Some(40));\n ```\n\n While you cannot `break` from a closure, the [`ControlFlow`] type allows\n a similar idea:\n\n ```\n use std::ops::ControlFlow;\n\n let triangular = (1..30).try_fold(0_i8, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Break(120));\n\n let triangular = (1..30).try_fold(0_u64, |prev, x| {\n     if let Some(next) = prev.checked_add(x) {\n         ControlFlow::Continue(next)\n     } else {\n         ControlFlow::Break(prev)\n     }\n });\n assert_eq!(triangular, ControlFlow::Continue(435));\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "External",
    "path": "iter::traits::iterator::Iterator::try_for_each"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2477:5: 2489:6",
  "src": "fn try_for_each<F, R>(&mut self, f: F) -> R\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> R,\n        R: Try<Output = ()>,\n    {\n        #[inline]\n        fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {\n            move |(), x| f(x)\n        }\n\n        self.try_fold((), call(f))\n    }",
  "mir": "fn iter::traits::iterator::Iterator::try_for_each(_1: &mut Self, _2: F) -> R {\n    let mut _0: R;\n    let mut _3: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2485:13: 2485:25};\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = iter::traits::iterator::Iterator::try_for_each::call::<<Self as iter::traits::iterator::Iterator>::Item, R, F>(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = <Self as iter::traits::iterator::Iterator>::try_fold::<(), {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2485:13: 2485:25}, R>(_1, (), move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " An iterator method that applies a fallible function to each item in the\n iterator, stopping at the first error and returning that error.\n\n This can also be thought of as the fallible form of [`for_each()`]\n or as the stateless version of [`try_fold()`].\n\n [`for_each()`]: Iterator::for_each\n [`try_fold()`]: Iterator::try_fold\n\n # Examples\n\n ```\n use std::fs::rename;\n use std::io::{stdout, Write};\n use std::path::Path;\n\n let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];\n\n let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{x}\"));\n assert!(res.is_ok());\n\n let mut it = data.iter().cloned();\n let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));\n assert!(res.is_err());\n // It short-circuited, so the remaining items are still in the iterator:\n assert_eq!(it.next(), Some(\"stale_bread.json\"));\n ```\n\n The [`ControlFlow`] type can be used with this method for the situations\n in which you'd use `break` and `continue` in a normal loop:\n\n ```\n use std::ops::ControlFlow;\n\n let r = (2..100).try_for_each(|x| {\n     if 323 % x == 0 {\n         return ControlFlow::Break(x)\n     }\n\n     ControlFlow::Continue(())\n });\n assert_eq!(r, ControlFlow::Break(17));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}