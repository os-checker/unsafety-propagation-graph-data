{
  "name": "<slice::iter::IterMut<'a, T> as iter::traits::iterator::Iterator>::rposition",
  "safe": true,
  "callees": {
    "ptr::mut_ptr::<impl *mut T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n [without_provenance]: without_provenance_mut\n",
      "adt": {}
    },
    "ptr::non_null::NonNull::<T>::offset_from_unsigned": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the distance between two pointers within the same allocation, *where it's known that\n `self` is equal to or greater than `origin`*. The returned value is in\n units of T: the distance in bytes is divided by `size_of::<T>()`.\n\n This computes the same value that [`offset_from`](#method.offset_from)\n would compute, but with the added precondition that the offset is\n guaranteed to be non-negative.  This method is equivalent to\n `usize::try_from(self.offset_from(origin)).unwrap_unchecked()`,\n but it provides slightly more information to the optimizer, which can\n sometimes allow it to optimize slightly better with some backends.\n\n This method can be though of as recovering the `count` that was passed\n to [`add`](#method.add) (or, with the parameters in the other order,\n to [`sub`](#method.sub)).  The following are all equivalent, assuming\n that their safety preconditions are met:\n ```rust\n # unsafe fn blah(ptr: std::ptr::NonNull<u32>, origin: std::ptr::NonNull<u32>, count: usize) -> bool { unsafe {\n ptr.offset_from_unsigned(origin) == count\n # &&\n origin.add(count) == ptr\n # &&\n ptr.sub(count) == origin\n # } }\n ```\n\n # Safety\n\n - The distance between the pointers must be non-negative (`self >= origin`)\n\n - *All* the safety conditions of [`offset_from`](#method.offset_from)\n   apply to this method as well; see it for the full details.\n\n Importantly, despite the return type of this method being able to represent\n a larger offset, it's still *not permitted* to pass pointers which differ\n by more than `isize::MAX` *bytes*.  As such, the result of this method will\n always be less than or equal to `isize::MAX as usize`.\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let a = [0; 5];\n let ptr1: NonNull<u32> = NonNull::from(&a[1]);\n let ptr2: NonNull<u32> = NonNull::from(&a[3]);\n unsafe {\n     assert_eq!(ptr2.offset_from_unsigned(ptr1), 2);\n     assert_eq!(ptr1.add(2), ptr2);\n     assert_eq!(ptr2.sub(2), ptr1);\n     assert_eq!(ptr2.offset_from_unsigned(ptr2), 0);\n }\n\n // This would be incorrect, as the pointers are not correctly ordered:\n // ptr1.offset_from_unsigned(ptr2)\n ```\n",
      "adt": {}
    },
    "iter::traits::double_ended::DoubleEndedIterator::next_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes and returns an element from the end of the iterator.\n\n Returns `None` when there are no more elements.\n\n The [trait-level] docs contain more details.\n\n [trait-level]: DoubleEndedIterator\n\n # Examples\n\n Basic usage:\n\n ```\n let numbers = vec![1, 2, 3, 4, 5, 6];\n\n let mut iter = numbers.iter();\n\n assert_eq!(Some(&1), iter.next());\n assert_eq!(Some(&6), iter.next_back());\n assert_eq!(Some(&5), iter.next_back());\n assert_eq!(Some(&2), iter.next());\n assert_eq!(Some(&3), iter.next());\n assert_eq!(Some(&4), iter.next());\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next_back());\n ```\n\n # Remarks\n\n The elements yielded by `DoubleEndedIterator`'s methods may differ from\n the ones yielded by [`Iterator`]'s methods:\n\n ```\n let vec = vec![(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b')];\n let uniq_by_fst_comp = || {\n     let mut seen = std::collections::HashSet::new();\n     vec.iter().copied().filter(move |x| seen.insert(x.0))\n };\n\n assert_eq!(uniq_by_fst_comp().last(), Some((2, 'a')));\n assert_eq!(uniq_by_fst_comp().next_back(), Some((2, 'b')));\n\n assert_eq!(\n     uniq_by_fst_comp().fold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(1, 'a'), (2, 'a')]\n );\n assert_eq!(\n     uniq_by_fst_comp().rfold(vec![], |mut v, x| {v.push(x); v}),\n     vec![(2, 'b'), (1, 'c')]\n );\n ```\n",
      "adt": {}
    },
    "ops::function::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    }
  },
  "adts": {
    "slice::iter::IterMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "ptr::non_null::NonNull": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47416, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25924, name: \"iter::traits::iterator::Iterator::Item\" }), args: GenericArgs([Type(Ty { id: 4256, kind: RigidTy(Adt(AdtDef(DefId { id: 24716, name: \"slice::iter::IterMut\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 622, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })]) }) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<slice::iter::IterMut<'a, T> as iter::traits::iterator::Iterator>::rposition"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs:399:13: 415:14",
  "src": "fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }",
  "mir": "fn <slice::iter::IterMut<'a, T> as iter::traits::iterator::Iterator>::rposition(_1: &mut slice::iter::IterMut<'_, T>, _2: P) -> option::Option<usize> {\n    let mut _0: option::Option<usize>;\n    let  _3: usize;\n    let  _4: usize;\n    let mut _5: *mut T;\n    let  _6: ptr::non_null::NonNull<T>;\n    let mut _7: *const T;\n    let mut _8: *mut T;\n    let mut _9: ptr::non_null::NonNull<T>;\n    let mut _10: usize;\n    let mut _11: option::Option<<slice::iter::IterMut<'_, T> as iter::traits::iterator::Iterator>::Item>;\n    let mut _12: isize;\n    let  _13: <slice::iter::IterMut<'_, T> as iter::traits::iterator::Iterator>::Item;\n    let mut _14: (usize, bool);\n    let mut _15: bool;\n    let mut _16: &mut P;\n    let mut _17: (<slice::iter::IterMut<'_, T> as iter::traits::iterator::Iterator>::Item,);\n    let  _18: ();\n    let mut _19: bool;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: usize;\n    debug self => _1;\n    debug predicate => _2;\n    debug n => _3;\n    debug len => _4;\n    debug end => _6;\n    debug i => _10;\n    debug x => _13;\n    bb0: {\n        StorageLive(_3);\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb3, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).1: *mut T);\n        _4 = ptr::mut_ptr::<impl *mut T>::addr(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = _4;\n        StorageDead(_4);\n        goto -> bb5;\n    }\n    bb3: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = ((*_1).1: *mut T);\n        _7 = move _8 as *const T;\n        StorageDead(_8);\n        _6 = move _7 as ptr::non_null::NonNull<T>;\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = ((*_1).0: ptr::non_null::NonNull<T>);\n        _3 = ptr::non_null::NonNull::<T>::offset_from_unsigned(_6, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_10);\n        _10 = _3;\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_11);\n        _11 = <slice::iter::IterMut<'_, T> as iter::traits::double_ended::DoubleEndedIterator>::next_back(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = discriminant(_11);\n        switchInt(move _12) -> [1: bb8, 0: bb14, otherwise: bb16];\n    }\n    bb8: {\n        _13 = move ((_11 as variant#1).0: <slice::iter::IterMut<'_, T> as iter::traits::iterator::Iterator>::Item);\n        _14 = CheckedSub(_10, 1_usize);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _10, 1_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _10 = move (_14.0: usize);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut _2;\n        StorageLive(_17);\n        _17 = (_13);\n        _15 = <P as ops::function::FnMut<(<slice::iter::IterMut<'_, T> as iter::traits::iterator::Iterator>::Item,)>>::call_mut(move _16, move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _15) -> [0: bb13, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = _10;\n        StorageLive(_21);\n        _21 = _3;\n        _19 = Lt(move _20, move _21);\n        StorageDead(_21);\n        StorageDead(_20);\n        _18 = hint::assert_unchecked(move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = _10;\n        _0 = option::Option::Some(move _22);\n        StorageDead(_22);\n        StorageDead(_15);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_3);\n        drop(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_11);\n        goto -> bb6;\n    }\n    bb14: {\n        StorageDead(_11);\n        _0 = option::Option::None;\n        StorageDead(_10);\n        StorageDead(_3);\n        drop(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        return;\n    }\n    bb16: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}