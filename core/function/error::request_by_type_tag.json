{
  "name": "error::request_by_type_tag",
  "safe": true,
  "callees": {
    "any::TypeId::of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `TypeId` of the generic type parameter.\n\n # Examples\n\n ```\n use std::any::{Any, TypeId};\n\n fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n     TypeId::of::<String>() == TypeId::of::<T>()\n }\n\n assert_eq!(is_string(&0), false);\n assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n ```\n",
      "adt": {
        "any::TypeId": "Constructor"
      }
    },
    "error::Tagged::<error::TaggedOption<'a, I>>::as_request": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "error::Tagged": "MutableAsArgument"
      }
    },
    "error::Error::provide": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_variables"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_variables\n"
        ]
      },
      "doc": " Provides type-based access to context intended for error reports.\n\n Used in conjunction with [`Request::provide_value`] and [`Request::provide_ref`] to extract\n references to member variables from `dyn Error` trait objects.\n\n # Example\n\n ```rust\n #![feature(error_generic_member_access)]\n use core::fmt;\n use core::error::{request_ref, Request};\n\n #[derive(Debug)]\n enum MyLittleTeaPot {\n     Empty,\n }\n\n #[derive(Debug)]\n struct MyBacktrace {\n     // ...\n }\n\n impl MyBacktrace {\n     fn new() -> MyBacktrace {\n         // ...\n         # MyBacktrace {}\n     }\n }\n\n #[derive(Debug)]\n struct Error {\n     backtrace: MyBacktrace,\n }\n\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"Example Error\")\n     }\n }\n\n impl std::error::Error for Error {\n     fn provide<'a>(&'a self, request: &mut Request<'a>) {\n         request\n             .provide_ref::<MyBacktrace>(&self.backtrace);\n     }\n }\n\n fn main() {\n     let backtrace = MyBacktrace::new();\n     let error = Error { backtrace };\n     let dyn_error = &error as &dyn std::error::Error;\n     let backtrace_ref = request_ref::<MyBacktrace>(dyn_error).unwrap();\n\n     assert!(core::ptr::eq(&error.backtrace, backtrace_ref));\n     assert!(request_ref::<MyLittleTeaPot>(dyn_error).is_none());\n }\n ```\n",
      "adt": {
        "error::Request": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "any::TypeId": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ],
    "error::TaggedOption": [
      "Plain"
    ],
    "error::Tagged": [
      "Plain",
      "MutRef",
      "Unknown([Field(1, Ty { id: 2822, kind: RigidTy(Adt(AdtDef(DefId { id: 25380, name: \"error::TaggedOption\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 1037, kind: Param(ParamTy { index: 1, name: \"I\" }) })]))) }), Field(0, Ty { id: 2813, kind: RigidTy(Adt(AdtDef(DefId { id: 24532, name: \"option::Option\" }), GenericArgs([Type(Ty { id: 2821, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25385, name: \"error::tags::Type::Reified\" }), args: GenericArgs([Type(Ty { id: 1037, kind: Param(ParamTy { index: 1, name: \"I\" }) }), Lifetime(Region { kind: ReErased })]) }) })]))) })])"
    ],
    "error::Request": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::error::request_by_type_tag"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/error.rs:431:1: 438:2",
  "src": "fn request_by_type_tag<'a, I>(err: &'a (impl Error + ?Sized)) -> Option<I::Reified>\nwhere\n    I: tags::Type<'a>,\n{\n    let mut tagged = Tagged { tag_id: TypeId::of::<I>(), value: TaggedOption::<'a, I>(None) };\n    err.provide(tagged.as_request());\n    tagged.value.0\n}",
  "mir": "fn error::request_by_type_tag(_1: &impl Error + ?Sized) -> option::Option<<I as error::tags::Type<'_>>::Reified> {\n    let mut _0: option::Option<<I as error::tags::Type<'_>>::Reified>;\n    let mut _2: error::Tagged<error::TaggedOption<'_, I>>;\n    let mut _3: any::TypeId;\n    let mut _4: error::TaggedOption<'_, I>;\n    let mut _5: option::Option<<I as error::tags::Type<'_>>::Reified>;\n    let  _6: ();\n    let mut _7: &mut error::Request<'_>;\n    let mut _8: &mut error::Tagged<error::TaggedOption<'_, I>>;\n    debug err => _1;\n    debug tagged => _2;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = any::TypeId::of::<I>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = option::Option::None;\n        _4 = TaggedOption(move _5);\n        StorageDead(_5);\n        _2 = Tagged(move _3, move _4);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_8);\n        _8 = &mut _2;\n        _7 = error::Tagged::<error::TaggedOption<'_, I>>::as_request(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _6 = <impl Error + ?Sized as error::Error>::provide(_1, _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = move ((_2.1: error::TaggedOption<'_, I>).0: option::Option<<I as error::tags::Type<'_>>::Reified>);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Request a specific value by tag from the `Error`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}