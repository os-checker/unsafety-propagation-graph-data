{
  "name": "slice::sort::shared::smallsort::small_sort_network",
  "safe": true,
  "callees": {
    "intrinsics::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the execution of the process.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n [`std::process::abort`](../../std/process/fn.abort.html) is to be preferred if possible,\n as its behavior is more user-friendly and more stable.\n\n The current implementation of `intrinsics::abort` is to invoke an invalid instruction,\n on most platforms.\n On Unix, the\n process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n `SIGBUS`.  The precise behavior is not guaranteed and not stable.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::slice_from_raw_parts_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forms a raw mutable slice from a pointer and a length.\n\n The `len` argument is the number of **elements**, not the number of bytes.\n\n Performs the same functionality as [`slice_from_raw_parts`], except that a\n raw mutable slice is returned, as opposed to a raw immutable slice.\n\n This function is safe, but actually using the return value is unsafe.\n See the documentation of [`slice::from_raw_parts_mut`] for slice safety requirements.\n\n [`slice::from_raw_parts_mut`]: crate::slice::from_raw_parts_mut\n\n # Examples\n\n ```rust\n use std::ptr;\n\n let x = &mut [5, 6, 7];\n let raw_pointer = x.as_mut_ptr();\n let slice = ptr::slice_from_raw_parts_mut(raw_pointer, 3);\n\n unsafe {\n     (*slice)[2] = 99; // assign a value at an index in the slice\n };\n\n assert_eq!(unsafe { &*slice }[2], 99);\n ```\n\n You must ensure that the pointer is valid and not null before dereferencing\n the raw slice. A slice reference must never have a null pointer, even if it's empty.\n\n ```rust,should_panic\n use std::ptr;\n let danger: *mut [u8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 0);\n unsafe {\n     danger.as_mut().expect(\"references must not be null\");\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::sort13_optimal": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the first 13 elements of `v` with a fast fixed function.\n\n Should `is_less` generate substantial amounts of code the compiler can choose to not inline\n `swap_if_less`. If the code of a sort impl changes so as to call this function in multiple\n places, `#[inline(never)]` is recommended to keep binary-size in check. The current design of\n `small_sort_network` makes sure to only call this once.\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::sort9_optimal": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the first 9 elements of `v` with a fast fixed function.\n\n Should `is_less` generate substantial amounts of code the compiler can choose to not inline\n `swap_if_less`. If the code of a sort impl changes so as to call this function in multiple\n places, `#[inline(never)]` is recommended to keep binary-size in check. The current design of\n `small_sort_network` makes sure to only call this once.\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::insertion_sort_shift_left": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sort `v` assuming `v[..offset]` is already sorted.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<Vec<u32>>`.\n // This is okay because we initialized it.\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n x_vec.push(3);\n assert_eq!(x_vec.len(), 4);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "slice::sort::shared::smallsort::bidirectional_merge": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Merge v assuming v[..len / 2] and v[len / 2..] are sorted.\n\n Original idea for bi-directional merging by Igor van den Hoven (quadsort),\n adapted to only use merge up and down. In contrast to the original\n parity_merge function, it performs 2 writes instead of 4 per iteration.\n\n # Safety\n The caller must guarantee that `dst` is valid for v.len() writes.\n Also `v.as_ptr()` and `dst` must not alias and v.len() must be >= 2.\n\n Note that T must be Freeze, the comparison function is evaluated on outdated\n temporary 'copies' that may not end up in the final array.\n",
      "adt": {}
    },
    "ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::sort::shared::smallsort::small_sort_network"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/shared/smallsort.rs:311:1: 377:2",
  "src": "fn small_sort_network<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    T: FreezeMarker,\n    F: FnMut(&T, &T) -> bool,\n{\n    // This implementation is tuned to be efficient for integer types.\n\n    let len = v.len();\n    if len < 2 {\n        return;\n    }\n\n    if len > SMALL_SORT_NETWORK_SCRATCH_LEN {\n        intrinsics::abort();\n    }\n\n    let mut stack_array = MaybeUninit::<[T; SMALL_SORT_NETWORK_SCRATCH_LEN]>::uninit();\n\n    let len_div_2 = len / 2;\n    let no_merge = len < 18;\n\n    let v_base = v.as_mut_ptr();\n    let initial_region_len = if no_merge { len } else { len_div_2 };\n    // SAFETY: Both possible values of `initial_region_len` are in-bounds.\n    let mut region = unsafe { &mut *ptr::slice_from_raw_parts_mut(v_base, initial_region_len) };\n\n    // Avoid compiler unrolling, we *really* don't want that to happen here for binary-size reasons.\n    loop {\n        let presorted_len = if region.len() >= 13 {\n            sort13_optimal(region, is_less);\n            13\n        } else if region.len() >= 9 {\n            sort9_optimal(region, is_less);\n            9\n        } else {\n            1\n        };\n\n        insertion_sort_shift_left(region, presorted_len, is_less);\n\n        if no_merge {\n            return;\n        }\n\n        if region.as_ptr() != v_base {\n            break;\n        }\n\n        // SAFETY: The right side of `v` based on `len_div_2` is guaranteed in-bounds.\n        unsafe {\n            region = &mut *ptr::slice_from_raw_parts_mut(v_base.add(len_div_2), len - len_div_2)\n        };\n    }\n\n    // SAFETY: We checked that T is Freeze and thus observation safe.\n    // Should is_less panic v was not modified in parity_merge and retains it's original input.\n    // scratch and v must not alias and scratch has v.len() space.\n    unsafe {\n        let scratch_base = stack_array.as_mut_ptr() as *mut T;\n        bidirectional_merge(\n            &mut *ptr::slice_from_raw_parts_mut(v_base, len),\n            scratch_base,\n            is_less,\n        );\n        ptr::copy_nonoverlapping(scratch_base, v_base, len);\n    }\n}",
  "mir": "fn slice::sort::shared::smallsort::small_sort_network(_1: &mut [T], _2: &mut F) -> () {\n    let mut _0: ();\n    let  _3: usize;\n    let mut _4: &[T];\n    let mut _5: bool;\n    let mut _6: bool;\n    let  _7: !;\n    let mut _8: mem::maybe_uninit::MaybeUninit<[T; 32]>;\n    let  _9: usize;\n    let mut _10: bool;\n    let  _11: bool;\n    let  _12: *mut T;\n    let  _13: usize;\n    let mut _14: &mut [T];\n    let mut _15: &mut [T];\n    let mut _16: *mut [T];\n    let mut _17: usize;\n    let  _18: usize;\n    let mut _19: bool;\n    let mut _20: usize;\n    let mut _21: &[T];\n    let  _22: ();\n    let mut _23: &mut [T];\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: &[T];\n    let  _27: ();\n    let mut _28: &mut [T];\n    let  _29: ();\n    let mut _30: &mut [T];\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: *const T;\n    let mut _34: &[T];\n    let mut _35: *const T;\n    let mut _36: &mut [T];\n    let mut _37: *mut [T];\n    let mut _38: *mut T;\n    let mut _39: usize;\n    let mut _40: (usize, bool);\n    let  _41: *mut T;\n    let mut _42: *mut [T; 32];\n    let mut _43: &mut mem::maybe_uninit::MaybeUninit<[T; 32]>;\n    let  _44: ();\n    let mut _45: &[T];\n    let  _46: &mut [T];\n    let mut _47: *mut [T];\n    let  _48: ();\n    let mut _49: *const T;\n    debug v => _1;\n    debug is_less => _2;\n    debug len => _3;\n    debug stack_array => _8;\n    debug len_div_2 => _9;\n    debug no_merge => _11;\n    debug v_base => _12;\n    debug initial_region_len => _13;\n    debug region => _14;\n    debug presorted_len => _18;\n    debug scratch_base => _41;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = Lt(_3, 2_usize);\n        switchInt(move _5) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        goto -> bb34;\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = Gt(_3, slice::sort::shared::smallsort::SMALL_SORT_NETWORK_SCRATCH_LEN);\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _7 = intrinsics::abort() -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = mem::maybe_uninit::MaybeUninit::<[T; 32]>::uninit() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = Eq(2_usize, 0_usize);\n        assert(!move _10, \"attempt to divide `{}` by zero\", _3) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = Div(_3, 2_usize);\n        _11 = Lt(_3, 18_usize);\n        _12 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_13);\n        switchInt(_11) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        _13 = _3;\n        goto -> bb10;\n    }\n    bb9: {\n        _13 = _9;\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _13;\n        _16 = ptr::slice_from_raw_parts_mut::<T>(_12, move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        _15 = &mut (*_16);\n        _14 = _15;\n        StorageDead(_15);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &(*_14);\n        _20 = PtrMetadata(move _21);\n        StorageDead(_21);\n        _19 = Ge(move _20, 13_usize);\n        switchInt(move _19) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = _14;\n        _22 = slice::sort::shared::smallsort::sort13_optimal::<T, F>(move _23, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        _18 = 13_usize;\n        goto -> bb20;\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_14);\n        _25 = PtrMetadata(move _26);\n        StorageDead(_26);\n        _24 = Ge(move _25, 9_usize);\n        switchInt(move _24) -> [0: bb18, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_25);\n        StorageLive(_28);\n        _28 = _14;\n        _27 = slice::sort::shared::smallsort::sort9_optimal::<T, F>(move _28, _2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_28);\n        _18 = 9_usize;\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_25);\n        _18 = 1_usize;\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_24);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_19);\n        StorageLive(_30);\n        _30 = _14;\n        StorageLive(_31);\n        _31 = _18;\n        _29 = slice::sort::shared::smallsort::insertion_sort_shift_left::<T, F>(move _30, move _31, _2) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_31);\n        StorageDead(_30);\n        switchInt(_11) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_8);\n        goto -> bb34;\n    }\n    bb23: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &(*_14);\n        _33 = slice::<impl [T]>::as_ptr(move _34) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_34);\n        StorageLive(_35);\n        _35 = _12 as *const T;\n        _32 = Ne(move _33, move _35);\n        switchInt(move _32) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_18);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &mut _8;\n        _42 = mem::maybe_uninit::MaybeUninit::<[T; 32]>::as_mut_ptr(move _43) -> [return: bb30, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = ptr::mut_ptr::<impl *mut T>::add(_12, _9) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageLive(_39);\n        _40 = CheckedSub(_3, _9);\n        assert(!move (_40.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _9) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _39 = move (_40.0: usize);\n        _37 = ptr::slice_from_raw_parts_mut::<T>(move _38, move _39) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _36 = &mut (*_37);\n        _14 = _36;\n        StorageDead(_37);\n        StorageDead(_18);\n        goto -> bb12;\n    }\n    bb30: {\n        StorageDead(_43);\n        _41 = move _42 as *mut T;\n        StorageDead(_42);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = ptr::slice_from_raw_parts_mut::<T>(_12, _3) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _46 = &mut (*_47);\n        _45 = &(*_46);\n        _44 = slice::sort::shared::smallsort::bidirectional_merge::<T, F>(move _45, _41, _2) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_45);\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageLive(_49);\n        _49 = _41 as *const T;\n        _48 = ptr::copy_nonoverlapping::<T>(move _49, _12, _3) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_49);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_8);\n        goto -> bb35;\n    }\n    bb34: {\n        goto -> bb35;\n    }\n    bb35: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}