{
  "name": "slice::<impl [T]>::align_to_mut",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "ptr::align_offset": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "ptr_to_integer_transmute_in_consts"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* ptr_to_integer_transmute_in_consts\n"
        ]
      },
      "doc": " Calculate an element-offset that increases a pointer's alignment.\n\n Calculate an element-offset (not byte-offset) that when added to a given pointer `p`, increases `p`'s alignment to at least the given alignment `a`.\n\n # Safety\n `a` must be a power of two.\n\n # Notes\n This implementation has been carefully tailored to not panic. It is UB for this to panic.\n The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n constants.\n\n If we ever decide to make it possible to call the intrinsic with `a` that is not a\n power-of-two, it will probably be more prudent to just change to a naive implementation rather\n than trying to adapt this to accommodate that change.\n\n Any questions go to @nagisa.\n",
      "adt": {}
    },
    "slice::<impl [T]>::split_at_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_mut_checked`](slice::split_at_mut_checked).\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n let (left, right) = v.split_at_mut(2);\n assert_eq!(left, [1, 0]);\n assert_eq!(right, [3, 0, 5, 6]);\n left[1] = 2;\n right[1] = 4;\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::align_to_offsets": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Function to calculate lengths of the middle and trailing slice for `align_to{,_mut}`.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "slice::raw::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1225,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:4134:5: 4175:6",
  "src": "pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is â€“ don't handle them at all.\n            return (self, &mut [], &mut []);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: Here we are ensuring we will use aligned pointers for U for the\n        // rest of the method. This is done by passing a pointer to &[T] with an\n        // alignment targeted for U.\n        // `crate::ptr::align_offset` is called with a correctly aligned and\n        // valid pointer `ptr` (it comes from a reference to `self`) and with\n        // a size that is a power of two (since it comes from the alignment for U),\n        // satisfying its safety constraints.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &mut [], &mut [])\n        } else {\n            let (left, rest) = self.split_at_mut(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            let rest_len = rest.len();\n            let mut_ptr = rest.as_mut_ptr();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                mut_ptr.cast() as *const (),\n                align_of::<U>(),\n            );\n            // We can't use `rest` again after this, that would invalidate its alias `mut_ptr`!\n            // SAFETY: see comments for `align_to`.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts_mut(mut_ptr as *mut U, us_len),\n                    from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n                )\n            }\n        }\n    }",
  "mir": "fn slice::<impl [T]>::align_to_mut(_1: &mut [T]) -> (&mut [T], &mut [U], &mut [T]) {\n    let mut _0: (&mut [T], &mut [U], &mut [T]);\n    let mut _2: &mut [U];\n    let mut _3: &mut [U; 0];\n    let mut _4: &mut [T];\n    let mut _5: &mut [T; 0];\n    let  _6: *const T;\n    let mut _7: &[T];\n    let  _8: usize;\n    let mut _9: usize;\n    let mut _10: bool;\n    let mut _11: usize;\n    let mut _12: &[T];\n    let mut _13: &mut [U];\n    let mut _14: &mut [U; 0];\n    let mut _15: &mut [T];\n    let mut _16: &mut [T; 0];\n    let  _17: &mut [T];\n    let  _18: &mut [T];\n    let mut _19: (&mut [T], &mut [T]);\n    let  _20: usize;\n    let  _21: usize;\n    let mut _22: (usize, usize);\n    let mut _23: &[T];\n    let  _24: usize;\n    let mut _25: &[T];\n    let  _26: *mut T;\n    let mut _27: &mut [U];\n    let mut _28: *mut U;\n    let mut _29: &mut [T];\n    let mut _30: *mut T;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    debug self => _1;\n    debug ptr => _6;\n    debug offset => _8;\n    debug left => _17;\n    debug rest => _18;\n    debug us_len => _20;\n    debug ts_len => _21;\n    debug rest_len => _24;\n    debug mut_ptr => _26;\n    bb0: {\n        switchInt(<U as mem::SizedTypeProperties>::IS_ZST) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        switchInt(<T as mem::SizedTypeProperties>::IS_ZST) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_2);\n        _3 = slice::<impl [T]>::align_to_mut::<U>::promoted[1];\n        _2 = _3 as &mut [U];\n        StorageLive(_4);\n        _5 = slice::<impl [T]>::align_to_mut::<U>::promoted[0];\n        _4 = _5 as &mut [T];\n        _0 = (_1, move _2, move _4);\n        StorageDead(_4);\n        StorageDead(_2);\n        goto -> bb17;\n    }\n    bb3: {\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = slice::<impl [T]>::as_ptr(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = mem::align_of::<U>() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = ptr::align_offset::<T>(_6, move _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = PtrMetadata(move _12);\n        StorageDead(_12);\n        _10 = Gt(_8, move _11);\n        switchInt(move _10) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_11);\n        StorageLive(_13);\n        _14 = slice::<impl [T]>::align_to_mut::<U>::promoted[3];\n        _13 = _14 as &mut [U];\n        StorageLive(_15);\n        _16 = slice::<impl [T]>::align_to_mut::<U>::promoted[2];\n        _15 = _16 as &mut [T];\n        _0 = (_1, move _13, move _15);\n        StorageDead(_15);\n        StorageDead(_13);\n        goto -> bb16;\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageLive(_19);\n        _19 = slice::<impl [T]>::split_at_mut(_1, _8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _17 = move (_19.0: &mut [T]);\n        _18 = move (_19.1: &mut [T]);\n        StorageDead(_19);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &(*_18);\n        _22 = slice::<impl [T]>::align_to_offsets::<U>(move _23) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_23);\n        _20 = (_22.0: usize);\n        _21 = (_22.1: usize);\n        StorageDead(_22);\n        StorageLive(_25);\n        _25 = &(*_18);\n        _24 = PtrMetadata(move _25);\n        StorageDead(_25);\n        _26 = slice::<impl [T]>::as_mut_ptr(_18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_28);\n        _28 = _26 as *mut U;\n        _27 = slice::raw::from_raw_parts_mut::<'_, U>(move _28, _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_28);\n        StorageLive(_30);\n        StorageLive(_31);\n        _32 = CheckedSub(_24, _21);\n        assert(!move (_32.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _24, _21) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _31 = move (_32.0: usize);\n        _30 = ptr::mut_ptr::<impl *mut T>::add(_26, move _31) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_31);\n        _29 = slice::raw::from_raw_parts_mut::<'_, T>(move _30, _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_30);\n        _0 = (_17, _27, _29);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_10);\n        goto -> bb17;\n    }\n    bb17: {\n        return;\n    }\n}\n",
  "doc": " Transmutes the mutable slice to a mutable slice of another type, ensuring alignment of the\n types is maintained.\n\n This method splits the slice into three distinct slices: prefix, correctly aligned middle\n slice of a new type, and the suffix slice. The middle part will be as big as possible under\n the given alignment constraint and element size.\n\n This method has no purpose when either input element `T` or output element `U` are\n zero-sized and will return the original slice without splitting anything.\n\n # Safety\n\n This method is essentially a `transmute` with respect to the elements in the returned\n middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n\n # Examples\n\n Basic usage:\n\n ```\n unsafe {\n     let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, shorts, suffix) = bytes.align_to_mut::<u16>();\n     // less_efficient_algorithm_for_bytes(prefix);\n     // more_efficient_algorithm_for_aligned_shorts(shorts);\n     // less_efficient_algorithm_for_bytes(suffix);\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}