{
  "name": "<iter::adapters::fuse::Fuse<I> as iter::adapters::SourceIter>::as_inner",
  "safe": false,
  "callees": {
    "option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value,\n without checking that the value is not [`None`].\n\n # Safety\n\n Calling this method on [`None`] is *[undefined behavior]*.\n\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\");\n ```\n\n ```no_run\n let x: Option<&str> = None;\n assert_eq!(unsafe { x.unwrap_unchecked() }, \"air\"); // Undefined behavior!\n ```\n",
      "adt": {}
    },
    "iter::adapters::SourceIter::as_inner": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Retrieve the source of an iterator pipeline.\n\n # Safety\n\n Implementations must return the same mutable reference for their lifetime, unless\n replaced by a caller.\n\n Callers may only replace the reference when they stopped iteration and drop the\n iterator pipeline after extracting the source.\n\n This means iterator adapters can rely on the source not changing during\n iteration but they cannot rely on it in their Drop implementations.\n\n Implementing this method means adapters relinquish private-only access to their\n source and can only rely on guarantees made based on method receiver types.\n The lack of restricted access also requires that adapters must uphold the source's\n public API even when they have access to its internals.\n\n Callers in turn must expect the source to be in any state that is consistent with\n its public API since adapters sitting between it and the source have the same\n access. In particular an adapter may have consumed more elements than strictly necessary.\n\n The overall goal of these requirements is to let the consumer of a pipeline use\n * whatever remains in the source after iteration has stopped\n * the memory that has become unused by advancing a consuming iterator\n\n [`next()`]: Iterator::next()\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "MutRef",
      "Plain"
    ],
    "iter::adapters::fuse::Fuse": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 13861,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/fuse.rs:459:5: 464:6",
  "src": "unsafe fn as_inner(&mut self) -> &mut I::Source {\n        // SAFETY: unsafe function forwarding to unsafe function with the same requirements.\n        // TrustedFused guarantees that we'll never encounter a case where `self.iter` would\n        // be set to None.\n        unsafe { SourceIter::as_inner(self.iter.as_mut().unwrap_unchecked()) }\n    }",
  "mir": "fn <iter::adapters::fuse::Fuse<I> as iter::adapters::SourceIter>::as_inner(_1: &mut iter::adapters::fuse::Fuse<I>) -> &mut <I as iter::adapters::SourceIter>::Source {\n    let mut _0: &mut <I as iter::adapters::SourceIter>::Source;\n    let mut _2: &mut I;\n    let mut _3: option::Option<&mut I>;\n    let mut _4: &mut option::Option<I>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: option::Option<I>);\n        _3 = option::Option::<I>::as_mut(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = option::Option::<&mut I>::unwrap_unchecked(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = <I as iter::adapters::SourceIter>::as_inner(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}