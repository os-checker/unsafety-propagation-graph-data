{
  "name": "num::<impl u128>::strict_rem",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl u128>::strict_rem"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:1442:9: 1444:10",
  "src": "pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }",
  "mir": "fn num::<impl u128>::strict_rem(_1: u128, _2: u128) -> u128 {\n    let mut _0: u128;\n    let mut _3: bool;\n    debug self => _1;\n    debug rhs => _2;\n    bb0: {\n        _3 = Eq(_2, 0_u128);\n        assert(!move _3, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Rem(_1, _2);\n        return;\n    }\n}\n",
  "doc": " Strict integer remainder. Computes `self % rhs`.\n\n Strict remainder calculation on unsigned types is just the regular\n remainder calculation. There's no way overflow could ever happen.\n This function exists so that all operations are accounted for in the\n strict operations.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n\n The following panics because of division by zero:\n\n ```should_panic\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}