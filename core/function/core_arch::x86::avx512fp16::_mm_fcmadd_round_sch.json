{
  "name": "core_arch::x86::avx512fp16::_mm_fcmadd_round_sch",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::vfcmaddcsh_mask": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128": [
      "Plain"
    ],
    "core_arch::x86::__m128h": [
      "Plain"
    ]
  },
  "path": 10765,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:5071:1: 5082:2",
  "src": "pub fn _mm_fcmadd_round_sch<const ROUNDING: i32>(a: __m128h, b: __m128h, c: __m128h) -> __m128h {\n    unsafe {\n        static_assert_rounding!(ROUNDING);\n        transmute(vfcmaddcsh_mask(\n            transmute(a),\n            transmute(b),\n            transmute(c),\n            0xff,\n            ROUNDING,\n        ))\n    }\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm_fcmadd_round_sch(_1: core_arch::x86::__m128h, _2: core_arch::x86::__m128h, _3: core_arch::x86::__m128h) -> core_arch::x86::__m128h {\n    let mut _0: core_arch::x86::__m128h;\n    let mut _4: core_arch::x86::__m128;\n    let mut _5: core_arch::x86::__m128;\n    let mut _6: core_arch::x86::__m128;\n    let mut _7: core_arch::x86::__m128;\n    debug a => _1;\n    debug b => _2;\n    debug c => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = _1 as core_arch::x86::__m128;\n        StorageLive(_6);\n        _6 = _2 as core_arch::x86::__m128;\n        StorageLive(_7);\n        _7 = _3 as core_arch::x86::__m128;\n        _4 = core_arch::x86::avx512fp16::vfcmaddcsh_mask(move _5, move _6, move _7, u8::MAX, ROUNDING) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        _0 = move _4 as core_arch::x86::__m128h;\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Multiply the lower complex number in a by the complex conjugate of the lower complex number in b,\n accumulate to the lower complex number in c, and store the result in the lower elements of dst,\n and copy the upper 6 packed elements from a to the upper elements of dst. Each complex number is\n composed of two adjacent half-precision (16-bit) floating-point elements, which defines the complex\n number `complex = vec.fp16[0] + i * vec.fp16[1]`, or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n Rounding is done according to the rounding parameter, which can be one of:\n\n * [`_MM_FROUND_TO_NEAREST_INT`] | [`_MM_FROUND_NO_EXC`] : round to nearest and suppress exceptions\n * [`_MM_FROUND_TO_NEG_INF`] | [`_MM_FROUND_NO_EXC`] : round down and suppress exceptions\n * [`_MM_FROUND_TO_POS_INF`] | [`_MM_FROUND_NO_EXC`] : round up and suppress exceptions\n * [`_MM_FROUND_TO_ZERO`] | [`_MM_FROUND_NO_EXC`] : truncate and suppress exceptions\n * [`_MM_FROUND_CUR_DIRECTION`] : use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`]\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_fcmadd_round_sch)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}