{
  "name": "core_simd::vector::Simd::<T, N>::scatter_select_unchecked",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::splat": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new SIMD vector with all elements set to the given value.\n\n # Examples\n\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::u32x4;\n let v = u32x4::splat(8);\n assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n ```\n",
      "adt": {
        "core_simd::vector::Simd": "Constructor"
      }
    },
    "core_simd::simd::ptr::mut_ptr::SimdMutPtr::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the offset from a pointer using wrapping arithmetic.\n\n Equivalent to calling [`pointer::wrapping_add`] on each element.\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::scatter_select_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Conditionally write pointers elementwise into a SIMD vector.\n The mask `enable`s all `true` pointers and disables all `false` pointers.\n If a pointer is disabled, the write to its pointee is skipped.\n\n # Safety\n\n Enabled pointers must satisfy the same conditions as [`core::ptr::write`].\n\n # Example\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::{Mask, Simd, ptr::SimdMutPtr};\n let mut values = [0; 4];\n let offset = Simd::from_array([3, 2, 1, 0]);\n let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n let enable = Mask::from_array([true, true, false, false]);\n unsafe { Simd::from_array([6, 3, 5, 7]).scatter_select_ptr(ptrs, enable); }\n assert_eq!(values, [0, 0, 3, 6]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core_simd::vector::Simd": [
      "Plain"
    ],
    "core_simd::masks::Mask": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_simd::vector::Simd::<T, N>::scatter_select_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:822:5: 847:6",
  "src": "pub unsafe fn scatter_select_unchecked(\n        self,\n        slice: &mut [T],\n        enable: Mask<isize, N>,\n        idxs: Simd<usize, N>,\n    ) {\n        // Safety: This block works with *mut T derived from &mut 'a [T],\n        // which means it is delicate in Rust's borrowing model, circa 2021:\n        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n        // Even though this block is largely safe methods, it must be exactly this way\n        // to prevent invalidating the raw ptrs while they're live.\n        // Thus, entering this block requires all values to use being already ready:\n        // 0. idxs we want to write to, which are used to construct the mask.\n        // 1. enable, which depends on an initial &'a [T] and the idxs.\n        // 2. actual values to scatter (self).\n        // 3. &mut [T] which will become our base ptr.\n        unsafe {\n            // Now Entering ☢️ *mut T Zone\n            let base_ptr = Simd::<*mut T, N>::splat(slice.as_mut_ptr());\n            // Ferris forgive me, I have done pointer arithmetic here.\n            let ptrs = base_ptr.wrapping_add(idxs);\n            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n            self.scatter_select_ptr(ptrs, enable);\n            // Cleared ☢️ *mut T Zone\n        }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::scatter_select_unchecked(_1: core_simd::vector::Simd<T, N>, _2: &mut [T], _3: core_simd::masks::Mask<isize, N>, _4: core_simd::vector::Simd<usize, N>) -> () {\n    let mut _0: ();\n    let  _5: core_simd::vector::Simd<*mut T, N>;\n    let mut _6: *mut T;\n    let  _7: core_simd::vector::Simd<*mut T, N>;\n    let  _8: ();\n    debug self => _1;\n    debug slice => _2;\n    debug enable => _3;\n    debug idxs => _4;\n    debug base_ptr => _5;\n    debug ptrs => _7;\n    bb0: {\n        StorageLive(_6);\n        _6 = slice::<impl [T]>::as_mut_ptr(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core_simd::vector::Simd::<*mut T, N>::splat(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = <core_simd::vector::Simd<*mut T, N> as core_simd::simd::ptr::mut_ptr::SimdMutPtr>::wrapping_add(_5, _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = core_simd::vector::Simd::<T, N>::scatter_select_ptr(_1, _7, _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": " Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n The mask `enable`s all `true` indices and disables all `false` indices.\n If two enabled elements in the scattered vector would write to the same index,\n only the last element is guaranteed to actually be written.\n\n # Safety\n\n Calling this function with an enabled out-of-bounds index is *[undefined behavior]*,\n and may lead to memory corruption.\n\n # Examples\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::{Simd, cmp::SimdPartialOrd, Mask};\n let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n let idxs = Simd::from_array([9, 3, 0, 0]);\n let vals = Simd::from_array([-27, 82, -41, 124]);\n let enable = Mask::from_array([true, true, true, false]); // Masks the final index\n // If this mask was used to scatter, it would be unsound. Let's fix that.\n let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n\n // We have masked the OOB index, so it's safe to scatter now.\n unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n // The second write to index 0 was masked, thus omitted.\n assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n ```\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}