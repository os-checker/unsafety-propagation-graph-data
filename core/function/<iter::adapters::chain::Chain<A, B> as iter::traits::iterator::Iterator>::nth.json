{
  "name": "<iter::adapters::chain::Chain<A, B> as iter::traits::iterator::Iterator>::nth",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::advance_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator by `n` elements.\n\n This method will eagerly skip `n` elements by calling [`next`] up to `n`\n times until [`None`] is encountered.\n\n `advance_by(n)` will return `Ok(())` if the iterator successfully advances by\n `n` elements, or a `Err(NonZero<usize>)` with value `k` if [`None`] is encountered,\n where `k` is remaining number of steps that could not be advanced because the iterator ran out.\n If `self` is empty and `n` is non-zero, then this returns `Err(n)`.\n Otherwise, `k` is always less than `n`.\n\n Calling `advance_by(0)` can do meaningful work, for example [`Flatten`]\n can advance its outer iterator until it finds an inner iterator that is not empty, which\n then often allows it to return a more accurate `size_hint()` than in its initial state.\n\n [`Flatten`]: crate::iter::Flatten\n [`next`]: Iterator::next\n\n # Examples\n\n ```\n #![feature(iter_advance_by)]\n\n use std::num::NonZero;\n\n let a = [1, 2, 3, 4];\n let mut iter = a.into_iter();\n\n assert_eq!(iter.advance_by(2), Ok(()));\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.advance_by(0), Ok(()));\n assert_eq!(iter.advance_by(100), Err(NonZero::new(99).unwrap())); // only `4` was skipped\n ```\n",
      "adt": {
        "result::Result": "Constructor",
        "num::nonzero::NonZero": "Constructor"
      }
    },
    "num::nonzero::NonZero::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained value as a primitive type.\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ops::try_trait::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::nth": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element of the iterator.\n\n Like most indexing operations, the count starts from zero, so `nth(0)`\n returns the first value, `nth(1)` the second, and so on.\n\n Note that all preceding elements, as well as the returned element, will be\n consumed from the iterator. That means that the preceding elements will be\n discarded, and also that calling `nth(0)` multiple times on the same iterator\n will return different elements.\n\n `nth()` will return [`None`] if `n` is greater than or equal to the length of the\n iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(1), Some(2));\n ```\n\n Calling `nth()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.nth(1), Some(2));\n assert_eq!(iter.nth(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.into_iter().nth(10), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::chain::Chain": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1742, kind: RigidTy(Adt(AdtDef(DefId { id: 24832, name: \"num::nonzero::NonZero\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "num::nonzero::NonZero": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "MutRef"
    ],
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 6149, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1017, kind: Param(ParamTy { index: 1, name: \"B\" }) }, Mut)) })])"
    ]
  },
  "path": 13659,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/chain.rs:148:5: 162:6",
  "src": "fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n        if let Some(ref mut a) = self.a {\n            n = match a.advance_by(n) {\n                Ok(()) => match a.next() {\n                    None => 0,\n                    x => return x,\n                },\n                Err(k) => k.get(),\n            };\n\n            self.a = None;\n        }\n\n        self.b.as_mut()?.nth(n)\n    }",
  "mir": "fn <iter::adapters::chain::Chain<A, B> as iter::traits::iterator::Iterator>::nth(_1: &mut iter::adapters::chain::Chain<A, B>, _2: usize) -> option::Option<<A as iter::traits::iterator::Iterator>::Item> {\n    let mut _0: option::Option<<A as iter::traits::iterator::Iterator>::Item>;\n    let mut _3: isize;\n    let  _4: &mut A;\n    let mut _5: usize;\n    let mut _6: result::Result<(), num::nonzero::NonZero<usize>>;\n    let mut _7: usize;\n    let mut _8: isize;\n    let mut _9: option::Option<<A as iter::traits::iterator::Iterator>::Item>;\n    let mut _10: isize;\n    let  _11: option::Option<<A as iter::traits::iterator::Iterator>::Item>;\n    let  _12: num::nonzero::NonZero<usize>;\n    let mut _13: option::Option<A>;\n    let mut _14: ops::control_flow::ControlFlow<option::Option<convert::Infallible>, &mut B>;\n    let mut _15: option::Option<&mut B>;\n    let mut _16: &mut option::Option<B>;\n    let mut _17: isize;\n    let  _18: &mut B;\n    let mut _19: usize;\n    debug self => _1;\n    debug n => _2;\n    debug a => _4;\n    debug x => _11;\n    debug k => _12;\n    debug residual => option::Option::<convert::Infallible>::None;\n    debug val => _18;\n    bb0: {\n        _3 = discriminant(((*_1).0: option::Option<A>));\n        switchInt(move _3) -> [1: bb1, 0: bb13, otherwise: bb3];\n    }\n    bb1: {\n        _4 = &mut ((((*_1).0: option::Option<A>) as variant#1).0: A);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _2;\n        _6 = <A as iter::traits::iterator::Iterator>::advance_by(_4, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _8 = discriminant(_6);\n        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _12 = ((_6 as variant#1).0: num::nonzero::NonZero<usize>);\n        _5 = num::nonzero::NonZero::<usize>::get(_12) -> [return: bb10, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_9);\n        _9 = <A as iter::traits::iterator::Iterator>::next(_4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _10 = discriminant(_9);\n        switchInt(move _10) -> [0: bb8, 1: bb7, otherwise: bb3];\n    }\n    bb7: {\n        StorageLive(_11);\n        _11 = move _9;\n        _0 = move _11;\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageDead(_6);\n        goto -> bb20;\n    }\n    bb8: {\n        _5 = 0_usize;\n        drop(_9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_9);\n        goto -> bb11;\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        _2 = move _5;\n        StorageDead(_5);\n        StorageDead(_6);\n        StorageLive(_13);\n        _13 = option::Option::None;\n        drop(((*_1).0: option::Option<A>)) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        ((*_1).0: option::Option<A>) = move _13;\n        StorageDead(_13);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut ((*_1).1: option::Option<B>);\n        _15 = option::Option::<B>::as_mut(move _16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_16);\n        _14 = <option::Option<&mut B> as ops::try_trait::Try>::branch(move _15) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_15);\n        _17 = discriminant(_14);\n        switchInt(move _17) -> [0: bb16, 1: bb17, otherwise: bb3];\n    }\n    bb16: {\n        _18 = move ((_14 as variant#0).0: &mut B);\n        StorageLive(_19);\n        _19 = _2;\n        _0 = <B as iter::traits::iterator::Iterator>::nth(_18, move _19) -> [return: bb19, unwind unreachable];\n    }\n    bb17: {\n        _0 = <option::Option<<A as iter::traits::iterator::Iterator>::Item> as ops::try_trait::FromResidual<option::Option<convert::Infallible>>>::from_residual(option::Option::<convert::Infallible>::None) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_14);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_19);\n        StorageDead(_14);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}