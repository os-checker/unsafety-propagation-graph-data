{
  "name": "array::try_from_fn",
  "safe": true,
  "callees": {
    "array::try_from_fn_erased": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Version of [`try_from_fn`] using a passed-in slice in order to avoid\n needing to monomorphize for every array length.\n\n This takes a generator rather than an iterator so that *at the type level*\n it never needs to worry about running out of items.  When combined with\n an infallible `Try` type, that means the loop canonicalizes easily, allowing\n it to optimize well.\n\n It would be *possible* to unify this and [`iter_next_chunk_erased`] into one\n function that does the union of both things, but last time it was that way\n it resulted in poor codegen from the \"are there enough source items?\" checks\n not optimizing away.  So if you give it a shot, make sure to watch what\n happens in the codegen tests.\n",
      "adt": {
        "ops::control_flow::ControlFlow": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::array_assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the values from an array of `MaybeUninit` containers.\n\n # Safety\n\n It is up to the caller to guarantee that all elements of the array are\n in an initialized state.\n\n # Examples\n\n ```\n #![feature(maybe_uninit_array_assume_init)]\n use std::mem::MaybeUninit;\n\n let mut array: [MaybeUninit<i32>; 3] = [MaybeUninit::uninit(); 3];\n array[0].write(0);\n array[1].write(1);\n array[2].write(2);\n\n // SAFETY: Now safe as we initialised all elements\n let array = unsafe {\n     MaybeUninit::array_assume_init(array)\n };\n\n assert_eq!(array, [0, 1, 2]);\n ```\n",
      "adt": {}
    },
    "ops::try_trait::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "ops::try_trait::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::control_flow::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3277, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 25500, name: \"ops::try_trait::Try::Residual\" }), args: GenericArgs([Type(Ty { id: 3279, kind: Param(ParamTy { index: 0, name: \"R\" }) })]) }) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::array::try_from_fn"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/array/mod.rs:148:1: 161:2",
  "src": "pub const fn try_from_fn<R, const N: usize, F>(cb: F) -> ChangeOutputType<R, [R::Output; N]>\nwhere\n    R: [const] Try<Residual: [const] Residual<[R::Output; N]>, Output: [const] Destruct>,\n    F: [const] FnMut(usize) -> R + [const] Destruct,\n{\n    let mut array = [const { MaybeUninit::uninit() }; N];\n    match try_from_fn_erased(&mut array, cb) {\n        ControlFlow::Break(r) => FromResidual::from_residual(r),\n        ControlFlow::Continue(()) => {\n            // SAFETY: All elements of the array were populated.\n            try { unsafe { MaybeUninit::array_assume_init(array) } }\n        }\n    }\n}",
  "mir": "fn array::try_from_fn(_1: F) -> <<R as ops::try_trait::Try>::Residual as ops::try_trait::Residual<[<R as ops::try_trait::Try>::Output; N]>>::TryType {\n    let mut _0: <<R as ops::try_trait::Try>::Residual as ops::try_trait::Residual<[<R as ops::try_trait::Try>::Output; N]>>::TryType;\n    let mut _2: [mem::maybe_uninit::MaybeUninit<<R as ops::try_trait::Try>::Output>; N];\n    let mut _3: ops::control_flow::ControlFlow<<R as ops::try_trait::Try>::Residual>;\n    let mut _4: &mut [mem::maybe_uninit::MaybeUninit<<R as ops::try_trait::Try>::Output>];\n    let mut _5: &mut [mem::maybe_uninit::MaybeUninit<<R as ops::try_trait::Try>::Output>; N];\n    let mut _6: isize;\n    let  _7: <R as ops::try_trait::Try>::Residual;\n    let mut _8: [<R as ops::try_trait::Try>::Output; N];\n    let mut _9: [mem::maybe_uninit::MaybeUninit<<R as ops::try_trait::Try>::Output>; N];\n    debug cb => _1;\n    debug array => _2;\n    debug r => _7;\n    bb0: {\n        StorageLive(_2);\n        _2 = [array::try_from_fn::<R, N, F>::{constant#2}; N];\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = &mut _2;\n        _4 = _5 as &mut [mem::maybe_uninit::MaybeUninit<<R as ops::try_trait::Try>::Output>];\n        _3 = array::try_from_fn_erased::<R, F>(move _4, _1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb3, 1: bb4, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = move _2;\n        _8 = mem::maybe_uninit::MaybeUninit::<<R as ops::try_trait::Try>::Output>::array_assume_init::<N>(move _9) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        _7 = move ((_3 as variant#1).0: <R as ops::try_trait::Try>::Residual);\n        _0 = <<<R as ops::try_trait::Try>::Residual as ops::try_trait::Residual<[<R as ops::try_trait::Try>::Output; N]>>::TryType as ops::try_trait::FromResidual<<R as ops::try_trait::Try>::Residual>>::from_residual(_7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        goto -> bb8;\n    }\n    bb6: {\n        StorageDead(_9);\n        _0 = <<<R as ops::try_trait::Try>::Residual as ops::try_trait::Residual<[<R as ops::try_trait::Try>::Output; N]>>::TryType as ops::try_trait::Try>::from_output(move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates an array `[T; N]` where each fallible array element `T` is returned by the `cb` call.\n Unlike [`from_fn`], where the element creation can't fail, this version will return an error\n if any element creation was unsuccessful.\n\n The return type of this function depends on the return type of the closure.\n If you return `Result<T, E>` from the closure, you'll get a `Result<[T; N], E>`.\n If you return `Option<T>` from the closure, you'll get an `Option<[T; N]>`.\n\n # Arguments\n\n * `cb`: Callback where the passed argument is the current array index.\n\n # Example\n\n ```rust\n #![feature(array_try_from_fn)]\n\n let array: Result<[u8; 5], _> = std::array::try_from_fn(|i| i.try_into());\n assert_eq!(array, Ok([0, 1, 2, 3, 4]));\n\n let array: Result<[i8; 200], _> = std::array::try_from_fn(|i| i.try_into());\n assert!(array.is_err());\n\n let array: Option<[_; 4]> = std::array::try_from_fn(|i| i.checked_add(100));\n assert_eq!(array, Some([100, 101, 102, 103]));\n\n let array: Option<[_; 4]> = std::array::try_from_fn(|i| i.checked_sub(100));\n assert_eq!(array, None);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}