{
  "name": "ptr::mut_ptr::<impl *mut T>::wrapping_offset",
  "safe": true,
  "callees": {
    "intrinsics::arith_offset": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the offset from a pointer, potentially wrapping.\n\n This is implemented as an intrinsic to avoid converting to and from an\n integer, since the conversion inhibits certain optimizations.\n\n # Safety\n\n Unlike the `offset` intrinsic, this intrinsic does not restrict the\n resulting pointer to point into or at the end of an allocated\n object, and it wraps with two's complement arithmetic. The resulting\n value is not necessarily valid to be used to actually access memory.\n\n The stabilized version of this intrinsic is [`pointer::wrapping_offset`].\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::ptr::mut_ptr::<impl *mut T>::wrapping_offset"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs:465:5: 471:6",
  "src": "pub const fn wrapping_offset(self, count: isize) -> *mut T\n    where\n        T: Sized,\n    {\n        // SAFETY: the `arith_offset` intrinsic has no prerequisites to be called.\n        unsafe { intrinsics::arith_offset(self, count) as *mut T }\n    }",
  "mir": "fn ptr::mut_ptr::<impl *mut T>::wrapping_offset(_1: *mut T, _2: isize) -> *mut T {\n    let mut _0: *mut T;\n    let mut _3: *const T;\n    let mut _4: *const T;\n    debug self => _1;\n    debug count => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = _1 as *const T;\n        _3 = intrinsics::arith_offset::<T>(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = move _3 as *mut T;\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Adds a signed offset to a pointer using wrapping arithmetic.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n This operation itself is always safe, but using the resulting pointer is not.\n\n The resulting pointer \"remembers\" the [allocation] that `self` points to\n (this is called \"[Provenance](ptr/index.html#provenance)\").\n The pointer must not be used to read or write other allocations.\n\n In other words, `let z = x.wrapping_offset((y as isize) - (x as isize))` does *not* make `z`\n the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n `x` and `y` point into the same allocation.\n\n Compared to [`offset`], this method basically delays the requirement of staying within the\n same allocation: [`offset`] is immediate Undefined Behavior when crossing object\n boundaries; `wrapping_offset` produces a pointer but still leads to Undefined Behavior if a\n pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`offset`]\n can be optimized better and is thus preferable in performance-sensitive code.\n\n The delayed check only considers the value of the pointer that was dereferenced, not the\n intermediate values used during the computation of the final result. For example,\n `x.wrapping_offset(o).wrapping_offset(o.wrapping_neg())` is always the same as `x`. In other\n words, leaving the allocation and then re-entering it later is permitted.\n\n [`offset`]: #method.offset\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n // Iterate using a raw pointer in increments of two elements\n let mut data = [1u8, 2, 3, 4, 5];\n let mut ptr: *mut u8 = data.as_mut_ptr();\n let step = 2;\n let end_rounded_up = ptr.wrapping_offset(6);\n\n while ptr != end_rounded_up {\n     unsafe {\n         *ptr = 0;\n     }\n     ptr = ptr.wrapping_offset(step);\n }\n assert_eq!(&data, &[0, 2, 0, 4, 0]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}