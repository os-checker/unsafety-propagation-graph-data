{
  "name": "ptr::swap_nonoverlapping_bytes",
  "safe": false,
  "callees": {
    "num::nonzero::NonZero::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained value as a primitive type.\n",
      "adt": {}
    },
    "num::nonzero::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {
        "num::nonzero::NonZero": "Constructor",
        "option::Option": "Constructor"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_chunks": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_short": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "num::nonzero::NonZero": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1742, kind: RigidTy(Adt(AdtDef(DefId { id: 24832, name: \"num::nonzero::NonZero\" }), GenericArgs([Type(Ty { id: 47, kind: RigidTy(Uint(Usize)) })]))) })])"
    ]
  },
  "path": 16089,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs:1438:1: 1495:2",
  "src": "unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, bytes: NonZero<usize>) {\n    // Same as `swap_nonoverlapping::<[u8; N]>`.\n    unsafe fn swap_nonoverlapping_chunks<const N: usize>(\n        x: *mut MaybeUninit<[u8; N]>,\n        y: *mut MaybeUninit<[u8; N]>,\n        chunks: NonZero<usize>,\n    ) {\n        let chunks = chunks.get();\n        for i in 0..chunks {\n            // SAFETY: i is in [0, chunks) so the adds and dereferences are in-bounds.\n            unsafe { swap_chunk(&mut *x.add(i), &mut *y.add(i)) };\n        }\n    }\n\n    // Same as `swap_nonoverlapping_bytes`, but accepts at most 1+2+4=7 bytes\n    #[inline]\n    unsafe fn swap_nonoverlapping_short(x: *mut u8, y: *mut u8, bytes: NonZero<usize>) {\n        // Tail handling for auto-vectorized code sometimes has element-at-a-time behaviour,\n        // see <https://github.com/rust-lang/rust/issues/134946>.\n        // By swapping as different sizes, rather than as a loop over bytes,\n        // we make sure not to end up with, say, seven byte-at-a-time copies.\n\n        let bytes = bytes.get();\n        let mut i = 0;\n        macro_rules! swap_prefix {\n            ($($n:literal)+) => {$(\n                if (bytes & $n) != 0 {\n                    // SAFETY: `i` can only have the same bits set as those in bytes,\n                    // so these `add`s are in-bounds of `bytes`.  But the bit for\n                    // `$n` hasn't been set yet, so the `$n` bytes that `swap_chunk`\n                    // will read and write are within the usable range.\n                    unsafe { swap_chunk::<$n>(&mut*x.add(i).cast(), &mut*y.add(i).cast()) };\n                    i |= $n;\n                }\n            )+};\n        }\n        swap_prefix!(4 2 1);\n        debug_assert_eq!(i, bytes);\n    }\n\n    const CHUNK_SIZE: usize = size_of::<*const ()>();\n    let bytes = bytes.get();\n\n    let chunks = bytes / CHUNK_SIZE;\n    let tail = bytes % CHUNK_SIZE;\n    if let Some(chunks) = NonZero::new(chunks) {\n        // SAFETY: this is bytes/CHUNK_SIZE*CHUNK_SIZE bytes, which is <= bytes,\n        // so it's within the range of our non-overlapping bytes.\n        unsafe { swap_nonoverlapping_chunks::<CHUNK_SIZE>(x.cast(), y.cast(), chunks) };\n    }\n    if let Some(tail) = NonZero::new(tail) {\n        const { assert!(CHUNK_SIZE <= 8) };\n        let delta = chunks * CHUNK_SIZE;\n        // SAFETY: the tail length is below CHUNK SIZE because of the remainder,\n        // and CHUNK_SIZE is at most 8 by the const assert, so tail <= 7\n        unsafe { swap_nonoverlapping_short(x.add(delta), y.add(delta), tail) };\n    }\n}",
  "mir": "fn ptr::swap_nonoverlapping_bytes(_1: *mut u8, _2: *mut u8, _3: num::nonzero::NonZero<usize>) -> () {\n    let mut _0: ();\n    let  _4: usize;\n    let  _5: usize;\n    let mut _6: bool;\n    let  _7: usize;\n    let mut _8: bool;\n    let mut _9: option::Option<num::nonzero::NonZero<usize>>;\n    let mut _10: isize;\n    let  _11: num::nonzero::NonZero<usize>;\n    let  _12: ();\n    let mut _13: *mut mem::maybe_uninit::MaybeUninit<[u8; 8]>;\n    let mut _14: *mut mem::maybe_uninit::MaybeUninit<[u8; 8]>;\n    let mut _15: option::Option<num::nonzero::NonZero<usize>>;\n    let mut _16: isize;\n    let  _17: num::nonzero::NonZero<usize>;\n    let  _18: usize;\n    let mut _19: (usize, bool);\n    let  _20: ();\n    let mut _21: *mut u8;\n    let mut _22: *mut u8;\n    debug x => _1;\n    debug y => _2;\n    debug bytes => _3;\n    debug bytes => _4;\n    debug chunks => _5;\n    debug tail => _7;\n    debug chunks => _11;\n    debug tail => _17;\n    debug delta => _18;\n    bb0: {\n        _4 = num::nonzero::NonZero::<usize>::get(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = Eq(ptr::swap_nonoverlapping_bytes::CHUNK_SIZE, 0_usize);\n        assert(!move _6, \"attempt to divide `{}` by zero\", _4) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = Div(_4, ptr::swap_nonoverlapping_bytes::CHUNK_SIZE);\n        _8 = Eq(ptr::swap_nonoverlapping_bytes::CHUNK_SIZE, 0_usize);\n        assert(!move _8, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _4) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = Rem(_4, ptr::swap_nonoverlapping_bytes::CHUNK_SIZE);\n        StorageLive(_9);\n        _9 = num::nonzero::NonZero::<usize>::new(_5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = discriminant(_9);\n        switchInt(move _10) -> [1: bb5, 0: bb9, otherwise: bb19];\n    }\n    bb5: {\n        _11 = ((_9 as variant#1).0: num::nonzero::NonZero<usize>);\n        StorageLive(_13);\n        _13 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 8]>>(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_14);\n        _14 = ptr::mut_ptr::<impl *mut u8>::cast::<mem::maybe_uninit::MaybeUninit<[u8; 8]>>(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_chunks::<8>(move _13, move _14, _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_9);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_9);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_15);\n        _15 = num::nonzero::NonZero::<usize>::new(_7) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _16 = discriminant(_15);\n        switchInt(move _16) -> [1: bb12, 0: bb17, otherwise: bb19];\n    }\n    bb12: {\n        _17 = ((_15 as variant#1).0: num::nonzero::NonZero<usize>);\n        _19 = CheckedMul(_5, ptr::swap_nonoverlapping_bytes::CHUNK_SIZE);\n        assert(!move (_19.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _5, ptr::swap_nonoverlapping_bytes::CHUNK_SIZE) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = move (_19.0: usize);\n        StorageLive(_21);\n        _21 = ptr::mut_ptr::<impl *mut u8>::add(_1, _18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_22);\n        _22 = ptr::mut_ptr::<impl *mut u8>::add(_2, _18) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20 = ptr::swap_nonoverlapping_bytes::swap_nonoverlapping_short(move _21, move _22, _17) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_15);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_15);\n        goto -> bb18;\n    }\n    bb18: {\n        return;\n    }\n    bb19: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}