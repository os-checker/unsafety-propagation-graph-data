{
  "name": "num::<impl i128>::from_ascii_radix",
  "safe": true,
  "callees": {
    "num::from_ascii_radix_panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "num::can_not_overflow": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Determines if a string of text of that length of that radix could be guaranteed to be\n stored in the given type T.\n Note that if the radix is known to the compiler, it is just the check of digits.len that\n is done at runtime.\n",
      "adt": {}
    },
    "char::methods::<impl char>::to_digit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a `char` to a digit in the given radix.\n\n A 'radix' here is sometimes also called a 'base'. A radix of two\n indicates a binary number, a radix of ten, decimal, and a radix of\n sixteen, hexadecimal, to give some common values. Arbitrary\n radices are supported.\n\n 'Digit' is defined to be only the following characters:\n\n * `0-9`\n * `a-z`\n * `A-Z`\n\n # Errors\n\n Returns `None` if the `char` does not refer to a digit in the given radix.\n\n # Panics\n\n Panics if given a radix smaller than 2 or larger than 36.\n\n # Examples\n\n Basic usage:\n\n ```\n assert_eq!('1'.to_digit(10), Some(1));\n assert_eq!('f'.to_digit(16), Some(15));\n ```\n\n Passing a non-digit results in failure:\n\n ```\n assert_eq!('f'.to_digit(10), None);\n assert_eq!('z'.to_digit(16), None);\n ```\n\n Passing a large radix, causing a panic:\n\n ```should_panic\n // this panics\n let _ = '1'.to_digit(37);\n ```\n Passing a small radix, causing a panic:\n\n ```should_panic\n // this panics\n let _ = '1'.to_digit(1);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl i128>::checked_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer multiplication. Computes `self * rhs`, returning `None` if\n overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl i128>::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer addition. Computes `self + rhs`, returning `None`\n if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl i128>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning `None` if\n overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "num::error::IntErrorKind": [
      "Plain"
    ],
    "num::error::ParseIntError": [
      "Plain"
    ],
    "result::Result": [
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 65, kind: RigidTy(Int(I128)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::<impl i128>::from_ascii_radix"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/mod.rs:1573:13: 1661:14",
  "src": "pub const fn from_ascii_radix(src: &[u8], radix: u32) -> Result<$int_ty, ParseIntError> {\n                use self::IntErrorKind::*;\n                use self::ParseIntError as PIE;\n\n                if 2 > radix || radix > 36 {\n                    from_ascii_radix_panic(radix);\n                }\n\n                if src.is_empty() {\n                    return Err(PIE { kind: Empty });\n                }\n\n                #[allow(unused_comparisons)]\n                let is_signed_ty = 0 > <$int_ty>::MIN;\n\n                let (is_positive, mut digits) = match src {\n                    [b'+' | b'-'] => {\n                        return Err(PIE { kind: InvalidDigit });\n                    }\n                    [b'+', rest @ ..] => (true, rest),\n                    [b'-', rest @ ..] if is_signed_ty => (false, rest),\n                    _ => (true, src),\n                };\n\n                let mut result = 0;\n\n                macro_rules! unwrap_or_PIE {\n                    ($option:expr, $kind:ident) => {\n                        match $option {\n                            Some(value) => value,\n                            None => return Err(PIE { kind: $kind }),\n                        }\n                    };\n                }\n\n                if can_not_overflow::<$int_ty>(radix, is_signed_ty, digits) {\n                    // If the len of the str is short compared to the range of the type\n                    // we are parsing into, then we can be certain that an overflow will not occur.\n                    // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition\n                    // above is a faster (conservative) approximation of this.\n                    //\n                    // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:\n                    // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.\n                    // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.\n                    macro_rules! run_unchecked_loop {\n                        ($unchecked_additive_op:tt) => {{\n                            while let [c, rest @ ..] = digits {\n                                result = result * (radix as $int_ty);\n                                let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit);\n                                result = result $unchecked_additive_op (x as $int_ty);\n                                digits = rest;\n                            }\n                        }};\n                    }\n                    if is_positive {\n                        run_unchecked_loop!(+)\n                    } else {\n                        run_unchecked_loop!(-)\n                    };\n                } else {\n                    macro_rules! run_checked_loop {\n                        ($checked_additive_op:ident, $overflow_err:ident) => {{\n                            while let [c, rest @ ..] = digits {\n                                // When `radix` is passed in as a literal, rather than doing a slow `imul`\n                                // the compiler can use shifts if `radix` can be expressed as a\n                                // sum of powers of 2 (x*10 can be written as x*8 + x*2).\n                                // When the compiler can't use these optimisations,\n                                // the latency of the multiplication can be hidden by issuing it\n                                // before the result is needed to improve performance on\n                                // modern out-of-order CPU as multiplication here is slower\n                                // than the other instructions, we can get the end result faster\n                                // doing multiplication first and let the CPU spends other cycles\n                                // doing other computation and get multiplication result later.\n                                let mul = result.checked_mul(radix as $int_ty);\n                                let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit) as $int_ty;\n                                result = unwrap_or_PIE!(mul, $overflow_err);\n                                result = unwrap_or_PIE!(<$int_ty>::$checked_additive_op(result, x), $overflow_err);\n                                digits = rest;\n                            }\n                        }};\n                    }\n                    if is_positive {\n                        run_checked_loop!(checked_add, PosOverflow)\n                    } else {\n                        run_checked_loop!(checked_sub, NegOverflow)\n                    };\n                }\n                Ok(result)\n            }",
  "mir": "fn num::<impl i128>::from_ascii_radix(_1: &[u8], _2: u32) -> result::Result<i128, num::error::ParseIntError> {\n    let mut _0: result::Result<i128, num::error::ParseIntError>;\n    let mut _3: bool;\n    let mut _4: bool;\n    let  _5: !;\n    let mut _6: bool;\n    let mut _7: num::error::ParseIntError;\n    let mut _8: num::error::IntErrorKind;\n    let  _9: bool;\n    let  _10: bool;\n    let mut _11: &[u8];\n    let mut _12: (bool, &[u8]);\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: bool;\n    let mut _16: num::error::ParseIntError;\n    let mut _17: num::error::IntErrorKind;\n    let  _18: &[u8];\n    let  _19: &[u8];\n    let  _20: &&[u8];\n    let mut _21: i128;\n    let mut _22: bool;\n    let mut _23: &[u8];\n    let mut _24: usize;\n    let mut _25: bool;\n    let  _26: &u8;\n    let  _27: &[u8];\n    let mut _28: i128;\n    let mut _29: i128;\n    let mut _30: (i128, bool);\n    let mut _31: option::Option<u32>;\n    let mut _32: char;\n    let mut _33: u8;\n    let mut _34: isize;\n    let  _35: u32;\n    let mut _36: num::error::ParseIntError;\n    let mut _37: num::error::IntErrorKind;\n    let mut _38: i128;\n    let mut _39: i128;\n    let mut _40: (i128, bool);\n    let mut _41: usize;\n    let mut _42: bool;\n    let  _43: &u8;\n    let  _44: &[u8];\n    let mut _45: i128;\n    let mut _46: i128;\n    let mut _47: (i128, bool);\n    let mut _48: option::Option<u32>;\n    let mut _49: char;\n    let mut _50: u8;\n    let mut _51: isize;\n    let  _52: u32;\n    let mut _53: num::error::ParseIntError;\n    let mut _54: num::error::IntErrorKind;\n    let mut _55: i128;\n    let mut _56: i128;\n    let mut _57: (i128, bool);\n    let mut _58: usize;\n    let mut _59: bool;\n    let  _60: &u8;\n    let  _61: &[u8];\n    let  _62: option::Option<i128>;\n    let mut _63: i128;\n    let mut _64: i128;\n    let  _65: i128;\n    let mut _66: option::Option<u32>;\n    let mut _67: char;\n    let mut _68: u8;\n    let mut _69: isize;\n    let  _70: u32;\n    let mut _71: num::error::ParseIntError;\n    let mut _72: num::error::IntErrorKind;\n    let mut _73: isize;\n    let  _74: i128;\n    let mut _75: num::error::ParseIntError;\n    let mut _76: num::error::IntErrorKind;\n    let mut _77: option::Option<i128>;\n    let mut _78: i128;\n    let mut _79: isize;\n    let  _80: i128;\n    let mut _81: num::error::ParseIntError;\n    let mut _82: num::error::IntErrorKind;\n    let mut _83: usize;\n    let mut _84: bool;\n    let  _85: &u8;\n    let  _86: &[u8];\n    let  _87: option::Option<i128>;\n    let mut _88: i128;\n    let mut _89: i128;\n    let  _90: i128;\n    let mut _91: option::Option<u32>;\n    let mut _92: char;\n    let mut _93: u8;\n    let mut _94: isize;\n    let  _95: u32;\n    let mut _96: num::error::ParseIntError;\n    let mut _97: num::error::IntErrorKind;\n    let mut _98: isize;\n    let  _99: i128;\n    let mut _100: num::error::ParseIntError;\n    let mut _101: num::error::IntErrorKind;\n    let mut _102: option::Option<i128>;\n    let mut _103: i128;\n    let mut _104: isize;\n    let  _105: i128;\n    let mut _106: num::error::ParseIntError;\n    let mut _107: num::error::IntErrorKind;\n    let mut _108: i128;\n    debug src => _1;\n    debug radix => _2;\n    debug is_signed_ty => _9;\n    debug is_positive => _10;\n    debug digits => _11;\n    debug rest => _18;\n    debug rest => _19;\n    debug rest => _20;\n    debug result => _21;\n    debug c => _26;\n    debug rest => _27;\n    debug x => _35;\n    debug value => _35;\n    debug c => _43;\n    debug rest => _44;\n    debug x => _52;\n    debug value => _52;\n    debug c => _60;\n    debug rest => _61;\n    debug mul => _62;\n    debug x => _65;\n    debug value => _70;\n    debug value => _74;\n    debug value => _80;\n    debug c => _85;\n    debug rest => _86;\n    debug mul => _87;\n    debug x => _90;\n    debug value => _95;\n    debug value => _99;\n    debug value => _105;\n    bb0: {\n        StorageLive(_3);\n        _3 = Gt(2_u32, _2);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        goto -> bb4;\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = Gt(_2, 36_u32);\n        switchInt(move _4) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        _5 = num::from_ascii_radix_panic(_2) -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        _6 = slice::<impl [u8]>::is_empty(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _6) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = num::error::IntErrorKind::Empty;\n        _7 = ParseIntError(move _8);\n        StorageDead(_8);\n        _0 = result::Result::Err(move _7);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb68;\n    }\n    bb8: {\n        StorageDead(_6);\n        _9 = Gt(0_i128, num::<impl i128>::MIN);\n        StorageLive(_12);\n        _13 = PtrMetadata(_1);\n        switchInt(_13) -> [1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        _14 = PtrMetadata(_1);\n        _15 = Ge(_14, 1_usize);\n        switchInt(move _15) -> [0: bb11, otherwise: bb12];\n    }\n    bb10: {\n        switchInt((*_1)[0 of 1]) -> [43: bb15, 45: bb15, otherwise: bb9];\n    }\n    bb11: {\n        _12 = (true, _1);\n        goto -> bb18;\n    }\n    bb12: {\n        switchInt((*_1)[0 of 1]) -> [43: bb14, 45: bb13, otherwise: bb11];\n    }\n    bb13: {\n        StorageLive(_20);\n        _19 = &(*_1)[1:];\n        _20 = &_19;\n        switchInt(_9) -> [0: bb17, otherwise: bb16];\n    }\n    bb14: {\n        _18 = &(*_1)[1:];\n        _12 = (true, _18);\n        goto -> bb18;\n    }\n    bb15: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = num::error::IntErrorKind::InvalidDigit;\n        _16 = ParseIntError(move _17);\n        StorageDead(_17);\n        _0 = result::Result::Err(move _16);\n        StorageDead(_16);\n        StorageDead(_12);\n        goto -> bb67;\n    }\n    bb16: {\n        _12 = (false, _19);\n        StorageDead(_20);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_20);\n        goto -> bb11;\n    }\n    bb18: {\n        _10 = (_12.0: bool);\n        StorageLive(_11);\n        _11 = (_12.1: &[u8]);\n        StorageDead(_12);\n        StorageLive(_21);\n        _21 = 0_i128;\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = _11;\n        _22 = num::can_not_overflow::<i128>(_2, _9, move _23) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        switchInt(move _22) -> [0: bb37, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_23);\n        switchInt(_10) -> [0: bb29, otherwise: bb21];\n    }\n    bb21: {\n        _24 = PtrMetadata(_11);\n        _25 = Ge(_24, 1_usize);\n        switchInt(move _25) -> [0: bb36, otherwise: bb22];\n    }\n    bb22: {\n        StorageLive(_26);\n        _26 = &(*_11)[0 of 1];\n        _27 = &(*_11)[1:];\n        StorageLive(_28);\n        _28 = _21;\n        StorageLive(_29);\n        _29 = _2 as i128;\n        _30 = CheckedMul(_28, _29);\n        assert(!move (_30.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _28, move _29) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _21 = move (_30.0: i128);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = (*_26);\n        _32 = move _33 as char;\n        StorageDead(_33);\n        _31 = char::methods::<impl char>::to_digit(move _32, _2) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_32);\n        _34 = discriminant(_31);\n        switchInt(move _34) -> [0: bb26, 1: bb27, otherwise: bb25];\n    }\n    bb25: {\n        unreachable;\n    }\n    bb26: {\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = num::error::IntErrorKind::InvalidDigit;\n        _36 = ParseIntError(move _37);\n        StorageDead(_37);\n        _0 = result::Result::Err(move _36);\n        StorageDead(_36);\n        StorageDead(_31);\n        StorageDead(_26);\n        goto -> bb65;\n    }\n    bb27: {\n        _35 = ((_31 as variant#1).0: u32);\n        StorageDead(_31);\n        StorageLive(_38);\n        _38 = _21;\n        StorageLive(_39);\n        _39 = _35 as i128;\n        _40 = CheckedAdd(_38, _39);\n        assert(!move (_40.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _38, move _39) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _21 = move (_40.0: i128);\n        StorageDead(_39);\n        StorageDead(_38);\n        _11 = _27;\n        StorageDead(_26);\n        goto -> bb21;\n    }\n    bb29: {\n        _41 = PtrMetadata(_11);\n        _42 = Ge(_41, 1_usize);\n        switchInt(move _42) -> [0: bb36, otherwise: bb30];\n    }\n    bb30: {\n        StorageLive(_43);\n        _43 = &(*_11)[0 of 1];\n        _44 = &(*_11)[1:];\n        StorageLive(_45);\n        _45 = _21;\n        StorageLive(_46);\n        _46 = _2 as i128;\n        _47 = CheckedMul(_45, _46);\n        assert(!move (_47.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _45, move _46) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _21 = move (_47.0: i128);\n        StorageDead(_46);\n        StorageDead(_45);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = (*_43);\n        _49 = move _50 as char;\n        StorageDead(_50);\n        _48 = char::methods::<impl char>::to_digit(move _49, _2) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_49);\n        _51 = discriminant(_48);\n        switchInt(move _51) -> [0: bb33, 1: bb34, otherwise: bb25];\n    }\n    bb33: {\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = num::error::IntErrorKind::InvalidDigit;\n        _53 = ParseIntError(move _54);\n        StorageDead(_54);\n        _0 = result::Result::Err(move _53);\n        StorageDead(_53);\n        StorageDead(_48);\n        StorageDead(_43);\n        goto -> bb65;\n    }\n    bb34: {\n        _52 = ((_48 as variant#1).0: u32);\n        StorageDead(_48);\n        StorageLive(_55);\n        _55 = _21;\n        StorageLive(_56);\n        _56 = _52 as i128;\n        _57 = CheckedSub(_55, _56);\n        assert(!move (_57.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _55, move _56) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _21 = move (_57.0: i128);\n        StorageDead(_56);\n        StorageDead(_55);\n        _11 = _44;\n        StorageDead(_43);\n        goto -> bb29;\n    }\n    bb36: {\n        goto -> bb61;\n    }\n    bb37: {\n        StorageDead(_23);\n        switchInt(_10) -> [0: bb49, otherwise: bb38];\n    }\n    bb38: {\n        _58 = PtrMetadata(_11);\n        _59 = Ge(_58, 1_usize);\n        switchInt(move _59) -> [0: bb60, otherwise: bb39];\n    }\n    bb39: {\n        StorageLive(_60);\n        _60 = &(*_11)[0 of 1];\n        _61 = &(*_11)[1:];\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = _21;\n        StorageLive(_64);\n        _64 = _2 as i128;\n        _62 = num::<impl i128>::checked_mul(move _63, move _64) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageLive(_66);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = (*_60);\n        _67 = move _68 as char;\n        StorageDead(_68);\n        _66 = char::methods::<impl char>::to_digit(move _67, _2) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_67);\n        _69 = discriminant(_66);\n        switchInt(move _69) -> [0: bb42, 1: bb43, otherwise: bb25];\n    }\n    bb42: {\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = num::error::IntErrorKind::InvalidDigit;\n        _71 = ParseIntError(move _72);\n        StorageDead(_72);\n        _0 = result::Result::Err(move _71);\n        StorageDead(_71);\n        StorageDead(_66);\n        goto -> bb63;\n    }\n    bb43: {\n        _70 = ((_66 as variant#1).0: u32);\n        _65 = _70 as i128;\n        StorageDead(_66);\n        _73 = discriminant(_62);\n        switchInt(move _73) -> [0: bb44, 1: bb45, otherwise: bb25];\n    }\n    bb44: {\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = num::error::IntErrorKind::PosOverflow;\n        _75 = ParseIntError(move _76);\n        StorageDead(_76);\n        _0 = result::Result::Err(move _75);\n        StorageDead(_75);\n        goto -> bb63;\n    }\n    bb45: {\n        _74 = ((_62 as variant#1).0: i128);\n        _21 = _74;\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = _21;\n        _77 = num::<impl i128>::checked_add(move _78, _65) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_78);\n        _79 = discriminant(_77);\n        switchInt(move _79) -> [0: bb47, 1: bb48, otherwise: bb25];\n    }\n    bb47: {\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = num::error::IntErrorKind::PosOverflow;\n        _81 = ParseIntError(move _82);\n        StorageDead(_82);\n        _0 = result::Result::Err(move _81);\n        StorageDead(_81);\n        StorageDead(_77);\n        goto -> bb63;\n    }\n    bb48: {\n        _80 = ((_77 as variant#1).0: i128);\n        _21 = _80;\n        StorageDead(_77);\n        _11 = _61;\n        StorageDead(_62);\n        StorageDead(_60);\n        goto -> bb38;\n    }\n    bb49: {\n        _83 = PtrMetadata(_11);\n        _84 = Ge(_83, 1_usize);\n        switchInt(move _84) -> [0: bb60, otherwise: bb50];\n    }\n    bb50: {\n        StorageLive(_85);\n        _85 = &(*_11)[0 of 1];\n        _86 = &(*_11)[1:];\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = _21;\n        StorageLive(_89);\n        _89 = _2 as i128;\n        _87 = num::<impl i128>::checked_mul(move _88, move _89) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_89);\n        StorageDead(_88);\n        StorageLive(_91);\n        StorageLive(_92);\n        StorageLive(_93);\n        _93 = (*_85);\n        _92 = move _93 as char;\n        StorageDead(_93);\n        _91 = char::methods::<impl char>::to_digit(move _92, _2) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_92);\n        _94 = discriminant(_91);\n        switchInt(move _94) -> [0: bb53, 1: bb54, otherwise: bb25];\n    }\n    bb53: {\n        StorageLive(_96);\n        StorageLive(_97);\n        _97 = num::error::IntErrorKind::InvalidDigit;\n        _96 = ParseIntError(move _97);\n        StorageDead(_97);\n        _0 = result::Result::Err(move _96);\n        StorageDead(_96);\n        StorageDead(_91);\n        goto -> bb62;\n    }\n    bb54: {\n        _95 = ((_91 as variant#1).0: u32);\n        _90 = _95 as i128;\n        StorageDead(_91);\n        _98 = discriminant(_87);\n        switchInt(move _98) -> [0: bb55, 1: bb56, otherwise: bb25];\n    }\n    bb55: {\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = num::error::IntErrorKind::NegOverflow;\n        _100 = ParseIntError(move _101);\n        StorageDead(_101);\n        _0 = result::Result::Err(move _100);\n        StorageDead(_100);\n        goto -> bb62;\n    }\n    bb56: {\n        _99 = ((_87 as variant#1).0: i128);\n        _21 = _99;\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = _21;\n        _102 = num::<impl i128>::checked_sub(move _103, _90) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_103);\n        _104 = discriminant(_102);\n        switchInt(move _104) -> [0: bb58, 1: bb59, otherwise: bb25];\n    }\n    bb58: {\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = num::error::IntErrorKind::NegOverflow;\n        _106 = ParseIntError(move _107);\n        StorageDead(_107);\n        _0 = result::Result::Err(move _106);\n        StorageDead(_106);\n        StorageDead(_102);\n        goto -> bb62;\n    }\n    bb59: {\n        _105 = ((_102 as variant#1).0: i128);\n        _21 = _105;\n        StorageDead(_102);\n        _11 = _86;\n        StorageDead(_87);\n        StorageDead(_85);\n        goto -> bb49;\n    }\n    bb60: {\n        goto -> bb61;\n    }\n    bb61: {\n        StorageDead(_22);\n        StorageLive(_108);\n        _108 = _21;\n        _0 = result::Result::Ok(move _108);\n        StorageDead(_108);\n        StorageDead(_21);\n        StorageDead(_11);\n        goto -> bb68;\n    }\n    bb62: {\n        StorageDead(_87);\n        StorageDead(_85);\n        goto -> bb64;\n    }\n    bb63: {\n        StorageDead(_62);\n        StorageDead(_60);\n        goto -> bb64;\n    }\n    bb64: {\n        goto -> bb66;\n    }\n    bb65: {\n        goto -> bb66;\n    }\n    bb66: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_11);\n        goto -> bb67;\n    }\n    bb67: {\n        goto -> bb68;\n    }\n    bb68: {\n        return;\n    }\n}\n",
  "doc": " Parses an integer from an ASCII-byte slice with digits in a given base.\n\n The characters are expected to be an optional\n sign followed by only digits. Leading and trailing non-digit characters (including\n whitespace) represent an error. Underscores (which are accepted in Rust literals)\n also represent an error.\n\n Digits are a subset of these characters, depending on `radix`:\n * `0-9`\n * `a-z`\n * `A-Z`\n\n # Panics\n\n This function panics if `radix` is not in the range from 2 to 36.\n\n # Examples\n\n ```\n #![feature(int_from_ascii)]\n\n ```\n Trailing space returns error:\n ```\n # #![feature(int_from_ascii)]\n #\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}