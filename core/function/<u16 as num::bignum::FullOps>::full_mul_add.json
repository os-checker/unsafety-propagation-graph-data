{
  "name": "<u16 as num::bignum::FullOps>::full_mul_add",
  "safe": true,
  "callees": {
    "num::<impl u16>::carrying_mul_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the \"full multiplication\" `self * rhs + carry + add`.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order.\n\n This cannot overflow, as the double-width result has exactly enough\n space for the largest possible result. This is equivalent to how, in\n decimal, 9 × 9 + 9 + 9 = 81 + 18 = 99 = 9×10⁰ + 9×10¹ = 10² - 1.\n\n Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n additional amount of overflow. This allows for chaining together multiple\n multiplications to create \"big integers\" which represent larger values.\n\n If you don't need the `add` part, then you can use [`Self::carrying_mul`] instead.\n\n # Examples\n\n Please note that this example is shared between integer types,\n which explains why `u32` is used here.\n\n ```\n assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n ```\n\n This is the core per-digit operation for \"grade school\" O(n²) multiplication.\n\n Please note that this example is shared between integer types,\n using `u8` for simplicity of the demonstration.\n\n ```\n fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n     let mut out = [0; N];\n     for j in 0..N {\n         let mut carry = 0;\n         for i in 0..(N - j) {\n             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n         }\n     }\n     out\n }\n\n // -1 * -1 == 1\n assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n\n assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xcffc982d);\n assert_eq!(\n     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n     u32::to_le_bytes(0xcffc982d)\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::<u16 as num::bignum::FullOps>::full_mul_add"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/bignum.rs:38:17: 43:18",
  "src": "fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n                    // This cannot overflow;\n                    // the output is between `0` and `2^nbits * (2^nbits - 1)`.\n                    let (lo, hi) = self.carrying_mul_add(other, other2, carry);\n                    (hi, lo)\n                }",
  "mir": "fn <u16 as num::bignum::FullOps>::full_mul_add(_1: u16, _2: u16, _3: u16, _4: u16) -> (u16, u16) {\n    let mut _0: (u16, u16);\n    let  _5: u16;\n    let  _6: u16;\n    let mut _7: (u16, u16);\n    debug self => _1;\n    debug other => _2;\n    debug other2 => _3;\n    debug carry => _4;\n    debug lo => _5;\n    debug hi => _6;\n    bb0: {\n        StorageLive(_7);\n        _7 = num::<impl u16>::carrying_mul_add(_1, _2, _3, _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = (_7.0: u16);\n        _6 = (_7.1: u16);\n        StorageDead(_7);\n        _0 = (_6, _5);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}