{
  "name": "num::int_sqrt::u128_stages",
  "safe": true,
  "callees": {
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "num::<impl u16>::overflowing_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates `self` - `rhs`.\n\n Returns a tuple of the subtraction along with a boolean indicating\n whether an arithmetic overflow would occur. If an overflow would\n have occurred then the wrapped value is returned.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u16>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u32>::overflowing_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates `self` - `rhs`.\n\n Returns a tuple of the subtraction along with a boolean indicating\n whether an arithmetic overflow would occur. If an overflow would\n have occurred then the wrapped value is returned.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u32>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::overflowing_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates `self` - `rhs`.\n\n Returns a tuple of the subtraction along with a boolean indicating\n whether an arithmetic overflow would occur. If an overflow would\n have occurred then the wrapped value is returned.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u64>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "num::<impl u128>::overflowing_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the multiplication of `self` and `rhs`.\n\n Returns a tuple of the multiplication along with a boolean\n indicating whether an arithmetic overflow would occur. If an\n overflow would have occurred then the wrapped value is returned.\n\n If you want the *value* of the overflow, rather than just *whether*\n an overflow occurred, see [`Self::carrying_mul`].\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u32` is used.\n\n ```\n assert_eq!(5u32.overflowing_mul(2), (10, false));\n assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::int_sqrt::u128_stages"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_sqrt.rs:297:1: 303:2",
  "src": "const fn u128_stages(n: u128) -> u128 {\n    let (s, r) = first_stage!(128, n);\n    let (s, r) = middle_stage!(128, u16, n, s, r);\n    let (s, r) = middle_stage!(128, u32, n, s, r);\n    let (s, r) = middle_stage!(128, u64, n, s, r);\n    last_stage!(u128, n, s, r)\n}",
  "mir": "fn num::int_sqrt::u128_stages(_1: u128) -> u128 {\n    let mut _0: u128;\n    let  _2: u8;\n    let  _3: u8;\n    let mut _4: (u8, u8);\n    let  _5: !;\n    let mut _6: fmt::Arguments<'_>;\n    let  _7: u128;\n    let mut _8: bool;\n    let  _9: u8;\n    let  _10: u8;\n    let mut _11: [(u8, u8); 256];\n    let  _12: usize;\n    let mut _13: bool;\n    let  _14: ();\n    let mut _15: bool;\n    let  _16: u16;\n    let  _17: u16;\n    let mut _18: (u16, u16);\n    let  _19: !;\n    let mut _20: fmt::Arguments<'_>;\n    let  _21: u16;\n    let mut _22: u128;\n    let mut _23: bool;\n    let  _24: u16;\n    let  _25: u16;\n    let mut _26: u16;\n    let mut _27: u16;\n    let mut _28: bool;\n    let mut _29: u16;\n    let mut _30: bool;\n    let  _31: u16;\n    let mut _32: u16;\n    let mut _33: u32;\n    let mut _34: bool;\n    let  _35: u16;\n    let mut _36: bool;\n    let  _37: u16;\n    let mut _38: bool;\n    let mut _39: u16;\n    let mut _40: u16;\n    let mut _41: u8;\n    let mut _42: bool;\n    let mut _43: (u16, bool);\n    let mut _44: u16;\n    let  _45: bool;\n    let mut _46: (u16, bool);\n    let mut _47: u16;\n    let mut _48: u16;\n    let mut _49: bool;\n    let mut _50: u16;\n    let mut _51: u16;\n    let mut _52: (u16, bool);\n    let mut _53: u16;\n    let mut _54: u16;\n    let mut _55: u16;\n    let mut _56: u16;\n    let mut _57: u16;\n    let mut _58: (u16, bool);\n    let mut _59: (u16, bool);\n    let mut _60: (u16, bool);\n    let  _61: ();\n    let mut _62: bool;\n    let mut _63: u16;\n    let mut _64: u16;\n    let mut _65: u16;\n    let  _66: u32;\n    let  _67: u32;\n    let mut _68: (u32, u32);\n    let  _69: !;\n    let mut _70: fmt::Arguments<'_>;\n    let  _71: u32;\n    let mut _72: u128;\n    let mut _73: bool;\n    let  _74: u32;\n    let  _75: u32;\n    let mut _76: u32;\n    let mut _77: u32;\n    let mut _78: bool;\n    let mut _79: u32;\n    let mut _80: bool;\n    let  _81: u32;\n    let mut _82: u32;\n    let mut _83: u32;\n    let mut _84: bool;\n    let  _85: u32;\n    let mut _86: bool;\n    let  _87: u32;\n    let mut _88: bool;\n    let mut _89: u32;\n    let mut _90: u32;\n    let mut _91: u16;\n    let mut _92: bool;\n    let mut _93: (u32, bool);\n    let mut _94: u32;\n    let  _95: bool;\n    let mut _96: (u32, bool);\n    let mut _97: u32;\n    let mut _98: u32;\n    let mut _99: bool;\n    let mut _100: u32;\n    let mut _101: u32;\n    let mut _102: (u32, bool);\n    let mut _103: u32;\n    let mut _104: u32;\n    let mut _105: u32;\n    let mut _106: u32;\n    let mut _107: u32;\n    let mut _108: (u32, bool);\n    let mut _109: (u32, bool);\n    let mut _110: (u32, bool);\n    let  _111: ();\n    let mut _112: bool;\n    let mut _113: u32;\n    let mut _114: u32;\n    let mut _115: u32;\n    let  _116: u64;\n    let  _117: u64;\n    let mut _118: (u64, u64);\n    let  _119: !;\n    let mut _120: fmt::Arguments<'_>;\n    let  _121: u64;\n    let mut _122: u128;\n    let mut _123: bool;\n    let  _124: u64;\n    let  _125: u64;\n    let mut _126: u64;\n    let mut _127: u64;\n    let mut _128: bool;\n    let mut _129: u64;\n    let mut _130: bool;\n    let  _131: u64;\n    let mut _132: u64;\n    let mut _133: u32;\n    let mut _134: bool;\n    let  _135: u64;\n    let mut _136: bool;\n    let  _137: u64;\n    let mut _138: bool;\n    let mut _139: u64;\n    let mut _140: u64;\n    let mut _141: u32;\n    let mut _142: bool;\n    let mut _143: (u64, bool);\n    let mut _144: u64;\n    let  _145: bool;\n    let mut _146: (u64, bool);\n    let mut _147: u64;\n    let mut _148: u64;\n    let mut _149: bool;\n    let mut _150: u64;\n    let mut _151: u64;\n    let mut _152: (u64, bool);\n    let mut _153: u64;\n    let mut _154: u64;\n    let mut _155: u64;\n    let mut _156: u64;\n    let mut _157: u64;\n    let mut _158: (u64, bool);\n    let mut _159: (u64, bool);\n    let mut _160: (u64, bool);\n    let  _161: ();\n    let mut _162: bool;\n    let mut _163: u64;\n    let mut _164: u64;\n    let mut _165: u64;\n    let  _166: !;\n    let mut _167: fmt::Arguments<'_>;\n    let  _168: u128;\n    let  _169: u128;\n    let mut _170: u128;\n    let mut _171: u128;\n    let mut _172: bool;\n    let mut _173: u128;\n    let mut _174: bool;\n    let  _175: u128;\n    let mut _176: u128;\n    let mut _177: u32;\n    let mut _178: bool;\n    let  _179: u128;\n    let mut _180: bool;\n    let mut _181: u128;\n    let mut _182: u128;\n    let mut _183: u64;\n    let mut _184: bool;\n    let mut _185: (u128, bool);\n    let  _186: u128;\n    let  _187: bool;\n    let mut _188: (u128, bool);\n    let mut _189: u128;\n    let mut _190: u128;\n    let mut _191: bool;\n    let mut _192: (u128, bool);\n    debug n => _1;\n    debug s => _2;\n    debug r => _3;\n    debug n => _7;\n    debug s => _9;\n    debug r => _10;\n    debug s => _16;\n    debug r => _17;\n    debug n => _21;\n    debug lo => _24;\n    debug numerator => _25;\n    debug denominator => _31;\n    debug q => _35;\n    debug u => _37;\n    debug s => _39;\n    debug r => _44;\n    debug overflow => _45;\n    debug s => _66;\n    debug r => _67;\n    debug n => _71;\n    debug lo => _74;\n    debug numerator => _75;\n    debug denominator => _81;\n    debug q => _85;\n    debug u => _87;\n    debug s => _89;\n    debug r => _94;\n    debug overflow => _95;\n    debug s => _116;\n    debug r => _117;\n    debug n => _121;\n    debug lo => _124;\n    debug numerator => _125;\n    debug denominator => _131;\n    debug q => _135;\n    debug u => _137;\n    debug s => _139;\n    debug r => _144;\n    debug overflow => _145;\n    debug lo => _168;\n    debug numerator => _169;\n    debug denominator => _175;\n    debug q => _179;\n    debug s => _181;\n    debug s_squared => _186;\n    debug overflow => _187;\n    bb0: {\n        StorageLive(_4);\n        switchInt(_1) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _8 = Lt(num::int_sqrt::u128_stages::N_SHIFT, 128_u32);\n        assert(move _8, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::N_SHIFT) -> [success: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = fmt::Arguments::<'_>::from_str(\"`$n` is  zero in `first_stage!`.\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n    bb4: {\n        _7 = Shr(_1, num::int_sqrt::u128_stages::N_SHIFT);\n        StorageLive(_11);\n        _11 = num::int_sqrt::U8_ISQRT_WITH_REMAINDER;\n        StorageLive(_12);\n        _12 = _7 as usize;\n        _13 = Lt(_12, 256_usize);\n        assert(move _13, \"index out of bounds: the length is {} but the index is {}\", 256_usize, _12) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = (_11[_12].0: u8);\n        _10 = (_11[_12].1: u8);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        _15 = Ne(_9, 0_u8);\n        _14 = hint::assert_unchecked(move _15) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_15);\n        _4 = (_9, _10);\n        _2 = (_4.0: u8);\n        _3 = (_4.1: u8);\n        StorageDead(_4);\n        StorageLive(_18);\n        switchInt(_2) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_22);\n        _23 = Lt(num::int_sqrt::u128_stages::N_SHIFT, 128_u32);\n        assert(move _23, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::N_SHIFT) -> [success: bb10, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_20);\n        _20 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `middle_stage!`.\") -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _19 = panicking::panic_fmt(move _20) -> unwind unreachable;\n    }\n    bb10: {\n        _22 = Shr(_1, num::int_sqrt::u128_stages::N_SHIFT);\n        _21 = move _22 as u16;\n        StorageDead(_22);\n        _24 = BitAnd(_21, num::int_sqrt::u128_stages::LOWER_HALF_1_BITS);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _3 as u16;\n        _28 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 16_u32);\n        assert(move _28, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _26 = Shl(move _27, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageDead(_27);\n        StorageLive(_29);\n        _30 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 16_u32);\n        assert(move _30, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _29 = Shr(_24, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _25 = BitOr(move _26, move _29);\n        StorageDead(_29);\n        StorageDead(_26);\n        StorageLive(_32);\n        _32 = _2 as u16;\n        _33 = 1_i32 as u32;\n        _34 = Lt(move _33, 16_u32);\n        assert(move _34, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _31 = Shl(move _32, 1_i32);\n        StorageDead(_32);\n        _36 = Eq(_31, 0_u16);\n        assert(!move _36, \"attempt to divide `{}` by zero\", _25) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _35 = Div(_25, _31);\n        _38 = Eq(_31, 0_u16);\n        assert(!move _38, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _25) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _37 = Rem(_25, _31);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _42 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 8_u32);\n        assert(move _42, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _41 = Shl(_2, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _40 = move _41 as u16;\n        StorageDead(_41);\n        _43 = CheckedAdd(_40, _35);\n        assert(!move (_43.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _40, _35) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _39 = move (_43.0: u16);\n        StorageDead(_40);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _49 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 16_u32);\n        assert(move _49, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _48 = Shl(_37, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageLive(_50);\n        _50 = BitAnd(_24, num::int_sqrt::u128_stages::LOWEST_QUARTER_1_BITS);\n        _47 = BitOr(move _48, move _50);\n        StorageDead(_50);\n        StorageDead(_48);\n        StorageLive(_51);\n        _52 = CheckedMul(_35, _35);\n        assert(!move (_52.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _35, _35) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _51 = move (_52.0: u16);\n        _46 = num::<impl u16>::overflowing_sub(move _47, move _51) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_51);\n        StorageDead(_47);\n        StorageLive(_44);\n        _44 = (_46.0: u16);\n        _45 = (_46.1: bool);\n        StorageDead(_46);\n        switchInt(_45) -> [0: bb26, otherwise: bb21];\n    }\n    bb21: {\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = _44;\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = _39;\n        _58 = CheckedMul(2_u16, _57);\n        assert(!move (_58.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u16, move _57) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _56 = move (_58.0: u16);\n        StorageDead(_57);\n        _59 = CheckedSub(_56, 1_u16);\n        assert(!move (_59.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _56, 1_u16) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _55 = move (_59.0: u16);\n        StorageDead(_56);\n        _53 = num::<impl u16>::wrapping_add(move _54, move _55) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_55);\n        StorageDead(_54);\n        _44 = move _53;\n        StorageDead(_53);\n        _60 = CheckedSub(_39, 1_u16);\n        assert(!move (_60.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _39, 1_u16) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _39 = move (_60.0: u16);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = _39;\n        _62 = Ne(move _63, 0_u16);\n        StorageDead(_63);\n        _61 = hint::assert_unchecked(move _62) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_62);\n        StorageLive(_64);\n        _64 = _39;\n        StorageLive(_65);\n        _65 = _44;\n        _18 = (move _64, move _65);\n        StorageDead(_65);\n        StorageDead(_64);\n        StorageDead(_44);\n        StorageDead(_39);\n        _16 = (_18.0: u16);\n        _17 = (_18.1: u16);\n        StorageDead(_18);\n        StorageLive(_68);\n        switchInt(_16) -> [0: bb29, otherwise: bb28];\n    }\n    bb28: {\n        StorageLive(_72);\n        _73 = Lt(num::int_sqrt::u128_stages::N_SHIFT, 128_u32);\n        assert(move _73, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::N_SHIFT) -> [success: bb31, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_70);\n        _70 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `middle_stage!`.\") -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        _69 = panicking::panic_fmt(move _70) -> unwind unreachable;\n    }\n    bb31: {\n        _72 = Shr(_1, num::int_sqrt::u128_stages::N_SHIFT);\n        _71 = move _72 as u32;\n        StorageDead(_72);\n        _74 = BitAnd(_71, num::int_sqrt::u128_stages::LOWER_HALF_1_BITS);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = _17 as u32;\n        _78 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 32_u32);\n        assert(move _78, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _76 = Shl(move _77, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageDead(_77);\n        StorageLive(_79);\n        _80 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 32_u32);\n        assert(move _80, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _79 = Shr(_74, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _75 = BitOr(move _76, move _79);\n        StorageDead(_79);\n        StorageDead(_76);\n        StorageLive(_82);\n        _82 = _16 as u32;\n        _83 = 1_i32 as u32;\n        _84 = Lt(move _83, 32_u32);\n        assert(move _84, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _81 = Shl(move _82, 1_i32);\n        StorageDead(_82);\n        _86 = Eq(_81, 0_u32);\n        assert(!move _86, \"attempt to divide `{}` by zero\", _75) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _85 = Div(_75, _81);\n        _88 = Eq(_81, 0_u32);\n        assert(!move _88, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _75) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _87 = Rem(_75, _81);\n        StorageLive(_89);\n        StorageLive(_90);\n        StorageLive(_91);\n        _92 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 16_u32);\n        assert(move _92, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _91 = Shl(_16, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _90 = move _91 as u32;\n        StorageDead(_91);\n        _93 = CheckedAdd(_90, _85);\n        assert(!move (_93.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _90, _85) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        _89 = move (_93.0: u32);\n        StorageDead(_90);\n        StorageLive(_96);\n        StorageLive(_97);\n        StorageLive(_98);\n        _99 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 32_u32);\n        assert(move _99, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _98 = Shl(_87, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageLive(_100);\n        _100 = BitAnd(_74, num::int_sqrt::u128_stages::LOWEST_QUARTER_1_BITS);\n        _97 = BitOr(move _98, move _100);\n        StorageDead(_100);\n        StorageDead(_98);\n        StorageLive(_101);\n        _102 = CheckedMul(_85, _85);\n        assert(!move (_102.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _85, _85) -> [success: bb40, unwind unreachable];\n    }\n    bb40: {\n        _101 = move (_102.0: u32);\n        _96 = num::<impl u32>::overflowing_sub(move _97, move _101) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_101);\n        StorageDead(_97);\n        StorageLive(_94);\n        _94 = (_96.0: u32);\n        _95 = (_96.1: bool);\n        StorageDead(_96);\n        switchInt(_95) -> [0: bb47, otherwise: bb42];\n    }\n    bb42: {\n        StorageLive(_103);\n        StorageLive(_104);\n        _104 = _94;\n        StorageLive(_105);\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = _89;\n        _108 = CheckedMul(2_u32, _107);\n        assert(!move (_108.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u32, move _107) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _106 = move (_108.0: u32);\n        StorageDead(_107);\n        _109 = CheckedSub(_106, 1_u32);\n        assert(!move (_109.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _106, 1_u32) -> [success: bb44, unwind unreachable];\n    }\n    bb44: {\n        _105 = move (_109.0: u32);\n        StorageDead(_106);\n        _103 = num::<impl u32>::wrapping_add(move _104, move _105) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_105);\n        StorageDead(_104);\n        _94 = move _103;\n        StorageDead(_103);\n        _110 = CheckedSub(_89, 1_u32);\n        assert(!move (_110.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _89, 1_u32) -> [success: bb46, unwind unreachable];\n    }\n    bb46: {\n        _89 = move (_110.0: u32);\n        goto -> bb47;\n    }\n    bb47: {\n        StorageLive(_112);\n        StorageLive(_113);\n        _113 = _89;\n        _112 = Ne(move _113, 0_u32);\n        StorageDead(_113);\n        _111 = hint::assert_unchecked(move _112) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_112);\n        StorageLive(_114);\n        _114 = _89;\n        StorageLive(_115);\n        _115 = _94;\n        _68 = (move _114, move _115);\n        StorageDead(_115);\n        StorageDead(_114);\n        StorageDead(_94);\n        StorageDead(_89);\n        _66 = (_68.0: u32);\n        _67 = (_68.1: u32);\n        StorageDead(_68);\n        StorageLive(_118);\n        switchInt(_66) -> [0: bb50, otherwise: bb49];\n    }\n    bb49: {\n        StorageLive(_122);\n        _123 = Lt(num::int_sqrt::u128_stages::N_SHIFT, 128_u32);\n        assert(move _123, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::N_SHIFT) -> [success: bb52, unwind unreachable];\n    }\n    bb50: {\n        StorageLive(_120);\n        _120 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `middle_stage!`.\") -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        _119 = panicking::panic_fmt(move _120) -> unwind unreachable;\n    }\n    bb52: {\n        _122 = Shr(_1, num::int_sqrt::u128_stages::N_SHIFT);\n        _121 = move _122 as u64;\n        StorageDead(_122);\n        _124 = BitAnd(_121, num::int_sqrt::u128_stages::LOWER_HALF_1_BITS);\n        StorageLive(_126);\n        StorageLive(_127);\n        _127 = _67 as u64;\n        _128 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 64_u32);\n        assert(move _128, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb53, unwind unreachable];\n    }\n    bb53: {\n        _126 = Shl(move _127, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageDead(_127);\n        StorageLive(_129);\n        _130 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 64_u32);\n        assert(move _130, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb54, unwind unreachable];\n    }\n    bb54: {\n        _129 = Shr(_124, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _125 = BitOr(move _126, move _129);\n        StorageDead(_129);\n        StorageDead(_126);\n        StorageLive(_132);\n        _132 = _66 as u64;\n        _133 = 1_i32 as u32;\n        _134 = Lt(move _133, 64_u32);\n        assert(move _134, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb55, unwind unreachable];\n    }\n    bb55: {\n        _131 = Shl(move _132, 1_i32);\n        StorageDead(_132);\n        _136 = Eq(_131, 0_u64);\n        assert(!move _136, \"attempt to divide `{}` by zero\", _125) -> [success: bb56, unwind unreachable];\n    }\n    bb56: {\n        _135 = Div(_125, _131);\n        _138 = Eq(_131, 0_u64);\n        assert(!move _138, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _125) -> [success: bb57, unwind unreachable];\n    }\n    bb57: {\n        _137 = Rem(_125, _131);\n        StorageLive(_139);\n        StorageLive(_140);\n        StorageLive(_141);\n        _142 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 32_u32);\n        assert(move _142, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb58, unwind unreachable];\n    }\n    bb58: {\n        _141 = Shl(_66, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _140 = move _141 as u64;\n        StorageDead(_141);\n        _143 = CheckedAdd(_140, _135);\n        assert(!move (_143.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _140, _135) -> [success: bb59, unwind unreachable];\n    }\n    bb59: {\n        _139 = move (_143.0: u64);\n        StorageDead(_140);\n        StorageLive(_146);\n        StorageLive(_147);\n        StorageLive(_148);\n        _149 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 64_u32);\n        assert(move _149, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb60, unwind unreachable];\n    }\n    bb60: {\n        _148 = Shl(_137, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageLive(_150);\n        _150 = BitAnd(_124, num::int_sqrt::u128_stages::LOWEST_QUARTER_1_BITS);\n        _147 = BitOr(move _148, move _150);\n        StorageDead(_150);\n        StorageDead(_148);\n        StorageLive(_151);\n        _152 = CheckedMul(_135, _135);\n        assert(!move (_152.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _135, _135) -> [success: bb61, unwind unreachable];\n    }\n    bb61: {\n        _151 = move (_152.0: u64);\n        _146 = num::<impl u64>::overflowing_sub(move _147, move _151) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_151);\n        StorageDead(_147);\n        StorageLive(_144);\n        _144 = (_146.0: u64);\n        _145 = (_146.1: bool);\n        StorageDead(_146);\n        switchInt(_145) -> [0: bb68, otherwise: bb63];\n    }\n    bb63: {\n        StorageLive(_153);\n        StorageLive(_154);\n        _154 = _144;\n        StorageLive(_155);\n        StorageLive(_156);\n        StorageLive(_157);\n        _157 = _139;\n        _158 = CheckedMul(2_u64, _157);\n        assert(!move (_158.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u64, move _157) -> [success: bb64, unwind unreachable];\n    }\n    bb64: {\n        _156 = move (_158.0: u64);\n        StorageDead(_157);\n        _159 = CheckedSub(_156, 1_u64);\n        assert(!move (_159.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _156, 1_u64) -> [success: bb65, unwind unreachable];\n    }\n    bb65: {\n        _155 = move (_159.0: u64);\n        StorageDead(_156);\n        _153 = num::<impl u64>::wrapping_add(move _154, move _155) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_155);\n        StorageDead(_154);\n        _144 = move _153;\n        StorageDead(_153);\n        _160 = CheckedSub(_139, 1_u64);\n        assert(!move (_160.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _139, 1_u64) -> [success: bb67, unwind unreachable];\n    }\n    bb67: {\n        _139 = move (_160.0: u64);\n        goto -> bb68;\n    }\n    bb68: {\n        StorageLive(_162);\n        StorageLive(_163);\n        _163 = _139;\n        _162 = Ne(move _163, 0_u64);\n        StorageDead(_163);\n        _161 = hint::assert_unchecked(move _162) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        StorageDead(_162);\n        StorageLive(_164);\n        _164 = _139;\n        StorageLive(_165);\n        _165 = _144;\n        _118 = (move _164, move _165);\n        StorageDead(_165);\n        StorageDead(_164);\n        StorageDead(_144);\n        StorageDead(_139);\n        _116 = (_118.0: u64);\n        _117 = (_118.1: u64);\n        StorageDead(_118);\n        switchInt(_116) -> [0: bb71, otherwise: bb70];\n    }\n    bb70: {\n        _168 = BitAnd(_1, num::int_sqrt::u128_stages::LOWER_HALF_1_BITS);\n        StorageLive(_170);\n        StorageLive(_171);\n        _171 = _117 as u128;\n        _172 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 128_u32);\n        assert(move _172, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb73, unwind unreachable];\n    }\n    bb71: {\n        StorageLive(_167);\n        _167 = fmt::Arguments::<'_>::from_str(\"`$s` is  zero in `last_stage!`.\") -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        _166 = panicking::panic_fmt(move _167) -> unwind unreachable;\n    }\n    bb73: {\n        _170 = Shl(move _171, num::int_sqrt::u128_stages::QUARTER_BITS);\n        StorageDead(_171);\n        StorageLive(_173);\n        _174 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 128_u32);\n        assert(move _174, \"attempt to shift right by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb74, unwind unreachable];\n    }\n    bb74: {\n        _173 = Shr(_168, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _169 = BitOr(move _170, move _173);\n        StorageDead(_173);\n        StorageDead(_170);\n        StorageLive(_176);\n        _176 = _116 as u128;\n        _177 = 1_i32 as u32;\n        _178 = Lt(move _177, 128_u32);\n        assert(move _178, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb75, unwind unreachable];\n    }\n    bb75: {\n        _175 = Shl(move _176, 1_i32);\n        StorageDead(_176);\n        _180 = Eq(_175, 0_u128);\n        assert(!move _180, \"attempt to divide `{}` by zero\", _169) -> [success: bb76, unwind unreachable];\n    }\n    bb76: {\n        _179 = Div(_169, _175);\n        StorageLive(_181);\n        StorageLive(_182);\n        StorageLive(_183);\n        _184 = Lt(num::int_sqrt::u128_stages::QUARTER_BITS, 64_u32);\n        assert(move _184, \"attempt to shift left by `{}`, which would overflow\", num::int_sqrt::u128_stages::QUARTER_BITS) -> [success: bb77, unwind unreachable];\n    }\n    bb77: {\n        _183 = Shl(_116, num::int_sqrt::u128_stages::QUARTER_BITS);\n        _182 = move _183 as u128;\n        StorageDead(_183);\n        _185 = CheckedAdd(_182, _179);\n        assert(!move (_185.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _182, _179) -> [success: bb78, unwind unreachable];\n    }\n    bb78: {\n        _181 = move (_185.0: u128);\n        StorageDead(_182);\n        StorageLive(_188);\n        StorageLive(_189);\n        _189 = _181;\n        StorageLive(_190);\n        _190 = _181;\n        _188 = num::<impl u128>::overflowing_mul(move _189, move _190) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_190);\n        StorageDead(_189);\n        _186 = (_188.0: u128);\n        _187 = (_188.1: bool);\n        StorageDead(_188);\n        switchInt(_187) -> [0: bb80, otherwise: bb82];\n    }\n    bb80: {\n        StorageLive(_191);\n        _191 = Gt(_186, _1);\n        switchInt(move _191) -> [0: bb84, otherwise: bb81];\n    }\n    bb81: {\n        goto -> bb82;\n    }\n    bb82: {\n        _192 = CheckedSub(_181, 1_u128);\n        assert(!move (_192.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _181, 1_u128) -> [success: bb83, unwind unreachable];\n    }\n    bb83: {\n        _181 = move (_192.0: u128);\n        goto -> bb85;\n    }\n    bb84: {\n        goto -> bb85;\n    }\n    bb85: {\n        StorageDead(_191);\n        _0 = _181;\n        StorageDead(_181);\n        return;\n    }\n}\n",
  "doc": " Takes the normalized [`u128`](prim@u128) input and gets its normalized\n [integer square root](https://en.wikipedia.org/wiki/Integer_square_root).\n\n # Safety\n\n `n` must be nonzero.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}