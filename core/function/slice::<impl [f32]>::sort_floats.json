{
  "name": "slice::<impl [f32]>::sort_floats",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::sort_unstable_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order with a comparison function, **without** preserving the\n initial order of equal elements.\n\n This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\n allocate), and *O*(*n* \\* log(*n*)) worst-case.\n\n If the comparison function `compare` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n All original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. Same is true if `compare` panics.\n\n # Current implementation\n\n The current implementation is based on [ipnsort] by Lukas Bergdoll and Orson Peters, which\n combines the fast average case of quicksort with the fast worst case of heapsort, achieving\n linear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\n expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n It is typically faster than stable sorting, except in a few special cases, e.g., when the\n slice is partially sorted.\n\n # Panics\n\n May panic if the `compare` does not implement a [total order], or if\n the `compare` itself panics.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n v.sort_unstable_by(|a, b| a.cmp(b));\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n\n // reverse sorting\n v.sort_unstable_by(|a, b| b.cmp(a));\n assert_eq!(v, [4, 2, 1, -3, -5]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    },
    "f32::<impl f32>::total_cmp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the ordering between `self` and `other`.\n\n Unlike the standard partial comparison between floating point numbers,\n this comparison always produces an ordering in accordance to\n the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)\n floating point standard. The values are ordered in the following sequence:\n\n - negative quiet NaN\n - negative signaling NaN\n - negative infinity\n - negative numbers\n - negative subnormal numbers\n - negative zero\n - positive zero\n - positive subnormal numbers\n - positive numbers\n - positive infinity\n - positive signaling NaN\n - positive quiet NaN.\n\n The ordering established by this function does not always agree with the\n [`PartialOrd`] and [`PartialEq`] implementations of `f32`. For example,\n they consider negative and positive zero equal, while `total_cmp`\n doesn't.\n\n The interpretation of the signaling NaN bit follows the definition in\n the IEEE 754 standard, which may not match the interpretation by some of\n the older, non-conformant (e.g. MIPS) hardware implementations.\n\n # Example\n\n ```\n struct GoodBoy {\n     name: String,\n     weight: f32,\n }\n\n let mut bois = vec![\n     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n     GoodBoy { name: \"Chonk\".to_owned(), weight: f32::INFINITY },\n     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f32::NAN },\n     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n ];\n\n bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n\n // `f32::NAN` could be positive or negative, which will affect the sort order.\n if f32::NAN.is_sign_negative() {\n     assert!(bois.into_iter().map(|b| b.weight)\n         .zip([f32::NAN, -5.0, 0.1, 10.0, 99.0, f32::INFINITY].iter())\n         .all(|(a, b)| a.to_bits() == b.to_bits()))\n } else {\n     assert!(bois.into_iter().map(|b| b.weight)\n         .zip([-5.0, 0.1, 10.0, 99.0, f32::INFINITY, f32::NAN].iter())\n         .all(|(a, b)| a.to_bits() == b.to_bits()))\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [f32]>::sort_floats"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:5072:5: 5074:6",
  "src": "pub fn sort_floats(&mut self) {\n        self.sort_unstable_by(f32::total_cmp);\n    }",
  "mir": "fn slice::<impl [f32]>::sort_floats(_1: &mut [f32]) -> () {\n    let mut _0: ();\n    let  _2: ();\n    debug self => _1;\n    bb0: {\n        _2 = slice::<impl [f32]>::sort_unstable_by::<for<'a, 'b> fn(&'a f32, &'b f32) -> cmp::Ordering {f32::<impl f32>::total_cmp}>(_1, f32::<impl f32>::total_cmp) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Sorts the slice of floats.\n\n This sort is in-place (i.e. does not allocate), *O*(*n* \\* log(*n*)) worst-case, and uses\n the ordering defined by [`f32::total_cmp`].\n\n # Current implementation\n\n This uses the same sorting algorithm as [`sort_unstable_by`](slice::sort_unstable_by).\n\n # Examples\n\n ```\n #![feature(sort_floats)]\n let mut v = [2.6, -5e-8, f32::NAN, 8.29, f32::INFINITY, -1.0, 0.0, -f32::INFINITY, -0.0];\n\n v.sort_floats();\n let sorted = [-f32::INFINITY, -1.0, -5e-8, -0.0, 0.0, 2.6, 8.29, f32::INFINITY, f32::NAN];\n assert_eq!(&v[..8], &sorted[..8]);\n assert!(v[8].is_nan());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}