{
  "name": "core_arch::x86::avx512bw::_mm512_movm_epi16",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512f::_mm512_set1_epi16": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Broadcast the low packed 16-bit integer from a to all elements of dst.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm512_set1_epi16&expand=4944)\n",
      "adt": {
        "core_arch::x86::__m512i": "Constructor"
      }
    },
    "core_arch::x86::__m512i::as_i16x32": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_arch::simd::i16x32": "Constructor"
      }
    },
    "intrinsics::simd::simd_select_bitmask": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Selects elements from a bitmask.\n\n `M` must be an unsigned integer or array of `u8`, matching `simd_bitmask`.\n\n `T` must be a vector.\n\n For each element, if the bit in `mask` is `1`, select the element from\n `if_true`.  If the corresponding bit in `mask` is `0`, select the element from\n `if_false`.\n The remaining bits of the mask are ignored.\n\n The bitmask bit order matches `simd_bitmask`.\n",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m512i": [
      "Plain"
    ],
    "core_arch::simd::i16x32": [
      "Plain"
    ]
  },
  "path": 6821,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512bw.rs:10125:1: 10148:2",
  "src": "pub fn _mm512_movm_epi16(k: __mmask32) -> __m512i {\n    unsafe {\n        let one = _mm512_set1_epi16(\n            1 << 15\n                | 1 << 14\n                | 1 << 13\n                | 1 << 12\n                | 1 << 11\n                | 1 << 10\n                | 1 << 9\n                | 1 << 8\n                | 1 << 7\n                | 1 << 6\n                | 1 << 5\n                | 1 << 4\n                | 1 << 3\n                | 1 << 2\n                | 1 << 1\n                | 1 << 0,\n        )\n        .as_i16x32();\n        transmute(simd_select_bitmask(k, one, i16x32::ZERO))\n    }\n}",
  "mir": "fn core_arch::x86::avx512bw::_mm512_movm_epi16(_1: u32) -> core_arch::x86::__m512i {\n    let mut _0: core_arch::x86::__m512i;\n    let  _2: core_arch::simd::i16x32;\n    let mut _3: core_arch::x86::__m512i;\n    let mut _4: i16;\n    let mut _5: i16;\n    let mut _6: i16;\n    let mut _7: i16;\n    let mut _8: i16;\n    let mut _9: i16;\n    let mut _10: i16;\n    let mut _11: i16;\n    let mut _12: i16;\n    let mut _13: i16;\n    let mut _14: i16;\n    let mut _15: i16;\n    let mut _16: i16;\n    let mut _17: i16;\n    let mut _18: i16;\n    let mut _19: i16;\n    let mut _20: u32;\n    let mut _21: bool;\n    let mut _22: i16;\n    let mut _23: u32;\n    let mut _24: bool;\n    let mut _25: i16;\n    let mut _26: u32;\n    let mut _27: bool;\n    let mut _28: i16;\n    let mut _29: u32;\n    let mut _30: bool;\n    let mut _31: i16;\n    let mut _32: u32;\n    let mut _33: bool;\n    let mut _34: i16;\n    let mut _35: u32;\n    let mut _36: bool;\n    let mut _37: i16;\n    let mut _38: u32;\n    let mut _39: bool;\n    let mut _40: i16;\n    let mut _41: u32;\n    let mut _42: bool;\n    let mut _43: i16;\n    let mut _44: u32;\n    let mut _45: bool;\n    let mut _46: i16;\n    let mut _47: u32;\n    let mut _48: bool;\n    let mut _49: i16;\n    let mut _50: u32;\n    let mut _51: bool;\n    let mut _52: i16;\n    let mut _53: u32;\n    let mut _54: bool;\n    let mut _55: i16;\n    let mut _56: u32;\n    let mut _57: bool;\n    let mut _58: i16;\n    let mut _59: u32;\n    let mut _60: bool;\n    let mut _61: i16;\n    let mut _62: u32;\n    let mut _63: bool;\n    let mut _64: i16;\n    let mut _65: u32;\n    let mut _66: bool;\n    let mut _67: core_arch::simd::i16x32;\n    debug k => _1;\n    debug one => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = 15_i32 as u32;\n        _21 = Lt(move _20, 16_u32);\n        assert(move _21, \"attempt to shift left by `{}`, which would overflow\", 15_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _19 = Shl(1_i16, 15_i32);\n        StorageLive(_22);\n        _23 = 14_i32 as u32;\n        _24 = Lt(move _23, 16_u32);\n        assert(move _24, \"attempt to shift left by `{}`, which would overflow\", 14_i32) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _22 = Shl(1_i16, 14_i32);\n        _18 = BitOr(move _19, move _22);\n        StorageDead(_22);\n        StorageDead(_19);\n        StorageLive(_25);\n        _26 = 13_i32 as u32;\n        _27 = Lt(move _26, 16_u32);\n        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", 13_i32) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _25 = Shl(1_i16, 13_i32);\n        _17 = BitOr(move _18, move _25);\n        StorageDead(_25);\n        StorageDead(_18);\n        StorageLive(_28);\n        _29 = 12_i32 as u32;\n        _30 = Lt(move _29, 16_u32);\n        assert(move _30, \"attempt to shift left by `{}`, which would overflow\", 12_i32) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _28 = Shl(1_i16, 12_i32);\n        _16 = BitOr(move _17, move _28);\n        StorageDead(_28);\n        StorageDead(_17);\n        StorageLive(_31);\n        _32 = 11_i32 as u32;\n        _33 = Lt(move _32, 16_u32);\n        assert(move _33, \"attempt to shift left by `{}`, which would overflow\", 11_i32) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _31 = Shl(1_i16, 11_i32);\n        _15 = BitOr(move _16, move _31);\n        StorageDead(_31);\n        StorageDead(_16);\n        StorageLive(_34);\n        _35 = 10_i32 as u32;\n        _36 = Lt(move _35, 16_u32);\n        assert(move _36, \"attempt to shift left by `{}`, which would overflow\", 10_i32) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _34 = Shl(1_i16, 10_i32);\n        _14 = BitOr(move _15, move _34);\n        StorageDead(_34);\n        StorageDead(_15);\n        StorageLive(_37);\n        _38 = 9_i32 as u32;\n        _39 = Lt(move _38, 16_u32);\n        assert(move _39, \"attempt to shift left by `{}`, which would overflow\", 9_i32) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _37 = Shl(1_i16, 9_i32);\n        _13 = BitOr(move _14, move _37);\n        StorageDead(_37);\n        StorageDead(_14);\n        StorageLive(_40);\n        _41 = 8_i32 as u32;\n        _42 = Lt(move _41, 16_u32);\n        assert(move _42, \"attempt to shift left by `{}`, which would overflow\", 8_i32) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _40 = Shl(1_i16, 8_i32);\n        _12 = BitOr(move _13, move _40);\n        StorageDead(_40);\n        StorageDead(_13);\n        StorageLive(_43);\n        _44 = 7_i32 as u32;\n        _45 = Lt(move _44, 16_u32);\n        assert(move _45, \"attempt to shift left by `{}`, which would overflow\", 7_i32) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _43 = Shl(1_i16, 7_i32);\n        _11 = BitOr(move _12, move _43);\n        StorageDead(_43);\n        StorageDead(_12);\n        StorageLive(_46);\n        _47 = 6_i32 as u32;\n        _48 = Lt(move _47, 16_u32);\n        assert(move _48, \"attempt to shift left by `{}`, which would overflow\", 6_i32) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _46 = Shl(1_i16, 6_i32);\n        _10 = BitOr(move _11, move _46);\n        StorageDead(_46);\n        StorageDead(_11);\n        StorageLive(_49);\n        _50 = 5_i32 as u32;\n        _51 = Lt(move _50, 16_u32);\n        assert(move _51, \"attempt to shift left by `{}`, which would overflow\", 5_i32) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _49 = Shl(1_i16, 5_i32);\n        _9 = BitOr(move _10, move _49);\n        StorageDead(_49);\n        StorageDead(_10);\n        StorageLive(_52);\n        _53 = 4_i32 as u32;\n        _54 = Lt(move _53, 16_u32);\n        assert(move _54, \"attempt to shift left by `{}`, which would overflow\", 4_i32) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _52 = Shl(1_i16, 4_i32);\n        _8 = BitOr(move _9, move _52);\n        StorageDead(_52);\n        StorageDead(_9);\n        StorageLive(_55);\n        _56 = 3_i32 as u32;\n        _57 = Lt(move _56, 16_u32);\n        assert(move _57, \"attempt to shift left by `{}`, which would overflow\", 3_i32) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _55 = Shl(1_i16, 3_i32);\n        _7 = BitOr(move _8, move _55);\n        StorageDead(_55);\n        StorageDead(_8);\n        StorageLive(_58);\n        _59 = 2_i32 as u32;\n        _60 = Lt(move _59, 16_u32);\n        assert(move _60, \"attempt to shift left by `{}`, which would overflow\", 2_i32) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _58 = Shl(1_i16, 2_i32);\n        _6 = BitOr(move _7, move _58);\n        StorageDead(_58);\n        StorageDead(_7);\n        StorageLive(_61);\n        _62 = 1_i32 as u32;\n        _63 = Lt(move _62, 16_u32);\n        assert(move _63, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _61 = Shl(1_i16, 1_i32);\n        _5 = BitOr(move _6, move _61);\n        StorageDead(_61);\n        StorageDead(_6);\n        StorageLive(_64);\n        _65 = 0_i32 as u32;\n        _66 = Lt(move _65, 16_u32);\n        assert(move _66, \"attempt to shift left by `{}`, which would overflow\", 0_i32) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _64 = Shl(1_i16, 0_i32);\n        _4 = BitOr(move _5, move _64);\n        StorageDead(_64);\n        StorageDead(_5);\n        _3 = core_arch::x86::avx512f::_mm512_set1_epi16(move _4) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_4);\n        _2 = core_arch::x86::__m512i::as_i16x32(move _3) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_3);\n        StorageLive(_67);\n        _67 = intrinsics::simd::simd_select_bitmask::<u32, core_arch::simd::i16x32>(_1, _2, core_arch::simd::i16x32::ZERO) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _0 = move _67 as core_arch::x86::__m512i;\n        StorageDead(_67);\n        return;\n    }\n}\n",
  "doc": " Set each packed 16-bit integer in dst to all ones or all zeros based on the value of the corresponding bit in k.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm512_movm_epi16&expand=3886)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}