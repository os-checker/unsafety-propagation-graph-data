{
  "name": "slice::memchr::memrchr",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "slice::<impl [T]>::align_to": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transmutes the slice to a slice of another type, ensuring alignment of the types is\n maintained.\n\n This method splits the slice into three distinct slices: prefix, correctly aligned middle\n slice of a new type, and the suffix slice. The middle part will be as big as possible under\n the given alignment constraint and element size.\n\n This method has no purpose when either input element `T` or output element `U` are\n zero-sized and will return the original slice without splitting anything.\n\n # Safety\n\n This method is essentially a `transmute` with respect to the elements in the returned\n middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n\n # Examples\n\n Basic usage:\n\n ```\n unsafe {\n     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n     // less_efficient_algorithm_for_bytes(prefix);\n     // more_efficient_algorithm_for_aligned_shorts(shorts);\n     // less_efficient_algorithm_for_bytes(suffix);\n }\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {
        "slice::iter::Iter": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::rposition": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element in an iterator from the right, returning its\n index.\n\n `rposition()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, starting from the end,\n and if one of them returns `true`, then `rposition()` returns\n [`Some(index)`]. If all of them return `false`, it returns [`None`].\n\n `rposition()` is short-circuiting; in other words, it will stop\n processing as soon as it finds a `true`.\n\n [`Some(index)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().rposition(|x| x == 3), Some(2));\n\n assert_eq!(a.into_iter().rposition(|x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [-1, 2, 3, 4];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.rposition(|x| x >= 2), Some(3));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(-1));\n assert_eq!(iter.next_back(), Some(3));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl usize>::repeat_u8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an `usize` where every byte is equal to `x`.\n",
      "adt": {}
    },
    "mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "slice::memchr::contains_zero_byte": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `x` contains any zero byte.\n\n From *Matters Computational*, J. Arndt:\n\n \"The idea is to subtract one from each of the bytes and then look for\n bytes where the borrow propagated all the way to the most significant\n bit.\"\n",
      "adt": {}
    }
  },
  "adts": {
    "ops::range::RangeFrom": [
      "Plain"
    ],
    "slice::iter::Iter": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ]
  },
  "path": 16634,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:111:1: 161:2",
  "src": "pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n    // Scan for a single byte value by reading two `usize` words at a time.\n    //\n    // Split `text` in three parts:\n    // - unaligned tail, after the last word aligned address in text,\n    // - body, scanned by 2 words at a time,\n    // - the first remaining bytes, < 2 word size.\n    let len = text.len();\n    let ptr = text.as_ptr();\n    type Chunk = usize;\n\n    let (min_aligned_offset, max_aligned_offset) = {\n        // We call this just to obtain the length of the prefix and suffix.\n        // In the middle we always process two chunks at once.\n        // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size differences\n        // which are handled by `align_to`.\n        let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };\n        (prefix.len(), len - suffix.len())\n    };\n\n    let mut offset = max_aligned_offset;\n    if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n        return Some(offset + index);\n    }\n\n    // Search the body of the text, make sure we don't cross min_aligned_offset.\n    // offset is always aligned, so just testing `>` is sufficient and avoids possible\n    // overflow.\n    let repeated_x = usize::repeat_u8(x);\n    let chunk_bytes = size_of::<Chunk>();\n\n    while offset > min_aligned_offset {\n        // SAFETY: offset starts at len - suffix.len(), as long as it is greater than\n        // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.\n        unsafe {\n            let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);\n            let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);\n\n            // Break if there is a matching byte.\n            let zu = contains_zero_byte(u ^ repeated_x);\n            let zv = contains_zero_byte(v ^ repeated_x);\n            if zu || zv {\n                break;\n            }\n        }\n        offset -= 2 * chunk_bytes;\n    }\n\n    // Find the byte before the point the body loop stopped.\n    text[..offset].iter().rposition(|elt| *elt == x)\n}",
  "mir": "fn slice::memchr::memrchr(_1: u8, _2: &[u8]) -> option::Option<usize> {\n    let mut _0: option::Option<usize>;\n    let  _3: usize;\n    let  _4: *const u8;\n    let  _5: usize;\n    let  _6: usize;\n    let mut _7: (usize, usize);\n    let  _8: &[u8];\n    let  _9: &[u8];\n    let mut _10: (&[u8], &[(usize, usize)], &[u8]);\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let mut _15: usize;\n    let mut _16: option::Option<usize>;\n    let mut _17: &mut slice::iter::Iter<'_, u8>;\n    let mut _18: slice::iter::Iter<'_, u8>;\n    let  _19: &[u8];\n    let mut _20: ops::range::RangeFrom<usize>;\n    let mut _21: usize;\n    let mut _22: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:132:58: 132:63};\n    let mut _23: &u8;\n    let mut _24: isize;\n    let  _25: usize;\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let  _29: usize;\n    let  _30: usize;\n    let mut _31: bool;\n    let mut _32: usize;\n    let  _33: usize;\n    let mut _34: *const usize;\n    let mut _35: *const u8;\n    let mut _36: usize;\n    let mut _37: usize;\n    let mut _38: usize;\n    let mut _39: (usize, bool);\n    let mut _40: (usize, bool);\n    let  _41: usize;\n    let mut _42: *const usize;\n    let mut _43: *const u8;\n    let mut _44: usize;\n    let mut _45: usize;\n    let mut _46: (usize, bool);\n    let  _47: bool;\n    let mut _48: usize;\n    let  _49: bool;\n    let mut _50: usize;\n    let mut _51: usize;\n    let mut _52: (usize, bool);\n    let mut _53: (usize, bool);\n    let mut _54: &mut slice::iter::Iter<'_, u8>;\n    let mut _55: slice::iter::Iter<'_, u8>;\n    let  _56: &[u8];\n    let mut _57: ops::range::RangeTo<usize>;\n    let mut _58: usize;\n    let mut _59: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:160:37: 160:42};\n    let mut _60: &u8;\n    debug x => _1;\n    debug text => _2;\n    debug len => _3;\n    debug ptr => _4;\n    debug min_aligned_offset => _5;\n    debug max_aligned_offset => _6;\n    debug prefix => _8;\n    debug suffix => _9;\n    debug offset => _15;\n    debug index => _25;\n    debug repeated_x => _29;\n    debug chunk_bytes => _30;\n    debug u => _33;\n    debug v => _41;\n    debug zu => _47;\n    debug zv => _49;\n    bb0: {\n        _3 = PtrMetadata(_2);\n        _4 = slice::<impl [u8]>::as_ptr(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_7);\n        StorageLive(_10);\n        _10 = slice::<impl [u8]>::align_to::<(usize, usize)>(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = (_10.0: &[u8]);\n        _9 = (_10.2: &[u8]);\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = PtrMetadata(_8);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = PtrMetadata(_9);\n        _14 = CheckedSub(_3, _13);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _13) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _12 = move (_14.0: usize);\n        StorageDead(_13);\n        _7 = (move _11, move _12);\n        StorageDead(_12);\n        StorageDead(_11);\n        _5 = (_7.0: usize);\n        StorageLive(_6);\n        _6 = (_7.1: usize);\n        StorageDead(_7);\n        StorageLive(_15);\n        _15 = _6;\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _15;\n        _20 = RangeFrom(move _21);\n        StorageDead(_21);\n        _19 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(_2, move _20) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_20);\n        _18 = slice::<impl [u8]>::iter(_19) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _17 = &mut _18;\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_1;\n        _22 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:132:58: 132:63}(move _23);\n        StorageDead(_23);\n        _16 = <slice::iter::Iter<'_, u8> as iter::traits::iterator::Iterator>::rposition::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:132:58: 132:63}>(move _17, move _22) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_22);\n        StorageDead(_17);\n        _24 = discriminant(_16);\n        switchInt(move _24) -> [1: bb7, 0: bb9, otherwise: bb31];\n    }\n    bb7: {\n        _25 = ((_16 as variant#1).0: usize);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _15;\n        _28 = CheckedAdd(_27, _25);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _27, _25) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _26 = move (_28.0: usize);\n        StorageDead(_27);\n        _0 = option::Option::Some(move _26);\n        StorageDead(_26);\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_6);\n        goto -> bb30;\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageDead(_16);\n        _29 = num::<impl usize>::repeat_u8(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _30 = mem::size_of::<usize>() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _15;\n        _31 = Gt(move _32, _5);\n        switchInt(move _31) -> [0: bb25, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_32);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = _15;\n        StorageLive(_38);\n        _39 = CheckedMul(2_usize, _30);\n        assert(!move (_39.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, _30) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _38 = move (_39.0: usize);\n        _40 = CheckedSub(_37, _38);\n        assert(!move (_40.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _37, move _38) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _36 = move (_40.0: usize);\n        StorageDead(_38);\n        StorageDead(_37);\n        _35 = ptr::const_ptr::<impl *const u8>::add(_4, move _36) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_36);\n        _34 = move _35 as *const usize;\n        StorageDead(_35);\n        _33 = (*_34);\n        StorageDead(_34);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = _15;\n        _46 = CheckedSub(_45, _30);\n        assert(!move (_46.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _45, _30) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _44 = move (_46.0: usize);\n        StorageDead(_45);\n        _43 = ptr::const_ptr::<impl *const u8>::add(_4, move _44) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_44);\n        _42 = move _43 as *const usize;\n        StorageDead(_43);\n        _41 = (*_42);\n        StorageDead(_42);\n        StorageLive(_48);\n        _48 = BitXor(_33, _29);\n        _47 = slice::memchr::contains_zero_byte(move _48) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_48);\n        StorageLive(_50);\n        _50 = BitXor(_41, _29);\n        _49 = slice::memchr::contains_zero_byte(move _50) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_50);\n        switchInt(_47) -> [0: bb20, otherwise: bb21];\n    }\n    bb20: {\n        switchInt(_49) -> [0: bb22, otherwise: bb21];\n    }\n    bb21: {\n        goto -> bb26;\n    }\n    bb22: {\n        StorageLive(_51);\n        _52 = CheckedMul(2_usize, _30);\n        assert(!move (_52.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, _30) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _51 = move (_52.0: usize);\n        _53 = CheckedSub(_15, _51);\n        assert(!move (_53.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _15, move _51) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _15 = move (_53.0: usize);\n        StorageDead(_51);\n        StorageDead(_31);\n        goto -> bb11;\n    }\n    bb25: {\n        StorageDead(_32);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_31);\n        StorageLive(_54);\n        StorageLive(_55);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = _15;\n        _57 = RangeTo(move _58);\n        StorageDead(_58);\n        _56 = <[u8] as ops::index::Index<ops::range::RangeTo<usize>>>::index(_2, move _57) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_57);\n        _55 = slice::<impl [u8]>::iter(_56) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _54 = &mut _55;\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &_1;\n        _59 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:160:37: 160:42}(move _60);\n        StorageDead(_60);\n        _0 = <slice::iter::Iter<'_, u8> as iter::traits::iterator::Iterator>::rposition::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/memchr.rs:160:37: 160:42}>(move _54, move _59) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_59);\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_15);\n        StorageDead(_6);\n        goto -> bb30;\n    }\n    bb30: {\n        return;\n    }\n    bb31: {\n        unreachable;\n    }\n}\n",
  "doc": " Returns the last index matching the byte `x` in `text`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}