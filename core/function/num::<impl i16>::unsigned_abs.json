{
  "name": "num::<impl i16>::unsigned_abs",
  "safe": true,
  "callees": {
    "num::<impl i16>::wrapping_abs": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unused_attributes"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unused_attributes\n"
        ]
      },
      "doc": " Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n the boundary of the type.\n\n The only case where such wrapping can occur is when one takes the absolute value of the negative\n minimal value for the type; this is a positive value that is too large to represent in the type. In\n such a case, this function returns `MIN` itself.\n\n # Examples\n\n ```\n assert_eq!((-128i8).wrapping_abs() as u8, 128);\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::num::<impl i16>::unsigned_abs"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs:2387:9: 2389:10",
  "src": "pub const fn unsigned_abs(self) -> $UnsignedT {\n             self.wrapping_abs() as $UnsignedT\n        }",
  "mir": "fn num::<impl i16>::unsigned_abs(_1: i16) -> u16 {\n    let mut _0: u16;\n    let mut _2: i16;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = num::<impl i16>::wrapping_abs(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = move _2 as u16;\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Computes the absolute value of `self` without any wrapping\n or panicking.\n\n\n # Examples\n\n ```\n assert_eq!((-128i8).unsigned_abs(), 128u8);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}