{
  "name": "ptr::const_ptr::<impl *const T>::is_null::compiletime",
  "safe": true,
  "callees": {
    "ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::guaranteed_eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether two pointers are guaranteed to be equal.\n\n At runtime this function behaves like `Some(self == other)`.\n However, in some contexts (e.g., compile-time evaluation),\n it is not always possible to determine equality of two pointers, so this function may\n spuriously return `None` for pointers that later actually turn out to have its equality known.\n But when it returns `Some`, the pointers' equality is guaranteed to be known.\n\n The return value may change from `Some` to `None` and vice versa depending on the compiler\n version and unsafe code must not\n rely on the result of this function for soundness. It is suggested to only use this function\n for performance optimizations where spurious `None` return values by this function do not\n affect the outcome, but just the performance.\n The consequences of using this method to make runtime and compile-time code behave\n differently have not been explored. This method should not be used to introduce such\n differences, and it should also not be stabilized before we have a better understanding\n of this issue.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3, kind: RigidTy(Bool) })])"
    ],
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::ptr::const_ptr::<impl *const T>::is_null::compiletime"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2442:9: 2447:10",
  "src": "const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }",
  "mir": "fn ptr::const_ptr::<impl *const T>::is_null::compiletime(_1: *const u8) -> bool {\n    let mut _0: bool;\n    let mut _2: option::Option<bool>;\n    let mut _3: *const u8;\n    let mut _4: *mut u8;\n    let mut _5: isize;\n    let  _6: !;\n    let mut _7: fmt::Arguments<'_>;\n    debug ptr => _1;\n    debug res => _0;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ptr::null_mut::<u8>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = move _4 as *const u8;\n        StorageDead(_4);\n        _2 = ptr::const_ptr::<impl *const u8>::guaranteed_eq(_1, move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _5 = discriminant(_2);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = fmt::Arguments::<'_>::from_str(\"null-ness of this pointer cannot be determined in const context\") -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        _0 = ((_2 as variant#1).0: bool);\n        StorageDead(_2);\n        return;\n    }\n    bb6: {\n        _6 = panicking::panic_fmt(move _7) -> unwind unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}