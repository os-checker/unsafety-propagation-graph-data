{
  "name": "<clone::uninit::InitializingSlice<'a, T> as ops::drop::Drop>::drop",
  "safe": true,
  "callees": {
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "<[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Drops the contained values in place.\n\n # Safety\n\n It is up to the caller to guarantee that every `MaybeUninit<T>` in the slice\n really is in an initialized state. Calling this when the content is not yet\n fully initialized causes undefined behavior.\n\n On top of that, all additional invariants of the type `T` must be\n satisfied, as the `Drop` implementation of `T` (or its members) may\n rely on this. For example, setting a `Vec<T>` to an invalid but\n non-null address makes it initialized (under the current implementation;\n this does not constitute a stable guarantee), because the only\n requirement the compiler knows about it is that the data pointer must be\n non-null. Dropping such a `Vec<T>` however will cause undefined\n behaviour.\n",
      "adt": {}
    }
  },
  "adts": {
    "clone::uninit::InitializingSlice": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "ops::range::RangeTo": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<clone::uninit::InitializingSlice<'a, T> as ops::drop::Drop>::drop"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone/uninit.rs:116:5: 122:6",
  "src": "fn drop(&mut self) {\n        // SAFETY:\n        // * the pointer is valid because it was made from a mutable reference\n        // * `initialized_len` counts the initialized elements as an invariant of this type,\n        //   so each of the pointed-to elements is initialized and may be dropped.\n        unsafe { self.data[..self.initialized_len].assume_init_drop() };\n    }",
  "mir": "fn <clone::uninit::InitializingSlice<'a, T> as ops::drop::Drop>::drop(_1: &mut clone::uninit::InitializingSlice<'_, T>) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    let mut _4: ops::range::RangeTo<usize>;\n    let mut _5: usize;\n    let mut _6: &mut [mem::maybe_uninit::MaybeUninit<T>];\n    debug self => _1;\n    bb0: {\n        _6 = ((*_1).0: &mut [mem::maybe_uninit::MaybeUninit<T>]);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).1: usize);\n        _4 = RangeTo(move _5);\n        StorageDead(_5);\n        _3 = <[mem::maybe_uninit::MaybeUninit<T>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_6, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = <[mem::maybe_uninit::MaybeUninit<T>]>::assume_init_drop(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}