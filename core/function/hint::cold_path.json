{
  "name": "hint::cold_path",
  "safe": true,
  "callees": {
    "intrinsics::cold_path": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Hints to the compiler that current code path is cold.\n\n Note that, unlike most intrinsics, this is safe to call;\n it does not require an `unsafe` block.\n Therefore, implementations must not require the user to uphold\n any safety invariants.\n\n This intrinsic does not have a stable counterpart.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::hint::cold_path"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hint.rs:728:1: 730:2",
  "src": "pub const fn cold_path() {\n    crate::intrinsics::cold_path()\n}",
  "mir": "fn hint::cold_path() -> () {\n    let mut _0: ();\n    bb0: {\n        _0 = intrinsics::cold_path() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Hints to the compiler that given path is cold, i.e., unlikely to be taken. The compiler may\n choose to optimize paths that are not cold at the expense of paths that are cold.\n\n # Examples\n\n ```\n #![feature(cold_path)]\n use core::hint::cold_path;\n\n fn foo(x: &[i32]) {\n     if let Some(first) = x.get(0) {\n         // this is the fast path\n     } else {\n         // this path is unlikely\n         cold_path();\n     }\n }\n\n fn bar(x: i32) -> i32 {\n     match x {\n         1 => 10,\n         2 => 100,\n         3 => { cold_path(); 1000 }, // this branch is unlikely\n         _ => { cold_path(); 10000 }, // this is also unlikely\n     }\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}