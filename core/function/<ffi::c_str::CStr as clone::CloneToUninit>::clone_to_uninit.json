{
  "name": "<ffi::c_str::CStr as clone::CloneToUninit>::clone_to_uninit",
  "safe": false,
  "callees": {
    "ffi::c_str::CStr::to_bytes_with_nul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice containing the trailing 0 byte.\n\n This function is the equivalent of [`CStr::to_bytes`] except that it\n will retain the trailing nul terminator instead of chopping it off.\n\n > **Note**: This method is currently implemented as a 0-cost cast, but\n > it is planned to alter its definition in the future to perform the\n > length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes_with_nul(), b\"foo\\0\");\n ```\n",
      "adt": {
        "ffi::c_str::CStr": "ImmutableAsArgument"
      }
    },
    "clone::CloneToUninit::clone_to_uninit": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs copy-assignment from `self` to `dest`.\n\n This is analogous to `std::ptr::write(dest.cast(), self.clone())`,\n except that `Self` may be a dynamically-sized type ([`!Sized`](Sized)).\n\n Before this function is called, `dest` may point to uninitialized memory.\n After this function is called, `dest` will point to initialized memory; it will be\n sound to create a `&Self` reference from the pointer with the [pointer metadata]\n from `self`.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dest` must be [valid] for writes for `size_of_val(self)` bytes.\n * `dest` must be properly aligned to `align_of_val(self)`.\n\n [valid]: crate::ptr#safety\n [pointer metadata]: crate::ptr::metadata()\n\n # Panics\n\n This function may panic. (For example, it might panic if memory allocation for a clone\n of a value owned by `self` fails.)\n If the call panics, then `*dest` should be treated as uninitialized memory; it must not be\n read or dropped, because even if it was previously valid, it may have been partially\n overwritten.\n\n The caller may wish to take care to deallocate the allocation pointed to by `dest`,\n if applicable, to avoid a memory leak (but this is not a requirement).\n\n Implementors should avoid leaking values by, upon unwinding, dropping all component values\n that might have already been created. (For example, if a `[Foo]` of length 3 is being\n cloned, and the second of the three calls to `Foo::clone()` unwinds, then the first `Foo`\n cloned should be dropped.)\n",
      "adt": {}
    }
  },
  "adts": {
    "ffi::c_str::CStr": [
      "Ref"
    ]
  },
  "path": 12831,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/clone.rs:579:5: 585:6",
  "src": "unsafe fn clone_to_uninit(&self, dest: *mut u8) {\n        // SAFETY: For now, CStr is just a #[repr(trasnsparent)] [c_char] with some invariants.\n        // And we can cast [c_char] to [u8] on all supported platforms (see: to_bytes_with_nul).\n        // The pointer metadata properly preserves the length (so NUL is also copied).\n        // See: `cstr_metadata_is_length_with_nul` in tests.\n        unsafe { self.to_bytes_with_nul().clone_to_uninit(dest) }\n    }",
  "mir": "fn <ffi::c_str::CStr as clone::CloneToUninit>::clone_to_uninit(_1: &ffi::c_str::CStr, _2: *mut u8) -> () {\n    let mut _0: ();\n    let  _3: &[u8];\n    debug self => _1;\n    debug dest => _2;\n    bb0: {\n        _3 = ffi::c_str::CStr::to_bytes_with_nul(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = <[u8] as clone::CloneToUninit>::clone_to_uninit(_3, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}