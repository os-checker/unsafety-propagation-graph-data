{
  "name": "core_arch::x86::sse41::_mm_mpsadbw_epu8",
  "safe": false,
  "callees": {
    "core_arch::x86::__m128i::as_u8x16": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core_arch::simd::u8x16": "Constructor"
      }
    },
    "core_arch::x86::sse41::mpsadbw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core_arch::x86::__m128i": [
      "Plain"
    ],
    "core_arch::simd::u8x16": [
      "Plain"
    ],
    "core_arch::simd::u16x8": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::sse41::_mm_mpsadbw_epu8"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/sse41.rs:984:1: 987:2",
  "src": "pub fn _mm_mpsadbw_epu8<const IMM8: i32>(a: __m128i, b: __m128i) -> __m128i {\n    static_assert_uimm_bits!(IMM8, 3);\n    unsafe { transmute(mpsadbw(a.as_u8x16(), b.as_u8x16(), IMM8 as u8)) }\n}",
  "mir": "fn core_arch::x86::sse41::_mm_mpsadbw_epu8(_1: core_arch::x86::__m128i, _2: core_arch::x86::__m128i) -> core_arch::x86::__m128i {\n    let mut _0: core_arch::x86::__m128i;\n    let mut _3: core_arch::simd::u16x8;\n    let mut _4: core_arch::simd::u8x16;\n    let mut _5: core_arch::simd::u8x16;\n    let mut _6: u8;\n    debug a => _1;\n    debug b => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = core_arch::x86::__m128i::as_u8x16(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = core_arch::x86::__m128i::as_u8x16(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = IMM8 as u8;\n        _3 = core_arch::x86::sse41::mpsadbw(move _4, move _5, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = move _3 as core_arch::x86::__m128i;\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Subtracts 8-bit unsigned integer values and computes the absolute\n values of the differences to the corresponding bits in the destination.\n Then sums of the absolute differences are returned according to the bit\n fields in the immediate operand.\n\n The following algorithm is performed:\n\n ```ignore\n i = IMM8[2] * 4\n j = IMM8[1:0] * 4\n for k := 0 to 7\n     d0 = abs(a[i + k + 0] - b[j + 0])\n     d1 = abs(a[i + k + 1] - b[j + 1])\n     d2 = abs(a[i + k + 2] - b[j + 2])\n     d3 = abs(a[i + k + 3] - b[j + 3])\n     r[k] = d0 + d1 + d2 + d3\n ```\n\n Arguments:\n\n * `a` - A 128-bit vector of type `__m128i`.\n * `b` - A 128-bit vector of type `__m128i`.\n * `IMM8` - An 8-bit immediate operand specifying how the absolute\n   differences are to be calculated\n     * Bit `[2]` specify the offset for operand `a`\n     * Bits `[1:0]` specify the offset for operand `b`\n\n Returns:\n\n * A `__m128i` vector containing the sums of the sets of   absolute\n   differences between both operands.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm_mpsadbw_epu8)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}