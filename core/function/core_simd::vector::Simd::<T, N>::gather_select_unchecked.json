{
  "name": "core_simd::vector::Simd::<T, N>::gather_select_unchecked",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::splat": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new SIMD vector with all elements set to the given value.\n\n # Examples\n\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::u32x4;\n let v = u32x4::splat(8);\n assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n ```\n",
      "adt": {
        "core_simd::vector::Simd": "Constructor"
      }
    },
    "core_simd::simd::ptr::const_ptr::SimdConstPtr::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the offset from a pointer using wrapping arithmetic.\n\n Equivalent to calling [`pointer::wrapping_add`] on each element.\n",
      "adt": {}
    },
    "core_simd::vector::Simd::<T, N>::gather_select_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Conditionally read elementwise from pointers into a SIMD vector.\n The mask `enable`s all `true` pointers and disables all `false` pointers.\n If a pointer is disabled, the element is selected from the `or` vector,\n and no read is performed.\n\n # Safety\n\n Enabled elements must satisfy the same conditions as [`core::ptr::read`].\n\n # Example\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::prelude::*;\n let values = [6, 2, 4, 9];\n let enable = Mask::from_array([true, true, false, true]);\n let offsets = Simd::from_array([1, 0, 0, 3]);\n let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n let gathered = unsafe { Simd::gather_select_ptr(source, enable, Simd::splat(0)) };\n assert_eq!(gathered, Simd::from_array([2, 6, 0, 9]));\n ```\n",
      "adt": {
        "core_simd::vector::Simd": "Constructor"
      }
    }
  },
  "adts": {
    "core_simd::vector::Simd": [
      "Plain"
    ],
    "core_simd::masks::Mask": [
      "Plain"
    ]
  },
  "path": 12673,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../portable-simd/crates/core_simd/src/vector.rs:588:5: 599:6",
  "src": "pub unsafe fn gather_select_unchecked(\n        slice: &[T],\n        enable: Mask<isize, N>,\n        idxs: Simd<usize, N>,\n        or: Self,\n    ) -> Self {\n        let base_ptr = Simd::<*const T, N>::splat(slice.as_ptr());\n        // Ferris forgive me, I have done pointer arithmetic here.\n        let ptrs = base_ptr.wrapping_add(idxs);\n        // Safety: The caller is responsible for determining the indices are okay to read\n        unsafe { Self::gather_select_ptr(ptrs, enable, or) }\n    }",
  "mir": "fn core_simd::vector::Simd::<T, N>::gather_select_unchecked(_1: &[T], _2: core_simd::masks::Mask<isize, N>, _3: core_simd::vector::Simd<usize, N>, _4: core_simd::vector::Simd<T, N>) -> core_simd::vector::Simd<T, N> {\n    let mut _0: core_simd::vector::Simd<T, N>;\n    let  _5: core_simd::vector::Simd<*const T, N>;\n    let mut _6: *const T;\n    let  _7: core_simd::vector::Simd<*const T, N>;\n    debug slice => _1;\n    debug enable => _2;\n    debug idxs => _3;\n    debug or => _4;\n    debug base_ptr => _5;\n    debug ptrs => _7;\n    bb0: {\n        StorageLive(_6);\n        _6 = slice::<impl [T]>::as_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core_simd::vector::Simd::<*const T, N>::splat(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _7 = <core_simd::vector::Simd<*const T, N> as core_simd::simd::ptr::const_ptr::SimdConstPtr>::wrapping_add(_5, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core_simd::vector::Simd::<T, N>::gather_select_ptr(_7, _2, _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": " Reads from indices in `slice` to construct a SIMD vector.\n The mask `enable`s all `true` indices and disables all `false` indices.\n If an index is disabled, the element is selected from the `or` vector.\n\n # Safety\n\n Calling this function with an `enable`d out-of-bounds index is *[undefined behavior]*\n even if the resulting value is not used.\n\n # Examples\n ```\n # #![feature(portable_simd)]\n # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n # use simd::{Simd, cmp::SimdPartialOrd, Mask};\n let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n let alt = Simd::from_array([-5, -4, -3, -2]);\n let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n // If this mask was used to gather, it would be unsound. Let's fix that.\n let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n\n // The out-of-bounds index has been masked, so it's safe to gather now.\n let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n ```\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}