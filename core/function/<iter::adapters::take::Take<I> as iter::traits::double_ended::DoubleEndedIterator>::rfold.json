{
  "name": "<iter::adapters::take::Take<I> as iter::traits::double_ended::DoubleEndedIterator>::rfold",
  "safe": true,
  "callees": {
    "iter::traits::exact_size::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "iter::traits::double_ended::DoubleEndedIterator::nth_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `n`th element from the end of the iterator.\n\n This is essentially the reversed version of [`Iterator::nth()`].\n Although like most indexing operations, the count starts from zero, so\n `nth_back(0)` returns the first value from the end, `nth_back(1)` the\n second, and so on.\n\n Note that all elements between the end and the returned element will be\n consumed, including the returned element. This also means that calling\n `nth_back(0)` multiple times on the same iterator will return different\n elements.\n\n `nth_back()` will return [`None`] if `n` is greater than or equal to the\n length of the iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().nth_back(2), Some(&1));\n ```\n\n Calling `nth_back()` multiple times doesn't rewind the iterator:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter();\n\n assert_eq!(iter.nth_back(1), Some(&2));\n assert_eq!(iter.nth_back(1), None);\n ```\n\n Returning `None` if there are less than `n + 1` elements:\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().nth_back(10), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {
        "option::Option": "ImmutableAsArgument"
      }
    },
    "iter::traits::double_ended::DoubleEndedIterator::rfold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An iterator method that reduces the iterator's elements to a single,\n final value, starting from the back.\n\n This is the reverse version of [`Iterator::fold()`]: it takes elements\n starting from the back of the iterator.\n\n `rfold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `rfold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `rfold()` combines elements in a *right-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *left-associative* version of `rfold()`, see [`Iterator::fold()`].\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of a\n let sum = a.iter()\n            .rfold(0, |acc, &x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n This example demonstrates the right-associative nature of `rfold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the back until the front:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().rfold(zero, |acc, &x| {\n     format!(\"({x} + {acc})\")\n });\n\n assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "iter::adapters::take::Take": [
      "Unknown([Field(1, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(0, Ty { id: 4656, kind: Param(ParamTy { index: 0, name: \"I\" }) })])",
      "Plain"
    ],
    "option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": 14097,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/take.rs:201:5: 216:6",
  "src": "fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n    where\n        Self: Sized,\n        Fold: FnMut(Acc, Self::Item) -> Acc,\n    {\n        if self.n == 0 {\n            init\n        } else {\n            let len = self.iter.len();\n            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n                init\n            } else {\n                self.iter.rfold(init, fold)\n            }\n        }\n    }",
  "mir": "fn <iter::adapters::take::Take<I> as iter::traits::double_ended::DoubleEndedIterator>::rfold(_1: iter::adapters::take::Take<I>, _2: Acc, _3: Fold) -> Acc {\n    let mut _0: Acc;\n    let mut _4: usize;\n    let  _5: usize;\n    let mut _6: &I;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: bool;\n    let mut _10: &option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let  _11: option::Option<<I as iter::traits::iterator::Iterator>::Item>;\n    let mut _12: &mut I;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let mut _17: (usize, bool);\n    let mut _18: I;\n    let mut _19: Fold;\n    let mut _20: bool;\n    let mut _21: bool;\n    debug self => _1;\n    debug init => _2;\n    debug fold => _3;\n    debug len => _5;\n    bb0: {\n        _20 = false;\n        _21 = false;\n        _21 = true;\n        _20 = true;\n        StorageLive(_4);\n        _4 = (_1.1: usize);\n        switchInt(move _4) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = _2;\n        goto -> bb17;\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = &(_1.0: I);\n        _5 = <I as iter::traits::exact_size::ExactSizeIterator>::len(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = (_1.1: usize);\n        _7 = Gt(_5, move _8);\n        switchInt(move _7) -> [0: bb13, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut (_1.0: I);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (_1.1: usize);\n        _16 = CheckedSub(_5, _15);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, move _15) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _14 = move (_16.0: usize);\n        StorageDead(_15);\n        _17 = CheckedSub(_14, 1_usize);\n        assert(!move (_17.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _14, 1_usize) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = move (_17.0: usize);\n        StorageDead(_14);\n        _11 = <I as iter::traits::double_ended::DoubleEndedIterator>::nth_back(move _12, move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = &_11;\n        StorageDead(_13);\n        StorageDead(_12);\n        _9 = option::Option::<<I as iter::traits::iterator::Iterator>::Item>::is_none(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _9) -> [0: bb11, otherwise: bb9];\n    }\n    bb9: {\n        drop(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _0 = _2;\n        goto -> bb16;\n    }\n    bb11: {\n        drop(_11) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_8);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_18);\n        _21 = false;\n        _18 = move (_1.0: I);\n        StorageLive(_19);\n        _20 = false;\n        _19 = move _3;\n        _0 = <I as iter::traits::double_ended::DoubleEndedIterator>::rfold::<Acc, Fold>(move _18, _2, move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_9);\n        StorageDead(_7);\n        goto -> bb17;\n    }\n    bb17: {\n        switchInt(_20) -> [0: bb18, otherwise: bb19];\n    }\n    bb18: {\n        switchInt(_21) -> [0: bb20, otherwise: bb21];\n    }\n    bb19: {\n        drop(_3) -> [return: bb18, unwind unreachable];\n    }\n    bb20: {\n        return;\n    }\n    bb21: {\n        drop((_1.0: I)) -> [return: bb20, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}