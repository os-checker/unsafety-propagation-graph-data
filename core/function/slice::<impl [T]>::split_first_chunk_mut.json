{
  "name": "slice::<impl [T]>::split_first_chunk_mut",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::split_at_mut_checked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one mutable slice into two at an index, returning `None` if the\n slice is too short.\n\n If `mid â‰¤ len` returns a pair of slices where the first will contain all\n indices from `[0, mid)` (excluding the index `mid` itself) and the\n second will contain all indices from `[mid, len)` (excluding the index\n `len` itself).\n\n Otherwise, if `mid > len`, returns `None`.\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n\n if let Some((left, right)) = v.split_at_mut_checked(2) {\n     assert_eq!(left, [1, 0]);\n     assert_eq!(right, [3, 0, 5, 6]);\n     left[1] = 2;\n     right[1] = 4;\n }\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n\n assert_eq!(None, v.split_at_mut_checked(7));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast_array": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts from a pointer-to-`T` to a pointer-to-`[T; N]`.\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12238, kind: RigidTy(Tuple([Ty { id: 1485, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1489, kind: RigidTy(Slice(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })) }, Mut)) }, Ty { id: 1485, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1489, kind: RigidTy(Slice(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })) }, Mut)) }])) }), Field(0, Ty { id: 1485, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1489, kind: RigidTy(Slice(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12238, kind: RigidTy(Tuple([Ty { id: 1485, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1489, kind: RigidTy(Slice(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })) }, Mut)) }, Ty { id: 1485, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1489, kind: RigidTy(Slice(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })) }, Mut)) }])) }), Field(1, Ty { id: 1485, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1489, kind: RigidTy(Slice(Ty { id: 95, kind: Param(ParamTy { index: 0, name: \"T\" }) })) }, Mut)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::split_first_chunk_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:416:5: 425:6",
  "src": "pub const fn split_first_chunk_mut<const N: usize>(\n        &mut self,\n    ) -> Option<(&mut [T; N], &mut [T])> {\n        let Some((first, tail)) = self.split_at_mut_checked(N) else { return None };\n\n        // SAFETY: We explicitly check for the correct number of elements,\n        //   do not let the reference outlive the slice,\n        //   and enforce exclusive mutability of the chunk by the split.\n        Some((unsafe { &mut *(first.as_mut_ptr().cast_array()) }, tail))\n    }",
  "mir": "fn slice::<impl [T]>::split_first_chunk_mut(_1: &mut [T]) -> option::Option<(&mut [T; N], &mut [T])> {\n    let mut _0: option::Option<(&mut [T; N], &mut [T])>;\n    let  _2: &mut [T];\n    let  _3: &mut [T];\n    let mut _4: option::Option<(&mut [T], &mut [T])>;\n    let mut _5: isize;\n    let mut _6: (&mut [T; N], &mut [T]);\n    let mut _7: &mut [T; N];\n    let mut _8: *mut [T; N];\n    let mut _9: *mut T;\n    debug self => _1;\n    debug first => _2;\n    debug tail => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = slice::<impl [T]>::split_at_mut_checked(_1, N) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = discriminant(_4);\n        switchInt(move _5) -> [1: bb2, 0: bb3, otherwise: bb7];\n    }\n    bb2: {\n        _2 = move (((_4 as variant#1).0: (&mut [T], &mut [T])).0: &mut [T]);\n        _3 = move (((_4 as variant#1).0: (&mut [T], &mut [T])).1: &mut [T]);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = slice::<impl [T]>::as_mut_ptr(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _0 = option::Option::None;\n        goto -> bb6;\n    }\n    bb4: {\n        _8 = ptr::mut_ptr::<impl *mut T>::cast_array::<N>(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _7 = &mut (*_8);\n        StorageDead(_8);\n        _6 = (_7, _3);\n        _0 = option::Option::Some(move _6);\n        StorageDead(_6);\n        goto -> bb6;\n    }\n    bb6: {\n        return;\n    }\n    bb7: {\n        unreachable;\n    }\n}\n",
  "doc": " Returns a mutable array reference to the first `N` items in the slice and the remaining\n slice.\n\n If the slice is not at least `N` in length, this will return `None`.\n\n # Examples\n\n ```\n let x = &mut [0, 1, 2];\n\n if let Some((first, elements)) = x.split_first_chunk_mut::<2>() {\n     first[0] = 3;\n     first[1] = 4;\n     elements[0] = 5;\n }\n assert_eq!(x, &[3, 4, 5]);\n\n assert_eq!(None, x.split_first_chunk_mut::<4>());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}