{
  "name": "ptr::const_ptr::<impl *const T>::offset_from",
  "safe": false,
  "callees": {
    "mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "intrinsics::ptr_offset_from": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " See documentation of `<*const T>::offset_from` for details.\n",
      "adt": {}
    },
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::ptr::const_ptr::<impl *const T>::offset_from"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:612:5: 620:6",
  "src": "pub const unsafe fn offset_from(self, origin: *const T) -> isize\n    where\n        T: Sized,\n    {\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from`.\n        unsafe { intrinsics::ptr_offset_from(self, origin) }\n    }",
  "mir": "fn ptr::const_ptr::<impl *const T>::offset_from(_1: *const T, _2: *const T) -> isize {\n    let mut _0: isize;\n    let  _3: usize;\n    let mut _4: bool;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: !;\n    debug self => _1;\n    debug origin => _2;\n    debug pointee_size => _3;\n    bb0: {\n        _3 = mem::size_of::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = Lt(0_usize, _3);\n        switchInt(move _4) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = num::<impl isize>::MAX as usize;\n        _5 = Le(_3, move _6);\n        switchInt(move _5) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = intrinsics::ptr_offset_from::<T>(_1, _2) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        goto -> bb6;\n    }\n    bb5: {\n        goto -> bb6;\n    }\n    bb6: {\n        _7 = panicking::panic(\"assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize\") -> unwind unreachable;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": " Calculates the distance between two pointers within the same allocation. The returned value is in\n units of T: the distance in bytes divided by `size_of::<T>()`.\n\n This is equivalent to `(self as isize - origin as isize) / (size_of::<T>() as isize)`,\n except that it has a lot more opportunities for UB, in exchange for the compiler\n better understanding what you are doing.\n\n The primary motivation of this method is for computing the `len` of an array/slice\n of `T` that you are currently representing as a \"start\" and \"end\" pointer\n (and \"end\" is \"one past the end\" of the array).\n In that case, `end.offset_from(start)` gets you the length of the array.\n\n All of the following safety requirements are trivially satisfied for this usecase.\n\n [`offset`]: #method.offset\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * `self` and `origin` must either\n\n   * point to the same address, or\n   * both be [derived from][crate::ptr#provenance] a pointer to the same [allocation], and the memory range between\n     the two pointers must be in bounds of that object. (See below for an example.)\n\n * The distance between the pointers, in bytes, must be an exact multiple\n   of the size of `T`.\n\n As a consequence, the absolute distance between the pointers, in bytes, computed on\n mathematical integers (without \"wrapping around\"), cannot overflow an `isize`. This is\n implied by the in-bounds requirement, and the fact that no allocation can be larger\n than `isize::MAX` bytes.\n\n The requirement for pointers to be derived from the same allocation is primarily\n needed for `const`-compatibility: the distance between pointers into *different* allocated\n objects is not known at compile-time. However, the requirement also exists at\n runtime and may be exploited by optimizations. If you wish to compute the difference between\n pointers that are not guaranteed to be from the same allocation, use `(self as isize -\n origin as isize) / size_of::<T>()`.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Panics\n\n This function panics if `T` is a Zero-Sized Type (\"ZST\").\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0; 5];\n let ptr1: *const i32 = &a[1];\n let ptr2: *const i32 = &a[3];\n unsafe {\n     assert_eq!(ptr2.offset_from(ptr1), 2);\n     assert_eq!(ptr1.offset_from(ptr2), -2);\n     assert_eq!(ptr1.offset(2), ptr2);\n     assert_eq!(ptr2.offset(-2), ptr1);\n }\n ```\n\n *Incorrect* usage:\n\n ```rust,no_run\n let ptr1 = Box::into_raw(Box::new(0u8)) as *const u8;\n let ptr2 = Box::into_raw(Box::new(1u8)) as *const u8;\n let diff = (ptr2 as isize).wrapping_sub(ptr1 as isize);\n // Make ptr2_other an \"alias\" of ptr2.add(1), but derived from ptr1.\n let ptr2_other = (ptr1 as *const u8).wrapping_offset(diff).wrapping_offset(1);\n assert_eq!(ptr2 as usize, ptr2_other as usize);\n // Since ptr2_other and ptr2 are derived from pointers to different objects,\n // computing their offset is undefined behavior, even though\n // they point to addresses that are in-bounds of the same object!\n unsafe {\n     let one = ptr2_other.offset_from(ptr2); // Undefined Behavior! ⚠️\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}