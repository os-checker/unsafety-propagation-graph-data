{
  "name": "slice::sort::stable::drift::create_run",
  "safe": true,
  "callees": {
    "slice::sort::shared::find_existing_run": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds a run of sorted elements starting at the beginning of the slice.\n\n Returns the length of the run, and a bool that is false when the run\n is ascending, and true if the run strictly descending.\n",
      "adt": {}
    },
    "ops::index::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "slice::<impl [T]>::reverse": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses the order of elements in the slice, in place.\n\n # Examples\n\n ```\n let mut v = [1, 2, 3];\n v.reverse();\n assert!(v == [3, 2, 1]);\n ```\n",
      "adt": {}
    },
    "slice::sort::stable::drift::DriftsortRun::new_sorted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "slice::sort::stable::drift::DriftsortRun": "Constructor"
      }
    },
    "slice::sort::shared::smallsort::StableSmallSortTypeImpl::small_sort_threshold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " For which input length <= return value of this function, is it valid to call `small_sort`.\n",
      "adt": {}
    },
    "cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "slice::sort::stable::quicksort::quicksort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts `v` recursively using quicksort.\n `scratch.len()` must be at least `max(v.len() - v.len() / 2, SMALL_SORT_GENERAL_SCRATCH_LEN)`\n otherwise the implementation may abort.\n\n `limit` when initialized with `c*log(v.len())` for some c ensures we do not\n overflow the stack or go quadratic.\n",
      "adt": {}
    },
    "slice::sort::stable::drift::DriftsortRun::new_unsorted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "slice::sort::stable::drift::DriftsortRun": "Constructor"
      }
    }
  },
  "adts": {
    "ops::range::RangeTo": [
      "Plain"
    ],
    "slice::sort::stable::drift::DriftsortRun": [
      "Plain"
    ],
    "option::Option": [
      "Plain"
    ]
  },
  "path": 16694,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/sort/stable/drift.rs:226:1: 260:2",
  "src": "fn create_run<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    min_good_run_len: usize,\n    eager_sort: bool,\n    is_less: &mut F,\n) -> DriftsortRun {\n    let len = v.len();\n    if len >= min_good_run_len {\n        let (run_len, was_reversed) = find_existing_run(v, is_less);\n\n        // SAFETY: find_existing_run promises to return a valid run_len.\n        unsafe { intrinsics::assume(run_len <= len) };\n\n        if run_len >= min_good_run_len {\n            if was_reversed {\n                v[..run_len].reverse();\n            }\n\n            return DriftsortRun::new_sorted(run_len);\n        }\n    }\n\n    if eager_sort {\n        // We call quicksort with a len that will immediately call small-sort.\n        // By not calling the small-sort directly here it can always be inlined into\n        // the quicksort itself, making the recursive base case faster and is generally\n        // more binary-size efficient.\n        let eager_run_len = cmp::min(T::small_sort_threshold(), len);\n        quicksort(&mut v[..eager_run_len], scratch, 0, None, is_less);\n        DriftsortRun::new_sorted(eager_run_len)\n    } else {\n        DriftsortRun::new_unsorted(cmp::min(min_good_run_len, len))\n    }\n}",
  "mir": "fn slice::sort::stable::drift::create_run(_1: &mut [T], _2: &mut [mem::maybe_uninit::MaybeUninit<T>], _3: usize, _4: bool, _5: &mut F) -> slice::sort::stable::drift::DriftsortRun {\n    let mut _0: slice::sort::stable::drift::DriftsortRun;\n    let  _6: usize;\n    let mut _7: &[T];\n    let mut _8: bool;\n    let  _9: usize;\n    let  _10: bool;\n    let mut _11: (usize, bool);\n    let mut _12: &[T];\n    let mut _13: bool;\n    let mut _14: bool;\n    let  _15: ();\n    let mut _16: &mut [T];\n    let mut _17: ops::range::RangeTo<usize>;\n    let  _18: usize;\n    let mut _19: usize;\n    let  _20: ();\n    let mut _21: &mut [T];\n    let mut _22: ops::range::RangeTo<usize>;\n    let mut _23: option::Option<&T>;\n    let mut _24: usize;\n    debug v => _1;\n    debug scratch => _2;\n    debug min_good_run_len => _3;\n    debug eager_sort => _4;\n    debug is_less => _5;\n    debug len => _6;\n    debug run_len => _9;\n    debug was_reversed => _10;\n    debug eager_run_len => _18;\n    bb0: {\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = Ge(_6, _3);\n        switchInt(move _8) -> [0: bb10, otherwise: bb1];\n    }\n    bb1: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = slice::sort::shared::find_existing_run::<T, F>(move _12, _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_12);\n        _9 = (_11.0: usize);\n        _10 = (_11.1: bool);\n        StorageDead(_11);\n        StorageLive(_13);\n        _13 = Le(_9, _6);\n        Intrinsic(Assume(Move(_13)));\n        StorageDead(_13);\n        StorageLive(_14);\n        _14 = Ge(_9, _3);\n        switchInt(move _14) -> [0: bb9, otherwise: bb3];\n    }\n    bb3: {\n        switchInt(_10) -> [0: bb7, otherwise: bb4];\n    }\n    bb4: {\n        StorageLive(_17);\n        _17 = RangeTo(_9);\n        _16 = <[T] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_1, move _17) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_17);\n        _15 = slice::<impl [T]>::reverse(_16) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb7;\n    }\n    bb7: {\n        _0 = slice::sort::stable::drift::DriftsortRun::new_sorted(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_8);\n        goto -> bb22;\n    }\n    bb9: {\n        StorageDead(_14);\n        goto -> bb11;\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_8);\n        switchInt(_4) -> [0: bb18, otherwise: bb12];\n    }\n    bb12: {\n        StorageLive(_19);\n        _19 = <T as slice::sort::shared::smallsort::StableSmallSortTypeImpl>::small_sort_threshold() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = cmp::min::<usize>(move _19, _6) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = RangeTo(_18);\n        _21 = <[T] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_1, move _22) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = option::Option::None;\n        _20 = slice::sort::stable::quicksort::quicksort::<T, F>(_21, _2, 0_u32, move _23, _5) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        _0 = slice::sort::stable::drift::DriftsortRun::new_sorted(_18) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        goto -> bb21;\n    }\n    bb18: {\n        StorageLive(_24);\n        _24 = cmp::min::<usize>(_3, _6) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _0 = slice::sort::stable::drift::DriftsortRun::new_unsorted(move _24) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_24);\n        goto -> bb21;\n    }\n    bb21: {\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": " Creates a new logical run.\n\n A logical run can either be sorted or unsorted. If there is a pre-existing\n run that clears the `min_good_run_len` threshold it is returned as a sorted\n run. If not, the result depends on the value of `eager_sort`. If it is true,\n then a sorted run of length `T::SMALL_SORT_THRESHOLD` is returned, and if it\n is false an unsorted run of length `min_good_run_len` is returned.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}