{
  "name": "str::slice_error_fail_rt",
  "safe": true,
  "callees": {
    "str::<impl str>::floor_char_boundary": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds the closest `x` not exceeding `index` where [`is_char_boundary(x)`] is `true`.\n\n This method can help you truncate a string so that it's still valid UTF-8, but doesn't\n exceed a given number of bytes. Note that this is done purely at the character level\n and can still visually split graphemes, even though the underlying characters aren't\n split. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only\n includes üßë (person) instead.\n\n [`is_char_boundary(x)`]: Self::is_char_boundary\n\n # Examples\n\n ```\n let s = \"‚ù§Ô∏èüß°üíõüíöüíôüíú\";\n assert_eq!(s.len(), 26);\n assert!(!s.is_char_boundary(13));\n\n let closest = s.floor_char_boundary(13);\n assert_eq!(closest, 10);\n assert_eq!(&s[..closest], \"‚ù§Ô∏èüß°\");\n ```\n",
      "adt": {}
    },
    "ops::index::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "str::<impl str>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of `self`.\n\n This length is in bytes, not [`char`]s or graphemes. In other words,\n it might not be what a human considers the length of the string.\n\n [`char`]: prim@char\n\n # Examples\n\n ```\n let len = \"foo\".len();\n assert_eq!(3, len);\n\n assert_eq!(\"∆íoo\".len(), 4); // fancy f!\n assert_eq!(\"∆íoo\".chars().count(), 3);\n ```\n",
      "adt": {}
    },
    "fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::rt::Argument": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "str::<impl str>::is_char_boundary": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks that `index`-th byte is the first byte in a UTF-8 code point\n sequence or the end of the string.\n\n The start and end of the string (when `index == self.len()`) are\n considered to be boundaries.\n\n Returns `false` if `index` is greater than `self.len()`.\n\n # Examples\n\n ```\n let s = \"L√∂we ËÄÅËôé L√©opard\";\n assert!(s.is_char_boundary(0));\n // start of `ËÄÅ`\n assert!(s.is_char_boundary(6));\n assert!(s.is_char_boundary(s.len()));\n\n // second byte of `√∂`\n assert!(!s.is_char_boundary(2));\n\n // third byte of `ËÄÅ`\n assert!(!s.is_char_boundary(8));\n ```\n",
      "adt": {}
    },
    "str::<impl str>::chars": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the [`char`]s of a string slice.\n\n As a string slice consists of valid UTF-8, we can iterate through a\n string slice by [`char`]. This method returns such an iterator.\n\n It's important to remember that [`char`] represents a Unicode Scalar\n Value, and might not match your idea of what a 'character' is. Iteration\n over grapheme clusters may be what you actually want. This functionality\n is not provided by Rust's standard library, check crates.io instead.\n\n # Examples\n\n Basic usage:\n\n ```\n let word = \"goodbye\";\n\n let count = word.chars().count();\n assert_eq!(7, count);\n\n let mut chars = word.chars();\n\n assert_eq!(Some('g'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('o'), chars.next());\n assert_eq!(Some('d'), chars.next());\n assert_eq!(Some('b'), chars.next());\n assert_eq!(Some('y'), chars.next());\n assert_eq!(Some('e'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n\n Remember, [`char`]s might not match your intuition about characters:\n\n [`char`]: prim@char\n\n ```\n let y = \"yÃÜ\";\n\n let mut chars = y.chars();\n\n assert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\n assert_eq!(Some('\\u{0306}'), chars.next());\n\n assert_eq!(None, chars.next());\n ```\n",
      "adt": {
        "str::iter::Chars": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "char::methods::<impl char>::len_utf8": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes this `char` would need if encoded in UTF-8.\n\n That number of bytes is always between 1 and 4, inclusive.\n\n # Examples\n\n Basic usage:\n\n ```\n let len = 'A'.len_utf8();\n assert_eq!(len, 1);\n\n let len = '√ü'.len_utf8();\n assert_eq!(len, 2);\n\n let len = '‚Ñù'.len_utf8();\n assert_eq!(len, 3);\n\n let len = 'üí£'.len_utf8();\n assert_eq!(len, 4);\n ```\n\n The `&str` type guarantees that its contents are UTF-8, and so we can compare the length it\n would take if each code point was represented as a `char` vs in the `&str` itself:\n\n ```\n // as chars\n let eastern = 'Êù±';\n let capital = '‰∫¨';\n\n // both can be represented as three bytes\n assert_eq!(3, eastern.len_utf8());\n assert_eq!(3, capital.len_utf8());\n\n // as a &str, these two are encoded in UTF-8\n let tokyo = \"Êù±‰∫¨\";\n\n let len = eastern.len_utf8() + capital.len_utf8();\n\n // we can see that they take six bytes total...\n assert_eq!(6, tokyo.len());\n\n // ... just like the &str\n assert_eq!(len, tokyo.len());\n ```\n",
      "adt": {}
    },
    "fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::rt::Argument": "Constructor"
      }
    }
  },
  "adts": {
    "ops::range::RangeTo": [
      "Plain"
    ],
    "fmt::rt::Argument": [
      "Plain"
    ],
    "fmt::Arguments": [
      "Plain"
    ],
    "ops::range::RangeFrom": [
      "Plain"
    ],
    "str::iter::Chars": [
      "Plain",
      "MutRef"
    ],
    "option::Option": [
      "Plain"
    ],
    "ops::range::Range": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(4)))"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::str::slice_error_fail_rt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:83:1: 116:2",
  "src": "fn slice_error_fail_rt(s: &str, begin: usize, end: usize) -> ! {\n    const MAX_DISPLAY_LENGTH: usize = 256;\n    let trunc_len = s.floor_char_boundary(MAX_DISPLAY_LENGTH);\n    let s_trunc = &s[..trunc_len];\n    let ellipsis = if trunc_len < s.len() { \"[...]\" } else { \"\" };\n\n    // 1. out of bounds\n    if begin > s.len() || end > s.len() {\n        let oob_index = if begin > s.len() { begin } else { end };\n        panic!(\"byte index {oob_index} is out of bounds of `{s_trunc}`{ellipsis}\");\n    }\n\n    // 2. begin <= end\n    assert!(\n        begin <= end,\n        \"begin <= end ({} <= {}) when slicing `{}`{}\",\n        begin,\n        end,\n        s_trunc,\n        ellipsis\n    );\n\n    // 3. character boundary\n    let index = if !s.is_char_boundary(begin) { begin } else { end };\n    // find the character\n    let char_start = s.floor_char_boundary(index);\n    // `char_start` must be less than len and a char boundary\n    let ch = s[char_start..].chars().next().unwrap();\n    let char_range = char_start..char_start + ch.len_utf8();\n    panic!(\n        \"byte index {} is not a char boundary; it is inside {:?} (bytes {:?}) of `{}`{}\",\n        index, ch, char_range, s_trunc, ellipsis\n    );\n}",
  "mir": "fn str::slice_error_fail_rt(_1: &str, _2: usize, _3: usize) -> ! {\n    let mut _0: !;\n    let  _4: usize;\n    let  _5: &str;\n    let  _6: &str;\n    let mut _7: ops::range::RangeTo<usize>;\n    let  _8: &str;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: bool;\n    let mut _14: usize;\n    let  _15: usize;\n    let mut _16: bool;\n    let mut _17: usize;\n    let  _18: !;\n    let mut _19: fmt::Arguments<'_>;\n    let  _20: (&usize, &&str, &&str);\n    let mut _21: &usize;\n    let mut _22: &&str;\n    let mut _23: &&str;\n    let  _24: [fmt::rt::Argument<'_>; 3];\n    let mut _25: fmt::rt::Argument<'_>;\n    let mut _26: fmt::rt::Argument<'_>;\n    let mut _27: fmt::rt::Argument<'_>;\n    let mut _28: &[u8; 41];\n    let  _29: &[fmt::rt::Argument<'_>; 3];\n    let mut _30: bool;\n    let  _31: !;\n    let mut _32: fmt::Arguments<'_>;\n    let  _33: (&usize, &usize, &&str, &&str);\n    let mut _34: &usize;\n    let mut _35: &usize;\n    let mut _36: &&str;\n    let mut _37: &&str;\n    let  _38: [fmt::rt::Argument<'_>; 4];\n    let mut _39: fmt::rt::Argument<'_>;\n    let mut _40: fmt::rt::Argument<'_>;\n    let mut _41: fmt::rt::Argument<'_>;\n    let mut _42: fmt::rt::Argument<'_>;\n    let mut _43: &[u8; 44];\n    let  _44: &[fmt::rt::Argument<'_>; 4];\n    let  _45: usize;\n    let mut _46: bool;\n    let  _47: usize;\n    let mut _48: usize;\n    let  _49: char;\n    let mut _50: option::Option<char>;\n    let mut _51: &mut str::iter::Chars<'_>;\n    let mut _52: str::iter::Chars<'_>;\n    let  _53: &str;\n    let mut _54: ops::range::RangeFrom<usize>;\n    let  _55: ops::range::Range<usize>;\n    let mut _56: usize;\n    let mut _57: usize;\n    let mut _58: (usize, bool);\n    let  _59: !;\n    let mut _60: fmt::Arguments<'_>;\n    let  _61: (&usize, &char, &ops::range::Range<usize>, &&str, &&str);\n    let mut _62: &usize;\n    let mut _63: &char;\n    let mut _64: &ops::range::Range<usize>;\n    let mut _65: &&str;\n    let mut _66: &&str;\n    let  _67: [fmt::rt::Argument<'_>; 5];\n    let mut _68: fmt::rt::Argument<'_>;\n    let mut _69: fmt::rt::Argument<'_>;\n    let mut _70: fmt::rt::Argument<'_>;\n    let mut _71: fmt::rt::Argument<'_>;\n    let mut _72: fmt::rt::Argument<'_>;\n    let mut _73: &[u8; 75];\n    let  _74: &[fmt::rt::Argument<'_>; 5];\n    let mut _75: &usize;\n    let mut _76: &&str;\n    let mut _77: &&str;\n    let mut _78: &usize;\n    let mut _79: &usize;\n    let mut _80: &&str;\n    let mut _81: &&str;\n    let mut _82: &usize;\n    let mut _83: &char;\n    let mut _84: &ops::range::Range<usize>;\n    let mut _85: &&str;\n    let mut _86: &&str;\n    debug s => _1;\n    debug begin => _2;\n    debug end => _3;\n    debug trunc_len => _4;\n    debug s_trunc => _5;\n    debug ellipsis => _8;\n    debug oob_index => _15;\n    debug args => _20;\n    debug args => _24;\n    debug args => _33;\n    debug args => _38;\n    debug index => _45;\n    debug char_start => _47;\n    debug ch => _49;\n    debug char_range => _55;\n    debug args => _61;\n    debug args => _67;\n    bb0: {\n        _4 = str::<impl str>::floor_char_boundary(_1, str::slice_error_fail_rt::MAX_DISPLAY_LENGTH) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = RangeTo(_4);\n        _6 = <str as ops::index::Index<ops::range::RangeTo<usize>>>::index(_1, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = _6;\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = str::<impl str>::len(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = Lt(_4, move _10);\n        switchInt(move _9) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = \"[...]\";\n        goto -> bb6;\n    }\n    bb5: {\n        StorageDead(_10);\n        _8 = \"\";\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = str::<impl str>::len(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = Gt(_2, move _12);\n        switchInt(move _11) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_12);\n        goto -> bb12;\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = str::<impl str>::len(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _13 = Gt(_3, move _14);\n        switchInt(move _13) -> [0: bb21, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_14);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = str::<impl str>::len(_1) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _16 = Gt(_2, move _17);\n        switchInt(move _16) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_17);\n        _15 = _2;\n        goto -> bb16;\n    }\n    bb15: {\n        StorageDead(_17);\n        _15 = _3;\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_15;\n        StorageLive(_22);\n        _22 = &_5;\n        StorageLive(_23);\n        _23 = &_8;\n        _20 = (move _21, move _22, move _23);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_24);\n        StorageLive(_25);\n        _75 = (_20.0: &usize);\n        _25 = fmt::rt::Argument::<'_>::new_display::<usize>(_75) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_26);\n        _76 = (_20.1: &&str);\n        _26 = fmt::rt::Argument::<'_>::new_display::<&str>(_76) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_27);\n        _77 = (_20.2: &&str);\n        _27 = fmt::rt::Argument::<'_>::new_display::<&str>(_77) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _24 = [move _25, move _26, move _27];\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_28);\n        _28 = b\"\\x0bbyte index \\xc0\\x16 is out of bounds of `\\xc0\\x01`\\xc0\\x00\";\n        _29 = &_24;\n        _19 = fmt::Arguments::<'_>::new::<41, 3>(move _28, _29) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_28);\n        _18 = panicking::panic_fmt(move _19) -> unwind unreachable;\n    }\n    bb21: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageLive(_30);\n        _30 = Le(_2, _3);\n        switchInt(move _30) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = str::<impl str>::is_char_boundary(_1, _2) -> [return: bb29, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &_2;\n        StorageLive(_35);\n        _35 = &_3;\n        StorageLive(_36);\n        _36 = &_5;\n        StorageLive(_37);\n        _37 = &_8;\n        _33 = (move _34, move _35, move _36, move _37);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_38);\n        StorageLive(_39);\n        _78 = (_33.0: &usize);\n        _39 = fmt::rt::Argument::<'_>::new_display::<usize>(_78) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageLive(_40);\n        _79 = (_33.1: &usize);\n        _40 = fmt::rt::Argument::<'_>::new_display::<usize>(_79) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageLive(_41);\n        _80 = (_33.2: &&str);\n        _41 = fmt::rt::Argument::<'_>::new_display::<&str>(_80) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_42);\n        _81 = (_33.3: &&str);\n        _42 = fmt::rt::Argument::<'_>::new_display::<&str>(_81) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _38 = [move _39, move _40, move _41, move _42];\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_43);\n        _43 = b\"\\x0ebegin <= end (\\xc0\\x04 <= \\xc0\\x10) when slicing `\\xc0\\x01`\\xc0\\x00\";\n        _44 = &_38;\n        _32 = fmt::Arguments::<'_>::new::<44, 4>(move _43, _44) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_43);\n        _31 = panicking::panic_fmt(move _32) -> unwind unreachable;\n    }\n    bb29: {\n        switchInt(move _46) -> [0: bb31, otherwise: bb30];\n    }\n    bb30: {\n        _45 = _3;\n        goto -> bb32;\n    }\n    bb31: {\n        _45 = _2;\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_46);\n        StorageLive(_48);\n        _48 = _45;\n        _47 = str::<impl str>::floor_char_boundary(_1, move _48) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_48);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_54);\n        _54 = RangeFrom(_47);\n        _53 = <str as ops::index::Index<ops::range::RangeFrom<usize>>>::index(_1, move _54) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_54);\n        _52 = str::<impl str>::chars(_53) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _51 = &mut _52;\n        _50 = <str::iter::Chars<'_> as iter::traits::iterator::Iterator>::next(move _51) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_51);\n        _49 = option::Option::<char>::unwrap(move _50) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_50);\n        StorageDead(_52);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = char::methods::<impl char>::len_utf8(_49) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        _58 = CheckedAdd(_47, _57);\n        assert(!move (_58.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _47, move _57) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _56 = move (_58.0: usize);\n        StorageDead(_57);\n        _55 = Range(_47, move _56);\n        StorageDead(_56);\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = &_45;\n        StorageLive(_63);\n        _63 = &_49;\n        StorageLive(_64);\n        _64 = &_55;\n        StorageLive(_65);\n        _65 = &_5;\n        StorageLive(_66);\n        _66 = &_8;\n        _61 = (move _62, move _63, move _64, move _65, move _66);\n        StorageDead(_66);\n        StorageDead(_65);\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageLive(_67);\n        StorageLive(_68);\n        _82 = (_61.0: &usize);\n        _68 = fmt::rt::Argument::<'_>::new_display::<usize>(_82) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageLive(_69);\n        _83 = (_61.1: &char);\n        _69 = fmt::rt::Argument::<'_>::new_debug::<char>(_83) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageLive(_70);\n        _84 = (_61.2: &ops::range::Range<usize>);\n        _70 = fmt::rt::Argument::<'_>::new_debug::<ops::range::Range<usize>>(_84) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageLive(_71);\n        _85 = (_61.3: &&str);\n        _71 = fmt::rt::Argument::<'_>::new_display::<&str>(_85) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageLive(_72);\n        _86 = (_61.4: &&str);\n        _72 = fmt::rt::Argument::<'_>::new_display::<&str>(_86) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _67 = [move _68, move _69, move _70, move _71, move _72];\n        StorageDead(_72);\n        StorageDead(_71);\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageLive(_73);\n        _73 = b\"\\x0bbyte index \\xc0& is not a char boundary; it is inside \\xc0\\x08 (bytes \\xc0\\x06) of `\\xc0\\x01`\\xc0\\x00\";\n        _74 = &_67;\n        _60 = fmt::Arguments::<'_>::new::<75, 5>(move _73, _74) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_73);\n        _59 = panicking::panic_fmt(move _60) -> unwind unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}