{
  "name": "<A as slice::cmp::SliceOrd>::compare",
  "safe": true,
  "callees": {
    "slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "intrinsics::compare_bytes": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Lexicographically compare `[left, left + bytes)` and `[right, right + bytes)`\n as unsigned bytes, returning negative if `left` is less, zero if all the\n bytes match, or positive if `left` is greater.\n\n This underlies things like `<[u8]>::cmp`, and will usually lower to `memcmp`.\n\n # Safety\n\n `left` and `right` must each be [valid] for reads of `bytes` bytes.\n\n Note that this applies to the whole range, not just until the first byte\n that differs.  That allows optimizations that can read in large chunks.\n\n [valid]: crate::ptr#safety\n",
      "adt": {}
    },
    "cmp::Ord::cmp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This method returns an [`Ordering`] between `self` and `other`.\n\n By convention, `self.cmp(&other)` returns the ordering matching the expression\n `self <operator> other` if true.\n\n # Examples\n\n ```\n use std::cmp::Ordering;\n\n assert_eq!(5.cmp(&10), Ordering::Less);\n assert_eq!(10.cmp(&5), Ordering::Greater);\n assert_eq!(5.cmp(&5), Ordering::Equal);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "cmp::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::<A as slice::cmp::SliceOrd>::compare"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/cmp.rs:309:5: 328:6",
  "src": "fn compare(left: &[Self], right: &[Self]) -> Ordering {\n        // Since the length of a slice is always less than or equal to\n        // isize::MAX, this never underflows.\n        let diff = left.len() as isize - right.len() as isize;\n        // This comparison gets optimized away (on x86_64 and ARM) because the\n        // subtraction updates flags.\n        let len = if left.len() < right.len() { left.len() } else { right.len() };\n        let left = left.as_ptr().cast();\n        let right = right.as_ptr().cast();\n        // SAFETY: `left` and `right` are references and are thus guaranteed to\n        // be valid. `UnsignedBytewiseOrd` is only implemented for types that\n        // are valid u8s and can be compared the same way. We use the minimum\n        // of both lengths which guarantees that both regions are valid for\n        // reads in that interval.\n        let mut order = unsafe { compare_bytes(left, right, len) as isize };\n        if order == 0 {\n            order = diff;\n        }\n        order.cmp(&0)\n    }",
  "mir": "fn <A as slice::cmp::SliceOrd>::compare(_1: &[A], _2: &[A]) -> cmp::Ordering {\n    let mut _0: cmp::Ordering;\n    let  _3: isize;\n    let mut _4: isize;\n    let mut _5: usize;\n    let mut _6: isize;\n    let mut _7: usize;\n    let mut _8: (isize, bool);\n    let  _9: usize;\n    let mut _10: bool;\n    let mut _11: usize;\n    let mut _12: usize;\n    let  _13: *const u8;\n    let mut _14: *const A;\n    let  _15: *const u8;\n    let mut _16: *const A;\n    let mut _17: isize;\n    let mut _18: i32;\n    let mut _19: usize;\n    let mut _20: isize;\n    let mut _21: &isize;\n    let  _22: &isize;\n    debug left => _1;\n    debug right => _2;\n    debug diff => _3;\n    debug len => _9;\n    debug left => _13;\n    debug right => _15;\n    debug order => _17;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = PtrMetadata(_1);\n        _4 = move _5 as isize;\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = PtrMetadata(_2);\n        _6 = move _7 as isize;\n        StorageDead(_7);\n        _8 = CheckedSub(_4, _6);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _4, move _6) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = move (_8.0: isize);\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = PtrMetadata(_1);\n        StorageLive(_12);\n        _12 = PtrMetadata(_2);\n        _10 = Lt(move _11, move _12);\n        switchInt(move _10) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = PtrMetadata(_1);\n        goto -> bb4;\n    }\n    bb3: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = PtrMetadata(_2);\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_14);\n        _14 = slice::<impl [A]>::as_ptr(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _13 = ptr::const_ptr::<impl *const A>::cast::<u8>(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = slice::<impl [A]>::as_ptr(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _15 = ptr::const_ptr::<impl *const A>::cast::<u8>(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = _9;\n        _18 = intrinsics::compare_bytes(_13, _15, move _19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        _17 = move _18 as isize;\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = _17;\n        switchInt(move _20) -> [0: bb10, otherwise: bb11];\n    }\n    bb10: {\n        StorageDead(_20);\n        _17 = _3;\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_20);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_21);\n        _21 = &_17;\n        _22 = <A as slice::cmp::SliceOrd>::compare::promoted[0];\n        _0 = <isize as cmp::Ord>::cmp(move _21, _22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_17);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}