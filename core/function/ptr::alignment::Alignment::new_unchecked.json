{
  "name": "ptr::alignment::Alignment::new_unchecked",
  "safe": false,
  "callees": {
    "ub_checks::check_language_ub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines whether we should check for language UB.\n\n The intention is to not do that when running in the interpreter, as that one has its own\n language UB checks which generally produce better errors.\n",
      "adt": {}
    },
    "ptr::alignment::Alignment::new_unchecked::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "ptr::alignment::Alignment": [
      "Plain"
    ]
  },
  "path": 15941,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/alignment.rs:79:5: 89:6",
  "src": "pub const unsafe fn new_unchecked(align: usize) -> Self {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"Alignment::new_unchecked requires a power of two\",\n            (align: usize = align) => align.is_power_of_two()\n        );\n\n        // SAFETY: By precondition, this must be a power of two, and\n        // our variants encompass all possible powers of two.\n        unsafe { mem::transmute::<usize, Alignment>(align) }\n    }",
  "mir": "fn ptr::alignment::Alignment::new_unchecked(_1: usize) -> ptr::alignment::Alignment {\n    let mut _0: ptr::alignment::Alignment;\n    let mut _2: bool;\n    let  _3: ();\n    debug align => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = ub_checks::check_language_ub() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        _3 = ptr::alignment::Alignment::new_unchecked::precondition_check(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_2);\n        _0 = _1 as ptr::alignment::Alignment;\n        return;\n    }\n}\n",
  "doc": " Creates an `Alignment` from a power-of-two `usize`.\n\n # Safety\n\n `align` must be a power of two.\n\n Equivalently, it must be `1 << exp` for some `exp` in `0..usize::BITS`.\n It must *not* be zero.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}