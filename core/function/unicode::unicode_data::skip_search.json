{
  "name": "unicode::unicode_data::skip_search",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::binary_search_by_key": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Binary searches this slice with a key extraction function.\n\n Assumes that the slice is sorted by the key, for instance with\n [`sort_by_key`] using the same key extraction function.\n If the slice is not sorted by the key, the returned result is\n unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n\n [`sort_by_key`]: slice::sort_by_key\n [`binary_search`]: slice::binary_search\n [`binary_search_by`]: slice::binary_search_by\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements in a slice of pairs sorted by\n their second elements. The first is found, with a uniquely\n determined position; the second and third are not found; the\n fourth could match any position in `[1, 4]`.\n\n ```\n let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n          (1, 21), (2, 34), (4, 55)];\n\n assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));\n assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));\n assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));\n let r = s.binary_search_by_key(&1, |&(a, b)| b);\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
      "adt": {
        "result::Result": "Constructor"
      }
    },
    "unicode::unicode_data::ShortOffsetRunHeader::start_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "unicode::unicode_data::ShortOffsetRunHeader": "ImmutableAsArgument"
      }
    },
    "slice::<impl [T]>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice depending on the type of\n index.\n\n - If given a position, returns a reference to the element at that\n   position or `None` if out of bounds.\n - If given a range, returns the subslice corresponding to that range,\n   or `None` if out of bounds.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&40), v.get(1));\n assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n assert_eq!(None, v.get(3));\n assert_eq!(None, v.get(0..4));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "num::<impl usize>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "iter::traits::collect::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 47, kind: RigidTy(Uint(Usize)) })])"
    ],
    "unicode::unicode_data::ShortOffsetRunHeader": [
      "Ref"
    ],
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15710, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 15708, kind: RigidTy(Adt(AdtDef(DefId { id: 29616, name: \"unicode::unicode_data::ShortOffsetRunHeader\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "ops::range::Range": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::unicode::unicode_data::skip_search"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:88:1: 141:2",
  "src": "unsafe fn skip_search<const SOR: usize, const OFFSETS: usize>(\n    needle: char,\n    short_offset_runs: &[ShortOffsetRunHeader; SOR],\n    offsets: &[u8; OFFSETS],\n) -> bool {\n    let needle = needle as u32;\n\n    let last_idx =\n        match short_offset_runs.binary_search_by_key(&(needle << 11), |header| header.0 << 11) {\n            Ok(idx) => idx + 1,\n            Err(idx) => idx,\n        };\n    // SAFETY: `last_idx` *cannot* be past the end of the array, as the last\n    // element is greater than `std::char::MAX` (the largest possible needle)\n    // as guaranteed by the caller.\n    //\n    // So, we cannot have found it (i.e. `Ok(idx) => idx + 1 != length`) and the\n    // correct location cannot be past it, so `Err(idx) => idx != length` either.\n    //\n    // This means that we can avoid bounds checking for the accesses below, too.\n    //\n    // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n    // in `hint::assert_unchecked` may not be optimized out.\n    unsafe { crate::intrinsics::assume(last_idx < SOR) };\n\n    let mut offset_idx = short_offset_runs[last_idx].start_index();\n    let length = if let Some(next) = short_offset_runs.get(last_idx + 1) {\n        (*next).start_index() - offset_idx\n    } else {\n        offsets.len() - offset_idx\n    };\n\n    let prev =\n        last_idx.checked_sub(1).map(|prev| short_offset_runs[prev].prefix_sum()).unwrap_or(0);\n\n    let total = needle - prev;\n    let mut prefix_sum = 0;\n    for _ in 0..(length - 1) {\n        // SAFETY: It is guaranteed that `length <= OFFSETS - offset_idx`,\n        // so it follows that `length - 1 + offset_idx < OFFSETS`, therefore\n        // `offset_idx < OFFSETS` is always true in this loop.\n        //\n        // We need to use `intrinsics::assume` since the `panic_nounwind` contained\n        // in `hint::assert_unchecked` may not be optimized out.\n        unsafe { crate::intrinsics::assume(offset_idx < OFFSETS) };\n        let offset = offsets[offset_idx];\n        prefix_sum += offset as u32;\n        if prefix_sum > total {\n            break;\n        }\n        offset_idx += 1;\n    }\n    offset_idx % 2 == 1\n}",
  "mir": "fn unicode::unicode_data::skip_search(_1: char, _2: &[unicode::unicode_data::ShortOffsetRunHeader; SOR], _3: &[u8; OFFSETS]) -> bool {\n    let mut _0: bool;\n    let  _4: u32;\n    let  _5: usize;\n    let mut _6: result::Result<usize, usize>;\n    let mut _7: &[unicode::unicode_data::ShortOffsetRunHeader];\n    let  _8: &u32;\n    let  _9: u32;\n    let mut _10: u32;\n    let mut _11: bool;\n    let mut _12: isize;\n    let  _13: usize;\n    let mut _14: (usize, bool);\n    let  _15: usize;\n    let mut _16: bool;\n    let mut _17: usize;\n    let mut _18: usize;\n    let mut _19: &unicode::unicode_data::ShortOffsetRunHeader;\n    let  _20: usize;\n    let mut _21: bool;\n    let  _22: usize;\n    let mut _23: option::Option<&unicode::unicode_data::ShortOffsetRunHeader>;\n    let mut _24: &[unicode::unicode_data::ShortOffsetRunHeader];\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: (usize, bool);\n    let mut _28: isize;\n    let  _29: &unicode::unicode_data::ShortOffsetRunHeader;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: (usize, bool);\n    let mut _33: usize;\n    let mut _34: &[u8];\n    let mut _35: usize;\n    let mut _36: (usize, bool);\n    let  _37: u32;\n    let mut _38: option::Option<u32>;\n    let mut _39: option::Option<usize>;\n    let mut _40: usize;\n    let mut _41: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:121:37: 121:43};\n    let  _42: u32;\n    let mut _43: (u32, bool);\n    let mut _44: u32;\n    let mut _45: ops::range::Range<usize>;\n    let mut _46: ops::range::Range<usize>;\n    let mut _47: usize;\n    let mut _48: usize;\n    let mut _49: (usize, bool);\n    let mut _50: ops::range::Range<usize>;\n    let mut _51: option::Option<usize>;\n    let mut _52: &mut ops::range::Range<usize>;\n    let mut _53: isize;\n    let mut _54: bool;\n    let mut _55: usize;\n    let  _56: u8;\n    let  _57: usize;\n    let mut _58: bool;\n    let mut _59: u32;\n    let mut _60: (u32, bool);\n    let mut _61: bool;\n    let mut _62: u32;\n    let mut _63: (usize, bool);\n    let mut _64: usize;\n    let mut _65: usize;\n    let mut _66: bool;\n    debug needle => _1;\n    debug short_offset_runs => _2;\n    debug offsets => _3;\n    debug needle => _4;\n    debug last_idx => _5;\n    debug idx => _13;\n    debug idx => _15;\n    debug offset_idx => _18;\n    debug length => _22;\n    debug next => _29;\n    debug prev => _37;\n    debug total => _42;\n    debug prefix_sum => _44;\n    debug iter => _50;\n    debug offset => _56;\n    bb0: {\n        _4 = _1 as u32;\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _2 as &[unicode::unicode_data::ShortOffsetRunHeader];\n        StorageLive(_9);\n        _10 = 11_i32 as u32;\n        _11 = Lt(move _10, 32_u32);\n        assert(move _11, \"attempt to shift left by `{}`, which would overflow\", 11_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _9 = Shl(_4, 11_i32);\n        _8 = &_9;\n        _6 = slice::<impl [unicode::unicode_data::ShortOffsetRunHeader]>::binary_search_by_key::<'_, u32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:96:71: 96:79}>(move _7, _8, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:96:71: 96:79}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _12 = discriminant(_6);\n        switchInt(move _12) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_15);\n        _15 = ((_6 as variant#1).0: usize);\n        _5 = _15;\n        StorageDead(_15);\n        goto -> bb7;\n    }\n    bb5: {\n        _13 = ((_6 as variant#0).0: usize);\n        _14 = CheckedAdd(_13, 1_usize);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _13, 1_usize) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _5 = move (_14.0: usize);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageDead(_6);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _5;\n        _16 = Lt(move _17, SOR);\n        StorageDead(_17);\n        Intrinsic(Assume(Move(_16)));\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = _5;\n        _21 = Lt(_20, SOR);\n        assert(move _21, \"index out of bounds: the length is {} but the index is {}\", SOR, _20) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _19 = &(*_2)[_20];\n        _18 = unicode::unicode_data::ShortOffsetRunHeader::start_index(move _19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = _2 as &[unicode::unicode_data::ShortOffsetRunHeader];\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = _5;\n        _27 = CheckedAdd(_26, 1_usize);\n        assert(!move (_27.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _26, 1_usize) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _25 = move (_27.0: usize);\n        StorageDead(_26);\n        _23 = slice::<impl [unicode::unicode_data::ShortOffsetRunHeader]>::get::<usize>(move _24, move _25) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_25);\n        StorageDead(_24);\n        _28 = discriminant(_23);\n        switchInt(move _28) -> [1: bb12, 0: bb15, otherwise: bb3];\n    }\n    bb12: {\n        _29 = ((_23 as variant#1).0: &unicode::unicode_data::ShortOffsetRunHeader);\n        StorageLive(_30);\n        _30 = unicode::unicode_data::ShortOffsetRunHeader::start_index(_29) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_31);\n        _31 = _18;\n        _32 = CheckedSub(_30, _31);\n        assert(!move (_32.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _30, move _31) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _22 = move (_32.0: usize);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_23);\n        goto -> bb17;\n    }\n    bb15: {\n        StorageDead(_23);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = _3 as &[u8];\n        _33 = PtrMetadata(move _34);\n        StorageDead(_34);\n        StorageLive(_35);\n        _35 = _18;\n        _36 = CheckedSub(_33, _35);\n        assert(!move (_36.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _33, move _35) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _22 = move (_36.0: usize);\n        StorageDead(_35);\n        StorageDead(_33);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = _5;\n        _39 = num::<impl usize>::checked_sub(move _40, 1_usize) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_40);\n        StorageLive(_41);\n        _41 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:121:37: 121:43}(_2);\n        _38 = option::Option::<usize>::map::<u32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs:121:37: 121:43}>(move _39, move _41) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_41);\n        StorageDead(_39);\n        _37 = option::Option::<u32>::unwrap_or(move _38, 0_u32) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_38);\n        _43 = CheckedSub(_4, _37);\n        assert(!move (_43.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _37) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _42 = move (_43.0: u32);\n        StorageLive(_44);\n        _44 = 0_u32;\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _22;\n        _49 = CheckedSub(_48, 1_usize);\n        assert(!move (_49.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _48, 1_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _47 = move (_49.0: usize);\n        StorageDead(_48);\n        _46 = Range(0_usize, move _47);\n        StorageDead(_47);\n        _45 = <ops::range::Range<usize> as iter::traits::collect::IntoIterator>::into_iter(move _46) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_46);\n        StorageLive(_50);\n        _50 = move _45;\n        goto -> bb24;\n    }\n    bb24: {\n        StorageLive(_51);\n        _52 = &mut _50;\n        _51 = <ops::range::Range<usize> as iter::traits::iterator::Iterator>::next(_52) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _53 = discriminant(_51);\n        switchInt(move _53) -> [0: bb32, 1: bb26, otherwise: bb3];\n    }\n    bb26: {\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = _18;\n        _54 = Lt(move _55, OFFSETS);\n        StorageDead(_55);\n        Intrinsic(Assume(Move(_54)));\n        StorageDead(_54);\n        StorageLive(_57);\n        _57 = _18;\n        _58 = Lt(_57, OFFSETS);\n        assert(move _58, \"index out of bounds: the length is {} but the index is {}\", OFFSETS, _57) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _56 = (*_3)[_57];\n        StorageDead(_57);\n        StorageLive(_59);\n        _59 = _56 as u32;\n        _60 = CheckedAdd(_44, _59);\n        assert(!move (_60.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _44, move _59) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _44 = move (_60.0: u32);\n        StorageDead(_59);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = _44;\n        _61 = Gt(move _62, _42);\n        switchInt(move _61) -> [0: bb30, otherwise: bb29];\n    }\n    bb29: {\n        StorageDead(_62);\n        StorageDead(_61);\n        goto -> bb32;\n    }\n    bb30: {\n        StorageDead(_62);\n        StorageDead(_61);\n        _63 = CheckedAdd(_18, 1_usize);\n        assert(!move (_63.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _18, 1_usize) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _18 = move (_63.0: usize);\n        StorageDead(_51);\n        goto -> bb24;\n    }\n    bb32: {\n        StorageDead(_51);\n        StorageDead(_50);\n        StorageDead(_45);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = _18;\n        _66 = Eq(2_usize, 0_usize);\n        assert(!move _66, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _65) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        _64 = Rem(move _65, 2_usize);\n        StorageDead(_65);\n        _0 = Eq(move _64, 1_usize);\n        StorageDead(_64);\n        StorageDead(_44);\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n - The last element of `short_offset_runs` must be greater than `std::char::MAX`.\n - The start indices of all elements in `short_offset_runs` must be less than `OFFSETS`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}