{
  "name": "iter::traits::iterator::Iterator::partition_in_place",
  "safe": true,
  "callees": {
    "iter::traits::iterator::Iterator::partition_in_place::is_false": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "iter::traits::iterator::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "iter::traits::iterator::Iterator::partition_in_place::is_true": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "iter::traits::double_ended::DoubleEndedIterator::rfind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator from the back that satisfies a predicate.\n\n `rfind()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, starting at the end, and if any\n of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `rfind()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `rfind()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n [`Some(element)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n\n assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter();\n\n assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next_back(), Some(&1));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    },
    "mem::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps the values at two mutable locations, without deinitializing either one.\n\n * If you want to swap with a default or dummy value, see [`take`].\n * If you want to swap with a passed value, returning the old value, see [`replace`].\n\n # Examples\n\n ```\n use std::mem;\n\n let mut x = 5;\n let mut y = 42;\n\n mem::swap(&mut x, &mut y);\n\n assert_eq!(42, x);\n assert_eq!(5, y);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8869, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3260, kind: Param(ParamTy { index: 2, name: \"T\" }) }, Mut)) })])"
    ]
  },
  "path": "iter::traits::iterator::Iterator::partition_in_place",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2268:5: 2306:6",
  "src": "fn partition_in_place<'a, T: 'a, P>(mut self, ref mut predicate: P) -> usize\n    where\n        Self: Sized + DoubleEndedIterator<Item = &'a mut T>,\n        P: FnMut(&T) -> bool,\n    {\n        // FIXME: should we worry about the count overflowing? The only way to have more than\n        // `usize::MAX` mutable references is with ZSTs, which aren't useful to partition...\n\n        // These closure \"factory\" functions exist to avoid genericity in `Self`.\n\n        #[inline]\n        fn is_false<'a, T>(\n            predicate: &'a mut impl FnMut(&T) -> bool,\n            true_count: &'a mut usize,\n        ) -> impl FnMut(&&mut T) -> bool + 'a {\n            move |x| {\n                let p = predicate(&**x);\n                *true_count += p as usize;\n                !p\n            }\n        }\n\n        #[inline]\n        fn is_true<T>(predicate: &mut impl FnMut(&T) -> bool) -> impl FnMut(&&mut T) -> bool + '_ {\n            move |x| predicate(&**x)\n        }\n\n        // Repeatedly find the first `false` and swap it with the last `true`.\n        let mut true_count = 0;\n        while let Some(head) = self.find(is_false(predicate, &mut true_count)) {\n            if let Some(tail) = self.rfind(is_true(predicate)) {\n                crate::mem::swap(head, tail);\n                true_count += 1;\n            } else {\n                break;\n            }\n        }\n        true_count\n    }",
  "mir": "fn iter::traits::iterator::Iterator::partition_in_place(_1: Self, _2: P) -> usize {\n    let mut _0: usize;\n    let  _3: &mut P;\n    let mut _4: usize;\n    let mut _5: option::Option<&mut T>;\n    let mut _6: &mut Self;\n    let mut _7: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2283:13: 2283:21};\n    let mut _8: &mut usize;\n    let mut _9: isize;\n    let  _10: &mut T;\n    let mut _11: option::Option<&mut T>;\n    let mut _12: &mut Self;\n    let mut _13: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2292:13: 2292:21};\n    let mut _14: isize;\n    let  _15: &mut T;\n    let  _16: ();\n    let mut _17: (usize, bool);\n    debug self => _1;\n    debug predicate => _3;\n    debug true_count => _4;\n    debug head => _10;\n    debug tail => _15;\n    bb0: {\n        _3 = &mut _2;\n        StorageLive(_4);\n        _4 = 0_usize;\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut _1;\n        StorageLive(_7);\n        _8 = &mut _4;\n        _7 = iter::traits::iterator::Iterator::partition_in_place::is_false::<T, P>(_3, _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = <Self as iter::traits::iterator::Iterator>::find::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2283:13: 2283:21}>(move _6, move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_6);\n        _9 = discriminant(_5);\n        switchInt(move _9) -> [1: bb4, 0: bb11, otherwise: bb15];\n    }\n    bb4: {\n        _10 = move ((_5 as variant#1).0: &mut T);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut _1;\n        StorageLive(_13);\n        _13 = iter::traits::iterator::Iterator::partition_in_place::is_true::<T, P>(_3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _11 = <Self as iter::traits::double_ended::DoubleEndedIterator>::rfind::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2292:13: 2292:21}>(move _12, move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _14 = discriminant(_11);\n        switchInt(move _14) -> [1: bb7, 0: bb10, otherwise: bb15];\n    }\n    bb7: {\n        _15 = move ((_11 as variant#1).0: &mut T);\n        _16 = mem::swap::<T>(_10, _15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _17 = CheckedAdd(_4, 1_usize);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, 1_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _4 = move (_17.0: usize);\n        StorageDead(_11);\n        StorageDead(_5);\n        goto -> bb1;\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageDead(_5);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_5);\n        goto -> bb12;\n    }\n    bb12: {\n        _0 = _4;\n        StorageDead(_4);\n        drop(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        drop(_1) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        return;\n    }\n    bb15: {\n        unreachable;\n    }\n}\n",
  "doc": " Reorders the elements of this iterator *in-place* according to the given predicate,\n such that all those that return `true` precede all those that return `false`.\n Returns the number of `true` elements found.\n\n The relative order of partitioned items is not maintained.\n\n # Current implementation\n\n The current algorithm tries to find the first element for which the predicate evaluates\n to false and the last element for which it evaluates to true, and repeatedly swaps them.\n\n Time complexity: *O*(*n*)\n\n See also [`is_partitioned()`] and [`partition()`].\n\n [`is_partitioned()`]: Iterator::is_partitioned\n [`partition()`]: Iterator::partition\n\n # Examples\n\n ```\n #![feature(iter_partition_in_place)]\n\n let mut a = [1, 2, 3, 4, 5, 6, 7];\n\n // Partition in-place between evens and odds\n let i = a.iter_mut().partition_in_place(|n| n % 2 == 0);\n\n assert_eq!(i, 3);\n assert!(a[..i].iter().all(|n| n % 2 == 0)); // evens\n assert!(a[i..].iter().all(|n| n % 2 == 1)); // odds\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}