{
  "name": "intrinsics::unchecked_funnel_shr",
  "safe": false,
  "callees": {
    "intrinsics::fallback::FunnelShift::unchecked_funnel_shr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " See [`super::unchecked_funnel_shr`]; we just need the trait indirection to handle\n different types since calling intrinsics with generics doesn't work.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 13554,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs:2165:1: 2172:2",
  "src": "pub const unsafe fn unchecked_funnel_shr<T: [const] fallback::FunnelShift>(\n    a: T,\n    b: T,\n    shift: u32,\n) -> T {\n    // SAFETY: caller ensures that `shift` is in-range\n    unsafe { a.unchecked_funnel_shr(b, shift) }\n}",
  "mir": "fn intrinsics::unchecked_funnel_shr(_1: T, _2: T, _3: u32) -> T {\n    let mut _0: T;\n    debug a => _1;\n    debug b => _2;\n    debug shift => _3;\n    bb0: {\n        _0 = <T as intrinsics::fallback::FunnelShift>::unchecked_funnel_shr(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Funnel Shift right.\n\n Concatenates `a` and `b` (with `a` in the most significant half),\n creating an integer twice as wide. Then shift this integer right\n by `shift` (taken modulo the bit size of `T`), and extract the\n least significant half. If `a` and `b` are the same, this is equivalent\n to a rotate right operation.\n\n It is undefined behavior if `shift` is greater than or equal to the\n bit size of `T`.\n\n Safer versions of this intrinsic are available on the integer primitives\n via the `funnel_shr` method. For example, [`u32::funnel_shr`]\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}