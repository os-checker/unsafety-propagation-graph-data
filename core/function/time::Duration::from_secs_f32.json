{
  "name": "time::Duration::from_secs_f32",
  "safe": true,
  "callees": {
    "time::Duration::try_from_secs_f32": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The checked version of [`from_secs_f32`].\n\n [`from_secs_f32`]: Duration::from_secs_f32\n\n This constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n\n # Examples\n ```\n use std::time::Duration;\n\n let res = Duration::try_from_secs_f32(0.0);\n assert_eq!(res, Ok(Duration::new(0, 0)));\n let res = Duration::try_from_secs_f32(1e-20);\n assert_eq!(res, Ok(Duration::new(0, 0)));\n let res = Duration::try_from_secs_f32(4.2e-7);\n assert_eq!(res, Ok(Duration::new(0, 420)));\n let res = Duration::try_from_secs_f32(2.7);\n assert_eq!(res, Ok(Duration::new(2, 700_000_048)));\n let res = Duration::try_from_secs_f32(3e10);\n assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));\n // subnormal float:\n let res = Duration::try_from_secs_f32(f32::from_bits(1));\n assert_eq!(res, Ok(Duration::new(0, 0)));\n\n let res = Duration::try_from_secs_f32(-5.0);\n assert!(res.is_err());\n let res = Duration::try_from_secs_f32(f32::NAN);\n assert!(res.is_err());\n let res = Duration::try_from_secs_f32(2e19);\n assert!(res.is_err());\n\n // the conversion uses rounding with tie resolution to even\n let res = Duration::try_from_secs_f32(0.999e-9);\n assert_eq!(res, Ok(Duration::new(0, 1)));\n\n // this float represents exactly 976562.5e-9\n let val = f32::from_bits(0x3A80_0000);\n let res = Duration::try_from_secs_f32(val);\n assert_eq!(res, Ok(Duration::new(0, 976_562)));\n\n // this float represents exactly 2929687.5e-9\n let val = f32::from_bits(0x3B40_0000);\n let res = Duration::try_from_secs_f32(val);\n assert_eq!(res, Ok(Duration::new(0, 2_929_688)));\n\n // this float represents exactly 1.000_976_562_5\n let val = f32::from_bits(0x3F802000);\n let res = Duration::try_from_secs_f32(val);\n assert_eq!(res, Ok(Duration::new(1, 976_562)));\n\n // this float represents exactly 1.002_929_687_5\n let val = f32::from_bits(0x3F806000);\n let res = Duration::try_from_secs_f32(val);\n assert_eq!(res, Ok(Duration::new(1, 2_929_688)));\n ```\n",
      "adt": {
        "result::Result": "Constructor",
        "time::TryFromFloatSecsError": "Constructor",
        "time::Duration": "Constructor"
      }
    },
    "fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::rt::Argument": "Constructor"
      }
    },
    "fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "fmt::Arguments": "Constructor"
      }
    },
    "panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {
        "fmt::Arguments": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15430, kind: RigidTy(Adt(AdtDef(DefId { id: 29498, name: \"time::TryFromFloatSecsError\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 15379, kind: RigidTy(Adt(AdtDef(DefId { id: 29470, name: \"time::Duration\" }), GenericArgs([]))) })])"
    ],
    "time::TryFromFloatSecsError": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "fmt::rt::Argument": [
      "Plain"
    ],
    "time::Duration": [
      "Plain"
    ],
    "fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::time::Duration::from_secs_f32"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/time.rs:999:5: 1004:6",
  "src": "pub fn from_secs_f32(secs: f32) -> Duration {\n        match Duration::try_from_secs_f32(secs) {\n            Ok(v) => v,\n            Err(e) => panic!(\"{e}\"),\n        }\n    }",
  "mir": "fn time::Duration::from_secs_f32(_1: f32) -> time::Duration {\n    let mut _0: time::Duration;\n    let mut _2: result::Result<time::Duration, time::TryFromFloatSecsError>;\n    let mut _3: isize;\n    let  _4: time::TryFromFloatSecsError;\n    let  _5: !;\n    let mut _6: fmt::Arguments<'_>;\n    let  _7: (&time::TryFromFloatSecsError,);\n    let mut _8: &time::TryFromFloatSecsError;\n    let  _9: [fmt::rt::Argument<'_>; 1];\n    let mut _10: fmt::rt::Argument<'_>;\n    let mut _11: &[u8; 2];\n    let  _12: &[fmt::rt::Argument<'_>; 1];\n    let mut _13: &time::TryFromFloatSecsError;\n    debug secs => _1;\n    debug v => _0;\n    debug e => _4;\n    debug args => _7;\n    debug args => _9;\n    bb0: {\n        StorageLive(_2);\n        _2 = time::Duration::try_from_secs_f32(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = discriminant(_2);\n        switchInt(move _3) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_4);\n        _4 = move ((_2 as variant#1).0: time::TryFromFloatSecsError);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_4;\n        _7 = (move _8);\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _13 = (_7.0: &time::TryFromFloatSecsError);\n        _10 = fmt::rt::Argument::<'_>::new_display::<time::TryFromFloatSecsError>(_13) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        _0 = ((_2 as variant#0).0: time::Duration);\n        StorageDead(_2);\n        return;\n    }\n    bb5: {\n        _9 = [move _10];\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = b\"\\xc0\\x00\";\n        _12 = &_9;\n        _6 = fmt::Arguments::<'_>::new::<2, 1>(move _11, _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _5 = panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n}\n",
  "doc": " Creates a new `Duration` from the specified number of seconds represented\n as `f32`.\n\n # Panics\n This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n\n # Examples\n ```\n use std::time::Duration;\n\n let res = Duration::from_secs_f32(0.0);\n assert_eq!(res, Duration::new(0, 0));\n let res = Duration::from_secs_f32(1e-20);\n assert_eq!(res, Duration::new(0, 0));\n let res = Duration::from_secs_f32(4.2e-7);\n assert_eq!(res, Duration::new(0, 420));\n let res = Duration::from_secs_f32(2.7);\n assert_eq!(res, Duration::new(2, 700_000_048));\n let res = Duration::from_secs_f32(3e10);\n assert_eq!(res, Duration::new(30_000_001_024, 0));\n // subnormal float\n let res = Duration::from_secs_f32(f32::from_bits(1));\n assert_eq!(res, Duration::new(0, 0));\n // conversion uses rounding\n let res = Duration::from_secs_f32(0.999e-9);\n assert_eq!(res, Duration::new(0, 1));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}