{
  "name": "fmt::num::imp::<impl u64>::_fmt_inner",
  "safe": false,
  "callees": {
    "mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "hint::assert_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a *soundness* promise to the compiler that `cond` holds.\n\n This may allow the optimizer to simplify things, but it might also make the generated code\n slower. Either way, calling it will most likely make compilation take longer.\n\n You may know this from other places as\n [`llvm.assume`](https://llvm.org/docs/LangRef.html#llvm-assume-intrinsic) or, in C,\n [`__builtin_assume`](https://clang.llvm.org/docs/LanguageExtensions.html#builtin-assume).\n\n This promotes a correctness requirement to a soundness requirement. Don't do that without\n very good reason.\n\n # Usage\n\n This is a situational tool for micro-optimization, and is allowed to do nothing. Any use\n should come with a repeatable benchmark to show the value, with the expectation to drop it\n later should the optimizer get smarter and no longer need it.\n\n The more complicated the condition, the less likely this is to be useful. For example,\n `assert_unchecked(foo.is_sorted())` is a complex enough value that the compiler is unlikely\n to be able to take advantage of it.\n\n There's also no need to `assert_unchecked` basic properties of things.  For example, the\n compiler already knows the range of `count_ones`, so there is no benefit to\n `let n = u32::count_ones(x); assert_unchecked(n <= u32::BITS);`.\n\n `assert_unchecked` is logically equivalent to `if !cond { unreachable_unchecked(); }`. If\n ever you are tempted to write `assert_unchecked(false)`, you should instead use\n [`unreachable_unchecked()`] directly.\n\n # Safety\n\n `cond` must be `true`. It is immediate UB to call this with `false`.\n\n # Example\n\n ```\n use core::hint;\n\n /// # Safety\n ///\n /// `p` must be nonnull and valid\n pub unsafe fn next_value(p: *const i32) -> i32 {\n     // SAFETY: caller invariants guarantee that `p` is not null\n     unsafe { hint::assert_unchecked(!p.is_null()) }\n\n     if p.is_null() {\n         return -1;\n     } else {\n         // SAFETY: caller invariants guarantee that `p` is valid\n         unsafe { *p + 1 }\n     }\n }\n ```\n\n Without the `assert_unchecked`, the above function produces the following with optimizations\n enabled:\n\n ```asm\n next_value:\n         test    rdi, rdi\n         je      .LBB0_1\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n .LBB0_1:\n         mov     eax, -1\n         ret\n ```\n\n Adding the assertion allows the optimizer to remove the extra check:\n\n ```asm\n next_value:\n         mov     eax, dword ptr [rdi]\n         inc     eax\n         ret\n ```\n\n This example is quite unlike anything that would be used in the real world: it is redundant\n to put an assertion right next to code that checks the same thing, and dereferencing a\n pointer already has the builtin assumption that it is nonnull. However, it illustrates the\n kind of changes the optimizer can make even when the behavior is less obviously related.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the value of the `MaybeUninit<T>`.\n\n This overwrites any previous value without dropping it, so be careful\n not to use this twice unless you want to skip running the destructor.\n For your convenience, this also returns a mutable reference to the\n (now safely initialized) contents of `self`.\n\n As the content is stored inside a `ManuallyDrop`, the destructor is not\n run for the inner data if the MaybeUninit leaves scope without a call to\n [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n the mutable reference returned by this function needs to keep this in\n mind. The safety model of Rust regards leaks as safe, but they are\n usually still undesirable. This being said, the mutable reference\n behaves like any other mutable reference would, so assigning a new value\n to it will drop the old content.\n\n [`assume_init`]: Self::assume_init\n [`assume_init_drop`]: Self::assume_init_drop\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u8>>::uninit();\n\n {\n     let hello = x.write((&b\"Hello, world!\").to_vec());\n     // Setting hello does not leak prior allocations, but drops them\n     *hello = (&b\"Hello\").to_vec();\n     hello[0] = 'h' as u8;\n }\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n assert_eq!(b\"hello\", s.as_slice());\n ```\n\n This usage of the method causes a leak:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<String>::uninit();\n\n x.write(\"Hello\".to_string());\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n // This leaks the contained string:\n x.write(\"hello\".to_string());\n // x is initialized now:\n let s = unsafe { x.assume_init() };\n ```\n\n This method can be used to avoid unsafe in some cases. The example below\n shows a part of an implementation of a fixed sized arena that lends out\n pinned references.\n With `write`, we can avoid the need to write through a raw pointer:\n\n ```rust\n use core::pin::Pin;\n use core::mem::MaybeUninit;\n\n struct PinArena<T> {\n     memory: Box<[MaybeUninit<T>]>,\n     len: usize,\n }\n\n impl <T> PinArena<T> {\n     pub fn capacity(&self) -> usize {\n         self.memory.len()\n     }\n     pub fn push(&mut self, val: T) -> Pin<&mut T> {\n         if self.len >= self.capacity() {\n             panic!(\"Attempted to push to a full pin arena!\");\n         }\n         let ref_ = self.memory[self.len].write(val);\n         self.len += 1;\n         unsafe { Pin::new_unchecked(ref_) }\n     }\n }\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "result::Result": [
      "Plain"
    ],
    "mem::maybe_uninit::MaybeUninit": [
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::fmt::num::imp::<impl u64>::_fmt_inner"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/num.rs:190:13: 253:14",
  "src": "unsafe fn _fmt_inner(self, buf: &mut [MaybeUninit::<u8>]) -> usize {\n                // Count the number of bytes in buf that are not initialized.\n                let mut offset = buf.len();\n                // Consume the least-significant decimals from a working copy.\n                let mut remain = self;\n\n                // Format per four digits from the lookup table.\n                // Four digits need a 16-bit $Unsigned or wider.\n                while size_of::<Self>() > 1 && remain > 999.try_into().expect(\"branch is not hit for types that cannot fit 999 (u8)\") {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the while condition ensures at least 4 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 4) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 4;\n\n                    // pull two pairs\n                    let scale: Self = 1_00_00.try_into().expect(\"branch is not hit for types that cannot fit 1E4 (u8)\");\n                    let quad = remain % scale;\n                    remain /= scale;\n                    let pair1 = (quad / 100) as usize;\n                    let pair2 = (quad % 100) as usize;\n                    buf[offset + 0].write(DECIMAL_PAIRS[pair1 * 2 + 0]);\n                    buf[offset + 1].write(DECIMAL_PAIRS[pair1 * 2 + 1]);\n                    buf[offset + 2].write(DECIMAL_PAIRS[pair2 * 2 + 0]);\n                    buf[offset + 3].write(DECIMAL_PAIRS[pair2 * 2 + 1]);\n                }\n\n                // Format per two digits from the lookup table.\n                if remain > 9 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures at least 2 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 2) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 2;\n\n                    let pair = (remain % 100) as usize;\n                    remain /= 100;\n                    buf[offset + 0].write(DECIMAL_PAIRS[pair * 2 + 0]);\n                    buf[offset + 1].write(DECIMAL_PAIRS[pair * 2 + 1]);\n                }\n\n                // Format the last remaining digit, if any.\n                if remain != 0 || self == 0 {\n                    // SAFETY: All of the decimals fit in buf due to MAX_DEC_N\n                    // and the if condition ensures (at least) 1 more decimals.\n                    unsafe { core::hint::assert_unchecked(offset >= 1) }\n                    // SAFETY: The offset counts down from its initial buf.len()\n                    // without underflow due to the previous precondition.\n                    unsafe { core::hint::assert_unchecked(offset <= buf.len()) }\n                    offset -= 1;\n\n                    // Either the compiler sees that remain < 10, or it prevents\n                    // a boundary check up next.\n                    let last = (remain & 15) as usize;\n                    buf[offset].write(DECIMAL_PAIRS[last * 2 + 1]);\n                    // not used: remain = 0;\n                }\n\n                offset\n            }",
  "mir": "fn fmt::num::imp::<impl u64>::_fmt_inner(_1: u64, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>]) -> usize {\n    let mut _0: usize;\n    let mut _3: usize;\n    let mut _4: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _5: u64;\n    let mut _6: bool;\n    let mut _7: usize;\n    let mut _8: bool;\n    let mut _9: u64;\n    let mut _10: u64;\n    let mut _11: result::Result<u64, num::error::TryFromIntError>;\n    let mut _12: &str;\n    let  _13: ();\n    let mut _14: bool;\n    let mut _15: usize;\n    let  _16: ();\n    let mut _17: bool;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _21: (usize, bool);\n    let  _22: u64;\n    let mut _23: result::Result<u64, num::error::TryFromIntError>;\n    let mut _24: &str;\n    let  _25: u64;\n    let mut _26: u64;\n    let mut _27: bool;\n    let mut _28: bool;\n    let  _29: usize;\n    let mut _30: u64;\n    let mut _31: bool;\n    let  _32: usize;\n    let mut _33: u64;\n    let mut _34: bool;\n    let  _35: &mut u8;\n    let mut _36: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _37: usize;\n    let mut _38: usize;\n    let mut _39: (usize, bool);\n    let mut _40: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _41: usize;\n    let mut _42: bool;\n    let mut _43: u8;\n    let mut _44: &&[u8; 200];\n    let  _45: usize;\n    let mut _46: usize;\n    let mut _47: (usize, bool);\n    let mut _48: (usize, bool);\n    let mut _49: bool;\n    let  _50: &mut u8;\n    let mut _51: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _52: usize;\n    let mut _53: usize;\n    let mut _54: (usize, bool);\n    let mut _55: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _56: usize;\n    let mut _57: bool;\n    let mut _58: u8;\n    let mut _59: &&[u8; 200];\n    let  _60: usize;\n    let mut _61: usize;\n    let mut _62: (usize, bool);\n    let mut _63: (usize, bool);\n    let mut _64: bool;\n    let  _65: &mut u8;\n    let mut _66: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _67: usize;\n    let mut _68: usize;\n    let mut _69: (usize, bool);\n    let mut _70: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _71: usize;\n    let mut _72: bool;\n    let mut _73: u8;\n    let mut _74: &&[u8; 200];\n    let  _75: usize;\n    let mut _76: usize;\n    let mut _77: (usize, bool);\n    let mut _78: (usize, bool);\n    let mut _79: bool;\n    let  _80: &mut u8;\n    let mut _81: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _82: usize;\n    let mut _83: usize;\n    let mut _84: (usize, bool);\n    let mut _85: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _86: usize;\n    let mut _87: bool;\n    let mut _88: u8;\n    let mut _89: &&[u8; 200];\n    let  _90: usize;\n    let mut _91: usize;\n    let mut _92: (usize, bool);\n    let mut _93: (usize, bool);\n    let mut _94: bool;\n    let mut _95: bool;\n    let mut _96: u64;\n    let  _97: ();\n    let mut _98: bool;\n    let mut _99: usize;\n    let  _100: ();\n    let mut _101: bool;\n    let mut _102: usize;\n    let mut _103: usize;\n    let mut _104: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _105: (usize, bool);\n    let  _106: usize;\n    let mut _107: u64;\n    let mut _108: u64;\n    let mut _109: bool;\n    let mut _110: bool;\n    let  _111: &mut u8;\n    let mut _112: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _113: usize;\n    let mut _114: usize;\n    let mut _115: (usize, bool);\n    let mut _116: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _117: usize;\n    let mut _118: bool;\n    let mut _119: u8;\n    let mut _120: &&[u8; 200];\n    let  _121: usize;\n    let mut _122: usize;\n    let mut _123: (usize, bool);\n    let mut _124: (usize, bool);\n    let mut _125: bool;\n    let  _126: &mut u8;\n    let mut _127: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _128: usize;\n    let mut _129: usize;\n    let mut _130: (usize, bool);\n    let mut _131: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _132: usize;\n    let mut _133: bool;\n    let mut _134: u8;\n    let mut _135: &&[u8; 200];\n    let  _136: usize;\n    let mut _137: usize;\n    let mut _138: (usize, bool);\n    let mut _139: (usize, bool);\n    let mut _140: bool;\n    let mut _141: u64;\n    let  _142: ();\n    let mut _143: bool;\n    let mut _144: usize;\n    let  _145: ();\n    let mut _146: bool;\n    let mut _147: usize;\n    let mut _148: usize;\n    let mut _149: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _150: (usize, bool);\n    let  _151: usize;\n    let mut _152: u64;\n    let mut _153: u64;\n    let  _154: &mut u8;\n    let mut _155: &mut mem::maybe_uninit::MaybeUninit<u8>;\n    let  _156: usize;\n    let mut _157: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _158: usize;\n    let mut _159: bool;\n    let mut _160: u8;\n    let mut _161: &&[u8; 200];\n    let  _162: usize;\n    let mut _163: usize;\n    let mut _164: (usize, bool);\n    let mut _165: (usize, bool);\n    let mut _166: bool;\n    let mut _167: &[u8; 200];\n    let mut _168: &[u8; 200];\n    let mut _169: &[u8; 200];\n    let mut _170: &[u8; 200];\n    let mut _171: &[u8; 200];\n    let mut _172: &[u8; 200];\n    let mut _173: &[u8; 200];\n    debug self => _1;\n    debug buf => _2;\n    debug offset => _3;\n    debug remain => _5;\n    debug scale => _22;\n    debug quad => _25;\n    debug pair1 => _29;\n    debug pair2 => _32;\n    debug pair => _106;\n    debug last => _151;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_2);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = _1;\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = mem::size_of::<u64>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = Gt(move _7, 1_usize);\n        switchInt(move _6) -> [0: bb41, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = _5;\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = <i32 as convert::TryInto<u64>>::try_into(999_i32) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_12);\n        _12 = \"branch is not hit for types that cannot fit 999 (u8)\";\n        _10 = result::Result::<u64, num::error::TryFromIntError>::expect(move _11, move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _8 = Gt(move _9, move _10);\n        switchInt(move _8) -> [0: bb40, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _3;\n        _14 = Ge(move _15, 4_usize);\n        StorageDead(_15);\n        _13 = hint::assert_unchecked(move _14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _3;\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &(*_2);\n        _19 = PtrMetadata(move _20);\n        StorageDead(_20);\n        _17 = Le(move _18, move _19);\n        StorageDead(_19);\n        StorageDead(_18);\n        _16 = hint::assert_unchecked(move _17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        _21 = CheckedSub(_3, 4_usize);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 4_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _3 = move (_21.0: usize);\n        StorageLive(_23);\n        _23 = <i32 as convert::TryInto<u64>>::try_into(10000_i32) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_24);\n        _24 = \"branch is not hit for types that cannot fit 1E4 (u8)\";\n        _22 = result::Result::<u64, num::error::TryFromIntError>::expect(move _23, move _24) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_26);\n        _26 = _5;\n        _27 = Eq(_22, 0_u64);\n        assert(!move _27, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _26) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _25 = Rem(move _26, _22);\n        StorageDead(_26);\n        _28 = Eq(_22, 0_u64);\n        assert(!move _28, \"attempt to divide `{}` by zero\", _5) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _5 = Div(_5, _22);\n        StorageLive(_30);\n        _31 = Eq(100_u64, 0_u64);\n        assert(!move _31, \"attempt to divide `{}` by zero\", _25) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _30 = Div(_25, 100_u64);\n        _29 = move _30 as usize;\n        StorageDead(_30);\n        StorageLive(_33);\n        _34 = Eq(100_u64, 0_u64);\n        assert(!move _34, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _25) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _33 = Rem(_25, 100_u64);\n        _32 = move _33 as usize;\n        StorageDead(_33);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _3;\n        _39 = CheckedAdd(_38, 0_usize);\n        assert(!move (_39.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _38, 0_usize) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _37 = move (_39.0: usize);\n        StorageDead(_38);\n        _40 = &raw const (fake) (*_2);\n        _41 = PtrMetadata(move _40);\n        _42 = Lt(_37, _41);\n        assert(move _42, \"index out of bounds: the length is {} but the index is {}\", move _41, _37) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _36 = &mut (*_2)[_37];\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = {alloc1915: &&[u8; 200]};\n        StorageLive(_45);\n        StorageLive(_46);\n        _47 = CheckedMul(_29, 2_usize);\n        assert(!move (_47.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _29, 2_usize) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _46 = move (_47.0: usize);\n        _48 = CheckedAdd(_46, 0_usize);\n        assert(!move (_48.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _46, 0_usize) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _45 = move (_48.0: usize);\n        StorageDead(_46);\n        _49 = Lt(_45, 200_usize);\n        assert(move _49, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _45) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _167 = (*_44);\n        _43 = (*_167)[_45];\n        _35 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _36, move _43) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_43);\n        StorageDead(_36);\n        StorageDead(_45);\n        StorageDead(_44);\n        StorageDead(_37);\n        StorageDead(_35);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = _3;\n        _54 = CheckedAdd(_53, 1_usize);\n        assert(!move (_54.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _53, 1_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _52 = move (_54.0: usize);\n        StorageDead(_53);\n        _55 = &raw const (fake) (*_2);\n        _56 = PtrMetadata(move _55);\n        _57 = Lt(_52, _56);\n        assert(move _57, \"index out of bounds: the length is {} but the index is {}\", move _56, _52) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _51 = &mut (*_2)[_52];\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = {alloc1915: &&[u8; 200]};\n        StorageLive(_60);\n        StorageLive(_61);\n        _62 = CheckedMul(_29, 2_usize);\n        assert(!move (_62.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _29, 2_usize) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _61 = move (_62.0: usize);\n        _63 = CheckedAdd(_61, 1_usize);\n        assert(!move (_63.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _61, 1_usize) -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _60 = move (_63.0: usize);\n        StorageDead(_61);\n        _64 = Lt(_60, 200_usize);\n        assert(move _64, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _60) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _168 = (*_59);\n        _58 = (*_168)[_60];\n        _50 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _51, move _58) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_58);\n        StorageDead(_51);\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_52);\n        StorageDead(_50);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = _3;\n        _69 = CheckedAdd(_68, 2_usize);\n        assert(!move (_69.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _68, 2_usize) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _67 = move (_69.0: usize);\n        StorageDead(_68);\n        _70 = &raw const (fake) (*_2);\n        _71 = PtrMetadata(move _70);\n        _72 = Lt(_67, _71);\n        assert(move _72, \"index out of bounds: the length is {} but the index is {}\", move _71, _67) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _66 = &mut (*_2)[_67];\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = {alloc1915: &&[u8; 200]};\n        StorageLive(_75);\n        StorageLive(_76);\n        _77 = CheckedMul(_32, 2_usize);\n        assert(!move (_77.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _32, 2_usize) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _76 = move (_77.0: usize);\n        _78 = CheckedAdd(_76, 0_usize);\n        assert(!move (_78.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _76, 0_usize) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _75 = move (_78.0: usize);\n        StorageDead(_76);\n        _79 = Lt(_75, 200_usize);\n        assert(move _79, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _75) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _169 = (*_74);\n        _73 = (*_169)[_75];\n        _65 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _66, move _73) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_73);\n        StorageDead(_66);\n        StorageDead(_75);\n        StorageDead(_74);\n        StorageDead(_67);\n        StorageDead(_65);\n        StorageLive(_80);\n        StorageLive(_81);\n        StorageLive(_82);\n        StorageLive(_83);\n        _83 = _3;\n        _84 = CheckedAdd(_83, 3_usize);\n        assert(!move (_84.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _83, 3_usize) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _82 = move (_84.0: usize);\n        StorageDead(_83);\n        _85 = &raw const (fake) (*_2);\n        _86 = PtrMetadata(move _85);\n        _87 = Lt(_82, _86);\n        assert(move _87, \"index out of bounds: the length is {} but the index is {}\", move _86, _82) -> [success: bb35, unwind unreachable];\n    }\n    bb35: {\n        _81 = &mut (*_2)[_82];\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = {alloc1915: &&[u8; 200]};\n        StorageLive(_90);\n        StorageLive(_91);\n        _92 = CheckedMul(_32, 2_usize);\n        assert(!move (_92.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _32, 2_usize) -> [success: bb36, unwind unreachable];\n    }\n    bb36: {\n        _91 = move (_92.0: usize);\n        _93 = CheckedAdd(_91, 1_usize);\n        assert(!move (_93.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _91, 1_usize) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _90 = move (_93.0: usize);\n        StorageDead(_91);\n        _94 = Lt(_90, 200_usize);\n        assert(move _94, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _90) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        _170 = (*_89);\n        _88 = (*_170)[_90];\n        _80 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _81, move _88) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_88);\n        StorageDead(_81);\n        StorageDead(_90);\n        StorageDead(_89);\n        StorageDead(_82);\n        StorageDead(_80);\n        StorageDead(_8);\n        StorageDead(_6);\n        goto -> bb1;\n    }\n    bb40: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb42;\n    }\n    bb41: {\n        StorageDead(_7);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_95);\n        StorageLive(_96);\n        _96 = _5;\n        _95 = Gt(move _96, 9_u64);\n        switchInt(move _95) -> [0: bb44, otherwise: bb43];\n    }\n    bb43: {\n        StorageDead(_96);\n        StorageLive(_98);\n        StorageLive(_99);\n        _99 = _3;\n        _98 = Ge(move _99, 2_usize);\n        StorageDead(_99);\n        _97 = hint::assert_unchecked(move _98) -> [return: bb45, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_96);\n        goto -> bb62;\n    }\n    bb45: {\n        StorageDead(_98);\n        StorageLive(_101);\n        StorageLive(_102);\n        _102 = _3;\n        StorageLive(_103);\n        StorageLive(_104);\n        _104 = &(*_2);\n        _103 = PtrMetadata(move _104);\n        StorageDead(_104);\n        _101 = Le(move _102, move _103);\n        StorageDead(_103);\n        StorageDead(_102);\n        _100 = hint::assert_unchecked(move _101) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_101);\n        _105 = CheckedSub(_3, 2_usize);\n        assert(!move (_105.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 2_usize) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _3 = move (_105.0: usize);\n        StorageLive(_107);\n        StorageLive(_108);\n        _108 = _5;\n        _109 = Eq(100_u64, 0_u64);\n        assert(!move _109, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _108) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _107 = Rem(move _108, 100_u64);\n        StorageDead(_108);\n        _106 = move _107 as usize;\n        StorageDead(_107);\n        _110 = Eq(100_u64, 0_u64);\n        assert(!move _110, \"attempt to divide `{}` by zero\", _5) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _5 = Div(_5, 100_u64);\n        StorageLive(_111);\n        StorageLive(_112);\n        StorageLive(_113);\n        StorageLive(_114);\n        _114 = _3;\n        _115 = CheckedAdd(_114, 0_usize);\n        assert(!move (_115.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _114, 0_usize) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _113 = move (_115.0: usize);\n        StorageDead(_114);\n        _116 = &raw const (fake) (*_2);\n        _117 = PtrMetadata(move _116);\n        _118 = Lt(_113, _117);\n        assert(move _118, \"index out of bounds: the length is {} but the index is {}\", move _117, _113) -> [success: bb51, unwind unreachable];\n    }\n    bb51: {\n        _112 = &mut (*_2)[_113];\n        StorageLive(_119);\n        StorageLive(_120);\n        _120 = {alloc1915: &&[u8; 200]};\n        StorageLive(_121);\n        StorageLive(_122);\n        _123 = CheckedMul(_106, 2_usize);\n        assert(!move (_123.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _106, 2_usize) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        _122 = move (_123.0: usize);\n        _124 = CheckedAdd(_122, 0_usize);\n        assert(!move (_124.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _122, 0_usize) -> [success: bb53, unwind unreachable];\n    }\n    bb53: {\n        _121 = move (_124.0: usize);\n        StorageDead(_122);\n        _125 = Lt(_121, 200_usize);\n        assert(move _125, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _121) -> [success: bb54, unwind unreachable];\n    }\n    bb54: {\n        _171 = (*_120);\n        _119 = (*_171)[_121];\n        _111 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _112, move _119) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_119);\n        StorageDead(_112);\n        StorageDead(_121);\n        StorageDead(_120);\n        StorageDead(_113);\n        StorageDead(_111);\n        StorageLive(_126);\n        StorageLive(_127);\n        StorageLive(_128);\n        StorageLive(_129);\n        _129 = _3;\n        _130 = CheckedAdd(_129, 1_usize);\n        assert(!move (_130.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _129, 1_usize) -> [success: bb56, unwind unreachable];\n    }\n    bb56: {\n        _128 = move (_130.0: usize);\n        StorageDead(_129);\n        _131 = &raw const (fake) (*_2);\n        _132 = PtrMetadata(move _131);\n        _133 = Lt(_128, _132);\n        assert(move _133, \"index out of bounds: the length is {} but the index is {}\", move _132, _128) -> [success: bb57, unwind unreachable];\n    }\n    bb57: {\n        _127 = &mut (*_2)[_128];\n        StorageLive(_134);\n        StorageLive(_135);\n        _135 = {alloc1915: &&[u8; 200]};\n        StorageLive(_136);\n        StorageLive(_137);\n        _138 = CheckedMul(_106, 2_usize);\n        assert(!move (_138.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _106, 2_usize) -> [success: bb58, unwind unreachable];\n    }\n    bb58: {\n        _137 = move (_138.0: usize);\n        _139 = CheckedAdd(_137, 1_usize);\n        assert(!move (_139.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _137, 1_usize) -> [success: bb59, unwind unreachable];\n    }\n    bb59: {\n        _136 = move (_139.0: usize);\n        StorageDead(_137);\n        _140 = Lt(_136, 200_usize);\n        assert(move _140, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _136) -> [success: bb60, unwind unreachable];\n    }\n    bb60: {\n        _172 = (*_135);\n        _134 = (*_172)[_136];\n        _126 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _127, move _134) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_134);\n        StorageDead(_127);\n        StorageDead(_136);\n        StorageDead(_135);\n        StorageDead(_128);\n        StorageDead(_126);\n        goto -> bb62;\n    }\n    bb62: {\n        StorageDead(_95);\n        StorageLive(_141);\n        _141 = _5;\n        switchInt(move _141) -> [0: bb64, otherwise: bb63];\n    }\n    bb63: {\n        StorageDead(_141);\n        goto -> bb66;\n    }\n    bb64: {\n        StorageDead(_141);\n        switchInt(_1) -> [0: bb65, otherwise: bb75];\n    }\n    bb65: {\n        goto -> bb66;\n    }\n    bb66: {\n        StorageLive(_143);\n        StorageLive(_144);\n        _144 = _3;\n        _143 = Ge(move _144, 1_usize);\n        StorageDead(_144);\n        _142 = hint::assert_unchecked(move _143) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_143);\n        StorageLive(_146);\n        StorageLive(_147);\n        _147 = _3;\n        StorageLive(_148);\n        StorageLive(_149);\n        _149 = &(*_2);\n        _148 = PtrMetadata(move _149);\n        StorageDead(_149);\n        _146 = Le(move _147, move _148);\n        StorageDead(_148);\n        StorageDead(_147);\n        _145 = hint::assert_unchecked(move _146) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_146);\n        _150 = CheckedSub(_3, 1_usize);\n        assert(!move (_150.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 1_usize) -> [success: bb69, unwind unreachable];\n    }\n    bb69: {\n        _3 = move (_150.0: usize);\n        StorageLive(_152);\n        StorageLive(_153);\n        _153 = _5;\n        _152 = BitAnd(move _153, 15_u64);\n        StorageDead(_153);\n        _151 = move _152 as usize;\n        StorageDead(_152);\n        StorageLive(_154);\n        StorageLive(_155);\n        StorageLive(_156);\n        _156 = _3;\n        _157 = &raw const (fake) (*_2);\n        _158 = PtrMetadata(move _157);\n        _159 = Lt(_156, _158);\n        assert(move _159, \"index out of bounds: the length is {} but the index is {}\", move _158, _156) -> [success: bb70, unwind unreachable];\n    }\n    bb70: {\n        _155 = &mut (*_2)[_156];\n        StorageLive(_160);\n        StorageLive(_161);\n        _161 = {alloc1915: &&[u8; 200]};\n        StorageLive(_162);\n        StorageLive(_163);\n        _164 = CheckedMul(_151, 2_usize);\n        assert(!move (_164.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _151, 2_usize) -> [success: bb71, unwind unreachable];\n    }\n    bb71: {\n        _163 = move (_164.0: usize);\n        _165 = CheckedAdd(_163, 1_usize);\n        assert(!move (_165.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _163, 1_usize) -> [success: bb72, unwind unreachable];\n    }\n    bb72: {\n        _162 = move (_165.0: usize);\n        StorageDead(_163);\n        _166 = Lt(_162, 200_usize);\n        assert(move _166, \"index out of bounds: the length is {} but the index is {}\", 200_usize, _162) -> [success: bb73, unwind unreachable];\n    }\n    bb73: {\n        _173 = (*_161);\n        _160 = (*_173)[_162];\n        _154 = mem::maybe_uninit::MaybeUninit::<u8>::write(move _155, move _160) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_160);\n        StorageDead(_155);\n        StorageDead(_162);\n        StorageDead(_161);\n        StorageDead(_156);\n        StorageDead(_154);\n        goto -> bb76;\n    }\n    bb75: {\n        goto -> bb76;\n    }\n    bb76: {\n        _0 = _3;\n        StorageDead(_5);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}