{
  "name": "core_arch::x86::avx512fp16::_mm_fcmadd_sch",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::_mm_fcmadd_round_sch": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiply the lower complex number in a by the complex conjugate of the lower complex number in b,\n accumulate to the lower complex number in c, and store the result in the lower elements of dst,\n and copy the upper 6 packed elements from a to the upper elements of dst. Each complex number is\n composed of two adjacent half-precision (16-bit) floating-point elements, which defines the complex\n number `complex = vec.fp16[0] + i * vec.fp16[1]`, or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n Rounding is done according to the rounding parameter, which can be one of:\n\n * [`_MM_FROUND_TO_NEAREST_INT`] | [`_MM_FROUND_NO_EXC`] : round to nearest and suppress exceptions\n * [`_MM_FROUND_TO_NEG_INF`] | [`_MM_FROUND_NO_EXC`] : round down and suppress exceptions\n * [`_MM_FROUND_TO_POS_INF`] | [`_MM_FROUND_NO_EXC`] : round up and suppress exceptions\n * [`_MM_FROUND_TO_ZERO`] | [`_MM_FROUND_NO_EXC`] : truncate and suppress exceptions\n * [`_MM_FROUND_CUR_DIRECTION`] : use `MXCSR.RC` - see [`_MM_SET_ROUNDING_MODE`]\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_fcmadd_round_sch)\n",
      "adt": {
        "core_arch::x86::__m128h": "Constructor"
      }
    }
  },
  "adts": {
    "core_arch::x86::__m128h": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::avx512fp16::_mm_fcmadd_sch"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:4999:1: 5001:2",
  "src": "pub fn _mm_fcmadd_sch(a: __m128h, b: __m128h, c: __m128h) -> __m128h {\n    _mm_fcmadd_round_sch::<_MM_FROUND_CUR_DIRECTION>(a, b, c)\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm_fcmadd_sch(_1: core_arch::x86::__m128h, _2: core_arch::x86::__m128h, _3: core_arch::x86::__m128h) -> core_arch::x86::__m128h {\n    let mut _0: core_arch::x86::__m128h;\n    debug a => _1;\n    debug b => _2;\n    debug c => _3;\n    bb0: {\n        _0 = core_arch::x86::avx512fp16::_mm_fcmadd_round_sch::<4>(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Multiply the lower complex number in a by the complex conjugate of the lower complex number in b,\n accumulate to the lower complex number in c, and store the result in the lower elements of dst,\n and copy the upper 6 packed elements from a to the upper elements of dst. Each complex number is\n composed of two adjacent half-precision (16-bit) floating-point elements, which defines the complex\n number `complex = vec.fp16[0] + i * vec.fp16[1]`, or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_fcmadd_sch)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}