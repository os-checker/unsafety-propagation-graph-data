{
  "name": "mem::uninitialized",
  "safe": false,
  "callees": {
    "intrinsics::assert_mem_uninitialized_valid": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A guard for `std::mem::uninitialized`. This will statically either panic, or do nothing. It does\n not *guarantee* to ever panic, and should only be called if an assertion failure will imply\n language UB in the following code.\n\n This intrinsic does not have a stable counterpart.\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "Constructor"
      }
    },
    "mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<Vec<u32>>`.\n // This is okay because we initialized it.\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n x_vec.push(3);\n assert_eq!(x_vec.len(), 4);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {
        "mem::maybe_uninit::MaybeUninit": "MutableAsArgument"
      }
    },
    "ptr::mut_ptr::<impl *mut T>::write_bytes": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n bytes of memory starting at `self` to `val`.\n\n See [`ptr::write_bytes`] for safety concerns and examples.\n\n [`ptr::write_bytes`]: crate::ptr::write_bytes()\n",
      "adt": {}
    },
    "mem::maybe_uninit::MaybeUninit::<T>::assume_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the value from the `MaybeUninit<T>` container. This is a great way\n to ensure that the data will get dropped, because the resulting `T` is\n subject to the usual drop handling.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes immediate undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n [inv]: #initialization-invariant\n\n On top of that, remember that most types have additional invariants beyond merely\n being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n is considered initialized (under the current implementation; this does not constitute\n a stable guarantee) because the only requirement the compiler knows about it\n is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n *immediate* undefined behavior, but will cause undefined behavior with most\n safe operations (including dropping it).\n\n [`Vec<T>`]: ../../std/vec/struct.Vec.html\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<bool>::uninit();\n x.write(true);\n let x_init = unsafe { x.assume_init() };\n assert_eq!(x_init, true);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_init = unsafe { x.assume_init() };\n // `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mem::maybe_uninit::MaybeUninit": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::mem::uninitialized"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:710:1: 724:2",
  "src": "pub unsafe fn uninitialized<T>() -> T {\n    // SAFETY: the caller must guarantee that an uninitialized value is valid for `T`.\n    unsafe {\n        intrinsics::assert_mem_uninitialized_valid::<T>();\n        let mut val = MaybeUninit::<T>::uninit();\n\n        // Fill memory with 0x01, as an imperfect mitigation for old code that uses this function on\n        // bool, nonnull, and noundef types. But don't do this if we actively want to detect UB.\n        if !cfg!(any(miri, sanitize = \"memory\")) {\n            val.as_mut_ptr().write_bytes(0x01, 1);\n        }\n\n        val.assume_init()\n    }\n}",
  "mir": "fn mem::uninitialized() -> T {\n    let mut _0: T;\n    let  _1: ();\n    let mut _2: mem::maybe_uninit::MaybeUninit<T>;\n    let  _3: ();\n    let mut _4: *mut T;\n    let mut _5: &mut mem::maybe_uninit::MaybeUninit<T>;\n    let mut _6: mem::maybe_uninit::MaybeUninit<T>;\n    debug val => _2;\n    bb0: {\n        _1 = intrinsics::assert_mem_uninitialized_valid::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        _2 = mem::maybe_uninit::MaybeUninit::<T>::uninit() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _2;\n        _4 = mem::maybe_uninit::MaybeUninit::<T>::as_mut_ptr(move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        _3 = ptr::mut_ptr::<impl *mut T>::write_bytes(move _4, 1_u8, 1_usize) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = move _2;\n        _0 = mem::maybe_uninit::MaybeUninit::<T>::assume_init(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Bypasses Rust's normal memory-initialization checks by pretending to\n produce a value of type `T`, while doing nothing at all.\n\n **This function is deprecated.** Use [`MaybeUninit<T>`] instead.\n It also might be slower than using `MaybeUninit<T>` due to mitigations that were put in place to\n limit the potential harm caused by incorrect use of this function in legacy code.\n\n The reason for deprecation is that the function basically cannot be used\n correctly: it has the same effect as [`MaybeUninit::uninit().assume_init()`][uninit].\n As the [`assume_init` documentation][assume_init] explains,\n [the Rust compiler assumes][inv] that values are properly initialized.\n\n Truly uninitialized memory like what gets returned here\n is special in that the compiler knows that it does not have a fixed value.\n This makes it undefined behavior to have uninitialized data in a variable even\n if that variable has an integer type.\n\n Therefore, it is immediate undefined behavior to call this function on nearly all types,\n including integer types and arrays of integer types, and even if the result is unused.\n\n [uninit]: MaybeUninit::uninit\n [assume_init]: MaybeUninit::assume_init\n [inv]: MaybeUninit#initialization-invariant\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}