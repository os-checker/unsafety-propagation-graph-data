{
  "name": "core_arch::x86::avx512fp16::_mm_fcmadd_pch",
  "safe": false,
  "callees": {
    "core_arch::x86::avx512fp16::_mm_mask3_fcmadd_pch": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Multiply packed complex numbers in a by the complex conjugates of packed complex numbers in b, accumulate\n to the corresponding complex numbers in c, and store the results in dst using writemask k (the element is\n copied from c when the corresponding mask bit is not set). Each complex number is composed of two adjacent\n half-precision (16-bit) floating-point elements, which defines the complex number `complex = vec.fp16[0] + i * vec.fp16[1]`,\n or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask3_fcmadd_pch)\n",
      "adt": {
        "core_arch::x86::__m128h": "Constructor"
      }
    }
  },
  "adts": {
    "core_arch::x86::__m128h": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::core_arch::x86::avx512fp16::_mm_fcmadd_pch"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/../../stdarch/crates/core_arch/src/x86/avx512fp16.rs:4654:1: 4656:2",
  "src": "pub fn _mm_fcmadd_pch(a: __m128h, b: __m128h, c: __m128h) -> __m128h {\n    _mm_mask3_fcmadd_pch(a, b, c, 0xff)\n}",
  "mir": "fn core_arch::x86::avx512fp16::_mm_fcmadd_pch(_1: core_arch::x86::__m128h, _2: core_arch::x86::__m128h, _3: core_arch::x86::__m128h) -> core_arch::x86::__m128h {\n    let mut _0: core_arch::x86::__m128h;\n    debug a => _1;\n    debug b => _2;\n    debug c => _3;\n    bb0: {\n        _0 = core_arch::x86::avx512fp16::_mm_mask3_fcmadd_pch(_1, _2, _3, u8::MAX) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Multiply packed complex numbers in a by the complex conjugates of packed complex numbers in b, accumulate\n to the corresponding complex numbers in c, and store the results in dst. Each complex number is composed\n of two adjacent half-precision (16-bit) floating-point elements, which defines the complex number\n `complex = vec.fp16[0] + i * vec.fp16[1]`, or the complex conjugate `conjugate = vec.fp16[0] - i * vec.fp16[1]`.\n\n [Intel's documentation](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_fcmadd_pch)\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}