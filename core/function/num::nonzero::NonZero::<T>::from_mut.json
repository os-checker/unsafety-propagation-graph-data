{
  "name": "num::nonzero::NonZero::<T>::from_mut",
  "safe": true,
  "callees": {
    "ptr::from_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a mutable reference to a raw pointer.\n\n For `r: &mut T`, `from_mut(r)` is equivalent to `r as *mut T` (except for the caveat noted\n below), but is a bit safer since it will never silently change type or mutability, in particular\n if the code is refactored.\n\n The caller must ensure that the pointee outlives the pointer this function returns, or else it\n will end up dangling.\n\n ## Interaction with lifetime extension\n\n Note that this has subtle interactions with the rules for lifetime extension of temporaries in\n tail expressions. This code is valid, albeit in a non-obvious way:\n ```rust\n # type T = i32;\n # fn foo() -> T { 42 }\n // The temporary holding the return value of `foo` has its lifetime extended,\n // because the surrounding expression involves no function call.\n let p = &mut foo() as *mut T;\n unsafe { p.write(T::default()) };\n ```\n Naively replacing the cast with `from_mut` is not valid:\n ```rust,no_run\n # use std::ptr;\n # type T = i32;\n # fn foo() -> T { 42 }\n // The temporary holding the return value of `foo` does *not* have its lifetime extended,\n // because the surrounding expression involves a function call.\n let p = ptr::from_mut(&mut foo());\n unsafe { p.write(T::default()) }; // UB! Writing to a dangling pointer ⚠️\n ```\n The recommended way to write this code is to avoid relying on lifetime extension\n when raw pointers are involved:\n ```rust\n # use std::ptr;\n # type T = i32;\n # fn foo() -> T { 42 }\n let mut x = foo();\n let p = ptr::from_mut(&mut x);\n unsafe { p.write(T::default()) };\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {
        "option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "option::Option": [
      "MutRef",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "core::num::nonzero::NonZero::<T>::from_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/nonzero.rs:440:5: 446:6",
  "src": "pub fn from_mut(n: &mut T) -> Option<&mut Self> {\n        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has\n        //         the same layout and size as `T`, with `0` representing `None`.\n        let opt_n = unsafe { &mut *(ptr::from_mut(n).cast::<Option<Self>>()) };\n\n        opt_n.as_mut()\n    }",
  "mir": "fn num::nonzero::NonZero::<T>::from_mut(_1: &mut T) -> option::Option<&mut num::nonzero::NonZero<T>> {\n    let mut _0: option::Option<&mut num::nonzero::NonZero<T>>;\n    let mut _2: &mut option::Option<num::nonzero::NonZero<T>>;\n    let mut _3: *mut option::Option<num::nonzero::NonZero<T>>;\n    let mut _4: *mut T;\n    debug n => _1;\n    debug opt_n => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ptr::from_mut::<T>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = ptr::mut_ptr::<impl *mut T>::cast::<option::Option<num::nonzero::NonZero<T>>>(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _2 = &mut (*_3);\n        _0 = option::Option::<num::nonzero::NonZero<T>>::as_mut(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Converts a reference to a non-zero mutable reference\n if the referenced value is not zero.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}