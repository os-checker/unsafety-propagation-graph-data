{
  "name": "slice::<impl [T]>::split_at_mut_unchecked",
  "safe": false,
  "callees": {
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "slice::<impl [T]>::split_at_mut_unchecked::precondition_check": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "slice::raw::from_raw_parts_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n mutable slice is returned.\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `data` must be non-null, [valid] for both reads and writes for `len * size_of::<T>()` many bytes,\n   and it must be properly aligned. This means in particular:\n\n     * The entire memory range of this slice must be contained within a single allocation!\n       Slices can never span across multiple allocations.\n     * `data` must be non-null and aligned even for zero-length slices or slices of ZSTs. One\n       reason for this is that enum layout optimizations may rely on references\n       (including slices of any length) being aligned and non-null to distinguish\n       them from other data. You can obtain a pointer that is usable as `data`\n       for zero-length slices using [`NonNull::dangling()`].\n\n * `data` must point to `len` consecutive properly initialized values of type `T`.\n\n * The memory referenced by the returned slice must not be accessed through any other pointer\n   (not derived from the return value) for the duration of lifetime `'a`.\n   Both read and write accesses are forbidden.\n\n * The total size `len * size_of::<T>()` of the slice must be no larger than `isize::MAX`,\n   and adding that size to `data` must not \"wrap around\" the address space.\n   See the safety documentation of [`pointer::offset`].\n\n [valid]: ptr#safety\n [`NonNull::dangling()`]: ptr::NonNull::dangling\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "core::slice::<impl [T]>::split_at_mut_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:2089:5: 2109:6",
  "src": "pub const unsafe fn split_at_mut_unchecked(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n        let len = self.len();\n        let ptr = self.as_mut_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_mut_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`.\n        //\n        // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n        // is fine.\n        unsafe {\n            (\n                from_raw_parts_mut(ptr, mid),\n                from_raw_parts_mut(ptr.add(mid), unchecked_sub(len, mid)),\n            )\n        }\n    }",
  "mir": "fn slice::<impl [T]>::split_at_mut_unchecked(_1: &mut [T], _2: usize) -> (&mut [T], &mut [T]) {\n    let mut _0: (&mut [T], &mut [T]);\n    let  _3: usize;\n    let mut _4: &[T];\n    let  _5: *mut T;\n    let mut _6: bool;\n    let  _7: ();\n    let mut _8: &mut [T];\n    let mut _9: &mut [T];\n    let mut _10: *mut T;\n    let mut _11: usize;\n    debug self => _1;\n    debug mid => _2;\n    debug len => _3;\n    debug ptr => _5;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = PtrMetadata(move _4);\n        StorageDead(_4);\n        _5 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = RuntimeChecks(UbChecks)() \" \";\n        switchInt(move _6) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        _7 = slice::<impl [T]>::split_at_mut_unchecked::precondition_check(_2, _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        StorageDead(_6);\n        _8 = slice::raw::from_raw_parts_mut::<'_, T>(_5, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_10);\n        _10 = ptr::mut_ptr::<impl *mut T>::add(_5, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_11);\n        _11 = SubUnchecked(_3, _2);\n        _9 = slice::raw::from_raw_parts_mut::<'_, T>(move _10, move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _0 = (_8, _9);\n        return;\n    }\n}\n",
  "doc": " Divides one mutable slice into two at an index, without doing bounds checking.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n For a safe alternative see [`split_at_mut`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used. The caller has to ensure that\n `0 <= mid <= self.len()`.\n\n [`split_at_mut`]: slice::split_at_mut\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let mut v = [1, 0, 3, 0, 5, 6];\n // scoped to restrict the lifetime of the borrows\n unsafe {\n     let (left, right) = v.split_at_mut_unchecked(2);\n     assert_eq!(left, [1, 0]);\n     assert_eq!(right, [3, 0, 5, 6]);\n     left[1] = 2;\n     right[1] = 4;\n }\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}