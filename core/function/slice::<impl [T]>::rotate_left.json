{
  "name": "slice::<impl [T]>::rotate_left",
  "safe": true,
  "callees": {
    "panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "slice::rotate::ptr_rotate": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Rotates the range `[mid-left, mid+right)` such that the element at `mid` becomes the first\n element. Equivalently, rotates the range `left` elements to the left or `right` elements to the\n right.\n\n # Safety\n\n The specified range must be valid for reading and writing.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1289,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs:3668:5: 3678:6",
  "src": "pub const fn rotate_left(&mut self, mid: usize) {\n        assert!(mid <= self.len());\n        let k = self.len() - mid;\n        let p = self.as_mut_ptr();\n\n        // SAFETY: The range `[p.add(mid) - mid, p.add(mid) + k)` is trivially\n        // valid for reading and writing, as required by `ptr_rotate`.\n        unsafe {\n            rotate::ptr_rotate(mid, p.add(mid), k);\n        }\n    }",
  "mir": "fn slice::<impl [T]>::rotate_left(_1: &mut [T], _2: usize) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &[T];\n    let mut _6: !;\n    let  _7: usize;\n    let mut _8: usize;\n    let mut _9: &[T];\n    let mut _10: (usize, bool);\n    let  _11: *mut T;\n    let  _12: ();\n    let mut _13: *mut T;\n    debug self => _1;\n    debug mid => _2;\n    debug k => _7;\n    debug p => _11;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = PtrMetadata(move _5);\n        StorageDead(_5);\n        _3 = Le(_2, move _4);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_1);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        _10 = CheckedSub(_8, _2);\n        assert(!move (_10.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _8, _2) -> [success: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = panicking::panic(\"assertion failed: mid <= self.len()\") -> unwind unreachable;\n    }\n    bb3: {\n        _7 = move (_10.0: usize);\n        StorageDead(_8);\n        _11 = slice::<impl [T]>::as_mut_ptr(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_13);\n        _13 = ptr::mut_ptr::<impl *mut T>::add(_11, _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = slice::rotate::ptr_rotate::<T>(_2, move _13, _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " Rotates the slice in-place such that the first `mid` elements of the\n slice move to the end while the last `self.len() - mid` elements move to\n the front.\n\n After calling `rotate_left`, the element previously at index `mid` will\n become the first element in the slice.\n\n # Panics\n\n This function will panic if `mid` is greater than the length of the\n slice. Note that `mid == self.len()` does _not_ panic and is a no-op\n rotation.\n\n # Complexity\n\n Takes linear (in `self.len()`) time.\n\n # Examples\n\n ```\n let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n a.rotate_left(2);\n assert_eq!(a, ['c', 'd', 'e', 'f', 'a', 'b']);\n ```\n\n Rotating a subslice:\n\n ```\n let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n a[1..5].rotate_left(1);\n assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}