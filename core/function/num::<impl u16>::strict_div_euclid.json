{
  "name": "num::<impl u16>::strict_div_euclid",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": 3526,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs:1296:9: 1298:10",
  "src": "pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }",
  "mir": "fn num::<impl u16>::strict_div_euclid(_1: u16, _2: u16) -> u16 {\n    let mut _0: u16;\n    let mut _3: bool;\n    debug self => _1;\n    debug rhs => _2;\n    bb0: {\n        _3 = Eq(_2, 0_u16);\n        assert(!move _3, \"attempt to divide `{}` by zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Div(_1, _2);\n        return;\n    }\n}\n",
  "doc": " Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n\n Strict division on unsigned types is just normal division. There's no\n way overflow could ever happen. This function exists so that all\n operations are accounted for in the strict operations. Since, for the\n positive integers, all common definitions of division are equal, this\n is exactly equal to `self.strict_div(rhs)`.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n The following panics because of division by zero:\n\n ```should_panic\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}