{
  "name": "iter::traits::iterator::Iterator::intersperse_with",
  "safe": true,
  "callees": {
    "iter::adapters::intersperse::IntersperseWith::<I, G>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "iter::adapters::intersperse::IntersperseWith": "Constructor"
      }
    }
  },
  "adts": {
    "iter::adapters::intersperse::IntersperseWith": [
      "Plain"
    ]
  },
  "path": {
    "type": "External",
    "path": "iter::traits::iterator::Iterator::intersperse_with"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:714:5: 720:6",
  "src": "fn intersperse_with<G>(self, separator: G) -> IntersperseWith<Self, G>\n    where\n        Self: Sized,\n        G: FnMut() -> Self::Item,\n    {\n        IntersperseWith::new(self, separator)\n    }",
  "mir": "fn iter::traits::iterator::Iterator::intersperse_with(_1: Self, _2: G) -> iter::adapters::intersperse::IntersperseWith<Self, G> {\n    let mut _0: iter::adapters::intersperse::IntersperseWith<Self, G>;\n    debug self => _1;\n    debug separator => _2;\n    bb0: {\n        _0 = iter::adapters::intersperse::IntersperseWith::<Self, G>::new(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Creates a new iterator which places an item generated by `separator`\n between adjacent items of the original iterator.\n\n The closure will be called exactly once each time an item is placed\n between two adjacent items from the underlying iterator; specifically,\n the closure is not called if the underlying iterator yields less than\n two items and after the last item is yielded.\n\n If the iterator's item implements [`Clone`], it may be easier to use\n [`intersperse`].\n\n # Examples\n\n Basic usage:\n\n ```\n #![feature(iter_intersperse)]\n\n #[derive(PartialEq, Debug)]\n struct NotClone(usize);\n\n let v = [NotClone(0), NotClone(1), NotClone(2)];\n let mut it = v.into_iter().intersperse_with(|| NotClone(99));\n\n assert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.\n assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.\n assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n assert_eq!(it.next(), Some(NotClone(2)));  // The last element from `v`.\n assert_eq!(it.next(), None);               // The iterator is finished.\n ```\n\n `intersperse_with` can be used in situations where the separator needs\n to be computed:\n ```\n #![feature(iter_intersperse)]\n\n let src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();\n\n // The closure mutably borrows its context to generate an item.\n let mut happy_emojis = [\" â¤ï¸ \", \" ğŸ˜€ \"].into_iter();\n let separator = || happy_emojis.next().unwrap_or(\" ğŸ¦€ \");\n\n let result = src.intersperse_with(separator).collect::<String>();\n assert_eq!(result, \"Hello â¤ï¸ to ğŸ˜€ all ğŸ¦€ people ğŸ¦€ !!\");\n ```\n [`Clone`]: crate::clone::Clone\n [`intersperse`]: Iterator::intersperse\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}