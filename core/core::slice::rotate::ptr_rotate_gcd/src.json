{
  "name": "core::slice::rotate::ptr_rotate_gcd",
  "span": "$library/core/src/slice/rotate.rs:121:1: 121:74",
  "src": "const unsafe fn ptr_rotate_gcd<T>(left: usize, mid: *mut T, right: usize) {\n    // Algorithm 2\n    // Microbenchmarks indicate that the average performance for random shifts is better all\n    // the way until about `left + right == 32`, but the worst case performance breaks even\n    // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n    // `usize`s, this algorithm also outperforms other algorithms.\n    // SAFETY: callers must ensure `mid - left` is valid for reading and writing.\n    let x = unsafe { mid.sub(left) };\n    // beginning of first round\n    // SAFETY: see previous comment.\n    let mut tmp: T = unsafe { x.read() };\n    let mut i = right;\n    // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n    // but it is faster to do one loop which calculates the gcd as a side effect, then\n    // doing the rest of the chunk\n    let mut gcd = right;\n    // benchmarks reveal that it is faster to swap temporaries all the way through instead\n    // of reading one temporary once, copying backwards, and then writing that temporary at\n    // the very end. This is possibly due to the fact that swapping or replacing temporaries\n    // uses only one memory address in the loop instead of needing to manage two.\n    loop {\n        // [long-safety-expl]\n        // SAFETY: callers must ensure `[left, left+mid+right)` are all valid for reading and\n        // writing.\n        //\n        // - `i` start with `right` so `mid-left <= x+i = x+right = mid-left+right < mid+right`\n        // - `i <= left+right-1` is always true\n        //   - if `i < left`, `right` is added so `i < left+right` and on the next\n        //     iteration `left` is removed from `i` so it doesn't go further\n        //   - if `i >= left`, `left` is removed immediately and so it doesn't go further.\n        // - overflows cannot happen for `i` since the function's safety contract ask for\n        //   `mid+right-1 = x+left+right` to be valid for writing\n        // - underflows cannot happen because `i` must be bigger or equal to `left` for\n        //   a subtraction of `left` to happen.\n        //\n        // So `x+i` is valid for reading and writing if the caller respected the contract\n        tmp = unsafe { x.add(i).replace(tmp) };\n        // instead of incrementing `i` and then checking if it is outside the bounds, we\n        // check if `i` will go outside the bounds on the next increment. This prevents\n        // any wrapping of pointers or `usize`.\n        if i >= left {\n            i -= left;\n            if i == 0 {\n                // end of first round\n                // SAFETY: tmp has been read from a valid source and x is valid for writing\n                // according to the caller.\n                unsafe { x.write(tmp) };\n                break;\n            }\n            // this conditional must be here if `left + right >= 15`\n            if i < gcd {\n                gcd = i;\n            }\n        } else {\n            i += right;\n        }\n    }\n    // finish the chunk with more rounds\n    // FIXME(const-hack): Use `for start in 1..gcd` when available in const\n    let mut start = 1;\n    while start < gcd {\n        // SAFETY: `gcd` is at most equal to `right` so all values in `1..gcd` are valid for\n        // reading and writing as per the function's safety contract, see [long-safety-expl]\n        // above\n        tmp = unsafe { x.add(start).read() };\n        // [safety-expl-addition]\n        //\n        // Here `start < gcd` so `start < right` so `i < right+right`: `right` being the\n        // greatest common divisor of `(left+right, right)` means that `left = right` so\n        // `i < left+right` so `x+i = mid-left+i` is always valid for reading and writing\n        // according to the function's safety contract.\n        i = start + right;\n        loop {\n            // SAFETY: see [long-safety-expl] and [safety-expl-addition]\n            tmp = unsafe { x.add(i).replace(tmp) };\n            if i >= left {\n                i -= left;\n                if i == start {\n                    // SAFETY: see [long-safety-expl] and [safety-expl-addition]\n                    unsafe { x.add(start).write(tmp) };\n                    break;\n                }\n            } else {\n                i += right;\n            }\n        }\n\n        start += 1;\n    }\n}"
}