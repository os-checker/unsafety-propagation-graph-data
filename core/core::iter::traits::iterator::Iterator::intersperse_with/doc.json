{
  "name": "core::iter::traits::iterator::Iterator::intersperse_with",
  "span": "$library/core/src/iter/traits/iterator.rs:714:5: 717:34",
  "doc": " Creates a new iterator which places an item generated by `separator`\n between adjacent items of the original iterator.\n\n The closure will be called exactly once each time an item is placed\n between two adjacent items from the underlying iterator; specifically,\n the closure is not called if the underlying iterator yields less than\n two items and after the last item is yielded.\n\n If the iterator's item implements [`Clone`], it may be easier to use\n [`intersperse`].\n\n # Examples\n\n Basic usage:\n\n ```\n #![feature(iter_intersperse)]\n\n #[derive(PartialEq, Debug)]\n struct NotClone(usize);\n\n let v = [NotClone(0), NotClone(1), NotClone(2)];\n let mut it = v.into_iter().intersperse_with(|| NotClone(99));\n\n assert_eq!(it.next(), Some(NotClone(0)));  // The first element from `v`.\n assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n assert_eq!(it.next(), Some(NotClone(1)));  // The next element from `v`.\n assert_eq!(it.next(), Some(NotClone(99))); // The separator.\n assert_eq!(it.next(), Some(NotClone(2)));  // The last element from `v`.\n assert_eq!(it.next(), None);               // The iterator is finished.\n ```\n\n `intersperse_with` can be used in situations where the separator needs\n to be computed:\n ```\n #![feature(iter_intersperse)]\n\n let src = [\"Hello\", \"to\", \"all\", \"people\", \"!!\"].iter().copied();\n\n // The closure mutably borrows its context to generate an item.\n let mut happy_emojis = [\" â¤ï¸ \", \" ğŸ˜€ \"].into_iter();\n let separator = || happy_emojis.next().unwrap_or(\" ğŸ¦€ \");\n\n let result = src.intersperse_with(separator).collect::<String>();\n assert_eq!(result, \"Hello â¤ï¸ to ğŸ˜€ all ğŸ¦€ people ğŸ¦€ !!\");\n ```\n [`Clone`]: crate::clone::Clone\n [`intersperse`]: Iterator::intersperse\n"
}