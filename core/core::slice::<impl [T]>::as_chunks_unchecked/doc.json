{
  "name": "core::slice::<impl [T]>::as_chunks_unchecked",
  "span": "$library/core/src/slice/mod.rs:1337:5: 1337:80",
  "doc": " Splits the slice into a slice of `N`-element arrays,\n assuming that there's no remainder.\n\n This is the inverse operation to [`as_flattened`].\n\n [`as_flattened`]: slice::as_flattened\n\n As this is `unsafe`, consider whether you could use [`as_chunks`] or\n [`as_rchunks`] instead, perhaps via something like\n `if let (chunks, []) = slice.as_chunks()` or\n `let (chunks, []) = slice.as_chunks() else { unreachable!() };`.\n\n [`as_chunks`]: slice::as_chunks\n [`as_rchunks`]: slice::as_rchunks\n\n # Safety\n\n This may only be called when\n - The slice splits exactly into `N`-element chunks (aka `self.len() % N == 0`).\n - `N != 0`.\n\n # Examples\n\n ```\n let slice: &[char] = &['l', 'o', 'r', 'e', 'm', '!'];\n let chunks: &[[char; 1]] =\n     // SAFETY: 1-element chunks never have remainder\n     unsafe { slice.as_chunks_unchecked() };\n assert_eq!(chunks, &[['l'], ['o'], ['r'], ['e'], ['m'], ['!']]);\n let chunks: &[[char; 3]] =\n     // SAFETY: The slice length (6) is a multiple of 3\n     unsafe { slice.as_chunks_unchecked() };\n assert_eq!(chunks, &[['l', 'o', 'r'], ['e', 'm', '!']]);\n\n // These would be unsound:\n // let chunks: &[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5\n // let chunks: &[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed\n ```\n"
}