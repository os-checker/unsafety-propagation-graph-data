{
  "name": "core::mem::maybe_uninit::MaybeUninit::<T>::zeroed",
  "span": "$library/core/src/mem/maybe_uninit.rs:470:5: 470:44",
  "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n filled with `0` bytes. It depends on `T` whether that already makes for\n proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n be null.\n\n Note that if `T` has padding bytes, those bytes are *not* preserved when the\n `MaybeUninit<T>` value is returned from this function, so those bytes will *not* be zeroed.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n Correct usage of this function: initializing a struct with zero, where all\n fields of the struct can hold the bit-pattern 0 as a valid value.\n\n ```rust\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<(u8, bool)>::zeroed();\n let x = unsafe { x.assume_init() };\n assert_eq!(x, (0, false));\n ```\n\n This can be used in const contexts, such as to indicate the end of static arrays for\n plugin registration.\n\n *Incorrect* usage of this function: calling `x.zeroed().assume_init()`\n when `0` is not a valid bit-pattern for the type:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n enum NotZero { One = 1, Two = 2 }\n\n let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n let x = unsafe { x.assume_init() };\n // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n // This is undefined behavior. ⚠️\n ```\n"
}