{
  "name": "core::iter::traits::iterator::Iterator::try_find",
  "span": "$library/core/src/iter/traits/iterator.rs:2966:5: 2972:71",
  "doc": " Applies function to the elements of iterator and returns\n the first true result or the first error.\n\n The return type of this method depends on the return type of the closure.\n If you return `Result<bool, E>` from the closure, you'll get a `Result<Option<Self::Item>, E>`.\n If you return `Option<bool>` from the closure, you'll get an `Option<Option<Self::Item>>`.\n\n # Examples\n\n ```\n #![feature(try_find)]\n\n let a = [\"1\", \"2\", \"lol\", \"NaN\", \"5\"];\n\n let is_my_num = |s: &str, search: i32| -> Result<bool, std::num::ParseIntError> {\n     Ok(s.parse::<i32>()? == search)\n };\n\n let result = a.into_iter().try_find(|&s| is_my_num(s, 2));\n assert_eq!(result, Ok(Some(\"2\")));\n\n let result = a.into_iter().try_find(|&s| is_my_num(s, 5));\n assert!(result.is_err());\n ```\n\n This also supports other types which implement [`Try`], not just [`Result`].\n\n ```\n #![feature(try_find)]\n\n use std::num::NonZero;\n\n let a = [3, 5, 7, 4, 9, 0, 11u32];\n let result = a.into_iter().try_find(|&x| NonZero::new(x).map(|y| y.is_power_of_two()));\n assert_eq!(result, Some(Some(4)));\n let result = a.into_iter().take(3).try_find(|&x| NonZero::new(x).map(|y| y.is_power_of_two()));\n assert_eq!(result, Some(None));\n let result = a.into_iter().rev().try_find(|&x| NonZero::new(x).map(|y| y.is_power_of_two()));\n assert_eq!(result, None);\n ```\n"
}