{
  "name": "core::slice::<impl [T]>::element_offset",
  "span": "$library/core/src/slice/mod.rs:4836:5: 4836:63",
  "doc": " Returns the index that an element reference points to.\n\n Returns `None` if `element` does not point to the start of an element within the slice.\n\n This method is useful for extending slice iterators like [`slice::split`].\n\n Note that this uses pointer arithmetic and **does not compare elements**.\n To find the index of an element via comparison, use\n [`.iter().position()`](crate::iter::Iterator::position) instead.\n\n # Panics\n Panics if `T` is zero-sized.\n\n # Examples\n Basic usage:\n ```\n #![feature(substr_range)]\n\n let nums: &[u32] = &[1, 7, 1, 1];\n let num = &nums[2];\n\n assert_eq!(num, &1);\n assert_eq!(nums.element_offset(num), Some(2));\n ```\n Returning `None` with an unaligned element:\n ```\n #![feature(substr_range)]\n\n let arr: &[[u32; 2]] = &[[0, 1], [2, 3]];\n let flat_arr: &[u32] = arr.as_flattened();\n\n let ok_elm: &[u32; 2] = flat_arr[0..2].try_into().unwrap();\n let weird_elm: &[u32; 2] = flat_arr[1..3].try_into().unwrap();\n\n assert_eq!(ok_elm, &[0, 1]);\n assert_eq!(weird_elm, &[1, 2]);\n\n assert_eq!(arr.element_offset(ok_elm), Some(0)); // Points to element 0\n assert_eq!(arr.element_offset(weird_elm), None); // Points between element 0 and 1\n ```\n"
}