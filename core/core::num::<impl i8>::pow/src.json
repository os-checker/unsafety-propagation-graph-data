{
  "name": "core::num::<impl i8>::pow",
  "span": "$library/core/src/num/int_macros.rs:3043:9: 3043:53",
  "src": "pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }"
}