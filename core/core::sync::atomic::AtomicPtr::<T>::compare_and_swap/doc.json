{
  "name": "core::sync::atomic::AtomicPtr::<T>::compare_and_swap",
  "span": "$library/core/src/sync/atomic.rs:1852:5: 1852:92",
  "doc": " Stores a value into the pointer if the current value is the same as the `current` value.\n\n The return value is always the previous value. If it is equal to `current`, then the value\n was updated.\n\n `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n ordering of this operation. Notice that even when using [`AcqRel`], the operation\n might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n happens, and using [`Release`] makes the load part [`Relaxed`].\n\n **Note:** This method is only available on platforms that support atomic\n operations on pointers.\n\n # Migrating to `compare_exchange` and `compare_exchange_weak`\n\n `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n memory orderings:\n\n Original | Success | Failure\n -------- | ------- | -------\n Relaxed  | Relaxed | Relaxed\n Acquire  | Acquire | Acquire\n Release  | Release | Relaxed\n AcqRel   | AcqRel  | Acquire\n SeqCst   | SeqCst  | SeqCst\n\n `compare_and_swap` and `compare_exchange` also differ in their return type. You can use\n `compare_exchange(...).unwrap_or_else(|x| x)` to recover the behavior of `compare_and_swap`,\n but in most cases it is more idiomatic to check whether the return value is `Ok` or `Err`\n rather than to infer success vs failure based on the value that was read.\n\n During migration, consider whether it makes sense to use `compare_exchange_weak` instead.\n `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n which allows the compiler to generate better assembly code when the compare and swap\n is used in a loop.\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let ptr = &mut 5;\n let some_ptr = AtomicPtr::new(ptr);\n\n let other_ptr = &mut 10;\n\n let value = some_ptr.compare_and_swap(ptr, other_ptr, Ordering::Relaxed);\n ```\n"
}