{
  "name": "core::cell::Ref::<'b, T>::try_map",
  "span": "$library/core/src/cell.rs:1722:5: 1725:39",
  "doc": " Tries to makes a new `Ref` for a component of the borrowed data.\n On failure, the original guard is returned alongside with the error\n returned by the closure.\n\n The `RefCell` is already immutably borrowed, so this cannot fail.\n\n This is an associated function that needs to be used as\n `Ref::try_map(...)`. A method would interfere with methods of the same\n name on the contents of a `RefCell` used through `Deref`.\n\n # Examples\n\n ```\n #![feature(refcell_try_map)]\n use std::cell::{RefCell, Ref};\n use std::str::{from_utf8, Utf8Error};\n\n let c = RefCell::new(vec![0xF0, 0x9F, 0xA6 ,0x80]);\n let b1: Ref<'_, Vec<u8>> = c.borrow();\n let b2: Result<Ref<'_, str>, _> = Ref::try_map(b1, |v| from_utf8(v));\n assert_eq!(&*b2.unwrap(), \"ðŸ¦€\");\n\n let c = RefCell::new(vec![0xF0, 0x9F, 0xA6]);\n let b1: Ref<'_, Vec<u8>> = c.borrow();\n let b2: Result<_, (Ref<'_, Vec<u8>>, Utf8Error)> = Ref::try_map(b1, |v| from_utf8(v));\n let (b3, e) = b2.unwrap_err();\n assert_eq!(*b3, vec![0xF0, 0x9F, 0xA6]);\n assert_eq!(e.valid_up_to(), 0);\n ```\n"
}