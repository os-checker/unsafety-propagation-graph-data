{
  "name": "core::num::flt2dec::to_exact_exp_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:510:1: 521:75",
  "src": "pub fn to_exact_exp_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    ndigits: usize,\n    upper: bool,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 6);\n    assert!(ndigits > 0);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            if ndigits > 1 {\n                // [0.][0000][e0]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(ndigits - 1));\n                parts[2] = MaybeUninit::new(Part::Copy(if upper { b\"E0\" } else { b\"e0\" }));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..3`.\n                    parts: unsafe { parts[..3].assume_init_ref() },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" }));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { parts[..1].assume_init_ref() },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let maxlen = estimate_max_buf_len(decoded.exp);\n            assert!(buf.len() >= ndigits || buf.len() >= maxlen);\n\n            let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n            let (buf, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n            Formatted { sign, parts: digits_to_exp_str(buf, exp, ndigits, upper, parts) }\n        }\n    }\n}"
}