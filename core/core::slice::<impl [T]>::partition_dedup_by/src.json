{
  "name": "core::slice::<impl [T]>::partition_dedup_by",
  "span": "$library/core/src/slice/mod.rs:3500:5: 3502:42",
  "src": "pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n    where\n        F: FnMut(&mut T, &mut T) -> bool,\n    {\n        // Although we have a mutable reference to `self`, we cannot make\n        // *arbitrary* changes. The `same_bucket` calls could panic, so we\n        // must ensure that the slice is in a valid state at all times.\n        //\n        // The way that we handle this is by using swaps; we iterate\n        // over all the elements, swapping as we go so that at the end\n        // the elements we wish to keep are in the front, and those we\n        // wish to reject are at the back. We can then split the slice.\n        // This operation is still `O(n)`.\n        //\n        // Example: We start in this state, where `r` represents \"next\n        // read\" and `w` represents \"next_write\".\n        //\n        //           r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //           w\n        //\n        // Comparing self[r] against self[w-1], this is not a duplicate, so\n        // we swap self[r] and self[w] (no effect as r==w) and then increment both\n        // r and w, leaving us with:\n        //\n        //               r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //               w\n        //\n        // Comparing self[r] against self[w-1], this value is a duplicate,\n        // so we increment `r` but leave everything else unchanged:\n        //\n        //                   r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //               w\n        //\n        // Comparing self[r] against self[w-1], this is not a duplicate,\n        // so swap self[r] and self[w] and advance r and w:\n        //\n        //                       r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 2 | 1 | 3 | 3 |\n        //     +---+---+---+---+---+---+\n        //                   w\n        //\n        // Not a duplicate, repeat:\n        //\n        //                           r\n        //     +---+---+---+---+---+---+\n        //     | 0 | 1 | 2 | 3 | 1 | 3 |\n        //     +---+---+---+---+---+---+\n        //                       w\n        //\n        // Duplicate, advance r. End of slice. Split at w.\n\n        let len = self.len();\n        if len <= 1 {\n            return (self, &mut []);\n        }\n\n        let ptr = self.as_mut_ptr();\n        let mut next_read: usize = 1;\n        let mut next_write: usize = 1;\n\n        // SAFETY: the `while` condition guarantees `next_read` and `next_write`\n        // are less than `len`, thus are inside `self`. `prev_ptr_write` points to\n        // one element before `ptr_write`, but `next_write` starts at 1, so\n        // `prev_ptr_write` is never less than 0 and is inside the slice.\n        // This fulfils the requirements for dereferencing `ptr_read`, `prev_ptr_write`\n        // and `ptr_write`, and for using `ptr.add(next_read)`, `ptr.add(next_write - 1)`\n        // and `prev_ptr_write.offset(1)`.\n        //\n        // `next_write` is also incremented at most once per loop at most meaning\n        // no element is skipped when it may need to be swapped.\n        //\n        // `ptr_read` and `prev_ptr_write` never point to the same element. This\n        // is required for `&mut *ptr_read`, `&mut *prev_ptr_write` to be safe.\n        // The explanation is simply that `next_read >= next_write` is always true,\n        // thus `next_read > next_write - 1` is too.\n        unsafe {\n            // Avoid bounds checks by using raw pointers.\n            while next_read < len {\n                let ptr_read = ptr.add(next_read);\n                let prev_ptr_write = ptr.add(next_write - 1);\n                if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n                    if next_read != next_write {\n                        let ptr_write = prev_ptr_write.add(1);\n                        mem::swap(&mut *ptr_read, &mut *ptr_write);\n                    }\n                    next_write += 1;\n                }\n                next_read += 1;\n            }\n        }\n\n        self.split_at_mut(next_write)\n    }"
}