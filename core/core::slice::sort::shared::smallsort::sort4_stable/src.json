{
  "name": "core::slice::sort::shared::smallsort::sort4_stable",
  "span": "$library/core/src/slice/sort/shared/smallsort.rs:612:1: 616:2",
  "src": "pub unsafe fn sort4_stable<T, F: FnMut(&T, &T) -> bool>(\n    v_base: *const T,\n    dst: *mut T,\n    is_less: &mut F,\n) {\n    // By limiting select to picking pointers, we are guaranteed good cmov code-gen\n    // regardless of type T's size. Further this only does 5 instead of 6\n    // comparisons compared to a stable transposition 4 element sorting-network,\n    // and always copies each element exactly once.\n\n    // SAFETY: all pointers have offset at most 3 from v_base and dst, and are\n    // thus in-bounds by the precondition.\n    unsafe {\n        // Stably create two pairs a <= b and c <= d.\n        let c1 = is_less(&*v_base.add(1), &*v_base);\n        let c2 = is_less(&*v_base.add(3), &*v_base.add(2));\n        let a = v_base.add(c1 as usize);\n        let b = v_base.add(!c1 as usize);\n        let c = v_base.add(2 + c2 as usize);\n        let d = v_base.add(2 + (!c2 as usize));\n\n        // Compare (a, c) and (b, d) to identify max/min. We're left with two\n        // unknown elements, but because we are a stable sort we must know which\n        // one is leftmost and which one is rightmost.\n        // c3, c4 | min max unknown_left unknown_right\n        //  0,  0 |  a   d    b         c\n        //  0,  1 |  a   b    c         d\n        //  1,  0 |  c   d    a         b\n        //  1,  1 |  c   b    a         d\n        let c3 = is_less(&*c, &*a);\n        let c4 = is_less(&*d, &*b);\n        let min = hint::select_unpredictable(c3, c, a);\n        let max = hint::select_unpredictable(c4, b, d);\n        let unknown_left = hint::select_unpredictable(c3, a, hint::select_unpredictable(c4, c, b));\n        let unknown_right = hint::select_unpredictable(c4, d, hint::select_unpredictable(c3, b, c));\n\n        // Sort the last two unknown elements.\n        let c5 = is_less(&*unknown_right, &*unknown_left);\n        let lo = hint::select_unpredictable(c5, unknown_right, unknown_left);\n        let hi = hint::select_unpredictable(c5, unknown_left, unknown_right);\n\n        ptr::copy_nonoverlapping(min, dst, 1);\n        ptr::copy_nonoverlapping(lo, dst.add(1), 1);\n        ptr::copy_nonoverlapping(hi, dst.add(2), 1);\n        ptr::copy_nonoverlapping(max, dst.add(3), 1);\n    }\n}"
}