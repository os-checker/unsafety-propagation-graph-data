{
  "name": "core::<slice::ascii::EscapeAscii<'a> as fmt::Display>::fmt",
  "span": "$library/core/src/slice/ascii.rs:286:5: 286:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // disassemble iterator, including front/back parts of flatmap in case it has been partially consumed\n        let (front, slice, back) = self.clone().inner.into_parts();\n        let front = front.unwrap_or(EscapeDefault::empty());\n        let mut bytes = slice.unwrap_or_default().as_slice();\n        let back = back.unwrap_or(EscapeDefault::empty());\n\n        // usually empty, so the formatter won't have to do any work\n        for byte in front {\n            f.write_char(byte as char)?;\n        }\n\n        fn needs_escape(b: u8) -> bool {\n            b > 0x7E || b < 0x20 || b == b'\\\\' || b == b'\\'' || b == b'\"'\n        }\n\n        while bytes.len() > 0 {\n            // fast path for the printable, non-escaped subset of ascii\n            let prefix = bytes.iter().take_while(|&&b| !needs_escape(b)).count();\n            // SAFETY: prefix length was derived by counting bytes in the same splice, so it's in-bounds\n            let (prefix, remainder) = unsafe { bytes.split_at_unchecked(prefix) };\n            // SAFETY: prefix is a valid utf8 sequence, as it's a subset of ASCII\n            let prefix = unsafe { crate::str::from_utf8_unchecked(prefix) };\n\n            f.write_str(prefix)?; // the fast part\n\n            bytes = remainder;\n\n            if let Some(&b) = bytes.first() {\n                // guaranteed to be non-empty, better to write it as a str\n                fmt::Display::fmt(&ascii::escape_default(b), f)?;\n                bytes = &bytes[1..];\n            }\n        }\n\n        // also usually empty\n        for byte in back {\n            f.write_char(byte as char)?;\n        }\n        Ok(())\n    }"
}