{
  "name": "core::num::flt2dec::strategy::grisu::format_exact_opt::possibly_round",
  "span": "$library/core/src/num/flt2dec/strategy/grisu.rs:648:5: 656:30",
  "mir": "fn core::num::flt2dec::strategy::grisu::format_exact_opt::possibly_round(_1: &mut [mem::maybe_uninit::MaybeUninit<u8>], _2: usize, _3: i16, _4: i16, _5: u64, _6: u64, _7: u64) -> option::Option<(&[u8], i16)> {\n    let mut _0: option::Option<(&[u8], i16)>;\n    let mut _8: bool;\n    let mut _9: !;\n    let mut _10: bool;\n    let mut _11: bool;\n    let mut _12: u64;\n    let mut _13: (u64, bool);\n    let mut _14: bool;\n    let mut _15: u64;\n    let mut _16: (u64, bool);\n    let mut _17: bool;\n    let mut _18: u64;\n    let mut _19: u64;\n    let mut _20: (u64, bool);\n    let mut _21: (u64, bool);\n    let mut _22: u64;\n    let mut _23: (u64, bool);\n    let mut _24: (&[u8], i16);\n    let  _25: &[u8];\n    let  _26: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _27: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _28: ops::range::RangeTo<usize>;\n    let mut _29: usize;\n    let mut _30: i16;\n    let mut _31: bool;\n    let mut _32: bool;\n    let mut _33: u64;\n    let mut _34: u64;\n    let mut _35: (u64, bool);\n    let mut _36: (u64, bool);\n    let mut _37: u64;\n    let mut _38: (u64, bool);\n    let mut _39: option::Option<u8>;\n    let mut _40: &mut [u8];\n    let mut _41: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _42: ops::range::RangeTo<usize>;\n    let mut _43: usize;\n    let mut _44: isize;\n    let  _45: u8;\n    let mut _46: (i16, bool);\n    let mut _47: bool;\n    let mut _48: i16;\n    let mut _49: bool;\n    let mut _50: usize;\n    let mut _51: usize;\n    let mut _52: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _53: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _54: usize;\n    let mut _55: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _56: usize;\n    let mut _57: bool;\n    let mut _58: (usize, bool);\n    let mut _59: (&[u8], i16);\n    let  _60: &[u8];\n    let  _61: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _62: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _63: ops::range::RangeTo<usize>;\n    let mut _64: usize;\n    let mut _65: i16;\n    debug buf => _1;\n    debug len => _2;\n    debug exp => _3;\n    debug limit => _4;\n    debug remainder => _5;\n    debug ten_kappa => _6;\n    debug ulp => _7;\n    debug c => _45;\n    bb0: {\n        StorageLive(_8);\n        _8 = Lt(_5, _6);\n        switchInt(move _8) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = Ge(_7, _6);\n        switchInt(move _10) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        _9 = panicking::panic(\"assertion failed: remainder < ten_kappa\") -> unwind unreachable;\n    }\n    bb3: {\n        _0 = option::Option::None;\n        StorageDead(_10);\n        goto -> bb44;\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _13 = CheckedSub(_6, _7);\n        assert(!move (_13.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, _7) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = move (_13.0: u64);\n        _11 = Le(move _12, _7);\n        switchInt(move _11) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_12);\n        _0 = option::Option::None;\n        StorageDead(_11);\n        goto -> bb44;\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = CheckedSub(_6, _5);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, _5) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = move (_16.0: u64);\n        _14 = Gt(move _15, _5);\n        switchInt(move _14) -> [0: bb17, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = CheckedMul(2_u64, _5);\n        assert(!move (_20.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u64, _5) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _19 = move (_20.0: u64);\n        _21 = CheckedSub(_6, _19);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, move _19) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = move (_21.0: u64);\n        StorageDead(_19);\n        StorageLive(_22);\n        _23 = CheckedMul(2_u64, _7);\n        assert(!move (_23.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_u64, _7) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _22 = move (_23.0: u64);\n        _17 = Ge(move _18, move _22);\n        switchInt(move _17) -> [0: bb16, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageLive(_24);\n        StorageLive(_27);\n        _27 = &(*_1);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = _2;\n        _28 = RangeTo(move _29);\n        StorageDead(_29);\n        _26 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _27, move _28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_28);\n        StorageDead(_27);\n        _25 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_30);\n        _30 = _3;\n        _24 = (_25, move _30);\n        StorageDead(_30);\n        _0 = option::Option::Some(move _24);\n        StorageDead(_24);\n        StorageDead(_17);\n        StorageDead(_14);\n        goto -> bb44;\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_18);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_15);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_17);\n        StorageDead(_14);\n        StorageLive(_31);\n        _31 = Gt(_5, _7);\n        switchInt(move _31) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _35 = CheckedSub(_5, _7);\n        assert(!move (_35.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _7) -> [success: bb21, unwind unreachable];\n    }\n    bb20: {\n        goto -> bb43;\n    }\n    bb21: {\n        _34 = move (_35.0: u64);\n        _36 = CheckedSub(_6, _34);\n        assert(!move (_36.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, move _34) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _33 = move (_36.0: u64);\n        StorageDead(_34);\n        StorageLive(_37);\n        _38 = CheckedSub(_5, _7);\n        assert(!move (_38.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _5, _7) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _37 = move (_38.0: u64);\n        _32 = Le(move _33, move _37);\n        switchInt(move _32) -> [0: bb42, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_37);\n        StorageDead(_33);\n        StorageLive(_39);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = _2;\n        _42 = RangeTo(move _43);\n        StorageDead(_43);\n        _41 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_1, move _42) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_42);\n        _40 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_41) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _39 = num::flt2dec::round_up(_40) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _44 = discriminant(_39);\n        switchInt(move _44) -> [1: bb28, 0: bb38, otherwise: bb45];\n    }\n    bb28: {\n        _45 = ((_39 as variant#1).0: u8);\n        _46 = CheckedAdd(_3, 1_i16);\n        assert(!move (_46.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, 1_i16) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _3 = move (_46.0: i16);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _3;\n        _47 = Gt(move _48, _4);\n        switchInt(move _47) -> [0: bb36, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = _2;\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &(*_1);\n        _51 = PtrMetadata(move _52);\n        StorageDead(_52);\n        _49 = Lt(move _50, move _51);\n        switchInt(move _49) -> [0: bb35, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_51);\n        StorageDead(_50);\n        StorageLive(_53);\n        _53 = mem::maybe_uninit::MaybeUninit::<u8>::new(_45) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_54);\n        _54 = _2;\n        _55 = &raw const (fake) (*_1);\n        _56 = PtrMetadata(move _55);\n        _57 = Lt(_54, _56);\n        assert(move _57, \"index out of bounds: the length is {} but the index is {}\", move _56, _54) -> [success: bb33, unwind unreachable];\n    }\n    bb33: {\n        (*_1)[_54] = move _53;\n        StorageDead(_53);\n        StorageDead(_54);\n        _58 = CheckedAdd(_2, 1_usize);\n        assert(!move (_58.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, 1_usize) -> [success: bb34, unwind unreachable];\n    }\n    bb34: {\n        _2 = move (_58.0: usize);\n        goto -> bb37;\n    }\n    bb35: {\n        StorageDead(_51);\n        StorageDead(_50);\n        goto -> bb37;\n    }\n    bb36: {\n        StorageDead(_48);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_49);\n        StorageDead(_47);\n        StorageDead(_39);\n        goto -> bb39;\n    }\n    bb38: {\n        StorageDead(_39);\n        goto -> bb39;\n    }\n    bb39: {\n        StorageLive(_59);\n        StorageLive(_62);\n        _62 = &(*_1);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _2;\n        _63 = RangeTo(move _64);\n        StorageDead(_64);\n        _61 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _62, move _63) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_63);\n        StorageDead(_62);\n        _60 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_61) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageLive(_65);\n        _65 = _3;\n        _59 = (_60, move _65);\n        StorageDead(_65);\n        _0 = option::Option::Some(move _59);\n        StorageDead(_59);\n        StorageDead(_32);\n        StorageDead(_31);\n        goto -> bb44;\n    }\n    bb42: {\n        StorageDead(_37);\n        StorageDead(_33);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _0 = option::Option::None;\n        goto -> bb44;\n    }\n    bb44: {\n        return;\n    }\n    bb45: {\n        unreachable;\n    }\n}\n"
}