{
  "name": "core::slice::<impl [T]>::swap_with_slice",
  "span": "$library/core/src/slice/mod.rs:3992:5: 3992:61",
  "doc": " Swaps all elements in `self` with those in `other`.\n\n The length of `other` must be the same as `self`.\n\n # Panics\n\n This function will panic if the two slices have different lengths.\n\n # Example\n\n Swapping two elements across slices:\n\n ```\n let mut slice1 = [0, 0];\n let mut slice2 = [1, 2, 3, 4];\n\n slice1.swap_with_slice(&mut slice2[2..]);\n\n assert_eq!(slice1, [3, 4]);\n assert_eq!(slice2, [1, 2, 0, 0]);\n ```\n\n Rust enforces that there can only be one mutable reference to a\n particular piece of data in a particular scope. Because of this,\n attempting to use `swap_with_slice` on a single slice will result in\n a compile failure:\n\n ```compile_fail\n let mut slice = [1, 2, 3, 4, 5];\n slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n ```\n\n To work around this, we can use [`split_at_mut`] to create two distinct\n mutable sub-slices from a slice:\n\n ```\n let mut slice = [1, 2, 3, 4, 5];\n\n {\n     let (left, right) = slice.split_at_mut(2);\n     left.swap_with_slice(&mut right[1..]);\n }\n\n assert_eq!(slice, [4, 5, 3, 1, 2]);\n ```\n\n [`split_at_mut`]: slice::split_at_mut\n"
}