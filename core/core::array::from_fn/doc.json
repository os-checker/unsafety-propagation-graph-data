{
  "name": "core::array::from_fn",
  "span": "$library/core/src/array/mod.rs:109:1: 111:53",
  "doc": " Creates an array where each element is produced by calling `f` with\n that element's index while walking forward through the array.\n\n This is essentially the same as writing\n ```text\n [f(0), f(1), f(2), â€¦, f(N - 2), f(N - 1)]\n ```\n and is similar to `(0..i).map(f)`, just for arrays not iterators.\n\n If `N == 0`, this produces an empty array without ever calling `f`.\n\n # Example\n\n ```rust\n // type inference is helping us here, the way `from_fn` knows how many\n // elements to produce is the length of array down there: only arrays of\n // equal lengths can be compared, so the const generic parameter `N` is\n // inferred to be 5, thus creating array of 5 elements.\n\n let array = core::array::from_fn(|i| i);\n // indexes are:    0  1  2  3  4\n assert_eq!(array, [0, 1, 2, 3, 4]);\n\n let array2: [usize; 8] = core::array::from_fn(|i| i * 2);\n // indexes are:     0  1  2  3  4  5   6   7\n assert_eq!(array2, [0, 2, 4, 6, 8, 10, 12, 14]);\n\n let bool_arr = core::array::from_fn::<_, 5, _>(|i| i % 2 == 0);\n // indexes are:       0     1      2     3      4\n assert_eq!(bool_arr, [true, false, true, false, true]);\n ```\n\n You can also capture things, for example to create an array full of clones\n where you can't just use `[item; N]` because it's not `Copy`:\n ```\n # // TBH `array::repeat` would be better for this, but it's not stable yet.\n let my_string = String::from(\"Hello\");\n let clones: [String; 42] = std::array::from_fn(|_| my_string.clone());\n assert!(clones.iter().all(|x| *x == my_string));\n ```\n\n The array is generated in ascending index order, starting from the front\n and going towards the back, so you can use closures with mutable state:\n ```\n let mut state = 1;\n let a = std::array::from_fn(|_| { let x = state; state *= 2; x });\n assert_eq!(a, [1, 2, 4, 8, 16, 32]);\n ```\n"
}