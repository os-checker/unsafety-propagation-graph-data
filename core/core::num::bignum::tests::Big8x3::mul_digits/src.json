{
  "name": "core::num::bignum::tests::Big8x3::mul_digits",
  "span": "$library/core/src/num/bignum.rs:281:13: 281:80",
  "src": "pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n                // the internal routine. works best when aa.len() <= bb.len().\n                fn mul_inner(ret: &mut [$ty; $n], aa: &[$ty], bb: &[$ty]) -> usize {\n                    use crate::num::bignum::FullOps;\n\n                    let mut retsz = 0;\n                    for (i, &a) in aa.iter().enumerate() {\n                        if a == 0 {\n                            continue;\n                        }\n                        let mut sz = bb.len();\n                        let mut carry = 0;\n                        for (j, &b) in bb.iter().enumerate() {\n                            let (c, v) = a.full_mul_add(b, ret[i + j], carry);\n                            ret[i + j] = v;\n                            carry = c;\n                        }\n                        if carry > 0 {\n                            ret[i + sz] = carry;\n                            sz += 1;\n                        }\n                        if retsz < i + sz {\n                            retsz = i + sz;\n                        }\n                    }\n                    retsz\n                }\n\n                let mut ret = [0; $n];\n                let retsz = if self.size < other.len() {\n                    mul_inner(&mut ret, &self.digits(), other)\n                } else {\n                    mul_inner(&mut ret, other, &self.digits())\n                };\n                self.base = ret;\n                self.size = retsz;\n                self\n            }"
}