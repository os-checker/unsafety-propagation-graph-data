{
  "name": "core::iter::adapters::map_windows::Buffer::<T, N>::push",
  "span": "$library/core/src/iter/adapters/map_windows.rs:145:5: 145:32",
  "src": "fn push(&mut self, next: T) {\n        let buffer_mut_ptr = self.buffer_mut_ptr();\n        debug_assert!(self.start + N <= 2 * N);\n\n        let to_drop = if self.start == N {\n            // We have reached the end of our buffer and have to copy\n            // everything to the start. Example layout for N = 3.\n            //\n            //    0   1   2   3   4   5            0   1   2   3   4   5\n            //  ┌───┬───┬───┬───┬───┬───┐        ┌───┬───┬───┬───┬───┬───┐\n            //  │ - │ - │ - │ a │ b │ c │   ->   │ b │ c │ n │ - │ - │ - │\n            //  └───┴───┴───┴───┴───┴───┘        └───┴───┴───┴───┴───┴───┘\n            //                ↑                    ↑\n            //              start                start\n\n            // SAFETY: the two pointers are valid for reads/writes of N -1\n            // elements because our array's size is semantically 2 * N. The\n            // regions also don't overlap for the same reason.\n            //\n            // We leave the old elements in place. As soon as `start` is set\n            // to 0, we treat them as uninitialized and treat their copies\n            // as initialized.\n            let to_drop = unsafe {\n                ptr::copy_nonoverlapping(buffer_mut_ptr.add(self.start + 1), buffer_mut_ptr, N - 1);\n                (*buffer_mut_ptr.add(N - 1)).write(next);\n                buffer_mut_ptr.add(self.start)\n            };\n            self.start = 0;\n            to_drop\n        } else {\n            // SAFETY: `self.start` is < N as guaranteed by the invariant\n            // plus the check above. Even if the drop at the end panics,\n            // the invariant is upheld.\n            //\n            // Example layout for N = 3:\n            //\n            //    0   1   2   3   4   5            0   1   2   3   4   5\n            //  ┌───┬───┬───┬───┬───┬───┐        ┌───┬───┬───┬───┬───┬───┐\n            //  │ - │ a │ b │ c │ - │ - │   ->   │ - │ - │ b │ c │ n │ - │\n            //  └───┴───┴───┴───┴───┴───┘        └───┴───┴───┴───┴───┴───┘\n            //        ↑                                    ↑\n            //      start                                start\n            //\n            let to_drop = unsafe {\n                (*buffer_mut_ptr.add(self.start + N)).write(next);\n                buffer_mut_ptr.add(self.start)\n            };\n            self.start += 1;\n            to_drop\n        };\n\n        // SAFETY: the index is valid and this is element `a` in the\n        // diagram above and has not been dropped yet.\n        unsafe { ptr::drop_in_place(to_drop.cast_init()) };\n    }"
}