{
  "name": "core::<slice::iter::Chunks<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::next_back",
  "span": "$library/core/src/slice/iter.rs:1575:5: 1575:47",
  "src": "fn next_back(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let remainder = self.v.len() % self.chunk_size;\n            let chunksz = if remainder != 0 { remainder } else { self.chunk_size };\n            // SAFETY: split_at_unchecked requires the argument be less than or\n            // equal to the length. This is guaranteed, but subtle: `chunksz`\n            // will always either be `self.v.len() % self.chunk_size`, which\n            // will always evaluate to strictly less than `self.v.len()` (or\n            // panic, in the case that `self.chunk_size` is zero), or it can be\n            // `self.chunk_size`, in the case that the length is exactly\n            // divisible by the chunk size.\n            //\n            // While it seems like using `self.chunk_size` in this case could\n            // lead to a value greater than `self.v.len()`, it cannot: if\n            // `self.chunk_size` were greater than `self.v.len()`, then\n            // `self.v.len() % self.chunk_size` would return nonzero (note that\n            // in this branch of the `if`, we already know that `self.v` is\n            // non-empty).\n            let (fst, snd) = unsafe { self.v.split_at_unchecked(self.v.len() - chunksz) };\n            self.v = fst;\n            Some(snd)\n        }\n    }"
}