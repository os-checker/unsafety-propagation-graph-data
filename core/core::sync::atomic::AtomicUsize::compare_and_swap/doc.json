{
  "name": "core::sync::atomic::AtomicUsize::compare_and_swap",
  "span": "$library/core/src/sync/atomic.rs:3042:13: 3045:66",
  "doc": " Stores a value into the atomic integer if the current value is the same as\n the `current` value.\n\n The return value is always the previous value. If it is equal to `current`, then the\n value was updated.\n\n `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n ordering of this operation. Notice that even when using [`AcqRel`], the operation\n might fail and hence just perform an `Acquire` load, but not have `Release` semantics.\n Using [`Acquire`] makes the store part of this operation [`Relaxed`] if it\n happens, and using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Migrating to `compare_exchange` and `compare_exchange_weak`\n\n `compare_and_swap` is equivalent to `compare_exchange` with the following mapping for\n memory orderings:\n\n Original | Success | Failure\n -------- | ------- | -------\n Relaxed  | Relaxed | Relaxed\n Acquire  | Acquire | Acquire\n Release  | Release | Relaxed\n AcqRel   | AcqRel  | Acquire\n SeqCst   | SeqCst  | SeqCst\n\n `compare_and_swap` and `compare_exchange` also differ in their return type. You can use\n `compare_exchange(...).unwrap_or_else(|x| x)` to recover the behavior of `compare_and_swap`,\n but in most cases it is more idiomatic to check whether the return value is `Ok` or `Err`\n rather than to infer success vs failure based on the value that was read.\n\n During migration, consider whether it makes sense to use `compare_exchange_weak` instead.\n `compare_exchange_weak` is allowed to fail spuriously even when the comparison succeeds,\n which allows the compiler to generate better assembly code when the compare and swap\n is used in a loop.\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.compare_and_swap(5, 10, Ordering::Relaxed), 5);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n\n assert_eq!(some_var.compare_and_swap(6, 12, Ordering::Relaxed), 10);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n"
}