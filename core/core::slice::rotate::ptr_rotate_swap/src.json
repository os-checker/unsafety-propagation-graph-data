{
  "name": "core::slice::rotate::ptr_rotate_swap",
  "span": "$library/core/src/slice/rotate.rs:230:1: 230:87",
  "src": "const unsafe fn ptr_rotate_swap<T>(mut left: usize, mut mid: *mut T, mut right: usize) {\n    loop {\n        if left >= right {\n            // Algorithm 3\n            // There is an alternate way of swapping that involves finding where the last swap\n            // of this algorithm would be, and swapping using that last chunk instead of swapping\n            // adjacent chunks like this algorithm is doing, but this way is still faster.\n            loop {\n                // SAFETY:\n                // `left >= right` so `[mid-right, mid+right)` is valid for reading and writing\n                // Subtracting `right` from `mid` each turn is counterbalanced by the addition and\n                // check after it.\n                unsafe {\n                    ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n                    mid = mid.sub(right);\n                }\n                left -= right;\n                if left < right {\n                    break;\n                }\n            }\n        } else {\n            // Algorithm 3, `left < right`\n            loop {\n                // SAFETY: `[mid-left, mid+left)` is valid for reading and writing because\n                // `left < right` so `mid+left < mid+right`.\n                // Adding `left` to `mid` each turn is counterbalanced by the subtraction and check\n                // after it.\n                unsafe {\n                    ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n                    mid = mid.add(left);\n                }\n                right -= left;\n                if right < left {\n                    break;\n                }\n            }\n        }\n        if (right == 0) || (left == 0) {\n            return;\n        }\n    }\n}"
}