{
  "name": "core::slice::sort::stable::quicksort::quicksort",
  "span": "$library/core/src/slice/sort/stable/quicksort.rs:16:1: 22:2",
  "src": "pub fn quicksort<T, F: FnMut(&T, &T) -> bool>(\n    mut v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    mut limit: u32,\n    mut left_ancestor_pivot: Option<&T>,\n    is_less: &mut F,\n) {\n    loop {\n        let len = v.len();\n\n        if len <= T::small_sort_threshold() {\n            T::small_sort(v, scratch, is_less);\n            return;\n        }\n\n        if limit == 0 {\n            // We have had too many bad pivots, switch to O(n log n) fallback\n            // algorithm. In our case that is driftsort in eager mode.\n            crate::slice::sort::stable::drift::sort(v, scratch, true, is_less);\n            return;\n        }\n        limit -= 1;\n\n        let pivot_pos = choose_pivot(v, is_less);\n\n        // SAFETY: We only access the temporary copy for Freeze types, otherwise\n        // self-modifications via `is_less` would not be observed and this would\n        // be unsound. Our temporary copy does not escape this scope.\n        let pivot_copy = unsafe { ManuallyDrop::new(ptr::read(&v[pivot_pos])) };\n        let pivot_ref = (!has_direct_interior_mutability::<T>()).then_some(&*pivot_copy);\n\n        // We choose a pivot, and check if this pivot is equal to our left\n        // ancestor. If true, we do a partition putting equal elements on the\n        // left and do not recurse on it. This gives O(n log k) sorting for k\n        // distinct values, a strategy borrowed from pdqsort. For types with\n        // interior mutability we can't soundly create a temporary copy of the\n        // ancestor pivot, and use left_partition_len == 0 as our method for\n        // detecting when we re-use a pivot, which means we do at most three\n        // partition operations with pivot p instead of the optimal two.\n        let mut perform_equal_partition = false;\n        if let Some(la_pivot) = left_ancestor_pivot {\n            perform_equal_partition = !is_less(la_pivot, &v[pivot_pos]);\n        }\n\n        let mut left_partition_len = 0;\n        if !perform_equal_partition {\n            left_partition_len = stable_partition(v, scratch, pivot_pos, false, is_less);\n            perform_equal_partition = left_partition_len == 0;\n        }\n\n        if perform_equal_partition {\n            let mid_eq = stable_partition(v, scratch, pivot_pos, true, &mut |a, b| !is_less(b, a));\n            v = &mut v[mid_eq..];\n            left_ancestor_pivot = None;\n            continue;\n        }\n\n        // Process left side with the next loop iter, right side with recursion.\n        let (left, right) = v.split_at_mut(left_partition_len);\n        quicksort(right, scratch, limit, pivot_ref, is_less);\n        v = left;\n    }\n}"
}