{
  "name": "core::slice::sort::shared::smallsort::insert_tail",
  "span": "$library/core/src/slice/sort/shared/smallsort.rs:542:1: 542:97",
  "src": "unsafe fn insert_tail<T, F: FnMut(&T, &T) -> bool>(begin: *mut T, tail: *mut T, is_less: &mut F) {\n    // SAFETY: see individual comments.\n    unsafe {\n        // SAFETY: in-bounds as tail > begin.\n        let mut sift = tail.sub(1);\n        if !is_less(&*tail, &*sift) {\n            return;\n        }\n\n        // SAFETY: after this read tail is never read from again, as we only ever\n        // read from sift, sift < tail and we only ever decrease sift. Thus this is\n        // effectively a move, not a copy. Should a panic occur, or we have found\n        // the correct insertion position, gap_guard ensures the element is moved\n        // back into the array.\n        let tmp = ManuallyDrop::new(tail.read());\n        let mut gap_guard = CopyOnDrop { src: &*tmp, dst: tail, len: 1 };\n\n        loop {\n            // SAFETY: we move sift into the gap (which is valid), and point the\n            // gap guard destination at sift, ensuring that if a panic occurs the\n            // gap is once again filled.\n            ptr::copy_nonoverlapping(sift, gap_guard.dst, 1);\n            gap_guard.dst = sift;\n\n            if sift == begin {\n                break;\n            }\n\n            // SAFETY: we checked that sift != begin, thus this is in-bounds.\n            sift = sift.sub(1);\n            if !is_less(&tmp, &*sift) {\n                break;\n            }\n        }\n    }\n}"
}