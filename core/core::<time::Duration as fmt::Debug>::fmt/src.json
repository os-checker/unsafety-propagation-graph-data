{
  "name": "core::<time::Duration as fmt::Debug>::fmt",
  "span": "$library/core/src/time.rs:1272:5: 1272:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        /// Formats a floating point number in decimal notation.\n        ///\n        /// The number is given as the `integer_part` and a fractional part.\n        /// The value of the fractional part is `fractional_part / divisor`. So\n        /// `integer_part` = 3, `fractional_part` = 12 and `divisor` = 100\n        /// represents the number `3.012`. Trailing zeros are omitted.\n        ///\n        /// `divisor` must not be above 100_000_000. It also should be a power\n        /// of 10, everything else doesn't make sense. `fractional_part` has\n        /// to be less than `10 * divisor`!\n        ///\n        /// A prefix and postfix may be added. The whole thing is padded\n        /// to the formatter's `width`, if specified.\n        fn fmt_decimal(\n            f: &mut fmt::Formatter<'_>,\n            integer_part: u64,\n            mut fractional_part: u32,\n            mut divisor: u32,\n            prefix: &str,\n            postfix: &str,\n        ) -> fmt::Result {\n            // Encode the fractional part into a temporary buffer. The buffer\n            // only need to hold 9 elements, because `fractional_part` has to\n            // be smaller than 10^9. The buffer is prefilled with '0' digits\n            // to simplify the code below.\n            let mut buf = [b'0'; 9];\n\n            // The next digit is written at this position\n            let mut pos = 0;\n\n            // We keep writing digits into the buffer while there are non-zero\n            // digits left and we haven't written enough digits yet.\n            while fractional_part > 0 && pos < f.precision().unwrap_or(9) {\n                // Write new digit into the buffer\n                buf[pos] = b'0' + (fractional_part / divisor) as u8;\n\n                fractional_part %= divisor;\n                divisor /= 10;\n                pos += 1;\n            }\n\n            // If a precision < 9 was specified, there may be some non-zero\n            // digits left that weren't written into the buffer. In that case we\n            // need to perform rounding to match the semantics of printing\n            // normal floating point numbers. However, we only need to do work\n            // when rounding up. This happens if the first digit of the\n            // remaining ones is >= 5.\n            let integer_part = if fractional_part > 0 && fractional_part >= divisor * 5 {\n                // Round up the number contained in the buffer. We go through\n                // the buffer backwards and keep track of the carry.\n                let mut rev_pos = pos;\n                let mut carry = true;\n                while carry && rev_pos > 0 {\n                    rev_pos -= 1;\n\n                    // If the digit in the buffer is not '9', we just need to\n                    // increment it and can stop then (since we don't have a\n                    // carry anymore). Otherwise, we set it to '0' (overflow)\n                    // and continue.\n                    if buf[rev_pos] < b'9' {\n                        buf[rev_pos] += 1;\n                        carry = false;\n                    } else {\n                        buf[rev_pos] = b'0';\n                    }\n                }\n\n                // If we still have the carry bit set, that means that we set\n                // the whole buffer to '0's and need to increment the integer\n                // part.\n                if carry {\n                    // If `integer_part == u64::MAX` and precision < 9, any\n                    // carry of the overflow during rounding of the\n                    // `fractional_part` into the `integer_part` will cause the\n                    // `integer_part` itself to overflow. Avoid this by using an\n                    // `Option<u64>`, with `None` representing `u64::MAX + 1`.\n                    integer_part.checked_add(1)\n                } else {\n                    Some(integer_part)\n                }\n            } else {\n                Some(integer_part)\n            };\n\n            // Determine the end of the buffer: if precision is set, we just\n            // use as many digits from the buffer (capped to 9). If it isn't\n            // set, we only use all digits up to the last non-zero one.\n            let end = f.precision().map(|p| crate::cmp::min(p, 9)).unwrap_or(pos);\n\n            // This closure emits the formatted duration without emitting any\n            // padding (padding is calculated below).\n            let emit_without_padding = |f: &mut fmt::Formatter<'_>| {\n                if let Some(integer_part) = integer_part {\n                    write!(f, \"{}{}\", prefix, integer_part)?;\n                } else {\n                    // u64::MAX + 1 == 18446744073709551616\n                    write!(f, \"{}18446744073709551616\", prefix)?;\n                }\n\n                // Write the decimal point and the fractional part (if any).\n                if end > 0 {\n                    // SAFETY: We are only writing ASCII digits into the buffer and\n                    // it was initialized with '0's, so it contains valid UTF8.\n                    let s = unsafe { crate::str::from_utf8_unchecked(&buf[..end]) };\n\n                    // If the user request a precision > 9, we pad '0's at the end.\n                    let w = f.precision().unwrap_or(pos);\n                    write!(f, \".{:0<width$}\", s, width = w)?;\n                }\n\n                write!(f, \"{}\", postfix)\n            };\n\n            match f.width() {\n                None => {\n                    // No `width` specified. There's no need to calculate the\n                    // length of the output in this case, just emit it.\n                    emit_without_padding(f)\n                }\n                Some(requested_w) => {\n                    // A `width` was specified. Calculate the actual width of\n                    // the output in order to calculate the required padding.\n                    // It consists of 4 parts:\n                    // 1. The prefix: is either \"+\" or \"\", so we can just use len().\n                    // 2. The postfix: can be \"µs\" so we have to count UTF8 characters.\n                    let mut actual_w = prefix.len() + postfix.chars().count();\n                    // 3. The integer part:\n                    if let Some(integer_part) = integer_part {\n                        if let Some(log) = integer_part.checked_ilog10() {\n                            // integer_part is > 0, so has length log10(x)+1\n                            actual_w += 1 + log as usize;\n                        } else {\n                            // integer_part is 0, so has length 1.\n                            actual_w += 1;\n                        }\n                    } else {\n                        // integer_part is u64::MAX + 1, so has length 20\n                        actual_w += 20;\n                    }\n                    // 4. The fractional part (if any):\n                    if end > 0 {\n                        let frac_part_w = f.precision().unwrap_or(pos);\n                        actual_w += 1 + frac_part_w;\n                    }\n\n                    if requested_w <= actual_w {\n                        // Output is already longer than `width`, so don't pad.\n                        emit_without_padding(f)\n                    } else {\n                        // We need to add padding. Use the `Formatter::padding` helper function.\n                        let default_align = fmt::Alignment::Left;\n                        let post_padding =\n                            f.padding((requested_w - actual_w) as u16, default_align)?;\n                        emit_without_padding(f)?;\n                        post_padding.write(f)\n                    }\n                }\n            }\n        }\n\n        // Print leading '+' sign if requested\n        let prefix = if f.sign_plus() { \"+\" } else { \"\" };\n\n        if self.secs > 0 {\n            fmt_decimal(f, self.secs, self.nanos.as_inner(), NANOS_PER_SEC / 10, prefix, \"s\")\n        } else if self.nanos.as_inner() >= NANOS_PER_MILLI {\n            fmt_decimal(\n                f,\n                (self.nanos.as_inner() / NANOS_PER_MILLI) as u64,\n                self.nanos.as_inner() % NANOS_PER_MILLI,\n                NANOS_PER_MILLI / 10,\n                prefix,\n                \"ms\",\n            )\n        } else if self.nanos.as_inner() >= NANOS_PER_MICRO {\n            fmt_decimal(\n                f,\n                (self.nanos.as_inner() / NANOS_PER_MICRO) as u64,\n                self.nanos.as_inner() % NANOS_PER_MICRO,\n                NANOS_PER_MICRO / 10,\n                prefix,\n                \"µs\",\n            )\n        } else {\n            fmt_decimal(f, self.nanos.as_inner() as u64, 0, 1, prefix, \"ns\")\n        }\n    }"
}