{
  "name": "core::f64::<impl f64>::total_cmp",
  "span": "$library/core/src/num/f64.rs:1366:5: 1366:72",
  "doc": " Returns the ordering between `self` and `other`.\n\n Unlike the standard partial comparison between floating point numbers,\n this comparison always produces an ordering in accordance to\n the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)\n floating point standard. The values are ordered in the following sequence:\n\n - negative quiet NaN\n - negative signaling NaN\n - negative infinity\n - negative numbers\n - negative subnormal numbers\n - negative zero\n - positive zero\n - positive subnormal numbers\n - positive numbers\n - positive infinity\n - positive signaling NaN\n - positive quiet NaN.\n\n The ordering established by this function does not always agree with the\n [`PartialOrd`] and [`PartialEq`] implementations of `f64`. For example,\n they consider negative and positive zero equal, while `total_cmp`\n doesn't.\n\n The interpretation of the signaling NaN bit follows the definition in\n the IEEE 754 standard, which may not match the interpretation by some of\n the older, non-conformant (e.g. MIPS) hardware implementations.\n\n # Example\n\n ```\n struct GoodBoy {\n     name: String,\n     weight: f64,\n }\n\n let mut bois = vec![\n     GoodBoy { name: \"Pucci\".to_owned(), weight: 0.1 },\n     GoodBoy { name: \"Woofer\".to_owned(), weight: 99.0 },\n     GoodBoy { name: \"Yapper\".to_owned(), weight: 10.0 },\n     GoodBoy { name: \"Chonk\".to_owned(), weight: f64::INFINITY },\n     GoodBoy { name: \"Abs. Unit\".to_owned(), weight: f64::NAN },\n     GoodBoy { name: \"Floaty\".to_owned(), weight: -5.0 },\n ];\n\n bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n\n // `f64::NAN` could be positive or negative, which will affect the sort order.\n if f64::NAN.is_sign_negative() {\n     assert!(bois.into_iter().map(|b| b.weight)\n         .zip([f64::NAN, -5.0, 0.1, 10.0, 99.0, f64::INFINITY].iter())\n         .all(|(a, b)| a.to_bits() == b.to_bits()))\n } else {\n     assert!(bois.into_iter().map(|b| b.weight)\n         .zip([-5.0, 0.1, 10.0, 99.0, f64::INFINITY, f64::NAN].iter())\n         .all(|(a, b)| a.to_bits() == b.to_bits()))\n }\n ```\n"
}