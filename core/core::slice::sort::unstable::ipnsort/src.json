{
  "name": "core::slice::sort::unstable::ipnsort",
  "span": "$library/core/src/slice/sort/unstable/mod.rs:61:1: 63:30",
  "src": "fn ipnsort<T, F>(v: &mut [T], is_less: &mut F)\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let len = v.len();\n    let (run_len, was_reversed) = find_existing_run(v, is_less);\n\n    // SAFETY: find_existing_run promises to return a valid run_len.\n    unsafe { intrinsics::assume(run_len <= len) };\n\n    if run_len == len {\n        if was_reversed {\n            v.reverse();\n        }\n\n        // It would be possible to a do in-place merging here for a long existing streak. But that\n        // makes the implementation a lot bigger, users can use `slice::sort` for that use-case.\n        return;\n    }\n\n    // Limit the number of imbalanced partitions to `2 * floor(log2(len))`.\n    // The binary OR by one is used to eliminate the zero-check in the logarithm.\n    let limit = 2 * (len | 1).ilog2();\n    crate::slice::sort::unstable::quicksort::quicksort(v, None, limit, is_less);\n}"
}