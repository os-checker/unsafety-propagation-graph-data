{
  "name": "core::slice::rotate::ptr_rotate_memmove",
  "span": "$library/core/src/slice/rotate.rs:49:1: 49:78",
  "src": "const unsafe fn ptr_rotate_memmove<T>(left: usize, mid: *mut T, right: usize) {\n    // The `[T; 0]` here is to ensure this is appropriately aligned for T\n    let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n    let buf = rawarray.as_mut_ptr() as *mut T;\n    // SAFETY: `mid-left <= mid-left+right < mid+right`\n    let dim = unsafe { mid.sub(left).add(right) };\n    if left <= right {\n        // SAFETY:\n        //\n        // 1) The `if` condition about the sizes ensures `[mid-left; left]` will fit in\n        //    `buf` without overflow and `buf` was created just above and so cannot be\n        //    overlapped with any value of `[mid-left; left]`\n        // 2) [mid-left, mid+right) are all valid for reading and writing and we don't care\n        //    about overlaps here.\n        // 3) The `if` condition about `left <= right` ensures writing `left` elements to\n        //    `dim = mid-left+right` is valid because:\n        //    - `buf` is valid and `left` elements were written in it in 1)\n        //    - `dim+left = mid-left+right+left = mid+right` and we write `[dim, dim+left)`\n        unsafe {\n            // 1)\n            ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n            // 2)\n            ptr::copy(mid, mid.sub(left), right);\n            // 3)\n            ptr::copy_nonoverlapping(buf, dim, left);\n        }\n    } else {\n        // SAFETY: same reasoning as above but with `left` and `right` reversed\n        unsafe {\n            ptr::copy_nonoverlapping(mid, buf, right);\n            ptr::copy(mid.sub(left), dim, left);\n            ptr::copy_nonoverlapping(buf, mid.sub(left), right);\n        }\n    }\n}"
}