{
  "name": "core::slice::memchr::memrchr",
  "span": "$library/core/src/slice/memchr.rs:111:1: 111:52",
  "src": "pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n    // Scan for a single byte value by reading two `usize` words at a time.\n    //\n    // Split `text` in three parts:\n    // - unaligned tail, after the last word aligned address in text,\n    // - body, scanned by 2 words at a time,\n    // - the first remaining bytes, < 2 word size.\n    let len = text.len();\n    let ptr = text.as_ptr();\n    type Chunk = usize;\n\n    let (min_aligned_offset, max_aligned_offset) = {\n        // We call this just to obtain the length of the prefix and suffix.\n        // In the middle we always process two chunks at once.\n        // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size differences\n        // which are handled by `align_to`.\n        let (prefix, _, suffix) = unsafe { text.align_to::<(Chunk, Chunk)>() };\n        (prefix.len(), len - suffix.len())\n    };\n\n    let mut offset = max_aligned_offset;\n    if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n        return Some(offset + index);\n    }\n\n    // Search the body of the text, make sure we don't cross min_aligned_offset.\n    // offset is always aligned, so just testing `>` is sufficient and avoids possible\n    // overflow.\n    let repeated_x = usize::repeat_u8(x);\n    let chunk_bytes = size_of::<Chunk>();\n\n    while offset > min_aligned_offset {\n        // SAFETY: offset starts at len - suffix.len(), as long as it is greater than\n        // min_aligned_offset (prefix.len()) the remaining distance is at least 2 * chunk_bytes.\n        unsafe {\n            let u = *(ptr.add(offset - 2 * chunk_bytes) as *const Chunk);\n            let v = *(ptr.add(offset - chunk_bytes) as *const Chunk);\n\n            // Break if there is a matching byte.\n            let zu = contains_zero_byte(u ^ repeated_x);\n            let zv = contains_zero_byte(v ^ repeated_x);\n            if zu || zv {\n                break;\n            }\n        }\n        offset -= 2 * chunk_bytes;\n    }\n\n    // Find the byte before the point the body loop stopped.\n    text[..offset].iter().rposition(|elt| *elt == x)\n}"
}