{
  "name": "core::fmt::float::float_to_exponential_common_shortest",
  "span": "$library/core/src/fmt/float.rs:130:1: 137:32",
  "src": "fn float_to_exponential_common_shortest<T>(\n    fmt: &mut Formatter<'_>,\n    num: &T,\n    sign: flt2dec::Sign,\n    upper: bool,\n) -> Result\nwhere\n    T: flt2dec::DecodableFloat,\n{\n    // enough for f32 and f64\n    let mut buf: [MaybeUninit<u8>; flt2dec::MAX_SIG_DIGITS] =\n        [MaybeUninit::uninit(); flt2dec::MAX_SIG_DIGITS];\n    let mut parts: [MaybeUninit<numfmt::Part<'_>>; 6] = [MaybeUninit::uninit(); 6];\n    let formatted = flt2dec::to_shortest_exp_str(\n        flt2dec::strategy::grisu::format_shortest,\n        *num,\n        sign,\n        (0, 0),\n        upper,\n        &mut buf,\n        &mut parts,\n    );\n    // SAFETY: `to_shortest_exp_str` and `format_shortest` produce only ASCII characters.\n    unsafe { fmt.pad_formatted_parts(&formatted) }\n}"
}