{
  "name": "core::num::<impl u8>::widening_mul",
  "span": "$library/core/src/num/uint_macros.rs:2994:9: 2994:67",
  "doc": " Calculates the complete double-width product `self * rhs`.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order. As such,\n `a.widening_mul(b).0` produces the same result as `a.wrapping_mul(b)`.\n\n If you also need to add a value and carry to the wide result, then you want\n [`Self::carrying_mul_add`] instead.\n\n If you also need to add a carry to the wide result, then you want\n [`Self::carrying_mul`] instead.\n\n If you just want to know *whether* the multiplication overflowed, then you\n want [`Self::overflowing_mul`] instead.\n\n # Examples\n\n ```\n #![feature(bigint_helper_methods)]\n ```\n\n Compared to other `*_mul` methods:\n ```\n #![feature(bigint_helper_methods)]\n ```\n\n Please note that this example is shared among integer types, which is why `u32` is used.\n\n ```\n #![feature(bigint_helper_methods)]\n assert_eq!(5u32.widening_mul(2), (10, 0));\n assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n ```\n"
}