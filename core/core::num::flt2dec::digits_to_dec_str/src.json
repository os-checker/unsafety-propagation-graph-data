{
  "name": "core::num::flt2dec::digits_to_dec_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:177:1: 182:20",
  "src": "fn digits_to_dec_str<'a>(\n    buf: &'a [u8],\n    exp: i16,\n    frac_digits: usize,\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> &'a [Part<'a>] {\n    assert!(!buf.is_empty());\n    assert!(buf[0] > b'0');\n    assert!(parts.len() >= 4);\n\n    // if there is the restriction on the last digit position, `buf` is assumed to be\n    // left-padded with the virtual zeroes. the number of virtual zeroes, `nzeroes`,\n    // equals to `max(0, exp + frac_digits - buf.len())`, so that the position of\n    // the last digit `exp - buf.len() - nzeroes` is no more than `-frac_digits`:\n    //\n    //                       |<-virtual->|\n    //       |<---- buf ---->|  zeroes   |     exp\n    //    0. 1 2 3 4 5 6 7 8 9 _ _ _ _ _ _ x 10\n    //    |                  |           |\n    // 10^exp    10^(exp-buf.len())   10^(exp-buf.len()-nzeroes)\n    //\n    // `nzeroes` is individually calculated for each case in order to avoid overflow.\n\n    if exp <= 0 {\n        // the decimal point is before rendered digits: [0.][000...000][1234][____]\n        let minus_exp = -(exp as i32) as usize;\n        parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n        parts[1] = MaybeUninit::new(Part::Zero(minus_exp));\n        parts[2] = MaybeUninit::new(Part::Copy(buf));\n        if frac_digits > buf.len() && frac_digits - buf.len() > minus_exp {\n            parts[3] = MaybeUninit::new(Part::Zero((frac_digits - buf.len()) - minus_exp));\n            // SAFETY: we just initialized the elements `..4`.\n            unsafe { parts[..4].assume_init_ref() }\n        } else {\n            // SAFETY: we just initialized the elements `..3`.\n            unsafe { parts[..3].assume_init_ref() }\n        }\n    } else {\n        let exp = exp as usize;\n        if exp < buf.len() {\n            // the decimal point is inside rendered digits: [12][.][34][____]\n            parts[0] = MaybeUninit::new(Part::Copy(&buf[..exp]));\n            parts[1] = MaybeUninit::new(Part::Copy(b\".\"));\n            parts[2] = MaybeUninit::new(Part::Copy(&buf[exp..]));\n            if frac_digits > buf.len() - exp {\n                parts[3] = MaybeUninit::new(Part::Zero(frac_digits - (buf.len() - exp)));\n                // SAFETY: we just initialized the elements `..4`.\n                unsafe { parts[..4].assume_init_ref() }\n            } else {\n                // SAFETY: we just initialized the elements `..3`.\n                unsafe { parts[..3].assume_init_ref() }\n            }\n        } else {\n            // the decimal point is after rendered digits: [1234][____0000] or [1234][__][.][__].\n            parts[0] = MaybeUninit::new(Part::Copy(buf));\n            parts[1] = MaybeUninit::new(Part::Zero(exp - buf.len()));\n            if frac_digits > 0 {\n                parts[2] = MaybeUninit::new(Part::Copy(b\".\"));\n                parts[3] = MaybeUninit::new(Part::Zero(frac_digits));\n                // SAFETY: we just initialized the elements `..4`.\n                unsafe { parts[..4].assume_init_ref() }\n            } else {\n                // SAFETY: we just initialized the elements `..2`.\n                unsafe { parts[..2].assume_init_ref() }\n            }\n        }\n    }\n}"
}