{
  "name": "core::char::methods::encode_utf8_raw",
  "span": "$library/core/src/char/methods.rs:1873:1: 1873:69",
  "src": "pub const fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> &mut [u8] {\n    let len = len_utf8(code);\n    if dst.len() < len {\n        const_panic!(\n            \"encode_utf8: buffer does not have enough bytes to encode code point\",\n            \"encode_utf8: need {len} bytes to encode U+{code:04X} but buffer has just {dst_len}\",\n            code: u32 = code,\n            len: usize = len,\n            dst_len: usize = dst.len(),\n        );\n    }\n\n    // SAFETY: `dst` is checked to be at least the length needed to encode the codepoint.\n    unsafe { encode_utf8_raw_unchecked(code, dst.as_mut_ptr()) };\n\n    // SAFETY: `<&mut [u8]>::as_mut_ptr` is guaranteed to return a valid pointer and `len` has been tested to be within bounds.\n    unsafe { slice::from_raw_parts_mut(dst.as_mut_ptr(), len) }\n}"
}