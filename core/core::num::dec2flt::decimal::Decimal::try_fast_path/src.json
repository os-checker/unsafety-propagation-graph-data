{
  "name": "core::num::dec2flt::decimal::Decimal::try_fast_path",
  "span": "$library/core/src/num/dec2flt/decimal.rs:54:5: 54:58",
  "src": "pub fn try_fast_path<F: RawFloat>(&self) -> Option<F> {\n        // Here we need to work around <https://github.com/rust-lang/rust/issues/114479>.\n        // The fast path crucially depends on arithmetic being rounded to the correct number of bits\n        // without any intermediate rounding. On x86 (without SSE or SSE2) this requires the precision\n        // of the x87 FPU stack to be changed so that it directly rounds to 64/32 bit.\n        // The `set_precision` function takes care of setting the precision on architectures which\n        // require setting it by changing the global state (like the control word of the x87 FPU).\n        let _cw = set_precision::<F>();\n\n        if !self.can_use_fast_path::<F>() {\n            return None;\n        }\n\n        let value = if self.exponent <= F::MAX_EXPONENT_FAST_PATH {\n            // normal fast path\n            let value = F::from_u64(self.mantissa);\n            if self.exponent < 0 {\n                value / F::pow10_fast_path((-self.exponent) as _)\n            } else {\n                value * F::pow10_fast_path(self.exponent as _)\n            }\n        } else {\n            // disguised fast path\n            let shift = self.exponent - F::MAX_EXPONENT_FAST_PATH;\n            let mantissa = self.mantissa.checked_mul(INT_POW10[shift as usize])?;\n            if mantissa > F::MAX_MANTISSA_FAST_PATH {\n                return None;\n            }\n            F::from_u64(mantissa) * F::pow10_fast_path(F::MAX_EXPONENT_FAST_PATH as _)\n        };\n\n        if self.negative { Some(-value) } else { Some(value) }\n    }"
}