{
  "name": "core::slice::sort::unstable::quicksort::partition_hoare_branchy_cyclic",
  "span": "$library/core/src/slice/sort/unstable/quicksort.rs:158:1: 160:30",
  "src": "fn partition_hoare_branchy_cyclic<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\nwhere\n    F: FnMut(&T, &T) -> bool,\n{\n    let len = v.len();\n\n    if len == 0 {\n        return 0;\n    }\n\n    // Optimized for large types that are expensive to move. Not optimized for integers. Optimized\n    // for small code-gen, assuming that is_less is an expensive operation that generates\n    // substantial amounts of code or a call. And that copying elements will likely be a call to\n    // memcpy. Using 2 `ptr::copy_nonoverlapping` has the chance to be faster than\n    // `ptr::swap_nonoverlapping` because `memcpy` can use wide SIMD based on runtime feature\n    // detection. Benchmarks support this analysis.\n\n    let mut gap_opt: Option<GapGuard<T>> = None;\n\n    // SAFETY: The left-to-right scanning loop performs a bounds check, where we know that `left >=\n    // v_base && left < right && right <= v_base.add(len)`. The right-to-left scanning loop performs\n    // a bounds check ensuring that `right` is in-bounds. We checked that `len` is more than zero,\n    // which means that unconditional `right = right.sub(1)` is safe to do. The exit check makes\n    // sure that `left` and `right` never alias, making `ptr::copy_nonoverlapping` safe. The\n    // drop-guard `gap` ensures that should `is_less` panic we always overwrite the duplicate in the\n    // input. `gap.pos` stores the previous value of `right` and starts at `right` and so it too is\n    // in-bounds. We never pass the saved `gap.value` to `is_less` while it is inside the `GapGuard`\n    // thus any changes via interior mutability will be observed.\n    unsafe {\n        let v_base = v.as_mut_ptr();\n\n        let mut left = v_base;\n        let mut right = v_base.add(len);\n\n        loop {\n            // Find the first element greater than the pivot.\n            while left < right && is_less(&*left, pivot) {\n                left = left.add(1);\n            }\n\n            // Find the last element equal to the pivot.\n            loop {\n                right = right.sub(1);\n                if left >= right || is_less(&*right, pivot) {\n                    break;\n                }\n            }\n\n            if left >= right {\n                break;\n            }\n\n            // Swap the found pair of out-of-order elements via cyclic permutation.\n            let is_first_swap_pair = gap_opt.is_none();\n\n            if is_first_swap_pair {\n                gap_opt = Some(GapGuard { pos: right, value: ManuallyDrop::new(ptr::read(left)) });\n            }\n\n            let gap = gap_opt.as_mut().unwrap_unchecked();\n\n            // Single place where we instantiate ptr::copy_nonoverlapping in the partition.\n            if !is_first_swap_pair {\n                ptr::copy_nonoverlapping(left, gap.pos, 1);\n            }\n            gap.pos = right;\n            ptr::copy_nonoverlapping(right, left, 1);\n\n            left = left.add(1);\n        }\n\n        left.offset_from_unsigned(v_base)\n\n        // `gap_opt` goes out of scope and overwrites the last wrong-side element on the right side\n        // with the first wrong-side element of the left side that was initially overwritten by the\n        // first wrong-side element on the right side element.\n    }\n}"
}