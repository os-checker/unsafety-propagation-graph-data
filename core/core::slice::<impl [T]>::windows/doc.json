{
  "name": "core::slice::<impl [T]>::windows",
  "span": "$library/core/src/slice/mod.rs:1114:5: 1114:63",
  "doc": " Returns an iterator over all contiguous windows of length\n `size`. The windows overlap. If the slice is shorter than\n `size`, the iterator returns no values.\n\n # Panics\n\n Panics if `size` is zero.\n\n # Examples\n\n ```\n let slice = ['l', 'o', 'r', 'e', 'm'];\n let mut iter = slice.windows(3);\n assert_eq!(iter.next().unwrap(), &['l', 'o', 'r']);\n assert_eq!(iter.next().unwrap(), &['o', 'r', 'e']);\n assert_eq!(iter.next().unwrap(), &['r', 'e', 'm']);\n assert!(iter.next().is_none());\n ```\n\n If the slice is shorter than `size`:\n\n ```\n let slice = ['f', 'o', 'o'];\n let mut iter = slice.windows(4);\n assert!(iter.next().is_none());\n ```\n\n Because the [Iterator] trait cannot represent the required lifetimes,\n there is no `windows_mut` analog to `windows`;\n `[0,1,2].windows_mut(2).collect()` would violate [the rules of references]\n (though a [LendingIterator] analog is possible). You can sometimes use\n [`Cell::as_slice_of_cells`](crate::cell::Cell::as_slice_of_cells) in\n conjunction with `windows` instead:\n\n [the rules of references]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references\n [LendingIterator]: https://blog.rust-lang.org/2022/10/28/gats-stabilization.html\n ```\n use std::cell::Cell;\n\n let mut array = ['R', 'u', 's', 't', ' ', '2', '0', '1', '5'];\n let slice = &mut array[..];\n let slice_of_cells: &[Cell<char>] = Cell::from_mut(slice).as_slice_of_cells();\n for w in slice_of_cells.windows(3) {\n     Cell::swap(&w[0], &w[2]);\n }\n assert_eq!(array, ['s', 't', ' ', '2', '0', '1', '5', 'u', 'R']);\n ```\n"
}