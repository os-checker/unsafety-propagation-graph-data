{
  "name": "core::str::iter::SplitInternal::<'a, P>::next_back",
  "span": "$library/core/src/str/iter.rs:698:5: 700:46",
  "src": "fn next_back(&mut self) -> Option<&'a str>\n    where\n        P::Searcher<'a>: ReverseSearcher<'a>,\n    {\n        if self.finished {\n            return None;\n        }\n\n        if !self.allow_trailing_empty {\n            self.allow_trailing_empty = true;\n            match self.next_back() {\n                Some(elt) if !elt.is_empty() => return Some(elt),\n                _ => {\n                    if self.finished {\n                        return None;\n                    }\n                }\n            }\n        }\n\n        let haystack = self.matcher.haystack();\n        match self.matcher.next_match_back() {\n            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n            Some((a, b)) => unsafe {\n                let elt = haystack.get_unchecked(b..self.end);\n                self.end = a;\n                Some(elt)\n            },\n            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n            None => unsafe {\n                self.finished = true;\n                Some(haystack.get_unchecked(self.start..self.end))\n            },\n        }\n    }"
}