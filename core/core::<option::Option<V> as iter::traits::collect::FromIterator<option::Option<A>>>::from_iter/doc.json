{
  "name": "core::<option::Option<V> as iter::traits::collect::FromIterator<option::Option<A>>>::from_iter",
  "span": "$library/core/src/option.rs:2645:5: 2645:74",
  "doc": " Takes each element in the [`Iterator`]: if it is [`None`][Option::None],\n no further elements are taken, and the [`None`][Option::None] is\n returned. Should no [`None`][Option::None] occur, a container of type\n `V` containing the values of each [`Option`] is returned.\n\n # Examples\n\n Here is an example which increments every integer in a vector.\n We use the checked variant of `add` that returns `None` when the\n calculation would result in an overflow.\n\n ```\n let items = vec![0_u16, 1, 2];\n\n let res: Option<Vec<u16>> = items\n     .iter()\n     .map(|x| x.checked_add(1))\n     .collect();\n\n assert_eq!(res, Some(vec![1, 2, 3]));\n ```\n\n As you can see, this will return the expected, valid items.\n\n Here is another example that tries to subtract one from another list\n of integers, this time checking for underflow:\n\n ```\n let items = vec![2_u16, 1, 0];\n\n let res: Option<Vec<u16>> = items\n     .iter()\n     .map(|x| x.checked_sub(1))\n     .collect();\n\n assert_eq!(res, None);\n ```\n\n Since the last element is zero, it would underflow. Thus, the resulting\n value is `None`.\n\n Here is a variation on the previous example, showing that no\n further elements are taken from `iter` after the first `None`.\n\n ```\n let items = vec![3_u16, 2, 1, 10];\n\n let mut shared = 0;\n\n let res: Option<Vec<u16>> = items\n     .iter()\n     .map(|x| { shared += x; x.checked_sub(2) })\n     .collect();\n\n assert_eq!(res, None);\n assert_eq!(shared, 6);\n ```\n\n Since the third element caused an underflow, no further elements were taken,\n so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.\n"
}