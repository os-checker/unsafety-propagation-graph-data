{
  "name": "core::slice::sort::stable::merge::merge",
  "span": "$library/core/src/slice/sort/stable/merge.rs:8:1: 13:2",
  "src": "pub fn merge<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    mid: usize,\n    is_less: &mut F,\n) {\n    let len = v.len();\n\n    if mid == 0 || mid >= len || scratch.len() < cmp::min(mid, len - mid) {\n        return;\n    }\n\n    // SAFETY: We checked that the two slices are non-empty and `mid` is in-bounds.\n    // We checked that the buffer `scratch` has enough capacity to hold a copy of\n    // the shorter slice. `merge_up` and `merge_down` are written in such a way that\n    // they uphold the contract described in `MergeState::drop`.\n    unsafe {\n        // The merge process first copies the shorter run into `buf`. Then it traces\n        // the newly copied run and the longer run forwards (or backwards), comparing\n        // their next unconsumed elements and copying the lesser (or greater) one into `v`.\n        //\n        // As soon as the shorter run is fully consumed, the process is done. If the\n        // longer run gets consumed first, then we must copy whatever is left of the\n        // shorter run into the remaining gap in `v`.\n        //\n        // Intermediate state of the process is always tracked by `gap`, which serves\n        // two purposes:\n        //  1. Protects integrity of `v` from panics in `is_less`.\n        //  2. Fills the remaining gap in `v` if the longer run gets consumed first.\n\n        let buf = scratch.as_mut_ptr().cast_init();\n\n        let v_base = v.as_mut_ptr();\n        let v_mid = v_base.add(mid);\n        let v_end = v_base.add(len);\n\n        let left_len = mid;\n        let right_len = len - mid;\n\n        let left_is_shorter = left_len <= right_len;\n        let save_base = if left_is_shorter { v_base } else { v_mid };\n        let save_len = if left_is_shorter { left_len } else { right_len };\n\n        ptr::copy_nonoverlapping(save_base, buf, save_len);\n\n        let mut merge_state = MergeState { start: buf, end: buf.add(save_len), dst: save_base };\n\n        if left_is_shorter {\n            merge_state.merge_up(v_mid, v_end, is_less);\n        } else {\n            merge_state.merge_down(v_base, buf, v_end, is_less);\n        }\n        // Finally, `merge_state` gets dropped. If the shorter run was not fully\n        // consumed, whatever remains of it will now be copied into the hole in `v`.\n    }\n}"
}