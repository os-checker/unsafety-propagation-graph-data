{
  "name": "core::<char::decode::DecodeUtf16<I> as iter::traits::iterator::Iterator>::next",
  "span": "$library/core/src/char/decode.rs:43:5: 43:65",
  "src": "fn next(&mut self) -> Option<Result<char, DecodeUtf16Error>> {\n        let u = match self.buf.take() {\n            Some(buf) => buf,\n            None => self.iter.next()?,\n        };\n\n        if !u.is_utf16_surrogate() {\n            // SAFETY: not a surrogate\n            Some(Ok(unsafe { char::from_u32_unchecked(u as u32) }))\n        } else if u >= 0xDC00 {\n            // a trailing surrogate\n            Some(Err(DecodeUtf16Error { code: u }))\n        } else {\n            let u2 = match self.iter.next() {\n                Some(u2) => u2,\n                // eof\n                None => return Some(Err(DecodeUtf16Error { code: u })),\n            };\n            if u2 < 0xDC00 || u2 > 0xDFFF {\n                // not a trailing surrogate so we're not a valid\n                // surrogate pair, so rewind to redecode u2 next time.\n                self.buf = Some(u2);\n                return Some(Err(DecodeUtf16Error { code: u }));\n            }\n\n            // all ok, so lets decode it.\n            let c = (((u & 0x3ff) as u32) << 10 | (u2 & 0x3ff) as u32) + 0x1_0000;\n            // SAFETY: we checked that it's a legal unicode value\n            Some(Ok(unsafe { char::from_u32_unchecked(c) }))\n        }\n    }"
}