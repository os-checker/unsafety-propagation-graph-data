{
  "name": "core::str::<impl str>::splitn",
  "span": "$library/core/src/str/mod.rs:1885:5: 1885:72",
  "doc": " Returns an iterator over substrings of the given string slice, separated\n by a pattern, restricted to returning at most `n` items.\n\n If `n` substrings are returned, the last substring (the `n`th substring)\n will contain the remainder of the string.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Iterator behavior\n\n The returned iterator will not be double ended, because it is\n not efficient to support.\n\n If the pattern allows a reverse search, the [`rsplitn`] method can be\n used.\n\n [`rsplitn`]: str::rsplitn\n\n # Examples\n\n Simple patterns:\n\n ```\n let v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\n assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n\n let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\n assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n\n let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n assert_eq!(v, [\"abcXdef\"]);\n\n let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n assert_eq!(v, [\"\"]);\n ```\n\n A more complex pattern, using a closure:\n\n ```\n let v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\n assert_eq!(v, [\"abc\", \"defXghi\"]);\n ```\n"
}