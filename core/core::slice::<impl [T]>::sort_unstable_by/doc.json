{
  "name": "core::slice::<impl [T]>::sort_unstable_by",
  "span": "$library/core/src/slice/mod.rs:3185:5: 3187:38",
  "doc": " Sorts the slice in ascending order with a comparison function, **without** preserving the\n initial order of equal elements.\n\n This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\n allocate), and *O*(*n* \\* log(*n*)) worst-case.\n\n If the comparison function `compare` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n All original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. Same is true if `compare` panics.\n\n # Current implementation\n\n The current implementation is based on [ipnsort] by Lukas Bergdoll and Orson Peters, which\n combines the fast average case of quicksort with the fast worst case of heapsort, achieving\n linear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\n expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n It is typically faster than stable sorting, except in a few special cases, e.g., when the\n slice is partially sorted.\n\n # Panics\n\n May panic if the `compare` does not implement a [total order], or if\n the `compare` itself panics.\n\n # Examples\n\n ```\n let mut v = [4, -5, 1, -3, 2];\n v.sort_unstable_by(|a, b| a.cmp(b));\n assert_eq!(v, [-5, -3, 1, 2, 4]);\n\n // reverse sorting\n v.sort_unstable_by(|a, b| b.cmp(a));\n assert_eq!(v, [4, 2, 1, -3, -5]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n"
}