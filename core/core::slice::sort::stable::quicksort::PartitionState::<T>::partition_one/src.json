{
  "name": "core::slice::sort::stable::quicksort::PartitionState::<T>::partition_one",
  "span": "$library/core/src/slice/sort/stable/quicksort.rs:212:5: 212:69",
  "src": "unsafe fn partition_one(&mut self, towards_left: bool) -> *mut T {\n        // SAFETY: see individual comments.\n        unsafe {\n            // SAFETY: in-bounds because this function is called at most len times, and thus\n            // right now is incremented at most len - 1 times. Similarly, num_left < len and\n            // num_right < len, where num_right == i - num_left at the start of the ith\n            // iteration (zero-indexed).\n            self.scratch_rev = self.scratch_rev.sub(1);\n\n            // SAFETY: now we have scratch_rev == base + len - (i + 1). This means\n            // scratch_rev + num_left == base + len - 1 - num_right < base + len.\n            let dst_base = if towards_left { self.scratch_base } else { self.scratch_rev };\n            let dst = dst_base.add(self.num_left);\n            ptr::copy_nonoverlapping(self.scan, dst, 1);\n\n            self.num_left += towards_left as usize;\n            self.scan = self.scan.add(1);\n            dst\n        }\n    }"
}