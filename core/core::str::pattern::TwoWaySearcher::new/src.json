{
  "name": "core::str::pattern::TwoWaySearcher::new",
  "span": "$library/core/src/str/pattern.rs:1376:5: 1376:56",
  "src": "fn new(needle: &[u8], end: usize) -> TwoWaySearcher {\n        let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n        let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n\n        let (crit_pos, period) = if crit_pos_false > crit_pos_true {\n            (crit_pos_false, period_false)\n        } else {\n            (crit_pos_true, period_true)\n        };\n\n        // A particularly readable explanation of what's going on here can be found\n        // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n        // see the code for \"Algorithm CP\" on p. 323.\n        //\n        // What's going on is we have some critical factorization (u, v) of the\n        // needle, and we want to determine whether u is a suffix of\n        // &v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n        // \"Algorithm CP2\", which is optimized for when the period of the needle\n        // is large.\n        if needle[..crit_pos] == needle[period..period + crit_pos] {\n            // short period case -- the period is exact\n            // compute a separate critical factorization for the reversed needle\n            // x = u' v' where |v'| < period(x).\n            //\n            // This is sped up by the period being known already.\n            // Note that a case like x = \"acba\" may be factored exactly forwards\n            // (crit_pos = 1, period = 3) while being factored with approximate\n            // period in reverse (crit_pos = 2, period = 2). We use the given\n            // reverse factorization but keep the exact period.\n            let crit_pos_back = needle.len()\n                - cmp::max(\n                    TwoWaySearcher::reverse_maximal_suffix(needle, period, false),\n                    TwoWaySearcher::reverse_maximal_suffix(needle, period, true),\n                );\n\n            TwoWaySearcher {\n                crit_pos,\n                crit_pos_back,\n                period,\n                byteset: Self::byteset_create(&needle[..period]),\n\n                position: 0,\n                end,\n                memory: 0,\n                memory_back: needle.len(),\n            }\n        } else {\n            // long period case -- we have an approximation to the actual period,\n            // and don't use memorization.\n            //\n            // Approximate the period by lower bound max(|u|, |v|) + 1.\n            // The critical factorization is efficient to use for both forward and\n            // reverse search.\n\n            TwoWaySearcher {\n                crit_pos,\n                crit_pos_back: crit_pos,\n                period: cmp::max(crit_pos, needle.len() - crit_pos) + 1,\n                byteset: Self::byteset_create(needle),\n\n                position: 0,\n                end,\n                memory: usize::MAX, // Dummy value to signify that the period is long\n                memory_back: usize::MAX,\n            }\n        }\n    }"
}