{
  "name": "core::ptr::const_ptr::<impl *const T>::align_offset",
  "span": "$library/core/src/ptr/const_ptr.rs:1294:5: 1296:18",
  "doc": " Computes the offset that needs to be applied to the pointer in order to make it aligned to\n `align`.\n\n If it is not possible to align the pointer, the implementation returns\n `usize::MAX`.\n\n The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n used with the `wrapping_add` method.\n\n There are no guarantees whatsoever that offsetting the pointer will not overflow or go\n beyond the allocation that the pointer points into. It is up to the caller to ensure that\n the returned offset is correct in all terms other than alignment.\n\n # Panics\n\n The function panics if `align` is not a power-of-two.\n\n # Examples\n\n Accessing adjacent `u8` as `u16`\n\n ```\n # unsafe {\n let x = [5_u8, 6, 7, 8, 9];\n let ptr = x.as_ptr();\n let offset = ptr.align_offset(align_of::<u16>());\n\n if offset < x.len() - 1 {\n     let u16_ptr = ptr.add(offset).cast::<u16>();\n     assert!(*u16_ptr == u16::from_ne_bytes([5, 6]) || *u16_ptr == u16::from_ne_bytes([6, 7]));\n } else {\n     // while the pointer can be aligned via `offset`, it would point\n     // outside the allocation\n }\n # }\n ```\n"
}