{
  "name": "core::sync::atomic::AtomicPtr::<T>::fetch_ptr_sub",
  "span": "$library/core/src/sync/atomic.rs:2287:5: 2287:71",
  "doc": " Offsets the pointer's address by subtracting `val` (in units of `T`),\n returning the previous pointer.\n\n This is equivalent to using [`wrapping_sub`] to atomically perform the\n equivalent of `ptr = ptr.wrapping_sub(val);`.\n\n This method operates in units of `T`, which means that it cannot be used\n to offset the pointer by an amount which is not a multiple of\n `size_of::<T>()`. This can sometimes be inconvenient, as you may want to\n work with a deliberately misaligned pointer. In such cases, you may use\n the [`fetch_byte_sub`](Self::fetch_byte_sub) method instead.\n\n `fetch_ptr_sub` takes an [`Ordering`] argument which describes the memory\n ordering of this operation. All ordering modes are possible. Note that\n using [`Acquire`] makes the store part of this operation [`Relaxed`],\n and using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic\n operations on [`AtomicPtr`].\n\n [`wrapping_sub`]: pointer::wrapping_sub\n\n # Examples\n\n ```\n use core::sync::atomic::{AtomicPtr, Ordering};\n\n let array = [1i32, 2i32];\n let atom = AtomicPtr::new(array.as_ptr().wrapping_add(1) as *mut _);\n\n assert!(core::ptr::eq(\n     atom.fetch_ptr_sub(1, Ordering::Relaxed),\n     &array[1],\n ));\n assert!(core::ptr::eq(atom.load(Ordering::Relaxed), &array[0]));\n ```\n"
}