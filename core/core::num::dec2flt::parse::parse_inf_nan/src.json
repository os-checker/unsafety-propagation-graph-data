{
  "name": "core::num::dec2flt::parse::parse_inf_nan",
  "span": "$library/core/src/num/dec2flt/parse.rs:198:1: 198:80",
  "src": "pub(crate) fn parse_inf_nan<F: RawFloat>(s: &[u8], negative: bool) -> Option<F> {\n    // Since a valid string has at most the length 8, we can load\n    // all relevant characters into a u64 and work from there.\n    // This also generates much better code.\n\n    let mut register;\n    let len: usize;\n\n    // All valid strings are either of length 8 or 3.\n    if s.len() == 8 {\n        register = s.read_u64();\n        len = 8;\n    } else if s.len() == 3 {\n        let a = s[0] as u64;\n        let b = s[1] as u64;\n        let c = s[2] as u64;\n        register = (c << 16) | (b << 8) | a;\n        len = 3;\n    } else {\n        return None;\n    }\n\n    // Clear out the bits which turn ASCII uppercase characters into\n    // lowercase characters. The resulting string is all uppercase.\n    // What happens to other characters is irrelevant.\n    register &= 0xDFDFDFDFDFDFDFDF;\n\n    // u64 values corresponding to relevant cases\n    const INF_3: u64 = 0x464E49; // \"INF\"\n    const INF_8: u64 = 0x5954494E49464E49; // \"INFINITY\"\n    const NAN: u64 = 0x4E414E; // \"NAN\"\n\n    // Match register value to constant to parse string.\n    // Also match on the string length to catch edge cases\n    // like \"inf\\0\\0\\0\\0\\0\".\n    let float = match (register, len) {\n        (INF_3, 3) => F::INFINITY,\n        (INF_8, 8) => F::INFINITY,\n        (NAN, 3) => F::NAN,\n        _ => return None,\n    };\n\n    if negative { Some(-float) } else { Some(float) }\n}"
}