{
  "name": "core::ptr::mut_ptr::<impl *mut [T]>::split_at_mut_unchecked",
  "span": "$library/core/src/ptr/mut_ptr.rs:1815:5: 1815:83",
  "doc": " Divides one mutable raw slice into two at an index, without doing bounds checking.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Safety\n\n `mid` must be [in-bounds] of the underlying [allocation].\n Which means `self` must be dereferenceable and span a single allocation\n that is at least `mid * size_of::<T>()` bytes long. Not upholding these\n requirements is *[undefined behavior]* even if the resulting pointers are not used.\n\n [in-bounds]: #method.add\n [out-of-bounds index]: #method.add\n [allocation]: crate::ptr#allocation\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n #![feature(raw_slice_split)]\n\n let mut v = [1, 0, 3, 0, 5, 6];\n // scoped to restrict the lifetime of the borrows\n unsafe {\n     let ptr = &mut v as *mut [_];\n     let (left, right) = ptr.split_at_mut_unchecked(2);\n     assert_eq!(&*left, [1, 0]);\n     assert_eq!(&*right, [3, 0, 5, 6]);\n     (&mut *left)[1] = 2;\n     (&mut *right)[1] = 4;\n }\n assert_eq!(v, [1, 2, 3, 4, 5, 6]);\n ```\n"
}