{
  "name": "core::<wtf8::EncodeWide<'_> as fmt::Debug>::fmt",
  "span": "$library/core/src/wtf8.rs:576:5: 576:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        struct CodeUnit(u16);\n        impl fmt::Debug for CodeUnit {\n            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                // This output attempts to balance readability with precision.\n                // Render characters which take only one WTF-16 code unit using\n                // `char` syntax and everything else as code units with hex\n                // integer syntax (including paired and unpaired surrogate\n                // halves). Since Rust has no `char`-like type for WTF-16, this\n                // isn't perfect, so if this output isn't suitable, it is open\n                // to being changed (see #140153).\n                match char::from_u32(self.0 as u32) {\n                    Some(c) => write!(f, \"{c:?}\"),\n                    None => write!(f, \"0x{:04X}\", self.0),\n                }\n            }\n        }\n\n        write!(f, \"EncodeWide(\")?;\n        f.debug_list().entries(self.clone().map(CodeUnit)).finish()?;\n        write!(f, \")\")?;\n        Ok(())\n    }"
}