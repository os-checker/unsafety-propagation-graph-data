{
  "name": "core::sync::atomic::AtomicPtr::<T>::fetch_and",
  "span": "$library/core/src/sync/atomic.rs:2459:5: 2459:67",
  "doc": " Performs a bitwise \"and\" operation on the address of the current\n pointer, and the argument `val`, and stores a pointer with provenance of\n the current pointer and the resulting address.\n\n This is equivalent to using [`map_addr`] to atomically perform\n `ptr = ptr.map_addr(|a| a & val)`. This can be used in tagged\n pointer schemes to atomically unset tag bits.\n\n **Caveat**: This operation returns the previous value. To compute the\n stored value without losing provenance, you may use [`map_addr`]. For\n example: `a.fetch_and(val).map_addr(|a| a & val)`.\n\n `fetch_and` takes an [`Ordering`] argument which describes the memory\n ordering of this operation. All ordering modes are possible. Note that\n using [`Acquire`] makes the store part of this operation [`Relaxed`],\n and using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic\n operations on [`AtomicPtr`].\n\n This API and its claimed semantics are part of the Strict Provenance\n experiment, see the [module documentation for `ptr`][crate::ptr] for\n details.\n\n [`map_addr`]: pointer::map_addr\n\n # Examples\n\n ```\n use core::sync::atomic::{AtomicPtr, Ordering};\n\n let pointer = &mut 3i64 as *mut i64;\n // A tagged pointer\n let atom = AtomicPtr::<i64>::new(pointer.map_addr(|a| a | 1));\n assert_eq!(atom.fetch_or(1, Ordering::Relaxed).addr() & 1, 1);\n // Untag, and extract the previously tagged pointer.\n let untagged = atom.fetch_and(!1, Ordering::Relaxed)\n     .map_addr(|a| a & !1);\n assert_eq!(untagged, pointer);\n ```\n"
}