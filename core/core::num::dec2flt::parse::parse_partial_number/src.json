{
  "name": "core::num::dec2flt::parse::parse_partial_number",
  "span": "$library/core/src/num/dec2flt/parse.rs:103:1: 103:66",
  "src": "fn parse_partial_number(mut s: &[u8]) -> Option<(Decimal, usize)> {\n    debug_assert!(!s.is_empty());\n\n    // parse initial digits before dot\n    let mut mantissa = 0_u64;\n    let start = s;\n    let tmp = try_parse_digits(s, mantissa);\n    s = tmp.0;\n    mantissa = tmp.1;\n    let mut n_digits = s.offset_from(start);\n\n    // handle dot with the following digits\n    let mut n_after_dot = 0;\n    let mut exponent = 0_i64;\n    let int_end = s;\n\n    if let Some((&b'.', s_next)) = s.split_first() {\n        s = s_next;\n        let before = s;\n        let tmp = try_parse_digits(s, mantissa);\n        s = tmp.0;\n        mantissa = tmp.1;\n        n_after_dot = s.offset_from(before);\n        exponent = -n_after_dot as i64;\n    }\n\n    n_digits += n_after_dot;\n    if n_digits == 0 {\n        return None;\n    }\n\n    // handle scientific format\n    let mut exp_number = 0_i64;\n    if let Some((&c, s_next)) = s.split_first() {\n        if c == b'e' || c == b'E' {\n            s = s_next;\n            // If None, we have no trailing digits after exponent, or an invalid float.\n            exp_number = parse_scientific(&mut s)?;\n            exponent += exp_number;\n        }\n    }\n\n    let len = s.offset_from(start) as _;\n\n    // handle uncommon case with many digits\n    if n_digits <= 19 {\n        return Some((Decimal { exponent, mantissa, negative: false, many_digits: false }, len));\n    }\n\n    n_digits -= 19;\n    let mut many_digits = false;\n    let mut p = start;\n    while let Some((&c, p_next)) = p.split_first() {\n        if c == b'.' || c == b'0' {\n            n_digits -= c.saturating_sub(b'0' - 1) as isize;\n            p = p_next;\n        } else {\n            break;\n        }\n    }\n    if n_digits > 0 {\n        // at this point we have more than 19 significant digits, let's try again\n        many_digits = true;\n        mantissa = 0;\n        let mut s = start;\n        try_parse_19digits(&mut s, &mut mantissa);\n        exponent = if mantissa >= MIN_19DIGIT_INT {\n            // big int\n            int_end.offset_from(s)\n        } else {\n            s = &s[1..];\n            let before = s;\n            try_parse_19digits(&mut s, &mut mantissa);\n            -s.offset_from(before)\n        } as i64;\n        // add back the explicit part\n        exponent += exp_number;\n    }\n\n    Some((Decimal { exponent, mantissa, negative: false, many_digits }, len))\n}"
}