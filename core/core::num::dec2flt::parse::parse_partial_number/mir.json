{
  "name": "core::num::dec2flt::parse::parse_partial_number",
  "span": "$library/core/src/num/dec2flt/parse.rs:103:1: 103:66",
  "mir": "fn core::num::dec2flt::parse::parse_partial_number(_1: &[u8]) -> option::Option<(num::dec2flt::decimal::Decimal, usize)> {\n    let mut _0: option::Option<(num::dec2flt::decimal::Decimal, usize)>;\n    let mut _2: bool;\n    let mut _3: &[u8];\n    let mut _4: !;\n    let mut _5: u64;\n    let  _6: &[u8];\n    let  _7: (&[u8], u64);\n    let mut _8: &[u8];\n    let mut _9: u64;\n    let mut _10: u64;\n    let mut _11: isize;\n    let mut _12: &[u8];\n    let mut _13: isize;\n    let mut _14: i64;\n    let  _15: &[u8];\n    let mut _16: option::Option<(&u8, &[u8])>;\n    let mut _17: &[u8];\n    let mut _18: isize;\n    let  _19: &[u8];\n    let  _20: &[u8];\n    let  _21: (&[u8], u64);\n    let mut _22: &[u8];\n    let mut _23: u64;\n    let mut _24: u64;\n    let mut _25: isize;\n    let mut _26: &[u8];\n    let mut _27: isize;\n    let mut _28: isize;\n    let mut _29: bool;\n    let mut _30: isize;\n    let mut _31: (isize, bool);\n    let mut _32: isize;\n    let mut _33: i64;\n    let mut _34: option::Option<(&u8, &[u8])>;\n    let mut _35: &[u8];\n    let mut _36: isize;\n    let  _37: u8;\n    let  _38: &[u8];\n    let mut _39: ops::control_flow::ControlFlow<option::Option<convert::Infallible>, i64>;\n    let mut _40: option::Option<i64>;\n    let mut _41: &mut &[u8];\n    let mut _42: isize;\n    let  _43: i64;\n    let mut _44: i64;\n    let mut _45: (i64, bool);\n    let mut _46: usize;\n    let mut _47: isize;\n    let mut _48: &[u8];\n    let mut _49: bool;\n    let mut _50: isize;\n    let mut _51: (num::dec2flt::decimal::Decimal, usize);\n    let mut _52: num::dec2flt::decimal::Decimal;\n    let mut _53: i64;\n    let mut _54: u64;\n    let mut _55: (isize, bool);\n    let mut _56: bool;\n    let mut _57: &[u8];\n    let mut _58: option::Option<(&u8, &[u8])>;\n    let mut _59: &[u8];\n    let mut _60: isize;\n    let  _61: u8;\n    let  _62: &[u8];\n    let mut _63: isize;\n    let mut _64: u8;\n    let mut _65: u8;\n    let mut _66: (u8, bool);\n    let mut _67: (isize, bool);\n    let mut _68: bool;\n    let mut _69: isize;\n    let mut _70: &[u8];\n    let  _71: ();\n    let mut _72: &mut &[u8];\n    let mut _73: &mut u64;\n    let mut _74: isize;\n    let mut _75: bool;\n    let mut _76: u64;\n    let mut _77: &[u8];\n    let  _78: &[u8];\n    let mut _79: &[u8];\n    let mut _80: ops::range::RangeFrom<usize>;\n    let  _81: &[u8];\n    let  _82: ();\n    let mut _83: &mut &[u8];\n    let mut _84: &mut u64;\n    let mut _85: isize;\n    let mut _86: &[u8];\n    let mut _87: bool;\n    let mut _88: i64;\n    let mut _89: (i64, bool);\n    let mut _90: (num::dec2flt::decimal::Decimal, usize);\n    let mut _91: num::dec2flt::decimal::Decimal;\n    let mut _92: i64;\n    let mut _93: u64;\n    let mut _94: bool;\n    let mut _95: &[u8];\n    let mut _96: &u8;\n    let mut _97: &[u8];\n    let mut _98: &u8;\n    let mut _99: &u8;\n    debug s => _1;\n    debug mantissa => _5;\n    debug start => _6;\n    debug tmp => _7;\n    debug n_digits => _11;\n    debug n_after_dot => _13;\n    debug exponent => _14;\n    debug int_end => _15;\n    debug s_next => _19;\n    debug before => _20;\n    debug tmp => _21;\n    debug exp_number => _33;\n    debug c => _37;\n    debug s_next => _38;\n    debug residual => option::Option::<convert::Infallible>::None;\n    debug val => _43;\n    debug len => _46;\n    debug many_digits => _56;\n    debug p => _57;\n    debug c => _61;\n    debug p_next => _62;\n    debug s => _70;\n    debug before => _81;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = _1;\n        _2 = slice::<impl [u8]>::is_empty(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = panicking::panic(\"assertion failed: !s.is_empty()\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_5);\n        _5 = 0_u64;\n        _6 = _1;\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = _1;\n        StorageLive(_9);\n        _9 = _5;\n        _7 = num::dec2flt::parse::try_parse_digits(move _8, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _95 = (_7.0: &[u8]);\n        _1 = _95;\n        StorageLive(_10);\n        _10 = (_7.1: u64);\n        _5 = move _10;\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = _1;\n        _11 = <[u8] as num::dec2flt::common::ByteSlice>::offset_from(move _12, _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageLive(_13);\n        _13 = 0_isize;\n        StorageLive(_14);\n        _14 = 0_i64;\n        _15 = _1;\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _1;\n        _16 = slice::<impl [u8]>::split_first(move _17) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_17);\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [1: bb7, 0: bb12, otherwise: bb25];\n    }\n    bb7: {\n        _96 = (((_16 as variant#1).0: (&u8, &[u8])).0: &u8);\n        switchInt((*_96)) -> [46: bb8, otherwise: bb12];\n    }\n    bb8: {\n        _19 = (((_16 as variant#1).0: (&u8, &[u8])).1: &[u8]);\n        _1 = _19;\n        _20 = _1;\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _1;\n        StorageLive(_23);\n        _23 = _5;\n        _21 = num::dec2flt::parse::try_parse_digits(move _22, move _23) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_23);\n        StorageDead(_22);\n        _97 = (_21.0: &[u8]);\n        _1 = _97;\n        StorageLive(_24);\n        _24 = (_21.1: u64);\n        _5 = move _24;\n        StorageDead(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = _1;\n        _25 = <[u8] as num::dec2flt::common::ByteSlice>::offset_from(move _26, _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_26);\n        _13 = move _25;\n        StorageDead(_25);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _13;\n        _29 = Eq(_28, isize::MIN);\n        assert(!move _29, \"attempt to negate `{}`, which would overflow\", _28) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _27 = Neg(move _28);\n        StorageDead(_28);\n        _14 = move _27 as i64;\n        StorageDead(_27);\n        StorageDead(_21);\n        StorageDead(_16);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_16);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_30);\n        _30 = _13;\n        _31 = CheckedAdd(_11, _30);\n        assert(!move (_31.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _11, move _30) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _11 = move (_31.0: isize);\n        StorageDead(_30);\n        StorageLive(_32);\n        _32 = _11;\n        switchInt(move _32) -> [0: bb15, otherwise: bb16];\n    }\n    bb15: {\n        StorageDead(_32);\n        _0 = option::Option::None;\n        goto -> bb65;\n    }\n    bb16: {\n        StorageDead(_32);\n        StorageLive(_33);\n        _33 = 0_i64;\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = _1;\n        _34 = slice::<impl [u8]>::split_first(move _35) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_35);\n        _36 = discriminant(_34);\n        switchInt(move _36) -> [1: bb18, 0: bb32, otherwise: bb25];\n    }\n    bb18: {\n        _98 = (((_34 as variant#1).0: (&u8, &[u8])).0: &u8);\n        _37 = (*_98);\n        _38 = (((_34 as variant#1).0: (&u8, &[u8])).1: &[u8]);\n        switchInt(_37) -> [101: bb19, otherwise: bb20];\n    }\n    bb19: {\n        goto -> bb22;\n    }\n    bb20: {\n        switchInt(_37) -> [69: bb21, otherwise: bb30];\n    }\n    bb21: {\n        goto -> bb22;\n    }\n    bb22: {\n        _1 = _38;\n        StorageLive(_39);\n        StorageLive(_40);\n        _41 = &mut _1;\n        _40 = num::dec2flt::parse::parse_scientific(_41) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _39 = <option::Option<i64> as ops::try_trait::Try>::branch(move _40) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_40);\n        _42 = discriminant(_39);\n        switchInt(move _42) -> [0: bb26, 1: bb27, otherwise: bb25];\n    }\n    bb25: {\n        unreachable;\n    }\n    bb26: {\n        _43 = ((_39 as variant#0).0: i64);\n        _33 = _43;\n        StorageDead(_39);\n        StorageLive(_44);\n        _44 = _33;\n        _45 = CheckedAdd(_14, _44);\n        assert(!move (_45.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, move _44) -> [success: bb29, unwind unreachable];\n    }\n    bb27: {\n        _0 = <option::Option<(num::dec2flt::decimal::Decimal, usize)> as ops::try_trait::FromResidual<option::Option<convert::Infallible>>>::from_residual(option::Option::<convert::Infallible>::None) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_39);\n        StorageDead(_34);\n        goto -> bb64;\n    }\n    bb29: {\n        _14 = move (_45.0: i64);\n        StorageDead(_44);\n        goto -> bb31;\n    }\n    bb30: {\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_34);\n        goto -> bb33;\n    }\n    bb32: {\n        StorageDead(_34);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = _1;\n        _47 = <[u8] as num::dec2flt::common::ByteSlice>::offset_from(move _48, _6) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_48);\n        _46 = move _47 as usize;\n        StorageDead(_47);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = _11;\n        _49 = Le(move _50, 19_isize);\n        switchInt(move _49) -> [0: bb36, otherwise: bb35];\n    }\n    bb35: {\n        StorageDead(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = _14;\n        StorageLive(_54);\n        _54 = _5;\n        _52 = Decimal(move _53, move _54, false, false);\n        StorageDead(_54);\n        StorageDead(_53);\n        _51 = (move _52, _46);\n        StorageDead(_52);\n        _0 = option::Option::Some(move _51);\n        StorageDead(_51);\n        StorageDead(_49);\n        goto -> bb64;\n    }\n    bb36: {\n        StorageDead(_50);\n        StorageDead(_49);\n        _55 = CheckedSub(_11, 19_isize);\n        assert(!move (_55.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _11, 19_isize) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _11 = move (_55.0: isize);\n        StorageLive(_56);\n        _56 = false;\n        StorageLive(_57);\n        _57 = _6;\n        goto -> bb38;\n    }\n    bb38: {\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = _57;\n        _58 = slice::<impl [u8]>::split_first(move _59) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_59);\n        _60 = discriminant(_58);\n        switchInt(move _60) -> [1: bb40, 0: bb49, otherwise: bb25];\n    }\n    bb40: {\n        _99 = (((_58 as variant#1).0: (&u8, &[u8])).0: &u8);\n        _61 = (*_99);\n        _62 = (((_58 as variant#1).0: (&u8, &[u8])).1: &[u8]);\n        switchInt(_61) -> [46: bb41, otherwise: bb42];\n    }\n    bb41: {\n        goto -> bb44;\n    }\n    bb42: {\n        switchInt(_61) -> [48: bb43, otherwise: bb48];\n    }\n    bb43: {\n        goto -> bb44;\n    }\n    bb44: {\n        StorageLive(_63);\n        StorageLive(_64);\n        StorageLive(_65);\n        _66 = CheckedSub(48_u8, 1_u8);\n        assert(!move (_66.1: bool), \"attempt to compute `{} - {}`, which would overflow\", 48_u8, 1_u8) -> [success: bb45, unwind unreachable];\n    }\n    bb45: {\n        _65 = move (_66.0: u8);\n        _64 = num::<impl u8>::saturating_sub(_61, move _65) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_65);\n        _63 = move _64 as isize;\n        StorageDead(_64);\n        _67 = CheckedSub(_11, _63);\n        assert(!move (_67.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _11, move _63) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _11 = move (_67.0: isize);\n        StorageDead(_63);\n        _57 = _62;\n        StorageDead(_58);\n        goto -> bb38;\n    }\n    bb48: {\n        StorageDead(_58);\n        goto -> bb50;\n    }\n    bb49: {\n        StorageDead(_58);\n        goto -> bb50;\n    }\n    bb50: {\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = _11;\n        _68 = Gt(move _69, 0_isize);\n        switchInt(move _68) -> [0: bb62, otherwise: bb51];\n    }\n    bb51: {\n        StorageDead(_69);\n        _56 = true;\n        _5 = 0_u64;\n        StorageLive(_70);\n        _70 = _6;\n        _72 = &mut _70;\n        _73 = &mut _5;\n        _71 = num::dec2flt::parse::try_parse_19digits(_72, _73) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = _5;\n        _75 = Ge(move _76, num::dec2flt::parse::MIN_19DIGIT_INT);\n        switchInt(move _75) -> [0: bb55, otherwise: bb53];\n    }\n    bb53: {\n        StorageDead(_76);\n        StorageLive(_77);\n        _77 = _70;\n        _74 = <[u8] as num::dec2flt::common::ByteSlice>::offset_from(_15, move _77) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_77);\n        goto -> bb60;\n    }\n    bb55: {\n        StorageDead(_76);\n        StorageLive(_79);\n        _79 = _70;\n        StorageLive(_80);\n        _80 = RangeFrom(1_usize);\n        _78 = <[u8] as ops::index::Index<ops::range::RangeFrom<usize>>>::index(move _79, move _80) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_80);\n        StorageDead(_79);\n        _70 = _78;\n        _81 = _70;\n        _83 = &mut _70;\n        _84 = &mut _5;\n        _82 = num::dec2flt::parse::try_parse_19digits(_83, _84) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = _70;\n        _85 = <[u8] as num::dec2flt::common::ByteSlice>::offset_from(move _86, _81) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_86);\n        _87 = Eq(_85, isize::MIN);\n        assert(!move _87, \"attempt to negate `{}`, which would overflow\", _85) -> [success: bb59, unwind unreachable];\n    }\n    bb59: {\n        _74 = Neg(move _85);\n        StorageDead(_85);\n        goto -> bb60;\n    }\n    bb60: {\n        StorageDead(_75);\n        _14 = move _74 as i64;\n        StorageDead(_74);\n        StorageLive(_88);\n        _88 = _33;\n        _89 = CheckedAdd(_14, _88);\n        assert(!move (_89.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _14, move _88) -> [success: bb61, unwind unreachable];\n    }\n    bb61: {\n        _14 = move (_89.0: i64);\n        StorageDead(_88);\n        StorageDead(_70);\n        goto -> bb63;\n    }\n    bb62: {\n        StorageDead(_69);\n        goto -> bb63;\n    }\n    bb63: {\n        StorageDead(_68);\n        StorageLive(_90);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = _14;\n        StorageLive(_93);\n        _93 = _5;\n        StorageLive(_94);\n        _94 = _56;\n        _91 = Decimal(move _92, move _93, false, move _94);\n        StorageDead(_94);\n        StorageDead(_93);\n        StorageDead(_92);\n        _90 = (move _91, _46);\n        StorageDead(_91);\n        _0 = option::Option::Some(move _90);\n        StorageDead(_90);\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_33);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb66;\n    }\n    bb64: {\n        StorageDead(_33);\n        goto -> bb65;\n    }\n    bb65: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb66;\n    }\n    bb66: {\n        return;\n    }\n}\n"
}