{
  "name": "core::slice::<impl [T]>::binary_search_by_key",
  "span": "$library/core/src/slice/mod.rs:3068:5: 3071:16",
  "doc": " Binary searches this slice with a key extraction function.\n\n Assumes that the slice is sorted by the key, for instance with\n [`sort_by_key`] using the same key extraction function.\n If the slice is not sorted by the key, the returned result is\n unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n\n [`sort_by_key`]: slice::sort_by_key\n [`binary_search`]: slice::binary_search\n [`binary_search_by`]: slice::binary_search_by\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements in a slice of pairs sorted by\n their second elements. The first is found, with a uniquely\n determined position; the second and third are not found; the\n fourth could match any position in `[1, 4]`.\n\n ```\n let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n          (1, 21), (2, 34), (4, 55)];\n\n assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));\n assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));\n assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));\n let r = s.binary_search_by_key(&1, |&(a, b)| b);\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n"
}