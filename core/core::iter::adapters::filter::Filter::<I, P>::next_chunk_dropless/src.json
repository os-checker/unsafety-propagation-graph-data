{
  "name": "core::iter::adapters::filter::Filter::<I, P>::next_chunk_dropless",
  "span": "$library/core/src/iter/adapters/filter.rs:38:5: 40:59",
  "src": "fn next_chunk_dropless<const N: usize>(\n        &mut self,\n    ) -> Result<[I::Item; N], array::IntoIter<I::Item, N>> {\n        let mut array: [MaybeUninit<I::Item>; N] = [const { MaybeUninit::uninit() }; N];\n        let mut initialized = 0;\n\n        let result = self.iter.try_for_each(|element| {\n            let idx = initialized;\n            // branchless index update combined with unconditionally copying the value even when\n            // it is filtered reduces branching and dependencies in the loop.\n            initialized = idx + (self.predicate)(&element) as usize;\n            // SAFETY: Loop conditions ensure the index is in bounds.\n            unsafe { array.get_unchecked_mut(idx) }.write(element);\n\n            if initialized < N { ControlFlow::Continue(()) } else { ControlFlow::Break(()) }\n        });\n\n        match result {\n            ControlFlow::Break(()) => {\n                // SAFETY: The loop above is only explicitly broken when the array has been fully initialized\n                Ok(unsafe { MaybeUninit::array_assume_init(array) })\n            }\n            ControlFlow::Continue(()) => {\n                // SAFETY: The range is in bounds since the loop breaks when reaching N elements.\n                Err(unsafe { array::IntoIter::new_unchecked(array, 0..initialized) })\n            }\n        }\n    }"
}