{
  "name": "core::<net::ip_addr::Ipv4Addr as fmt::Display>::fmt",
  "span": "$library/core/src/net/ip_addr.rs:1137:5: 1137:63",
  "src": "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let octets = self.octets();\n\n        // If there are no alignment requirements, write the IP address directly to `f`.\n        // Otherwise, write it to a local buffer and then use `f.pad`.\n        if fmt.precision().is_none() && fmt.width().is_none() {\n            write!(fmt, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3])\n        } else {\n            const LONGEST_IPV4_ADDR: &str = \"255.255.255.255\";\n\n            let mut buf = DisplayBuffer::<{ LONGEST_IPV4_ADDR.len() }>::new();\n            // Buffer is long enough for the longest possible IPv4 address, so this should never fail.\n            write!(buf, \"{}.{}.{}.{}\", octets[0], octets[1], octets[2], octets[3]).unwrap();\n\n            fmt.pad(buf.as_str())\n        }\n    }"
}