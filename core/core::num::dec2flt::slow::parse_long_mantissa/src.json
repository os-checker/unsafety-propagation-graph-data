{
  "name": "core::num::dec2flt::slow::parse_long_mantissa",
  "span": "$library/core/src/num/dec2flt/slow.rs:26:1: 26:69",
  "src": "pub(crate) fn parse_long_mantissa<F: RawFloat>(s: &[u8]) -> BiasedFp {\n    const MAX_SHIFT: usize = 60;\n    const NUM_POWERS: usize = 19;\n    const POWERS: [u8; 19] =\n        [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36, 39, 43, 46, 49, 53, 56, 59];\n\n    let get_shift = |n| {\n        if n < NUM_POWERS { POWERS[n] as usize } else { MAX_SHIFT }\n    };\n\n    let fp_zero = BiasedFp::zero_pow2(0);\n    let fp_inf = BiasedFp::zero_pow2(F::INFINITE_POWER);\n\n    let mut d = parse_decimal_seq(s);\n\n    // Short-circuit if the value can only be a literal 0 or infinity.\n    if d.num_digits == 0 || d.decimal_point < -324 {\n        return fp_zero;\n    } else if d.decimal_point >= 310 {\n        return fp_inf;\n    }\n    let mut exp2 = 0_i32;\n    // Shift right toward (1/2 ... 1].\n    while d.decimal_point > 0 {\n        let n = d.decimal_point as usize;\n        let shift = get_shift(n);\n        d.right_shift(shift);\n        if d.decimal_point < -DecimalSeq::DECIMAL_POINT_RANGE {\n            return fp_zero;\n        }\n        exp2 += shift as i32;\n    }\n    // Shift left toward (1/2 ... 1].\n    while d.decimal_point <= 0 {\n        let shift = if d.decimal_point == 0 {\n            match d.digits[0] {\n                digit if digit >= 5 => break,\n                0 | 1 => 2,\n                _ => 1,\n            }\n        } else {\n            get_shift((-d.decimal_point) as _)\n        };\n        d.left_shift(shift);\n        if d.decimal_point > DecimalSeq::DECIMAL_POINT_RANGE {\n            return fp_inf;\n        }\n        exp2 -= shift as i32;\n    }\n    // We are now in the range [1/2 ... 1] but the binary format uses [1 ... 2].\n    exp2 -= 1;\n    while F::EXP_MIN > exp2 {\n        let mut n = (F::EXP_MIN - exp2) as usize;\n        if n > MAX_SHIFT {\n            n = MAX_SHIFT;\n        }\n        d.right_shift(n);\n        exp2 += n as i32;\n    }\n    if (exp2 - F::EXP_MIN + 1) >= F::INFINITE_POWER {\n        return fp_inf;\n    }\n    // Shift the decimal to the hidden bit, and then round the value\n    // to get the high mantissa+1 bits.\n    d.left_shift(F::SIG_BITS as usize + 1);\n    let mut mantissa = d.round();\n    if mantissa >= (1_u64 << (F::SIG_BITS + 1)) {\n        // Rounding up overflowed to the carry bit, need to\n        // shift back to the hidden bit.\n        d.right_shift(1);\n        exp2 += 1;\n        mantissa = d.round();\n        if (exp2 - F::EXP_MIN + 1) >= F::INFINITE_POWER {\n            return fp_inf;\n        }\n    }\n    let mut power2 = exp2 - F::EXP_MIN + 1;\n    if mantissa < (1_u64 << F::SIG_BITS) {\n        power2 -= 1;\n    }\n    // Zero out all the bits above the explicit mantissa bits.\n    mantissa &= (1_u64 << F::SIG_BITS) - 1;\n    BiasedFp { m: mantissa, p_biased: power2 }\n}"
}