{
  "name": "core::iter::sources::once::once",
  "span": "$library/core/src/iter/sources/once.rs:56:1: 56:36",
  "doc": " Creates an iterator that yields an element exactly once.\n\n This is commonly used to adapt a single value into a [`chain()`] of other\n kinds of iteration. Maybe you have an iterator that covers almost\n everything, but you need an extra special case. Maybe you have a function\n which works on iterators, but you only need to process one value.\n\n [`chain()`]: Iterator::chain\n\n # Examples\n\n Basic usage:\n\n ```\n use std::iter;\n\n // one is the loneliest number\n let mut one = iter::once(1);\n\n assert_eq!(Some(1), one.next());\n\n // just one, that's all we get\n assert_eq!(None, one.next());\n ```\n\n Chaining together with another iterator. Let's say that we want to iterate\n over each file of the `.foo` directory, but also a configuration file,\n `.foorc`:\n\n ```no_run\n use std::iter;\n use std::fs;\n use std::path::PathBuf;\n\n let dirs = fs::read_dir(\".foo\")?;\n\n // we need to convert from an iterator of DirEntry-s to an iterator of\n // PathBufs, so we use map\n let dirs = dirs.map(|file| file.unwrap().path());\n\n // now, our iterator just for our config file\n let config = iter::once(PathBuf::from(\".foorc\"));\n\n // chain the two iterators together into one big iterator\n let files = dirs.chain(config);\n\n // this will give us all of the files in .foo as well as .foorc\n for f in files {\n     println!(\"{f:?}\");\n }\n # std::io::Result::Ok(())\n ```\n"
}