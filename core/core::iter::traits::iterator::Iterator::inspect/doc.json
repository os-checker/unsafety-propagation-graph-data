{
  "name": "core::iter::traits::iterator::Iterator::inspect",
  "span": "$library/core/src/iter/traits/iterator.rs:1859:5: 1862:31",
  "doc": " Does something with each element of an iterator, passing the value on.\n\n When using iterators, you'll often chain several of them together.\n While working on such code, you might want to check out what's\n happening at various parts in the pipeline. To do that, insert\n a call to `inspect()`.\n\n It's more common for `inspect()` to be used as a debugging tool than to\n exist in your final code, but applications may find it useful in certain\n situations when errors need to be logged before being discarded.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 4, 2, 3];\n\n // this iterator sequence is complex.\n let sum = a.iter()\n     .cloned()\n     .filter(|x| x % 2 == 0)\n     .fold(0, |sum, i| sum + i);\n\n println!(\"{sum}\");\n\n // let's add some inspect() calls to investigate what's happening\n let sum = a.iter()\n     .cloned()\n     .inspect(|x| println!(\"about to filter: {x}\"))\n     .filter(|x| x % 2 == 0)\n     .inspect(|x| println!(\"made it through filter: {x}\"))\n     .fold(0, |sum, i| sum + i);\n\n println!(\"{sum}\");\n ```\n\n This will print:\n\n ```text\n 6\n about to filter: 1\n about to filter: 4\n made it through filter: 4\n about to filter: 2\n made it through filter: 2\n about to filter: 3\n 6\n ```\n\n Logging errors before discarding them:\n\n ```\n let lines = [\"1\", \"2\", \"a\"];\n\n let sum: i32 = lines\n     .iter()\n     .map(|line| line.parse::<i32>())\n     .inspect(|num| {\n         if let Err(ref e) = *num {\n             println!(\"Parsing error: {e}\");\n         }\n     })\n     .filter_map(Result::ok)\n     .sum();\n\n println!(\"Sum: {sum}\");\n ```\n\n This will print:\n\n ```text\n Parsing error: invalid digit found in string\n Sum: 3\n ```\n"
}