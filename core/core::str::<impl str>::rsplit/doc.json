{
  "name": "core::str::<impl str>::rsplit",
  "span": "$library/core/src/str/mod.rs:1735:5: 1737:54",
  "doc": " Returns an iterator over substrings of the given string slice, separated\n by characters matched by a pattern and yielded in reverse order.\n\n The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Iterator behavior\n\n The returned iterator requires that the pattern supports a reverse\n search, and it will be a [`DoubleEndedIterator`] if a forward/reverse\n search yields the same elements.\n\n For iterating from the front, the [`split`] method can be used.\n\n [`split`]: str::split\n\n # Examples\n\n Simple patterns:\n\n ```\n let v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\n assert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n\n let v: Vec<&str> = \"\".rsplit('X').collect();\n assert_eq!(v, [\"\"]);\n\n let v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\n assert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n\n let v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\n assert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n ```\n\n A more complex pattern, using a closure:\n\n ```\n let v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\n assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n ```\n"
}