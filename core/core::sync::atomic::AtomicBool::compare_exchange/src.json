{
  "name": "core::sync::atomic::AtomicBool::compare_exchange",
  "span": "$library/core/src/sync/atomic.rs:918:5: 924:28",
  "src": "pub fn compare_exchange(\n        &self,\n        current: bool,\n        new: bool,\n        success: Ordering,\n        failure: Ordering,\n    ) -> Result<bool, bool> {\n        if EMULATE_ATOMIC_BOOL {\n            // Pick the strongest ordering from success and failure.\n            let order = match (success, failure) {\n                (SeqCst, _) => SeqCst,\n                (_, SeqCst) => SeqCst,\n                (AcqRel, _) => AcqRel,\n                (_, AcqRel) => {\n                    panic!(\"there is no such thing as an acquire-release failure ordering\")\n                }\n                (Release, Acquire) => AcqRel,\n                (Acquire, _) => Acquire,\n                (_, Acquire) => Acquire,\n                (Release, Relaxed) => Release,\n                (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n                (Relaxed, Relaxed) => Relaxed,\n            };\n            let old = if current == new {\n                // This is a no-op, but we still need to perform the operation\n                // for memory ordering reasons.\n                self.fetch_or(false, order)\n            } else {\n                // This sets the value to the new one and returns the old one.\n                self.swap(new, order)\n            };\n            if old == current { Ok(old) } else { Err(old) }\n        } else {\n            // SAFETY: data races are prevented by atomic intrinsics.\n            match unsafe {\n                atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n            } {\n                Ok(x) => Ok(x != 0),\n                Err(x) => Err(x != 0),\n            }\n        }\n    }"
}