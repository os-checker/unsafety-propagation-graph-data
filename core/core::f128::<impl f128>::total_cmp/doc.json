{
  "name": "core::f128::<impl f128>::total_cmp",
  "span": "$library/core/src/num/f128.rs:1209:5: 1209:72",
  "doc": " Returns the ordering between `self` and `other`.\n\n Unlike the standard partial comparison between floating point numbers,\n this comparison always produces an ordering in accordance to\n the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)\n floating point standard. The values are ordered in the following sequence:\n\n - negative quiet NaN\n - negative signaling NaN\n - negative infinity\n - negative numbers\n - negative subnormal numbers\n - negative zero\n - positive zero\n - positive subnormal numbers\n - positive numbers\n - positive infinity\n - positive signaling NaN\n - positive quiet NaN.\n\n The ordering established by this function does not always agree with the\n [`PartialOrd`] and [`PartialEq`] implementations of `f128`. For example,\n they consider negative and positive zero equal, while `total_cmp`\n doesn't.\n\n The interpretation of the signaling NaN bit follows the definition in\n the IEEE 754 standard, which may not match the interpretation by some of\n the older, non-conformant (e.g. MIPS) hardware implementations.\n\n # Example\n\n ```\n #![feature(f128)]\n\n struct GoodBoy {\n     name: &'static str,\n     weight: f128,\n }\n\n let mut bois = vec![\n     GoodBoy { name: \"Pucci\", weight: 0.1 },\n     GoodBoy { name: \"Woofer\", weight: 99.0 },\n     GoodBoy { name: \"Yapper\", weight: 10.0 },\n     GoodBoy { name: \"Chonk\", weight: f128::INFINITY },\n     GoodBoy { name: \"Abs. Unit\", weight: f128::NAN },\n     GoodBoy { name: \"Floaty\", weight: -5.0 },\n ];\n\n bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n\n // `f128::NAN` could be positive or negative, which will affect the sort order.\n if f128::NAN.is_sign_negative() {\n     bois.into_iter().map(|b| b.weight)\n         .zip([f128::NAN, -5.0, 0.1, 10.0, 99.0, f128::INFINITY].iter())\n         .for_each(|(a, b)| assert_eq!(a.to_bits(), b.to_bits()))\n } else {\n     bois.into_iter().map(|b| b.weight)\n         .zip([-5.0, 0.1, 10.0, 99.0, f128::INFINITY, f128::NAN].iter())\n         .for_each(|(a, b)| assert_eq!(a.to_bits(), b.to_bits()))\n }\n ```\n"
}