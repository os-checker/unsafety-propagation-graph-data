{
  "name": "core::str::slice_error_fail_rt",
  "span": "$library/core/src/str/mod.rs:83:1: 83:63",
  "src": "fn slice_error_fail_rt(s: &str, begin: usize, end: usize) -> ! {\n    const MAX_DISPLAY_LENGTH: usize = 256;\n    let trunc_len = s.floor_char_boundary(MAX_DISPLAY_LENGTH);\n    let s_trunc = &s[..trunc_len];\n    let ellipsis = if trunc_len < s.len() { \"[...]\" } else { \"\" };\n\n    // 1. out of bounds\n    if begin > s.len() || end > s.len() {\n        let oob_index = if begin > s.len() { begin } else { end };\n        panic!(\"byte index {oob_index} is out of bounds of `{s_trunc}`{ellipsis}\");\n    }\n\n    // 2. begin <= end\n    assert!(\n        begin <= end,\n        \"begin <= end ({} <= {}) when slicing `{}`{}\",\n        begin,\n        end,\n        s_trunc,\n        ellipsis\n    );\n\n    // 3. character boundary\n    let index = if !s.is_char_boundary(begin) { begin } else { end };\n    // find the character\n    let char_start = s.floor_char_boundary(index);\n    // `char_start` must be less than len and a char boundary\n    let ch = s[char_start..].chars().next().unwrap();\n    let char_range = char_start..char_start + ch.len_utf8();\n    panic!(\n        \"byte index {} is not a char boundary; it is inside {:?} (bytes {:?}) of `{}`{}\",\n        index, ch, char_range, s_trunc, ellipsis\n    );\n}"
}