{
  "name": "core::mem::conjure_zst",
  "span": "$library/core/src/mem/mod.rs:1476:1: 1476:42",
  "doc": " Create a fresh instance of the inhabited ZST type `T`.\n\n Prefer this to [`zeroed`] or [`uninitialized`] or [`transmute_copy`]\n in places where you know that `T` is zero-sized, but don't have a bound\n (such as [`Default`]) that would allow you to instantiate it using safe code.\n\n If you're not sure whether `T` is an inhabited ZST, then you should be\n using [`MaybeUninit`], not this function.\n\n # Panics\n\n If `size_of::<T>() != 0`.\n\n # Safety\n\n - `T` must be *[inhabited]*, i.e. possible to construct. This means that types\n   like zero-variant enums and [`!`] are unsound to conjure.\n - You must use the value only in ways which do not violate any *safety*\n   invariants of the type.\n\n While it's easy to create a *valid* instance of an inhabited ZST, since having\n no bits in its representation means there's only one possible value, that\n doesn't mean that it's always *sound* to do so.\n\n For example, a library could design zero-sized tokens that are `!Default + !Clone`, limiting\n their creation to functions that initialize some state or establish a scope. Conjuring such a\n token could break invariants and lead to unsoundness.\n\n # Examples\n\n ```\n #![feature(mem_conjure_zst)]\n use std::mem::conjure_zst;\n\n assert_eq!(unsafe { conjure_zst::<()>() }, ());\n assert_eq!(unsafe { conjure_zst::<[i32; 0]>() }, []);\n ```\n\n [inhabited]: https://doc.rust-lang.org/reference/glossary.html#inhabited\n"
}