{
  "name": "core::ptr::non_null::NonNull::<T>::sub",
  "span": "$library/core/src/ptr/non_null.rs:729:5: 731:18",
  "doc": " Subtracts an offset from a pointer (convenience for\n `.offset((count as isize).wrapping_neg())`).\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let s: &str = \"123\";\n\n unsafe {\n     let end: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap().add(3);\n     println!(\"{}\", end.sub(1).read() as char);\n     println!(\"{}\", end.sub(2).read() as char);\n }\n ```\n"
}