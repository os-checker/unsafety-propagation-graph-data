{
  "name": "core::slice::sort::shared::smallsort::insertion_sort_shift_left",
  "span": "$library/core/src/slice/sort/shared/smallsort.rs:580:1: 584:2",
  "src": "pub fn insertion_sort_shift_left<T, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    offset: usize,\n    is_less: &mut F,\n) {\n    let len = v.len();\n    if offset == 0 || offset > len {\n        intrinsics::abort();\n    }\n\n    // SAFETY: see individual comments.\n    unsafe {\n        // We write this basic loop directly using pointers, as when we use a\n        // for loop LLVM likes to unroll this loop which we do not want.\n        // SAFETY: v_end is the one-past-end pointer, and we checked that\n        // offset <= len, thus tail is also in-bounds.\n        let v_base = v.as_mut_ptr();\n        let v_end = v_base.add(len);\n        let mut tail = v_base.add(offset);\n        while tail != v_end {\n            // SAFETY: v_base and tail are both valid pointers to elements, and\n            // v_base < tail since we checked offset != 0.\n            insert_tail(v_base, tail, is_less);\n\n            // SAFETY: we checked that tail is not yet the one-past-end pointer.\n            tail = tail.add(1);\n        }\n    }\n}"
}