{
  "name": "core::num::flt2dec::to_shortest_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:344:1: 354:70",
  "src": "pub fn to_shortest_str<'a, T, F>(\n    mut format_shortest: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>]) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 4);\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            if frac_digits > 0 {\n                // [0.][0000]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..2`.\n                    parts: unsafe { parts[..2].assume_init_ref() },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { parts[..1].assume_init_ref() },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let (buf, exp) = format_shortest(decoded, buf);\n            Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n        }\n    }\n}"
}