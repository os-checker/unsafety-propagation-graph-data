{
  "name": "core::<net::ip_addr::Ipv6Addr as fmt::Display>::fmt",
  "span": "$library/core/src/net/ip_addr.rs:2078:5: 2078:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // If there are no alignment requirements, write the IP address directly to `f`.\n        // Otherwise, write it to a local buffer and then use `f.pad`.\n        if f.precision().is_none() && f.width().is_none() {\n            let segments = self.segments();\n\n            if let Some(ipv4) = self.to_ipv4_mapped() {\n                write!(f, \"::ffff:{}\", ipv4)\n            } else {\n                #[derive(Copy, Clone, Default)]\n                struct Span {\n                    start: usize,\n                    len: usize,\n                }\n\n                // Find the inner 0 span\n                let zeroes = {\n                    let mut longest = Span::default();\n                    let mut current = Span::default();\n\n                    for (i, &segment) in segments.iter().enumerate() {\n                        if segment == 0 {\n                            if current.len == 0 {\n                                current.start = i;\n                            }\n\n                            current.len += 1;\n\n                            if current.len > longest.len {\n                                longest = current;\n                            }\n                        } else {\n                            current = Span::default();\n                        }\n                    }\n\n                    longest\n                };\n\n                /// Writes a colon-separated part of the address.\n                #[inline]\n                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n                    if let Some((first, tail)) = chunk.split_first() {\n                        write!(f, \"{:x}\", first)?;\n                        for segment in tail {\n                            f.write_char(':')?;\n                            write!(f, \"{:x}\", segment)?;\n                        }\n                    }\n                    Ok(())\n                }\n\n                if zeroes.len > 1 {\n                    fmt_subslice(f, &segments[..zeroes.start])?;\n                    f.write_str(\"::\")?;\n                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n                } else {\n                    fmt_subslice(f, &segments)\n                }\n            }\n        } else {\n            const LONGEST_IPV6_ADDR: &str = \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\";\n\n            let mut buf = DisplayBuffer::<{ LONGEST_IPV6_ADDR.len() }>::new();\n            // Buffer is long enough for the longest possible IPv6 address, so this should never fail.\n            write!(buf, \"{}\", self).unwrap();\n\n            f.pad(buf.as_str())\n        }\n    }"
}