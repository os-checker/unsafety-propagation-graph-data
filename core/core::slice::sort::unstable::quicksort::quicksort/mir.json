{
  "name": "core::slice::sort::unstable::quicksort::quicksort",
  "span": "$library/core/src/slice/sort/unstable/quicksort.rs:21:1: 27:30",
  "mir": "fn core::slice::sort::unstable::quicksort::quicksort(_1: &mut [T], _2: option::Option<&T>, _3: u32, _4: &mut F) -> () {\n    let mut _0: ();\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: &[T];\n    let mut _8: usize;\n    let  _9: ();\n    let mut _10: &mut [T];\n    let mut _11: u32;\n    let  _12: ();\n    let mut _13: &mut [T];\n    let mut _14: (u32, bool);\n    let  _15: usize;\n    let mut _16: &[T];\n    let mut _17: isize;\n    let  _18: &T;\n    let mut _19: bool;\n    let mut _20: (&T, &T);\n    let  _21: &T;\n    let mut _22: *const [T];\n    let mut _23: usize;\n    let mut _24: bool;\n    let  _25: usize;\n    let mut _26: &mut [T];\n    let mut _27: &mut {closure@$library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65};\n    let mut _28: {closure@$library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65};\n    let mut _29: &mut [T];\n    let mut _30: &mut [T];\n    let mut _31: ops::range::RangeFrom<usize>;\n    let mut _32: usize;\n    let mut _33: (usize, bool);\n    let mut _34: option::Option<&T>;\n    let  _35: usize;\n    let mut _36: &mut [T];\n    let mut _37: bool;\n    let mut _38: usize;\n    let mut _39: &[T];\n    let  _40: &mut [T];\n    let  _41: &mut [T];\n    let mut _42: (&mut [T], &mut [T]);\n    let mut _43: &mut [T];\n    let  _44: &mut [T];\n    let  _45: &mut [T];\n    let mut _46: (&mut [T], &mut [T]);\n    let  _47: &T;\n    let  _48: usize;\n    let mut _49: *const [T];\n    let mut _50: usize;\n    let mut _51: bool;\n    let  _52: ();\n    let mut _53: option::Option<&T>;\n    let mut _54: u32;\n    let mut _55: option::Option<&T>;\n    debug v => _1;\n    debug ancestor_pivot => _2;\n    debug limit => _3;\n    debug is_less => _4;\n    debug pivot_pos => _15;\n    debug p => _18;\n    debug num_lt => _25;\n    debug num_lt => _35;\n    debug left => _40;\n    debug right => _41;\n    debug pivot => _44;\n    debug right => _45;\n    debug pivot => _47;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = PtrMetadata(move _7);\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = <T as slice::sort::shared::smallsort::UnstableSmallSortTypeImpl>::small_sort_threshold() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = Le(move _6, move _8);\n        switchInt(move _5) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = _1;\n        _9 = <T as slice::sort::shared::smallsort::UnstableSmallSortTypeImpl>::small_sort::<F>(move _10, _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageDead(_5);\n        goto -> bb25;\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_11);\n        _11 = _3;\n        switchInt(move _11) -> [0: bb6, otherwise: bb7];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageLive(_13);\n        _13 = _1;\n        _12 = slice::sort::unstable::heapsort::heapsort::<T, F>(move _13, _4) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _14 = CheckedSub(_3, 1_u32);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, 1_u32) -> [success: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        goto -> bb25;\n    }\n    bb9: {\n        _3 = move (_14.0: u32);\n        StorageLive(_16);\n        _16 = &(*_1);\n        _15 = slice::sort::shared::pivot::choose_pivot::<T, F>(move _16, _4) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        _17 = discriminant(_2);\n        switchInt(move _17) -> [1: bb11, 0: bb19, otherwise: bb26];\n    }\n    bb11: {\n        _18 = ((_2 as variant#1).0: &T);\n        StorageLive(_19);\n        StorageLive(_20);\n        _22 = &raw const (fake) (*_1);\n        _23 = PtrMetadata(move _22);\n        _24 = Lt(_15, _23);\n        assert(move _24, \"index out of bounds: the length is {} but the index is {}\", move _23, _15) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _21 = &(*_1)[_15];\n        _20 = (_18, _21);\n        _19 = <F as ops::function::FnMut<(&T, &T)>>::call_mut(_4, move _20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _19) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb19;\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageLive(_26);\n        _26 = _1;\n        StorageLive(_28);\n        _28 = {closure@$library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65}(_4);\n        _27 = &mut _28;\n        _25 = slice::sort::unstable::quicksort::partition::<T, {closure@$library/core/src/slice/sort/unstable/quicksort.rs:52:59: 52:65}>(move _26, _15, _27) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        StorageDead(_28);\n        StorageLive(_30);\n        _30 = _1;\n        StorageLive(_31);\n        StorageLive(_32);\n        _33 = CheckedAdd(_25, 1_usize);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, 1_usize) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _32 = move (_33.0: usize);\n        _31 = RangeFrom(move _32);\n        StorageDead(_32);\n        _29 = <[T] as ops::index::IndexMut<ops::range::RangeFrom<usize>>>::index_mut(move _30, move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        StorageDead(_30);\n        _1 = _29;\n        StorageLive(_34);\n        _34 = option::Option::None;\n        _2 = move _34;\n        StorageDead(_34);\n        StorageDead(_19);\n        goto -> bb1;\n    }\n    bb19: {\n        StorageLive(_36);\n        _36 = _1;\n        _35 = slice::sort::unstable::quicksort::partition::<T, F>(move _36, _15, _4) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &(*_1);\n        _38 = PtrMetadata(move _39);\n        StorageDead(_39);\n        _37 = Lt(_35, move _38);\n        StorageDead(_38);\n        Intrinsic(Assume(Move(_37)));\n        StorageDead(_37);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = _1;\n        _42 = slice::<impl [T]>::split_at_mut(move _43, _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_43);\n        _40 = move (_42.0: &mut [T]);\n        _41 = move (_42.1: &mut [T]);\n        StorageDead(_42);\n        StorageLive(_46);\n        _46 = slice::<impl [T]>::split_at_mut(_41, 1_usize) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_44);\n        _44 = move (_46.0: &mut [T]);\n        _45 = move (_46.1: &mut [T]);\n        StorageDead(_46);\n        StorageLive(_48);\n        _48 = 0_usize;\n        _49 = &raw const (fake) (*_44);\n        _50 = PtrMetadata(move _49);\n        _51 = Lt(_48, _50);\n        assert(move _51, \"index out of bounds: the length is {} but the index is {}\", move _50, _48) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _47 = &(*_44)[_48];\n        StorageDead(_48);\n        StorageLive(_53);\n        _53 = _2;\n        StorageLive(_54);\n        _54 = _3;\n        _52 = slice::sort::unstable::quicksort::quicksort::<T, F>(_40, move _53, move _54, _4) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_54);\n        StorageDead(_53);\n        _1 = _45;\n        StorageLive(_55);\n        _55 = option::Option::Some(_47);\n        _2 = move _55;\n        StorageDead(_55);\n        StorageDead(_44);\n        goto -> bb1;\n    }\n    bb25: {\n        return;\n    }\n    bb26: {\n        unreachable;\n    }\n}\n"
}