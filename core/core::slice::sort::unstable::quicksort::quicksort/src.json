{
  "name": "core::slice::sort::unstable::quicksort::quicksort",
  "span": "$library/core/src/slice/sort/unstable/quicksort.rs:21:1: 27:30",
  "src": "pub(crate) fn quicksort<'a, T, F>(\n    mut v: &'a mut [T],\n    mut ancestor_pivot: Option<&'a T>,\n    mut limit: u32,\n    is_less: &mut F,\n) where\n    F: FnMut(&T, &T) -> bool,\n{\n    loop {\n        if v.len() <= T::small_sort_threshold() {\n            T::small_sort(v, is_less);\n            return;\n        }\n\n        // If too many bad pivot choices were made, simply fall back to heapsort in order to\n        // guarantee `O(N x log(N))` worst-case.\n        if limit == 0 {\n            heapsort::heapsort(v, is_less);\n            return;\n        }\n\n        limit -= 1;\n\n        // Choose a pivot and try guessing whether the slice is already sorted.\n        let pivot_pos = choose_pivot(v, is_less);\n\n        // If the chosen pivot is equal to the predecessor, then it's the smallest element in the\n        // slice. Partition the slice into elements equal to and elements greater than the pivot.\n        // This case is usually hit when the slice contains many duplicate elements.\n        if let Some(p) = ancestor_pivot {\n            if !is_less(p, &v[pivot_pos]) {\n                let num_lt = partition(v, pivot_pos, &mut |a, b| !is_less(b, a));\n\n                // Continue sorting elements greater than the pivot. We know that `num_lt` contains\n                // the pivot. So we can continue after `num_lt`.\n                v = &mut v[(num_lt + 1)..];\n                ancestor_pivot = None;\n                continue;\n            }\n        }\n\n        // Partition the slice.\n        let num_lt = partition(v, pivot_pos, is_less);\n        // SAFETY: partition ensures that `num_lt` will be in-bounds.\n        unsafe { intrinsics::assume(num_lt < v.len()) };\n\n        // Split the slice into `left`, `pivot`, and `right`.\n        let (left, right) = v.split_at_mut(num_lt);\n        let (pivot, right) = right.split_at_mut(1);\n        let pivot = &pivot[0];\n\n        // Recurse into the left side. We have a fixed recursion limit, testing shows no real\n        // benefit for recursing into the shorter side.\n        quicksort(left, ancestor_pivot, limit, is_less);\n\n        // Continue with the right side.\n        v = right;\n        ancestor_pivot = Some(pivot);\n    }\n}"
}