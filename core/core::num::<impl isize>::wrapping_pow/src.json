{
  "name": "core::num::<impl isize>::wrapping_pow",
  "span": "$library/core/src/num/int_macros.rs:2407:9: 2407:62",
  "src": "pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }"
}