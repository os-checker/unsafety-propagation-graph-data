{
  "name": "core::slice::<impl [T]>::as_rchunks_mut",
  "span": "$library/core/src/slice/mod.rs:1604:5: 1604:88",
  "doc": " Splits the slice into a slice of `N`-element arrays,\n starting at the end of the slice,\n and a remainder slice with length strictly less than `N`.\n\n The remainder is meaningful in the division sense.  Given\n `let (remainder, chunks) = slice.as_rchunks_mut()`, then:\n - `remainder.len()` equals `slice.len() % N`,\n - `chunks.len()` equals `slice.len() / N`, and\n - `slice.len()` equals `chunks.len() * N + remainder.len()`.\n\n You can flatten the chunks back into a slice-of-`T` with [`as_flattened_mut`].\n\n [`as_flattened_mut`]: slice::as_flattened_mut\n\n # Panics\n\n Panics if `N` is zero.\n\n Note that this check is against a const generic parameter, not a runtime\n value, and thus a particular monomorphization will either always panic\n or it will never panic.\n\n # Examples\n\n ```\n let v = &mut [0, 0, 0, 0, 0];\n let mut count = 1;\n\n let (remainder, chunks) = v.as_rchunks_mut();\n remainder[0] = 9;\n for chunk in chunks {\n     *chunk = [count; 2];\n     count += 1;\n }\n assert_eq!(v, &[9, 1, 1, 2, 2]);\n ```\n"
}