{
  "name": "core::fmt::num::<impl i128>::format_into",
  "span": "$library/core/src/fmt/num.rs:794:5: 794:64",
  "src": "pub fn format_into(self, buf: &mut NumBuffer<Self>) -> &str {\n        let diff = buf.capacity() - U128_MAX_DEC_N;\n        // FIXME: Once const generics are better, use `NumberBufferTrait::BUF_SIZE` as generic const\n        // for `fmt_u128_inner`.\n        //\n        // In the meantime, we have to use a slice starting at index 1 and add 1 to the returned\n        // offset to ensure the number is correctly generated at the end of the buffer.\n        let mut offset =\n            // SAFETY: `buf` will always be big enough to contain all digits.\n            unsafe { self.unsigned_abs()._fmt_inner(buf.buf.get_unchecked_mut(diff..)) };\n        // We put back the offset at the right position.\n        offset += diff;\n        // Only difference between signed and unsigned are these 4 lines.\n        if self < 0 {\n            offset -= 1;\n            // SAFETY: `buf` will always be big enough to contain all digits plus the minus sign.\n            unsafe {\n                buf.buf.get_unchecked_mut(offset).write(b'-');\n            }\n        }\n        // SAFETY: Starting from `offset`, all elements of the slice have been set.\n        unsafe { slice_buffer_to_str(&buf.buf, offset) }\n    }"
}