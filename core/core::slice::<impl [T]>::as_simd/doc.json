{
  "name": "core::slice::<impl [T]>::as_simd",
  "span": "$library/core/src/slice/mod.rs:4225:5: 4229:58",
  "doc": " Splits a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n\n This is a safe wrapper around [`slice::align_to`], so inherits the same\n guarantees as that method.\n\n # Panics\n\n This will panic if the size of the SIMD type is different from\n `LANES` times that of the scalar.\n\n At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n that from ever happening, as only power-of-two numbers of lanes are\n supported.  It's possible that, in the future, those restrictions might\n be lifted in a way that would make it possible to see panics from this\n method for something like `LANES == 3`.\n\n # Examples\n\n ```\n #![feature(portable_simd)]\n use core::simd::prelude::*;\n\n let short = &[1, 2, 3];\n let (prefix, middle, suffix) = short.as_simd::<4>();\n assert_eq!(middle, []); // Not enough elements for anything in the middle\n\n // They might be split in any possible way between prefix and suffix\n let it = prefix.iter().chain(suffix).copied();\n assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);\n\n fn basic_simd_sum(x: &[f32]) -> f32 {\n     use std::ops::Add;\n     let (prefix, middle, suffix) = x.as_simd();\n     let sums = f32x4::from_array([\n         prefix.iter().copied().sum(),\n         0.0,\n         0.0,\n         suffix.iter().copied().sum(),\n     ]);\n     let sums = middle.iter().copied().fold(sums, f32x4::add);\n     sums.reduce_sum()\n }\n\n let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();\n assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);\n ```\n"
}