{
  "name": "core::<bstr::ByteStr as fmt::Display>::fmt",
  "span": "$library/core/src/bstr/mod.rs:152:5: 152:61",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fn fmt_nopad(this: &ByteStr, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            for chunk in this.utf8_chunks() {\n                f.write_str(chunk.valid())?;\n                if !chunk.invalid().is_empty() {\n                    f.write_str(\"\\u{FFFD}\")?;\n                }\n            }\n            Ok(())\n        }\n\n        let Some(align) = f.align() else {\n            return fmt_nopad(self, f);\n        };\n        let nchars: usize = self\n            .utf8_chunks()\n            .map(|chunk| {\n                chunk.valid().chars().count() + if chunk.invalid().is_empty() { 0 } else { 1 }\n            })\n            .sum();\n        let padding = f.width().unwrap_or(0).saturating_sub(nchars);\n        let fill = f.fill();\n        let (lpad, rpad) = match align {\n            fmt::Alignment::Left => (0, padding),\n            fmt::Alignment::Right => (padding, 0),\n            fmt::Alignment::Center => {\n                let half = padding / 2;\n                (half, half + padding % 2)\n            }\n        };\n        for _ in 0..lpad {\n            write!(f, \"{fill}\")?;\n        }\n        fmt_nopad(self, f)?;\n        for _ in 0..rpad {\n            write!(f, \"{fill}\")?;\n        }\n\n        Ok(())\n    }"
}