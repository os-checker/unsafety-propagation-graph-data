{
  "name": "core::slice::sort::stable::driftsort_main",
  "span": "$library/core/src/slice/sort/stable/mod.rs:94:1: 94:96",
  "src": "fn driftsort_main<T, F: FnMut(&T, &T) -> bool, BufT: BufGuard<T>>(v: &mut [T], is_less: &mut F) {\n    // By allocating n elements of memory we can ensure the entire input can\n    // be sorted using stable quicksort, which allows better performance on\n    // random and low-cardinality distributions. However, we still want to\n    // reduce our memory usage to n - n / 2 for large inputs. We do this by scaling\n    // our allocation as max(n - n / 2, min(n, 8MB)), ensuring we scale like n for\n    // small inputs and n - n / 2 for large inputs, without a sudden drop off. We\n    // also need to ensure our alloc >= SMALL_SORT_GENERAL_SCRATCH_LEN, as the\n    // small-sort always needs this much memory.\n    //\n    // driftsort will produce unsorted runs of up to min_good_run_len, which\n    // is at most len - len / 2.\n    // Unsorted runs need to be processed by quicksort, which requires as much\n    // scratch space as the run length, therefore the scratch space must be at\n    // least len - len / 2.\n    // If min_good_run_len is ever modified, this code must be updated to allocate\n    // the correct scratch size for it.\n    const MAX_FULL_ALLOC_BYTES: usize = 8_000_000; // 8MB\n    let max_full_alloc = MAX_FULL_ALLOC_BYTES / size_of::<T>();\n    let len = v.len();\n    let alloc_len = cmp::max(\n        cmp::max(len - len / 2, cmp::min(len, max_full_alloc)),\n        SMALL_SORT_GENERAL_SCRATCH_LEN,\n    );\n\n    // For small inputs 4KiB of stack storage suffices, which allows us to avoid\n    // calling the (de-)allocator. Benchmarks showed this was quite beneficial.\n    let mut stack_buf = AlignedStorage::<T, 4096>::new();\n    let stack_scratch = stack_buf.as_uninit_slice_mut();\n    let mut heap_buf;\n    let scratch = if stack_scratch.len() >= alloc_len {\n        stack_scratch\n    } else {\n        heap_buf = BufT::with_capacity(alloc_len);\n        heap_buf.as_uninit_slice_mut()\n    };\n\n    // For small inputs using quicksort is not yet beneficial, and a single\n    // small-sort or two small-sorts plus a single merge outperforms it, so use\n    // eager mode.\n    let eager_sort = len <= T::small_sort_threshold() * 2;\n    crate::slice::sort::stable::drift::sort(v, scratch, eager_sort, is_less);\n}"
}