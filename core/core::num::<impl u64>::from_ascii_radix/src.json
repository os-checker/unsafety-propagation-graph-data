{
  "name": "core::num::<impl u64>::from_ascii_radix",
  "span": "$library/core/src/num/mod.rs:1573:13: 1573:100",
  "src": "pub const fn from_ascii_radix(src: &[u8], radix: u32) -> Result<$int_ty, ParseIntError> {\n                use self::IntErrorKind::*;\n                use self::ParseIntError as PIE;\n\n                if 2 > radix || radix > 36 {\n                    from_ascii_radix_panic(radix);\n                }\n\n                if src.is_empty() {\n                    return Err(PIE { kind: Empty });\n                }\n\n                #[allow(unused_comparisons)]\n                let is_signed_ty = 0 > <$int_ty>::MIN;\n\n                let (is_positive, mut digits) = match src {\n                    [b'+' | b'-'] => {\n                        return Err(PIE { kind: InvalidDigit });\n                    }\n                    [b'+', rest @ ..] => (true, rest),\n                    [b'-', rest @ ..] if is_signed_ty => (false, rest),\n                    _ => (true, src),\n                };\n\n                let mut result = 0;\n\n                macro_rules! unwrap_or_PIE {\n                    ($option:expr, $kind:ident) => {\n                        match $option {\n                            Some(value) => value,\n                            None => return Err(PIE { kind: $kind }),\n                        }\n                    };\n                }\n\n                if can_not_overflow::<$int_ty>(radix, is_signed_ty, digits) {\n                    // If the len of the str is short compared to the range of the type\n                    // we are parsing into, then we can be certain that an overflow will not occur.\n                    // This bound is when `radix.pow(digits.len()) - 1 <= T::MAX` but the condition\n                    // above is a faster (conservative) approximation of this.\n                    //\n                    // Consider radix 16 as it has the highest information density per digit and will thus overflow the earliest:\n                    // `u8::MAX` is `ff` - any str of len 2 is guaranteed to not overflow.\n                    // `i8::MAX` is `7f` - only a str of len 1 is guaranteed to not overflow.\n                    macro_rules! run_unchecked_loop {\n                        ($unchecked_additive_op:tt) => {{\n                            while let [c, rest @ ..] = digits {\n                                result = result * (radix as $int_ty);\n                                let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit);\n                                result = result $unchecked_additive_op (x as $int_ty);\n                                digits = rest;\n                            }\n                        }};\n                    }\n                    if is_positive {\n                        run_unchecked_loop!(+)\n                    } else {\n                        run_unchecked_loop!(-)\n                    };\n                } else {\n                    macro_rules! run_checked_loop {\n                        ($checked_additive_op:ident, $overflow_err:ident) => {{\n                            while let [c, rest @ ..] = digits {\n                                // When `radix` is passed in as a literal, rather than doing a slow `imul`\n                                // the compiler can use shifts if `radix` can be expressed as a\n                                // sum of powers of 2 (x*10 can be written as x*8 + x*2).\n                                // When the compiler can't use these optimisations,\n                                // the latency of the multiplication can be hidden by issuing it\n                                // before the result is needed to improve performance on\n                                // modern out-of-order CPU as multiplication here is slower\n                                // than the other instructions, we can get the end result faster\n                                // doing multiplication first and let the CPU spends other cycles\n                                // doing other computation and get multiplication result later.\n                                let mul = result.checked_mul(radix as $int_ty);\n                                let x = unwrap_or_PIE!((*c as char).to_digit(radix), InvalidDigit) as $int_ty;\n                                result = unwrap_or_PIE!(mul, $overflow_err);\n                                result = unwrap_or_PIE!(<$int_ty>::$checked_additive_op(result, x), $overflow_err);\n                                digits = rest;\n                            }\n                        }};\n                    }\n                    if is_positive {\n                        run_checked_loop!(checked_add, PosOverflow)\n                    } else {\n                        run_checked_loop!(checked_sub, NegOverflow)\n                    };\n                }\n                Ok(result)\n            }"
}