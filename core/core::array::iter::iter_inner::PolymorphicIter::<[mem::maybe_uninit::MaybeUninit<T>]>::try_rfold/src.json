{
  "name": "core::array::iter::iter_inner::PolymorphicIter::<[mem::maybe_uninit::MaybeUninit<T>]>::try_rfold",
  "span": "$library/core/src/array/iter/iter_inner.rs:264:5: 267:28",
  "src": "pub(super) fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n    where\n        F: FnMut(B, T) -> R,\n        R: Try<Output = B>,\n    {\n        // `alive` is an `IndexRange`, not an arbitrary iterator, so we can\n        // trust that its `try_rfold` isn't going to do something weird like\n        // call the fold-er multiple times for the same index.\n        let data = &mut self.data;\n        self.alive.try_rfold(init, move |accum, idx| {\n            // SAFETY: `idx` has been removed from the alive range, so we're not\n            // going to drop it (even if `f` panics) and thus its ok to give\n            // out ownership of that item to `f` to handle.\n            let elem = unsafe { data.get_unchecked(idx).assume_init_read() };\n            f(accum, elem)\n        })\n    }"
}