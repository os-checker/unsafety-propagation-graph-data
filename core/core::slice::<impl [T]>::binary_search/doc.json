{
  "name": "core::slice::<impl [T]>::binary_search",
  "span": "$library/core/src/slice/mod.rs:2916:5: 2918:16",
  "doc": " Binary searches this slice for a given element.\n If the slice is not sorted, the returned result is unspecified and\n meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n\n [`binary_search_by`]: slice::binary_search_by\n [`binary_search_by_key`]: slice::binary_search_by_key\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements. The first is found, with a\n uniquely determined position; the second and third are not\n found; the fourth could match any position in `[1, 4]`.\n\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n assert_eq!(s.binary_search(&13),  Ok(9));\n assert_eq!(s.binary_search(&4),   Err(7));\n assert_eq!(s.binary_search(&100), Err(13));\n let r = s.binary_search(&1);\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n\n If you want to find that whole *range* of matching items, rather than\n an arbitrary matching one, that can be done using [`partition_point`]:\n ```\n let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n\n let low = s.partition_point(|x| x < &1);\n assert_eq!(low, 1);\n let high = s.partition_point(|x| x <= &1);\n assert_eq!(high, 5);\n let r = s.binary_search(&1);\n assert!((low..high).contains(&r.unwrap()));\n\n assert!(s[..low].iter().all(|&x| x < 1));\n assert!(s[low..high].iter().all(|&x| x == 1));\n assert!(s[high..].iter().all(|&x| x > 1));\n\n // For something not found, the \"range\" of equal items is empty\n assert_eq!(s.partition_point(|x| x < &11), 9);\n assert_eq!(s.partition_point(|x| x <= &11), 9);\n assert_eq!(s.binary_search(&11), Err(9));\n ```\n\n If you want to insert an item to a sorted vector, while maintaining\n sort order, consider using [`partition_point`]:\n\n ```\n let mut s = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n let num = 42;\n let idx = s.partition_point(|&x| x <= num);\n // If `num` is unique, `s.partition_point(|&x| x < num)` (with `<`) is equivalent to\n // `s.binary_search(&num).unwrap_or_else(|x| x)`, but using `<=` will allow `insert`\n // to shift less elements.\n s.insert(idx, num);\n assert_eq!(s, [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n ```\n"
}