{
  "name": "core::iter::traits::iterator::Iterator::try_reduce",
  "span": "$library/core/src/iter/traits/iterator.rs:2704:5: 2710:77",
  "doc": " Reduces the elements to a single one by repeatedly applying a reducing operation. If the\n closure returns a failure, the failure is propagated back to the caller immediately.\n\n The return type of this method depends on the return type of the closure. If the closure\n returns `Result<Self::Item, E>`, then this function will return `Result<Option<Self::Item>,\n E>`. If the closure returns `Option<Self::Item>`, then this function will return\n `Option<Option<Self::Item>>`.\n\n When called on an empty iterator, this function will return either `Some(None)` or\n `Ok(None)` depending on the type of the provided closure.\n\n For iterators with at least one element, this is essentially the same as calling\n [`try_fold()`] with the first element of the iterator as the initial accumulator value.\n\n [`try_fold()`]: Iterator::try_fold\n\n # Examples\n\n Safely calculate the sum of a series of numbers:\n\n ```\n #![feature(iterator_try_reduce)]\n\n let numbers: Vec<usize> = vec![10, 20, 5, 23, 0];\n let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n assert_eq!(sum, Some(Some(58)));\n ```\n\n Determine when a reduction short circuited:\n\n ```\n #![feature(iterator_try_reduce)]\n\n let numbers = vec![1, 2, 3, usize::MAX, 4, 5];\n let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n assert_eq!(sum, None);\n ```\n\n Determine when a reduction was not performed because there are no elements:\n\n ```\n #![feature(iterator_try_reduce)]\n\n let numbers: Vec<usize> = Vec::new();\n let sum = numbers.into_iter().try_reduce(|x, y| x.checked_add(y));\n assert_eq!(sum, Some(None));\n ```\n\n Use a [`Result`] instead of an [`Option`]:\n\n ```\n #![feature(iterator_try_reduce)]\n\n let numbers = vec![\"1\", \"2\", \"3\", \"4\", \"5\"];\n let max: Result<Option<_>, <usize as std::str::FromStr>::Err> =\n     numbers.into_iter().try_reduce(|x, y| {\n         if x.parse::<usize>()? > y.parse::<usize>()? { Ok(x) } else { Ok(y) }\n     });\n assert_eq!(max, Ok(Some(\"5\")));\n ```\n"
}