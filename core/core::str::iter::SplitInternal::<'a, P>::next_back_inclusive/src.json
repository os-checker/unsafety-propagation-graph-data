{
  "name": "core::str::iter::SplitInternal::<'a, P>::next_back_inclusive",
  "span": "$library/core/src/str/iter.rs:735:5: 737:46",
  "src": "fn next_back_inclusive(&mut self) -> Option<&'a str>\n    where\n        P::Searcher<'a>: ReverseSearcher<'a>,\n    {\n        if self.finished {\n            return None;\n        }\n\n        if !self.allow_trailing_empty {\n            self.allow_trailing_empty = true;\n            match self.next_back_inclusive() {\n                Some(elt) if !elt.is_empty() => return Some(elt),\n                _ => {\n                    if self.finished {\n                        return None;\n                    }\n                }\n            }\n        }\n\n        let haystack = self.matcher.haystack();\n        match self.matcher.next_match_back() {\n            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n            // and self.end is either the end of the original string,\n            // or `b` was assigned to it, so it also lies on unicode boundary.\n            Some((_, b)) => unsafe {\n                let elt = haystack.get_unchecked(b..self.end);\n                self.end = b;\n                Some(elt)\n            },\n            // SAFETY: self.start is either the start of the original string,\n            // or start of a substring that represents the part of the string that hasn't\n            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n            // self.end is either the end of the original string,\n            // or `b` was assigned to it, so it also lies on unicode boundary.\n            None => unsafe {\n                self.finished = true;\n                Some(haystack.get_unchecked(self.start..self.end))\n            },\n        }\n    }"
}