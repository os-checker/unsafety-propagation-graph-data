{
  "name": "core::num::flt2dec::to_exact_fixed_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:586:1: 596:75",
  "src": "pub fn to_exact_fixed_str<'a, T, F>(\n    mut format_exact: F,\n    v: T,\n    sign: Sign,\n    frac_digits: usize,\n    buf: &'a mut [MaybeUninit<u8>],\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> Formatted<'a>\nwhere\n    T: DecodableFloat,\n    F: FnMut(&Decoded, &'a mut [MaybeUninit<u8>], i16) -> (&'a [u8], i16),\n{\n    assert!(parts.len() >= 4);\n\n    let (negative, full_decoded) = decode(v);\n    let sign = determine_sign(sign, &full_decoded, negative);\n    match full_decoded {\n        FullDecoded::Nan => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"NaN\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Infinite => {\n            parts[0] = MaybeUninit::new(Part::Copy(b\"inf\"));\n            // SAFETY: we just initialized the elements `..1`.\n            Formatted { sign, parts: unsafe { parts[..1].assume_init_ref() } }\n        }\n        FullDecoded::Zero => {\n            if frac_digits > 0 {\n                // [0.][0000]\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..2`.\n                    parts: unsafe { parts[..2].assume_init_ref() },\n                }\n            } else {\n                parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                Formatted {\n                    sign,\n                    // SAFETY: we just initialized the elements `..1`.\n                    parts: unsafe { parts[..1].assume_init_ref() },\n                }\n            }\n        }\n        FullDecoded::Finite(ref decoded) => {\n            let maxlen = estimate_max_buf_len(decoded.exp);\n            assert!(buf.len() >= maxlen);\n\n            // it *is* possible that `frac_digits` is ridiculously large.\n            // `format_exact` will end rendering digits much earlier in this case,\n            // because we are strictly limited by `maxlen`.\n            let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n            let (buf, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n            if exp <= limit {\n                // the restriction couldn't been met, so this should render like zero no matter\n                // `exp` was. this does not include the case that the restriction has been met\n                // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n                debug_assert_eq!(buf.len(), 0);\n                if frac_digits > 0 {\n                    // [0.][0000]\n                    parts[0] = MaybeUninit::new(Part::Copy(b\"0.\"));\n                    parts[1] = MaybeUninit::new(Part::Zero(frac_digits));\n                    Formatted {\n                        sign,\n                        // SAFETY: we just initialized the elements `..2`.\n                        parts: unsafe { parts[..2].assume_init_ref() },\n                    }\n                } else {\n                    parts[0] = MaybeUninit::new(Part::Copy(b\"0\"));\n                    Formatted {\n                        sign,\n                        // SAFETY: we just initialized the elements `..1`.\n                        parts: unsafe { parts[..1].assume_init_ref() },\n                    }\n                }\n            } else {\n                Formatted { sign, parts: digits_to_dec_str(buf, exp, frac_digits, parts) }\n            }\n        }\n    }\n}"
}