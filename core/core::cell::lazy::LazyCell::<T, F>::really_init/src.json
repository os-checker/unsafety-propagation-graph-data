{
  "name": "core::cell::lazy::LazyCell::<T, F>::really_init",
  "span": "$library/core/src/cell/lazy.rs:230:5: 230:55",
  "src": "unsafe fn really_init(this: &LazyCell<T, F>) -> &T {\n        // SAFETY:\n        // This function is only called when the state is uninitialized,\n        // so no references to `state` can exist except for the reference\n        // in `force`, which is invalidated here and not accessed again.\n        let state = unsafe { &mut *this.state.get() };\n        // Temporarily mark the state as poisoned. This prevents reentrant\n        // accesses and correctly poisons the cell if the closure panicked.\n        let State::Uninit(f) = mem::replace(state, State::Poisoned) else { unreachable!() };\n\n        let data = f();\n\n        // SAFETY:\n        // If the closure accessed the cell through something like a reentrant\n        // mutex, but caught the panic resulting from the state being poisoned,\n        // the mutable borrow for `state` will be invalidated, so we need to\n        // go through the `UnsafeCell` pointer here. The state can only be\n        // poisoned at this point, so using `write` to skip the destructor\n        // of `State` should help the optimizer.\n        unsafe { this.state.get().write(State::Init(data)) };\n\n        // SAFETY:\n        // The previous references were invalidated by the `write` call above,\n        // so do a new shared borrow of the state instead.\n        let state = unsafe { &*this.state.get() };\n        let State::Init(data) = state else { unreachable!() };\n        data\n    }"
}