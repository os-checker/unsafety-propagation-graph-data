{
  "name": "core::iter::traits::iterator::Iterator::partition_in_place",
  "span": "$library/core/src/iter/traits/iterator.rs:2268:5: 2271:30",
  "src": "fn partition_in_place<'a, T: 'a, P>(mut self, ref mut predicate: P) -> usize\n    where\n        Self: Sized + DoubleEndedIterator<Item = &'a mut T>,\n        P: FnMut(&T) -> bool,\n    {\n        // FIXME: should we worry about the count overflowing? The only way to have more than\n        // `usize::MAX` mutable references is with ZSTs, which aren't useful to partition...\n\n        // These closure \"factory\" functions exist to avoid genericity in `Self`.\n\n        #[inline]\n        fn is_false<'a, T>(\n            predicate: &'a mut impl FnMut(&T) -> bool,\n            true_count: &'a mut usize,\n        ) -> impl FnMut(&&mut T) -> bool + 'a {\n            move |x| {\n                let p = predicate(&**x);\n                *true_count += p as usize;\n                !p\n            }\n        }\n\n        #[inline]\n        fn is_true<T>(predicate: &mut impl FnMut(&T) -> bool) -> impl FnMut(&&mut T) -> bool + '_ {\n            move |x| predicate(&**x)\n        }\n\n        // Repeatedly find the first `false` and swap it with the last `true`.\n        let mut true_count = 0;\n        while let Some(head) = self.find(is_false(predicate, &mut true_count)) {\n            if let Some(tail) = self.rfind(is_true(predicate)) {\n                crate::mem::swap(head, tail);\n                true_count += 1;\n            } else {\n                break;\n            }\n        }\n        true_count\n    }"
}