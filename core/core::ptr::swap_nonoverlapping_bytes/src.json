{
  "name": "core::ptr::swap_nonoverlapping_bytes",
  "span": "$library/core/src/ptr/mod.rs:1438:1: 1438:83",
  "src": "unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, bytes: NonZero<usize>) {\n    // Same as `swap_nonoverlapping::<[u8; N]>`.\n    unsafe fn swap_nonoverlapping_chunks<const N: usize>(\n        x: *mut MaybeUninit<[u8; N]>,\n        y: *mut MaybeUninit<[u8; N]>,\n        chunks: NonZero<usize>,\n    ) {\n        let chunks = chunks.get();\n        for i in 0..chunks {\n            // SAFETY: i is in [0, chunks) so the adds and dereferences are in-bounds.\n            unsafe { swap_chunk(&mut *x.add(i), &mut *y.add(i)) };\n        }\n    }\n\n    // Same as `swap_nonoverlapping_bytes`, but accepts at most 1+2+4=7 bytes\n    #[inline]\n    unsafe fn swap_nonoverlapping_short(x: *mut u8, y: *mut u8, bytes: NonZero<usize>) {\n        // Tail handling for auto-vectorized code sometimes has element-at-a-time behaviour,\n        // see <https://github.com/rust-lang/rust/issues/134946>.\n        // By swapping as different sizes, rather than as a loop over bytes,\n        // we make sure not to end up with, say, seven byte-at-a-time copies.\n\n        let bytes = bytes.get();\n        let mut i = 0;\n        macro_rules! swap_prefix {\n            ($($n:literal)+) => {$(\n                if (bytes & $n) != 0 {\n                    // SAFETY: `i` can only have the same bits set as those in bytes,\n                    // so these `add`s are in-bounds of `bytes`.  But the bit for\n                    // `$n` hasn't been set yet, so the `$n` bytes that `swap_chunk`\n                    // will read and write are within the usable range.\n                    unsafe { swap_chunk::<$n>(&mut*x.add(i).cast(), &mut*y.add(i).cast()) };\n                    i |= $n;\n                }\n            )+};\n        }\n        swap_prefix!(4 2 1);\n        debug_assert_eq!(i, bytes);\n    }\n\n    const CHUNK_SIZE: usize = size_of::<*const ()>();\n    let bytes = bytes.get();\n\n    let chunks = bytes / CHUNK_SIZE;\n    let tail = bytes % CHUNK_SIZE;\n    if let Some(chunks) = NonZero::new(chunks) {\n        // SAFETY: this is bytes/CHUNK_SIZE*CHUNK_SIZE bytes, which is <= bytes,\n        // so it's within the range of our non-overlapping bytes.\n        unsafe { swap_nonoverlapping_chunks::<CHUNK_SIZE>(x.cast(), y.cast(), chunks) };\n    }\n    if let Some(tail) = NonZero::new(tail) {\n        const { assert!(CHUNK_SIZE <= 8) };\n        let delta = chunks * CHUNK_SIZE;\n        // SAFETY: the tail length is below CHUNK SIZE because of the remainder,\n        // and CHUNK_SIZE is at most 8 by the const assert, so tail <= 7\n        unsafe { swap_nonoverlapping_short(x.add(delta), y.add(delta), tail) };\n    }\n}"
}