{
  "name": "core::num::flt2dec::digits_to_exp_str",
  "span": "$library/core/src/num/flt2dec/mod.rs:255:1: 261:20",
  "src": "fn digits_to_exp_str<'a>(\n    buf: &'a [u8],\n    exp: i16,\n    min_ndigits: usize,\n    upper: bool,\n    parts: &'a mut [MaybeUninit<Part<'a>>],\n) -> &'a [Part<'a>] {\n    assert!(!buf.is_empty());\n    assert!(buf[0] > b'0');\n    assert!(parts.len() >= 6);\n\n    let mut n = 0;\n\n    parts[n] = MaybeUninit::new(Part::Copy(&buf[..1]));\n    n += 1;\n\n    if buf.len() > 1 || min_ndigits > 1 {\n        parts[n] = MaybeUninit::new(Part::Copy(b\".\"));\n        parts[n + 1] = MaybeUninit::new(Part::Copy(&buf[1..]));\n        n += 2;\n        if min_ndigits > buf.len() {\n            parts[n] = MaybeUninit::new(Part::Zero(min_ndigits - buf.len()));\n            n += 1;\n        }\n    }\n\n    // 0.1234 x 10^exp = 1.234 x 10^(exp-1)\n    let exp = exp as i32 - 1; // avoid underflow when exp is i16::MIN\n    if exp < 0 {\n        parts[n] = MaybeUninit::new(Part::Copy(if upper { b\"E-\" } else { b\"e-\" }));\n        parts[n + 1] = MaybeUninit::new(Part::Num(-exp as u16));\n    } else {\n        parts[n] = MaybeUninit::new(Part::Copy(if upper { b\"E\" } else { b\"e\" }));\n        parts[n + 1] = MaybeUninit::new(Part::Num(exp as u16));\n    }\n    // SAFETY: we just initialized the elements `..n + 2`.\n    unsafe { parts[..n + 2].assume_init_ref() }\n}"
}