{
  "name": "core::fmt::Formatter::<'a>::pad_integral",
  "span": "$library/core/src/fmt/mod.rs:1825:5: 1825:92",
  "doc": " Performs the correct padding for an integer which has already been\n emitted into a str. The str should *not* contain the sign for the\n integer, that will be added by this method.\n\n # Arguments\n\n * is_nonnegative - whether the original integer was either positive or zero.\n * prefix - if the '#' character (Alternate) is provided, this\n   is the prefix to put in front of the number.\n * buf - the byte array that the number has been formatted into\n\n This function will correctly account for the flags provided as well as\n the minimum width. It will not take precision into account.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo { nb: i32 }\n\n impl Foo {\n     fn new(nb: i32) -> Foo {\n         Foo {\n             nb,\n         }\n     }\n }\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // We need to remove \"-\" from the number output.\n         let tmp = self.nb.abs().to_string();\n\n         formatter.pad_integral(self.nb >= 0, \"Foo \", &tmp)\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo::new(2)), \"2\");\n assert_eq!(format!(\"{}\", Foo::new(-1)), \"-1\");\n assert_eq!(format!(\"{}\", Foo::new(0)), \"0\");\n assert_eq!(format!(\"{:#}\", Foo::new(-1)), \"-Foo 1\");\n assert_eq!(format!(\"{:0>#8}\", Foo::new(-1)), \"00-Foo 1\");\n ```\n"
}