{
  "name": "core::fmt::Formatter::<'a>::pad_integral",
  "span": "$library/core/src/fmt/mod.rs:1825:5: 1825:92",
  "src": "pub fn pad_integral(&mut self, is_nonnegative: bool, prefix: &str, buf: &str) -> Result {\n        let mut width = buf.len();\n\n        let mut sign = None;\n        if !is_nonnegative {\n            sign = Some('-');\n            width += 1;\n        } else if self.sign_plus() {\n            sign = Some('+');\n            width += 1;\n        }\n\n        let prefix = if self.alternate() {\n            width += prefix.chars().count();\n            Some(prefix)\n        } else {\n            None\n        };\n\n        // Writes the sign if it exists, and then the prefix if it was requested\n        #[inline(never)]\n        fn write_prefix(f: &mut Formatter<'_>, sign: Option<char>, prefix: Option<&str>) -> Result {\n            if let Some(c) = sign {\n                f.buf.write_char(c)?;\n            }\n            if let Some(prefix) = prefix { f.buf.write_str(prefix) } else { Ok(()) }\n        }\n\n        // The `width` field is more of a `min-width` parameter at this point.\n        let min = self.options.width;\n        if width >= usize::from(min) {\n            // We're over the minimum width, so then we can just write the bytes.\n            write_prefix(self, sign, prefix)?;\n            self.buf.write_str(buf)\n        } else if self.sign_aware_zero_pad() {\n            // The sign and prefix goes before the padding if the fill character\n            // is zero\n            let old_options = self.options;\n            self.options.fill('0').align(Some(Alignment::Right));\n            write_prefix(self, sign, prefix)?;\n            let post_padding = self.padding(min - width as u16, Alignment::Right)?;\n            self.buf.write_str(buf)?;\n            post_padding.write(self)?;\n            self.options = old_options;\n            Ok(())\n        } else {\n            // Otherwise, the sign and prefix goes after the padding\n            let post_padding = self.padding(min - width as u16, Alignment::Right)?;\n            write_prefix(self, sign, prefix)?;\n            self.buf.write_str(buf)?;\n            post_padding.write(self)\n        }\n    }"
}