{
  "name": "core::f16::<impl f16>::total_cmp",
  "span": "$library/core/src/num/f16.rs:1188:5: 1188:72",
  "doc": " Returns the ordering between `self` and `other`.\n\n Unlike the standard partial comparison between floating point numbers,\n this comparison always produces an ordering in accordance to\n the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)\n floating point standard. The values are ordered in the following sequence:\n\n - negative quiet NaN\n - negative signaling NaN\n - negative infinity\n - negative numbers\n - negative subnormal numbers\n - negative zero\n - positive zero\n - positive subnormal numbers\n - positive numbers\n - positive infinity\n - positive signaling NaN\n - positive quiet NaN.\n\n The ordering established by this function does not always agree with the\n [`PartialOrd`] and [`PartialEq`] implementations of `f16`. For example,\n they consider negative and positive zero equal, while `total_cmp`\n doesn't.\n\n The interpretation of the signaling NaN bit follows the definition in\n the IEEE 754 standard, which may not match the interpretation by some of\n the older, non-conformant (e.g. MIPS) hardware implementations.\n\n # Example\n\n ```\n #![feature(f16)]\n # // FIXME(f16_f128): extendhfsf2, truncsfhf2, __gnu_h2f_ieee, __gnu_f2h_ieee missing for many platforms\n # #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] {\n\n struct GoodBoy {\n     name: &'static str,\n     weight: f16,\n }\n\n let mut bois = vec![\n     GoodBoy { name: \"Pucci\", weight: 0.1 },\n     GoodBoy { name: \"Woofer\", weight: 99.0 },\n     GoodBoy { name: \"Yapper\", weight: 10.0 },\n     GoodBoy { name: \"Chonk\", weight: f16::INFINITY },\n     GoodBoy { name: \"Abs. Unit\", weight: f16::NAN },\n     GoodBoy { name: \"Floaty\", weight: -5.0 },\n ];\n\n bois.sort_by(|a, b| a.weight.total_cmp(&b.weight));\n\n // `f16::NAN` could be positive or negative, which will affect the sort order.\n if f16::NAN.is_sign_negative() {\n     bois.into_iter().map(|b| b.weight)\n         .zip([f16::NAN, -5.0, 0.1, 10.0, 99.0, f16::INFINITY].iter())\n         .for_each(|(a, b)| assert_eq!(a.to_bits(), b.to_bits()))\n } else {\n     bois.into_iter().map(|b| b.weight)\n         .zip([-5.0, 0.1, 10.0, 99.0, f16::INFINITY, f16::NAN].iter())\n         .for_each(|(a, b)| assert_eq!(a.to_bits(), b.to_bits()))\n }\n # }\n ```\n"
}