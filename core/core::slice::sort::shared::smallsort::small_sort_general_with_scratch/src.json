{
  "name": "core::slice::sort::shared::smallsort::small_sort_general_with_scratch",
  "span": "$library/core/src/slice/sort/shared/smallsort.rs:220:1: 224:2",
  "src": "fn small_sort_general_with_scratch<T: FreezeMarker, F: FnMut(&T, &T) -> bool>(\n    v: &mut [T],\n    scratch: &mut [MaybeUninit<T>],\n    is_less: &mut F,\n) {\n    let len = v.len();\n    if len < 2 {\n        return;\n    }\n\n    if scratch.len() < len + 16 {\n        intrinsics::abort();\n    }\n\n    let v_base = v.as_mut_ptr();\n    let len_div_2 = len / 2;\n\n    // SAFETY: See individual comments.\n    unsafe {\n        let scratch_base = scratch.as_mut_ptr() as *mut T;\n\n        let presorted_len = if const { size_of::<T>() <= 16 } && len >= 16 {\n            // SAFETY: scratch_base is valid and has enough space.\n            sort8_stable(v_base, scratch_base, scratch_base.add(len), is_less);\n            sort8_stable(\n                v_base.add(len_div_2),\n                scratch_base.add(len_div_2),\n                scratch_base.add(len + 8),\n                is_less,\n            );\n\n            8\n        } else if len >= 8 {\n            // SAFETY: scratch_base is valid and has enough space.\n            sort4_stable(v_base, scratch_base, is_less);\n            sort4_stable(v_base.add(len_div_2), scratch_base.add(len_div_2), is_less);\n\n            4\n        } else {\n            ptr::copy_nonoverlapping(v_base, scratch_base, 1);\n            ptr::copy_nonoverlapping(v_base.add(len_div_2), scratch_base.add(len_div_2), 1);\n\n            1\n        };\n\n        for offset in [0, len_div_2] {\n            // SAFETY: at this point dst is initialized with presorted_len elements.\n            // We extend this to desired_len, src is valid for desired_len elements.\n            let src = v_base.add(offset);\n            let dst = scratch_base.add(offset);\n            let desired_len = if offset == 0 { len_div_2 } else { len - len_div_2 };\n\n            for i in presorted_len..desired_len {\n                ptr::copy_nonoverlapping(src.add(i), dst.add(i), 1);\n                insert_tail(dst, dst.add(i), is_less);\n            }\n        }\n\n        // SAFETY: see comment in `CopyOnDrop::drop`.\n        let drop_guard = CopyOnDrop { src: scratch_base, dst: v_base, len };\n\n        // SAFETY: at this point scratch_base is fully initialized, allowing us\n        // to use it as the source of our merge back into the original array.\n        // If a panic occurs we ensure the original array is restored to a valid\n        // permutation of the input through drop_guard. This technique is similar\n        // to ping-pong merging.\n        bidirectional_merge(\n            &*ptr::slice_from_raw_parts(drop_guard.src, drop_guard.len),\n            drop_guard.dst,\n            is_less,\n        );\n        mem::forget(drop_guard);\n    }\n}"
}