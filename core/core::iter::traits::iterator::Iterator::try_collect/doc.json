{
  "name": "core::iter::traits::iterator::Iterator::try_collect",
  "span": "$library/core/src/iter/traits/iterator.rs:2102:5: 2106:54",
  "doc": " Fallibly transforms an iterator into a collection, short circuiting if\n a failure is encountered.\n\n `try_collect()` is a variation of [`collect()`][`collect`] that allows fallible\n conversions during collection. Its main use case is simplifying conversions from\n iterators yielding [`Option<T>`][`Option`] into `Option<Collection<T>>`, or similarly for other [`Try`]\n types (e.g. [`Result`]).\n\n Importantly, `try_collect()` doesn't require that the outer [`Try`] type also implements [`FromIterator`];\n only the inner type produced on `Try::Output` must implement it. Concretely,\n this means that collecting into `ControlFlow<_, Vec<i32>>` is valid because `Vec<i32>` implements\n [`FromIterator`], even though [`ControlFlow`] doesn't.\n\n Also, if a failure is encountered during `try_collect()`, the iterator is still valid and\n may continue to be used, in which case it will continue iterating starting after the element that\n triggered the failure. See the last example below for an example of how this works.\n\n # Examples\n Successfully collecting an iterator of `Option<i32>` into `Option<Vec<i32>>`:\n ```\n #![feature(iterator_try_collect)]\n\n let u = vec![Some(1), Some(2), Some(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, Some(vec![1, 2, 3]));\n ```\n\n Failing to collect in the same way:\n ```\n #![feature(iterator_try_collect)]\n\n let u = vec![Some(1), Some(2), None, Some(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, None);\n ```\n\n A similar example, but with `Result`:\n ```\n #![feature(iterator_try_collect)]\n\n let u: Vec<Result<i32, ()>> = vec![Ok(1), Ok(2), Ok(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, Ok(vec![1, 2, 3]));\n\n let u = vec![Ok(1), Ok(2), Err(()), Ok(3)];\n let v = u.into_iter().try_collect::<Vec<i32>>();\n assert_eq!(v, Err(()));\n ```\n\n Finally, even [`ControlFlow`] works, despite the fact that it\n doesn't implement [`FromIterator`]. Note also that the iterator can\n continue to be used, even if a failure is encountered:\n\n ```\n #![feature(iterator_try_collect)]\n\n use core::ops::ControlFlow::{Break, Continue};\n\n let u = [Continue(1), Continue(2), Break(3), Continue(4), Continue(5)];\n let mut it = u.into_iter();\n\n let v = it.try_collect::<Vec<_>>();\n assert_eq!(v, Break(3));\n\n let v = it.try_collect::<Vec<_>>();\n assert_eq!(v, Continue(vec![4, 5]));\n ```\n\n [`collect`]: Iterator::collect\n"
}