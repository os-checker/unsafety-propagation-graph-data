{
  "name": "core::slice::<impl [T]>::chunk_by",
  "span": "$library/core/src/slice/mod.rs:1861:5: 1863:34",
  "doc": " Returns an iterator over the slice producing non-overlapping runs\n of elements using the predicate to separate them.\n\n The predicate is called for every pair of consecutive elements,\n meaning that it is called on `slice[0]` and `slice[1]`,\n followed by `slice[1]` and `slice[2]`, and so on.\n\n # Examples\n\n ```\n let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n\n let mut iter = slice.chunk_by(|a, b| a == b);\n\n assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n assert_eq!(iter.next(), Some(&[3, 3][..]));\n assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n assert_eq!(iter.next(), None);\n ```\n\n This method can be used to extract the sorted subslices:\n\n ```\n let slice = &[1, 1, 2, 3, 2, 3, 2, 3, 4];\n\n let mut iter = slice.chunk_by(|a, b| a <= b);\n\n assert_eq!(iter.next(), Some(&[1, 1, 2, 3][..]));\n assert_eq!(iter.next(), Some(&[2, 3][..]));\n assert_eq!(iter.next(), Some(&[2, 3, 4][..]));\n assert_eq!(iter.next(), None);\n ```\n"
}