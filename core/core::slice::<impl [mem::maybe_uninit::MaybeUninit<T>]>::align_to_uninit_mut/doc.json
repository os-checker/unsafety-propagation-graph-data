{
  "name": "core::slice::<impl [mem::maybe_uninit::MaybeUninit<T>]>::align_to_uninit_mut",
  "span": "$library/core/src/slice/mod.rs:4951:5: 4951:94",
  "doc": " Transmutes the mutable uninitialized slice to a mutable uninitialized slice of\n another type, ensuring alignment of the types is maintained.\n\n This is a safe wrapper around [`slice::align_to_mut`], so inherits the same\n guarantees as that method.\n\n # Examples\n\n ```\n #![feature(align_to_uninit_mut)]\n use std::mem::MaybeUninit;\n\n pub struct BumpAllocator<'scope> {\n     memory: &'scope mut [MaybeUninit<u8>],\n }\n\n impl<'scope> BumpAllocator<'scope> {\n     pub fn new(memory: &'scope mut [MaybeUninit<u8>]) -> Self {\n         Self { memory }\n     }\n     pub fn try_alloc_uninit<T>(&mut self) -> Option<&'scope mut MaybeUninit<T>> {\n         let first_end = self.memory.as_ptr().align_offset(align_of::<T>()) + size_of::<T>();\n         let prefix = self.memory.split_off_mut(..first_end)?;\n         Some(&mut prefix.align_to_uninit_mut::<T>().1[0])\n     }\n     pub fn try_alloc_u32(&mut self, value: u32) -> Option<&'scope mut u32> {\n         let uninit = self.try_alloc_uninit()?;\n         Some(uninit.write(value))\n     }\n }\n\n let mut memory = [MaybeUninit::<u8>::uninit(); 10];\n let mut allocator = BumpAllocator::new(&mut memory);\n let v = allocator.try_alloc_u32(42);\n assert_eq!(v, Some(&mut 42));\n ```\n"
}