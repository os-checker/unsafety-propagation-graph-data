{
  "name": "core::num::flt2dec::strategy::dragon::format_shortest",
  "span": "$library/core/src/num/flt2dec/strategy/dragon.rs:102:1: 105:40",
  "mir": "fn core::num::flt2dec::strategy::dragon::format_shortest(_1: &num::flt2dec::decoder::Decoded, _2: &mut [mem::maybe_uninit::MaybeUninit<u8>]) -> (&[u8], i16) {\n    let mut _0: (&[u8], i16);\n    let mut _3: bool;\n    let mut _4: u64;\n    let mut _5: !;\n    let mut _6: bool;\n    let mut _7: u64;\n    let mut _8: !;\n    let mut _9: bool;\n    let mut _10: u64;\n    let mut _11: !;\n    let mut _12: bool;\n    let mut _13: &option::Option<u64>;\n    let  _14: option::Option<u64>;\n    let mut _15: u64;\n    let mut _16: u64;\n    let mut _17: !;\n    let mut _18: bool;\n    let mut _19: &option::Option<u64>;\n    let  _20: option::Option<u64>;\n    let mut _21: u64;\n    let mut _22: u64;\n    let mut _23: !;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _27: !;\n    let  _28: cmp::Ordering;\n    let mut _29: bool;\n    let mut _30: i16;\n    let mut _31: u64;\n    let mut _32: u64;\n    let mut _33: u64;\n    let mut _34: (u64, bool);\n    let mut _35: i16;\n    let mut _36: num::bignum::Big32x40;\n    let mut _37: u64;\n    let mut _38: num::bignum::Big32x40;\n    let mut _39: u64;\n    let mut _40: num::bignum::Big32x40;\n    let mut _41: u64;\n    let mut _42: num::bignum::Big32x40;\n    let mut _43: bool;\n    let mut _44: i16;\n    let  _45: &mut num::bignum::Big32x40;\n    let mut _46: &mut num::bignum::Big32x40;\n    let mut _47: usize;\n    let mut _48: i16;\n    let mut _49: i16;\n    let mut _50: bool;\n    let  _51: &mut num::bignum::Big32x40;\n    let mut _52: &mut num::bignum::Big32x40;\n    let mut _53: usize;\n    let mut _54: i16;\n    let  _55: &mut num::bignum::Big32x40;\n    let mut _56: &mut num::bignum::Big32x40;\n    let mut _57: usize;\n    let mut _58: i16;\n    let  _59: &mut num::bignum::Big32x40;\n    let mut _60: &mut num::bignum::Big32x40;\n    let mut _61: usize;\n    let mut _62: i16;\n    let mut _63: bool;\n    let mut _64: i16;\n    let  _65: &mut num::bignum::Big32x40;\n    let mut _66: &mut num::bignum::Big32x40;\n    let mut _67: usize;\n    let mut _68: i16;\n    let  _69: &mut num::bignum::Big32x40;\n    let mut _70: &mut num::bignum::Big32x40;\n    let mut _71: usize;\n    let mut _72: i16;\n    let mut _73: i16;\n    let mut _74: bool;\n    let  _75: &mut num::bignum::Big32x40;\n    let mut _76: &mut num::bignum::Big32x40;\n    let mut _77: usize;\n    let mut _78: i16;\n    let mut _79: i16;\n    let mut _80: bool;\n    let  _81: &mut num::bignum::Big32x40;\n    let mut _82: &mut num::bignum::Big32x40;\n    let mut _83: usize;\n    let mut _84: i16;\n    let mut _85: i16;\n    let mut _86: bool;\n    let mut _87: bool;\n    let mut _88: &cmp::Ordering;\n    let  _89: cmp::Ordering;\n    let mut _90: &num::bignum::Big32x40;\n    let mut _91: &num::bignum::Big32x40;\n    let  _92: &mut num::bignum::Big32x40;\n    let mut _93: &mut num::bignum::Big32x40;\n    let mut _94: num::bignum::Big32x40;\n    let mut _95: &num::bignum::Big32x40;\n    let  _96: &num::bignum::Big32x40;\n    let mut _97: &cmp::Ordering;\n    let mut _98: (i16, bool);\n    let  _99: &mut num::bignum::Big32x40;\n    let mut _100: &mut num::bignum::Big32x40;\n    let  _101: &mut num::bignum::Big32x40;\n    let mut _102: &mut num::bignum::Big32x40;\n    let  _103: &mut num::bignum::Big32x40;\n    let mut _104: &mut num::bignum::Big32x40;\n    let mut _105: num::bignum::Big32x40;\n    let mut _106: &num::bignum::Big32x40;\n    let  _107: &mut num::bignum::Big32x40;\n    let mut _108: &mut num::bignum::Big32x40;\n    let mut _109: num::bignum::Big32x40;\n    let mut _110: &num::bignum::Big32x40;\n    let  _111: &mut num::bignum::Big32x40;\n    let mut _112: &mut num::bignum::Big32x40;\n    let mut _113: num::bignum::Big32x40;\n    let mut _114: &num::bignum::Big32x40;\n    let  _115: &mut num::bignum::Big32x40;\n    let mut _116: &mut num::bignum::Big32x40;\n    let mut _117: usize;\n    let  _118: u8;\n    let mut _119: (u8, &mut num::bignum::Big32x40);\n    let mut _120: &mut num::bignum::Big32x40;\n    let  _121: &num::bignum::Big32x40;\n    let  _122: &num::bignum::Big32x40;\n    let  _123: &num::bignum::Big32x40;\n    let  _124: &num::bignum::Big32x40;\n    let mut _125: bool;\n    let mut _126: !;\n    let mut _127: mem::maybe_uninit::MaybeUninit<u8>;\n    let mut _128: u8;\n    let mut _129: (u8, bool);\n    let  _130: usize;\n    let mut _131: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _132: usize;\n    let mut _133: bool;\n    let mut _134: (usize, bool);\n    let mut _135: bool;\n    let mut _136: &cmp::Ordering;\n    let  _137: cmp::Ordering;\n    let mut _138: &num::bignum::Big32x40;\n    let  _139: &num::bignum::Big32x40;\n    let mut _140: &cmp::Ordering;\n    let mut _141: bool;\n    let mut _142: &cmp::Ordering;\n    let  _143: cmp::Ordering;\n    let mut _144: &num::bignum::Big32x40;\n    let mut _145: &num::bignum::Big32x40;\n    let  _146: &mut num::bignum::Big32x40;\n    let mut _147: &mut num::bignum::Big32x40;\n    let mut _148: num::bignum::Big32x40;\n    let mut _149: &num::bignum::Big32x40;\n    let  _150: &num::bignum::Big32x40;\n    let mut _151: &cmp::Ordering;\n    let  _152: &mut num::bignum::Big32x40;\n    let mut _153: &mut num::bignum::Big32x40;\n    let  _154: &mut num::bignum::Big32x40;\n    let mut _155: &mut num::bignum::Big32x40;\n    let  _156: &mut num::bignum::Big32x40;\n    let mut _157: &mut num::bignum::Big32x40;\n    let mut _158: bool;\n    let mut _159: &num::bignum::Big32x40;\n    let  _160: &mut num::bignum::Big32x40;\n    let mut _161: &mut num::bignum::Big32x40;\n    let mut _162: &num::bignum::Big32x40;\n    let mut _163: option::Option<u8>;\n    let mut _164: &mut [u8];\n    let mut _165: &mut [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _166: ops::range::RangeTo<usize>;\n    let mut _167: usize;\n    let mut _168: isize;\n    let  _169: u8;\n    let mut _170: mem::maybe_uninit::MaybeUninit<u8>;\n    let  _171: usize;\n    let mut _172: *const [mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _173: usize;\n    let mut _174: bool;\n    let mut _175: (usize, bool);\n    let mut _176: (i16, bool);\n    let  _177: &[u8];\n    let  _178: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _179: &[mem::maybe_uninit::MaybeUninit<u8>];\n    let mut _180: ops::range::RangeTo<usize>;\n    let mut _181: usize;\n    let mut _182: i16;\n    debug d => _1;\n    debug buf => _2;\n    debug rounding => _28;\n    debug k => _30;\n    debug mant => _36;\n    debug minus => _38;\n    debug plus => _40;\n    debug scale => _42;\n    debug scale2 => _105;\n    debug scale4 => _109;\n    debug scale8 => _113;\n    debug down => _135;\n    debug up => _141;\n    debug i => _117;\n    debug d => _118;\n    debug c => _169;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).0: u64);\n        _3 = Gt(move _4, 0_u64);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = ((*_1).1: u64);\n        _6 = Gt(move _7, 0_u64);\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = panicking::panic(\"assertion failed: d.mant > 0\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).2: u64);\n        _9 = Gt(move _10, 0_u64);\n        switchInt(move _9) -> [0: bb6, otherwise: bb5];\n    }\n    bb4: {\n        StorageDead(_7);\n        _8 = panicking::panic(\"assertion failed: d.minus > 0\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = ((*_1).0: u64);\n        StorageLive(_16);\n        _16 = ((*_1).2: u64);\n        _14 = num::<impl u64>::checked_add(move _15, move _16) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _11 = panicking::panic(\"assertion failed: d.plus > 0\") -> unwind unreachable;\n    }\n    bb7: {\n        _13 = &_14;\n        StorageDead(_16);\n        StorageDead(_15);\n        _12 = option::Option::<u64>::is_some(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _12) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = ((*_1).0: u64);\n        StorageLive(_22);\n        _22 = ((*_1).1: u64);\n        _20 = num::<impl u64>::checked_sub(move _21, move _22) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_14);\n        _17 = panicking::panic(\"assertion failed: d.mant.checked_add(d.plus).is_some()\") -> unwind unreachable;\n    }\n    bb11: {\n        _19 = &_20;\n        StorageDead(_22);\n        StorageDead(_21);\n        _18 = option::Option::<u64>::is_some(move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _18) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_2);\n        _25 = PtrMetadata(move _26);\n        StorageDead(_26);\n        _24 = Ge(move _25, num::flt2dec::MAX_SIG_DIGITS);\n        switchInt(move _24) -> [0: bb16, otherwise: bb15];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_20);\n        _23 = panicking::panic(\"assertion failed: d.mant.checked_sub(d.minus).is_some()\") -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = ((*_1).4: bool);\n        switchInt(move _29) -> [0: bb18, otherwise: bb17];\n    }\n    bb16: {\n        StorageDead(_25);\n        _27 = panicking::panic(\"assertion failed: buf.len() >= MAX_SIG_DIGITS\") -> unwind unreachable;\n    }\n    bb17: {\n        _28 = cmp::Ordering::Greater;\n        goto -> bb19;\n    }\n    bb18: {\n        _28 = cmp::Ordering::Equal;\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = ((*_1).0: u64);\n        StorageLive(_33);\n        _33 = ((*_1).2: u64);\n        _34 = CheckedAdd(_32, _33);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _32, move _33) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _31 = move (_34.0: u64);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_35);\n        _35 = ((*_1).3: i16);\n        _30 = num::flt2dec::estimator::estimate_scaling_factor(move _31, move _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_35);\n        StorageDead(_31);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = ((*_1).0: u64);\n        _36 = num::bignum::Big32x40::from_u64(move _37) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = ((*_1).1: u64);\n        _38 = num::bignum::Big32x40::from_u64(move _39) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = ((*_1).2: u64);\n        _40 = num::bignum::Big32x40::from_u64(move _41) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_41);\n        StorageLive(_42);\n        _42 = num::bignum::Big32x40::from_small(1_u32) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = ((*_1).3: i16);\n        _43 = Lt(move _44, 0_i16);\n        switchInt(move _43) -> [0: bb29, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &mut _42;\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = ((*_1).3: i16);\n        _50 = Eq(_49, i16::MIN);\n        assert(!move _50, \"attempt to negate `{}`, which would overflow\", _49) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _48 = Neg(move _49);\n        StorageDead(_49);\n        _47 = move _48 as usize;\n        StorageDead(_48);\n        _45 = num::bignum::Big32x40::mul_pow2(move _46, move _47) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageDead(_45);\n        goto -> bb33;\n    }\n    bb29: {\n        StorageDead(_44);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &mut _36;\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = ((*_1).3: i16);\n        _53 = move _54 as usize;\n        StorageDead(_54);\n        _51 = num::bignum::Big32x40::mul_pow2(move _52, move _53) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageDead(_51);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = &mut _38;\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = ((*_1).3: i16);\n        _57 = move _58 as usize;\n        StorageDead(_58);\n        _55 = num::bignum::Big32x40::mul_pow2(move _56, move _57) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &mut _40;\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = ((*_1).3: i16);\n        _61 = move _62 as usize;\n        StorageDead(_62);\n        _59 = num::bignum::Big32x40::mul_pow2(move _60, move _61) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_61);\n        StorageDead(_60);\n        StorageDead(_59);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageDead(_43);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = _30;\n        _63 = Ge(move _64, 0_i16);\n        switchInt(move _63) -> [0: bb36, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_64);\n        StorageLive(_65);\n        _66 = &mut _42;\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = _30;\n        _67 = move _68 as usize;\n        StorageDead(_68);\n        _65 = num::flt2dec::strategy::dragon::mul_pow10(_66, move _67) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_67);\n        StorageDead(_65);\n        goto -> bb43;\n    }\n    bb36: {\n        StorageDead(_64);\n        StorageLive(_69);\n        _70 = &mut _36;\n        StorageLive(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        _73 = _30;\n        _74 = Eq(_73, i16::MIN);\n        assert(!move _74, \"attempt to negate `{}`, which would overflow\", _73) -> [success: bb37, unwind unreachable];\n    }\n    bb37: {\n        _72 = Neg(move _73);\n        StorageDead(_73);\n        _71 = move _72 as usize;\n        StorageDead(_72);\n        _69 = num::flt2dec::strategy::dragon::mul_pow10(_70, move _71) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_71);\n        StorageDead(_69);\n        StorageLive(_75);\n        _76 = &mut _38;\n        StorageLive(_77);\n        StorageLive(_78);\n        StorageLive(_79);\n        _79 = _30;\n        _80 = Eq(_79, i16::MIN);\n        assert(!move _80, \"attempt to negate `{}`, which would overflow\", _79) -> [success: bb39, unwind unreachable];\n    }\n    bb39: {\n        _78 = Neg(move _79);\n        StorageDead(_79);\n        _77 = move _78 as usize;\n        StorageDead(_78);\n        _75 = num::flt2dec::strategy::dragon::mul_pow10(_76, move _77) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_77);\n        StorageDead(_75);\n        StorageLive(_81);\n        _82 = &mut _40;\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = _30;\n        _86 = Eq(_85, i16::MIN);\n        assert(!move _86, \"attempt to negate `{}`, which would overflow\", _85) -> [success: bb41, unwind unreachable];\n    }\n    bb41: {\n        _84 = Neg(move _85);\n        StorageDead(_85);\n        _83 = move _84 as usize;\n        StorageDead(_84);\n        _81 = num::flt2dec::strategy::dragon::mul_pow10(_82, move _83) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_83);\n        StorageDead(_81);\n        goto -> bb43;\n    }\n    bb43: {\n        StorageDead(_63);\n        StorageLive(_87);\n        StorageLive(_88);\n        StorageLive(_89);\n        StorageLive(_90);\n        _90 = &_42;\n        StorageLive(_91);\n        StorageLive(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = &_36;\n        _94 = <num::bignum::Big32x40 as clone::Clone>::clone(move _95) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _93 = &mut _94;\n        StorageDead(_95);\n        _96 = &_40;\n        _92 = num::bignum::Big32x40::add(move _93, _96) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        _91 = &(*_92);\n        StorageDead(_93);\n        _89 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _90, move _91) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _88 = &_89;\n        StorageDead(_91);\n        StorageDead(_90);\n        StorageLive(_97);\n        _97 = &_28;\n        _87 = <cmp::Ordering as cmp::PartialOrd>::lt(move _88, move _97) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        switchInt(move _87) -> [0: bb50, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_97);\n        StorageDead(_94);\n        StorageDead(_92);\n        StorageDead(_89);\n        StorageDead(_88);\n        _98 = CheckedAdd(_30, 1_i16);\n        assert(!move (_98.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _30, 1_i16) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _30 = move (_98.0: i16);\n        goto -> bb54;\n    }\n    bb50: {\n        StorageDead(_97);\n        StorageDead(_94);\n        StorageDead(_92);\n        StorageDead(_89);\n        StorageDead(_88);\n        StorageLive(_99);\n        StorageLive(_100);\n        _100 = &mut _36;\n        _99 = num::bignum::Big32x40::mul_small(move _100, 10_u32) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_100);\n        StorageDead(_99);\n        StorageLive(_101);\n        StorageLive(_102);\n        _102 = &mut _38;\n        _101 = num::bignum::Big32x40::mul_small(move _102, 10_u32) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_102);\n        StorageDead(_101);\n        StorageLive(_103);\n        StorageLive(_104);\n        _104 = &mut _40;\n        _103 = num::bignum::Big32x40::mul_small(move _104, 10_u32) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_104);\n        StorageDead(_103);\n        goto -> bb54;\n    }\n    bb54: {\n        StorageDead(_87);\n        StorageLive(_105);\n        StorageLive(_106);\n        _106 = &_42;\n        _105 = <num::bignum::Big32x40 as clone::Clone>::clone(move _106) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_106);\n        StorageLive(_107);\n        StorageLive(_108);\n        _108 = &mut _105;\n        _107 = num::bignum::Big32x40::mul_pow2(move _108, 1_usize) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_108);\n        StorageDead(_107);\n        StorageLive(_109);\n        StorageLive(_110);\n        _110 = &_42;\n        _109 = <num::bignum::Big32x40 as clone::Clone>::clone(move _110) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_110);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = &mut _109;\n        _111 = num::bignum::Big32x40::mul_pow2(move _112, 2_usize) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_112);\n        StorageDead(_111);\n        StorageLive(_113);\n        StorageLive(_114);\n        _114 = &_42;\n        _113 = <num::bignum::Big32x40 as clone::Clone>::clone(move _114) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_114);\n        StorageLive(_115);\n        StorageLive(_116);\n        _116 = &mut _113;\n        _115 = num::bignum::Big32x40::mul_pow2(move _116, 3_usize) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_116);\n        StorageDead(_115);\n        StorageLive(_117);\n        _117 = 0_usize;\n        goto -> bb61;\n    }\n    bb61: {\n        StorageLive(_119);\n        _120 = &mut _36;\n        _121 = &_42;\n        _122 = &_105;\n        _123 = &_109;\n        _124 = &_113;\n        _119 = num::flt2dec::strategy::dragon::div_rem_upto_16(_120, _121, _122, _123, _124) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        _118 = (_119.0: u8);\n        StorageDead(_119);\n        StorageLive(_125);\n        _125 = Lt(_118, 10_u8);\n        switchInt(move _125) -> [0: bb64, otherwise: bb63];\n    }\n    bb63: {\n        StorageDead(_125);\n        StorageLive(_127);\n        StorageLive(_128);\n        _129 = CheckedAdd(48_u8, _118);\n        assert(!move (_129.1: bool), \"attempt to compute `{} + {}`, which would overflow\", 48_u8, _118) -> [success: bb65, unwind unreachable];\n    }\n    bb64: {\n        _126 = panicking::panic(\"assertion failed: d < 10\") -> unwind unreachable;\n    }\n    bb65: {\n        _128 = move (_129.0: u8);\n        _127 = mem::maybe_uninit::MaybeUninit::<u8>::new(move _128) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_128);\n        StorageLive(_130);\n        _130 = _117;\n        _131 = &raw const (fake) (*_2);\n        _132 = PtrMetadata(move _131);\n        _133 = Lt(_130, _132);\n        assert(move _133, \"index out of bounds: the length is {} but the index is {}\", move _132, _130) -> [success: bb67, unwind unreachable];\n    }\n    bb67: {\n        (*_2)[_130] = move _127;\n        StorageDead(_127);\n        StorageDead(_130);\n        _134 = CheckedAdd(_117, 1_usize);\n        assert(!move (_134.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _117, 1_usize) -> [success: bb68, unwind unreachable];\n    }\n    bb68: {\n        _117 = move (_134.0: usize);\n        StorageLive(_136);\n        StorageLive(_137);\n        StorageLive(_138);\n        _138 = &_36;\n        _139 = &_38;\n        _137 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _138, _139) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        _136 = &_137;\n        StorageDead(_138);\n        StorageLive(_140);\n        _140 = &_28;\n        _135 = <cmp::Ordering as cmp::PartialOrd>::lt(move _136, move _140) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_140);\n        StorageDead(_136);\n        StorageDead(_137);\n        StorageLive(_142);\n        StorageLive(_143);\n        StorageLive(_144);\n        _144 = &_42;\n        StorageLive(_145);\n        StorageLive(_146);\n        StorageLive(_147);\n        StorageLive(_148);\n        StorageLive(_149);\n        _149 = &_36;\n        _148 = <num::bignum::Big32x40 as clone::Clone>::clone(move _149) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        _147 = &mut _148;\n        StorageDead(_149);\n        _150 = &_40;\n        _146 = num::bignum::Big32x40::add(move _147, _150) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        _145 = &(*_146);\n        StorageDead(_147);\n        _143 = <num::bignum::Big32x40 as cmp::Ord>::cmp(move _144, move _145) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        _142 = &_143;\n        StorageDead(_145);\n        StorageDead(_144);\n        StorageLive(_151);\n        _151 = &_28;\n        _141 = <cmp::Ordering as cmp::PartialOrd>::lt(move _142, move _151) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_151);\n        StorageDead(_142);\n        StorageDead(_148);\n        StorageDead(_146);\n        StorageDead(_143);\n        switchInt(_135) -> [0: bb75, otherwise: bb76];\n    }\n    bb75: {\n        switchInt(_141) -> [0: bb77, otherwise: bb76];\n    }\n    bb76: {\n        switchInt(_141) -> [0: bb97, otherwise: bb81];\n    }\n    bb77: {\n        StorageLive(_152);\n        StorageLive(_153);\n        _153 = &mut _36;\n        _152 = num::bignum::Big32x40::mul_small(move _153, 10_u32) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        StorageDead(_153);\n        StorageDead(_152);\n        StorageLive(_154);\n        StorageLive(_155);\n        _155 = &mut _38;\n        _154 = num::bignum::Big32x40::mul_small(move _155, 10_u32) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_155);\n        StorageDead(_154);\n        StorageLive(_156);\n        StorageLive(_157);\n        _157 = &mut _40;\n        _156 = num::bignum::Big32x40::mul_small(move _157, 10_u32) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_157);\n        StorageDead(_156);\n        goto -> bb61;\n    }\n    bb81: {\n        switchInt(_135) -> [0: bb86, otherwise: bb82];\n    }\n    bb82: {\n        StorageLive(_158);\n        StorageLive(_159);\n        StorageLive(_160);\n        StorageLive(_161);\n        _161 = &mut _36;\n        _160 = num::bignum::Big32x40::mul_pow2(move _161, 1_usize) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        StorageDead(_161);\n        _159 = &(*_160);\n        StorageLive(_162);\n        _162 = &_42;\n        _158 = <num::bignum::Big32x40 as cmp::PartialOrd>::ge(move _159, move _162) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        switchInt(move _158) -> [0: bb96, otherwise: bb85];\n    }\n    bb85: {\n        StorageDead(_162);\n        StorageDead(_160);\n        StorageDead(_159);\n        goto -> bb86;\n    }\n    bb86: {\n        StorageLive(_163);\n        StorageLive(_166);\n        StorageLive(_167);\n        _167 = _117;\n        _166 = RangeTo(move _167);\n        StorageDead(_167);\n        _165 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::IndexMut<ops::range::RangeTo<usize>>>::index_mut(_2, move _166) -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        StorageDead(_166);\n        _164 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_mut(_165) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        _163 = num::flt2dec::round_up(_164) -> [return: bb89, unwind unreachable];\n    }\n    bb89: {\n        _168 = discriminant(_163);\n        switchInt(move _168) -> [1: bb90, 0: bb95, otherwise: bb100];\n    }\n    bb90: {\n        _169 = ((_163 as variant#1).0: u8);\n        StorageLive(_170);\n        _170 = mem::maybe_uninit::MaybeUninit::<u8>::new(_169) -> [return: bb91, unwind unreachable];\n    }\n    bb91: {\n        StorageLive(_171);\n        _171 = _117;\n        _172 = &raw const (fake) (*_2);\n        _173 = PtrMetadata(move _172);\n        _174 = Lt(_171, _173);\n        assert(move _174, \"index out of bounds: the length is {} but the index is {}\", move _173, _171) -> [success: bb92, unwind unreachable];\n    }\n    bb92: {\n        (*_2)[_171] = move _170;\n        StorageDead(_170);\n        StorageDead(_171);\n        _175 = CheckedAdd(_117, 1_usize);\n        assert(!move (_175.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _117, 1_usize) -> [success: bb93, unwind unreachable];\n    }\n    bb93: {\n        _117 = move (_175.0: usize);\n        _176 = CheckedAdd(_30, 1_i16);\n        assert(!move (_176.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _30, 1_i16) -> [success: bb94, unwind unreachable];\n    }\n    bb94: {\n        _30 = move (_176.0: i16);\n        StorageDead(_163);\n        goto -> bb97;\n    }\n    bb95: {\n        StorageDead(_163);\n        goto -> bb97;\n    }\n    bb96: {\n        StorageDead(_162);\n        StorageDead(_160);\n        StorageDead(_159);\n        goto -> bb97;\n    }\n    bb97: {\n        StorageDead(_158);\n        StorageLive(_179);\n        _179 = &(*_2);\n        StorageLive(_180);\n        StorageLive(_181);\n        _181 = _117;\n        _180 = RangeTo(move _181);\n        StorageDead(_181);\n        _178 = <[mem::maybe_uninit::MaybeUninit<u8>] as ops::index::Index<ops::range::RangeTo<usize>>>::index(move _179, move _180) -> [return: bb98, unwind unreachable];\n    }\n    bb98: {\n        StorageDead(_180);\n        StorageDead(_179);\n        _177 = <[mem::maybe_uninit::MaybeUninit<u8>]>::assume_init_ref(_178) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        StorageLive(_182);\n        _182 = _30;\n        _0 = (_177, move _182);\n        StorageDead(_182);\n        StorageDead(_117);\n        StorageDead(_113);\n        StorageDead(_109);\n        StorageDead(_105);\n        StorageDead(_42);\n        StorageDead(_40);\n        StorageDead(_38);\n        StorageDead(_36);\n        StorageDead(_30);\n        StorageDead(_28);\n        return;\n    }\n    bb100: {\n        unreachable;\n    }\n}\n"
}