{
  "name": "core::num::flt2dec::strategy::dragon::format_shortest",
  "span": "$library/core/src/num/flt2dec/strategy/dragon.rs:102:1: 105:40",
  "src": "pub fn format_shortest<'a>(\n    d: &Decoded,\n    buf: &'a mut [MaybeUninit<u8>],\n) -> (/*digits*/ &'a [u8], /*exp*/ i16) {\n    // the number `v` to format is known to be:\n    // - equal to `mant * 2^exp`;\n    // - preceded by `(mant - 2 * minus) * 2^exp` in the original type; and\n    // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n    //\n    // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n    // also we assume that at least one digit is generated, i.e., `mant` cannot be zero too.\n    //\n    // this also means that any number between `low = (mant - minus) * 2^exp` and\n    // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n    // with bounds included when the original mantissa was even (i.e., `!mant_was_odd`).\n\n    assert!(d.mant > 0);\n    assert!(d.minus > 0);\n    assert!(d.plus > 0);\n    assert!(d.mant.checked_add(d.plus).is_some());\n    assert!(d.mant.checked_sub(d.minus).is_some());\n    assert!(buf.len() >= MAX_SIG_DIGITS);\n\n    // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n    let rounding = if d.inclusive { Ordering::Greater } else { Ordering::Equal };\n\n    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n    // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n    let mut k = estimate_scaling_factor(d.mant + d.plus, d.exp);\n\n    // convert `{mant, plus, minus} * 2^exp` into the fractional form so that:\n    // - `v = mant / scale`\n    // - `low = (mant - minus) / scale`\n    // - `high = (mant + plus) / scale`\n    let mut mant = Big::from_u64(d.mant);\n    let mut minus = Big::from_u64(d.minus);\n    let mut plus = Big::from_u64(d.plus);\n    let mut scale = Big::from_small(1);\n    if d.exp < 0 {\n        scale.mul_pow2(-d.exp as usize);\n    } else {\n        mant.mul_pow2(d.exp as usize);\n        minus.mul_pow2(d.exp as usize);\n        plus.mul_pow2(d.exp as usize);\n    }\n\n    // divide `mant` by `10^k`. now `scale / 10 < mant + plus <= scale * 10`.\n    if k >= 0 {\n        mul_pow10(&mut scale, k as usize);\n    } else {\n        mul_pow10(&mut mant, -k as usize);\n        mul_pow10(&mut minus, -k as usize);\n        mul_pow10(&mut plus, -k as usize);\n    }\n\n    // fixup when `mant + plus > scale` (or `>=`).\n    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n    // now `scale < mant + plus <= scale * 10` and we are ready to generate digits.\n    //\n    // note that `d[0]` *can* be zero, when `scale - plus < mant < scale`.\n    // in this case rounding-up condition (`up` below) will be triggered immediately.\n    if scale.cmp(mant.clone().add(&plus)) < rounding {\n        // equivalent to scaling `scale` by 10\n        k += 1;\n    } else {\n        mant.mul_small(10);\n        minus.mul_small(10);\n        plus.mul_small(10);\n    }\n\n    // cache `(2, 4, 8) * scale` for digit generation.\n    let mut scale2 = scale.clone();\n    scale2.mul_pow2(1);\n    let mut scale4 = scale.clone();\n    scale4.mul_pow2(2);\n    let mut scale8 = scale.clone();\n    scale8.mul_pow2(3);\n\n    let mut down;\n    let mut up;\n    let mut i = 0;\n    loop {\n        // invariants, where `d[0..n-1]` are digits generated so far:\n        // - `v = mant / scale * 10^(k-n-1) + d[0..n-1] * 10^(k-n)`\n        // - `v - low = minus / scale * 10^(k-n-1)`\n        // - `high - v = plus / scale * 10^(k-n-1)`\n        // - `(mant + plus) / scale <= 10` (thus `mant / scale < 10`)\n        // where `d[i..j]` is a shorthand for `d[i] * 10^(j-i) + ... + d[j-1] * 10 + d[j]`.\n\n        // generate one digit: `d[n] = floor(mant / scale) < 10`.\n        let (d, _) = div_rem_upto_16(&mut mant, &scale, &scale2, &scale4, &scale8);\n        debug_assert!(d < 10);\n        buf[i] = MaybeUninit::new(b'0' + d);\n        i += 1;\n\n        // this is a simplified description of the modified Dragon algorithm.\n        // many intermediate derivations and completeness arguments are omitted for convenience.\n        //\n        // start with modified invariants, as we've updated `n`:\n        // - `v = mant / scale * 10^(k-n) + d[0..n-1] * 10^(k-n)`\n        // - `v - low = minus / scale * 10^(k-n)`\n        // - `high - v = plus / scale * 10^(k-n)`\n        //\n        // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n        // i.e., `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n        // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n        // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n        //\n        // the second condition simplifies to `2 * mant <= scale`.\n        // solving invariants in terms of `mant`, `low` and `high` yields\n        // a simpler version of the first condition: `-plus < mant < minus`.\n        // since `-plus < 0 <= mant`, we have the correct shortest representation\n        // when `mant < minus` and `2 * mant <= scale`.\n        // (the former becomes `mant <= minus` when the original mantissa is even.)\n        //\n        // when the second doesn't hold (`2 * mant > scale`), we need to increase the last digit.\n        // this is enough for restoring that condition: we already know that\n        // the digit generation guarantees `0 <= v / 10^(k-n) - d[0..n-1] < 1`.\n        // in this case, the first condition becomes `-plus < mant - scale < minus`.\n        // since `mant < scale` after the generation, we have `scale < mant + plus`.\n        // (again, this becomes `scale <= mant + plus` when the original mantissa is even.)\n        //\n        // in short:\n        // - stop and round `down` (keep digits as is) when `mant < minus` (or `<=`).\n        // - stop and round `up` (increase the last digit) when `scale < mant + plus` (or `<=`).\n        // - keep generating otherwise.\n        down = mant.cmp(&minus) < rounding;\n        up = scale.cmp(mant.clone().add(&plus)) < rounding;\n        if down || up {\n            break;\n        } // we have the shortest representation, proceed to the rounding\n\n        // restore the invariants.\n        // this makes the algorithm always terminating: `minus` and `plus` always increases,\n        // but `mant` is clipped modulo `scale` and `scale` is fixed.\n        mant.mul_small(10);\n        minus.mul_small(10);\n        plus.mul_small(10);\n    }\n\n    // rounding up happens when\n    // i) only the rounding-up condition was triggered, or\n    // ii) both conditions were triggered and tie breaking prefers rounding up.\n    if up && (!down || *mant.mul_pow2(1) >= scale) {\n        // if rounding up changes the length, the exponent should also change.\n        // it seems that this condition is very hard to satisfy (possibly impossible),\n        // but we are just being safe and consistent here.\n        // SAFETY: we initialized that memory above.\n        if let Some(c) = round_up(unsafe { buf[..i].assume_init_mut() }) {\n            buf[i] = MaybeUninit::new(c);\n            i += 1;\n            k += 1;\n        }\n    }\n\n    // SAFETY: we initialized that memory above.\n    (unsafe { buf[..i].assume_init_ref() }, k)\n}"
}