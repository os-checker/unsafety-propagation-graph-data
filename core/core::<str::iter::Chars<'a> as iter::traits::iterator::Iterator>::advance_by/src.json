{
  "name": "core::<str::iter::Chars<'a> as iter::traits::iterator::Iterator>::advance_by",
  "span": "$library/core/src/str/iter.rs:51:5: 51:81",
  "src": "fn advance_by(&mut self, mut remainder: usize) -> Result<(), NonZero<usize>> {\n        const CHUNK_SIZE: usize = 32;\n\n        if remainder >= CHUNK_SIZE {\n            let mut chunks = self.iter.as_slice().as_chunks::<CHUNK_SIZE>().0.iter();\n            let mut bytes_skipped: usize = 0;\n\n            while remainder > CHUNK_SIZE\n                && let Some(chunk) = chunks.next()\n            {\n                bytes_skipped += CHUNK_SIZE;\n\n                let mut start_bytes = [false; CHUNK_SIZE];\n\n                for i in 0..CHUNK_SIZE {\n                    start_bytes[i] = !super::validations::utf8_is_cont_byte(chunk[i]);\n                }\n\n                remainder -= start_bytes.into_iter().map(|i| i as u8).sum::<u8>() as usize;\n            }\n\n            // SAFETY: The amount of bytes exists since we just iterated over them,\n            // so advance_by will succeed.\n            unsafe { self.iter.advance_by(bytes_skipped).unwrap_unchecked() };\n\n            // skip trailing continuation bytes\n            while self.iter.len() > 0 {\n                let b = self.iter.as_slice()[0];\n                if !super::validations::utf8_is_cont_byte(b) {\n                    break;\n                }\n                // SAFETY: We just peeked at the byte, therefore it exists\n                unsafe { self.iter.advance_by(1).unwrap_unchecked() };\n            }\n        }\n\n        while (remainder > 0) && (self.iter.len() > 0) {\n            remainder -= 1;\n            let b = self.iter.as_slice()[0];\n            let slurp = super::validations::utf8_char_width(b);\n            // SAFETY: utf8 validity requires that the string must contain\n            // the continuation bytes (if any)\n            unsafe { self.iter.advance_by(slurp).unwrap_unchecked() };\n        }\n\n        NonZero::new(remainder).map_or(Ok(()), Err)\n    }"
}