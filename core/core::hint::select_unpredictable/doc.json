{
  "name": "core::hint::select_unpredictable",
  "span": "$library/core/src/hint.rs:776:1: 778:25",
  "doc": " Returns either `true_val` or `false_val` depending on the value of\n `condition`, with a hint to the compiler that `condition` is unlikely to be\n correctly predicted by a CPUâ€™s branch predictor.\n\n This method is functionally equivalent to\n ```ignore (this is just for illustrative purposes)\n fn select_unpredictable<T>(b: bool, true_val: T, false_val: T) -> T {\n     if b { true_val } else { false_val }\n }\n ```\n but might generate different assembly. In particular, on platforms with\n a conditional move or select instruction (like `cmov` on x86 or `csel`\n on ARM) the optimizer might use these instructions to avoid branches,\n which can benefit performance if the branch predictor is struggling\n with predicting `condition`, such as in an implementation of binary\n search.\n\n Note however that this lowering is not guaranteed (on any platform) and\n should not be relied upon when trying to write cryptographic constant-time\n code. Also be aware that this lowering might *decrease* performance if\n `condition` is well-predictable. It is advisable to perform benchmarks to\n tell if this function is useful.\n\n # Examples\n\n Distribute values evenly between two buckets:\n ```\n use std::hash::BuildHasher;\n use std::hint;\n\n fn append<H: BuildHasher>(hasher: &H, v: i32, bucket_one: &mut Vec<i32>, bucket_two: &mut Vec<i32>) {\n     let hash = hasher.hash_one(&v);\n     let bucket = hint::select_unpredictable(hash % 2 == 0, bucket_one, bucket_two);\n     bucket.push(v);\n }\n # let hasher = std::collections::hash_map::RandomState::new();\n # let mut bucket_one = Vec::new();\n # let mut bucket_two = Vec::new();\n # append(&hasher, 42, &mut bucket_one, &mut bucket_two);\n # assert_eq!(bucket_one.len() + bucket_two.len(), 1);\n ```\n"
}