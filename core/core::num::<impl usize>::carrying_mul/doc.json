{
  "name": "core::num::<impl usize>::carrying_mul",
  "span": "$library/core/src/num/uint_macros.rs:3077:9: 3077:80",
  "doc": " Calculates the \"full multiplication\" `self * rhs + carry`\n without the possibility to overflow.\n\n This returns the low-order (wrapping) bits and the high-order (overflow) bits\n of the result as two separate values, in that order.\n\n Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n additional amount of overflow. This allows for chaining together multiple\n multiplications to create \"big integers\" which represent larger values.\n\n If you also need to add a value, then use [`Self::carrying_mul_add`].\n\n # Examples\n\n Please note that this example is shared among integer types, which is why `u32` is used.\n\n ```\n assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n ```\n\n This is the core operation needed for scalar multiplication when\n implementing it for wider-than-native types.\n\n ```\n #![feature(bigint_helper_methods)]\n fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n     let mut carry = 0;\n     for d in little_endian_digits.iter_mut() {\n         (*d, carry) = d.carrying_mul(multiplicand, carry);\n     }\n     if carry != 0 {\n         little_endian_digits.push(carry);\n     }\n }\n\n let mut v = vec![10, 20];\n scalar_mul_eq(&mut v, 3);\n assert_eq!(v, [30, 60]);\n\n assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n let mut v = vec![0x4321, 0x8765];\n scalar_mul_eq(&mut v, 0xFEED);\n assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n ```\n\n If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n except that it gives the value of the overflow instead of just whether one happened:\n\n ```\n #![feature(bigint_helper_methods)]\n let r = u8::carrying_mul(7, 13, 0);\n assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n let r = u8::carrying_mul(13, 42, 0);\n assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n ```\n\n The value of the first field in the returned tuple matches what you'd get\n by combining the [`wrapping_mul`](Self::wrapping_mul) and\n [`wrapping_add`](Self::wrapping_add) methods:\n\n ```\n #![feature(bigint_helper_methods)]\n assert_eq!(\n     789_u16.carrying_mul(456, 123).0,\n     789_u16.wrapping_mul(456).wrapping_add(123),\n );\n ```\n"
}