{
  "name": "num::FpCategory",
  "constructors": [
    "f128::<impl f128>::classify",
    "f16::<impl f16>::classify",
    "f32::<impl f32>::classify",
    "f64::<impl f64>::classify",
    "<f16 as num::dec2flt::float::RawFloat>::classify",
    "<f32 as num::dec2flt::float::RawFloat>::classify",
    "<f64 as num::dec2flt::float::RawFloat>::classify",
    "<num::FpCategory as clone::Clone>::clone"
  ],
  "access_self_as_arg": {
    "read": [
      "<num::FpCategory as clone::Clone>::clone",
      "<num::FpCategory as cmp::PartialEq>::eq",
      "<num::FpCategory as cmp::Eq>::assert_receiver_is_total_eq",
      "<num::FpCategory as fmt::Debug>::fmt"
    ],
    "write": [
      "<num::FpCategory as clone::Clone>::clone",
      "<num::FpCategory as cmp::PartialEq>::eq",
      "<num::FpCategory as fmt::Debug>::fmt"
    ],
    "other": [
      "<num::FpCategory as clone::Clone>::clone"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "f128::<impl f128>::is_subnormal",
      "f128::<impl f128>::is_normal",
      "f128::<impl f128>::classify",
      "f16::<impl f16>::is_subnormal",
      "f16::<impl f16>::is_normal",
      "f16::<impl f16>::classify",
      "f32::<impl f32>::is_subnormal",
      "f32::<impl f32>::is_normal",
      "f32::<impl f32>::classify",
      "f64::<impl f64>::is_subnormal",
      "f64::<impl f64>::is_normal",
      "f64::<impl f64>::classify",
      "<f16 as num::dec2flt::float::RawFloat>::classify",
      "<f32 as num::dec2flt::float::RawFloat>::classify",
      "<f64 as num::dec2flt::float::RawFloat>::classify",
      "num::flt2dec::decoder::decode"
    ]
  },
  "access_field": [],
  "span": "$library/core/src/num/mod.rs:1339:1: 1339:20",
  "src": "pub enum FpCategory",
  "kind": "Enum",
  "doc_adt": " A classification of floating point numbers.\n\n This `enum` is used as the return type for [`f32::classify`] and [`f64::classify`]. See\n their documentation for more.\n\n # Examples\n\n ```\n use std::num::FpCategory;\n\n let num = 12.4_f32;\n let inf = f32::INFINITY;\n let zero = 0f32;\n let sub: f32 = 1.1754942e-38;\n let nan = f32::NAN;\n\n assert_eq!(num.classify(), FpCategory::Normal);\n assert_eq!(inf.classify(), FpCategory::Infinite);\n assert_eq!(zero.classify(), FpCategory::Zero);\n assert_eq!(sub.classify(), FpCategory::Subnormal);\n assert_eq!(nan.classify(), FpCategory::Nan);\n ```\n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "Nan",
      "doc": " NaN (not a number): this value results from calculations like `(-1.0).sqrt()`.\n\n See [the documentation for `f32`](f32) for more information on the unusual properties\n of NaN.\n"
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "Infinite",
      "doc": " Positive or negative infinity, which often results from dividing a nonzero number\n by zero.\n"
    },
    "VariantIdx(Some(2))-FieldIdx(None)": {
      "name": "Zero",
      "doc": " Positive or negative zero.\n\n See [the documentation for `f32`](f32) for more information on the signedness of zeroes.\n"
    },
    "VariantIdx(Some(3))-FieldIdx(None)": {
      "name": "Subnormal",
      "doc": " “Subnormal” or “denormal” floating point representation (less precise, relative to\n their magnitude, than [`Normal`]).\n\n Subnormal numbers are larger in magnitude than [`Zero`] but smaller in magnitude than all\n [`Normal`] numbers.\n\n [`Normal`]: Self::Normal\n [`Zero`]: Self::Zero\n"
    },
    "VariantIdx(Some(4))-FieldIdx(None)": {
      "name": "Normal",
      "doc": " A regular floating point number, not any of the exceptional categories.\n\n The smallest positive normal numbers are [`f32::MIN_POSITIVE`] and [`f64::MIN_POSITIVE`],\n and the largest positive normal numbers are [`f32::MAX`] and [`f64::MAX`]. (Unlike signed\n integers, floating point numbers are symmetric in their range, so negating any of these\n constants will produce their negative counterpart.)\n"
    }
  }
}