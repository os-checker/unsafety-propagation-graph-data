{
  "name": "slice::iter::ChunksMut",
  "constructors": [
    "slice::iter::ChunksMut::<'a, T>::new",
    "slice::<impl [T]>::chunks_mut"
  ],
  "access_self_as_arg": {
    "read": [
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::size_hint",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::count",
      "<slice::iter::ChunksMut<'a, T> as fmt::Debug>::fmt"
    ],
    "write": [
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::next",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::nth",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::__iterator_get_unchecked",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::next_back",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::nth_back"
    ],
    "other": [
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::count",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::last",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::last",
      "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::last"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "slice::iter::ChunksMut::<'a, T>::new",
      "slice::<impl [T]>::chunks_mut"
    ]
  },
  "access_field": [
    {
      "read": [
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::size_hint",
        "<slice::iter::ChunksMut<'a, T> as fmt::Debug>::fmt"
      ],
      "write": [
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::next",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::nth",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::__iterator_get_unchecked",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::next_back",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::nth_back"
      ],
      "other": []
    },
    {
      "read": [
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::size_hint",
        "<slice::iter::ChunksMut<'a, T> as fmt::Debug>::fmt"
      ],
      "write": [
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::next",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::nth",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::iterator::Iterator>::__iterator_get_unchecked",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::next_back",
        "<slice::iter::ChunksMut<'a, T> as iter::traits::double_ended::DoubleEndedIterator>::nth_back"
      ],
      "other": []
    },
    {
      "read": [
        "<slice::iter::ChunksMut<'a, T> as fmt::Debug>::fmt"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/slice/iter.rs:1656:1: 1656:32",
  "src": "pub struct ChunksMut<'a, T: 'a>",
  "kind": "Struct",
  "doc_adt": " An iterator over a slice in (non-overlapping) mutable chunks (`chunk_size`\n elements at a time), starting at the beginning of the slice.\n\n When the slice len is not evenly divided by the chunk size, the last slice\n of the iteration will be the remainder.\n\n This struct is created by the [`chunks_mut`] method on [slices].\n\n # Example\n\n ```\n let mut slice = ['l', 'o', 'r', 'e', 'm'];\n let iter = slice.chunks_mut(2);\n ```\n\n [`chunks_mut`]: slice::chunks_mut\n [slices]: slice\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "v",
      "doc": " # Safety\n This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "chunk_size",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "_marker",
      "doc": ""
    }
  }
}