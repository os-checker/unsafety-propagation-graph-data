{
  "name": "ffi::c_str::CStr",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "<ffi::c_str::CStr as clone::CloneToUninit>::clone_to_uninit",
      "<ffi::c_str::CStr as fmt::Debug>::fmt",
      "ffi::c_str::CStr::as_ptr",
      "ffi::c_str::CStr::as_non_null_ptr",
      "ffi::c_str::CStr::count_bytes",
      "ffi::c_str::CStr::is_empty",
      "ffi::c_str::CStr::to_bytes",
      "ffi::c_str::CStr::to_bytes_with_nul",
      "ffi::c_str::CStr::bytes",
      "ffi::c_str::CStr::to_str",
      "ffi::c_str::CStr::display",
      "<ffi::c_str::CStr as cmp::PartialEq<&ffi::c_str::CStr>>::eq",
      "<ffi::c_str::CStr as cmp::PartialEq<&ffi::c_str::CStr>>::ne",
      "<ffi::c_str::CStr as cmp::PartialOrd>::partial_cmp",
      "<ffi::c_str::CStr as cmp::Ord>::cmp",
      "<ffi::c_str::CStr as ops::index::Index<ops::range::RangeFrom<usize>>>::index",
      "<ffi::c_str::CStr as convert::AsRef<ffi::c_str::CStr>>::as_ref",
      "ffi::c_str::Bytes::<'a>::new",
      "<ffi::c_str::CStr as cmp::PartialEq>::eq",
      "<ffi::c_str::CStr as cmp::Eq>::assert_receiver_is_total_eq",
      "<ffi::c_str::CStr as hash::Hash>::hash"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "<&ffi::c_str::CStr as default::Default>::default",
      "ffi::c_str::CStr::from_ptr",
      "ffi::c_str::CStr::from_bytes_until_nul",
      "ffi::c_str::CStr::from_bytes_with_nul",
      "ffi::c_str::CStr::from_bytes_with_nul_unchecked",
      "panic::location::Location::<'a>::file_as_c_str",
      "ffi::c_str::CStr::from_bytes_with_nul_unchecked::runtime",
      "ffi::c_str::CStr::from_bytes_with_nul_unchecked::compiletime"
    ],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "ffi::c_str::CStr::as_ptr",
        "ffi::c_str::CStr::as_non_null_ptr",
        "ffi::c_str::CStr::count_bytes",
        "ffi::c_str::CStr::is_empty",
        "ffi::c_str::CStr::to_bytes_with_nul",
        "<ffi::c_str::CStr as cmp::PartialEq>::eq",
        "<ffi::c_str::CStr as hash::Hash>::hash"
      ],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ffi/c_str.rs:102:1: 102:16",
  "src": "pub struct CStr",
  "kind": "Struct",
  "doc_adt": " A dynamically-sized view of a C string.\n\n The type `&CStr` represents a reference to a borrowed nul-terminated\n array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n slice, or unsafely from a raw `*const c_char`. It can be expressed as a\n literal in the form `c\"Hello world\"`.\n\n The `&CStr` can then be converted to a Rust <code>&[str]</code> by performing\n UTF-8 validation, or into an owned `CString`.\n\n `&CStr` is to `CString` as <code>&[str]</code> is to `String`: the former\n in each pair are borrowing references; the latter are owned\n strings.\n\n Note that this structure does **not** have a guaranteed layout (the `repr(transparent)`\n notwithstanding) and should not be placed in the signatures of FFI functions.\n Instead, safe wrappers of FFI functions may leverage [`CStr::as_ptr`] and the unsafe\n [`CStr::from_ptr`] constructor to provide a safe interface to other consumers.\n\n # Examples\n\n Inspecting a foreign C string:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n # /* Extern functions are awkward in doc comments - fake it instead\n extern \"C\" { fn my_string() -> *const c_char; }\n # */ unsafe extern \"C\" fn my_string() -> *const c_char { c\"hello\".as_ptr() }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n }\n ```\n\n Passing a Rust-originating C string:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n fn work(data: &CStr) {\n     unsafe extern \"C\" fn work_with(s: *const c_char) {}\n     unsafe { work_with(data.as_ptr()) }\n }\n\n let s = c\"Hello world!\";\n work(&s);\n ```\n\n Converting a foreign C string into a Rust `String`:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n # /* Extern functions are awkward in doc comments - fake it instead\n extern \"C\" { fn my_string() -> *const c_char; }\n # */ unsafe extern \"C\" fn my_string() -> *const c_char { c\"hello\".as_ptr() }\n\n fn my_string_safe() -> String {\n     let cstr = unsafe { CStr::from_ptr(my_string()) };\n     // Get a copy-on-write Cow<'_, str>, then extract the\n     // allocated String (or allocate a fresh one if needed).\n     cstr.to_string_lossy().into_owned()\n }\n\n println!(\"string: {}\", my_string_safe());\n ```\n\n [str]: prim@str \"str\"\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}