{
  "name": "any::TypeId",
  "constructors": [
    "error::Error::type_id",
    "<T as any::Any>::type_id",
    "any::TypeId::of",
    "<any::TypeId as clone::Clone>::clone"
  ],
  "access_self_as_arg": {
    "read": [
      "<any::TypeId as cmp::PartialEq>::eq",
      "<any::TypeId as hash::Hash>::hash",
      "<any::TypeId as fmt::Debug>::fmt",
      "<any::TypeId as cmp::PartialOrd>::partial_cmp",
      "<any::TypeId as cmp::Ord>::cmp",
      "<any::TypeId as clone::Clone>::clone",
      "<any::TypeId as cmp::Eq>::assert_receiver_is_total_eq",
      "<any::TypeId as cmp::PartialEq>::eq::runtime",
      "<any::TypeId as cmp::PartialEq>::eq::compiletime"
    ],
    "write": [
      "<any::TypeId as fmt::Debug>::fmt",
      "<any::TypeId as clone::Clone>::clone",
      "<any::TypeId as cmp::PartialEq>::eq::runtime",
      "<any::TypeId as cmp::PartialEq>::eq::compiletime"
    ],
    "other": [
      "intrinsics::type_id_eq",
      "any::TypeId::as_u128",
      "intrinsics::type_id_eq",
      "any::TypeId::as_u128",
      "<any::TypeId as fmt::Debug>::fmt",
      "<any::TypeId as clone::Clone>::clone",
      "<any::TypeId as cmp::PartialEq>::eq::runtime",
      "<any::TypeId as cmp::PartialEq>::eq::compiletime",
      "<any::TypeId as cmp::PartialEq>::eq",
      "<any::TypeId as cmp::PartialEq>::eq"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<(dyn error::Error + 'static)>::is",
      "error::Tagged::<(dyn error::Erased<'a> + 'a)>::downcast",
      "error::Tagged::<(dyn error::Erased<'a> + 'a)>::downcast_mut",
      "<(dyn any::Any + 'static)>::is"
    ],
    "write": [],
    "other": [
      "error::Error::type_id",
      "<(dyn error::Error + 'static)>::is",
      "error::request_by_type_tag",
      "error::Tagged::<(dyn error::Erased<'a> + 'a)>::downcast",
      "error::Tagged::<(dyn error::Erased<'a> + 'a)>::downcast_mut",
      "<T as any::Any>::type_id",
      "<(dyn any::Any + 'static)>::is",
      "any::TypeId::of"
    ]
  },
  "access_field": [
    {
      "read": [
        "<any::TypeId as hash::Hash>::hash",
        "<any::TypeId as cmp::PartialOrd>::partial_cmp",
        "<any::TypeId as cmp::Ord>::cmp"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/any.rs:721:1: 721:18",
  "src": "pub struct TypeId",
  "kind": "Struct",
  "doc_adt": " A `TypeId` represents a globally unique identifier for a type.\n\n Each `TypeId` is an opaque object which does not allow inspection of what's\n inside but does allow basic operations such as cloning, comparison,\n printing, and showing.\n\n A `TypeId` is currently only available for types which ascribe to `'static`,\n but this limitation may be removed in the future.\n\n While `TypeId` implements `Hash`, `PartialOrd`, and `Ord`, it is worth\n noting that the hashes and ordering will vary between Rust releases. Beware\n of relying on them inside of your code!\n\n # Layout\n\n Like other [`Rust`-representation][repr-rust] types, `TypeId`'s size and layout are unstable.\n In particular, this means that you cannot rely on the size and layout of `TypeId` remaining the\n same between Rust releases; they are subject to change without prior notice between Rust\n releases.\n\n [repr-rust]: https://doc.rust-lang.org/reference/type-layout.html#r-layout.repr.rust.unspecified\n\n # Danger of Improper Variance\n\n You might think that subtyping is impossible between two static types,\n but this is false; there exists a static type with a static subtype.\n To wit, `fn(&str)`, which is short for `for<'any> fn(&'any str)`, and\n `fn(&'static str)`, are two distinct, static types, and yet,\n `fn(&str)` is a subtype of `fn(&'static str)`, since any value of type\n `fn(&str)` can be used where a value of type `fn(&'static str)` is needed.\n\n This means that abstractions around `TypeId`, despite its\n `'static` bound on arguments, still need to worry about unnecessary\n and improper variance: it is advisable to strive for invariance\n first. The usability impact will be negligible, while the reduction\n in the risk of unsoundness will be most welcome.\n\n ## Examples\n\n Suppose `SubType` is a subtype of `SuperType`, that is,\n a value of type `SubType` can be used wherever\n a value of type `SuperType` is expected.\n Suppose also that `CoVar<T>` is a generic type, which is covariant over `T`\n (like many other types, including `PhantomData<T>` and `Vec<T>`).\n\n Then, by covariance, `CoVar<SubType>` is a subtype of `CoVar<SuperType>`,\n that is, a value of type `CoVar<SubType>` can be used wherever\n a value of type `CoVar<SuperType>` is expected.\n\n Then if `CoVar<SuperType>` relies on `TypeId::of::<SuperType>()` to uphold any invariants,\n those invariants may be broken because a value of type `CoVar<SuperType>` can be created\n without going through any of its methods, like so:\n ```\n type SubType = fn(&());\n type SuperType = fn(&'static ());\n type CoVar<T> = Vec<T>; // imagine something more complicated\n\n let sub: CoVar<SubType> = CoVar::new();\n // we have a `CoVar<SuperType>` instance without\n // *ever* having called `CoVar::<SuperType>::new()`!\n let fake_super: CoVar<SuperType> = sub;\n ```\n\n The following is an example program that tries to use `TypeId::of` to\n implement a generic type `Unique<T>` that guarantees unique instances for each `Unique<T>`,\n that is, and for each type `T` there can be at most one value of type `Unique<T>` at any time.\n\n ```\n mod unique {\n     use std::any::TypeId;\n     use std::collections::BTreeSet;\n     use std::marker::PhantomData;\n     use std::sync::Mutex;\n\n     static ID_SET: Mutex<BTreeSet<TypeId>> = Mutex::new(BTreeSet::new());\n\n     // TypeId has only covariant uses, which makes Unique covariant over TypeAsId ðŸš¨\n     #[derive(Debug, PartialEq)]\n     pub struct Unique<TypeAsId: 'static>(\n         // private field prevents creation without `new` outside this module\n         PhantomData<TypeAsId>,\n     );\n\n     impl<TypeAsId: 'static> Unique<TypeAsId> {\n         pub fn new() -> Option<Self> {\n             let mut set = ID_SET.lock().unwrap();\n             (set.insert(TypeId::of::<TypeAsId>())).then(|| Self(PhantomData))\n         }\n     }\n\n     impl<TypeAsId: 'static> Drop for Unique<TypeAsId> {\n         fn drop(&mut self) {\n             let mut set = ID_SET.lock().unwrap();\n             (!set.remove(&TypeId::of::<TypeAsId>())).then(|| panic!(\"duplicity detected\"));\n         }\n     }\n }\n\n use unique::Unique;\n\n // `OtherRing` is a subtype of `TheOneRing`. Both are 'static, and thus have a TypeId.\n type TheOneRing = fn(&'static ());\n type OtherRing = fn(&());\n\n fn main() {\n     let the_one_ring: Unique<TheOneRing> = Unique::new().unwrap();\n     assert_eq!(Unique::<TheOneRing>::new(), None);\n\n     let other_ring: Unique<OtherRing> = Unique::new().unwrap();\n     // Use that `Unique<OtherRing>` is a subtype of `Unique<TheOneRing>` ðŸš¨\n     let fake_one_ring: Unique<TheOneRing> = other_ring;\n     assert_eq!(fake_one_ring, the_one_ring);\n\n     std::mem::forget(fake_one_ring);\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "data",
      "doc": " This needs to be an array of pointers, since there is provenance\n in the first array field. This provenance knows exactly which type\n the TypeId actually is, allowing CTFE and miri to operate based off it.\n At runtime all the pointers in the array contain bits of the hash, making\n the entire `TypeId` actually just be a `u128` hash of the type.\n"
    }
  }
}