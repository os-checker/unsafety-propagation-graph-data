{
  "name": "ptr::unique::Unique",
  "constructors": [
    "ptr::unique::Unique::<T>::dangling",
    "ptr::unique::Unique::<T>::new_unchecked",
    "ptr::unique::Unique::<T>::new",
    "ptr::unique::Unique::<T>::from_non_null",
    "ptr::unique::Unique::<T>::cast",
    "<ptr::unique::Unique<T> as clone::Clone>::clone",
    "<ptr::unique::Unique<T> as convert::From<&mut T>>::from",
    "<ptr::unique::Unique<T> as convert::From<ptr::non_null::NonNull<T>>>::from"
  ],
  "access_self_as_arg": {
    "read": [
      "ptr::unique::Unique::<T>::as_ref",
      "<ptr::unique::Unique<T> as clone::Clone>::clone",
      "<ptr::unique::Unique<T> as fmt::Debug>::fmt",
      "<ptr::unique::Unique<T> as fmt::Pointer>::fmt"
    ],
    "write": [
      "ptr::unique::Unique::<T>::as_mut",
      "<ptr::unique::Unique<T> as clone::Clone>::clone",
      "<ptr::unique::Unique<T> as fmt::Debug>::fmt",
      "<ptr::unique::Unique<T> as fmt::Pointer>::fmt"
    ],
    "other": [
      "<ptr::non_null::NonNull<T> as convert::From<ptr::unique::Unique<T>>>::from",
      "ptr::unique::Unique::<T>::as_ptr",
      "ptr::unique::Unique::<T>::as_non_null_ptr",
      "ptr::unique::Unique::<T>::cast",
      "<ptr::unique::Unique<T> as clone::Clone>::clone",
      "<ptr::unique::Unique<T> as fmt::Debug>::fmt",
      "<ptr::unique::Unique<T> as fmt::Pointer>::fmt",
      "ptr::unique::Unique::<T>::as_ptr",
      "ptr::unique::Unique::<T>::as_non_null_ptr",
      "ptr::unique::Unique::<T>::cast"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "ptr::unique::Unique::<T>::dangling",
      "ptr::unique::Unique::<T>::new_unchecked",
      "ptr::unique::Unique::<T>::new",
      "ptr::unique::Unique::<T>::from_non_null",
      "<ptr::unique::Unique<T> as convert::From<&mut T>>::from",
      "<ptr::unique::Unique<T> as convert::From<ptr::non_null::NonNull<T>>>::from"
    ]
  },
  "access_field": [
    {
      "read": [
        "ptr::unique::Unique::<T>::as_ref"
      ],
      "write": [
        "ptr::unique::Unique::<T>::as_mut"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ptr/unique.rs:36:1: 36:35",
  "src": "pub struct Unique<T: PointeeSized>",
  "kind": "Struct",
  "doc_adt": " A wrapper around a raw non-null `*mut T` that indicates that the possessor\n of this wrapper owns the referent. Useful for building abstractions like\n `Box<T>`, `Vec<T>`, `String`, and `HashMap<K, V>`.\n\n Unlike `*mut T`, `Unique<T>` behaves \"as if\" it were an instance of `T`.\n It implements `Send`/`Sync` if `T` is `Send`/`Sync`. It also implies\n the kind of strong aliasing guarantees an instance of `T` can expect:\n the referent of the pointer should not be modified without a unique path to\n its owning Unique.\n\n If you're uncertain of whether it's correct to use `Unique` for your purposes,\n consider using `NonNull`, which has weaker semantics.\n\n Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n is never dereferenced. This is so that enums may use this forbidden value\n as a discriminant -- `Option<Unique<T>>` has the same size as `Unique<T>`.\n However the pointer may still dangle if it isn't dereferenced.\n\n Unlike `*mut T`, `Unique<T>` is covariant over `T`. This should always be correct\n for any type which upholds Unique's aliasing requirements.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "pointer",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "_marker",
      "doc": ""
    }
  }
}