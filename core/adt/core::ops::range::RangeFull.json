{
  "name": "core::ops::range::RangeFull",
  "constructors": [
    "core::<ops::range::RangeFull as clone::Clone>::clone",
    "core::<ops::range::RangeFull as default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "core::<ops::range::RangeFull as fmt::Debug>::fmt",
      "core::<ops::range::RangeFull as ops::range::RangeBounds<T>>::start_bound",
      "core::<ops::range::RangeFull as ops::range::RangeBounds<T>>::end_bound",
      "core::<ops::range::RangeFull as random::Distribution<bool>>::sample",
      "core::<ops::range::RangeFull as hash::Hash>::hash",
      "core::<ops::range::RangeFull as clone::Clone>::clone",
      "core::<ops::range::RangeFull as cmp::Eq>::assert_receiver_is_total_eq",
      "core::<ops::range::RangeFull as cmp::PartialEq>::eq",
      "core::<ops::range::RangeFull as random::Distribution<u8>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<i8>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<u16>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<i16>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<u32>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<i32>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<u64>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<i64>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<u128>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<i128>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<usize>>::sample",
      "core::<ops::range::RangeFull as random::Distribution<isize>>::sample"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [],
  "span": "$library/core/src/ops/range.rs:44:1: 44:21",
  "src": "pub struct RangeFull",
  "kind": "Struct",
  "doc_adt": " An unbounded range (`..`).\n\n `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\n It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n\n # Examples\n\n The `..` syntax is a `RangeFull`:\n\n ```\n assert_eq!(.., std::ops::RangeFull);\n ```\n\n It does not have an [`IntoIterator`] implementation, so you can't use it in\n a `for` loop directly. This won't compile:\n\n ```compile_fail,E0277\n for i in .. {\n     // ...\n }\n ```\n\n Used as a [slicing index], `RangeFull` produces the full array as a slice.\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]); // This is the `RangeFull`\n assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n ```\n\n [slicing index]: crate::slice::SliceIndex\n",
  "variant_fields": {}
}