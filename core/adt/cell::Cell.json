{
  "name": "cell::Cell",
  "constructors": [
    "<cell::Cell<T> as clone::Clone>::clone",
    "<cell::Cell<T> as default::Default>::default",
    "<cell::Cell<T> as convert::From<T>>::from",
    "cell::Cell::<T>::new",
    "cell::Cell::<T>::get_cloned"
  ],
  "access_self_as_arg": {
    "read": [
      "<cell::Cell<T> as clone::Clone>::clone",
      "<cell::Cell<T> as cmp::PartialEq>::eq",
      "<cell::Cell<T> as cmp::PartialOrd>::partial_cmp",
      "<cell::Cell<T> as cmp::PartialOrd>::lt",
      "<cell::Cell<T> as cmp::PartialOrd>::le",
      "<cell::Cell<T> as cmp::PartialOrd>::gt",
      "<cell::Cell<T> as cmp::PartialOrd>::ge",
      "<cell::Cell<T> as cmp::Ord>::cmp",
      "cell::Cell::<T>::set",
      "cell::Cell::<T>::swap",
      "cell::Cell::<T>::replace",
      "cell::Cell::<T>::get",
      "cell::Cell::<T>::update",
      "cell::Cell::<T>::as_ptr",
      "cell::Cell::<T>::take",
      "cell::Cell::<[T]>::as_slice_of_cells",
      "cell::Cell::<[T; N]>::as_array_of_cells",
      "cell::Cell::<T>::get_cloned",
      "cell::BorrowRef::<'b>::new",
      "cell::BorrowRefMut::<'b>::new",
      "<cell::Cell<T> as fmt::Debug>::fmt"
    ],
    "write": [
      "cell::Cell::<T>::swap",
      "cell::Cell::<[T]>::as_slice_of_cells",
      "cell::Cell::<[T; N]>::as_array_of_cells",
      "cell::Cell::<T>::get_mut"
    ],
    "other": [
      "<cell::Cell<T> as clone::Clone>::clone",
      "cell::Cell::<T>::into_inner",
      "cell::Cell::<T>::get_cloned",
      "cell::assert_coerce_unsized",
      "cell::Cell::<T>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "cell::Cell::<T>::from_mut",
      "cell::RefCell::<T>::try_borrow",
      "cell::RefCell::<T>::try_borrow_mut",
      "cell::RefCell::<T>::try_borrow_unguarded",
      "<cell::BorrowRef<'_> as ops::drop::Drop>::drop",
      "<cell::BorrowRef<'_> as clone::Clone>::clone",
      "<cell::BorrowRefMut<'_> as ops::drop::Drop>::drop",
      "cell::BorrowRefMut::<'b>::clone"
    ],
    "write": [
      "cell::RefCell::<T>::undo_leak"
    ],
    "other": [
      "<cell::Cell<T> as default::Default>::default",
      "<cell::Cell<T> as convert::From<T>>::from",
      "cell::Cell::<T>::new",
      "cell::RefCell::<T>::new"
    ]
  },
  "access_field": [
    {
      "read": [
        "cell::Cell::<T>::swap",
        "cell::Cell::<T>::replace",
        "cell::Cell::<T>::get",
        "cell::Cell::<T>::as_ptr"
      ],
      "write": [
        "cell::Cell::<T>::get_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/cell.rs:313:1: 313:27",
  "src": "pub struct Cell<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A mutable memory location.\n\n # Memory layout\n\n `Cell<T>` has the same [memory layout and caveats as\n `UnsafeCell<T>`](UnsafeCell#memory-layout). In particular, this means that\n `Cell<T>` has the same in-memory representation as its inner type `T`.\n\n # Examples\n\n In this example, you can see that `Cell<T>` enables mutation inside an\n immutable struct. In other words, it enables \"interior mutability\".\n\n ```\n use std::cell::Cell;\n\n struct SomeStruct {\n     regular_field: u8,\n     special_field: Cell<u8>,\n }\n\n let my_struct = SomeStruct {\n     regular_field: 0,\n     special_field: Cell::new(1),\n };\n\n let new_value = 100;\n\n // ERROR: `my_struct` is immutable\n // my_struct.regular_field = new_value;\n\n // WORKS: although `my_struct` is immutable, `special_field` is a `Cell`,\n // which can always be mutated\n my_struct.special_field.set(new_value);\n assert_eq!(my_struct.special_field.get(), new_value);\n ```\n\n See the [module-level documentation](self) for more.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}