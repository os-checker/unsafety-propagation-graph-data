{
  "name": "core::num::bignum::tests::Big8x3",
  "constructors": [
    "core::<num::bignum::tests::Big8x3 as clone::Clone>::clone",
    "core::num::bignum::tests::Big8x3::from_small",
    "core::num::bignum::tests::Big8x3::from_u64"
  ],
  "access_self_as_arg": {
    "read": [
      "core::<num::bignum::tests::Big8x3 as clone::Clone>::clone",
      "core::<num::bignum::tests::Big8x3 as cmp::Ord>::cmp",
      "core::<num::bignum::tests::Big8x3 as cmp::PartialEq>::eq",
      "core::<num::bignum::tests::Big8x3 as cmp::PartialOrd>::partial_cmp",
      "core::<num::bignum::tests::Big8x3 as fmt::Debug>::fmt",
      "core::num::bignum::tests::Big8x3::add",
      "core::num::bignum::tests::Big8x3::bit_length",
      "core::num::bignum::tests::Big8x3::digits",
      "core::num::bignum::tests::Big8x3::get_bit",
      "core::num::bignum::tests::Big8x3::is_zero",
      "core::num::bignum::tests::Big8x3::mul_digits",
      "core::num::bignum::tests::Big8x3::sub"
    ],
    "write": [
      "core::num::bignum::tests::Big8x3::add",
      "core::num::bignum::tests::Big8x3::add_small",
      "core::num::bignum::tests::Big8x3::div_rem_small",
      "core::num::bignum::tests::Big8x3::mul_digits",
      "core::num::bignum::tests::Big8x3::mul_digits",
      "core::num::bignum::tests::Big8x3::mul_pow2",
      "core::num::bignum::tests::Big8x3::mul_pow5",
      "core::num::bignum::tests::Big8x3::mul_small",
      "core::num::bignum::tests::Big8x3::sub"
    ],
    "other": [
      "core::<num::bignum::tests::Big8x3 as clone::Clone>::clone"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "core::num::bignum::tests::Big8x3::from_small",
      "core::num::bignum::tests::Big8x3::from_u64"
    ]
  },
  "access_field": [
    {
      "read": [
        "core::<num::bignum::tests::Big8x3 as clone::Clone>::clone",
        "core::<num::bignum::tests::Big8x3 as cmp::Ord>::cmp",
        "core::<num::bignum::tests::Big8x3 as fmt::Debug>::fmt",
        "core::num::bignum::tests::Big8x3::add",
        "core::num::bignum::tests::Big8x3::digits",
        "core::num::bignum::tests::Big8x3::sub"
      ],
      "write": [
        "core::num::bignum::tests::Big8x3::add",
        "core::num::bignum::tests::Big8x3::add_small",
        "core::num::bignum::tests::Big8x3::div_rem_small",
        "core::num::bignum::tests::Big8x3::mul_digits",
        "core::num::bignum::tests::Big8x3::mul_pow2",
        "core::num::bignum::tests::Big8x3::mul_small",
        "core::num::bignum::tests::Big8x3::sub"
      ],
      "other": []
    },
    {
      "read": [
        "core::<num::bignum::tests::Big8x3 as clone::Clone>::clone",
        "core::<num::bignum::tests::Big8x3 as cmp::Ord>::cmp",
        "core::<num::bignum::tests::Big8x3 as cmp::PartialEq>::eq",
        "core::<num::bignum::tests::Big8x3 as fmt::Debug>::fmt",
        "core::num::bignum::tests::Big8x3::add",
        "core::num::bignum::tests::Big8x3::digits",
        "core::num::bignum::tests::Big8x3::get_bit",
        "core::num::bignum::tests::Big8x3::sub"
      ],
      "write": [
        "core::num::bignum::tests::Big8x3::add",
        "core::num::bignum::tests::Big8x3::add_small",
        "core::num::bignum::tests::Big8x3::div_rem_small",
        "core::num::bignum::tests::Big8x3::mul_digits",
        "core::num::bignum::tests::Big8x3::mul_pow2",
        "core::num::bignum::tests::Big8x3::mul_small",
        "core::num::bignum::tests::Big8x3::sub"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/num/bignum.rs:79:9: 87:10",
  "src": "pub struct $name {\n            /// One plus the offset to the maximum \"digit\" in use.\n            /// This does not decrease, so be aware of the computation order.\n            /// `base[size..]` should be zero.\n            size: usize,\n            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n            /// where `W` is the number of bits in the digit type.\n            base: [$ty; $n],\n        }",
  "kind": "Struct",
  "doc_adt": " Stack-allocated arbitrary-precision (up to certain limit) integer.\n\n This is backed by a fixed-size array of given type (\"digit\").\n While the array is not very large (normally some hundred bytes),\n copying it recklessly may result in the performance hit.\n Thus this is intentionally not `Copy`.\n\n All operations available to bignums panic in the case of overflows.\n The caller is responsible to use large enough bignum types.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "size",
      "doc": " One plus the offset to the maximum \"digit\" in use.\n This does not decrease, so be aware of the computation order.\n `base[size..]` should be zero.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "base",
      "doc": " Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n where `W` is the number of bits in the digit type.\n"
    }
  }
}