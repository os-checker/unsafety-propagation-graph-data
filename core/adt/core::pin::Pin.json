{
  "name": "core::pin::Pin",
  "constructors": [
    "core::<pin::Pin<Ptr> as clone::Clone>::clone",
    "core::option::Option::<T>::as_pin_mut",
    "core::option::Option::<T>::as_pin_ref",
    "core::pin::Pin::<&'a T>::map_unchecked",
    "core::pin::Pin::<&'a mut T>::into_ref",
    "core::pin::Pin::<&'a mut T>::map_unchecked_mut",
    "core::pin::Pin::<&'static T>::static_ref",
    "core::pin::Pin::<&'static mut T>::static_mut",
    "core::pin::Pin::<Ptr>::as_deref_mut",
    "core::pin::Pin::<Ptr>::as_mut",
    "core::pin::Pin::<Ptr>::as_ref",
    "core::pin::Pin::<Ptr>::new",
    "core::pin::Pin::<Ptr>::new_unchecked",
    "core::sync::exclusive::Exclusive::<T>::from_pin_mut",
    "core::sync::exclusive::Exclusive::<T>::get_pin_mut"
  ],
  "access_self_as_arg": {
    "read": [
      "core::<pin::Pin<P> as async_iter::async_iter::AsyncIterator>::size_hint",
      "core::<pin::Pin<Ptr> as clone::Clone>::clone",
      "core::<pin::Pin<Ptr> as cmp::Ord>::cmp",
      "core::<pin::Pin<Ptr> as cmp::PartialEq<pin::Pin<Q>>>::eq",
      "core::<pin::Pin<Ptr> as cmp::PartialEq<pin::Pin<Q>>>::ne",
      "core::<pin::Pin<Ptr> as cmp::PartialOrd<pin::Pin<Q>>>::ge",
      "core::<pin::Pin<Ptr> as cmp::PartialOrd<pin::Pin<Q>>>::gt",
      "core::<pin::Pin<Ptr> as cmp::PartialOrd<pin::Pin<Q>>>::le",
      "core::<pin::Pin<Ptr> as cmp::PartialOrd<pin::Pin<Q>>>::lt",
      "core::<pin::Pin<Ptr> as cmp::PartialOrd<pin::Pin<Q>>>::partial_cmp",
      "core::<pin::Pin<Ptr> as fmt::Debug>::fmt",
      "core::<pin::Pin<Ptr> as fmt::Display>::fmt",
      "core::<pin::Pin<Ptr> as fmt::Pointer>::fmt",
      "core::<pin::Pin<Ptr> as hash::Hash>::hash",
      "core::<pin::Pin<Ptr> as ops::deref::Deref>::deref",
      "core::pin::Pin::<Ptr>::as_ref"
    ],
    "write": [
      "core::<&mut F as future::future::Future>::poll",
      "core::<&mut G as ops::coroutine::Coroutine<R>>::resume",
      "core::<&mut S as async_iter::async_iter::AsyncIterator>::poll_next",
      "core::<async_iter::from_iter::FromIter<I> as async_iter::async_iter::AsyncIterator>::poll_next",
      "core::<future::join::MaybeDone<F> as future::future::Future>::poll",
      "core::<future::ready::Ready<T> as future::future::Future>::poll",
      "core::<pin::Pin<&mut G> as ops::coroutine::Coroutine<R>>::resume",
      "core::<pin::Pin<Ptr> as ops::deref::DerefMut>::deref_mut",
      "core::<pin::Pin<Ptr> as ops::deref::DerefMut>::deref_mut",
      "core::pin::Pin::<Ptr>::as_deref_mut",
      "core::pin::Pin::<Ptr>::as_mut",
      "core::pin::Pin::<Ptr>::set"
    ],
    "other": [
      "core::<&mut F as future::future::Future>::poll",
      "core::<&mut G as ops::coroutine::Coroutine<R>>::resume",
      "core::<&mut S as async_iter::async_iter::AsyncIterator>::poll_next",
      "core::<async_iter::from_iter::FromIter<I> as async_iter::async_iter::AsyncIterator>::poll_next",
      "core::<future::join::MaybeDone<F> as future::future::Future>::poll",
      "core::<future::pending::Pending<T> as future::future::Future>::poll",
      "core::<future::poll_fn::PollFn<F> as future::future::Future>::poll",
      "core::<future::ready::Ready<T> as future::future::Future>::poll",
      "core::<panic::unwind_safe::AssertUnwindSafe<F> as future::future::Future>::poll",
      "core::<panic::unwind_safe::AssertUnwindSafe<S> as async_iter::async_iter::AsyncIterator>::poll_next",
      "core::<pin::Pin<&mut G> as ops::coroutine::Coroutine<R>>::resume",
      "core::<pin::Pin<P> as async_iter::async_iter::AsyncIterator>::poll_next",
      "core::<pin::Pin<P> as future::future::Future>::poll",
      "core::<pin::Pin<Ptr> as clone::Clone>::clone",
      "core::<pin::Pin<Ptr> as ops::deref::Deref>::deref",
      "core::<sync::exclusive::Exclusive<G> as ops::coroutine::Coroutine<R>>::resume",
      "core::<sync::exclusive::Exclusive<T> as future::future::Future>::poll",
      "core::option::Option::<T>::as_pin_mut",
      "core::option::Option::<T>::as_pin_ref",
      "core::pin::Pin::<&'a T>::get_ref",
      "core::pin::Pin::<&'a T>::get_ref",
      "core::pin::Pin::<&'a T>::map_unchecked",
      "core::pin::Pin::<&'a T>::map_unchecked",
      "core::pin::Pin::<&'a mut T>::get_mut",
      "core::pin::Pin::<&'a mut T>::get_mut",
      "core::pin::Pin::<&'a mut T>::get_unchecked_mut",
      "core::pin::Pin::<&'a mut T>::get_unchecked_mut",
      "core::pin::Pin::<&'a mut T>::into_ref",
      "core::pin::Pin::<&'a mut T>::into_ref",
      "core::pin::Pin::<&'a mut T>::map_unchecked_mut",
      "core::pin::Pin::<Ptr>::as_deref_mut",
      "core::pin::Pin::<Ptr>::as_mut",
      "core::pin::Pin::<Ptr>::as_ref",
      "core::pin::Pin::<Ptr>::into_inner",
      "core::pin::Pin::<Ptr>::into_inner",
      "core::pin::Pin::<Ptr>::into_inner_unchecked",
      "core::pin::Pin::<Ptr>::into_inner_unchecked",
      "core::pin::unsafe_pinned::UnsafePinned::<T>::get_mut_pinned",
      "core::sync::exclusive::Exclusive::<T>::from_pin_mut",
      "core::sync::exclusive::Exclusive::<T>::get_pin_mut"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "core::<iter::sources::from_coroutine::FromCoroutine<G> as iter::traits::iterator::Iterator>::next",
      "core::pin::Pin::<&'static T>::static_ref",
      "core::pin::Pin::<&'static mut T>::static_mut",
      "core::pin::Pin::<Ptr>::new",
      "core::pin::Pin::<Ptr>::new_unchecked"
    ]
  },
  "access_field": [
    {
      "read": [
        "core::<pin::Pin<Ptr> as clone::Clone>::clone",
        "core::<pin::Pin<Ptr> as fmt::Debug>::fmt",
        "core::<pin::Pin<Ptr> as fmt::Display>::fmt",
        "core::<pin::Pin<Ptr> as fmt::Pointer>::fmt",
        "core::pin::Pin::<Ptr>::as_ref"
      ],
      "write": [
        "core::pin::Pin::<Ptr>::as_mut",
        "core::pin::Pin::<Ptr>::set"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/pin.rs:1094:1: 1094:20",
  "src": "pub struct Pin<Ptr>",
  "kind": "Struct",
  "doc_adt": " A pointer which pins its pointee in place.\n\n [`Pin`] is a wrapper around some kind of pointer `Ptr` which makes that pointer \"pin\" its\n pointee value in place, thus preventing the value referenced by that pointer from being moved\n or otherwise invalidated at that place in memory unless it implements [`Unpin`].\n\n *See the [`pin` module] documentation for a more thorough exploration of pinning.*\n\n ## Pinning values with [`Pin<Ptr>`]\n\n In order to pin a value, we wrap a *pointer to that value* (of some type `Ptr`) in a\n [`Pin<Ptr>`]. [`Pin<Ptr>`] can wrap any pointer type, forming a promise that the **pointee**\n will not be *moved* or [otherwise invalidated][subtle-details]. If the pointee value's type\n implements [`Unpin`], we are free to disregard these requirements entirely and can wrap any\n pointer to that value in [`Pin`] directly via [`Pin::new`]. If the pointee value's type does\n not implement [`Unpin`], then Rust will not let us use the [`Pin::new`] function directly and\n we'll need to construct a [`Pin`]-wrapped pointer in one of the more specialized manners\n discussed below.\n\n We call such a [`Pin`]-wrapped pointer a **pinning pointer** (or pinning ref, or pinning\n [`Box`], etc.) because its existence is the thing that is pinning the underlying pointee in\n place: it is the metaphorical \"pin\" securing the data in place on the pinboard (in memory).\n\n It is important to stress that the thing in the [`Pin`] is not the value which we want to pin\n itself, but rather a pointer to that value! A [`Pin<Ptr>`] does not pin the `Ptr` but rather\n the pointer's ***pointee** value*.\n\n The most common set of types which require pinning related guarantees for soundness are the\n compiler-generated state machines that implement [`Future`] for the return value of\n `async fn`s. These compiler-generated [`Future`]s may contain self-referential pointers, one\n of the most common use cases for [`Pin`]. More details on this point are provided in the\n [`pin` module] docs, but suffice it to say they require the guarantees provided by pinning to\n be implemented soundly.\n\n This requirement for the implementation of `async fn`s means that the [`Future`] trait\n requires all calls to [`poll`] to use a <code>self: [Pin]\\<&mut Self></code> parameter instead\n of the usual `&mut self`. Therefore, when manually polling a future, you will need to pin it\n first.\n\n You may notice that `async fn`-sourced [`Future`]s are only a small percentage of all\n [`Future`]s that exist, yet we had to modify the signature of [`poll`] for all [`Future`]s\n to accommodate them. This is unfortunate, but there is a way that the language attempts to\n alleviate the extra friction that this API choice incurs: the [`Unpin`] trait.\n\n The vast majority of Rust types have no reason to ever care about being pinned. These\n types implement the [`Unpin`] trait, which entirely opts all values of that type out of\n pinning-related guarantees. For values of these types, pinning a value by pointing to it with a\n [`Pin<Ptr>`] will have no actual effect.\n\n The reason this distinction exists is exactly to allow APIs like [`Future::poll`] to take a\n [`Pin<Ptr>`] as an argument for all types while only forcing [`Future`] types that actually\n care about pinning guarantees pay the ergonomics cost. For the majority of [`Future`] types\n that don't have a reason to care about being pinned and therefore implement [`Unpin`], the\n <code>[Pin]\\<&mut Self></code> will act exactly like a regular `&mut Self`, allowing direct\n access to the underlying value. Only types that *don't* implement [`Unpin`] will be restricted.\n\n ### Pinning a value of a type that implements [`Unpin`]\n\n If the type of the value you need to \"pin\" implements [`Unpin`], you can trivially wrap any\n pointer to that value in a [`Pin`] by calling [`Pin::new`].\n\n ```\n use std::pin::Pin;\n\n // Create a value of a type that implements `Unpin`\n let mut unpin_future = std::future::ready(5);\n\n // Pin it by creating a pinning mutable reference to it (ready to be `poll`ed!)\n let my_pinned_unpin_future: Pin<&mut _> = Pin::new(&mut unpin_future);\n ```\n\n ### Pinning a value inside a [`Box`]\n\n The simplest and most flexible way to pin a value that does not implement [`Unpin`] is to put\n that value inside a [`Box`] and then turn that [`Box`] into a \"pinning [`Box`]\" by wrapping it\n in a [`Pin`]. You can do both of these in a single step using [`Box::pin`]. Let's see an\n example of using this flow to pin a [`Future`] returned from calling an `async fn`, a common\n use case as described above.\n\n ```\n use std::pin::Pin;\n\n async fn add_one(x: u32) -> u32 {\n     x + 1\n }\n\n // Call the async function to get a future back\n let fut = add_one(42);\n\n // Pin the future inside a pinning box\n let pinned_fut: Pin<Box<_>> = Box::pin(fut);\n ```\n\n If you have a value which is already boxed, for example a [`Box<dyn Future>`][Box], you can pin\n that value in-place at its current memory address using [`Box::into_pin`].\n\n ```\n use std::pin::Pin;\n use std::future::Future;\n\n async fn add_one(x: u32) -> u32 {\n     x + 1\n }\n\n fn boxed_add_one(x: u32) -> Box<dyn Future<Output = u32>> {\n     Box::new(add_one(x))\n }\n\n let boxed_fut = boxed_add_one(42);\n\n // Pin the future inside the existing box\n let pinned_fut: Pin<Box<_>> = Box::into_pin(boxed_fut);\n ```\n\n There are similar pinning methods offered on the other standard library smart pointer types\n as well, like [`Rc`] and [`Arc`].\n\n ### Pinning a value on the stack using [`pin!`]\n\n There are some situations where it is desirable or even required (for example, in a `#[no_std]`\n context where you don't have access to the standard library or allocation in general) to\n pin a value which does not implement [`Unpin`] to its location on the stack. Doing so is\n possible using the [`pin!`] macro. See its documentation for more.\n\n ## Layout and ABI\n\n [`Pin<Ptr>`] is guaranteed to have the same memory layout and ABI[^noalias] as `Ptr`.\n\n [^noalias]: There is a bit of nuance here that is still being decided about whether the\n aliasing semantics of `Pin<&mut T>` should be different than `&mut T`, but this is true as of\n today.\n\n [`pin!`]: crate::pin::pin \"pin!\"\n [`Future`]: crate::future::Future \"Future\"\n [`poll`]: crate::future::Future::poll \"Future::poll\"\n [`Future::poll`]: crate::future::Future::poll \"Future::poll\"\n [`pin` module]: self \"pin module\"\n [`Rc`]: ../../std/rc/struct.Rc.html \"Rc\"\n [`Arc`]: ../../std/sync/struct.Arc.html \"Arc\"\n [Box]: ../../std/boxed/struct.Box.html \"Box\"\n [`Box`]: ../../std/boxed/struct.Box.html \"Box\"\n [`Box::pin`]: ../../std/boxed/struct.Box.html#method.pin \"Box::pin\"\n [`Box::into_pin`]: ../../std/boxed/struct.Box.html#method.into_pin \"Box::into_pin\"\n [subtle-details]: self#subtle-details-and-the-drop-guarantee \"pin subtle details\"\n [`unsafe`]: ../../std/keyword.unsafe.html \"keyword unsafe\"\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "pointer",
      "doc": ""
    }
  }
}