{
  "name": "core::cell::lazy::LazyCell",
  "constructors": [
    "core::cell::lazy::LazyCell::<T, F>::new",
    "core::<cell::lazy::LazyCell<T> as default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "core::cell::lazy::LazyCell::<T, F>::force",
      "core::cell::lazy::LazyCell::<T, F>::really_init",
      "core::cell::lazy::LazyCell::<T, F>::get",
      "core::<cell::lazy::LazyCell<T, F> as ops::deref::Deref>::deref",
      "core::<cell::lazy::LazyCell<T, F> as fmt::Debug>::fmt"
    ],
    "write": [
      "core::cell::lazy::LazyCell::<T, F>::force_mut",
      "core::cell::lazy::LazyCell::<T, F>::get_mut",
      "core::<cell::lazy::LazyCell<T, F> as ops::deref::DerefMut>::deref_mut"
    ],
    "other": [
      "core::cell::lazy::LazyCell::<T, F>::into_inner",
      "core::cell::lazy::LazyCell::<T, F>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "core::cell::lazy::LazyCell::<T, F>::new",
      "core::<cell::lazy::LazyCell<T> as default::Default>::default"
    ]
  },
  "access_field": [
    {
      "read": [
        "core::cell::lazy::LazyCell::<T, F>::force",
        "core::cell::lazy::LazyCell::<T, F>::really_init",
        "core::cell::lazy::LazyCell::<T, F>::get"
      ],
      "write": [
        "core::cell::lazy::LazyCell::<T, F>::force_mut",
        "core::cell::lazy::LazyCell::<T, F>::get_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/cell/lazy.rs:54:1: 54:38",
  "src": "pub struct LazyCell<T, F = fn() -> T>",
  "kind": "Struct",
  "doc_adt": " A value which is initialized on the first access.\n\n For a thread-safe version of this struct, see [`std::sync::LazyLock`].\n\n [`std::sync::LazyLock`]: ../../std/sync/struct.LazyLock.html\n\n # Poisoning\n\n If the initialization closure passed to [`LazyCell::new`] panics, the cell will be poisoned.\n Once the cell is poisoned, any threads that attempt to access this cell (via a dereference\n or via an explicit call to [`force()`]) will panic.\n\n This concept is similar to that of poisoning in the [`std::sync::poison`] module. A key\n difference, however, is that poisoning in `LazyCell` is _unrecoverable_. All future accesses of\n the cell from other threads will panic, whereas a type in [`std::sync::poison`] like\n [`std::sync::poison::Mutex`] allows recovery via [`PoisonError::into_inner()`].\n\n [`force()`]: LazyCell::force\n [`std::sync::poison`]: ../../std/sync/poison/index.html\n [`std::sync::poison::Mutex`]: ../../std/sync/poison/struct.Mutex.html\n [`PoisonError::into_inner()`]: ../../std/sync/poison/struct.PoisonError.html#method.into_inner\n\n # Examples\n\n ```\n use std::cell::LazyCell;\n\n let lazy: LazyCell<i32> = LazyCell::new(|| {\n     println!(\"initializing\");\n     92\n });\n println!(\"ready\");\n println!(\"{}\", *lazy);\n println!(\"{}\", *lazy);\n\n // Prints:\n //   ready\n //   initializing\n //   92\n //   92\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "state",
      "doc": ""
    }
  }
}