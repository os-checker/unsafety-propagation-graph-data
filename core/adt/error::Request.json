{
  "name": "error::Request",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "error::Request::<'a>::would_be_satisfied_by_value_of",
      "error::Request::<'a>::would_be_satisfied_by_ref_of",
      "error::Request::<'a>::would_be_satisfied_by",
      "<error::Request<'a> as fmt::Debug>::fmt"
    ],
    "write": [
      "error::Error::provide",
      "error::Request::<'a>::provide_value",
      "error::Request::<'a>::provide_value_with",
      "error::Request::<'a>::provide_ref",
      "error::Request::<'a>::provide_ref_with",
      "error::Request::<'a>::provide",
      "error::Request::<'a>::provide_with",
      "<&'a T as error::Error>::provide"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "error::request_by_type_tag",
      "error::Tagged::<error::TaggedOption<'a, I>>::as_request"
    ],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "error::Request::<'a>::provide",
        "error::Request::<'a>::provide_with",
        "error::Request::<'a>::would_be_satisfied_by"
      ],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/error.rs:538:1: 538:23",
  "src": "pub struct Request<'a>",
  "kind": "Struct",
  "doc_adt": " `Request` supports generic, type-driven access to data. Its use is currently restricted to the\n standard library in cases where trait authors wish to allow trait implementors to share generic\n information across trait boundaries. The motivating and prototypical use case is\n `core::error::Error` which would otherwise require a method per concrete type (eg.\n `std::backtrace::Backtrace` instance that implementors want to expose to users).\n\n # Data flow\n\n To describe the intended data flow for Request objects, let's consider two conceptual users\n separated by API boundaries:\n\n * Consumer - the consumer requests objects using a Request instance; eg a crate that offers\n   fancy `Error`/`Result` reporting to users wants to request a Backtrace from a given `dyn Error`.\n\n * Producer - the producer provides objects when requested via Request; eg. a library with an\n   an `Error` implementation that automatically captures backtraces at the time instances are\n   created.\n\n The consumer only needs to know where to submit their request and are expected to handle the\n request not being fulfilled by the use of `Option<T>` in the responses offered by the producer.\n\n * A Producer initializes the value of one of its fields of a specific type. (or is otherwise\n   prepared to generate a value requested). eg, `backtrace::Backtrace` or\n   `std::backtrace::Backtrace`\n * A Consumer requests an object of a specific type (say `std::backtrace::Backtrace`). In the\n   case of a `dyn Error` trait object (the Producer), there are functions called `request_ref` and\n   `request_value` to simplify obtaining an `Option<T>` for a given type.\n * The Producer, when requested, populates the given Request object which is given as a mutable\n   reference.\n * The Consumer extracts a value or reference to the requested type from the `Request` object\n   wrapped in an `Option<T>`; in the case of `dyn Error` the aforementioned `request_ref` and `\n   request_value` methods mean that `dyn Error` users don't have to deal with the `Request` type at\n   all (but `Error` implementors do). The `None` case of the `Option` suggests only that the\n   Producer cannot currently offer an instance of the requested type, not it can't or never will.\n\n # Examples\n\n The best way to demonstrate this is using an example implementation of `Error`'s `provide` trait\n method:\n\n ```\n #![feature(error_generic_member_access)]\n use core::fmt;\n use core::error::Request;\n use core::error::request_ref;\n\n #[derive(Debug)]\n enum MyLittleTeaPot {\n     Empty,\n }\n\n #[derive(Debug)]\n struct MyBacktrace {\n     // ...\n }\n\n impl MyBacktrace {\n     fn new() -> MyBacktrace {\n         // ...\n         # MyBacktrace {}\n     }\n }\n\n #[derive(Debug)]\n struct Error {\n     backtrace: MyBacktrace,\n }\n\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"Example Error\")\n     }\n }\n\n impl std::error::Error for Error {\n     fn provide<'a>(&'a self, request: &mut Request<'a>) {\n         request\n             .provide_ref::<MyBacktrace>(&self.backtrace);\n     }\n }\n\n fn main() {\n     let backtrace = MyBacktrace::new();\n     let error = Error { backtrace };\n     let dyn_error = &error as &dyn std::error::Error;\n     let backtrace_ref = request_ref::<MyBacktrace>(dyn_error).unwrap();\n\n     assert!(core::ptr::eq(&error.backtrace, backtrace_ref));\n     assert!(request_ref::<MyLittleTeaPot>(dyn_error).is_none());\n }\n ```\n\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}