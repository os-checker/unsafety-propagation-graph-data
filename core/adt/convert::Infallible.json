{
  "name": "convert::Infallible",
  "constructors": [
    "<T as convert::TryFrom<U>>::try_from",
    "<convert::Infallible as clone::Clone>::clone",
    "<convert::Infallible as convert::From<!>>::from",
    "<ops::control_flow::ControlFlow<B, C> as ops::try_trait::Try>::branch",
    "<option::Option<T> as ops::try_trait::Try>::branch",
    "<result::Result<T, E> as ops::try_trait::Try>::branch",
    "<task::poll::Poll<result::Result<T, E>> as ops::try_trait::Try>::branch",
    "<task::poll::Poll<option::Option<result::Result<T, E>>> as ops::try_trait::Try>::branch"
  ],
  "access_self_as_arg": {
    "read": [
      "<convert::Infallible as clone::Clone>::clone",
      "<convert::Infallible as fmt::Debug>::fmt",
      "<convert::Infallible as fmt::Display>::fmt",
      "<convert::Infallible as cmp::PartialEq>::eq",
      "<convert::Infallible as cmp::PartialOrd>::partial_cmp",
      "<convert::Infallible as cmp::Ord>::cmp",
      "<convert::Infallible as hash::Hash>::hash"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:930:1: 930:20",
  "src": "pub enum Infallible",
  "kind": "Enum",
  "doc_adt": " The error type for errors that can never happen.\n\n Since this enum has no variant, a value of this type can never actually exist.\n This can be useful for generic APIs that use [`Result`] and parameterize the error type,\n to indicate that the result is always [`Ok`].\n\n For example, the [`TryFrom`] trait (conversion that returns a [`Result`])\n has a blanket implementation for all types where a reverse [`Into`] implementation exists.\n\n ```ignore (illustrates std code, duplicating the impl in a doctest would be an error)\n impl<T, U> TryFrom<U> for T where U: Into<T> {\n     type Error = Infallible;\n\n     fn try_from(value: U) -> Result<Self, Infallible> {\n         Ok(U::into(value))  // Never returns `Err`\n     }\n }\n ```\n\n # Future compatibility\n\n This enum has the same role as [the `!` “never” type][never],\n which is unstable in this version of Rust.\n When `!` is stabilized, we plan to make `Infallible` a type alias to it:\n\n ```ignore (illustrates future std change)\n pub type Infallible = !;\n ```\n\n … and eventually deprecate `Infallible`.\n\n However there is one case where `!` syntax can be used\n before `!` is stabilized as a full-fledged type: in the position of a function’s return type.\n Specifically, it is possible to have implementations for two different function pointer types:\n\n ```\n trait MyTrait {}\n impl MyTrait for fn() -> ! {}\n impl MyTrait for fn() -> std::convert::Infallible {}\n ```\n\n With `Infallible` being an enum, this code is valid.\n However when `Infallible` becomes an alias for the never type,\n the two `impl`s will start to overlap\n and therefore will be disallowed by the language’s trait coherence rules.\n",
  "variant_fields": {}
}