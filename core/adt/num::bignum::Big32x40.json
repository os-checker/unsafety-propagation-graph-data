{
  "name": "num::bignum::Big32x40",
  "constructors": [
    "num::bignum::Big32x40::from_small",
    "num::bignum::Big32x40::from_u64",
    "<num::bignum::Big32x40 as clone::Clone>::clone"
  ],
  "access_self_as_arg": {
    "read": [
      "num::flt2dec::strategy::dragon::div_rem_upto_16",
      "num::bignum::Big32x40::digits",
      "num::bignum::Big32x40::get_bit",
      "num::bignum::Big32x40::is_zero",
      "num::bignum::Big32x40::bit_length",
      "num::bignum::Big32x40::add",
      "num::bignum::Big32x40::sub",
      "num::bignum::Big32x40::mul_digits",
      "<num::bignum::Big32x40 as cmp::PartialEq>::eq",
      "<num::bignum::Big32x40 as cmp::PartialOrd>::partial_cmp",
      "<num::bignum::Big32x40 as cmp::Ord>::cmp",
      "<num::bignum::Big32x40 as clone::Clone>::clone",
      "<num::bignum::Big32x40 as fmt::Debug>::fmt"
    ],
    "write": [
      "num::flt2dec::strategy::dragon::mul_pow10",
      "num::flt2dec::strategy::dragon::div_2pow10",
      "num::flt2dec::strategy::dragon::div_rem_upto_16",
      "num::bignum::Big32x40::add",
      "num::bignum::Big32x40::add_small",
      "num::bignum::Big32x40::sub",
      "num::bignum::Big32x40::mul_small",
      "num::bignum::Big32x40::mul_pow2",
      "num::bignum::Big32x40::mul_pow5",
      "num::bignum::Big32x40::mul_digits",
      "num::bignum::Big32x40::div_rem_small",
      "num::flt2dec::strategy::dragon::div_rem_upto_16",
      "num::bignum::Big32x40::mul_digits"
    ],
    "other": [
      "<num::bignum::Big32x40 as clone::Clone>::clone"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "num::flt2dec::strategy::dragon::format_shortest",
      "num::flt2dec::strategy::dragon::format_exact"
    ],
    "write": [
      "num::flt2dec::strategy::dragon::format_shortest",
      "num::flt2dec::strategy::dragon::format_exact",
      "num::flt2dec::strategy::dragon::format_shortest",
      "num::flt2dec::strategy::dragon::format_exact"
    ],
    "other": [
      "num::flt2dec::strategy::dragon::format_shortest",
      "num::flt2dec::strategy::dragon::format_exact",
      "num::bignum::Big32x40::from_small",
      "num::bignum::Big32x40::from_u64"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "num::bignum::Big32x40::digits",
        "num::bignum::Big32x40::add",
        "num::bignum::Big32x40::add_small",
        "num::bignum::Big32x40::sub",
        "num::bignum::Big32x40::mul_small",
        "num::bignum::Big32x40::mul_pow2",
        "num::bignum::Big32x40::mul_digits",
        "num::bignum::Big32x40::div_rem_small",
        "<num::bignum::Big32x40 as cmp::Ord>::cmp",
        "<num::bignum::Big32x40 as clone::Clone>::clone",
        "<num::bignum::Big32x40 as fmt::Debug>::fmt"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "num::bignum::Big32x40::digits",
        "num::bignum::Big32x40::get_bit",
        "num::bignum::Big32x40::add",
        "num::bignum::Big32x40::add_small",
        "num::bignum::Big32x40::sub",
        "num::bignum::Big32x40::mul_small",
        "num::bignum::Big32x40::mul_pow2",
        "num::bignum::Big32x40::mul_digits",
        "num::bignum::Big32x40::div_rem_small",
        "<num::bignum::Big32x40 as cmp::PartialEq>::eq",
        "<num::bignum::Big32x40 as cmp::Ord>::cmp",
        "<num::bignum::Big32x40 as clone::Clone>::clone",
        "<num::bignum::Big32x40 as fmt::Debug>::fmt"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/num/bignum.rs:79:9: 87:10",
  "src": "pub struct $name {\n            /// One plus the offset to the maximum \"digit\" in use.\n            /// This does not decrease, so be aware of the computation order.\n            /// `base[size..]` should be zero.\n            size: usize,\n            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n            /// where `W` is the number of bits in the digit type.\n            base: [$ty; $n],\n        }",
  "kind": "Struct",
  "doc_adt": " Stack-allocated arbitrary-precision (up to certain limit) integer.\n\n This is backed by a fixed-size array of given type (\"digit\").\n While the array is not very large (normally some hundred bytes),\n copying it recklessly may result in the performance hit.\n Thus this is intentionally not `Copy`.\n\n All operations available to bignums panic in the case of overflows.\n The caller is responsible to use large enough bignum types.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "size",
      "doc": " One plus the offset to the maximum \"digit\" in use.\n This does not decrease, so be aware of the computation order.\n `base[size..]` should be zero.\n"
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "base",
      "doc": " Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n where `W` is the number of bits in the digit type.\n"
    }
  }
}