{
  "name": "str::error::Utf8Error",
  "constructors": [
    "bstr::<impl convert::TryFrom<&'a bstr::ByteStr> for &'a str>::try_from",
    "bstr::<impl convert::TryFrom<&'a mut bstr::ByteStr> for &'a mut str>::try_from",
    "ffi::c_str::CStr::to_str",
    "str::converts::from_utf8",
    "str::converts::from_utf8_mut",
    "str::validations::run_utf8_validation",
    "str::<impl str>::from_utf8",
    "str::<impl str>::from_utf8_mut",
    "wtf8::Wtf8::as_str",
    "<str::error::Utf8Error as clone::Clone>::clone"
  ],
  "access_self_as_arg": {
    "read": [
      "str::error::Utf8Error::valid_up_to",
      "str::error::Utf8Error::error_len",
      "<str::error::Utf8Error as fmt::Display>::fmt",
      "<str::error::Utf8Error as cmp::Eq>::assert_receiver_is_total_eq",
      "<str::error::Utf8Error as cmp::PartialEq>::eq",
      "<str::error::Utf8Error as clone::Clone>::clone",
      "<str::error::Utf8Error as fmt::Debug>::fmt"
    ],
    "write": [
      "<str::error::Utf8Error as clone::Clone>::clone"
    ],
    "other": [
      "<str::error::Utf8Error as clone::Clone>::clone"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "str::converts::from_utf8",
      "str::converts::from_utf8_mut",
      "str::validations::run_utf8_validation"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "str::error::Utf8Error::valid_up_to",
        "<str::error::Utf8Error as fmt::Display>::fmt",
        "<str::error::Utf8Error as cmp::PartialEq>::eq",
        "<str::error::Utf8Error as fmt::Debug>::fmt"
      ],
      "other": []
    },
    {
      "read": [],
      "write": [
        "str::error::Utf8Error::error_len",
        "<str::error::Utf8Error as fmt::Display>::fmt",
        "<str::error::Utf8Error as cmp::PartialEq>::eq",
        "<str::error::Utf8Error as fmt::Debug>::fmt"
      ],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/error.rs:47:1: 47:21",
  "src": "pub struct Utf8Error",
  "kind": "Struct",
  "doc_adt": " Errors which can occur when attempting to interpret a sequence of [`u8`]\n as a string.\n\n As such, the `from_utf8` family of functions and methods for both [`String`]s\n and [`&str`]s make use of this error, for example.\n\n [`String`]: ../../std/string/struct.String.html#method.from_utf8\n [`&str`]: super::from_utf8\n\n # Examples\n\n This error typeâ€™s methods can be used to create functionality\n similar to `String::from_utf8_lossy` without allocating heap memory:\n\n ```\n fn from_utf8_lossy<F>(mut input: &[u8], mut push: F) where F: FnMut(&str) {\n     loop {\n         match std::str::from_utf8(input) {\n             Ok(valid) => {\n                 push(valid);\n                 break\n             }\n             Err(error) => {\n                 let (valid, after_valid) = input.split_at(error.valid_up_to());\n                 unsafe {\n                     push(std::str::from_utf8_unchecked(valid))\n                 }\n                 push(\"\\u{FFFD}\");\n\n                 if let Some(invalid_sequence_length) = error.error_len() {\n                     input = &after_valid[invalid_sequence_length..]\n                 } else {\n                     break\n                 }\n             }\n         }\n     }\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "valid_up_to",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "error_len",
      "doc": ""
    }
  }
}