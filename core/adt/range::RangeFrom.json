{
  "name": "range::RangeFrom",
  "constructors": [
    "range::iter::RangeFromIter::<A>::remainder",
    "<range::RangeFrom<T> as convert::From<ops::range::RangeFrom<T>>>::from",
    "<range::RangeFrom<Idx> as clone::Clone>::clone"
  ],
  "access_self_as_arg": {
    "read": [
      "<range::RangeFrom<Idx> as fmt::Debug>::fmt",
      "range::RangeFrom::<Idx>::iter",
      "range::RangeFrom::<Idx>::contains",
      "<range::RangeFrom<T> as ops::range::RangeBounds<T>>::start_bound",
      "<range::RangeFrom<T> as ops::range::RangeBounds<T>>::end_bound",
      "<range::RangeFrom<&T> as ops::range::RangeBounds<T>>::start_bound",
      "<range::RangeFrom<&T> as ops::range::RangeBounds<T>>::end_bound",
      "<range::RangeFrom<Idx> as hash::Hash>::hash",
      "<range::RangeFrom<Idx> as clone::Clone>::clone",
      "<range::RangeFrom<Idx> as cmp::PartialEq>::eq",
      "<range::RangeFrom<Idx> as cmp::Eq>::assert_receiver_is_total_eq"
    ],
    "write": [],
    "other": [
      "range::iter::<impl iter::traits::collect::IntoIterator for range::RangeFrom<A>>::into_iter",
      "range::RangeFrom::<Idx>::iter",
      "<range::RangeFrom<T> as ops::range::IntoBounds<T>>::into_bounds",
      "range::<impl convert::From<range::RangeFrom<T>> for ops::range::RangeFrom<T>>::from",
      "<range::RangeFrom<usize> as slice::index::SliceIndex<[T]>>::get",
      "<range::RangeFrom<usize> as slice::index::SliceIndex<[T]>>::get_mut",
      "<range::RangeFrom<usize> as slice::index::SliceIndex<[T]>>::get_unchecked",
      "<range::RangeFrom<usize> as slice::index::SliceIndex<[T]>>::get_unchecked_mut",
      "<range::RangeFrom<usize> as slice::index::SliceIndex<[T]>>::index",
      "<range::RangeFrom<usize> as slice::index::SliceIndex<[T]>>::index_mut",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get_mut",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get_unchecked",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get_unchecked_mut",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::index",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::index_mut",
      "bstr::traits::<impl slice::index::SliceIndex<bstr::ByteStr> for range::RangeFrom<usize>>::get",
      "bstr::traits::<impl slice::index::SliceIndex<bstr::ByteStr> for range::RangeFrom<usize>>::get_mut",
      "bstr::traits::<impl slice::index::SliceIndex<bstr::ByteStr> for range::RangeFrom<usize>>::get_unchecked",
      "bstr::traits::<impl slice::index::SliceIndex<bstr::ByteStr> for range::RangeFrom<usize>>::get_unchecked_mut",
      "bstr::traits::<impl slice::index::SliceIndex<bstr::ByteStr> for range::RangeFrom<usize>>::index",
      "bstr::traits::<impl slice::index::SliceIndex<bstr::ByteStr> for range::RangeFrom<usize>>::index_mut",
      "<range::RangeFrom<Idx> as clone::Clone>::clone",
      "range::iter::<impl iter::traits::collect::IntoIterator for range::RangeFrom<A>>::into_iter",
      "<range::RangeFrom<T> as ops::range::IntoBounds<T>>::into_bounds",
      "range::<impl convert::From<range::RangeFrom<T>> for ops::range::RangeFrom<T>>::from",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get_mut",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get_unchecked",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::get_unchecked_mut",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::index",
      "str::traits::<impl slice::index::SliceIndex<str> for range::RangeFrom<usize>>::index_mut"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "range::iter::RangeFromIter::<A>::remainder",
      "<range::RangeFrom<T> as convert::From<ops::range::RangeFrom<T>>>::from"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "<range::RangeFrom<Idx> as fmt::Debug>::fmt",
        "<range::RangeFrom<T> as ops::range::RangeBounds<T>>::start_bound",
        "<range::RangeFrom<&T> as ops::range::RangeBounds<T>>::start_bound",
        "<range::RangeFrom<Idx> as hash::Hash>::hash",
        "<range::RangeFrom<Idx> as clone::Clone>::clone",
        "<range::RangeFrom<Idx> as cmp::PartialEq>::eq"
      ],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/range.rs:447:1: 447:26",
  "src": "pub struct RangeFrom<Idx>",
  "kind": "Struct",
  "doc_adt": " A range only bounded inclusively below (`start..`).\n\n The `RangeFrom` `start..` contains all values with `x >= start`.\n\n *Note*: Overflow in the [`Iterator`] implementation (when the contained\n data type reaches its numerical limit) is allowed to panic, wrap, or\n saturate. This behavior is defined by the implementation of the [`Step`]\n trait. For primitive integers, this follows the normal rules, and respects\n the overflow checks profile (panic in debug, wrap in release). Note also\n that overflow happens earlier than you might assume: the overflow happens\n in the call to `next` that yields the maximum value, as the range must be\n set to a state to yield the next value.\n\n [`Step`]: crate::iter::Step\n\n # Examples\n\n The `start..` syntax is a `RangeFrom`:\n\n ```\n #![feature(new_range_api)]\n use core::range::RangeFrom;\n\n assert_eq!(RangeFrom::from(2..), core::range::RangeFrom { start: 2 });\n assert_eq!(2 + 3 + 4, RangeFrom::from(2..).into_iter().take(3).sum());\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "start",
      "doc": " The lower bound of the range (inclusive).\n"
    }
  }
}