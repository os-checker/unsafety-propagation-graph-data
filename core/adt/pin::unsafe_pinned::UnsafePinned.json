{
  "name": "pin::unsafe_pinned::UnsafePinned",
  "constructors": [
    "pin::unsafe_pinned::UnsafePinned::<T>::new",
    "<pin::unsafe_pinned::UnsafePinned<T> as default::Default>::default",
    "<pin::unsafe_pinned::UnsafePinned<T> as convert::From<T>>::from"
  ],
  "access_self_as_arg": {
    "read": [
      "pin::unsafe_pinned::UnsafePinned::<T>::get",
      "<pin::unsafe_pinned::UnsafePinned<T> as fmt::Debug>::fmt"
    ],
    "write": [
      "pin::unsafe_pinned::UnsafePinned::<T>::get_mut_unchecked"
    ],
    "other": [
      "pin::unsafe_pinned::UnsafePinned::<T>::into_inner",
      "pin::unsafe_pinned::UnsafePinned::<T>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "pin::unsafe_pinned::UnsafePinned::<T>::get_mut_pinned"
    ],
    "other": [
      "pin::unsafe_pinned::UnsafePinned::<T>::new",
      "<pin::unsafe_pinned::UnsafePinned<T> as default::Default>::default",
      "<pin::unsafe_pinned::UnsafePinned<T> as convert::From<T>>::from"
    ]
  },
  "access_field": [
    {
      "read": [
        "pin::unsafe_pinned::UnsafePinned::<T>::get"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/pin/unsafe_pinned.rs:27:1: 27:35",
  "src": "pub struct UnsafePinned<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " This type provides a way to entirely opt-out of typical aliasing rules;\n specifically, `&mut UnsafePinned<T>` is not guaranteed to be a unique pointer.\n This also subsumes the effects of `UnsafeCell`, i.e., `&UnsafePinned<T>` may point to data\n that is being mutated.\n\n However, even if you define your type like `pub struct Wrapper(UnsafePinned<...>)`, it is still\n very risky to have an `&mut Wrapper` that aliases anything else. Many functions that work\n generically on `&mut T` assume that the memory that stores `T` is uniquely owned (such as\n `mem::swap`). In other words, while having aliasing with `&mut Wrapper` is not immediate\n Undefined Behavior, it is still unsound to expose such a mutable reference to code you do not\n control! Techniques such as pinning via [`Pin`] are needed to ensure soundness.\n\n Similar to [`UnsafeCell`](crate::cell::UnsafeCell), `UnsafePinned` will not usually show up in\n the public API of a library. It is an internal implementation detail of libraries that need to\n support aliasing mutable references.\n\n This type blocks niches the same way `UnsafeCell` does.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}