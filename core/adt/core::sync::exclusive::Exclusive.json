{
  "name": "core::sync::exclusive::Exclusive",
  "constructors": [
    "core::sync::exclusive::Exclusive::<T>::new",
    "core::<sync::exclusive::Exclusive<T> as convert::From<T>>::from",
    "core::<sync::exclusive::Exclusive<T> as clone::Clone>::clone",
    "core::<sync::exclusive::Exclusive<T> as default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "core::<sync::exclusive::Exclusive<T> as fmt::Debug>::fmt",
      "core::<sync::exclusive::Exclusive<F> as ops::function::Fn<Args>>::call",
      "core::<sync::exclusive::Exclusive<T> as convert::AsRef<T>>::as_ref",
      "core::<sync::exclusive::Exclusive<T> as clone::Clone>::clone",
      "core::<sync::exclusive::Exclusive<T> as cmp::PartialEq<sync::exclusive::Exclusive<U>>>::eq",
      "core::<sync::exclusive::Exclusive<T> as hash::Hash>::hash",
      "core::<sync::exclusive::Exclusive<T> as cmp::PartialOrd<sync::exclusive::Exclusive<U>>>::partial_cmp",
      "core::<sync::exclusive::Exclusive<T> as cmp::Ord>::cmp"
    ],
    "write": [
      "core::sync::exclusive::Exclusive::<T>::get_mut",
      "core::<sync::exclusive::Exclusive<F> as ops::function::FnMut<Args>>::call_mut"
    ],
    "other": [
      "core::sync::exclusive::Exclusive::<T>::into_inner",
      "core::<sync::exclusive::Exclusive<F> as ops::function::FnOnce<Args>>::call_once",
      "core::<sync::exclusive::Exclusive<T> as clone::Clone>::clone",
      "core::sync::exclusive::Exclusive::<T>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "core::sync::exclusive::Exclusive::<T>::get_pin_mut",
      "core::sync::exclusive::Exclusive::<T>::from_mut",
      "core::sync::exclusive::Exclusive::<T>::from_pin_mut"
    ],
    "other": [
      "core::sync::exclusive::Exclusive::<T>::new",
      "core::<sync::exclusive::Exclusive<T> as convert::From<T>>::from",
      "core::<sync::exclusive::Exclusive<T> as default::Default>::default"
    ]
  },
  "access_field": [
    {
      "read": [
        "core::<sync::exclusive::Exclusive<T> as convert::AsRef<T>>::as_ref",
        "core::<sync::exclusive::Exclusive<T> as clone::Clone>::clone",
        "core::<sync::exclusive::Exclusive<T> as cmp::PartialEq<sync::exclusive::Exclusive<U>>>::eq",
        "core::<sync::exclusive::Exclusive<T> as hash::Hash>::hash",
        "core::<sync::exclusive::Exclusive<T> as cmp::PartialOrd<sync::exclusive::Exclusive<U>>>::partial_cmp",
        "core::<sync::exclusive::Exclusive<T> as cmp::Ord>::cmp"
      ],
      "write": [
        "core::sync::exclusive::Exclusive::<T>::get_mut",
        "core::sync::exclusive::Exclusive::<T>::get_pin_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/sync/exclusive.rs:90:1: 90:32",
  "src": "pub struct Exclusive<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " `Exclusive` provides _mutable_ access, also referred to as _exclusive_\n access to the underlying value. However, it only permits _immutable_, or _shared_\n access to the underlying value when that value is [`Sync`].\n\n While this may seem not very useful, it allows `Exclusive` to _unconditionally_\n implement `Sync`. Indeed, the safety requirements of `Sync` state that for `Exclusive`\n to be `Sync`, it must be sound to _share_ across threads, that is, it must be sound\n for `&Exclusive` to cross thread boundaries. By design, a `&Exclusive<T>` for non-`Sync` T\n has no API whatsoever, making it useless, thus harmless, thus memory safe.\n\n Certain constructs like [`Future`]s can only be used with _exclusive_ access,\n and are often `Send` but not `Sync`, so `Exclusive` can be used as hint to the\n Rust compiler that something is `Sync` in practice.\n\n ## Examples\n\n Using a non-`Sync` future prevents the wrapping struct from being `Sync`:\n\n ```compile_fail\n use core::cell::Cell;\n\n async fn other() {}\n fn assert_sync<T: Sync>(t: T) {}\n struct State<F> {\n     future: F\n }\n\n assert_sync(State {\n     future: async {\n         let cell = Cell::new(1);\n         let cell_ref = &cell;\n         other().await;\n         let value = cell_ref.get();\n     }\n });\n ```\n\n `Exclusive` ensures the struct is `Sync` without stripping the future of its\n functionality:\n\n ```\n #![feature(exclusive_wrapper)]\n use core::cell::Cell;\n use core::sync::Exclusive;\n\n async fn other() {}\n fn assert_sync<T: Sync>(t: T) {}\n struct State<F> {\n     future: Exclusive<F>\n }\n\n assert_sync(State {\n     future: Exclusive::new(async {\n         let cell = Cell::new(1);\n         let cell_ref = &cell;\n         other().await;\n         let value = cell_ref.get();\n     })\n });\n ```\n\n ## Parallels with a mutex\n\n In some sense, `Exclusive` can be thought of as a _compile-time_ version of\n a mutex, as the borrow-checker guarantees that only one `&mut` can exist\n for any value. This is a parallel with the fact that\n `&` and `&mut` references together can be thought of as a _compile-time_\n version of a read-write lock.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}