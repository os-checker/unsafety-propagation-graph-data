{
  "name": "mem::manually_drop::ManuallyDrop",
  "constructors": [
    "mem::manually_drop::ManuallyDrop::<T>::new",
    "<mem::manually_drop::ManuallyDrop<T> as clone::Clone>::clone",
    "<mem::manually_drop::ManuallyDrop<T> as default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "<mem::manually_drop::ManuallyDrop<T> as ops::deref::Deref>::deref",
      "<mem::manually_drop::ManuallyDrop<T> as clone::Clone>::clone",
      "<mem::manually_drop::ManuallyDrop<T> as fmt::Debug>::fmt",
      "<mem::manually_drop::ManuallyDrop<T> as cmp::PartialEq>::eq",
      "<mem::manually_drop::ManuallyDrop<T> as cmp::Eq>::assert_receiver_is_total_eq",
      "<mem::manually_drop::ManuallyDrop<T> as cmp::PartialOrd>::partial_cmp",
      "<mem::manually_drop::ManuallyDrop<T> as cmp::Ord>::cmp",
      "<mem::manually_drop::ManuallyDrop<T> as hash::Hash>::hash"
    ],
    "write": [
      "mem::manually_drop::ManuallyDrop::<T>::take",
      "mem::manually_drop::ManuallyDrop::<T>::drop",
      "<mem::manually_drop::ManuallyDrop<T> as ops::deref::DerefMut>::deref_mut",
      "array::drain::Drain::<'l, 'f, T, N, F>::new"
    ],
    "other": [
      "mem::manually_drop::ManuallyDrop::<T>::into_inner",
      "<mem::manually_drop::ManuallyDrop<T> as clone::Clone>::clone",
      "mem::manually_drop::ManuallyDrop::<T>::into_inner"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<mem::drop_guard::DropGuard<T, F> as ops::deref::Deref>::deref",
      "array::iter::IntoIter::<T, N>::unsize",
      "<array::iter::IntoIter<T, N> as iter::traits::exact_size::ExactSizeIterator>::len",
      "<array::iter::IntoIter<T, N> as iter::traits::exact_size::ExactSizeIterator>::is_empty",
      "<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk",
      "slice::sort::stable::quicksort::quicksort",
      "<slice::sort::unstable::quicksort::GapGuard<T> as ops::drop::Drop>::drop",
      "slice::sort::shared::smallsort::swap_if_less",
      "slice::sort::shared::smallsort::insert_tail",
      "task::wake::Waker::wake",
      "task::wake::LocalWaker::wake",
      "<array::iter::IntoIter<T, N> as clone::Clone>::clone"
    ],
    "write": [
      "mem::drop_guard::DropGuard::<T, F>::dismiss",
      "<mem::drop_guard::DropGuard<T, F> as ops::deref::DerefMut>::deref_mut",
      "<mem::drop_guard::DropGuard<T, F> as ops::drop::Drop>::drop",
      "array::iter::IntoIter::<T, N>::unsize_mut",
      "<array::iter::IntoIter<T, N> as ops::drop::Drop>::drop",
      "array::<impl [T; N]>::try_map",
      "slice::sort::unstable::quicksort::partition_lomuto_branchless_cyclic"
    ],
    "other": [
      "mem::manually_drop::ManuallyDrop::<T>::new",
      "mem::maybe_uninit::MaybeUninit::<T>::new",
      "mem::transmutability::TransmuteFrom::transmute",
      "mem::drop_guard::DropGuard::<T, F>::new",
      "mem::drop_guard::DropGuard::<T, F>::dismiss",
      "mem::forget",
      "array::iter::<impl iter::traits::collect::IntoIterator for [T; N]>::into_iter",
      "array::iter::IntoIter::<T, N>::new_unchecked",
      "array::iter::IntoIter::<T, N>::empty",
      "array::<impl [T; N]>::try_map",
      "<iter::adapters::filter_map::FilterMap<I, F> as iter::traits::iterator::Iterator>::next_chunk",
      "slice::sort::stable::quicksort::quicksort",
      "slice::sort::unstable::quicksort::partition_hoare_branchy_cyclic",
      "slice::sort::unstable::quicksort::partition_lomuto_branchless_cyclic",
      "slice::sort::shared::smallsort::swap_if_less",
      "slice::sort::shared::smallsort::insert_tail",
      "task::wake::Waker::wake",
      "task::wake::LocalWaker::wake",
      "<mem::manually_drop::ManuallyDrop<T> as default::Default>::default",
      "<array::iter::IntoIter<T, N> as clone::Clone>::clone"
    ]
  },
  "access_field": [
    {
      "read": [
        "<mem::manually_drop::ManuallyDrop<T> as ops::deref::Deref>::deref",
        "<mem::manually_drop::ManuallyDrop<T> as clone::Clone>::clone",
        "<mem::manually_drop::ManuallyDrop<T> as fmt::Debug>::fmt",
        "<mem::manually_drop::ManuallyDrop<T> as cmp::PartialEq>::eq",
        "<mem::manually_drop::ManuallyDrop<T> as cmp::PartialOrd>::partial_cmp",
        "<mem::manually_drop::ManuallyDrop<T> as cmp::Ord>::cmp",
        "<mem::manually_drop::ManuallyDrop<T> as hash::Hash>::hash"
      ],
      "write": [
        "mem::manually_drop::ManuallyDrop::<T>::take",
        "mem::manually_drop::ManuallyDrop::<T>::drop",
        "<mem::manually_drop::ManuallyDrop<T> as ops::deref::DerefMut>::deref_mut"
      ],
      "other": []
    }
  ],
  "span": "$library/core/src/mem/manually_drop.rs:158:1: 158:35",
  "src": "pub struct ManuallyDrop<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A wrapper to inhibit the compiler from automatically calling `T`â€™s\n destructor. This wrapper is 0-cost.\n\n `ManuallyDrop<T>` is guaranteed to have the same layout and bit validity as\n `T`, and is subject to the same layout optimizations as `T`. As a\n consequence, it has *no effect* on the assumptions that the compiler makes\n about its contents. For example, initializing a `ManuallyDrop<&mut T>` with\n [`mem::zeroed`] is undefined behavior. If you need to handle uninitialized\n data, use [`MaybeUninit<T>`] instead.\n\n Note that accessing the value inside a `ManuallyDrop<T>` is safe. This means\n that a `ManuallyDrop<T>` whose content has been dropped must not be exposed\n through a public safe API. Correspondingly, `ManuallyDrop::drop` is unsafe.\n\n # `ManuallyDrop` and drop order\n\n Rust has a well-defined [drop order] of values. To make sure that fields or\n locals are dropped in a specific order, reorder the declarations such that\n the implicit drop order is the correct one.\n\n It is possible to use `ManuallyDrop` to control the drop order, but this\n requires unsafe code and is hard to do correctly in the presence of\n unwinding.\n\n For example, if you want to make sure that a specific field is dropped after\n the others, make it the last field of a struct:\n\n ```\n struct Context;\n\n struct Widget {\n     children: Vec<Widget>,\n     // `context` will be dropped after `children`.\n     // Rust guarantees that fields are dropped in the order of declaration.\n     context: Context,\n }\n ```\n\n # Interaction with `Box`\n\n Currently, if you have a `ManuallyDrop<T>`, where the type `T` is a `Box` or\n contains a `Box` inside, then dropping the `T` followed by moving the\n `ManuallyDrop<T>` is [considered to be undefined\n behavior](https://github.com/rust-lang/unsafe-code-guidelines/issues/245).\n That is, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n let mut x = ManuallyDrop::new(Box::new(42));\n unsafe {\n     ManuallyDrop::drop(&mut x);\n }\n let y = x; // Undefined behavior!\n ```\n\n This is [likely to change in the\n future](https://rust-lang.github.io/rfcs/3336-maybe-dangling.html). In the\n meantime, consider using [`MaybeUninit`] instead.\n\n # Safety hazards when storing `ManuallyDrop` in a struct or an enum.\n\n Special care is needed when all of the conditions below are met:\n * A struct or enum contains a `ManuallyDrop`.\n * The `ManuallyDrop` is not inside a `union`.\n * The struct or enum is part of public API, or is stored in a struct or an\n   enum that is part of public API.\n * There is code that drops the contents of the `ManuallyDrop` field, and\n   this code is outside the struct or enum's `Drop` implementation.\n\n In particular, the following hazards may occur:\n\n #### Storing generic types\n\n If the `ManuallyDrop` contains a client-supplied generic type, the client\n might provide a `Box` as that type. This would cause undefined behavior when\n the struct or enum is later moved, as mentioned in the previous section. For\n example, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n pub struct BadOption<T> {\n     // Invariant: Has been dropped if `is_some` is false.\n     value: ManuallyDrop<T>,\n     is_some: bool,\n }\n impl<T> BadOption<T> {\n     pub fn new(value: T) -> Self {\n         Self { value: ManuallyDrop::new(value), is_some: true }\n     }\n     pub fn change_to_none(&mut self) {\n         if self.is_some {\n             self.is_some = false;\n             unsafe {\n                 // SAFETY: `value` hasn't been dropped yet, as per the invariant\n                 // (This is actually unsound!)\n                 ManuallyDrop::drop(&mut self.value);\n             }\n         }\n     }\n }\n\n // In another crate:\n\n let mut option = BadOption::new(Box::new(42));\n option.change_to_none();\n let option2 = option; // Undefined behavior!\n ```\n\n #### Deriving traits\n\n Deriving `Debug`, `Clone`, `PartialEq`, `PartialOrd`, `Ord`, or `Hash` on\n the struct or enum could be unsound, since the derived implementations of\n these traits would access the `ManuallyDrop` field. For example, the\n following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n // This derive is unsound in combination with the `ManuallyDrop::drop` call.\n #[derive(Debug)]\n pub struct Foo {\n     value: ManuallyDrop<String>,\n }\n impl Foo {\n     pub fn new() -> Self {\n         let mut temp = Self {\n             value: ManuallyDrop::new(String::from(\"Unsafe rust is hard.\"))\n         };\n         unsafe {\n             // SAFETY: `value` hasn't been dropped yet.\n             ManuallyDrop::drop(&mut temp.value);\n         }\n         temp\n     }\n }\n\n // In another crate:\n\n let foo = Foo::new();\n println!(\"{:?}\", foo); // Undefined behavior!\n ```\n\n [drop order]: https://doc.rust-lang.org/reference/destructors.html\n [`mem::zeroed`]: crate::mem::zeroed\n [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n [`MaybeUninit`]: crate::mem::MaybeUninit\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}