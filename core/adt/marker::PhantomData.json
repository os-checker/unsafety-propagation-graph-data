{
  "name": "marker::PhantomData",
  "constructors": [
    "<marker::PhantomData<T> as clone::Clone>::clone",
    "<marker::PhantomData<T> as default::Default>::default"
  ],
  "access_self_as_arg": {
    "read": [
      "<marker::PhantomData<T> as hash::Hash>::hash",
      "<marker::PhantomData<T> as cmp::PartialEq>::eq",
      "<marker::PhantomData<T> as cmp::PartialOrd>::partial_cmp",
      "<marker::PhantomData<T> as cmp::Ord>::cmp",
      "<marker::PhantomData<T> as clone::Clone>::clone",
      "<marker::PhantomData<T> as fmt::Debug>::fmt"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "<error::tags::Value<T> as fmt::Debug>::fmt",
      "<error::tags::MaybeSizedValue<T> as fmt::Debug>::fmt",
      "<error::tags::Ref<I> as fmt::Debug>::fmt",
      "<ffi::c_str::Bytes<'a> as clone::Clone>::clone",
      "<ffi::c_str::Bytes<'a> as fmt::Debug>::fmt",
      "<ffi::va_list::VaList<'a, 'f> as fmt::Debug>::fmt",
      "<fmt::num_buffer::NumBuffer<T> as fmt::Debug>::fmt",
      "<hash::sip::Hasher<S> as fmt::Debug>::fmt",
      "<slice::iter::ChunksMut<'a, T> as fmt::Debug>::fmt",
      "<slice::iter::ChunksExactMut<'a, T> as fmt::Debug>::fmt",
      "<slice::iter::RChunksMut<'a, T> as fmt::Debug>::fmt",
      "<task::wake::ContextBuilder<'a> as fmt::Debug>::fmt",
      "<escape::EscapeIterInner<N, ESCAPING> as clone::Clone>::clone"
    ],
    "write": [],
    "other": [
      "<ffi::c_str::Bytes<'a> as clone::Clone>::clone",
      "<escape::EscapeIterInner<N, ESCAPING> as clone::Clone>::clone"
    ]
  },
  "access_field": [],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/marker.rs:819:1: 819:40",
  "src": "pub struct PhantomData<T: PointeeSized>",
  "kind": "Struct",
  "doc_adt": " Zero-sized type used to mark things that \"act like\" they own a `T`.\n\n Adding a `PhantomData<T>` field to your type tells the compiler that your\n type acts as though it stores a value of type `T`, even though it doesn't\n really. This information is used when computing certain safety properties.\n\n For a more in-depth explanation of how to use `PhantomData<T>`, please see\n [the Nomicon](../../nomicon/phantom-data.html).\n\n # A ghastly note ðŸ‘»ðŸ‘»ðŸ‘»\n\n Though they both have scary names, `PhantomData` and 'phantom types' are\n related, but not identical. A phantom type parameter is simply a type\n parameter which is never used. In Rust, this often causes the compiler to\n complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.\n\n # Examples\n\n ## Unused lifetime parameters\n\n Perhaps the most common use case for `PhantomData` is a struct that has an\n unused lifetime parameter, typically as part of some unsafe code. For\n example, here is a struct `Slice` that has two pointers of type `*const T`,\n presumably pointing into an array somewhere:\n\n ```compile_fail,E0392\n struct Slice<'a, T> {\n     start: *const T,\n     end: *const T,\n }\n ```\n\n The intention is that the underlying data is only valid for the\n lifetime `'a`, so `Slice` should not outlive `'a`. However, this\n intent is not expressed in the code, since there are no uses of\n the lifetime `'a` and hence it is not clear what data it applies\n to. We can correct this by telling the compiler to act *as if* the\n `Slice` struct contained a reference `&'a T`:\n\n ```\n use std::marker::PhantomData;\n\n # #[allow(dead_code)]\n struct Slice<'a, T> {\n     start: *const T,\n     end: *const T,\n     phantom: PhantomData<&'a T>,\n }\n ```\n\n This also in turn infers the lifetime bound `T: 'a`, indicating\n that any references in `T` are valid over the lifetime `'a`.\n\n When initializing a `Slice` you simply provide the value\n `PhantomData` for the field `phantom`:\n\n ```\n # #![allow(dead_code)]\n # use std::marker::PhantomData;\n # struct Slice<'a, T> {\n #     start: *const T,\n #     end: *const T,\n #     phantom: PhantomData<&'a T>,\n # }\n fn borrow_vec<T>(vec: &Vec<T>) -> Slice<'_, T> {\n     let ptr = vec.as_ptr();\n     Slice {\n         start: ptr,\n         end: unsafe { ptr.add(vec.len()) },\n         phantom: PhantomData,\n     }\n }\n ```\n\n ## Unused type parameters\n\n It sometimes happens that you have unused type parameters which\n indicate what type of data a struct is \"tied\" to, even though that\n data is not actually found in the struct itself. Here is an\n example where this arises with [FFI]. The foreign interface uses\n handles of type `*mut ()` to refer to Rust values of different\n types. We track the Rust type using a phantom type parameter on\n the struct `ExternalResource` which wraps a handle.\n\n [FFI]: ../../book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code\n\n ```\n # #![allow(dead_code)]\n # trait ResType { }\n # struct ParamType;\n # mod foreign_lib {\n #     pub fn new(_: usize) -> *mut () { 42 as *mut () }\n #     pub fn do_stuff(_: *mut (), _: usize) {}\n # }\n # fn convert_params(_: ParamType) -> usize { 42 }\n use std::marker::PhantomData;\n\n struct ExternalResource<R> {\n    resource_handle: *mut (),\n    resource_type: PhantomData<R>,\n }\n\n impl<R: ResType> ExternalResource<R> {\n     fn new() -> Self {\n         let size_of_res = size_of::<R>();\n         Self {\n             resource_handle: foreign_lib::new(size_of_res),\n             resource_type: PhantomData,\n         }\n     }\n\n     fn do_stuff(&self, param: ParamType) {\n         let foreign_params = convert_params(param);\n         foreign_lib::do_stuff(self.resource_handle, foreign_params);\n     }\n }\n ```\n\n ## Ownership and the drop check\n\n The exact interaction of `PhantomData` with drop check **may change in the future**.\n\n Currently, adding a field of type `PhantomData<T>` indicates that your type *owns* data of type\n `T` in very rare circumstances. This in turn has effects on the Rust compiler's [drop check]\n analysis. For the exact rules, see the [drop check] documentation.\n\n ## Layout\n\n For all `T`, the following are guaranteed:\n * `size_of::<PhantomData<T>>() == 0`\n * `align_of::<PhantomData<T>>() == 1`\n\n [drop check]: Drop#drop-check\n",
  "variant_fields": {}
}