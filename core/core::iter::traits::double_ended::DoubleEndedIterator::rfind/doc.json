{
  "name": "core::iter::traits::double_ended::DoubleEndedIterator::rfind",
  "span": "$library/core/src/iter/traits/double_ended.rs:356:5: 359:39",
  "doc": " Searches for an element of an iterator from the back that satisfies a predicate.\n\n `rfind()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, starting at the end, and if any\n of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `rfind()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `rfind()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n [`Some(element)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n\n assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter();\n\n assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next_back(), Some(&1));\n ```\n"
}