{
  "name": "core::f128::<impl f128>::next_up",
  "span": "$library/core/src/num/f128.rs:537:5: 537:39",
  "doc": " Returns the least number greater than `self`.\n\n Let `TINY` be the smallest representable positive `f128`. Then,\n  - if `self.is_nan()`, this returns `self`;\n  - if `self` is [`NEG_INFINITY`], this returns [`MIN`];\n  - if `self` is `-TINY`, this returns -0.0;\n  - if `self` is -0.0 or +0.0, this returns `TINY`;\n  - if `self` is [`MAX`] or [`INFINITY`], this returns [`INFINITY`];\n  - otherwise the unique least value greater than `self` is returned.\n\n The identity `x.next_up() == -(-x).next_down()` holds for all non-NaN `x`. When `x`\n is finite `x == x.next_up().next_down()` also holds.\n\n ```rust\n #![feature(f128)]\n # // FIXME(f16_f128): remove when `eqtf2` is available\n # #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] {\n\n // f128::EPSILON is the difference between 1.0 and the next number up.\n assert_eq!(1.0f128.next_up(), 1.0 + f128::EPSILON);\n // But not for most numbers.\n assert!(0.1f128.next_up() < 0.1 + f128::EPSILON);\n assert_eq!(4611686018427387904f128.next_up(), 4611686018427387904.000000000000001);\n # }\n ```\n\n This operation corresponds to IEEE-754 `nextUp`.\n\n [`NEG_INFINITY`]: Self::NEG_INFINITY\n [`INFINITY`]: Self::INFINITY\n [`MIN`]: Self::MIN\n [`MAX`]: Self::MAX\n"
}