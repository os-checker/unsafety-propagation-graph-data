{
  "name": "core::<[mem::maybe_uninit::MaybeUninit<T>]>::write_clone_of_slice",
  "span": "$library/core/src/mem/maybe_uninit.rs:1205:5: 1207:18",
  "doc": " Clones the elements from `src` to `self`,\n returning a mutable reference to the now initialized contents of `self`.\n Any already initialized elements will not be dropped.\n\n If `T` implements `Copy`, use [`write_copy_of_slice`] instead.\n\n This is similar to [`slice::clone_from_slice`] but does not drop existing elements.\n\n # Panics\n\n This function will panic if the two slices have different lengths, or if the implementation of `Clone` panics.\n\n If there is a panic, the already cloned elements will be dropped.\n\n # Examples\n\n ```\n use std::mem::MaybeUninit;\n\n let mut dst = [const { MaybeUninit::uninit() }; 5];\n let src = [\"wibbly\", \"wobbly\", \"timey\", \"wimey\", \"stuff\"].map(|s| s.to_string());\n\n let init = dst.write_clone_of_slice(&src);\n\n assert_eq!(init, src);\n\n # // Prevent leaks for Miri\n # unsafe { std::ptr::drop_in_place(init); }\n ```\n\n ```\n let mut vec = Vec::with_capacity(32);\n let src = [\"rust\", \"is\", \"a\", \"pretty\", \"cool\", \"language\"].map(|s| s.to_string());\n\n vec.spare_capacity_mut()[..src.len()].write_clone_of_slice(&src);\n\n // SAFETY: we have just cloned all the elements of len into the spare capacity\n // the first src.len() elements of the vec are valid now.\n unsafe {\n     vec.set_len(src.len());\n }\n\n assert_eq!(vec, src);\n ```\n\n [`write_copy_of_slice`]: slice::write_copy_of_slice\n"
}