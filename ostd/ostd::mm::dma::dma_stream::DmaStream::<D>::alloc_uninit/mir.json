{
  "name": "ostd::mm::dma::dma_stream::DmaStream::<D>::alloc_uninit",
  "span": "ostd/src/mm/dma/dma_stream.rs:125:5: 125:88",
  "mir": "fn ostd::mm::dma::dma_stream::DmaStream::<D>::alloc_uninit(_1: usize, _2: bool) -> core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error> {\n    let mut _0: core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error>;\n    let  _3: bool;\n    let  _4: mm::dma::dma_stream::Inner;\n    let  _5: core::ops::Range<usize>;\n    let mut _6: (mm::dma::dma_stream::Inner, core::ops::Range<usize>);\n    let mut _7: bool;\n    let  _8: mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta>;\n    let mut _9: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::segment::Segment<()>>;\n    let mut _10: core::result::Result<mm::frame::segment::Segment<()>, error::Error>;\n    let mut _11: &mm::frame::allocator::FrameAllocOptions;\n    let  _12: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _13: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _14: mm::frame::allocator::FrameAllocOptions;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _17: mm::frame::segment::Segment<()>;\n    let  _18: core::ops::Range<usize>;\n    let mut _19: &mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta>;\n    let mut _20: mm::dma::dma_stream::Inner;\n    let  _21: mm::kspace::kvirt_area::KVirtArea;\n    let  _22: usize;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, (mm::kspace::kvirt_area::KVirtArea, usize)>;\n    let mut _24: core::result::Result<(mm::kspace::kvirt_area::KVirtArea, usize), error::Error>;\n    let mut _25: bool;\n    let mut _26: bool;\n    let mut _27: isize;\n    let  _28: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _29: (mm::kspace::kvirt_area::KVirtArea, usize);\n    let mut _30: mm::dma::dma_stream::Inner;\n    let mut _31: core::ops::Range<usize>;\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: (usize, bool);\n    let mut _35: (usize, bool);\n    let  _36: core::option::Option<usize>;\n    let  _37: &core::ops::Range<usize>;\n    let mut _38: mm::dma::dma_stream::DmaStream<D>;\n    debug nframes => _1;\n    debug is_cache_coherent => _2;\n    debug cvm => _3;\n    debug inner => _4;\n    debug paddr_range => _5;\n    debug segment => _8;\n    debug residual => _16;\n    debug val => _17;\n    debug paddr_range => _18;\n    debug kva => _21;\n    debug paddr => _22;\n    debug residual => _28;\n    debug val => _29;\n    debug map_daddr => _36;\n    bb0: {\n        _3 = mm::dma::util::cvm_need_private_protection() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = arch::mm::can_sync_dma() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _7) -> [0: bb3, otherwise: bb4];\n    }\n    bb3: {\n        switchInt(_2) -> [0: bb16, otherwise: bb4];\n    }\n    bb4: {\n        switchInt(_3) -> [0: bb5, otherwise: bb16];\n    }\n    bb5: {\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = &mut _14;\n        _12 = mm::frame::allocator::FrameAllocOptions::zeroed(move _13, false) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = &(*_12);\n        StorageDead(_13);\n        _10 = mm::frame::allocator::FrameAllocOptions::alloc_segment(move _11, _1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _9 = <core::result::Result<mm::frame::segment::Segment<()>, error::Error> as core::ops::Try>::branch(move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        _15 = discriminant(_9);\n        switchInt(move _15) -> [0: bb11, 1: bb12, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _17 = move ((_9 as variant#0).0: mm::frame::segment::Segment<()>);\n        _8 = <mm::frame::segment::Segment<()> as core::convert::Into<mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta>>>::into(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _16 = ((_9 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_9);\n        goto -> bb30;\n    }\n    bb14: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageLive(_19);\n        _19 = &_8;\n        _18 = <mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta> as mm::mem_obj::HasPaddrRange>::paddr_range(move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = mm::dma::dma_stream::Inner::Segment(_8);\n        _6 = (move _20, _18);\n        StorageDead(_20);\n        goto -> bb28;\n    }\n    bb16: {\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = arch::mm::can_sync_dma() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        switchInt(move _26) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        _25 = true;\n        goto -> bb20;\n    }\n    bb19: {\n        _25 = _2;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_26);\n        _24 = mm::dma::util::alloc_kva(_1, move _25) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_25);\n        _23 = <core::result::Result<(mm::kspace::kvirt_area::KVirtArea, usize), error::Error> as core::ops::Try>::branch(move _24) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_24);\n        _27 = discriminant(_23);\n        switchInt(move _27) -> [0: bb23, 1: bb24, otherwise: bb10];\n    }\n    bb23: {\n        _29 = move ((_23 as variant#0).0: (mm::kspace::kvirt_area::KVirtArea, usize));\n        _21 = (_29.0: mm::kspace::kvirt_area::KVirtArea);\n        _22 = (_29.1: usize);\n        StorageDead(_23);\n        StorageLive(_30);\n        _30 = mm::dma::dma_stream::Inner::Kva(_21, _22);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _34 = CheckedMul(_1, mm::PAGE_SIZE);\n        assert(!move (_34.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _1, mm::PAGE_SIZE) -> [success: bb26, unwind unreachable];\n    }\n    bb24: {\n        _28 = ((_23 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_28) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_23);\n        goto -> bb30;\n    }\n    bb26: {\n        _33 = move (_34.0: usize);\n        _35 = CheckedAdd(_22, _33);\n        assert(!move (_35.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _22, move _33) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _32 = move (_35.0: usize);\n        StorageDead(_33);\n        _31 = Range(_22, move _32);\n        StorageDead(_32);\n        _6 = (move _30, move _31);\n        StorageDead(_31);\n        StorageDead(_30);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_7);\n        _4 = move (_6.0: mm::dma::dma_stream::Inner);\n        StorageLive(_5);\n        _5 = move (_6.1: core::ops::Range<usize>);\n        StorageDead(_6);\n        _37 = &_5;\n        _36 = mm::dma::util::prepare_dma(_37) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_38);\n        _38 = DmaStream(_4, _36, _2, ZeroSized: core::marker::PhantomData<D>);\n        _0 = core::result::Result::Ok(move _38);\n        StorageDead(_38);\n        StorageDead(_5);\n        goto -> bb31;\n    }\n    bb30: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb31;\n    }\n    bb31: {\n        return;\n    }\n}\n"
}