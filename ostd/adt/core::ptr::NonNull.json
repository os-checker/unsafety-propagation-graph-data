{
  "name": "core::ptr::NonNull",
  "constructors": [
    "mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::into_raw",
    "mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::ref_as_raw",
    "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::into_raw",
    "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::ref_as_raw",
    "sync::rcu::non_null::either::remove_bits",
    "<alloc::boxed::Box<T> as sync::rcu::non_null::NonNullPtr>::into_raw",
    "<alloc::boxed::Box<T> as sync::rcu::non_null::NonNullPtr>::ref_as_raw",
    "<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::into_raw",
    "<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::ref_as_raw",
    "task::processor::current_task"
  ],
  "access_self_as_arg": {
    "read": [
      "arch::iommu::fault::init"
    ],
    "write": [],
    "other": [
      "arch::iommu::fault::FaultEventRegisters::new",
      "arch::iommu::fault::init",
      "arch::iommu::registers::invalidation::InvalidationRegisters::new",
      "arch::timer::hpet::Hpet::new",
      "mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::from_raw",
      "mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::raw_as_ref",
      "mm::heap::slot::HeapSlot::new",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::from_raw",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::raw_as_ref",
      "sync::rcu::non_null::either::remove_bits",
      "<alloc::boxed::Box<T> as sync::rcu::non_null::NonNullPtr>::from_raw",
      "<alloc::boxed::Box<T> as sync::rcu::non_null::NonNullPtr>::raw_as_ref",
      "<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::from_raw",
      "<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::raw_as_ref",
      "sync::rcu::delay_drop",
      "task::CurrentTask::new",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::from_raw",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::raw_as_ref",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::from_raw",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::raw_as_ref"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "mm::frame::linked_list::CursorMut::<'_, M>::move_next",
      "mm::frame::linked_list::CursorMut::<'_, M>::move_prev",
      "<task::CurrentTask as core::ops::Deref>::deref",
      "<task::CurrentTask as core::fmt::Debug>::fmt"
    ],
    "write": [
      "mm::frame::linked_list::CursorMut::<'_, M>::take_current",
      "mm::frame::linked_list::CursorMut::<'_, M>::insert_before",
      "mm::frame::linked_list::CursorMut::<'_, M>::insert_before"
    ],
    "other": [
      "arch::iommu::registers::IommuRegisters::new",
      "arch::kernel::acpi::dmar::Dmar::new",
      "<arch::kernel::acpi::AcpiMemoryHandler as acpi::AcpiHandler>::map_physical_region",
      "arch::timer::hpet::init",
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_target",
      "cpu::local::dyn_cpu_local::<impl cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::__new_dynamic",
      "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::get_item_index",
      "mm::dma::util::alloc_unprotect_physical_range",
      "mm::frame::linked_list::LinkedList::<M>::cursor_mut_at",
      "mm::frame::linked_list::CursorMut::<'_, M>::move_next",
      "mm::frame::linked_list::CursorMut::<'_, M>::move_prev",
      "mm::frame::linked_list::CursorMut::<'_, M>::take_current",
      "mm::frame::linked_list::CursorMut::<'_, M>::insert_before",
      "mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::into_raw",
      "mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::ref_as_raw",
      "mm::heap::slab::<impl mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>::new",
      "mm::heap::slot::HeapSlot::alloc_large",
      "mm::heap::slot::HeapSlot::paddr",
      "mm::heap::slot::HeapSlot::as_ptr",
      "mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push",
      "mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::pop",
      "<mm::heap::AllocDispatch as core::alloc::GlobalAlloc>::dealloc",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::into_raw",
      "sync::rcu::non_null::either::<impl sync::rcu::non_null::NonNullPtr for util::either::Either<L, R>>::ref_as_raw",
      "<alloc::boxed::Box<T> as sync::rcu::non_null::NonNullPtr>::into_raw",
      "<alloc::boxed::Box<T> as sync::rcu::non_null::NonNullPtr>::ref_as_raw",
      "<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::into_raw",
      "<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::ref_as_raw",
      "sync::rcu::RcuInner::<P>::new",
      "sync::rcu::RcuInner::<P>::update",
      "<sync::rcu::RcuInner<P> as core::ops::Drop>::drop",
      "sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange",
      "task::Task::current",
      "task::CurrentTask::cloned"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ptr/non_null.rs:76:1: 76:36",
  "src": "pub struct NonNull<T: PointeeSized>",
  "kind": "Struct",
  "doc_adt": " `*mut T` but non-zero and [covariant].\n\n This is often the correct thing to use when building data structures using\n raw pointers, but is ultimately more dangerous to use because of its additional\n properties. If you're not sure if you should use `NonNull<T>`, just use `*mut T`!\n\n Unlike `*mut T`, the pointer must always be non-null, even if the pointer\n is never dereferenced. This is so that enums may use this forbidden value\n as a discriminant -- `Option<NonNull<T>>` has the same size as `*mut T`.\n However the pointer may still dangle if it isn't dereferenced.\n\n Unlike `*mut T`, `NonNull<T>` is covariant over `T`. This is usually the correct\n choice for most data structures and safe abstractions, such as `Box`, `Rc`, `Arc`, `Vec`,\n and `LinkedList`.\n\n In rare cases, if your type exposes a way to mutate the value of `T` through a `NonNull<T>`,\n and you need to prevent unsoundness from variance (for example, if `T` could be a reference\n with a shorter lifetime), you should add a field to make your type invariant, such as\n `PhantomData<Cell<T>>` or `PhantomData<&'a mut T>`.\n\n Example of a type that must be invariant:\n ```rust\n use std::cell::Cell;\n use std::marker::PhantomData;\n struct Invariant<T> {\n     ptr: std::ptr::NonNull<T>,\n     _invariant: PhantomData<Cell<T>>,\n }\n ```\n\n Notice that `NonNull<T>` has a `From` instance for `&T`. However, this does\n not change the fact that mutating through a (pointer derived from a) shared\n reference is undefined behavior unless the mutation happens inside an\n [`UnsafeCell<T>`]. The same goes for creating a mutable reference from a shared\n reference. When using this `From` instance without an `UnsafeCell<T>`,\n it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n is never used for mutation.\n\n # Representation\n\n Thanks to the [null pointer optimization],\n `NonNull<T>` and `Option<NonNull<T>>`\n are guaranteed to have the same size and alignment:\n\n ```\n use std::ptr::NonNull;\n\n assert_eq!(size_of::<NonNull<i16>>(), size_of::<Option<NonNull<i16>>>());\n assert_eq!(align_of::<NonNull<i16>>(), align_of::<Option<NonNull<i16>>>());\n\n assert_eq!(size_of::<NonNull<str>>(), size_of::<Option<NonNull<str>>>());\n assert_eq!(align_of::<NonNull<str>>(), align_of::<Option<NonNull<str>>>());\n ```\n\n [covariant]: https://doc.rust-lang.org/reference/subtyping.html\n [`PhantomData`]: crate::marker::PhantomData\n [`UnsafeCell<T>`]: crate::cell::UnsafeCell\n [null pointer optimization]: crate::option#representation\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "pointer",
      "doc": ""
    }
  }
}