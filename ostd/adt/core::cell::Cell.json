{
  "name": "core::cell::Cell",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "task::TaskOptions::build::kernel_task_entry"
    ],
    "write": [],
    "other": [
      "task::TaskOptions::build"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/cell.rs:313:1: 313:27",
  "src": "pub struct Cell<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A mutable memory location.\n\n # Memory layout\n\n `Cell<T>` has the same [memory layout and caveats as\n `UnsafeCell<T>`](UnsafeCell#memory-layout). In particular, this means that\n `Cell<T>` has the same in-memory representation as its inner type `T`.\n\n # Examples\n\n In this example, you can see that `Cell<T>` enables mutation inside an\n immutable struct. In other words, it enables \"interior mutability\".\n\n ```\n use std::cell::Cell;\n\n struct SomeStruct {\n     regular_field: u8,\n     special_field: Cell<u8>,\n }\n\n let my_struct = SomeStruct {\n     regular_field: 0,\n     special_field: Cell::new(1),\n };\n\n let new_value = 100;\n\n // ERROR: `my_struct` is immutable\n // my_struct.regular_field = new_value;\n\n // WORKS: although `my_struct` is immutable, `special_field` is a `Cell`,\n // which can always be mutated\n my_struct.special_field.set(new_value);\n assert_eq!(my_struct.special_field.get(), new_value);\n ```\n\n See the [module-level documentation](self) for more.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}