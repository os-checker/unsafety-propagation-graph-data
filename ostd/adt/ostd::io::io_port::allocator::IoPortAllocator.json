{
  "name": "ostd::io::io_port::allocator::IoPortAllocator",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "ostd::io::io_port::allocator::IoPortAllocator::acquire",
      "ostd::io::io_port::allocator::IoPortAllocator::recycle"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "ostd::<io::io_port::IoPort<T, A> as core::ops::Drop>::drop",
      "ostd::io::io_port::IoPort::<T, A>::acquire",
      "ostd::io::io_port::IoPort::<T, A>::acquire_overlapping",
      "ostd::io::io_port::allocator::init"
    ],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [
        "ostd::io::io_port::allocator::IoPortAllocator::acquire",
        "ostd::io::io_port::allocator::IoPortAllocator::recycle"
      ],
      "write": [],
      "other": []
    }
  ],
  "span": "ostd/src/io/io_port/allocator.rs:17:1: 17:34",
  "src": "pub(super) struct IoPortAllocator",
  "kind": "Struct",
  "doc_adt": " I/O port allocator that allocates port I/O access to device drivers.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "allocator",
      "doc": " Each ID indicates whether a Port I/O (1B) is allocated.\n\n Instead of using `RangeAllocator` like `IoMemAllocator` does, it is more reasonable to use `IdAlloc`,\n as PIO space includes only a small region; for example, x86 module in OSTD allows just 65536 I/O ports.\n"
    }
  }
}