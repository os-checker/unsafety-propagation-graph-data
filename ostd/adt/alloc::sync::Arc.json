{
  "name": "alloc::sync::Arc",
  "constructors": [
    "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::from_raw",
    "ostd::<task::scheduler::fifo_scheduler::FifoRunQueue<T> as task::scheduler::LocalRunQueue<T>>::dequeue_current",
    "ostd::sync::wait::Waiter::new_pair",
    "ostd::sync::wait::Waiter::waker",
    "ostd::task::CurrentTask::cloned",
    "ostd::task::TaskOptions::spawn"
  ],
  "access_self_as_arg": {
    "read": [
      "ostd::<alloc::sync::Arc<T> as mm::io_util::HasVmReaderWriter>::reader",
      "ostd::<alloc::sync::Arc<T> as mm::io_util::HasVmReaderWriter>::writer",
      "ostd::<alloc::sync::Arc<T> as mm::mem_obj::HasDaddr>::daddr",
      "ostd::<alloc::sync::Arc<T> as mm::mem_obj::HasPaddr>::paddr",
      "ostd::<alloc::sync::Arc<T> as mm::mem_obj::HasSize>::size",
      "ostd::<task::scheduler::fifo_scheduler::FifoScheduler<T> as task::scheduler::Scheduler<T>>::enqueue",
      "ostd::mm::vm_space::VmSpace::activate",
      "ostd::task::Task::run",
      "ostd::task::processor::switch_to_task"
    ],
    "write": [],
    "other": [
      "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::into_raw",
      "ostd::<task::scheduler::fifo_scheduler::FifoScheduler<T> as task::scheduler::Scheduler<T>>::enqueue",
      "ostd::mm::vm_space::VmSpace::activate",
      "ostd::sync::wait::WaitQueue::enqueue",
      "ostd::task::Task::run",
      "ostd::task::processor::switch_to_task",
      "ostd::task::scheduler::run_new_task",
      "ostd::task::scheduler::unpark_target"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "ostd::<io::io_mem::IoMem as mm::io_util::HasVmReaderWriter>::reader",
      "ostd::<io::io_mem::IoMem as mm::io_util::HasVmReaderWriter>::writer",
      "ostd::<io::io_mem::IoMem<SecuritySensitivity> as core::clone::Clone>::clone",
      "ostd::<io::io_mem::IoMem<SecuritySensitivity> as core::fmt::Debug>::fmt",
      "ostd::<irq::top_half::IrqLine as core::clone::Clone>::clone",
      "ostd::<irq::top_half::IrqLine as core::fmt::Debug>::fmt",
      "ostd::<sync::rcu::non_null::ArcRef<'_, T> as core::ops::Deref>::deref",
      "ostd::<sync::rwarc::RwArc<T> as core::clone::Clone>::clone",
      "ostd::<sync::rwarc::RwArc<T> as core::ops::Drop>::drop",
      "ostd::<sync::wait::Waiter as core::ops::Drop>::drop",
      "ostd::io::io_mem::IoMem::<SecuritySensitivity>::slice",
      "ostd::io::io_mem::IoMem::<io::io_mem::Sensitive>::read_once",
      "ostd::io::io_mem::IoMem::<io::io_mem::Sensitive>::write_once",
      "ostd::irq::top_half::IrqLine::num",
      "ostd::irq::top_half::IrqLine::on_active",
      "ostd::irq::top_half::IrqLine::remapping_index",
      "ostd::sync::rcu::non_null::ArcRef::<'a, T>::deref_target",
      "ostd::sync::rwarc::RoArc::<T>::read",
      "ostd::sync::rwarc::RwArc::<T>::clone_ro",
      "ostd::sync::rwarc::RwArc::<T>::get",
      "ostd::sync::rwarc::RwArc::<T>::read",
      "ostd::sync::rwarc::RwArc::<T>::write",
      "ostd::sync::wait::WaitQueue::wake_all",
      "ostd::sync::wait::WaitQueue::wake_one",
      "ostd::sync::wait::Waiter::new_pair",
      "ostd::sync::wait::Waiter::task",
      "ostd::sync::wait::Waiter::wait",
      "ostd::sync::wait::Waiter::wait_until_or_cancelled",
      "ostd::sync::wait::Waiter::waker",
      "ostd::sync::wait::Waker::wake_up",
      "ostd::task::TaskOptions::spawn",
      "ostd::task::processor::after_switching_to",
      "ostd::task::scheduler::LocalRunQueue::pick_next"
    ],
    "write": [],
    "other": [
      "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::from_raw",
      "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::raw_as_ref",
      "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::ref_as_raw",
      "ostd::<io::io_mem::IoMem<SecuritySensitivity> as core::clone::Clone>::clone",
      "ostd::<irq::top_half::IrqLine as core::clone::Clone>::clone",
      "ostd::<sync::rwarc::RwArc<T> as core::clone::Clone>::clone",
      "ostd::<task::scheduler::fifo_scheduler::FifoRunQueue<T> as task::scheduler::LocalRunQueue<T>>::try_pick_next",
      "ostd::io::io_mem::IoMem::<SecuritySensitivity>::new",
      "ostd::io::io_mem::IoMem::<SecuritySensitivity>::slice",
      "ostd::irq::top_half::IrqLine::new",
      "ostd::sync::rwarc::RwArc::<T>::clone_ro",
      "ostd::sync::rwarc::RwArc::<T>::new",
      "ostd::sync::wait::WaitQueue::wait_until",
      "ostd::sync::wait::WaitQueue::wait_until",
      "ostd::sync::wait::WaitQueue::wait_until",
      "ostd::sync::wait::WaitQueue::wake_all",
      "ostd::sync::wait::WaitQueue::wake_one",
      "ostd::sync::wait::Waiter::new_pair",
      "ostd::sync::wait::Waiter::waker",
      "ostd::sync::wait::Waker::wake_up",
      "ostd::task::CurrentTask::cloned",
      "ostd::task::TaskOptions::spawn",
      "ostd::task::processor::after_switching_to",
      "ostd::task::scheduler::reschedule"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/alloc/src/sync.rs:264:1: 267:2",
  "src": "pub struct Arc<\n    T: ?Sized,\n    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n>",
  "kind": "Struct",
  "doc_adt": " A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n Reference Counted'.\n\n The type `Arc<T>` provides shared ownership of a value of type `T`,\n allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n a new `Arc` instance, which points to the same allocation on the heap as the\n source `Arc`, while increasing a reference count. When the last `Arc`\n pointer to a given allocation is destroyed, the value stored in that allocation (often\n referred to as \"inner value\") is also dropped.\n\n Shared references in Rust disallow mutation by default, and `Arc` is no\n exception: you cannot generally obtain a mutable reference to something\n inside an `Arc`. If you do need to mutate through an `Arc`, you have several options:\n\n 1. Use interior mutability with synchronization primitives like [`Mutex`][mutex],\n    [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n\n 2. Use clone-on-write semantics with [`Arc::make_mut`] which provides efficient mutation\n    without requiring interior mutability. This approach clones the data only when\n    needed (when there are multiple references) and can be more efficient when mutations\n    are infrequent.\n\n 3. Use [`Arc::get_mut`] when you know your `Arc` is not shared (has a reference count of 1),\n    which provides direct mutable access to the inner value without any cloning.\n\n ```\n use std::sync::Arc;\n\n let mut data = Arc::new(vec![1, 2, 3]);\n\n // This will clone the vector only if there are other references to it\n Arc::make_mut(&mut data).push(4);\n\n assert_eq!(*data, vec![1, 2, 3, 4]);\n ```\n\n **Note**: This type is only available on platforms that support atomic\n loads and stores of pointers, which includes all platforms that support\n the `std` crate but not all those which only support [`alloc`](crate).\n This may be detected at compile time using `#[cfg(target_has_atomic = \"ptr\")]`.\n\n ## Thread Safety\n\n Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n counting. This means that it is thread-safe. The disadvantage is that\n atomic operations are more expensive than ordinary memory accesses. If you\n are not sharing reference-counted allocations between threads, consider using\n [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n compiler will catch any attempt to send an [`Rc<T>`] between threads.\n However, a library might choose `Arc<T>` in order to give library consumers\n more flexibility.\n\n `Arc<T>` will implement [`Send`] and [`Sync`] as long as the `T` implements\n [`Send`] and [`Sync`]. Why can't you put a non-thread-safe type `T` in an\n `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at\n first: after all, isn't the point of `Arc<T>` thread safety? The key is\n this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n data, but it  doesn't add thread safety to its data. Consider\n <code>Arc<[RefCell\\<T>]></code>. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n [`Send`], <code>Arc<[RefCell\\<T>]></code> would be as well. But then we'd have a problem:\n [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n non-atomic operations.\n\n In the end, this means that you may need to pair `Arc<T>` with some sort of\n [`std::sync`] type, usually [`Mutex<T>`][mutex].\n\n ## Breaking cycles with `Weak`\n\n The [`downgrade`][downgrade] method can be used to create a non-owning\n [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n already been dropped. In other words, `Weak` pointers do not keep the value\n inside the allocation alive; however, they *do* keep the allocation\n (the backing store for the value) alive.\n\n A cycle between `Arc` pointers will never be deallocated. For this reason,\n [`Weak`] is used to break cycles. For example, a tree could have\n strong `Arc` pointers from parent nodes to children, and [`Weak`]\n pointers from children back to their parents.\n\n # Cloning references\n\n Creating a new reference from an existing reference-counted pointer is done using the\n `Clone` trait implemented for [`Arc<T>`][Arc] and [`Weak<T>`][Weak].\n\n ```\n use std::sync::Arc;\n let foo = Arc::new(vec![1.0, 2.0, 3.0]);\n // The two syntaxes below are equivalent.\n let a = foo.clone();\n let b = Arc::clone(&foo);\n // a, b, and foo are all Arcs that point to the same memory location\n ```\n\n ## `Deref` behavior\n\n `Arc<T>` automatically dereferences to `T` (via the [`Deref`] trait),\n so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n clashes with `T`'s methods, the methods of `Arc<T>` itself are associated\n functions, called using [fully qualified syntax]:\n\n ```\n use std::sync::Arc;\n\n let my_arc = Arc::new(());\n let my_weak = Arc::downgrade(&my_arc);\n ```\n\n `Arc<T>`'s implementations of traits like `Clone` may also be called using\n fully qualified syntax. Some people prefer to use fully qualified syntax,\n while others prefer using method-call syntax.\n\n ```\n use std::sync::Arc;\n\n let arc = Arc::new(());\n // Method-call syntax\n let arc2 = arc.clone();\n // Fully qualified syntax\n let arc3 = Arc::clone(&arc);\n ```\n\n [`Weak<T>`][Weak] does not auto-dereference to `T`, because the inner value may have\n already been dropped.\n\n [`Rc<T>`]: crate::rc::Rc\n [clone]: Clone::clone\n [mutex]: ../../std/sync/struct.Mutex.html\n [rwlock]: ../../std/sync/struct.RwLock.html\n [atomic]: core::sync::atomic\n [downgrade]: Arc::downgrade\n [upgrade]: Weak::upgrade\n [RefCell\\<T>]: core::cell::RefCell\n [`RefCell<T>`]: core::cell::RefCell\n [`std::sync`]: ../../std/sync/index.html\n [`Arc::clone(&from)`]: Arc::clone\n [fully qualified syntax]: https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name\n\n # Examples\n\n Sharing some immutable data between threads:\n\n ```\n use std::sync::Arc;\n use std::thread;\n\n let five = Arc::new(5);\n\n for _ in 0..10 {\n     let five = Arc::clone(&five);\n\n     thread::spawn(move || {\n         println!(\"{five:?}\");\n     });\n }\n ```\n\n Sharing a mutable [`AtomicUsize`]:\n\n [`AtomicUsize`]: core::sync::atomic::AtomicUsize \"sync::atomic::AtomicUsize\"\n\n ```\n use std::sync::Arc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::thread;\n\n let val = Arc::new(AtomicUsize::new(5));\n\n for _ in 0..10 {\n     let val = Arc::clone(&val);\n\n     thread::spawn(move || {\n         let v = val.fetch_add(1, Ordering::Relaxed);\n         println!(\"{v:?}\");\n     });\n }\n ```\n\n See the [`rc` documentation][rc_examples] for more examples of reference\n counting in general.\n\n [rc_examples]: crate::rc#examples\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "ptr",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "phantom",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "alloc",
      "doc": ""
    }
  }
}