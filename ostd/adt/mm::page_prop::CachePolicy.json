{
  "name": "mm::page_prop::CachePolicy",
  "constructors": [
    "arch::mm::pat::flags_to_cache_policy",
    "io::io_mem::IoMem::<SecuritySensitivity>::cache_policy",
    "<mm::page_prop::CachePolicy as core::clone::Clone>::clone"
  ],
  "access_self_as_arg": {
    "read": [
      "io::io_mem::allocator::IoMemAllocator::acquire",
      "io::io_mem::allocator::IoMemAllocatorBuilder::reserve",
      "<mm::page_prop::CachePolicy as core::clone::Clone>::clone",
      "<mm::page_prop::CachePolicy as core::fmt::Debug>::fmt",
      "<mm::page_prop::CachePolicy as core::cmp::PartialEq>::eq",
      "<mm::page_prop::CachePolicy as core::cmp::Eq>::assert_receiver_is_total_eq"
    ],
    "write": [
      "<mm::page_prop::CachePolicy as core::clone::Clone>::clone",
      "<mm::page_prop::CachePolicy as core::fmt::Debug>::fmt",
      "<mm::page_prop::CachePolicy as core::cmp::PartialEq>::eq"
    ],
    "other": [
      "arch::mm::pat::cache_policy_to_flags",
      "arch::mm::pat::configure_pat::cache_policy_to_pat_entry",
      "arch::mm::activate_page_table",
      "io::io_mem::allocator::IoMemAllocator::acquire",
      "io::io_mem::allocator::IoMemAllocatorBuilder::reserve",
      "io::io_mem::IoMem::<SecuritySensitivity>::new",
      "io::io_mem::IoMem::acquire_with_cache_policy",
      "mm::page_prop::PageProperty::new_user",
      "<mm::page_prop::CachePolicy as core::clone::Clone>::clone",
      "io::io_mem::allocator::IoMemAllocator::acquire",
      "io::io_mem::allocator::IoMemAllocatorBuilder::reserve",
      "io::io_mem::allocator::IoMemAllocator::acquire",
      "io::io_mem::allocator::IoMemAllocatorBuilder::reserve"
    ]
  },
  "access_self_as_locals": {
    "read": [
      "<arch::iommu::dma_remapping::second_stage::PageTableEntry as mm::page_table::PageTableEntryTrait>::set_prop",
      "<io::io_mem::IoMem<SecuritySensitivity> as core::fmt::Debug>::fmt",
      "<io::io_mem::IoMem<SecuritySensitivity> as core::clone::Clone>::clone",
      "<mm::page_prop::PageProperty as core::fmt::Debug>::fmt",
      "<mm::page_prop::PageProperty as core::cmp::PartialEq>::eq"
    ],
    "write": [],
    "other": [
      "arch::iommu::dma_remapping::context_table::ContextTable::map",
      "<arch::iommu::dma_remapping::second_stage::PageTableEntry as mm::page_table::PageTableEntryTrait>::prop",
      "arch::irq::chip::ioapic::IoApicAccess::new",
      "arch::kernel::apic::init",
      "arch::mm::pat::flags_to_cache_policy",
      "arch::mm::pat::configure_pat",
      "<arch::mm::PageTableEntry as mm::page_table::PageTableEntryTrait>::prop",
      "<arch::mm::PageTableEntry as mm::page_table::PageTableEntryTrait>::set_prop",
      "io::io_mem::IoMem::<SecuritySensitivity>::slice",
      "io::io_mem::IoMem::<SecuritySensitivity>::cache_policy",
      "io::io_mem::IoMem::acquire",
      "mm::dma::util::alloc_kva",
      "mm::frame::meta::add_temp_linear_mapping",
      "mm::kspace::init_kernel_page_table",
      "mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::activate",
      "mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::first_activate",
      "task::kernel_stack::KernelStack::new_with_guard_page",
      "<io::io_mem::IoMem<SecuritySensitivity> as core::clone::Clone>::clone"
    ]
  },
  "access_field": [],
  "span": "ostd/src/mm/page_prop.rs:35:1: 35:21",
  "src": "pub enum CachePolicy",
  "kind": "Enum",
  "doc_adt": " A type to control the cacheability of the main memory.\n\n The type currently follows the definition as defined by the AMD64 manual.\n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "Uncacheable",
      "doc": " Uncacheable (UC).\n\n Reads from, and writes to, UC memory are not cacheable.\n Reads from UC memory cannot be speculative.\n Write-combining to UC memory is not allowed.\n Reads from or writes to UC memory cause the write buffers to be written to memory\n and be invalidated prior to the access to UC memory.\n\n The UC memory type is useful for memory-mapped I/O devices\n where strict ordering of reads and writes is important.\n"
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "WriteCombining",
      "doc": " Write-Combining (WC).\n\n Reads from, and writes to, WC memory are not cacheable.\n Reads from WC memory can be speculative.\n\n Writes to this memory type can be combined internally by the processor\n and written to memory as a single write operation to reduce memory accesses.\n\n The WC memory type is useful for graphics-display memory buffers\n where the order of writes is not important.\n"
    },
    "VariantIdx(Some(2))-FieldIdx(None)": {
      "name": "WriteProtected",
      "doc": " Write-Protect (WP).\n\n Reads from WP memory are cacheable and allocate cache lines on a read miss.\n Reads from WP memory can be speculative.\n\n Writes to WP memory that hit in the cache do not update the cache.\n Instead, all writes update memory (write to memory),\n and writes that hit in the cache invalidate the cache line.\n Write buffering of WP memory is allowed.\n\n The WP memory type is useful for shadowed-ROM memory\n where updates must be immediately visible to all devices that read the shadow locations.\n"
    },
    "VariantIdx(Some(3))-FieldIdx(None)": {
      "name": "Writethrough",
      "doc": " Writethrough (WT).\n\n Reads from WT memory are cacheable and allocate cache lines on a read miss.\n Reads from WT memory can be speculative.\n\n All writes to WT memory update main memory,\n and writes that hit in the cache update the cache line.\n Writes that miss the cache do not allocate a cache line.\n Write buffering of WT memory is allowed.\n"
    },
    "VariantIdx(Some(4))-FieldIdx(None)": {
      "name": "Writeback",
      "doc": " Writeback (WB).\n\n The WB memory is the \"normal\" memory. See detailed descriptions in the manual.\n\n This type of memory provides the highest-possible performance\n and is useful for most software and data stored in system memory (DRAM).\n"
    }
  }
}