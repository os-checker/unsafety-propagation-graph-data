{
  "name": "core::ops::RangeInclusive",
  "constructors": [
    "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
    "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
    "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
    "ostd::mm::page_table::vaddr_range"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "ostd::mm::page_table::is_valid_range"
    ],
    "write": [
      "ostd::arch::irq::chip::ioapic::IoApic::new"
    ],
    "other": [
      "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
      "ostd::arch::irq::chip::ioapic::IoApic::new",
      "ostd::arch::kernel::apic::ApicId::x2apic_logical_cluster_id",
      "ostd::arch::kernel::apic::ApicId::x2apic_logical_field_id",
      "ostd::mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root",
      "ostd::mm::page_table::vaddr_range",
      "ostd::mm::page_table::is_valid_range"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ops/range.rs:357:1: 357:31",
  "src": "pub struct RangeInclusive<Idx>",
  "kind": "Struct",
  "doc_adt": " A range bounded inclusively below and above (`start..=end`).\n\n The `RangeInclusive` `start..=end` contains all values with `x >= start`\n and `x <= end`. It is empty unless `start <= end`.\n\n This iterator is [fused], but the specific values of `start` and `end` after\n iteration has finished are **unspecified** other than that [`.is_empty()`]\n will return `true` once no more values will be produced.\n\n [fused]: crate::iter::FusedIterator\n [`.is_empty()`]: RangeInclusive::is_empty\n\n # Examples\n\n The `start..=end` syntax is a `RangeInclusive`:\n\n ```\n assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n assert_eq!(3 + 4 + 5, (3..=5).sum());\n ```\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]); // This is a `RangeInclusive`\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "start",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "end",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(2))": {
      "name": "exhausted",
      "doc": ""
    }
  }
}