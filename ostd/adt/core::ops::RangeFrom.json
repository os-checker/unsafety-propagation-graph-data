{
  "name": "core::ops::RangeFrom",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "ostd::<core::ops::RangeFrom<I> as util::id_set::IdSetSlicer<I>>::to_range_bounds",
      "ostd::<core::ops::RangeFrom<I> as util::id_set::IdSetSlicer<I>>::to_range_bounds"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "ostd::arch::kernel::acpi::remapping::Andd::from_bytes",
      "ostd::arch::kernel::acpi::remapping::Drhd::from_bytes",
      "ostd::arch::kernel::acpi::remapping::Rmrr::from_bytes",
      "ostd::arch::kernel::acpi::remapping::Atsr::from_bytes",
      "ostd::arch::kernel::acpi::remapping::Satc::from_bytes",
      "ostd::arch::kernel::acpi::remapping::Sidp::from_bytes"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ops/range.rs:197:1: 197:26",
  "src": "pub struct RangeFrom<Idx>",
  "kind": "Struct",
  "doc_adt": " A range only bounded inclusively below (`start..`).\n\n The `RangeFrom` `start..` contains all values with `x >= start`.\n\n *Note*: Overflow in the [`Iterator`] implementation (when the contained\n data type reaches its numerical limit) is allowed to panic, wrap, or\n saturate. This behavior is defined by the implementation of the [`Step`]\n trait. For primitive integers, this follows the normal rules, and respects\n the overflow checks profile (panic in debug, wrap in release). Note also\n that overflow happens earlier than you might assume: the overflow happens\n in the call to `next` that yields the maximum value, as the range must be\n set to a state to yield the next value.\n\n [`Step`]: crate::iter::Step\n\n # Examples\n\n The `start..` syntax is a `RangeFrom`:\n\n ```\n assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n ```\n\n ```\n let arr = [0, 1, 2, 3, 4];\n assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n assert_eq!(arr[1..  ], [   1, 2, 3, 4]); // This is a `RangeFrom`\n assert_eq!(arr[1.. 3], [   1, 2      ]);\n assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "start",
      "doc": " The lower bound of the range (inclusive).\n"
    }
  }
}