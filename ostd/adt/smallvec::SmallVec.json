{
  "name": "smallvec::SmallVec",
  "constructors": [
    "util::id_set::IdSet::<I>::with_bit_pattern"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [
      "util::id_set::IdSet::<I>::clear_invalid_id_bits"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "util::id_set::IdSet::<I>::add",
      "util::id_set::IdSet::<I>::remove",
      "util::id_set::IdSet::<I>::contains",
      "util::id_set::IdSet::<I>::count",
      "util::id_set::IdSet::<I>::is_empty",
      "util::id_set::IdSet::<I>::is_full",
      "util::id_set::IdSet::<I>::iter_in",
      "util::id_set::AtomicIdSet::<I>::load",
      "util::id_set::AtomicIdSet::<I>::store",
      "util::id_set::AtomicIdSet::<I>::add",
      "util::id_set::AtomicIdSet::<I>::remove",
      "util::id_set::AtomicIdSet::<I>::contains",
      "<util::id_set::IdSet<I> as core::clone::Clone>::clone",
      "<util::id_set::IdSet<I> as core::fmt::Debug>::fmt",
      "<util::id_set::IdSet<I> as core::cmp::PartialEq>::eq",
      "<util::id_set::AtomicIdSet<I> as core::fmt::Debug>::fmt"
    ],
    "write": [
      "util::id_set::IdSet::<I>::new_full",
      "util::id_set::IdSet::<I>::with_bit_pattern",
      "util::id_set::IdSet::<I>::add",
      "util::id_set::IdSet::<I>::remove",
      "util::id_set::IdSet::<I>::add_all",
      "util::id_set::IdSet::<I>::clear"
    ],
    "other": [
      "util::id_set::IdSet::<I>::new_full",
      "util::id_set::IdSet::<I>::new_empty",
      "util::id_set::IdSet::<I>::with_bit_pattern",
      "util::id_set::AtomicIdSet::<I>::new",
      "util::id_set::AtomicIdSet::<I>::load",
      "<util::id_set::IdSet<I> as core::clone::Clone>::clone"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/smallvec-1.15.0/src/lib.rs:770:1: 770:30",
  "src": "pub struct SmallVec<A: Array>",
  "kind": "Struct",
  "doc_adt": " A `Vec`-like container that can store a small number of elements inline.\n\n `SmallVec` acts like a vector, but can store a limited amount of data inline within the\n `SmallVec` struct rather than in a separate allocation.  If the data exceeds this limit, the\n `SmallVec` will \"spill\" its data onto the heap, allocating a new buffer to hold it.\n\n The amount of data that a `SmallVec` can store inline depends on its backing store. The backing\n store can be any type that implements the `Array` trait; usually it is a small fixed-sized\n array.  For example a `SmallVec<[u64; 8]>` can hold up to eight 64-bit integers inline.\n\n ## Example\n\n ```rust\n use smallvec::SmallVec;\n let mut v = SmallVec::<[u8; 4]>::new(); // initialize an empty vector\n\n // The vector can hold up to 4 items without spilling onto the heap.\n v.extend(0..4);\n assert_eq!(v.len(), 4);\n assert!(!v.spilled());\n\n // Pushing another element will force the buffer to spill:\n v.push(4);\n assert_eq!(v.len(), 5);\n assert!(v.spilled());\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "capacity",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "data",
      "doc": ""
    }
  }
}