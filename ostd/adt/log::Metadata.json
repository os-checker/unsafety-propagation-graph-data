{
  "name": "log::Metadata",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "<logger::Logger as log::Log>::enabled"
    ],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "/home/gh-zjp-CN/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/log-0.4.27/src/lib.rs:1083:1: 1083:24",
  "src": "pub struct Metadata<'a>",
  "kind": "Struct",
  "doc_adt": " Metadata about a log message.\n\n # Use\n\n `Metadata` structs are created when users of the library use\n logging macros.\n\n They are consumed by implementations of the `Log` trait in the\n `enabled` method.\n\n `Record`s use `Metadata` to determine the log message's severity\n and target.\n\n Users should use the `log_enabled!` macro in their code to avoid\n constructing expensive log messages.\n\n # Examples\n\n ```\n use log::{Record, Level, Metadata};\n\n struct MyLogger;\n\n impl log::Log for MyLogger {\n     fn enabled(&self, metadata: &Metadata) -> bool {\n         metadata.level() <= Level::Info\n     }\n\n     fn log(&self, record: &Record) {\n         if self.enabled(record.metadata()) {\n             println!(\"{} - {}\", record.level(), record.args());\n         }\n     }\n     fn flush(&self) {}\n }\n\n # fn main(){}\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "level",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "target",
      "doc": ""
    }
  }
}