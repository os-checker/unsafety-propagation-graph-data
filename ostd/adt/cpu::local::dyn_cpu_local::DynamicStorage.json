{
  "name": "cpu::local::dyn_cpu_local::DynamicStorage",
  "constructors": [
    "cpu::local::dyn_cpu_local::<impl cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::__new_dynamic",
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::alloc",
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc"
  ],
  "access_self_as_arg": {
    "read": [
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_current",
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_target",
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_mut_ptr_on_target"
    ],
    "write": [
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_mut_ptr_on_target",
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_mut_ptr_on_target",
      "<cpu::local::dyn_cpu_local::DynamicStorage<T> as core::ops::Drop>::drop"
    ],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "cpu::local::dyn_cpu_local::<impl cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::__new_dynamic",
      "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc"
    ],
    "other": [
      "cpu::local::dyn_cpu_local::<impl cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::__new_dynamic"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [
        "<cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_target"
      ],
      "other": []
    }
  ],
  "span": "ostd/src/cpu/local/dyn_cpu_local.rs:33:1: 33:29",
  "src": "pub struct DynamicStorage<T>",
  "kind": "Struct",
  "doc_adt": " A dynamically-allocated storage for a CPU-local variable of type `T`.\n\n Such a CPU-local storage should be allocated and deallocated by\n [`DynCpuLocalChunk`], not directly. Dropping it without deallocation\n will cause panic.\n\n When dropping a `CpuLocal<T, DynamicStorage<T>>`, we have no way to know\n which `DynCpuLocalChunk` the CPU-local object was originally allocated\n from. Therefore, we rely on the user to correctly manage the corresponding\n `DynCpuLocalChunk`, ensuring that both allocation and deallocation of\n `CpuLocal<T, DynamicStorage<T>>` occur within the same chunk.\n\n To properly deallocate the CPU-local object, the user must explicitly call\n the appropriate `DynCpuLocalChunk`'s `try_dealloc<T>()`. Otherwise,\n dropping it directly will cause a panic.\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "0",
      "doc": ""
    }
  }
}