{
  "name": "core::sync::atomic::Ordering",
  "constructors": [],
  "access_self_as_arg": {
    "read": [
      "util::id_set::AtomicIdSet::<I>::load"
    ],
    "write": [],
    "other": [
      "mm::page_table::load_pte",
      "mm::page_table::store_pte",
      "util::id_set::AtomicIdSet::<I>::load",
      "util::id_set::AtomicIdSet::<I>::store",
      "util::id_set::AtomicIdSet::<I>::add",
      "util::id_set::AtomicIdSet::<I>::remove",
      "util::id_set::AtomicIdSet::<I>::contains"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "arch::kernel::tsc::init_tsc_freq",
      "arch::kernel::tsc::determine_tsc_freq_via_pit",
      "arch::kernel::tsc::determine_tsc_freq_via_pit::pit_callback",
      "arch::timer::apic::init_periodic_mode_config::pit_callback",
      "arch::tsc_freq",
      "mm::frame::linked_list::LinkedList::<M>::contains",
      "mm::frame::linked_list::LinkedList::<M>::cursor_mut_at",
      "mm::frame::linked_list::LinkedList::<M>::lazy_get_id",
      "mm::frame::linked_list::CursorMut::<'_, M>::take_current",
      "mm::frame::linked_list::CursorMut::<'_, M>::insert_before",
      "mm::frame::meta::MetaSlot::get_from_unused",
      "mm::frame::meta::MetaSlot::get_from_in_use",
      "mm::frame::meta::MetaSlot::inc_ref_count",
      "mm::frame::meta::MetaSlot::drop_last_in_place",
      "mm::frame::meta::init",
      "mm::frame::meta::is_initialized",
      "mm::frame::unique::UniqueFrame::<M>::reset_as_unused",
      "<mm::frame::unique::UniqueFrame<M> as core::ops::Drop>::drop",
      "mm::frame::unique::<impl core::convert::From<mm::frame::unique::UniqueFrame<M>> for mm::frame::Frame<M>>::from",
      "<mm::frame::unique::UniqueFrame<M> as core::convert::TryFrom<mm::frame::Frame<M>>>::try_from",
      "mm::frame::max_paddr",
      "mm::frame::Frame::<M>::reference_count",
      "<mm::frame::Frame<M> as core::ops::Drop>::drop",
      "mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'a, mm::page_table::node::PageTablePageMeta<C>>>::lock",
      "mm::page_table::node::PageTableGuard::<'rcu, C>::read_pte",
      "mm::page_table::node::PageTableGuard::<'rcu, C>::write_pte",
      "<mm::page_table::node::PageTableGuard<'_, C> as core::ops::Drop>::drop",
      "mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root",
      "mm::page_table::boot_pt::dismiss",
      "mm::tlb::TlbFlusher::<'a, G>::dispatch_tlb_flush",
      "mm::tlb::TlbFlusher::<'a, G>::sync_tlb_flush",
      "mm::tlb::do_remote_flush",
      "mm::vm_space::VmSpace::activate",
      "sync::mutex::Mutex::<T>::acquire_lock",
      "sync::mutex::Mutex::<T>::release_lock",
      "sync::rcu::monitor::RcuMonitor::finish_grace_period",
      "sync::rcu::monitor::RcuMonitor::after_grace_period",
      "sync::rcu::monitor::GracePeriod::finish_grace_period",
      "sync::rcu::monitor::GracePeriod::restart",
      "sync::rcu::RcuInner::<P>::update",
      "sync::rcu::RcuInner::<P>::read",
      "sync::rcu::RcuInner::<P>::read_with",
      "<sync::rcu::RcuInner<P> as core::ops::Drop>::drop",
      "sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange",
      "sync::rwarc::RwArc::<T>::get",
      "<sync::rwarc::RwArc<T> as core::clone::Clone>::clone",
      "<sync::rwarc::RwArc<T> as core::ops::Drop>::drop",
      "sync::rwlock::RwLock::<T, G>::try_read",
      "sync::rwlock::RwLock::<T, G>::try_write",
      "sync::rwlock::RwLock::<T, G>::try_upread",
      "<sync::rwlock::RwLockReadGuard<'_, T, G> as core::ops::Drop>::drop",
      "<sync::rwlock::RwLockWriteGuard<'_, T, G> as core::ops::Drop>::drop",
      "sync::rwlock::RwLockUpgradeableGuard::<'a, T, G>::upgrade",
      "sync::rwlock::RwLockUpgradeableGuard::<'a, T, G>::try_upgrade",
      "<sync::rwlock::RwLockUpgradeableGuard<'_, T, G> as core::ops::Drop>::drop",
      "sync::rwmutex::RwMutex::<T>::try_read",
      "sync::rwmutex::RwMutex::<T>::try_write",
      "sync::rwmutex::RwMutex::<T>::try_upread",
      "<sync::rwmutex::RwMutexReadGuard<'_, T> as core::ops::Drop>::drop",
      "sync::rwmutex::RwMutexWriteGuard::<'a, T>::try_downgrade",
      "<sync::rwmutex::RwMutexWriteGuard<'_, T> as core::ops::Drop>::drop",
      "sync::rwmutex::RwMutexUpgradeableGuard::<'a, T>::upgrade",
      "sync::rwmutex::RwMutexUpgradeableGuard::<'a, T>::try_upgrade",
      "<sync::rwmutex::RwMutexUpgradeableGuard<'_, T> as core::ops::Drop>::drop",
      "sync::spin::SpinLock::<T, G>::try_acquire_lock",
      "sync::spin::SpinLock::<T, G>::release_lock",
      "sync::wait::WaitQueue::wake_one",
      "sync::wait::WaitQueue::wake_all",
      "sync::wait::WaitQueue::is_empty",
      "sync::wait::WaitQueue::enqueue",
      "sync::wait::Waker::wake_up",
      "sync::wait::Waker::do_wait",
      "sync::wait::Waker::close",
      "task::atomic_mode::might_sleep",
      "task::kernel_stack::KernelStack::flush_tlb",
      "task::processor::before_switching_to",
      "task::processor::after_switching_to",
      "task::scheduler::info::AtomicCpuId::set_if_is_none",
      "task::scheduler::info::AtomicCpuId::set_anyway",
      "task::scheduler::info::AtomicCpuId::set_to_none",
      "task::scheduler::info::AtomicCpuId::get",
      "timer::jiffies::Jiffies::elapsed",
      "timer::call_timer_callback_functions",
      "init",
      "cpu::local::is_used::debug_set_true",
      "cpu::local::is_used::debug_assert_false"
    ]
  },
  "access_field": [],
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/sync/atomic.rs:441:1: 441:18",
  "src": "pub enum Ordering",
  "kind": "Enum",
  "doc_adt": " Atomic memory orderings\n\n Memory orderings specify the way atomic operations synchronize memory.\n In its weakest [`Ordering::Relaxed`], only the memory directly touched by the\n operation is synchronized. On the other hand, a store-load pair of [`Ordering::SeqCst`]\n operations synchronize other memory while additionally preserving a total order of such\n operations across all threads.\n\n Rust's memory orderings are [the same as those of\n C++20](https://en.cppreference.com/w/cpp/atomic/memory_order).\n\n For more information see the [nomicon].\n\n [nomicon]: ../../../nomicon/atomics.html\n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "Relaxed",
      "doc": " No ordering constraints, only atomic operations.\n\n Corresponds to [`memory_order_relaxed`] in C++20.\n\n [`memory_order_relaxed`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Relaxed_ordering\n"
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "Release",
      "doc": " When coupled with a store, all previous operations become ordered\n before any load of this value with [`Acquire`] (or stronger) ordering.\n In particular, all previous writes become visible to all threads\n that perform an [`Acquire`] (or stronger) load of this value.\n\n Notice that using this ordering for an operation that combines loads\n and stores leads to a [`Relaxed`] load operation!\n\n This ordering is only applicable for operations that can perform a store.\n\n Corresponds to [`memory_order_release`] in C++20.\n\n [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n"
    },
    "VariantIdx(Some(2))-FieldIdx(None)": {
      "name": "Acquire",
      "doc": " When coupled with a load, if the loaded value was written by a store operation with\n [`Release`] (or stronger) ordering, then all subsequent operations\n become ordered after that store. In particular, all subsequent loads will see data\n written before the store.\n\n Notice that using this ordering for an operation that combines loads\n and stores leads to a [`Relaxed`] store operation!\n\n This ordering is only applicable for operations that can perform a load.\n\n Corresponds to [`memory_order_acquire`] in C++20.\n\n [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n"
    },
    "VariantIdx(Some(3))-FieldIdx(None)": {
      "name": "AcqRel",
      "doc": " Has the effects of both [`Acquire`] and [`Release`] together:\n For loads it uses [`Acquire`] ordering. For stores it uses the [`Release`] ordering.\n\n Notice that in the case of `compare_and_swap`, it is possible that the operation ends up\n not performing any store and hence it has just [`Acquire`] ordering. However,\n `AcqRel` will never perform [`Relaxed`] accesses.\n\n This ordering is only applicable for operations that combine both loads and stores.\n\n Corresponds to [`memory_order_acq_rel`] in C++20.\n\n [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n"
    },
    "VariantIdx(Some(4))-FieldIdx(None)": {
      "name": "SeqCst",
      "doc": " Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n operations, respectively) with the additional guarantee that all threads see all\n sequentially consistent operations in the same order.\n\n Corresponds to [`memory_order_seq_cst`] in C++20.\n\n [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n"
    }
  }
}