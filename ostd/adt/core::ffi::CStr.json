{
  "name": "core::ffi::CStr",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "arch::boot::linux_boot::parse_kernel_commandline",
      "arch::boot::multiboot::parse_as_cstr"
    ],
    "write": [],
    "other": []
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/ffi/c_str.rs:102:1: 102:16",
  "src": "pub struct CStr",
  "kind": "Struct",
  "doc_adt": " A dynamically-sized view of a C string.\n\n The type `&CStr` represents a reference to a borrowed nul-terminated\n array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n slice, or unsafely from a raw `*const c_char`. It can be expressed as a\n literal in the form `c\"Hello world\"`.\n\n The `&CStr` can then be converted to a Rust <code>&[str]</code> by performing\n UTF-8 validation, or into an owned `CString`.\n\n `&CStr` is to `CString` as <code>&[str]</code> is to `String`: the former\n in each pair are borrowing references; the latter are owned\n strings.\n\n Note that this structure does **not** have a guaranteed layout (the `repr(transparent)`\n notwithstanding) and should not be placed in the signatures of FFI functions.\n Instead, safe wrappers of FFI functions may leverage [`CStr::as_ptr`] and the unsafe\n [`CStr::from_ptr`] constructor to provide a safe interface to other consumers.\n\n # Examples\n\n Inspecting a foreign C string:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n # /* Extern functions are awkward in doc comments - fake it instead\n extern \"C\" { fn my_string() -> *const c_char; }\n # */ unsafe extern \"C\" fn my_string() -> *const c_char { c\"hello\".as_ptr() }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n }\n ```\n\n Passing a Rust-originating C string:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n fn work(data: &CStr) {\n     unsafe extern \"C\" fn work_with(s: *const c_char) {}\n     unsafe { work_with(data.as_ptr()) }\n }\n\n let s = c\"Hello world!\";\n work(&s);\n ```\n\n Converting a foreign C string into a Rust `String`:\n\n ```\n use std::ffi::CStr;\n use std::os::raw::c_char;\n\n # /* Extern functions are awkward in doc comments - fake it instead\n extern \"C\" { fn my_string() -> *const c_char; }\n # */ unsafe extern \"C\" fn my_string() -> *const c_char { c\"hello\".as_ptr() }\n\n fn my_string_safe() -> String {\n     let cstr = unsafe { CStr::from_ptr(my_string()) };\n     // Get a copy-on-write Cow<'_, str>, then extract the\n     // allocated String (or allocate a fresh one if needed).\n     cstr.to_string_lossy().into_owned()\n }\n\n println!(\"string: {}\", my_string_safe());\n ```\n\n [str]: prim@str \"str\"\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "inner",
      "doc": ""
    }
  }
}