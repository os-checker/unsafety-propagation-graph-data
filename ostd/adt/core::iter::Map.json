{
  "name": "core::iter::Map",
  "constructors": [
    "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
    "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
    "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
    "ostd::cpu::id::all_cpus",
    "ostd::mm::tlb::OpsStack::ops_iter",
    "ostd::util::id_set::IdSet::<I>::iter",
    "ostd::util::id_set::IdSet::<I>::iter_in"
  ],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [],
    "write": [
      "ostd::arch::iommu::dma_remapping::init",
      "ostd::cpu::local::dyn_cpu_local::<impl core::fmt::Debug for cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::fmt",
      "ostd::cpu::local::dyn_cpu_local::<impl cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::__new_dynamic",
      "ostd::cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc",
      "ostd::mm::tlb::TlbFlusher::<'a, G>::dispatch_tlb_flush",
      "ostd::mm::tlb::TlbFlusher::<'a, G>::sync_tlb_flush",
      "ostd::mm::tlb::OpsStack::push_from",
      "ostd::smp::IpiSender::inter_processor_call"
    ],
    "other": [
      "ostd::arch::iommu::dma_remapping::PciDeviceLocation::all",
      "ostd::arch::iommu::dma_remapping::init",
      "ostd::boot::memory_region::MemoryRegionArray::<LEN>::into_non_overlapping",
      "ostd::cpu::id::all_cpus",
      "ostd::cpu::local::dyn_cpu_local::<impl core::fmt::Debug for cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::fmt",
      "ostd::cpu::local::dyn_cpu_local::<impl cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::__new_dynamic",
      "ostd::cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc",
      "ostd::mm::frame::meta::init",
      "ostd::mm::tlb::TlbFlusher::<'a, G>::dispatch_tlb_flush",
      "ostd::mm::tlb::TlbFlusher::<'a, G>::sync_tlb_flush",
      "ostd::mm::tlb::OpsStack::push_from",
      "ostd::mm::tlb::OpsStack::flush_all",
      "ostd::mm::tlb::OpsStack::ops_iter",
      "ostd::smp::IpiSender::inter_processor_call",
      "ostd::util::id_set::IdSet::<I>::count",
      "ostd::util::id_set::IdSet::<I>::iter",
      "ostd::util::id_set::IdSet::<I>::iter_in",
      "ostd::util::id_set::AtomicIdSet::<I>::new",
      "ostd::util::id_set::AtomicIdSet::<I>::load"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    },
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/iter/adapters/map.rs:61:1: 61:21",
  "src": "pub struct Map<I, F>",
  "kind": "Struct",
  "doc_adt": " An iterator that maps the values of `iter` with `f`.\n\n This `struct` is created by the [`map`] method on [`Iterator`]. See its\n documentation for more.\n\n [`map`]: Iterator::map\n [`Iterator`]: trait.Iterator.html\n\n # Notes about side effects\n\n The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n you can also [`map`] backwards:\n\n ```rust\n let v: Vec<i32> = [1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n\n assert_eq!(v, [4, 3, 2]);\n ```\n\n [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n\n But if your closure has state, iterating backwards may act in a way you do\n not expect. Let's go through an example. First, in the forward direction:\n\n ```rust\n let mut c = 0;\n\n for pair in ['a', 'b', 'c'].into_iter()\n                                .map(|letter| { c += 1; (letter, c) }) {\n     println!(\"{pair:?}\");\n }\n ```\n\n This will print `('a', 1), ('b', 2), ('c', 3)`.\n\n Now consider this twist where we add a call to `rev`. This version will\n print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n but the values of the counter still go in order. This is because `map()` is\n still being called lazily on each item, but we are popping items off the\n back of the vector now, instead of shifting them from the front.\n\n ```rust\n let mut c = 0;\n\n for pair in ['a', 'b', 'c'].into_iter()\n                                .map(|letter| { c += 1; (letter, c) })\n                                .rev() {\n     println!(\"{pair:?}\");\n }\n ```\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "iter",
      "doc": ""
    },
    "VariantIdx(None)-FieldIdx(Some(1))": {
      "name": "f",
      "doc": ""
    }
  }
}