{
  "name": "arch::timer::pit::OperatingMode",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": [
      "arch::timer::pit::init"
    ]
  },
  "access_self_as_locals": {
    "read": [],
    "write": [],
    "other": [
      "arch::kernel::tsc::determine_tsc_freq_via_pit",
      "arch::timer::apic::init_periodic_mode_config"
    ]
  },
  "access_field": [],
  "span": "ostd/src/arch/x86/timer/pit.rs:30:1: 30:23",
  "src": "pub enum OperatingMode",
  "kind": "Enum",
  "doc_adt": " PIT Operating Mode.\n\n Usually, only the rate generator, which is used to determine the base frequency of other timers\n (e.g. APIC Timer), and the Square wave generator, which is used to generate interrupts directly, are used.\n\n Note that if IOAPIC is used to manage interrupts and square wave mode is enabled, the frequency at which\n clock interrupts are generated is `Frequency/2`.\n",
  "variant_fields": {
    "VariantIdx(Some(0))-FieldIdx(None)": {
      "name": "InterruptOnTerminalCount",
      "doc": " Triggers an interrupt (only on channel 0) when the counter is terminated (1 -> 0).\n The data port needs to be reset before the next interrupt.\n ```text,ignore\n            software reload counter\n                      ⬇\n               +------+             +----\n               |      |             |\n --------------+      +-------------+\n ⬆             ⬆                    ⬆\n init()   counter 1 -> 0         counter 1 -> 0\n ```\n"
    },
    "VariantIdx(Some(1))-FieldIdx(None)": {
      "name": "OneShotHardwareRetriggerable",
      "doc": " This mode is similar to `InterruptOnTerminalCount` mode, however counting doesn't start until\n a rising edge of the gate input is detected. For this reason it is not usable for PIT channels\n 0 or 1(where the gate input can't be changed).\n"
    },
    "VariantIdx(Some(2))-FieldIdx(None)": {
      "name": "RateGenerator",
      "doc": " Rate generator, which produces a pulse at a fixed frequency.\n ```text,ignore\n init()   counter 2 -> 1    counter 2 -> 1\n ⬇             ⬇                ⬇\n --------------+  +-------------+\n               |  |             |\n               +--+             +--\n                  ⬆\n     counter 1 -> 0, auto reload counter\n ```\n"
    },
    "VariantIdx(Some(3))-FieldIdx(None)": {
      "name": "SquareWaveGenerator",
      "doc": " In this mode, the current count is **decremented twice** on each falling edge of the input signal.\n The output will change state and then set to reload value.\n ```text,ignore\n init()  auto reload counter\n ⬇             ⬇\n --------------+              +--------------\n               |              |\n               +--------------+\n                              ⬆\n                       auto reload counter\n ```\n"
    },
    "VariantIdx(Some(4))-FieldIdx(None)": {
      "name": "SoftwareTriggeredStrobe",
      "doc": " Similar to a Rate generator, but requires a software reset to start counting.\n ```text,ignore\n init()   counter: 1  software reload counter\n ⬇             ⬇              ⬇\n --------------+ +---------------------------+ +--\n               | |                           | |\n               +-+                           +-+\n                 ⬆\n              counter: 0\n ```\n"
    },
    "VariantIdx(Some(5))-FieldIdx(None)": {
      "name": "HardwareTriggeredStrobe",
      "doc": " This mode is similar to `SoftwareTriggeredStrobe` mode, except that it waits for the rising\n edge of the gate input to trigger (or re-trigger) the delay period (like `OneShotHardwareRetriggerable`\n mode).\n"
    }
  }
}