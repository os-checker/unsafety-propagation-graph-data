{
  "name": "core::mem::ManuallyDrop",
  "constructors": [],
  "access_self_as_arg": {
    "read": [],
    "write": [],
    "other": []
  },
  "access_self_as_locals": {
    "read": [
      "ostd::<mm::dma::dma_coherent::DmaCoherent as mm::mem_obj::Split>::split",
      "ostd::<mm::dma::dma_stream::DmaStream<D> as mm::mem_obj::Split>::split",
      "ostd::<mm::frame::frame_ref::FrameRef<'_, M> as core::ops::Deref>::deref",
      "ostd::<mm::frame::frame_ref::FrameRef<'a, M> as core::fmt::Debug>::fmt",
      "ostd::<mm::frame::segment::Segment<(dyn mm::frame::untyped::AnyUFrameMeta + 'static)> as core::convert::TryFrom<mm::frame::segment::Segment<(dyn mm::frame::meta::AnyFrameMeta + 'static)>>>::try_from",
      "ostd::<mm::frame::segment::Segment<M> as core::convert::TryFrom<mm::frame::segment::Segment<(dyn mm::frame::meta::AnyFrameMeta + 'static)>>>::try_from",
      "ostd::<mm::frame::segment::Segment<M> as mm::mem_obj::Split>::split",
      "ostd::<mm::kspace::kvirt_area::KVirtArea as mm::mem_obj::Split>::split",
      "ostd::<sync::rcu::RcuDrop<T> as core::clone::Clone>::clone",
      "ostd::<sync::rcu::RcuDrop<T> as core::cmp::Ord>::cmp",
      "ostd::<sync::rcu::RcuDrop<T> as core::cmp::PartialEq>::eq",
      "ostd::<sync::rcu::RcuDrop<T> as core::cmp::PartialOrd>::partial_cmp",
      "ostd::<sync::rcu::RcuDrop<T> as core::fmt::Debug>::fmt",
      "ostd::<sync::rcu::RcuDrop<T> as core::hash::Hash>::hash",
      "ostd::<sync::rcu::RcuDrop<T> as core::ops::Deref>::deref",
      "ostd::<sync::rcu::non_null::ArcRef<'_, T> as core::ops::Deref>::deref",
      "ostd::<sync::rcu::non_null::ArcRef<'a, T> as core::fmt::Debug>::fmt",
      "ostd::cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::start_vaddr",
      "ostd::mm::frame::Frame::<M>::into_raw",
      "ostd::mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::ref_as_raw",
      "ostd::mm::frame::segment::Segment::<(dyn mm::frame::meta::AnyFrameMeta + 'static)>::from_unsized",
      "ostd::mm::frame::unique::UniqueFrame::<M>::into_raw",
      "ostd::mm::frame::unique::UniqueFrame::<M>::repurpose",
      "ostd::mm::frame::unique::UniqueFrame::<M>::reset_as_unused",
      "ostd::mm::page_table::cursor::Cursor::<'rcu, C>::query"
    ],
    "write": [
      "ostd::<cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE> as core::ops::Drop>::drop",
      "ostd::<sync::rcu::RcuDrop<T> as core::ops::Drop>::drop"
    ],
    "other": [
      "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::raw_as_ref",
      "ostd::<alloc::sync::Arc<T> as sync::rcu::non_null::NonNullPtr>::ref_as_raw",
      "ostd::<mm::dma::dma_coherent::DmaCoherent as mm::mem_obj::Split>::split",
      "ostd::<mm::dma::dma_stream::DmaStream<D> as mm::mem_obj::Split>::split",
      "ostd::<mm::frame::segment::Segment<(dyn mm::frame::untyped::AnyUFrameMeta + 'static)> as core::convert::TryFrom<mm::frame::segment::Segment<(dyn mm::frame::meta::AnyFrameMeta + 'static)>>>::try_from",
      "ostd::<mm::frame::segment::Segment<M> as core::convert::From<mm::frame::Frame<M>>>::from",
      "ostd::<mm::frame::segment::Segment<M> as core::convert::TryFrom<mm::frame::segment::Segment<(dyn mm::frame::meta::AnyFrameMeta + 'static)>>>::try_from",
      "ostd::<mm::frame::segment::Segment<M> as mm::mem_obj::Split>::split",
      "ostd::<mm::kspace::kvirt_area::KVirtArea as mm::mem_obj::Split>::split",
      "ostd::<sync::rcu::RcuDrop<T> as core::clone::Clone>::clone",
      "ostd::<sync::rcu::RcuDrop<T> as core::default::Default>::default",
      "ostd::cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::new",
      "ostd::cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc",
      "ostd::mm::frame::Frame::<M>::into_raw",
      "ostd::mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::into_raw",
      "ostd::mm::frame::frame_ref::<impl sync::rcu::non_null::NonNullPtr for mm::frame::Frame<M>>::raw_as_ref",
      "ostd::mm::frame::frame_ref::FrameRef::<'_, M>::borrow_paddr",
      "ostd::mm::frame::meta::init",
      "ostd::mm::frame::meta::mark_unusable_ranges",
      "ostd::mm::frame::segment::Segment::<(dyn mm::frame::meta::AnyFrameMeta + 'static)>::from_unsized",
      "ostd::mm::frame::segment::Segment::<M>::from_unused",
      "ostd::mm::frame::segment::Segment::<M>::into_raw",
      "ostd::mm::frame::unique::UniqueFrame::<M>::into_raw",
      "ostd::mm::frame::unique::UniqueFrame::<M>::repurpose",
      "ostd::mm::frame::unique::UniqueFrame::<M>::reset_as_unused",
      "ostd::mm::page_table::cursor::Cursor::<'rcu, C>::find_next_impl",
      "ostd::mm::page_table::cursor::Cursor::<'rcu, C>::pop_level",
      "ostd::mm::page_table::cursor::Cursor::<'rcu, C>::query",
      "ostd::mm::page_table::cursor::CursorMut::<'rcu, C>::replace_cur_entry",
      "ostd::mm::page_table::cursor::locking::dfs_acquire_lock",
      "ostd::mm::page_table::cursor::locking::unlock_range",
      "ostd::mm::page_table::node::child::Child::<C>::into_pte",
      "ostd::sync::rcu::RcuDrop::<T>::new"
    ]
  },
  "access_field": [
    {
      "read": [],
      "write": [],
      "other": []
    }
  ],
  "span": "$library/core/src/mem/manually_drop.rs:158:1: 158:35",
  "src": "pub struct ManuallyDrop<T: ?Sized>",
  "kind": "Struct",
  "doc_adt": " A wrapper to inhibit the compiler from automatically calling `T`â€™s\n destructor. This wrapper is 0-cost.\n\n `ManuallyDrop<T>` is guaranteed to have the same layout and bit validity as\n `T`, and is subject to the same layout optimizations as `T`. As a\n consequence, it has *no effect* on the assumptions that the compiler makes\n about its contents. For example, initializing a `ManuallyDrop<&mut T>` with\n [`mem::zeroed`] is undefined behavior. If you need to handle uninitialized\n data, use [`MaybeUninit<T>`] instead.\n\n Note that accessing the value inside a `ManuallyDrop<T>` is safe. This means\n that a `ManuallyDrop<T>` whose content has been dropped must not be exposed\n through a public safe API. Correspondingly, `ManuallyDrop::drop` is unsafe.\n\n # `ManuallyDrop` and drop order\n\n Rust has a well-defined [drop order] of values. To make sure that fields or\n locals are dropped in a specific order, reorder the declarations such that\n the implicit drop order is the correct one.\n\n It is possible to use `ManuallyDrop` to control the drop order, but this\n requires unsafe code and is hard to do correctly in the presence of\n unwinding.\n\n For example, if you want to make sure that a specific field is dropped after\n the others, make it the last field of a struct:\n\n ```\n struct Context;\n\n struct Widget {\n     children: Vec<Widget>,\n     // `context` will be dropped after `children`.\n     // Rust guarantees that fields are dropped in the order of declaration.\n     context: Context,\n }\n ```\n\n # Interaction with `Box`\n\n Currently, if you have a `ManuallyDrop<T>`, where the type `T` is a `Box` or\n contains a `Box` inside, then dropping the `T` followed by moving the\n `ManuallyDrop<T>` is [considered to be undefined\n behavior](https://github.com/rust-lang/unsafe-code-guidelines/issues/245).\n That is, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n let mut x = ManuallyDrop::new(Box::new(42));\n unsafe {\n     ManuallyDrop::drop(&mut x);\n }\n let y = x; // Undefined behavior!\n ```\n\n This is [likely to change in the\n future](https://rust-lang.github.io/rfcs/3336-maybe-dangling.html). In the\n meantime, consider using [`MaybeUninit`] instead.\n\n # Safety hazards when storing `ManuallyDrop` in a struct or an enum.\n\n Special care is needed when all of the conditions below are met:\n * A struct or enum contains a `ManuallyDrop`.\n * The `ManuallyDrop` is not inside a `union`.\n * The struct or enum is part of public API, or is stored in a struct or an\n   enum that is part of public API.\n * There is code that drops the contents of the `ManuallyDrop` field, and\n   this code is outside the struct or enum's `Drop` implementation.\n\n In particular, the following hazards may occur:\n\n #### Storing generic types\n\n If the `ManuallyDrop` contains a client-supplied generic type, the client\n might provide a `Box` as that type. This would cause undefined behavior when\n the struct or enum is later moved, as mentioned in the previous section. For\n example, the following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n pub struct BadOption<T> {\n     // Invariant: Has been dropped if `is_some` is false.\n     value: ManuallyDrop<T>,\n     is_some: bool,\n }\n impl<T> BadOption<T> {\n     pub fn new(value: T) -> Self {\n         Self { value: ManuallyDrop::new(value), is_some: true }\n     }\n     pub fn change_to_none(&mut self) {\n         if self.is_some {\n             self.is_some = false;\n             unsafe {\n                 // SAFETY: `value` hasn't been dropped yet, as per the invariant\n                 // (This is actually unsound!)\n                 ManuallyDrop::drop(&mut self.value);\n             }\n         }\n     }\n }\n\n // In another crate:\n\n let mut option = BadOption::new(Box::new(42));\n option.change_to_none();\n let option2 = option; // Undefined behavior!\n ```\n\n #### Deriving traits\n\n Deriving `Debug`, `Clone`, `PartialEq`, `PartialOrd`, `Ord`, or `Hash` on\n the struct or enum could be unsound, since the derived implementations of\n these traits would access the `ManuallyDrop` field. For example, the\n following code causes undefined behavior:\n\n ```no_run\n use std::mem::ManuallyDrop;\n\n // This derive is unsound in combination with the `ManuallyDrop::drop` call.\n #[derive(Debug)]\n pub struct Foo {\n     value: ManuallyDrop<String>,\n }\n impl Foo {\n     pub fn new() -> Self {\n         let mut temp = Self {\n             value: ManuallyDrop::new(String::from(\"Unsafe rust is hard.\"))\n         };\n         unsafe {\n             // SAFETY: `value` hasn't been dropped yet.\n             ManuallyDrop::drop(&mut temp.value);\n         }\n         temp\n     }\n }\n\n // In another crate:\n\n let foo = Foo::new();\n println!(\"{:?}\", foo); // Undefined behavior!\n ```\n\n [drop order]: https://doc.rust-lang.org/reference/destructors.html\n [`mem::zeroed`]: crate::mem::zeroed\n [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n [`MaybeUninit`]: crate::mem::MaybeUninit\n",
  "variant_fields": {
    "VariantIdx(None)-FieldIdx(Some(0))": {
      "name": "value",
      "doc": ""
    }
  }
}