{
  "name": "ostd::mm::io::VmWriter::<'a, mm::io::Infallible>::write_once",
  "span": "ostd/src/mm/io.rs:762:5: 762:72",
  "src": "pub fn write_once<T: PodOnce>(&mut self, new_val: &T) -> Result<()> {\n        if self.avail() < size_of::<T>() {\n            return Err(Error::InvalidArgs);\n        }\n\n        let cursor = self.cursor.cast::<T>();\n        assert!(cursor.is_aligned());\n\n        const { assert!(pod_once_impls::is_non_tearing::<T>()) };\n\n        // SAFETY: We have checked that the number of bytes remaining is at least the size of `T`\n        // and that the cursor is properly aligned with respect to the type `T`. All other safety\n        // requirements are the same as for `Self::write`.\n        unsafe { cursor.write_volatile(*new_val) };\n        self.cursor = self.cursor.wrapping_add(size_of::<T>());\n\n        Ok(())\n    }"
}