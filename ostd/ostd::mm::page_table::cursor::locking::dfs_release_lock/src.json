{
  "name": "ostd::mm::page_table::cursor::locking::dfs_release_lock",
  "span": "ostd/src/mm/page_table/cursor/locking.rs:207:1: 212:2",
  "src": "unsafe fn dfs_release_lock<'rcu, C: PageTableConfig>(\n    guard: &'rcu dyn InAtomicMode,\n    mut cur_node: PageTableGuard<'rcu, C>,\n    cur_node_va: Vaddr,\n    va_range: Range<Vaddr>,\n) {\n    let cur_level = cur_node.level();\n    if cur_level == 1 {\n        return;\n    }\n\n    let idx_range = dfs_get_idx_range::<C>(cur_level, cur_node_va, &va_range);\n    for i in idx_range.rev() {\n        let child = cur_node.entry(i);\n        match child.to_ref() {\n            ChildRef::PageTable(pt) => {\n                // SAFETY: The caller ensures that the node is locked and the new guard is unique.\n                let child_node = unsafe { pt.make_guard_unchecked(guard) };\n                let child_node_va = cur_node_va + i * page_size::<C>(cur_level);\n                let child_node_va_end = child_node_va + page_size::<C>(cur_level);\n                let va_start = va_range.start.max(child_node_va);\n                let va_end = va_range.end.min(child_node_va_end);\n                // SAFETY: The caller ensures that all the nodes in the sub-tree are locked and all\n                // guards are forgotten.\n                unsafe { dfs_release_lock(guard, child_node, child_node_va, va_start..va_end) };\n            }\n            ChildRef::None | ChildRef::Frame(_, _, _) => {}\n        }\n    }\n}"
}