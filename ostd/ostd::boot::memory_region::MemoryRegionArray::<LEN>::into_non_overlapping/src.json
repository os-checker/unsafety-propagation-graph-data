{
  "name": "ostd::boot::memory_region::MemoryRegionArray::<LEN>::into_non_overlapping",
  "span": "ostd/src/boot/memory_region.rs:233:5: 233:57",
  "src": "pub(crate) fn into_non_overlapping(mut self) -> Self {\n        let max_addr = self\n            .iter()\n            .map(|r| r.end())\n            .max()\n            .unwrap_or(0)\n            .align_down(PAGE_SIZE);\n        self.regions.iter_mut().for_each(|r| *r = r.as_aligned());\n\n        let mut result = MemoryRegionArray::<LEN>::new();\n\n        let mut cur_right = 0;\n\n        while cur_right < max_addr {\n            // Find the most restrictive type.\n            let typ = self\n                .iter()\n                .filter(|region| (region.base()..region.end()).contains(&cur_right))\n                .map(|region| region.typ())\n                .min()\n                .unwrap_or(MemoryRegionType::Unknown);\n\n            // Find the right boundary.\n            let right = self\n                .iter()\n                .filter_map(|region| {\n                    if region.base() > cur_right {\n                        Some(region.base())\n                    } else if region.end() > cur_right {\n                        Some(region.end())\n                    } else {\n                        None\n                    }\n                })\n                .min()\n                .unwrap();\n\n            result\n                .push(MemoryRegion::new(cur_right, right - cur_right, typ))\n                .unwrap();\n\n            cur_right = right;\n        }\n\n        // Merge the adjacent regions with the same type.\n        let mut merged_count = 1;\n        for i in 1..result.count {\n            if result[i].typ() == result.regions[merged_count - 1].typ() {\n                result.regions[merged_count - 1] = MemoryRegion::new(\n                    result.regions[merged_count - 1].base(),\n                    result.regions[merged_count - 1].len() + result[i].len(),\n                    result.regions[merged_count - 1].typ(),\n                );\n            } else {\n                result.regions[merged_count] = result[i];\n                merged_count += 1;\n            }\n        }\n        result.count = merged_count;\n\n        result\n    }"
}