{
  "name": "ostd::task::processor::switch_to_task",
  "span": "ostd/src/task/processor.rs:39:1: 39:51",
  "src": "pub(super) fn switch_to_task(next_task: Arc<Task>) {\n    super::atomic_mode::might_sleep();\n\n    // SAFETY: RCU read-side critical sections disables preemption. By the time\n    // we reach this point, we have already checked that preemption is enabled.\n    unsafe {\n        crate::sync::finish_grace_period();\n    }\n\n    let irq_guard = crate::irq::disable_local();\n\n    before_switching_to(&next_task, &irq_guard);\n\n    // `before_switching_to` guarantees that from now on, and while the next task is running on the\n    // CPU, its context can be used exclusively.\n    let next_task_ctx_ptr = next_task.ctx().get().cast_const();\n\n    let current_task_ptr = CURRENT_TASK_PTR.load();\n    CURRENT_TASK_PTR.store(Arc::into_raw(next_task));\n    debug_assert!(PREVIOUS_TASK_PTR.load().is_null());\n    PREVIOUS_TASK_PTR.store(current_task_ptr);\n\n    // We must disable IRQs when switching, see `after_switching_to`.\n    core::mem::forget(irq_guard);\n\n    let current_task_ctx_ptr = if !current_task_ptr.is_null() {\n        // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n        // built with `Arc::into_raw`. It will only be dropped as a previous task,\n        // so its reference will be valid until `after_switching_to`.\n        let current_task = unsafe { &*current_task_ptr };\n        // Until `after_switching_to`, the task's context is alive and can be exclusively used.\n        current_task.ctx.get()\n    } else {\n        // SAFETY:\n        // 1. We have exclusive access to the next context (see above).\n        // 2. The next context is valid (because it is either correctly initialized or written by a\n        //    previous `context_switch`).\n        unsafe { first_context_switch(next_task_ctx_ptr) };\n        // We've switched to the first task on the current CPU.\n        unreachable!(\"`first_context_switch` should never return\");\n    };\n\n    // SAFETY:\n    // 1. We have exclusive access to both the current context and the next context (see above).\n    // 2. The next context is valid (because it is either correctly initialized or written by a\n    //    previous `context_switch`).\n    unsafe {\n        // This function may not return, for example, when the current task exits. So make sure\n        // that all variables on the stack can be forgotten without causing resource leakage.\n        context_switch(next_task_ctx_ptr, current_task_ctx_ptr);\n    }\n\n    // SAFETY: The task is just switched back, `after_switching_to` hasn't been called yet.\n    unsafe { after_switching_to() };\n}"
}