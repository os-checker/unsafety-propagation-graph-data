{
  "name": "ostd::util::range_alloc::RangeAllocator::free",
  "span": "ostd/src/util/range_alloc.rs:107:5: 107:44",
  "src": "pub fn free(&self, range: Range<usize>) {\n        let mut lock_guard = self.freelist.lock();\n        let freelist = lock_guard.as_mut().unwrap_or_else(|| {\n            panic!(\"Free a 'KVirtArea' when 'VirtAddrAllocator' has not been initialized.\")\n        });\n        // 1. get the previous free block, check if we can merge this block with the free one\n        //     - if contiguous, merge this area with the free block.\n        //     - if not contiguous, create a new free block, insert it into the list.\n        let mut free_range = range.clone();\n\n        if let Some((prev_va, prev_node)) = freelist\n            .upper_bound_mut(core::ops::Bound::Excluded(&free_range.start))\n            .peek_prev()\n            && prev_node.block.end == free_range.start\n        {\n            let prev_va = *prev_va;\n            free_range.start = prev_node.block.start;\n            freelist.remove(&prev_va);\n        }\n\n        freelist.insert(free_range.start, FreeRange::new(free_range.clone()));\n\n        // 2. check if we can merge the current block with the next block, if we can, do so.\n        if let Some((next_va, next_node)) = freelist\n            .lower_bound_mut(core::ops::Bound::Excluded(&free_range.start))\n            .peek_next()\n            && free_range.end == next_node.block.start\n        {\n            let next_va = *next_va;\n            free_range.end = next_node.block.end;\n            freelist.remove(&next_va);\n            freelist.get_mut(&free_range.start).unwrap().block.end = free_range.end;\n        }\n    }"
}