{
  "name": "ostd::sync::rcu::monitor::RcuMonitor::finish_grace_period",
  "span": "ostd/src/sync/rcu/monitor.rs:35:5: 35:52",
  "src": "pub(super) unsafe fn finish_grace_period(&self) {\n        // Fast path\n        if !self.is_monitoring.load(Relaxed) {\n            return;\n        }\n\n        // Check if the current GP is complete after passing the quiescent state\n        // on the current CPU. If GP is complete, take the callbacks of the current\n        // GP.\n        let callbacks = {\n            let mut state = self.state.disable_irq().lock();\n            let cpu = state.as_atomic_mode_guard().current_cpu();\n            if state.current_gp.is_complete() {\n                return;\n            }\n\n            state.current_gp.finish_grace_period(cpu);\n            if !state.current_gp.is_complete() {\n                return;\n            }\n\n            // Now that the current GP is complete, take its callbacks\n            let current_callbacks = state.current_gp.take_callbacks();\n\n            // Check if we need to watch for a next GP\n            if !state.next_callbacks.is_empty() {\n                let callbacks = core::mem::take(&mut state.next_callbacks);\n                state.current_gp.restart(callbacks);\n            } else {\n                self.is_monitoring.store(false, Relaxed);\n            }\n\n            current_callbacks\n        };\n\n        // Invoke the callbacks to notify the completion of GP\n        for f in callbacks {\n            (f)();\n        }\n    }"
}