{
  "name": "ostd::boot::smp::boot_all_aps",
  "span": "ostd/src/boot/smp.rs:72:1: 72:36",
  "src": "pub(crate) unsafe fn boot_all_aps() {\n    // Mark the BSP as started.\n    report_online_and_hw_cpu_id(crate::cpu::CpuId::bsp().as_usize().try_into().unwrap());\n\n    let num_cpus = crate::cpu::num_cpus();\n\n    if num_cpus == 1 {\n        return;\n    }\n    log::info!(\"Booting {} processors\", num_cpus - 1);\n\n    let mut per_ap_raw_info = Vec::with_capacity(num_cpus);\n    let mut per_ap_info = Vec::with_capacity(num_cpus);\n\n    for ap in 1..num_cpus {\n        let boot_stack_pages = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_segment_with(AP_BOOT_STACK_SIZE / PAGE_SIZE, |_| KernelMeta)\n            .unwrap();\n\n        per_ap_raw_info.push(PerApRawInfo {\n            stack_top: paddr_to_vaddr(boot_stack_pages.end_paddr()) as *mut u8,\n            cpu_local: paddr_to_vaddr(crate::cpu::local::get_ap(ap.try_into().unwrap())) as *mut u8,\n        });\n        per_ap_info.push(PerApInfo { boot_stack_pages });\n    }\n\n    assert!(!AP_BOOT_INFO.is_completed());\n    AP_BOOT_INFO.call_once(move || ApBootInfo {\n        per_ap_raw_info: per_ap_raw_info.into_boxed_slice(),\n        per_ap_info: per_ap_info.into_boxed_slice(),\n    });\n\n    log::info!(\"Booting all application processors...\");\n\n    let info_ptr = AP_BOOT_INFO.get().unwrap().per_ap_raw_info.as_ptr();\n    let pt_ptr = crate::mm::page_table::boot_pt::with_borrow(|pt| pt.root_address()).unwrap();\n    // SAFETY: It's the right time to boot APs (guaranteed by the caller) and\n    // the arguments are valid to boot APs (generated above).\n    unsafe { crate::arch::boot::smp::bringup_all_aps(info_ptr, pt_ptr, num_cpus as u32) };\n\n    wait_for_all_aps_started(num_cpus);\n\n    log::info!(\"All application processors started. The BSP continues to run.\");\n}"
}