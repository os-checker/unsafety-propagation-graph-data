{
  "name": "ostd::arch::cpu::cpuid::query_tsc_freq",
  "span": "ostd/src/arch/x86/cpu/cpuid.rs:57:1: 57:55",
  "src": "pub(in crate::arch) fn query_tsc_freq() -> Option<u64> {\n    let CpuidResult {\n        eax: denominator,\n        ebx: numerator,\n        ecx: crystal_freq,\n        ..\n    } = cpuid(Leaf::Tsc as u32, 0)?;\n\n    if denominator == 0 || numerator == 0 {\n        return None;\n    }\n\n    // If the nominal core crystal clock frequency is not enumerated, we can either obtain that\n    // information from a hardcoded table or rely on the processor base frequency. The Intel\n    // documentation recommends the first approach [1], but Linux uses the second approach because\n    // the first approach is difficult to implement correctly for all corner cases [2]. However,\n    // the second approach does not provide 100% accurate frequencies, so Linux must adjust them at\n    // runtime [2]. For now, we avoid these headaches by faithfully reporting that the TSC\n    // frequency is unavailable.\n    //\n    // [1]: Intel(R) 64 and IA-32 Architectures Software Developerâ€™s Manual,\n    //      Section 20.7.3, Determining the Processor Base Frequency\n    // [2]: https://github.com/torvalds/linux/commit/604dc9170f2435d27da5039a3efd757dceadc684\n    if crystal_freq == 0 {\n        return None;\n    }\n\n    Some((crystal_freq as u64) * (numerator as u64) / (denominator as u64))\n}"
}