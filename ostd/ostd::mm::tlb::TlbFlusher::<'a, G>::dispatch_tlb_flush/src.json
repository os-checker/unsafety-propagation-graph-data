{
  "name": "ostd::mm::tlb::TlbFlusher::<'a, G>::dispatch_tlb_flush",
  "span": "ostd/src/mm/tlb.rs:84:5: 84:41",
  "src": "pub fn dispatch_tlb_flush(&mut self) {\n        let irq_guard = crate::irq::disable_local();\n\n        if self.ops_stack.is_empty() {\n            return;\n        }\n\n        // `Release` to make sure our modification on the PT is visible to CPUs\n        // that are going to activate the PT.\n        let mut target_cpus = self.target_cpus.load(Ordering::Release);\n\n        let cur_cpu = irq_guard.current_cpu();\n        let mut need_flush_on_self = false;\n\n        if target_cpus.contains(cur_cpu) {\n            target_cpus.remove(cur_cpu);\n            need_flush_on_self = true;\n        }\n\n        if let Some(ipi_sender) = self.ipi_sender {\n            for cpu in target_cpus.iter() {\n                self.have_unsynced_flush.add(cpu);\n\n                let mut flush_ops = FLUSH_OPS.get_on_cpu(cpu).lock();\n                flush_ops.push_from(&self.ops_stack);\n                // Clear ACK before dropping the lock to avoid false ACKs.\n                ACK_REMOTE_FLUSH\n                    .get_on_cpu(cpu)\n                    .store(false, Ordering::Relaxed);\n            }\n\n            ipi_sender.inter_processor_call(&target_cpus, do_remote_flush);\n        }\n\n        // Flush ourselves after sending all IPIs to save some time.\n        if need_flush_on_self {\n            self.ops_stack.flush_all();\n        } else {\n            self.ops_stack.clear_without_flush();\n        }\n    }"
}