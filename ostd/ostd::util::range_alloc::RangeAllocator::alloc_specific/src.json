{
  "name": "ostd::util::range_alloc::RangeAllocator::alloc_specific",
  "span": "ostd/src/util/range_alloc.rs:30:5: 30:95",
  "src": "pub fn alloc_specific(&self, allocate_range: &Range<usize>) -> Result<(), RangeAllocError> {\n        if allocate_range.is_empty() {\n            return Err(RangeAllocError);\n        }\n\n        let mut lock_guard = self.get_freelist_guard();\n        let freelist = lock_guard.as_mut().unwrap();\n        let mut target_node = None;\n        let mut left_length = 0;\n        let mut right_length = 0;\n\n        for (key, value) in freelist.iter() {\n            if value.block.end >= allocate_range.end && value.block.start <= allocate_range.start {\n                target_node = Some(*key);\n                left_length = allocate_range.start - value.block.start;\n                right_length = value.block.end - allocate_range.end;\n                break;\n            }\n        }\n\n        if let Some(key) = target_node {\n            if left_length == 0 {\n                freelist.remove(&key);\n            } else if let Some(freenode) = freelist.get_mut(&key) {\n                freenode.block.end = allocate_range.start;\n            }\n\n            if right_length != 0 {\n                freelist.insert(\n                    allocate_range.end,\n                    FreeRange::new(allocate_range.end..(allocate_range.end + right_length)),\n                );\n            }\n        }\n\n        if target_node.is_some() {\n            Ok(())\n        } else {\n            Err(RangeAllocError)\n        }\n    }"
}