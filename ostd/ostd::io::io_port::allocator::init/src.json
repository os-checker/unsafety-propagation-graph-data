{
  "name": "ostd::io::io_port::allocator::init",
  "span": "ostd/src/io/io_port/allocator.rs:79:1: 79:35",
  "src": "pub(in crate::io) unsafe fn init() {\n    // SAFETY: `MAX_IO_PORT` is guaranteed not to exceed the maximum value specified by architecture.\n    let mut allocator = IdAlloc::with_capacity(crate::arch::io::MAX_IO_PORT as usize);\n\n    unsafe extern \"C\" {\n        fn __sensitive_io_ports_start();\n        fn __sensitive_io_ports_end();\n    }\n    let start = __sensitive_io_ports_start as *const () as usize;\n    let end = __sensitive_io_ports_end as *const () as usize;\n    assert!((end - start).is_multiple_of(size_of::<RawIoPortRange>()));\n\n    // Iterate through the sensitive I/O port ranges and remove them from the allocator.\n    let io_port_range_count = (end - start) / size_of::<RawIoPortRange>();\n    for i in 0..io_port_range_count {\n        let range_base_addr =\n            __sensitive_io_ports_start as *const () as usize + i * size_of::<RawIoPortRange>();\n        // SAFETY: The range is guaranteed to be valid as it is defined in the `.sensitive_io_ports` section.\n        let port_range = unsafe { *(range_base_addr as *const RawIoPortRange) };\n\n        assert!(port_range.begin < port_range.end);\n        debug!(\"Removing sensitive I/O port range: {:#x?}\", port_range);\n\n        for i in port_range.begin..port_range.end {\n            allocator.alloc_specific(i as usize);\n        }\n    }\n\n    IO_PORT_ALLOCATOR.call_once(|| IoPortAllocator {\n        allocator: SpinLock::new(allocator),\n    });\n}"
}