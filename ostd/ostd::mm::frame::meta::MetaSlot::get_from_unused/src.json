{
  "name": "ostd::mm::frame::meta::MetaSlot::get_from_unused",
  "span": "ostd/src/mm/frame/meta.rs:233:5: 237:44",
  "src": "pub(super) fn get_from_unused<M: AnyFrameMeta>(\n        paddr: Paddr,\n        metadata: M,\n        as_unique_ptr: bool,\n    ) -> Result<*const Self, GetFrameError> {\n        let slot = get_slot(paddr)?;\n\n        // `Acquire` pairs with the `Release` in `drop_last_in_place` and ensures the metadata\n        // initialization won't be reordered before this memory compare-and-exchange.\n        slot.ref_count\n            .compare_exchange(REF_COUNT_UNUSED, 0, Ordering::Acquire, Ordering::Relaxed)\n            .map_err(|val| match val {\n                REF_COUNT_UNIQUE => GetFrameError::Unique,\n                0 => GetFrameError::Busy,\n                _ => GetFrameError::InUse,\n            })?;\n\n        // SAFETY: The slot now has a reference count of `0`, other threads will\n        // not access the metadata slot so it is safe to have a mutable reference.\n        unsafe { slot.write_meta(metadata) };\n\n        if as_unique_ptr {\n            // No one can create a `Frame` instance directly from the page\n            // address, so `Relaxed` is fine here.\n            slot.ref_count.store(REF_COUNT_UNIQUE, Ordering::Relaxed);\n        } else {\n            // `Release` is used to ensure that the metadata initialization\n            // won't be reordered after this memory store.\n            slot.ref_count.store(1, Ordering::Release);\n        }\n\n        Ok(slot as *const MetaSlot)\n    }"
}