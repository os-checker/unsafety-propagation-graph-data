{
  "name": "ostd::task::kernel_stack::KernelStack::new_with_guard_page",
  "span": "ostd/src/task/kernel_stack.rs:63:5: 63:56",
  "mir": "fn ostd::task::kernel_stack::KernelStack::new_with_guard_page() -> core::result::Result<task::kernel_stack::KernelStack, error::Error> {\n    let mut _0: core::result::Result<task::kernel_stack::KernelStack, error::Error>;\n    let mut _1: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>>;\n    let mut _2: core::result::Result<mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>, error::Error>;\n    let mut _3: &mm::frame::allocator::FrameAllocOptions;\n    let  _4: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _5: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _6: mm::frame::allocator::FrameAllocOptions;\n    let mut _7: usize;\n    let mut _8: bool;\n    let mut _9: isize;\n    let  _10: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _11: mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>;\n    let  _12: mm::page_prop::PageProperty;\n    let mut _13: mm::page_prop::CachePolicy;\n    let mut _14: mm::page_prop::PrivilegedPageFlags;\n    let  _15: mm::kspace::kvirt_area::KVirtArea;\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: (usize, bool);\n    let mut _19: (usize, bool);\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>;\n    let  _23: usize;\n    let mut _24: usize;\n    let mut _25: core::ops::Range<usize>;\n    let mut _26: &mm::kspace::kvirt_area::KVirtArea;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let mut _29: (usize, bool);\n    let  _30: usize;\n    let mut _31: (usize, bool);\n    let mut _32: task::kernel_stack::KernelStack;\n    let mut _33: util::id_set::AtomicIdSet<cpu::id::CpuId>;\n    let mut _34: util::id_set::IdSet<cpu::id::CpuId>;\n    debug pages => _11;\n    debug residual => _10;\n    debug val => _11;\n    debug prop => _12;\n    debug new_kvirt_area => _15;\n    debug mapped_start => _23;\n    debug mapped_end => _30;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &mut _6;\n        _4 = mm::frame::allocator::FrameAllocOptions::zeroed(move _5, false) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = &(*_4);\n        StorageDead(_5);\n        StorageLive(_7);\n        _8 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _8, \"attempt to divide `{}` by zero\", task::kernel_stack::KERNEL_STACK_SIZE) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = Div(task::kernel_stack::KERNEL_STACK_SIZE, mm::PAGE_SIZE);\n        _2 = mm::frame::allocator::FrameAllocOptions::alloc_segment_with::<task::kernel_stack::KernelStackMeta, {closure@ostd/src/task/kernel_stack.rs:66:64: 66:67}>(move _3, move _7, ZeroSized: {closure@ostd/src/task/kernel_stack.rs:66:64: 66:67}) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_3);\n        _1 = <core::result::Result<mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>, error::Error> as core::ops::Try>::branch(move _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        _9 = discriminant(_1);\n        switchInt(move _9) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _11 = move ((_1 as variant#0).0: mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>);\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageDead(_1);\n        StorageLive(_13);\n        _13 = mm::page_prop::CachePolicy::Writeback;\n        StorageLive(_14);\n        _14 = mm::page_prop::PrivilegedPageFlags::empty() -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _10 = ((_1 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<task::kernel_stack::KernelStack, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageDead(_1);\n        goto -> bb22;\n    }\n    bb10: {\n        _12 = PageProperty(mm::page_prop::PageFlags::RW, move _13, move _14);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_16);\n        StorageLive(_17);\n        _18 = CheckedMul(4_usize, mm::PAGE_SIZE);\n        assert(!move (_18.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 4_usize, mm::PAGE_SIZE) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _17 = move (_18.0: usize);\n        _19 = CheckedAdd(task::kernel_stack::KERNEL_STACK_SIZE, _17);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", task::kernel_stack::KERNEL_STACK_SIZE, move _17) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _16 = move (_19.0: usize);\n        StorageDead(_17);\n        StorageLive(_20);\n        _21 = CheckedMul(2_usize, mm::PAGE_SIZE);\n        assert(!move (_21.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, mm::PAGE_SIZE) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_21.0: usize);\n        StorageLive(_22);\n        _22 = <mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta> as core::iter::IntoIterator>::into_iter(_11) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _15 = mm::kspace::kvirt_area::KVirtArea::map_frames::<task::kernel_stack::KernelStackMeta, mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>>(move _16, move _20, move _22, _12) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageDead(_16);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_15;\n        _25 = mm::kspace::kvirt_area::KVirtArea::range(move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _24 = (_25.0: usize);\n        StorageLive(_27);\n        _28 = CheckedMul(2_usize, mm::PAGE_SIZE);\n        assert(!move (_28.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, mm::PAGE_SIZE) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _27 = move (_28.0: usize);\n        _29 = CheckedAdd(_24, _27);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _24, move _27) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _23 = move (_29.0: usize);\n        StorageDead(_27);\n        StorageDead(_24);\n        StorageDead(_25);\n        _31 = CheckedAdd(_23, task::kernel_stack::KERNEL_STACK_SIZE);\n        assert(!move (_31.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _23, task::kernel_stack::KERNEL_STACK_SIZE) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _30 = move (_31.0: usize);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = util::id_set::IdSet::<cpu::id::CpuId>::new_empty() -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _33 = util::id_set::AtomicIdSet::<cpu::id::CpuId>::new(move _34) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_34);\n        _32 = KernelStack(_15, move _33, _30);\n        StorageDead(_33);\n        _0 = core::result::Result::Ok(move _32);\n        StorageDead(_32);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n"
}