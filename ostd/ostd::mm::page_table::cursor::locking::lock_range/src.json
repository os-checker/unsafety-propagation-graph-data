{
  "name": "ostd::mm::page_table::cursor::locking::lock_range",
  "span": "ostd/src/mm/page_table/cursor/locking.rs:21:1: 25:21",
  "src": "pub(super) fn lock_range<'rcu, C: PageTableConfig>(\n    pt: &'rcu PageTable<C>,\n    guard: &'rcu dyn InAtomicMode,\n    va: &Range<Vaddr>,\n) -> Cursor<'rcu, C> {\n    // The re-try loop of finding the sub-tree root.\n    //\n    // If we locked a stray node, we need to re-try. Otherwise, although\n    // there are no safety concerns, the operations of a cursor on an stray\n    // sub-tree will not see the current state and will not change the current\n    // state, breaking serializability.\n    let mut subtree_root = loop {\n        if let Some(subtree_root) = try_traverse_and_lock_subtree_root(pt, guard, va) {\n            break subtree_root;\n        }\n    };\n\n    // Once we have locked the sub-tree that is not stray, we won't read any\n    // stray nodes in the following traversal since we must lock before reading.\n    let guard_level = subtree_root.level();\n    let cur_node_va = va.start.align_down(page_size::<C>(guard_level + 1));\n    dfs_acquire_lock(guard, &mut subtree_root, cur_node_va, va.clone());\n\n    let mut path = core::array::from_fn(|_| None);\n    path[guard_level as usize - 1] = Some(subtree_root);\n\n    Cursor::<'rcu, C> {\n        path,\n        rcu_guard: guard,\n        level: guard_level,\n        guard_level,\n        va: va.start,\n        barrier_va: va.clone(),\n        _phantom: PhantomData,\n    }\n}"
}