{
  "name": "ostd::mm::dma::dma_stream::DmaStream::<D>::sync_impl",
  "span": "ostd/src/mm/dma/dma_stream.rs:213:5: 213:93",
  "src": "fn sync_impl(&self, byte_range: Range<usize>, is_from_device: bool) -> Result<(), Error> {\n        let size = self.size();\n        if byte_range.end > size || byte_range.start > size {\n            return Err(Error::InvalidArgs);\n        }\n        if self.is_cache_coherent {\n            return Ok(());\n        }\n\n        let va_range = match &self.inner {\n            Inner::Segment(segment) => {\n                let pa_range = segment.paddr_range();\n                paddr_to_vaddr(pa_range.start)..paddr_to_vaddr(pa_range.end)\n            }\n            Inner::Kva(kva, _) => {\n                if !can_sync_dma() {\n                    // The KVA is mapped as uncachable.\n                    return Ok(());\n                }\n                kva.range()\n            }\n            Inner::Both(kva, _, seg) => {\n                self.sync_via_copying(byte_range, is_from_device, seg, kva);\n                return Ok(());\n            }\n        };\n        let range = va_range.start + byte_range.start..va_range.start + byte_range.end;\n\n        // SAFETY: We've checked that the range is inbound, so the virtual\n        // address range and the DMA direction correspond to a DMA region\n        // (they're part of `self`).\n        unsafe { crate::arch::mm::sync_dma_range::<D>(range) };\n\n        Ok(())\n    }"
}