{
  "name": "ostd::arch::iommu::registers::IommuRegisters::enable_queued_invalidation",
  "span": "ostd/src/arch/x86/iommu/registers/mod.rs:151:5: 151:71",
  "src": "pub(super) fn enable_queued_invalidation(&mut self, queue: &Queue) {\n        assert!(\n            self.read_extended_capability()\n                .flags()\n                .contains(ExtendedCapabilityFlags::QI)\n        );\n        self.invalidate.queue_tail.as_mut_ptr().write(0);\n\n        let mut write_value = queue.base_paddr() as u64;\n        // By default, we set descriptor width to 128-bit(0)\n        let descriptor_width = 0b0;\n        write_value |= descriptor_width << 11;\n\n        let write_queue_size = {\n            let mut queue_size = queue.size();\n            assert!(queue_size.is_power_of_two());\n            let mut write_queue_size = 0;\n\n            if descriptor_width == 0 {\n                // 2^(write_queue_size + 8) = number of entries = queue_size\n                assert!(queue_size >= (1 << 8));\n                queue_size >>= 8;\n            } else {\n                // 2^(write_queue_size + 7) = number of entries = queue_size\n                assert!(queue_size >= (1 << 7));\n                queue_size >>= 7;\n            };\n\n            while queue_size & 0b1 == 0 {\n                queue_size >>= 1;\n                write_queue_size += 1;\n            }\n            write_queue_size\n        };\n\n        write_value |= write_queue_size;\n\n        self.invalidate.queue_addr.as_mut_ptr().write(write_value);\n\n        // Enable queued invalidation\n        self.write_global_command(GlobalCommand::QIE, true);\n        while !self.read_global_status().contains(GlobalStatus::QIES) {}\n\n        // Clear the Invalidation Completion Status Register\n        self.invalidate.completion_status.as_mut_ptr().write(1);\n    }"
}