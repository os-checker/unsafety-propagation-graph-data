{
  "name": "ostd::arch::io::construct_io_mem_allocator_builder",
  "span": "ostd/src/arch/x86/io.rs:29:1: 29:83",
  "src": "pub(super) unsafe fn construct_io_mem_allocator_builder() -> IoMemAllocatorBuilder {\n    // TODO: Add MMIO regions below 1MB (e.g., VGA framebuffer).\n    let regions = &crate::boot::EARLY_INFO.get().unwrap().memory_regions;\n    let mut ranges = Vec::with_capacity(2);\n\n    let reserved_filter = regions.iter().filter(|r| {\n        r.typ() != MemoryRegionType::Unknown\n            && r.typ() != MemoryRegionType::Reserved\n            && r.typ() != MemoryRegionType::Framebuffer\n    });\n\n    // Find the TOLM (Top of Low Memory) and initialize Low MMIO region (TOLM ~ LOW_MMIO_TOP).\n    // Align start address to LOW_MMIO_ALIGN (according to Intel's datasheets, the lower 20 bits\n    // are zeroed).\n    const LOW_MMIO_TOP: usize = 0x1_0000_0000; // 4 GiB, 32 bits\n    const LOW_MMIO_ALIGN: usize = 0x10_0000; // 1 MiB, 20 bits\n    let (lower_half_base, lower_half_len) = reserved_filter\n        .clone()\n        .filter(|r| r.base() < LOW_MMIO_TOP)\n        .max_by(|a, b| a.base().cmp(&b.base()))\n        .map(|reg| (reg.base(), reg.len()))\n        .unwrap();\n\n    let mmio_start_addr = (lower_half_base + lower_half_len).align_up(LOW_MMIO_ALIGN);\n    assert!(mmio_start_addr < LOW_MMIO_TOP);\n    ranges.push(mmio_start_addr..LOW_MMIO_TOP);\n\n    // Find the TOHM (Top of High Memory) and initialize High MMIO region (TOHM ~ HIGH_MMIO_TOP).\n    // Align start address to HIGH_MMIO_ALIGN (according to Intel's datasheets, the lower 20 bits\n    // are zeroed).\n    //\n    // TODO: Use the CPUID instruction to determine the maximum number of bits in physical\n    // addresses. We use 52 bits here, which is the architectural limit for physical addresses.\n    const HIGH_MMIO_TOP: usize = 0x10_0000_0000_0000; // 4 PiB, 52 bits\n    const HIGH_MMIO_ALIGN: usize = 0x10_0000; // 1 MiB, 20 bits\n    let (upper_half_base, upper_half_len) = reserved_filter\n        .filter(|r| r.base() >= LOW_MMIO_TOP)\n        .max_by(|a, b| a.base().cmp(&b.base()))\n        .map(|reg| (reg.base(), reg.len()))\n        .unwrap_or((LOW_MMIO_TOP, 0));\n\n    let mmio_start_addr = (upper_half_base + upper_half_len).align_up(HIGH_MMIO_ALIGN);\n    assert!(mmio_start_addr < HIGH_MMIO_TOP);\n    ranges.push(mmio_start_addr..HIGH_MMIO_TOP);\n\n    // SAFETY:\n    // 1. This is the only place that creates an `IoMemAllocatorBuilder`. The\n    //    caller ensures that the function is only called once.\n    // 2. The caller ensures that the kernel page table is already activated.\n    // 3. The range is guaranteed not to access physical memory.\n    unsafe { IoMemAllocatorBuilder::new(ranges) }\n}"
}