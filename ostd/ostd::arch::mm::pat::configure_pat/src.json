{
  "name": "ostd::arch::mm::pat::configure_pat",
  "span": "ostd/src/arch/x86/mm/pat.rs:70:1: 70:30",
  "src": "pub(super) fn configure_pat() {\n    // Reference: Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Table 12-10,\n    // \"Memory Types That Can Be Encoded With PAT\".\n    fn cache_policy_to_pat_entry(cache_policy: CachePolicy) -> u8 {\n        match cache_policy {\n            CachePolicy::Uncacheable => 0x00,\n            CachePolicy::WriteCombining => 0x01,\n            CachePolicy::WriteProtected => 0x05,\n            CachePolicy::Writethrough => 0x04,\n            CachePolicy::Writeback => 0x06,\n        }\n    }\n\n    let mut programmed_pat = 0u64;\n    for (idx, policy) in IA32_PAT_MAPPINGS.iter().copied().enumerate() {\n        programmed_pat |= (cache_policy_to_pat_entry(policy) as u64) << (idx * 8);\n    }\n\n    // SAFETY: Writing `IA32_PAT` only programs the PAT MSR of the current CPU.\n    // Updating PAT merely redefines how hardware interprets future cache\n    // policy encodings. The programmed value is the global invariant, which\n    // is set up before the kernel page table is activated.\n    unsafe {\n        wrmsr(IA32_PAT, programmed_pat);\n    }\n}"
}