{
  "name": "ostd::arch::trap::gdt::init_on_cpu",
  "span": "ostd/src/arch/x86/trap/gdt.rs:33:1: 33:35",
  "src": "pub(super) unsafe fn init_on_cpu() {\n    let tss_ptr = LOCAL_TSS.as_ptr();\n\n    // FIXME: The segment limit in the descriptor created by `tss_segment_unchecked` does not\n    // include the I/O port bitmap.\n\n    // SAFETY: As a CPU-local variable, the TSS lives for `'static`.\n    let tss_desc = unsafe { Descriptor::tss_segment_unchecked(tss_ptr) };\n    let (tss0, tss1) = match tss_desc {\n        Descriptor::SystemSegment(tss0, tss1) => (tss0, tss1),\n        _ => unreachable!(),\n    };\n\n    // The kernel CS is considered a global invariant set by the boot GDT. This method is not\n    // intended for switching to a new kernel CS.\n    assert_eq!(CS::get_reg(), KERNEL_CS);\n\n    // Allocate a new GDT with 8 entries.\n    let gdt = Box::new([\n        0, KCODE64, KDATA, /* UCODE32 (not used) */ 0, UDATA, UCODE64, tss0, tss1,\n    ]);\n    let gdt = &*Box::leak(gdt);\n    assert_eq!(gdt[KERNEL_CS.index() as usize], KCODE64);\n    assert_eq!(gdt[KERNEL_SS.index() as usize], KDATA);\n    assert_eq!(gdt[USER_CS.index() as usize], UCODE64);\n    assert_eq!(gdt[USER_SS.index() as usize], UDATA);\n\n    // Load the new GDT.\n    let gdtr = DescriptorTablePointer {\n        limit: (size_of_val(gdt) - 1) as u16,\n        base: VirtAddr::new(gdt.as_ptr().addr() as u64),\n    };\n    // SAFETY: The GDT is valid to load because:\n    //  - It lives for `'static`.\n    //  - It contains correct entries at correct indexes: the kernel code/data segments, the user\n    //    code/data segments, and the TSS segment.\n    //  - Specifically, the TSS segment points to the CPU-local TSS of the current CPU.\n    unsafe { lgdt(&gdtr) };\n\n    // Load the TSS.\n    let tss_sel = SegmentSelector::new(6, PrivilegeLevel::Ring0);\n    assert_eq!(gdt[tss_sel.index() as usize], tss0);\n    assert_eq!(gdt[(tss_sel.index() + 1) as usize], tss1);\n    // SAFETY: The selector points to the TSS descriptors in the GDT.\n    unsafe { load_tss(tss_sel) };\n\n    // Set up the selectors for the `syscall` and `sysret` instructions.\n    let sysret = SegmentSelector::new(3, PrivilegeLevel::Ring3);\n    assert_eq!(gdt[(sysret.index() + 1) as usize], UDATA);\n    assert_eq!(gdt[(sysret.index() + 2) as usize], UCODE64);\n    let syscall = SegmentSelector::new(1, PrivilegeLevel::Ring0);\n    assert_eq!(gdt[syscall.index() as usize], KCODE64);\n    assert_eq!(gdt[(syscall.index() + 1) as usize], KDATA);\n    // SAFETY: The selector points to correct kernel/user code/data descriptors in the GDT.\n    unsafe { Star::write_raw(sysret.0, syscall.0) };\n}"
}