{
  "name": "ostd::arch::kernel::apic::get_or_init",
  "span": "ostd/src/arch/x86/kernel/apic/mod.rs:44:1: 44:72",
  "src": "pub fn get_or_init(_guard: &dyn PinCurrentCpu) -> &(dyn Apic + 'static) {\n    struct ForceSyncSend<T>(T);\n\n    // SAFETY: `ForceSyncSend` is `Sync + Send`, but accessing its contained value is unsafe.\n    unsafe impl<T> Sync for ForceSyncSend<T> {}\n    unsafe impl<T> Send for ForceSyncSend<T> {}\n\n    impl<T> ForceSyncSend<T> {\n        /// # Safety\n        ///\n        /// The caller must ensure that its context allows for safe access to `&T`.\n        unsafe fn get(&self) -> &T {\n            &self.0\n        }\n    }\n\n    cpu_local! {\n        static APIC_INSTANCE: Once<ForceSyncSend<Box<dyn Apic + 'static>>> = Once::new();\n    }\n\n    // No races due to `_guard`, but use `current_racy` to avoid calling via the vtable.\n    // TODO: Find a better way to make `dyn PinCurrentCpu` easy to use?\n    let apic_instance = APIC_INSTANCE.get_on_cpu(crate::cpu::CpuId::current_racy());\n\n    // The APIC instance has already been initialized.\n    if let Some(apic) = apic_instance.get() {\n        // SAFETY: Accessing `&dyn Apic` is safe as long as we're running on the same CPU on which\n        // the APIC instance was created. The `get_on_cpu` method above ensures this.\n        return &**unsafe { apic.get() };\n    }\n\n    // Initialize the APIC instance now.\n    apic_instance.call_once(|| match APIC_TYPE.get().unwrap() {\n        ApicType::XApic(io_mem) => {\n            let mut xapic = xapic::XApic::new(io_mem).unwrap();\n            xapic.enable();\n            let version = xapic.version();\n            log::info!(\n                \"xAPIC ID:{:x}, Version:{:x}, Max LVT:{:x}\",\n                xapic.id(),\n                version & 0xff,\n                (version >> 16) & 0xff\n            );\n            ForceSyncSend(Box::new(xapic))\n        }\n        ApicType::X2Apic => {\n            let mut x2apic = x2apic::X2Apic::new().unwrap();\n            x2apic.enable();\n            let version = x2apic.version();\n            log::info!(\n                \"x2APIC ID:{:x}, Version:{:x}, Max LVT:{:x}\",\n                x2apic.id(),\n                version & 0xff,\n                (version >> 16) & 0xff\n            );\n            ForceSyncSend(Box::new(x2apic))\n        }\n    });\n\n    // We've initialized the APIC instance, so this `unwrap` cannot fail.\n    let apic = apic_instance.get().unwrap();\n    // SAFETY: Accessing `&dyn Apic` is safe as long as we're running on the same CPU on which the\n    // APIC instance was created. The initialization above ensures this.\n    &**unsafe { apic.get() }\n}"
}