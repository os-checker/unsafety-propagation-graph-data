{
  "name": "ostd::init",
  "span": "ostd/src/lib.rs:72:1: 72:17",
  "src": "unsafe fn init() {\n    arch::enable_cpu_features();\n\n    // SAFETY: This function is called only once, before `allocator::init`\n    // and after memory regions are initialized.\n    unsafe { mm::frame::allocator::init_early_allocator() };\n\n    #[cfg(target_arch = \"x86_64\")]\n    arch::if_tdx_enabled!({\n    } else {\n        arch::serial::init();\n    });\n    #[cfg(not(target_arch = \"x86_64\"))]\n    arch::serial::init();\n\n    logger::init();\n\n    // SAFETY:\n    //  1. They are only called once in the boot context of the BSP.\n    //  2. The number of CPUs are available because ACPI has been initialized.\n    //  3. CPU-local storage has NOT been used.\n    unsafe { cpu::init_on_bsp() };\n\n    // SAFETY: We are on the BSP and APs are not yet started.\n    let meta_pages = unsafe { mm::frame::meta::init() };\n    // The frame allocator should be initialized immediately after the metadata\n    // is initialized. Otherwise the boot page table can't allocate frames.\n    // SAFETY: This function is called only once.\n    unsafe { mm::frame::allocator::init() };\n\n    mm::kspace::init_kernel_page_table(meta_pages);\n\n    // SAFETY: This function is called only once on the BSP.\n    unsafe { mm::kspace::activate_kernel_page_table() };\n\n    sync::init();\n\n    boot::init_after_heap();\n\n    // SAFETY: This function is called only once on the BSP.\n    unsafe { arch::late_init_on_bsp() };\n\n    #[cfg(target_arch = \"x86_64\")]\n    arch::if_tdx_enabled!({\n        arch::serial::init();\n    });\n\n    smp::init();\n\n    // SAFETY:\n    // 1. The kernel page table is activated on the BSP.\n    // 2. The function is called only once on the BSP.\n    // 3. No remaining `with_borrow` invocations from now.\n    unsafe { crate::mm::page_table::boot_pt::dismiss() };\n\n    arch::irq::enable_local();\n\n    invoke_ffi_init_funcs();\n\n    IN_BOOTSTRAP_CONTEXT.store(false, Ordering::Relaxed);\n}"
}