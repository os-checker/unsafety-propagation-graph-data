{
  "name": "ostd::mm::vm_space::CursorMut::<'a>::map_iomem",
  "span": "ostd/src/mm/vm_space.rs:396:5: 396:94",
  "src": "pub fn map_iomem(&mut self, io_mem: IoMem, prop: PageProperty, len: usize, offset: usize) {\n        assert_eq!(len % PAGE_SIZE, 0);\n        assert_eq!(offset % PAGE_SIZE, 0);\n\n        if offset >= io_mem.size() {\n            return;\n        }\n\n        let paddr_begin = io_mem.paddr() + offset;\n        let paddr_end = if io_mem.size() - offset < len {\n            io_mem.paddr() + io_mem.size()\n        } else {\n            io_mem.paddr() + len + offset\n        };\n\n        for current_paddr in (paddr_begin..paddr_end).step_by(PAGE_SIZE) {\n            // Save the current virtual address before mapping, since map() will advance the cursor\n            let current_va = self.virt_addr();\n\n            // SAFETY: It is safe to map I/O memory into the userspace.\n            let map_result = unsafe {\n                self.pt_cursor\n                    .map(VmItem::new_untracked_io(current_paddr, prop))\n            };\n\n            let Err(frag) = map_result else {\n                // No mapping exists at the current address.\n                continue;\n            };\n\n            self.handle_remapped_frag(frag, current_va);\n        }\n\n        // If the `iomems` list in `VmSpace` does not contain the current I/O\n        // memory, push it to maintain the correct reference count.\n        let mut iomems = self.vmspace.iomems.lock();\n        if !iomems\n            .iter()\n            .any(|iomem| iomem.paddr() == io_mem.paddr() && iomem.size() == io_mem.size())\n        {\n            iomems.push(io_mem);\n        }\n    }"
}