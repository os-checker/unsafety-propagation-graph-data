{
  "name": "ostd::mm::page_table::cursor::Cursor::<'rcu, C>::query",
  "span": "ostd/src/mm/page_table/cursor/mod.rs:147:5: 147:69",
  "src": "pub fn query(&mut self) -> Result<PagesState<C>, PageTableError> {\n        if self.va >= self.barrier_va.end {\n            return Err(PageTableError::InvalidVaddr(self.va));\n        }\n\n        let rcu_guard = self.rcu_guard;\n\n        loop {\n            let level = self.level;\n\n            let cur_entry = self.cur_entry();\n            let item = match cur_entry.to_ref() {\n                ChildRef::PageTable(pt) => {\n                    // SAFETY: The `pt` must be locked and no other guards exist.\n                    let guard = unsafe { pt.make_guard_unchecked(rcu_guard) };\n                    self.push_level(guard);\n                    continue;\n                }\n                ChildRef::None => None,\n                ChildRef::Frame(pa, ch_level, prop) => {\n                    debug_assert_eq!(ch_level, level);\n\n                    // SAFETY:\n                    // This is part of (if `split_huge` happens) a page table item mapped\n                    // with a previous call to `C::item_into_raw`, where:\n                    //  - The physical address and the paging level match it;\n                    //  - The item part is still mapped so we don't take its ownership;\n                    //  - The `AVAIL1` flag is preserved by the cursor and the callers of\n                    //    the unsafe `protect_next` method.\n                    let item = ManuallyDrop::new(unsafe { C::item_from_raw(pa, level, prop) });\n                    // TODO: Provide a `PageTableItemRef` to reduce copies.\n                    Some((*item).clone())\n                }\n            };\n\n            return Ok((self.cur_va_range(), item));\n        }\n    }"
}