{
  "name": "ostd::mm::page_table::boot_pt::BootPageTable::<E, C>::map_base_page",
  "span": "ostd/src/mm/page_table/boot_pt.rs:163:5: 163:93",
  "src": "pub unsafe fn map_base_page(&mut self, from: Vaddr, to: FrameNumber, prop: PageProperty) {\n        let mut pt = self.root_pt;\n        let mut level = C::NR_LEVELS;\n        // Walk to the last level of the page table.\n        while level > 1 {\n            let index = pte_index::<C>(from, level);\n            let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n            let pte = unsafe { pte_ptr.read() };\n            pt = if !pte.is_present() {\n                let pte = self.alloc_child();\n                unsafe { pte_ptr.write(pte) };\n                pte.paddr() / C::BASE_PAGE_SIZE\n            } else if pte.is_last(level) {\n                panic!(\"mapping an already mapped huge page in the boot page table\");\n            } else {\n                pte.paddr() / C::BASE_PAGE_SIZE\n            };\n            level -= 1;\n        }\n        // Map the page in the last level page table.\n        let index = pte_index::<C>(from, 1);\n        let pte_ptr = unsafe { (paddr_to_vaddr(pt * C::BASE_PAGE_SIZE) as *mut E).add(index) };\n        let pte = unsafe { pte_ptr.read() };\n        if pte.is_present() {\n            panic!(\"mapping an already mapped page in the boot page table\");\n        }\n        unsafe { pte_ptr.write(E::new_page(to * C::BASE_PAGE_SIZE, 1, prop)) };\n    }"
}