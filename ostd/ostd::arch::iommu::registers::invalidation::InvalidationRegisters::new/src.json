{
  "name": "ostd::arch::iommu::registers::invalidation::InvalidationRegisters::new",
  "span": "ostd/src/arch/x86/iommu/registers/invalidation.rs:39:5: 39:56",
  "src": "pub(super) unsafe fn new(base: NonNull<u8>) -> Self {\n        let offset = {\n            // SAFETY: The safety is upheld by the caller.\n            let extended_capability =\n                unsafe { VolatileRef::new_read_only(base.add(0x10).cast::<u64>()) };\n            let extend_cap = ExtendedCapability::new(extended_capability.as_ptr().read());\n            extend_cap.iotlb_register_offset() as usize * 16\n        };\n\n        // FIXME: We now trust the hardware. We should instead find a way to check that `offset`\n        // are reasonable values before proceeding.\n\n        // SAFETY: The safety is upheld by the caller and the correctness of the capability value.\n        unsafe {\n            Self {\n                _queue_head: VolatileRef::new_read_only(base.add(0x80).cast::<u64>()),\n                queue_tail: VolatileRef::new(base.add(0x88).cast::<u64>()),\n                queue_addr: VolatileRef::new(base.add(0x90).cast::<u64>()),\n                completion_status: VolatileRef::new(base.add(0x9C).cast::<u32>()),\n                _completion_event_control: VolatileRef::new(base.add(0xA0).cast::<u32>()),\n                _completion_event_data: VolatileRef::new(base.add(0xA4).cast::<u32>()),\n                _completion_event_addr: VolatileRef::new(base.add(0xA8).cast::<u32>()),\n                _completion_event_upper_addr: VolatileRef::new(base.add(0xAC).cast::<u32>()),\n                _queue_error_record: VolatileRef::new_read_only(base.add(0xB0).cast::<u64>()),\n\n                _invalidate_address: VolatileRef::new_restricted(\n                    WriteOnly,\n                    base.add(offset).cast::<u64>(),\n                ),\n                iotlb_invalidate: VolatileRef::new(base.add(offset).add(0x08).cast::<u64>()),\n            }\n        }\n    }"
}