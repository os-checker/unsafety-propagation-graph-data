{
  "name": "ostd::mm::dma::util::alloc_kva",
  "span": "ostd/src/mm/dma/util.rs:74:1: 77:39",
  "src": "pub(super) fn alloc_kva(\n    nframes: usize,\n    is_cache_coherent: bool,\n) -> Result<(KVirtArea, Paddr), Error> {\n    let segment = Segment::from_unsized(\n        FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_segment_with(nframes, |_| DmaBufferMeta)?,\n    );\n\n    #[cfg_attr(not(target_arch = \"x86_64\"), expect(unused_labels))]\n    let priv_flags = 'priv_flags: {\n        #[cfg(target_arch = \"x86_64\")]\n        crate::if_tdx_enabled!({ break 'priv_flags PrivilegedPageFlags::SHARED });\n\n        PrivilegedPageFlags::empty()\n    };\n\n    let cache = if is_cache_coherent {\n        CachePolicy::Writeback\n    } else {\n        CachePolicy::Uncacheable\n    };\n\n    let paddr = segment.paddr();\n    let kva = KVirtArea::map_frames(\n        segment.size(),\n        0,\n        segment,\n        PageProperty {\n            flags: PageFlags::RW,\n            cache,\n            priv_flags,\n        },\n    );\n\n    let target_cpus = AtomicCpuSet::new(CpuSet::new_full());\n    let mut flusher = TlbFlusher::new(&target_cpus, disable_preempt());\n    flusher.issue_tlb_flush(TlbFlushOp::for_range(kva.range()));\n    flusher.dispatch_tlb_flush();\n    flusher.sync_tlb_flush();\n\n    Ok((kva, paddr))\n}"
}