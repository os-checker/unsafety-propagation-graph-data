{
  "name": "ostd::panic::print_stack_trace::callback",
  "span": "ostd/src/panic.rs:75:5: 75:97",
  "src": "extern \"C\" fn callback(unwind_ctx: &UnwindContext<'_>, arg: *mut c_void) -> UnwindReasonCode {\n        let data = unsafe { &mut *(arg as *mut CallbackData) };\n        data.counter += 1;\n        let pc = _Unwind_GetIP(unwind_ctx);\n        if pc > 0 {\n            let fde_initial_address = _Unwind_FindEnclosingFunction(pc as *mut c_void) as usize;\n            early_println!(\n                \"{:4}: fn {:#18x} - pc {:#18x} / registers:\",\n                data.counter,\n                fde_initial_address,\n                pc,\n            );\n        }\n        // Print the first 8 general registers for any architecture. The register number follows\n        // the DWARF standard.\n        for i in 0..8u16 {\n            let reg_i = _Unwind_GetGR(unwind_ctx, i as i32);\n            cfg_if::cfg_if! {\n                if #[cfg(target_arch = \"x86_64\")] {\n                    let reg_name = gimli::X86_64::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else if #[cfg(target_arch = \"riscv64\")] {\n                    let reg_name = gimli::RiscV::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else if #[cfg(target_arch = \"aarch64\")] {\n                    let reg_name = gimli::AArch64::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else {\n                    let reg_name = \"unknown\";\n                }\n            }\n            if i.is_multiple_of(4) {\n                early_print!(\"\\n    \");\n            }\n            early_print!(\" {} {:#18x};\", reg_name, reg_i);\n        }\n        early_print!(\"\\n\\n\");\n        UnwindReasonCode::NO_REASON\n    }"
}