{
  "name": "ostd::arch::boot::multiboot::parse_memory_regions",
  "span": "ostd/src/arch/x86/boot/multiboot/mod.rs:78:1: 78:77",
  "src": "fn parse_memory_regions(mb1_info: &MultibootLegacyInfo) -> MemoryRegionArray {\n    let mut regions = MemoryRegionArray::new();\n\n    // Add the regions in the multiboot protocol.\n    for entry in mb1_info.get_memory_map() {\n        let region = MemoryRegion::new(\n            entry.base_addr().try_into().unwrap(),\n            entry.length().try_into().unwrap(),\n            entry.memory_type(),\n        );\n        regions.push(region).unwrap();\n    }\n\n    // Add the framebuffer region.\n    if let Some(fb) = parse_framebuffer_info(mb1_info) {\n        regions.push(MemoryRegion::framebuffer(&fb)).unwrap();\n    }\n\n    // Add the kernel region.\n    regions.push(MemoryRegion::kernel()).unwrap();\n\n    // Add the initramfs region.\n    if let Some(initramfs) = parse_initramfs(mb1_info) {\n        regions.push(MemoryRegion::module(initramfs)).unwrap();\n    }\n\n    // Add the AP boot code region that will be copied into by the BSP.\n    regions\n        .push(super::smp::reclaimable_memory_region())\n        .unwrap();\n\n    // Add the kernel cmdline and boot loader name region since Grub does not specify it.\n    if let Some(kcmdline) = parse_kernel_commandline(mb1_info) {\n        regions\n            .push(MemoryRegion::module(kcmdline.as_bytes()))\n            .unwrap();\n    }\n    if let Some(bootloader_name) = parse_bootloader_name(mb1_info) {\n        regions\n            .push(MemoryRegion::module(bootloader_name.as_bytes()))\n            .unwrap();\n    }\n\n    regions.into_non_overlapping()\n}"
}