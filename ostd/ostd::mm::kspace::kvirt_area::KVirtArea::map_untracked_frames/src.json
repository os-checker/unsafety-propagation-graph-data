{
  "name": "ostd::mm::kspace::kvirt_area::KVirtArea::map_untracked_frames",
  "span": "ostd/src/mm/kspace/kvirt_area.rs:145:5: 150:14",
  "src": "pub unsafe fn map_untracked_frames(\n        area_size: usize,\n        map_offset: usize,\n        pa_range: Range<Paddr>,\n        prop: PageProperty,\n    ) -> Self {\n        assert!(pa_range.start.is_multiple_of(PAGE_SIZE));\n        assert!(pa_range.end.is_multiple_of(PAGE_SIZE));\n        assert!(area_size.is_multiple_of(PAGE_SIZE));\n        assert!(map_offset.is_multiple_of(PAGE_SIZE));\n        assert!(map_offset + pa_range.len() <= area_size);\n\n        let range = KVIRT_AREA_ALLOCATOR.alloc(area_size).unwrap();\n\n        if !pa_range.is_empty() {\n            let len = pa_range.len();\n            let va_range = range.start + map_offset..range.start + map_offset + len;\n\n            let page_table = KERNEL_PAGE_TABLE.get().unwrap();\n            let preempt_guard = disable_preempt();\n            let mut cursor = page_table.cursor_mut(&preempt_guard, &va_range).unwrap();\n\n            for (pa, level) in largest_pages::<KernelPtConfig>(va_range.start, pa_range.start, len)\n            {\n                // SAFETY: The caller of `map_untracked_frames` has ensured the safety of this mapping.\n                let _ = unsafe { cursor.map(MappedItem::Untracked(pa, level, prop)) };\n            }\n        }\n\n        Self { range }\n    }"
}