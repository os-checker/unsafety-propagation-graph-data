{
  "name": "ostd::mm::page_table::cursor::Cursor::<'rcu, C>::find_next_impl",
  "span": "ostd/src/mm/page_table/cursor/mod.rs:216:5: 221:23",
  "src": "fn find_next_impl(\n        &mut self,\n        len: usize,\n        find_unmap_subtree: bool,\n        split_huge: bool,\n    ) -> Option<Vaddr> {\n        assert_eq!(len % C::BASE_PAGE_SIZE, 0);\n        let end = self.va + len;\n        assert!(end <= self.barrier_va.end);\n        debug_assert_eq!(end % C::BASE_PAGE_SIZE, 0);\n\n        let rcu_guard = self.rcu_guard;\n\n        while self.va < end {\n            let cur_va = self.va;\n            let cur_va_range = self.cur_va_range();\n            let cur_entry_fits_range = cur_va == cur_va_range.start && cur_va_range.end <= end;\n\n            let mut cur_entry = self.cur_entry();\n            match cur_entry.to_ref() {\n                ChildRef::PageTable(pt) => {\n                    if find_unmap_subtree\n                        && cur_entry_fits_range\n                        && (C::TOP_LEVEL_CAN_UNMAP || self.level != C::NR_LEVELS)\n                    {\n                        return Some(cur_va);\n                    }\n\n                    // SAFETY: The `pt` must be locked and no other guards exist.\n                    let pt_guard = unsafe { pt.make_guard_unchecked(rcu_guard) };\n                    // If there's no mapped PTEs in the next level, we can\n                    // skip to save time.\n                    if pt_guard.nr_children() != 0 {\n                        self.push_level(pt_guard);\n                    } else {\n                        let _ = ManuallyDrop::new(pt_guard);\n                        self.move_forward();\n                    }\n                    continue;\n                }\n                ChildRef::None => {\n                    self.move_forward();\n                    continue;\n                }\n                ChildRef::Frame(_, _, _) => {\n                    if cur_entry_fits_range || !split_huge {\n                        return Some(cur_va);\n                    }\n\n                    let split_child = cur_entry\n                        .split_if_mapped_huge(rcu_guard)\n                        .expect(\"The entry must be a huge page\");\n                    self.push_level(split_child);\n                    continue;\n                }\n            }\n        }\n\n        None\n    }"
}