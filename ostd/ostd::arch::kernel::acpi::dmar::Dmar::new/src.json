{
  "name": "ostd::arch::kernel::acpi::dmar::Dmar::new",
  "span": "ostd/src/arch/x86/kernel/acpi/dmar.rs:76:5: 76:33",
  "src": "pub fn new() -> Option<Self> {\n        let acpi_table = super::get_acpi_tables()?;\n\n        let dmar_mapping = acpi_table.find_table::<DmarHeader>().ok()?;\n\n        let header = *dmar_mapping;\n        // SAFETY: `find_table` returns a region of memory that belongs to the ACPI table. This\n        // memory region is valid to read, properly initialized, lives for `'static`, and will\n        // never be mutated.\n        let slice = unsafe {\n            core::slice::from_raw_parts(\n                dmar_mapping\n                    .virtual_start()\n                    .as_ptr()\n                    .cast::<u8>()\n                    .cast_const(),\n                dmar_mapping.mapped_length(),\n            )\n        };\n\n        let mut index = size_of::<DmarHeader>();\n        let mut remapping_structures = Vec::new();\n        while index != (header.header.length as usize) {\n            // CommonHeader { type: u16, length: u16 }\n            let typ = u16::from_ne_bytes(slice[index..index + 2].try_into().unwrap());\n            let length =\n                u16::from_ne_bytes(slice[index + 2..index + 4].try_into().unwrap()) as usize;\n\n            let bytes = &slice[index..index + length];\n            let remapping = match typ {\n                0 => Remapping::Drhd(Drhd::from_bytes(bytes)),\n                1 => Remapping::Rmrr(Rmrr::from_bytes(bytes)),\n                2 => Remapping::Atsr(Atsr::from_bytes(bytes)),\n                3 => Remapping::Rhsa(Rhsa::from_bytes(bytes)),\n                4 => Remapping::Andd(Andd::from_bytes(bytes)),\n                5 => Remapping::Satc(Satc::from_bytes(bytes)),\n                6 => Remapping::Sidp(Sidp::from_bytes(bytes)),\n                _ => {\n                    panic!(\n                        \"the type of the remapping structure is invalid or not supported: {}\",\n                        typ\n                    );\n                }\n            };\n            remapping_structures.push(remapping);\n\n            index += length;\n        }\n\n        Some(Dmar {\n            header: *dmar_mapping,\n            remapping_structures,\n        })\n    }"
}