{
  "name": "ostd::mm::page_table::node::entry::Entry::<'a, 'rcu, C>::split_if_mapped_huge",
  "span": "ostd/src/mm/page_table/node/entry.rs:169:5: 172:41",
  "src": "pub(in crate::mm::page_table) fn split_if_mapped_huge(\n        &mut self,\n        guard: &'rcu dyn InAtomicMode,\n    ) -> Option<PageTableGuard<'rcu, C>> {\n        let level = self.node.level();\n\n        if !(self.pte.is_last(level) && level > 1) {\n            return None;\n        }\n\n        let pa = self.pte.paddr();\n        let prop = self.pte.prop();\n\n        let new_page = RcuDrop::new(PageTableNode::<C>::alloc(level - 1));\n\n        let paddr = new_page.paddr();\n        // SAFETY: The page table won't be dropped before the RCU grace period\n        // ends, so it outlives `'rcu`.\n        let pt_ref = unsafe { PageTableNodeRef::borrow_paddr(paddr) };\n\n        // Lock before writing the PTE, so no one else can operate on it.\n        let mut pt_lock_guard = pt_ref.lock(guard);\n\n        for i in 0..nr_subpage_per_huge::<C>() {\n            let small_pa = pa + i * page_size::<C>(level - 1);\n            let mut entry = pt_lock_guard.entry(i);\n            let old = entry.replace(Child::Frame(small_pa, level - 1, prop));\n            debug_assert!(old.is_none());\n        }\n\n        self.pte = Child::PageTable(new_page).into_pte();\n\n        // SAFETY:\n        //  1. The index is within the bounds.\n        //  2. The new PTE is a child in `C` and at the correct paging level.\n        //  3. The ownership of the child is passed to the page table node.\n        unsafe { self.node.write_pte(self.idx, self.pte) };\n\n        Some(pt_lock_guard)\n    }"
}