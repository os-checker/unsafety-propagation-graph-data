{
  "name": "ostd::arch::boot::multiboot2::parse_memory_regions",
  "span": "ostd/src/arch/x86/boot/multiboot2/mod.rs:88:1: 88:73",
  "src": "fn parse_memory_regions(mb2_info: &BootInformation) -> MemoryRegionArray {\n    let mut regions = MemoryRegionArray::new();\n\n    // Add the regions returned by Grub.\n    let memory_regions_tag = mb2_info\n        .memory_map_tag()\n        .expect(\"No memory regions are found in the Multiboot2 header!\");\n    for region in memory_regions_tag.memory_areas() {\n        let start = region.start_address();\n        let end = region.end_address();\n        let area_typ: MemoryRegionType = MemoryAreaType::from(region.typ()).into();\n        let region = MemoryRegion::new(\n            start.try_into().unwrap(),\n            (end - start).try_into().unwrap(),\n            area_typ,\n        );\n        regions.push(region).unwrap();\n    }\n\n    // Add the framebuffer region since Grub does not specify it.\n    if let Some(fb) = parse_framebuffer_info(mb2_info) {\n        regions.push(MemoryRegion::framebuffer(&fb)).unwrap();\n    }\n\n    // Add the kernel region since Grub does not specify it.\n    regions.push(MemoryRegion::kernel()).unwrap();\n\n    // Add the initramfs region.\n    if let Some(initramfs) = parse_initramfs(mb2_info) {\n        regions.push(MemoryRegion::module(initramfs)).unwrap();\n    }\n\n    // Add the AP boot code region that will be copied into by the BSP.\n    regions\n        .push(super::smp::reclaimable_memory_region())\n        .unwrap();\n\n    // Add the kernel cmdline and boot loader name region since Grub does not specify it.\n    if let Some(kcmdline) = parse_kernel_commandline(mb2_info) {\n        regions\n            .push(MemoryRegion::module(kcmdline.as_bytes()))\n            .unwrap();\n    }\n    if let Some(bootloader_name) = parse_bootloader_name(mb2_info) {\n        regions\n            .push(MemoryRegion::module(bootloader_name.as_bytes()))\n            .unwrap();\n    }\n\n    regions.into_non_overlapping()\n}"
}