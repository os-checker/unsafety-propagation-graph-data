{
  "name": "ostd::<arch::mm::PageTableEntry as mm::page_table::PageTableEntryTrait>::prop",
  "span": "ostd/src/arch/x86/mm/mod.rs:226:5: 226:35",
  "src": "fn prop(&self) -> PageProperty {\n        let flags = (parse_flags!(self.0, PageTableFlags::PRESENT, PageFlags::R))\n            | (parse_flags!(self.0, PageTableFlags::WRITABLE, PageFlags::W))\n            | (parse_flags!(!self.0, PageTableFlags::NO_EXECUTE, PageFlags::X))\n            | (parse_flags!(self.0, PageTableFlags::ACCESSED, PageFlags::ACCESSED))\n            | (parse_flags!(self.0, PageTableFlags::DIRTY, PageFlags::DIRTY))\n            | (parse_flags!(self.0, PageTableFlags::HIGH_IGN2, PageFlags::AVAIL2));\n        let priv_flags = (parse_flags!(self.0, PageTableFlags::USER, PrivFlags::USER))\n            | (parse_flags!(self.0, PageTableFlags::GLOBAL, PrivFlags::GLOBAL))\n            | (parse_flags!(self.0, PageTableFlags::HIGH_IGN1, PrivFlags::AVAIL1));\n        #[cfg(feature = \"cvm_guest\")]\n        let priv_flags =\n            priv_flags | (parse_flags!(self.0, PageTableFlags::SHARED, PrivFlags::SHARED));\n        // Determine cache policy from PCD, PWT bits.\n        let cache = flags_to_cache_policy(PageTableFlags::from_bits_truncate(self.0));\n        PageProperty {\n            flags: PageFlags::from_bits(flags as u8).unwrap(),\n            cache,\n            priv_flags: PrivFlags::from_bits(priv_flags as u8).unwrap(),\n        }\n    }"
}