{
  "name": "ostd::task::scheduler::park_current",
  "span": "ostd/src/task/scheduler/mod.rs:416:1: 418:21",
  "src": "pub(crate) fn park_current<F>(has_unparked: F)\nwhere\n    F: Fn() -> bool,\n{\n    let mut current = None;\n    let mut is_first_try = true;\n\n    reschedule(|local_rq: &mut dyn LocalRunQueue| {\n        let next_task_opt = if is_first_try {\n            if has_unparked() {\n                return ReschedAction::DoNothing;\n            }\n            is_first_try = false;\n\n            // Note the race conditions: the current task may be woken after the above `has_unparked`\n            // check, but before the below `dequeue_current` action, we need to make sure that the\n            // wakeup event isn't lost.\n            //\n            // Currently, for the FIFO and CFS scheduler, `Scheduler::enqueue` will try to lock `local_rq`\n            // when the above race condition occurs, so it will wait until we finish calling the\n            // `dequeue_current` method and nothing bad will happen. This may need to be revisited\n            // after more complex schedulers are introduced.\n\n            let should_pick_next = local_rq.update_current(UpdateFlags::Wait);\n            current = local_rq.dequeue_current();\n            should_pick_next.then(|| local_rq.pick_next())\n        } else {\n            local_rq.try_pick_next()\n        };\n\n        if let Some(next_task) = next_task_opt {\n            if Arc::ptr_eq(current.as_ref().unwrap(), next_task) {\n                // The current task has been woken and picked as the next runnable task.\n                return ReschedAction::DoNothing;\n            }\n            return ReschedAction::SwitchTo(next_task.clone());\n        }\n\n        ReschedAction::Retry\n    });\n}"
}