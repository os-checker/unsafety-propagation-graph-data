{
  "name": "ostd::arch::trap::trap_handler",
  "span": "ostd/src/arch/x86/trap/mod.rs:136:1: 136:58",
  "src": "unsafe extern \"sysv64\" fn trap_handler(f: &mut TrapFrame) {\n    fn enable_local_if(cond: bool) {\n        if cond {\n            enable_local();\n        }\n    }\n\n    fn disable_local_if(cond: bool) {\n        if cond {\n            disable_local();\n        }\n    }\n\n    // The IRQ state before trapping. We need to ensure that the IRQ state\n    // during exception handling is consistent with the state before the trap.\n    let was_irq_enabled =\n        f.rflags as u64 & x86_64::registers::rflags::RFlags::INTERRUPT_FLAG.bits() > 0;\n\n    let cpu_exception = CpuException::new(f.trap_num, f.error_code);\n    match cpu_exception {\n        #[cfg(feature = \"cvm_guest\")]\n        Some(CpuException::VirtualizationException) => {\n            let ve_info = tdcall::get_veinfo().expect(\"#VE handler: fail to get VE info\\n\");\n            // We need to enable interrupts only after `tdcall::get_veinfo` is called\n            // to avoid nested `#VE`s.\n            enable_local_if(was_irq_enabled);\n            let mut trapframe_wrapper = TrapFrameWrapper(&mut *f);\n            handle_virtual_exception(&mut trapframe_wrapper, &ve_info);\n            *f = *trapframe_wrapper.0;\n            disable_local_if(was_irq_enabled);\n        }\n        Some(CpuException::PageFault(raw_page_fault_info)) => {\n            enable_local_if(was_irq_enabled);\n            // The actual user space implementation should be responsible\n            // for providing mechanism to treat the 0 virtual address.\n            if (0..MAX_USERSPACE_VADDR).contains(&raw_page_fault_info.addr) {\n                handle_user_page_fault(f, cpu_exception.as_ref().unwrap());\n            } else {\n                panic!(\n                    \"Cannot handle kernel page fault: {:#x?}; trapframe: {:#x?}\",\n                    raw_page_fault_info, f\n                );\n            }\n            disable_local_if(was_irq_enabled);\n        }\n        Some(exception) => {\n            enable_local_if(was_irq_enabled);\n            panic!(\n                \"Cannot handle kernel CPU exception: {:#x?}; trapframe: {:#x?}\",\n                exception, f\n            );\n        }\n        None => {\n            call_irq_callback_functions(\n                f,\n                &HwIrqLine::new(f.trap_num as u8),\n                PrivilegeLevel::Kernel,\n            );\n        }\n    }\n}"
}