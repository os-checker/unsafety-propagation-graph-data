{
  "name": "ostd::<arch::cpu::context::UserContext as user::UserContextApiInternal>::execute",
  "span": "ostd/src/arch/x86/cpu/context/mod.rs:264:5: 266:28",
  "src": "fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason\n    where\n        F: FnMut() -> bool,\n    {\n        // set interrupt flag so that in user mode it can receive external interrupts\n        // set ID flag which means cpu support CPUID instruction\n        self.user_context.general.rflags |= (RFlags::INTERRUPT_FLAG | RFlags::ID).bits() as usize;\n\n        const SYSCALL_TRAPNUM: usize = 0x100;\n\n        // Return when it is syscall or cpu exception type is Fault or Trap.\n        loop {\n            crate::task::scheduler::might_preempt();\n            self.user_context.run();\n\n            let exception =\n                CpuException::new(self.user_context.trap_num, self.user_context.error_code);\n            match exception {\n                #[cfg(feature = \"cvm_guest\")]\n                Some(CpuException::VirtualizationException) => {\n                    let ve_handler = VirtualizationExceptionHandler::new();\n                    // Check out the doc of `VirtualizationExceptionHandler::new` to\n                    // see why IRQs must enabled _after_ instantiating a `VirtualizationExceptionHandler`.\n                    crate::arch::irq::enable_local();\n                    ve_handler.handle(self);\n                }\n                Some(exception) if exception.type_().is_fault_or_trap() => {\n                    crate::arch::irq::enable_local();\n                    self.exception = Some(exception);\n                    return ReturnReason::UserException;\n                }\n                Some(exception) => {\n                    panic!(\n                        \"cannot handle user CPU exception: {:?}, trapframe: {:?}\",\n                        exception,\n                        self.as_trap_frame()\n                    );\n                }\n                None if self.user_context.trap_num == SYSCALL_TRAPNUM => {\n                    crate::arch::irq::enable_local();\n                    return ReturnReason::UserSyscall;\n                }\n                None => {\n                    call_irq_callback_functions(\n                        &self.as_trap_frame(),\n                        &HwIrqLine::new(self.as_trap_frame().trap_num as u8),\n                        PrivilegeLevel::User,\n                    );\n                    crate::arch::irq::enable_local();\n                }\n            }\n\n            if has_kernel_event() {\n                break ReturnReason::KernelEvent;\n            }\n        }\n    }"
}