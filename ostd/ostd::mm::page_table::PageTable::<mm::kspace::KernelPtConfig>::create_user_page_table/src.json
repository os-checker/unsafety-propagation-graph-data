{
  "name": "ostd::mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::create_user_page_table",
  "span": "ostd/src/mm/page_table/mod.rs:318:5: 318:90",
  "src": "pub(in crate::mm) fn create_user_page_table(&'static self) -> PageTable<UserPtConfig> {\n        let new_root = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n\n        let preempt_guard = disable_preempt();\n        let mut root_node = self.root.borrow().lock(&preempt_guard);\n        let mut new_node = new_root.borrow().lock(&preempt_guard);\n\n        const {\n            assert!(!KernelPtConfig::TOP_LEVEL_CAN_UNMAP);\n            assert!(\n                UserPtConfig::TOP_LEVEL_INDEX_RANGE.end\n                    <= KernelPtConfig::TOP_LEVEL_INDEX_RANGE.start\n            );\n        }\n\n        for i in KernelPtConfig::TOP_LEVEL_INDEX_RANGE {\n            let root_entry = root_node.entry(i);\n            let child = root_entry.to_ref();\n            let ChildRef::PageTable(pt) = child else {\n                panic!(\"The kernel page table doesn't contain shared nodes\");\n            };\n\n            // We do not add additional reference count specifically for the\n            // shared kernel page tables. It requires user page tables to\n            // outlive the kernel page table, which is trivially true.\n            // See also `<PageTablePageMeta as AnyFrameMeta>::on_drop`.\n            let pt_addr = pt.paddr();\n            let pte = PageTableEntry::new_pt(pt_addr);\n            // SAFETY: The index is within the bounds and the PTE is at the\n            // correct paging level. However, neither it's a `UserPtConfig`\n            // child nor the node has the ownership of the child. It is\n            // still safe because `UserPtConfig::TOP_LEVEL_INDEX_RANGE`\n            // guarantees that the cursor won't access it.\n            unsafe { new_node.write_pte(i, pte) };\n        }\n        drop(new_node);\n\n        PageTable::<UserPtConfig> { root: new_root }\n    }"
}