{
  "name": "ostd::arch::kernel::tsc::determine_tsc_freq_via_pit",
  "span": "ostd/src/arch/x86/kernel/tsc.rs:31:1: 31:43",
  "src": "pub fn determine_tsc_freq_via_pit() -> u64 {\n    // Allocate IRQ\n    let mut irq = IrqLine::alloc().unwrap();\n    irq.on_active(pit_callback);\n\n    // Enable PIT\n    pit::init(OperatingMode::RateGenerator);\n    let irq = pit::enable_interrupt(irq);\n\n    static IS_FINISH: AtomicBool = AtomicBool::new(false);\n    static FREQUENCY: AtomicU64 = AtomicU64::new(0);\n\n    // Wait until `FREQUENCY` is ready\n    loop {\n        crate::arch::irq::enable_local_and_halt();\n\n        // Disable local IRQs so they won't come after checking `IS_FINISH`\n        // but before halting the CPU.\n        crate::arch::irq::disable_local();\n\n        if IS_FINISH.load(Ordering::Acquire) {\n            break;\n        }\n    }\n\n    // Disable PIT\n    drop(irq);\n\n    return FREQUENCY.load(Ordering::Acquire);\n\n    fn pit_callback(_trap_frame: &TrapFrame) {\n        static IN_TIME: AtomicU64 = AtomicU64::new(0);\n        static TSC_FIRST_COUNT: AtomicU64 = AtomicU64::new(0);\n        // Set a certain times of callbacks to calculate the frequency\n        const CALLBACK_TIMES: u64 = TIMER_FREQ / 10;\n\n        let tsc_current_count = crate::arch::read_tsc();\n\n        if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || IS_FINISH.load(Ordering::Acquire) {\n            if IN_TIME.load(Ordering::Relaxed) == 0 {\n                TSC_FIRST_COUNT.store(tsc_current_count, Ordering::Relaxed);\n            }\n            IN_TIME.fetch_add(1, Ordering::Relaxed);\n            return;\n        }\n\n        let tsc_first_count = TSC_FIRST_COUNT.load(Ordering::Relaxed);\n        let freq = (tsc_current_count - tsc_first_count) * (TIMER_FREQ / CALLBACK_TIMES);\n        FREQUENCY.store(freq, Ordering::Release);\n        IS_FINISH.store(true, Ordering::Release);\n    }\n}"
}