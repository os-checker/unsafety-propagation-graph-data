{
  "name": "ostd::mm::page_table::cursor::CursorMut::<'rcu, C>::map",
  "span": "ostd/src/mm/page_table/cursor/mod.rs:459:5: 459:80",
  "src": "pub unsafe fn map(&mut self, item: C::Item) -> Result<(), PageTableFrag<C>> {\n        assert!(self.0.va < self.0.barrier_va.end);\n        let (pa, level, prop) = C::item_into_raw(item);\n        assert!(level <= C::HIGHEST_TRANSLATION_LEVEL);\n        let size = page_size::<C>(level);\n        assert_eq!(self.0.va % size, 0);\n        let end = self.0.va + size;\n        assert!(end <= self.0.barrier_va.end);\n\n        let rcu_guard = self.0.rcu_guard;\n\n        // Adjust ourselves to the level of the item.\n        while self.0.level != level {\n            if self.0.level < level {\n                self.0.pop_level();\n                continue;\n            }\n            // We are at a higher level, go down.\n            let mut cur_entry = self.0.cur_entry();\n            match cur_entry.to_ref() {\n                ChildRef::PageTable(pt) => {\n                    // SAFETY: The `pt` must be locked and no other guards exist.\n                    let pt_guard = unsafe { pt.make_guard_unchecked(rcu_guard) };\n                    self.0.push_level(pt_guard);\n                }\n                ChildRef::None => {\n                    let child_guard = cur_entry.alloc_if_none(rcu_guard).unwrap();\n                    self.0.push_level(child_guard);\n                }\n                ChildRef::Frame(_, _, _) => {\n                    let split_child = cur_entry.split_if_mapped_huge(rcu_guard).unwrap();\n                    self.0.push_level(split_child);\n                }\n            }\n        }\n\n        let frag = self.replace_cur_entry(Child::Frame(pa, level, prop));\n\n        self.0.move_forward();\n\n        if let Some(frag) = frag {\n            Err(frag)\n        } else {\n            Ok(())\n        }\n    }"
}