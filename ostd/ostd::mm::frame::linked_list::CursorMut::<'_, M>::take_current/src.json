{
  "name": "ostd::mm::frame::linked_list::CursorMut::<'_, M>::take_current",
  "span": "ostd/src/mm/frame/linked_list.rs:283:5: 283:67",
  "src": "pub fn take_current(&mut self) -> Option<UniqueFrame<Link<M>>> {\n        let current = self.current?;\n\n        let mut frame = {\n            let meta_ptr = current.as_ptr() as *mut MetaSlot;\n            let paddr = mapping::meta_to_frame::<PagingConsts>(meta_ptr as Vaddr);\n            // SAFETY: The frame was forgotten when inserted into the linked list.\n            unsafe { UniqueFrame::<Link<M>>::from_raw(paddr) }\n        };\n\n        let next_ptr = frame.meta().next;\n        if let Some(prev) = &mut frame.meta_mut().prev {\n            // SAFETY: We own the previous node by `&mut self` and the node is\n            // initialized.\n            let prev_mut = unsafe { prev.as_mut() };\n\n            debug_assert_eq!(prev_mut.next, Some(current));\n            prev_mut.next = next_ptr;\n        } else {\n            self.list.front = next_ptr;\n        }\n        let prev_ptr = frame.meta().prev;\n        if let Some(next) = &mut frame.meta_mut().next {\n            // SAFETY: We own the next node by `&mut self` and the node is\n            // initialized.\n            let next_mut = unsafe { next.as_mut() };\n\n            debug_assert_eq!(next_mut.prev, Some(current));\n            next_mut.prev = prev_ptr;\n            self.current = Some(NonNull::from(next_mut));\n        } else {\n            self.list.back = prev_ptr;\n            self.current = None;\n        }\n\n        frame.meta_mut().next = None;\n        frame.meta_mut().prev = None;\n\n        frame.slot().in_list.store(0, Ordering::Relaxed);\n\n        self.list.size -= 1;\n\n        Some(frame)\n    }"
}