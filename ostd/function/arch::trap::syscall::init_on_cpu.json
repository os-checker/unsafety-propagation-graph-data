{
  "name": "arch::trap::syscall::init_on_cpu",
  "safe": false,
  "callees": {
    "arch::trap::syscall::syscall_entry": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "x86_64::VirtAddr::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new canonical virtual address.\n\n This function performs sign extension of bit 47 to make the address canonical.\n\n ## Panics\n\n This function panics if the bits in the range 48 to 64 contain data (i.e. are not null and no sign extension).\n",
      "adt": {}
    },
    "x86_64::registers::model_specific::x86_64::<impl x86_64::registers::model_specific::LStar>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Write a given virtual address to the LStar register.\n This holds the target RIP of a syscall.\n",
      "adt": {}
    },
    "x86_64::registers::rflags::_::<impl x86_64::registers::rflags::RFlags>::from_bits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert from a bits value.\n\n This method will return `None` if any unknown bits are set.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "x86_64::registers::model_specific::x86_64::<impl x86_64::registers::model_specific::SFMask>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Write to the SFMask register.\n The SFMASK register is used to specify which RFLAGS bits\n are cleared during a SYSCALL. In long mode, SFMASK is used\n to specify which RFLAGS bits are cleared when SYSCALL is\n executed. If a bit in SFMASK is set to 1, the corresponding\n bit in RFLAGS is cleared to 0. If a bit in SFMASK is cleared\n to 0, the corresponding rFLAGS bit is not modified.\n",
      "adt": {}
    },
    "x86_64::registers::model_specific::x86_64::<impl x86_64::registers::control::Efer>::update": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Update EFER flags.\n\n Preserves the value of reserved fields.\n\n ## Safety\n\n Unsafe because it's possible to break memory\n safety with wrong flags, e.g. by disabling long mode.\n",
      "adt": {}
    }
  },
  "adts": {
    "x86_64::VirtAddr": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "x86_64::registers::rflags::RFlags": [
      "Plain"
    ]
  },
  "path": 1537,
  "span": "ostd/src/arch/x86/trap/syscall.rs:44:1: 66:2",
  "src": "pub(super) unsafe fn init_on_cpu() {\n    // We now assume that all x86-64 CPUs should support the `syscall` and `sysret` instructions.\n    // Otherwise, we should check `has_extensions(IsaExtensions::SYSCALL)` here.\n\n    // Flags to clear on syscall.\n    //\n    // Linux 5.0 uses TF|DF|IF|IOPL|AC|NT. Reference:\n    // <https://github.com/torvalds/linux/blob/v5.0/arch/x86/kernel/cpu/common.c#L1559-L1562>\n    const RFLAGS_MASK: u64 = 0x47700;\n\n    // SAFETY: The segment selectors are correctly initialized (as upheld by the caller), and the\n    // entry point and flags to clear are also correctly set, so enabling the `syscall` and\n    // `sysret` instructions is safe.\n    unsafe {\n        LStar::write(VirtAddr::new(syscall_entry as *const () as usize as u64));\n        SFMask::write(RFlags::from_bits(RFLAGS_MASK).unwrap());\n\n        // Enable the `syscall` and `sysret` instructions.\n        Efer::update(|efer| {\n            efer.insert(EferFlags::SYSTEM_CALL_EXTENSIONS);\n        });\n    }\n}",
  "mir": "fn arch::trap::syscall::init_on_cpu() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let mut _2: x86_64::VirtAddr;\n    let mut _3: u64;\n    let mut _4: usize;\n    let mut _5: *const ();\n    let mut _6: unsafe extern \"C\" fn();\n    let  _7: ();\n    let mut _8: x86_64::registers::rflags::RFlags;\n    let mut _9: core::option::Option<x86_64::registers::rflags::RFlags>;\n    let  _10: ();\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = arch::trap::syscall::syscall_entry as unsafe extern \"C\" fn();\n        _5 = move _6 as *const ();\n        StorageDead(_6);\n        _4 = move _5 as usize;\n        StorageDead(_5);\n        _3 = move _4 as u64;\n        StorageDead(_4);\n        _2 = x86_64::VirtAddr::new(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _1 = x86_64::registers::model_specific::x86_64::<impl x86_64::registers::model_specific::LStar>::write(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = x86_64::registers::rflags::_::<impl x86_64::registers::rflags::RFlags>::from_bits(arch::trap::syscall::init_on_cpu::RFLAGS_MASK) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = core::option::Option::<x86_64::registers::rflags::RFlags>::unwrap(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _7 = x86_64::registers::model_specific::x86_64::<impl x86_64::registers::model_specific::SFMask>::write(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _10 = x86_64::registers::model_specific::x86_64::<impl x86_64::registers::control::Efer>::update::<{closure@ostd/src/arch/x86/trap/syscall.rs:62:22: 62:28}>(ZeroSized: {closure@ostd/src/arch/x86/trap/syscall.rs:62:22: 62:28}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n The caller needs to ensure that `gdt::init_on_cpu` has been called before,\n so the segment selectors used in the `syscall` and `sysret` instructions\n have been properly initialized.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}