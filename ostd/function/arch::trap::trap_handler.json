{
  "name": "arch::trap::trap_handler",
  "safe": false,
  "callees": {
    "x86_64::registers::rflags::_::<impl x86_64::registers::rflags::RFlags>::bits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Get the underlying bits value.\n\n The returned value is exactly the bits set in this flags value.\n",
      "adt": {}
    },
    "arch::cpu::context::CpuException::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "arch::cpu::context::CpuException": "Constructor"
      }
    },
    "arch::irq::HwIrqLine::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::irq::HwIrqLine": "Constructor"
      }
    },
    "arch::trap::trap_handler::enable_local_if": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "tdx_guest::get_veinfo": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Get Virtualization Exception Information for the recent #VE exception.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "tdx_guest::handle_virtual_exception": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::trap::trap_handler::disable_local_if": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::Range::<Idx>::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `item` is contained in the range.\n\n # Examples\n\n ```\n assert!(!(3..5).contains(&2));\n assert!( (3..5).contains(&3));\n assert!( (3..5).contains(&4));\n assert!(!(3..5).contains(&5));\n\n assert!(!(3..3).contains(&3));\n assert!(!(3..2).contains(&3));\n\n assert!( (0.0..1.0).contains(&0.5));\n assert!(!(0.0..1.0).contains(&f32::NAN));\n assert!(!(0.0..f32::NAN).contains(&0.5));\n assert!(!(f32::NAN..1.0).contains(&0.5));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&Option<T>` to `Option<&T>`.\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n reference to the value inside the original.\n\n [`map`]: Option::map\n [String]: ../../std/string/struct.String.html \"String\"\n [`String`]: ../../std/string/struct.String.html \"String\"\n\n ```\n let text: Option<String> = Some(\"Hello, world!\".to_string());\n // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n // then consume *that* with `map`, leaving `text` on the stack.\n let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n println!(\"still can print text: {text:?}\");\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "arch::trap::handle_user_page_fault": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Handles page fault from user space.\n",
      "adt": {
        "arch::trap::TrapFrame": "MutableAsArgument",
        "arch::cpu::context::CpuException": "ImmutableAsArgument"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "irq::call_irq_callback_functions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::trap::TrapFrame": "ImmutableAsArgument",
        "arch::irq::HwIrqLine": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "arch::trap::TrapFrame": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(21)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(17)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(18)))",
      "Ref",
      "Deref",
      "MutRef",
      "Plain"
    ],
    "x86_64::registers::rflags::RFlags": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 515, kind: RigidTy(Adt(AdtDef(DefId { id: 3107, name: \"arch::cpu::context::CpuException\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 515, kind: RigidTy(Adt(AdtDef(DefId { id: 3107, name: \"arch::cpu::context::CpuException\" }), GenericArgs([]))) }), Downcast(VariantIdx(14, ThreadLocalIndex)), Field(0, Ty { id: 525, kind: RigidTy(Adt(AdtDef(DefId { id: 3109, name: \"arch::cpu::context::RawPageFaultInfo\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "arch::irq::HwIrqLine": [
      "Plain",
      "Ref"
    ],
    "arch::cpu::context::CpuException": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 530, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 515, kind: RigidTy(Adt(AdtDef(DefId { id: 3107, name: \"arch::cpu::context::CpuException\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 2787, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2779, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 591, kind: RigidTy(Adt(AdtDef(DefId { id: 3173, name: \"arch::trap::TrapFrame\" }), GenericArgs([]))) }, Mut)) }, Not)) })])"
    ],
    "arch::cpu::context::RawPageFaultInfo": [
      "Plain",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "tdx_guest::TdgVeInfo": [
      "Plain",
      "Ref"
    ],
    "arch::tdx_guest::TrapFrameWrapper": [
      "Plain",
      "MutRef",
      "Unknown([Field(0, Ty { id: 2779, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 591, kind: RigidTy(Adt(AdtDef(DefId { id: 3173, name: \"arch::trap::TrapFrame\" }), GenericArgs([]))) }, Mut)) })])"
    ],
    "core::ops::Range": [
      "Ref"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "cpu::PrivilegeLevel": [
      "Plain"
    ]
  },
  "path": 1543,
  "span": "ostd/src/arch/x86/trap/mod.rs:136:1: 196:2",
  "src": "unsafe extern \"sysv64\" fn trap_handler(f: &mut TrapFrame) {\n    fn enable_local_if(cond: bool) {\n        if cond {\n            enable_local();\n        }\n    }\n\n    fn disable_local_if(cond: bool) {\n        if cond {\n            disable_local();\n        }\n    }\n\n    // The IRQ state before trapping. We need to ensure that the IRQ state\n    // during exception handling is consistent with the state before the trap.\n    let was_irq_enabled =\n        f.rflags as u64 & x86_64::registers::rflags::RFlags::INTERRUPT_FLAG.bits() > 0;\n\n    let cpu_exception = CpuException::new(f.trap_num, f.error_code);\n    match cpu_exception {\n        #[cfg(feature = \"cvm_guest\")]\n        Some(CpuException::VirtualizationException) => {\n            let ve_info = tdcall::get_veinfo().expect(\"#VE handler: fail to get VE info\\n\");\n            // We need to enable interrupts only after `tdcall::get_veinfo` is called\n            // to avoid nested `#VE`s.\n            enable_local_if(was_irq_enabled);\n            let mut trapframe_wrapper = TrapFrameWrapper(&mut *f);\n            handle_virtual_exception(&mut trapframe_wrapper, &ve_info);\n            *f = *trapframe_wrapper.0;\n            disable_local_if(was_irq_enabled);\n        }\n        Some(CpuException::PageFault(raw_page_fault_info)) => {\n            enable_local_if(was_irq_enabled);\n            // The actual user space implementation should be responsible\n            // for providing mechanism to treat the 0 virtual address.\n            if (0..MAX_USERSPACE_VADDR).contains(&raw_page_fault_info.addr) {\n                handle_user_page_fault(f, cpu_exception.as_ref().unwrap());\n            } else {\n                panic!(\n                    \"Cannot handle kernel page fault: {:#x?}; trapframe: {:#x?}\",\n                    raw_page_fault_info, f\n                );\n            }\n            disable_local_if(was_irq_enabled);\n        }\n        Some(exception) => {\n            enable_local_if(was_irq_enabled);\n            panic!(\n                \"Cannot handle kernel CPU exception: {:#x?}; trapframe: {:#x?}\",\n                exception, f\n            );\n        }\n        None => {\n            call_irq_callback_functions(\n                f,\n                &HwIrqLine::new(f.trap_num as u8),\n                PrivilegeLevel::Kernel,\n            );\n        }\n    }\n}",
  "mir": "fn arch::trap::trap_handler(_1: &mut arch::trap::TrapFrame) -> () {\n    let mut _0: ();\n    let  _2: bool;\n    let mut _3: u64;\n    let mut _4: u64;\n    let mut _5: usize;\n    let mut _6: u64;\n    let mut _7: &x86_64::registers::rflags::RFlags;\n    let  _8: core::option::Option<arch::cpu::context::CpuException>;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: isize;\n    let mut _12: isize;\n    let  _13: tdx_guest::TdgVeInfo;\n    let mut _14: core::result::Result<tdx_guest::TdgVeInfo, tdx_guest::tdcall::TdCallError>;\n    let mut _15: &str;\n    let  _16: ();\n    let mut _17: arch::tdx_guest::TrapFrameWrapper<'_>;\n    let  _18: ();\n    let mut _19: &mut dyn tdx_guest::TdxTrapFrame;\n    let mut _20: &mut arch::tdx_guest::TrapFrameWrapper<'_>;\n    let  _21: &tdx_guest::TdgVeInfo;\n    let mut _22: arch::trap::TrapFrame;\n    let  _23: ();\n    let  _24: arch::cpu::context::RawPageFaultInfo;\n    let  _25: ();\n    let mut _26: bool;\n    let mut _27: &core::ops::Range<usize>;\n    let  _28: &usize;\n    let  _29: ();\n    let  _30: &arch::cpu::context::CpuException;\n    let mut _31: core::option::Option<&arch::cpu::context::CpuException>;\n    let mut _32: &core::option::Option<arch::cpu::context::CpuException>;\n    let  _33: !;\n    let mut _34: core::fmt::Arguments<'_>;\n    let  _35: (&arch::cpu::context::RawPageFaultInfo, &&mut arch::trap::TrapFrame);\n    let mut _36: &arch::cpu::context::RawPageFaultInfo;\n    let mut _37: &&mut arch::trap::TrapFrame;\n    let  _38: [core::fmt::rt::Argument<'_>; 2];\n    let mut _39: core::fmt::rt::Argument<'_>;\n    let mut _40: core::fmt::rt::Argument<'_>;\n    let mut _41: &[u8; 59];\n    let  _42: &[core::fmt::rt::Argument<'_>; 2];\n    let  _43: ();\n    let  _44: arch::cpu::context::CpuException;\n    let  _45: ();\n    let  _46: !;\n    let mut _47: core::fmt::Arguments<'_>;\n    let  _48: (&arch::cpu::context::CpuException, &&mut arch::trap::TrapFrame);\n    let mut _49: &arch::cpu::context::CpuException;\n    let mut _50: &&mut arch::trap::TrapFrame;\n    let  _51: [core::fmt::rt::Argument<'_>; 2];\n    let mut _52: core::fmt::rt::Argument<'_>;\n    let mut _53: core::fmt::rt::Argument<'_>;\n    let mut _54: &[u8; 62];\n    let  _55: &[core::fmt::rt::Argument<'_>; 2];\n    let  _56: ();\n    let mut _57: &arch::trap::TrapFrame;\n    let  _58: &arch::irq::HwIrqLine;\n    let  _59: arch::irq::HwIrqLine;\n    let mut _60: u8;\n    let mut _61: usize;\n    let mut _62: cpu::PrivilegeLevel;\n    let mut _63: &mut arch::trap::TrapFrame;\n    let mut _64: &arch::cpu::context::RawPageFaultInfo;\n    let mut _65: &&mut arch::trap::TrapFrame;\n    let mut _66: &arch::cpu::context::CpuException;\n    let mut _67: &&mut arch::trap::TrapFrame;\n    debug f => _1;\n    debug was_irq_enabled => _2;\n    debug cpu_exception => _8;\n    debug ve_info => _13;\n    debug trapframe_wrapper => _17;\n    debug raw_page_fault_info => _24;\n    debug args => _35;\n    debug args => _38;\n    debug exception => _44;\n    debug args => _48;\n    debug args => _51;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).21: usize);\n        _4 = move _5 as u64;\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = arch::trap::trap_handler::promoted[1];\n        _6 = x86_64::registers::rflags::_::<impl x86_64::registers::rflags::RFlags>::bits(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _3 = BitAnd(move _4, move _6);\n        StorageDead(_6);\n        StorageDead(_4);\n        _2 = Gt(move _3, 0_u64);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = ((*_1).17: usize);\n        StorageLive(_10);\n        _10 = ((*_1).18: usize);\n        _8 = arch::cpu::context::CpuException::new(move _9, move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageDead(_9);\n        _12 = discriminant(_8);\n        switchInt(move _12) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _11 = discriminant(((_8 as variant#1).0: arch::cpu::context::CpuException));\n        switchInt(move _11) -> [14: bb7, 19: bb8, otherwise: bb6];\n    }\n    bb5: {\n        StorageLive(_57);\n        _57 = &(*_1);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = ((*_1).17: usize);\n        _60 = move _61 as u8;\n        StorageDead(_61);\n        _59 = arch::irq::HwIrqLine::new(move _60) -> [return: bb29, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_44);\n        _44 = ((_8 as variant#1).0: arch::cpu::context::CpuException);\n        _45 = arch::trap::trap_handler::enable_local_if(_2) -> [return: bb25, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_24);\n        _24 = ((((_8 as variant#1).0: arch::cpu::context::CpuException) as variant#14).0: arch::cpu::context::RawPageFaultInfo);\n        _25 = arch::trap::trap_handler::enable_local_if(_2) -> [return: bb14, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = tdx_guest::get_veinfo() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_15);\n        _15 = \"#VE handler: fail to get VE info\\n\";\n        _13 = core::result::Result::<tdx_guest::TdgVeInfo, tdx_guest::tdcall::TdCallError>::expect(move _14, move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _16 = arch::trap::trap_handler::enable_local_if(_2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_17);\n        _17 = TrapFrameWrapper(_1);\n        StorageLive(_19);\n        _20 = &mut _17;\n        _19 = _20 as &mut dyn tdx_guest::TdxTrapFrame;\n        _21 = &_13;\n        _18 = tdx_guest::handle_virtual_exception(move _19, _21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageLive(_22);\n        _63 = (_17.0: &mut arch::trap::TrapFrame);\n        _22 = (*_63);\n        (*_1) = move _22;\n        StorageDead(_22);\n        _23 = arch::trap::trap_handler::disable_local_if(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        StorageDead(_13);\n        goto -> bb31;\n    }\n    bb14: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = arch::trap::trap_handler::promoted[0];\n        _28 = &(_24.1: usize);\n        _26 = core::ops::Range::<usize>::contains::<usize>(move _27, _28) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _26) -> [0: bb20, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_27);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &_8;\n        _31 = core::option::Option::<arch::cpu::context::CpuException>::as_ref(move _32) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_32);\n        _30 = core::option::Option::<&arch::cpu::context::CpuException>::unwrap(move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        _29 = arch::trap::handle_user_page_fault(_1, _30) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_26);\n        _43 = arch::trap::trap_handler::disable_local_if(_2) -> [return: bb24, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_27);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &_24;\n        StorageLive(_37);\n        _37 = &_1;\n        _35 = (move _36, move _37);\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _64 = (_35.0: &arch::cpu::context::RawPageFaultInfo);\n        _39 = core::fmt::rt::Argument::<'_>::new_debug::<arch::cpu::context::RawPageFaultInfo>(_64) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_40);\n        _65 = (_35.1: &&mut arch::trap::TrapFrame);\n        _40 = core::fmt::rt::Argument::<'_>::new_debug::<&mut arch::trap::TrapFrame>(_65) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _38 = [move _39, move _40];\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_41);\n        _41 = b\"!Cannot handle kernel page fault: \\xc1 \\x00\\x80b\\r; trapframe: \\xc1 \\x00\\x80b\\x00\";\n        _42 = &_38;\n        _34 = core::fmt::Arguments::<'_>::new::<59, 2>(move _41, _42) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_41);\n        _33 = core::panicking::panic_fmt(move _34) -> unwind unreachable;\n    }\n    bb24: {\n        StorageDead(_24);\n        goto -> bb31;\n    }\n    bb25: {\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &_44;\n        StorageLive(_50);\n        _50 = &_1;\n        _48 = (move _49, move _50);\n        StorageDead(_50);\n        StorageDead(_49);\n        StorageLive(_51);\n        StorageLive(_52);\n        _66 = (_48.0: &arch::cpu::context::CpuException);\n        _52 = core::fmt::rt::Argument::<'_>::new_debug::<arch::cpu::context::CpuException>(_66) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_53);\n        _67 = (_48.1: &&mut arch::trap::TrapFrame);\n        _53 = core::fmt::rt::Argument::<'_>::new_debug::<&mut arch::trap::TrapFrame>(_67) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _51 = [move _52, move _53];\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageLive(_54);\n        _54 = b\"$Cannot handle kernel CPU exception: \\xc1 \\x00\\x80b\\r; trapframe: \\xc1 \\x00\\x80b\\x00\";\n        _55 = &_51;\n        _47 = core::fmt::Arguments::<'_>::new::<62, 2>(move _54, _55) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_54);\n        _46 = core::panicking::panic_fmt(move _47) -> unwind unreachable;\n    }\n    bb29: {\n        StorageDead(_60);\n        _58 = &_59;\n        StorageLive(_62);\n        _62 = cpu::PrivilegeLevel::Kernel;\n        _56 = irq::call_irq_callback_functions(move _57, _58, move _62) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_62);\n        StorageDead(_57);\n        StorageDead(_59);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Handle traps (only from kernel).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}