{
  "name": "arch::kernel::tsc::determine_tsc_freq_via_pit",
  "safe": true,
  "callees": {
    "irq::top_half::IrqLine::alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates an available IRQ line.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "irq::top_half::IrqLine": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "irq::top_half::IrqLine::on_active": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Registers a callback that will be invoked when the IRQ is active.\n\n For each IRQ line, multiple callbacks may be registered.\n",
      "adt": {
        "irq::top_half::IrqLine": "MutableAsArgument"
      }
    },
    "arch::kernel::tsc::determine_tsc_freq_via_pit::pit_callback": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::timer::pit::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::timer::pit::enable_interrupt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables the interrupt line that is connected to the PIT.\n",
      "adt": {
        "arch::irq::chip::MappedIrqLine": "Constructor"
      }
    },
    "arch::irq::ops::enable_local_and_halt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables local IRQs and halts the CPU to wait for interrupts.\n\n This method guarantees that no interrupts can occur in the middle. In other words, IRQs must\n either have been processed before this method is called, or they must wake the CPU up from the\n halting state.\n",
      "adt": {}
    },
    "arch::irq::ops::disable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the bool.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n assert_eq!(some_bool.load(Ordering::Relaxed), true);\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU64::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "irq::top_half::IrqLine": [
      "Plain",
      "MutRef"
    ],
    "arch::timer::pit::OperatingMode": [
      "Plain"
    ],
    "arch::irq::chip::MappedIrqLine": [
      "Plain"
    ],
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ]
  },
  "path": 1306,
  "span": "ostd/src/arch/x86/kernel/tsc.rs:31:1: 82:2",
  "src": "pub fn determine_tsc_freq_via_pit() -> u64 {\n    // Allocate IRQ\n    let mut irq = IrqLine::alloc().unwrap();\n    irq.on_active(pit_callback);\n\n    // Enable PIT\n    pit::init(OperatingMode::RateGenerator);\n    let irq = pit::enable_interrupt(irq);\n\n    static IS_FINISH: AtomicBool = AtomicBool::new(false);\n    static FREQUENCY: AtomicU64 = AtomicU64::new(0);\n\n    // Wait until `FREQUENCY` is ready\n    loop {\n        crate::arch::irq::enable_local_and_halt();\n\n        // Disable local IRQs so they won't come after checking `IS_FINISH`\n        // but before halting the CPU.\n        crate::arch::irq::disable_local();\n\n        if IS_FINISH.load(Ordering::Acquire) {\n            break;\n        }\n    }\n\n    // Disable PIT\n    drop(irq);\n\n    return FREQUENCY.load(Ordering::Acquire);\n\n    fn pit_callback(_trap_frame: &TrapFrame) {\n        static IN_TIME: AtomicU64 = AtomicU64::new(0);\n        static TSC_FIRST_COUNT: AtomicU64 = AtomicU64::new(0);\n        // Set a certain times of callbacks to calculate the frequency\n        const CALLBACK_TIMES: u64 = TIMER_FREQ / 10;\n\n        let tsc_current_count = crate::arch::read_tsc();\n\n        if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || IS_FINISH.load(Ordering::Acquire) {\n            if IN_TIME.load(Ordering::Relaxed) == 0 {\n                TSC_FIRST_COUNT.store(tsc_current_count, Ordering::Relaxed);\n            }\n            IN_TIME.fetch_add(1, Ordering::Relaxed);\n            return;\n        }\n\n        let tsc_first_count = TSC_FIRST_COUNT.load(Ordering::Relaxed);\n        let freq = (tsc_current_count - tsc_first_count) * (TIMER_FREQ / CALLBACK_TIMES);\n        FREQUENCY.store(freq, Ordering::Release);\n        IS_FINISH.store(true, Ordering::Release);\n    }\n}",
  "mir": "fn arch::kernel::tsc::determine_tsc_freq_via_pit() -> u64 {\n    let mut _0: u64;\n    let mut _1: irq::top_half::IrqLine;\n    let mut _2: core::result::Result<irq::top_half::IrqLine, error::Error>;\n    let  _3: ();\n    let mut _4: &mut irq::top_half::IrqLine;\n    let  _5: ();\n    let mut _6: arch::timer::pit::OperatingMode;\n    let  _7: arch::irq::chip::MappedIrqLine;\n    let mut _8: irq::top_half::IrqLine;\n    let  _9: ();\n    let  _10: ();\n    let mut _11: bool;\n    let mut _12: &core::sync::atomic::AtomicBool;\n    let mut _13: core::sync::atomic::Ordering;\n    let  _14: ();\n    let mut _15: &core::sync::atomic::AtomicU64;\n    let mut _16: core::sync::atomic::Ordering;\n    debug irq => _1;\n    debug irq => _7;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        _2 = irq::top_half::IrqLine::alloc() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = core::result::Result::<irq::top_half::IrqLine, error::Error>::unwrap(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_4);\n        _4 = &mut _1;\n        _3 = irq::top_half::IrqLine::on_active::<for<'a> fn(&'a arch::trap::TrapFrame) {arch::kernel::tsc::determine_tsc_freq_via_pit::pit_callback}>(move _4, arch::kernel::tsc::determine_tsc_freq_via_pit::pit_callback) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = arch::timer::pit::OperatingMode::RateGenerator;\n        _5 = arch::timer::pit::init(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = move _1;\n        _7 = arch::timer::pit::enable_interrupt(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        goto -> bb6;\n    }\n    bb6: {\n        _9 = arch::irq::ops::enable_local_and_halt() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = arch::irq::ops::disable_local() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = {alloc371: &core::sync::atomic::AtomicBool};\n        StorageLive(_13);\n        _13 = core::sync::atomic::Ordering::Acquire;\n        _11 = core::sync::atomic::AtomicBool::load(move _12, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _11) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        _14 = core::mem::drop::<arch::irq::chip::MappedIrqLine>(_7) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb6;\n    }\n    bb12: {\n        StorageLive(_15);\n        _15 = {alloc375: &core::sync::atomic::AtomicU64};\n        StorageLive(_16);\n        _16 = core::sync::atomic::Ordering::Acquire;\n        _0 = core::sync::atomic::AtomicU64::load(move _15, move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " Determines the TSC frequency with the help of the Programmable Interval Timer (PIT).\n\n When the TSC frequency is not enumerated in the results of the CPUID instruction, it can\n leverage the PIT to calculate the TSC frequency.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}