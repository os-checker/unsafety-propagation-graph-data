{
  "name": "sync::rcu::RcuReadGuard::<'_, P>::compare_exchange",
  "safe": true,
  "callees": {
    "sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::rcu::RcuReadGuardInner": [
      "Plain"
    ],
    "sync::rcu::RcuReadGuard": [
      "Unknown([Field(0, Ty { id: 6791, kind: RigidTy(Adt(AdtDef(DefId { id: 5763, name: \"sync::rcu::RcuReadGuardInner\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 443, kind: Param(ParamTy { index: 1, name: \"P\" }) })]))) })])",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2642,
  "span": "ostd/src/sync/rcu/mod.rs:372:5: 376:6",
  "src": "pub fn compare_exchange(self, new_ptr: P) -> Result<(), P> {\n        self.0\n            .compare_exchange(Some(new_ptr))\n            .map_err(|err| err.unwrap())\n    }",
  "mir": "fn sync::rcu::RcuReadGuard::<'_, P>::compare_exchange(_1: sync::rcu::RcuReadGuard<'_, P>, _2: P) -> core::result::Result<(), P> {\n    let mut _0: core::result::Result<(), P>;\n    let mut _3: core::result::Result<(), core::option::Option<P>>;\n    let mut _4: sync::rcu::RcuReadGuardInner<'_, P>;\n    let mut _5: core::option::Option<P>;\n    debug self => _1;\n    debug new_ptr => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = move (_1.0: sync::rcu::RcuReadGuardInner<'_, P>);\n        StorageLive(_5);\n        _5 = core::option::Option::Some(_2);\n        _3 = sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = core::result::Result::<(), core::option::Option<P>>::map_err::<P, {closure@ostd/src/sync/rcu/mod.rs:375:22: 375:27}>(move _3, ZeroSized: {closure@ostd/src/sync/rcu/mod.rs:375:22: 375:27}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Tries to replace the already read pointer with a new pointer.\n\n If another thread has updated the pointer after the read, this\n function will fail, and returns the given pointer back. Otherwise,\n it will replace the pointer with the new one and drop the old pointer\n after the grace period.\n\n If spinning on [`Rcu::read`] and this function, it is recommended\n to relax the CPU or yield the task on failure. Otherwise contention\n will occur.\n\n This API does not help to avoid\n [the ABA problem](https://en.wikipedia.org/wiki/ABA_problem).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}