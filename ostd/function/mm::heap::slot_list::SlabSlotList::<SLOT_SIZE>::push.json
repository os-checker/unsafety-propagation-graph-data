{
  "name": "mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push",
  "safe": true,
  "callees": {
    "mm::heap::slot::HeapSlot::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the pointer to the slot.\n",
      "adt": {
        "mm::heap::slot::HeapSlot": "ImmutableAsArgument"
      }
    },
    "mm::heap::slot::HeapSlot::info": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the type and size of the slot.\n",
      "adt": {
        "mm::heap::slot::HeapSlot": "ImmutableAsArgument",
        "mm::heap::slot::SlotInfo": "Constructor"
      }
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull`.\n\n # Safety\n\n `ptr` must be non-null.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = unsafe { NonNull::new_unchecked(&mut x as *mut _) };\n ```\n\n *Incorrect* usage of this function:\n\n ```rust,no_run\n use std::ptr::NonNull;\n\n // NEVER DO THAT!!! This is undefined behavior. ⚠️\n let ptr = unsafe { NonNull::<u32>::new_unchecked(std::ptr::null_mut()) };\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::option::Option::<T>::map_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the provided default result (if none),\n or applies a function to the contained value (if any).\n\n Arguments passed to `map_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`map_or_else`],\n which is lazily evaluated.\n\n [`map_or_else`]: Option::map_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.map_or(42, |v| v.len()), 3);\n\n let x: Option<&str> = None;\n assert_eq!(x.map_or(42, |v| v.len()), 42);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::write": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Overwrites a memory location with the given value without reading or\n dropping the old value.\n\n See [`ptr::write`] for safety concerns and examples.\n\n [`ptr::write`]: crate::ptr::write()\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::heap::slot::HeapSlot": [
      "Ref",
      "Plain"
    ],
    "mm::heap::slot::SlotInfo": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "mm::heap::slot_list::SlabSlotList": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push"
  },
  "span": "ostd/src/mm/heap/slot_list.rs:46:5: 68:6",
  "src": "pub fn push(&mut self, slot: HeapSlot) {\n        let slot_ptr = slot.as_ptr();\n        let super::SlotInfo::SlabSlot(slot_size) = slot.info() else {\n            panic!(\"The slot does not come from a slab\");\n        };\n\n        assert_eq!(slot_size, SLOT_SIZE);\n        const { assert!(SLOT_SIZE >= size_of::<usize>()) };\n\n        let original_head = self.head;\n\n        debug_assert!(!slot_ptr.is_null());\n        // SAFETY: A pointer to a slot must not be NULL;\n        self.head = Some(unsafe { NonNull::new_unchecked(slot_ptr) });\n        // Write the original head to the slot.\n        // SAFETY: A heap slot must be free so the pointer to the slot can be\n        // written to. The slot size is at least the size of a pointer.\n        unsafe {\n            slot_ptr\n                .cast::<usize>()\n                .write(original_head.map_or(0, |h| h.as_ptr() as usize));\n        }\n    }",
  "mir": "fn mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push(_1: &mut mm::heap::slot_list::SlabSlotList<SLOT_SIZE>, _2: mm::heap::slot::HeapSlot) -> () {\n    let mut _0: ();\n    let  _3: *mut u8;\n    let mut _4: &mm::heap::slot::HeapSlot;\n    let  _5: !;\n    let mut _6: core::fmt::Arguments<'_>;\n    let  _7: usize;\n    let mut _8: mm::heap::slot::SlotInfo;\n    let mut _9: &mm::heap::slot::HeapSlot;\n    let mut _10: isize;\n    let mut _11: (&usize, &usize);\n    let mut _12: &usize;\n    let mut _13: &usize;\n    let  _14: &usize;\n    let  _15: &usize;\n    let mut _16: bool;\n    let mut _17: usize;\n    let mut _18: usize;\n    let  _19: core::panicking::AssertKind;\n    let  _20: !;\n    let mut _21: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _22: core::option::Option<core::ptr::NonNull<u8>>;\n    let mut _23: bool;\n    let mut _24: !;\n    let mut _25: core::option::Option<core::ptr::NonNull<u8>>;\n    let mut _26: core::ptr::NonNull<u8>;\n    let  _27: ();\n    let mut _28: *mut usize;\n    let mut _29: usize;\n    debug self => _1;\n    debug slot => _2;\n    debug slot_ptr => _3;\n    debug slot_size => _7;\n    debug left_val => _14;\n    debug right_val => _15;\n    debug kind => _19;\n    debug original_head => _22;\n    bb0: {\n        StorageLive(_4);\n        _4 = &_2;\n        _3 = mm::heap::slot::HeapSlot::as_ptr(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_2;\n        _8 = mm::heap::slot::HeapSlot::info(move _9) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        _5 = core::panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_9);\n        _10 = discriminant(_8);\n        switchInt(move _10) -> [0: bb4, 1: bb5, otherwise: bb15];\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = ((_8 as variant#0).0: usize);\n        StorageDead(_8);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_7;\n        StorageLive(_13);\n        _13 = mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push::promoted[0];\n        _11 = (move _12, move _13);\n        StorageDead(_13);\n        StorageDead(_12);\n        _14 = (_11.0: &usize);\n        _15 = (_11.1: &usize);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (*_14);\n        StorageLive(_18);\n        _18 = (*_15);\n        _16 = Eq(move _17, move _18);\n        switchInt(move _16) -> [0: bb7, otherwise: bb6];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageLive(_6);\n        _6 = core::fmt::Arguments::<'_>::from_str(\"The slot does not come from a slab\") -> [return: bb2, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_11);\n        _22 = ((*_1).0: core::option::Option<core::ptr::NonNull<u8>>);\n        StorageLive(_23);\n        _23 = core::ptr::mut_ptr::<impl *mut u8>::is_null(_3) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _19 = core::panicking::AssertKind::Eq;\n        StorageLive(_21);\n        _21 = core::option::Option::None;\n        _20 = core::panicking::assert_failed::<usize, usize>(_19, _14, _15, move _21) -> unwind unreachable;\n    }\n    bb8: {\n        switchInt(move _23) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        _24 = core::panicking::panic(\"assertion failed: !slot_ptr.is_null()\") -> unwind unreachable;\n    }\n    bb10: {\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = core::ptr::NonNull::<u8>::new_unchecked(_3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _25 = core::option::Option::Some(move _26);\n        StorageDead(_26);\n        ((*_1).0: core::option::Option<core::ptr::NonNull<u8>>) = move _25;\n        StorageDead(_25);\n        StorageLive(_28);\n        _28 = core::ptr::mut_ptr::<impl *mut u8>::cast::<usize>(_3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_29);\n        _29 = core::option::Option::<core::ptr::NonNull<u8>>::map_or::<usize, {closure@ostd/src/mm/heap/slot_list.rs:66:48: 66:51}>(_22, 0_usize, ZeroSized: {closure@ostd/src/mm/heap/slot_list.rs:66:48: 66:51}) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _27 = core::ptr::mut_ptr::<impl *mut usize>::write(move _28, move _29) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_7);\n        return;\n    }\n    bb15: {\n        unreachable;\n    }\n}\n",
  "doc": " Pushes a slot to the front of the list.\n\n # Panics\n\n Panics if\n  - the slot does not come from a slab\n    (i.e., `!matches(slot.info(), SlotInfo::SlabSlot(_))`);\n  - the size of the slot does not match `SLOT_SIZE`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}