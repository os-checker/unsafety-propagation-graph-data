{
  "name": "util::range_alloc::RangeAllocator::free",
  "safe": true,
  "callees": {
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::upper_bound_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a [`CursorMut`] pointing at the gap after the greatest key\n smaller than the given bound.\n\n Passing `Bound::Included(x)` will return a cursor pointing to the\n gap after the greatest key smaller than or equal to `x`.\n\n Passing `Bound::Excluded(x)` will return a cursor pointing to the\n gap after the greatest key smaller than `x`.\n\n Passing `Bound::Unbounded` will return a cursor pointing to the\n gap after the greatest key in the map.\n\n # Examples\n\n ```\n #![feature(btree_cursors)]\n\n use std::collections::BTreeMap;\n use std::ops::Bound;\n\n let mut map = BTreeMap::from([\n     (1, \"a\"),\n     (2, \"b\"),\n     (3, \"c\"),\n     (4, \"d\"),\n ]);\n\n let mut cursor = map.upper_bound_mut(Bound::Included(&3));\n assert_eq!(cursor.peek_prev(), Some((&3, &mut \"c\")));\n assert_eq!(cursor.peek_next(), Some((&4, &mut \"d\")));\n\n let mut cursor = map.upper_bound_mut(Bound::Excluded(&3));\n assert_eq!(cursor.peek_prev(), Some((&2, &mut \"b\")));\n assert_eq!(cursor.peek_next(), Some((&3, &mut \"c\")));\n\n let mut cursor = map.upper_bound_mut(Bound::Unbounded);\n assert_eq!(cursor.peek_prev(), Some((&4, &mut \"d\")));\n assert_eq!(cursor.peek_next(), None);\n ```\n",
      "adt": {}
    },
    "alloc::collections::btree_map::CursorMut::<'a, K, V, A>::peek_prev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the key and value of the previous element\n without moving the cursor.\n\n If the cursor is at the start of the map then `None` is returned.\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {}
    },
    "util::range_alloc::FreeRange::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "util::range_alloc::FreeRange": "Constructor"
      }
    },
    "alloc::collections::BTreeMap::<K, V, A>::insert": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a key-value pair into the map.\n\n If the map did not have this key present, `None` is returned.\n\n If the map did have this key present, the value is updated, and the old\n value is returned. The key is not updated, though; this matters for\n types that can be `==` without being identical. See the [module-level\n documentation] for more.\n\n [module-level documentation]: index.html#insert-and-complex-keys\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n assert_eq!(map.insert(37, \"a\"), None);\n assert_eq!(map.is_empty(), false);\n\n map.insert(37, \"b\");\n assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n assert_eq!(map[&37], \"c\");\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::lower_bound_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a [`CursorMut`] pointing at the gap before the smallest key\n greater than the given bound.\n\n Passing `Bound::Included(x)` will return a cursor pointing to the\n gap before the smallest key greater than or equal to `x`.\n\n Passing `Bound::Excluded(x)` will return a cursor pointing to the\n gap before the smallest key greater than `x`.\n\n Passing `Bound::Unbounded` will return a cursor pointing to the\n gap before the smallest key in the map.\n\n # Examples\n\n ```\n #![feature(btree_cursors)]\n\n use std::collections::BTreeMap;\n use std::ops::Bound;\n\n let mut map = BTreeMap::from([\n     (1, \"a\"),\n     (2, \"b\"),\n     (3, \"c\"),\n     (4, \"d\"),\n ]);\n\n let mut cursor = map.lower_bound_mut(Bound::Included(&2));\n assert_eq!(cursor.peek_prev(), Some((&1, &mut \"a\")));\n assert_eq!(cursor.peek_next(), Some((&2, &mut \"b\")));\n\n let mut cursor = map.lower_bound_mut(Bound::Excluded(&2));\n assert_eq!(cursor.peek_prev(), Some((&2, &mut \"b\")));\n assert_eq!(cursor.peek_next(), Some((&3, &mut \"c\")));\n\n let mut cursor = map.lower_bound_mut(Bound::Unbounded);\n assert_eq!(cursor.peek_prev(), None);\n assert_eq!(cursor.peek_next(), Some((&1, &mut \"a\")));\n ```\n",
      "adt": {}
    },
    "alloc::collections::btree_map::CursorMut::<'a, K, V, A>::peek_next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the key and value of the next element without\n moving the cursor.\n\n If the cursor is at the end of the map then `None` is returned.\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the value corresponding to the key.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n if let Some(x) = map.get_mut(&1) {\n     *x = \"b\";\n }\n assert_eq!(map[&1], \"b\");\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "util::range_alloc::RangeAllocator": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7944, kind: RigidTy(Tuple([Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) }, Ty { id: 7914, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Mut)) }])) }), Field(0, Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7944, kind: RigidTy(Tuple([Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) }, Ty { id: 7914, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Mut)) }])) }), Field(1, Ty { id: 7914, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Mut)) })])"
    ],
    "alloc::collections::BTreeMap": [
      "MutRef"
    ],
    "core::ops::Range": [
      "Ref",
      "Plain",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ops::Bound": [
      "Plain"
    ],
    "alloc::collections::btree_map::CursorMut": [
      "Plain",
      "MutRef"
    ],
    "util::range_alloc::FreeRange": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain"
    ]
  },
  "path": 2958,
  "span": "ostd/src/util/range_alloc.rs:107:5: 140:6",
  "src": "pub fn free(&self, range: Range<usize>) {\n        let mut lock_guard = self.freelist.lock();\n        let freelist = lock_guard.as_mut().unwrap_or_else(|| {\n            panic!(\"Free a 'KVirtArea' when 'VirtAddrAllocator' has not been initialized.\")\n        });\n        // 1. get the previous free block, check if we can merge this block with the free one\n        //     - if contiguous, merge this area with the free block.\n        //     - if not contiguous, create a new free block, insert it into the list.\n        let mut free_range = range.clone();\n\n        if let Some((prev_va, prev_node)) = freelist\n            .upper_bound_mut(core::ops::Bound::Excluded(&free_range.start))\n            .peek_prev()\n            && prev_node.block.end == free_range.start\n        {\n            let prev_va = *prev_va;\n            free_range.start = prev_node.block.start;\n            freelist.remove(&prev_va);\n        }\n\n        freelist.insert(free_range.start, FreeRange::new(free_range.clone()));\n\n        // 2. check if we can merge the current block with the next block, if we can, do so.\n        if let Some((next_va, next_node)) = freelist\n            .lower_bound_mut(core::ops::Bound::Excluded(&free_range.start))\n            .peek_next()\n            && free_range.end == next_node.block.start\n        {\n            let next_va = *next_va;\n            free_range.end = next_node.block.end;\n            freelist.remove(&next_va);\n            freelist.get_mut(&free_range.start).unwrap().block.end = free_range.end;\n        }\n    }",
  "mir": "fn util::range_alloc::RangeAllocator::free(_1: &util::range_alloc::RangeAllocator, _2: core::ops::Range<usize>) -> () {\n    let mut _0: ();\n    let mut _3: sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled>;\n    let mut _4: &sync::spin::SpinLock<core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>>;\n    let  _5: &mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>;\n    let mut _6: core::option::Option<&mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>;\n    let mut _7: &mut core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>;\n    let mut _8: &mut sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled>;\n    let mut _9: core::ops::Range<usize>;\n    let mut _10: &core::ops::Range<usize>;\n    let mut _11: core::option::Option<(&usize, &mut util::range_alloc::FreeRange)>;\n    let mut _12: &mut alloc::collections::btree_map::CursorMut<'_, usize, util::range_alloc::FreeRange>;\n    let mut _13: alloc::collections::btree_map::CursorMut<'_, usize, util::range_alloc::FreeRange>;\n    let mut _14: core::ops::Bound<&usize>;\n    let  _15: &usize;\n    let mut _16: isize;\n    let  _17: &usize;\n    let  _18: &mut util::range_alloc::FreeRange;\n    let mut _19: bool;\n    let mut _20: usize;\n    let mut _21: usize;\n    let  _22: usize;\n    let mut _23: usize;\n    let  _24: core::option::Option<util::range_alloc::FreeRange>;\n    let  _25: &usize;\n    let  _26: core::option::Option<util::range_alloc::FreeRange>;\n    let mut _27: usize;\n    let mut _28: util::range_alloc::FreeRange;\n    let mut _29: core::ops::Range<usize>;\n    let mut _30: &core::ops::Range<usize>;\n    let mut _31: core::option::Option<(&usize, &mut util::range_alloc::FreeRange)>;\n    let mut _32: &mut alloc::collections::btree_map::CursorMut<'_, usize, util::range_alloc::FreeRange>;\n    let mut _33: alloc::collections::btree_map::CursorMut<'_, usize, util::range_alloc::FreeRange>;\n    let mut _34: core::ops::Bound<&usize>;\n    let  _35: &usize;\n    let mut _36: isize;\n    let  _37: &usize;\n    let  _38: &mut util::range_alloc::FreeRange;\n    let mut _39: bool;\n    let mut _40: usize;\n    let mut _41: usize;\n    let  _42: usize;\n    let mut _43: usize;\n    let  _44: core::option::Option<util::range_alloc::FreeRange>;\n    let  _45: &usize;\n    let mut _46: usize;\n    let mut _47: &mut util::range_alloc::FreeRange;\n    let mut _48: core::option::Option<&mut util::range_alloc::FreeRange>;\n    let  _49: &usize;\n    debug self => _1;\n    debug range => _2;\n    debug lock_guard => _3;\n    debug freelist => _5;\n    debug free_range => _9;\n    debug prev_va => _17;\n    debug prev_node => _18;\n    debug prev_va => _22;\n    debug next_va => _37;\n    debug next_node => _38;\n    debug next_va => _42;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).1: sync::spin::SpinLock<core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>>);\n        _3 = sync::spin::SpinLock::<core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>>::lock(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_8);\n        _8 = &mut _3;\n        _7 = <sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _6 = core::option::Option::<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>::as_mut(_7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = core::option::Option::<&mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>::unwrap_or_else::<{closure@ostd/src/util/range_alloc.rs:109:59: 109:61}>(move _6, ZeroSized: {closure@ostd/src/util/range_alloc.rs:109:59: 109:61}) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        _9 = <core::ops::Range<usize> as core::clone::Clone>::clone(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _15 = &(_9.0: usize);\n        _14 = core::ops::Bound::Excluded(_15);\n        _13 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::upper_bound_mut::<usize>(_5, move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = &mut _13;\n        StorageDead(_14);\n        _11 = alloc::collections::btree_map::CursorMut::<'_, usize, util::range_alloc::FreeRange>::peek_prev(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _16 = discriminant(_11);\n        switchInt(move _16) -> [1: bb8, 0: bb12, otherwise: bb28];\n    }\n    bb8: {\n        StorageLive(_17);\n        _17 = (((_11 as variant#1).0: (&usize, &mut util::range_alloc::FreeRange)).0: &usize);\n        StorageLive(_18);\n        _18 = move (((_11 as variant#1).0: (&usize, &mut util::range_alloc::FreeRange)).1: &mut util::range_alloc::FreeRange);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = (((*_18).0: core::ops::Range<usize>).1: usize);\n        StorageLive(_21);\n        _21 = (_9.0: usize);\n        _19 = Eq(move _20, move _21);\n        switchInt(move _19) -> [0: bb11, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = (*_17);\n        StorageLive(_23);\n        _23 = (((*_18).0: core::ops::Range<usize>).0: usize);\n        (_9.0: usize) = move _23;\n        StorageDead(_23);\n        StorageLive(_24);\n        _25 = &_22;\n        _24 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::remove::<usize>(_5, _25) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_24);\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_13);\n        StorageDead(_11);\n        goto -> bb13;\n    }\n    bb11: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_13);\n        StorageDead(_11);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = (_9.0: usize);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_9;\n        _29 = <core::ops::Range<usize> as core::clone::Clone>::clone(move _30) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_30);\n        _28 = util::range_alloc::FreeRange::new(move _29) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_29);\n        _26 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::insert(_5, move _27, move _28) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _35 = &(_9.0: usize);\n        _34 = core::ops::Bound::Excluded(_35);\n        _33 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::lower_bound_mut::<usize>(_5, move _34) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _32 = &mut _33;\n        StorageDead(_34);\n        _31 = alloc::collections::btree_map::CursorMut::<'_, usize, util::range_alloc::FreeRange>::peek_next(move _32) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_32);\n        _36 = discriminant(_31);\n        switchInt(move _36) -> [1: bb19, 0: bb25, otherwise: bb28];\n    }\n    bb19: {\n        StorageLive(_37);\n        _37 = (((_31 as variant#1).0: (&usize, &mut util::range_alloc::FreeRange)).0: &usize);\n        StorageLive(_38);\n        _38 = move (((_31 as variant#1).0: (&usize, &mut util::range_alloc::FreeRange)).1: &mut util::range_alloc::FreeRange);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = (_9.1: usize);\n        StorageLive(_41);\n        _41 = (((*_38).0: core::ops::Range<usize>).0: usize);\n        _39 = Eq(move _40, move _41);\n        switchInt(move _39) -> [0: bb24, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageLive(_42);\n        _42 = (*_37);\n        StorageLive(_43);\n        _43 = (((*_38).0: core::ops::Range<usize>).1: usize);\n        (_9.1: usize) = move _43;\n        StorageDead(_43);\n        StorageLive(_44);\n        _45 = &_42;\n        _44 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::remove::<usize>(_5, _45) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_44);\n        StorageLive(_46);\n        _46 = (_9.1: usize);\n        StorageLive(_47);\n        StorageLive(_48);\n        _49 = &(_9.0: usize);\n        _48 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::get_mut::<usize>(_5, _49) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _47 = core::option::Option::<&mut util::range_alloc::FreeRange>::unwrap(move _48) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_48);\n        (((*_47).0: core::ops::Range<usize>).1: usize) = move _46;\n        StorageDead(_46);\n        StorageDead(_47);\n        StorageDead(_42);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_33);\n        StorageDead(_31);\n        goto -> bb26;\n    }\n    bb24: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_33);\n        StorageDead(_31);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_39);\n        StorageDead(_9);\n        drop(_3) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_3);\n        return;\n    }\n    bb28: {\n        unreachable;\n    }\n}\n",
  "doc": " Frees a `range`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}