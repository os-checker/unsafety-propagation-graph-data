{
  "name": "arch::timer::init_on_bsp",
  "safe": true,
  "callees": {
    "arch::timer::apic::init_on_bsp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes APIC with TSC-deadline mode or periodic mode.\n\n Return the corresponding [`IrqLine`] for the system timer.\n",
      "adt": {
        "irq::top_half::IrqLine": "Constructor"
      }
    },
    "irq::top_half::IrqLine::on_active": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Registers a callback that will be invoked when the IRQ is active.\n\n For each IRQ line, multiple callbacks may be registered.\n",
      "adt": {
        "irq::top_half::IrqLine": "MutableAsArgument"
      }
    },
    "arch::timer::timer_callback": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "irq::top_half::IrqLine": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::timer::init_on_bsp"
  },
  "span": "ostd/src/arch/x86/timer/mod.rs:17:1: 26:2",
  "src": "pub(super) fn init_on_bsp() {\n    // TODO: Currently, we only enable per-CPU APIC timers. We may also need to enable a global\n    // timer, such as a PIT or HPET.\n\n    let mut timer_irq = apic::init_on_bsp();\n\n    timer_irq.on_active(timer_callback);\n\n    TIMER_IRQ.call_once(|| timer_irq);\n}",
  "mir": "fn arch::timer::init_on_bsp() -> () {\n    let mut _0: ();\n    let mut _1: irq::top_half::IrqLine;\n    let  _2: ();\n    let mut _3: &mut irq::top_half::IrqLine;\n    let  _4: &irq::top_half::IrqLine;\n    let mut _5: &spin::once::Once<irq::top_half::IrqLine>;\n    let mut _6: {closure@ostd/src/arch/x86/timer/mod.rs:25:25: 25:27};\n    debug timer_irq => _1;\n    bb0: {\n        StorageLive(_1);\n        _1 = arch::timer::apic::init_on_bsp() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = &mut _1;\n        _2 = irq::top_half::IrqLine::on_active::<for<'a> fn(&'a arch::trap::TrapFrame) {arch::timer::timer_callback}>(move _3, arch::timer::timer_callback) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = {alloc598: &spin::once::Once<irq::top_half::IrqLine>};\n        StorageLive(_6);\n        _6 = {closure@ostd/src/arch/x86/timer/mod.rs:25:25: 25:27}(move _1);\n        _4 = spin::once::Once::<irq::top_half::IrqLine>::call_once::<{closure@ostd/src/arch/x86/timer/mod.rs:25:25: 25:27}>(move _5, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " Initializes the timer state and enable timer interrupts on BSP.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}