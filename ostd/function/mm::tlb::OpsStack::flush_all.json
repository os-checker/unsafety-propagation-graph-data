{
  "name": "mm::tlb::OpsStack::flush_all",
  "safe": true,
  "callees": {
    "mm::tlb::OpsStack::need_flush_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::tlb::OpsStack": "ImmutableAsArgument"
      }
    },
    "arch::mm::tlb_flush_all_excluding_global": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Flush all TLB entries except for the global-page entries.\n",
      "adt": {}
    },
    "mm::tlb::OpsStack::ops_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::tlb::OpsStack": "ImmutableAsArgument",
        "core::iter::Map": "Constructor"
      }
    },
    "core::iter::Iterator::for_each": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls a closure on each element of an iterator.\n\n This is equivalent to using a [`for`] loop on the iterator, although\n `break` and `continue` are not possible from a closure. It's generally\n more idiomatic to use a `for` loop, but `for_each` may be more legible\n when processing items at the end of longer iterator chains. In some\n cases `for_each` may also be faster than a loop, because it will use\n internal iteration on adapters like `Chain`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n use std::sync::mpsc::channel;\n\n let (tx, rx) = channel();\n (0..5).map(|x| x * 2 + 1)\n       .for_each(move |x| tx.send(x).unwrap());\n\n let v: Vec<_> = rx.iter().collect();\n assert_eq!(v, vec![1, 3, 5, 7, 9]);\n ```\n\n For such a small example, a `for` loop may be cleaner, but `for_each`\n might be preferable to keep a functional style with longer iterators:\n\n ```\n (0..5).flat_map(|x| (x * 100)..(x * 110))\n       .enumerate()\n       .filter(|&(i, x)| (i + x) % 3 == 0)\n       .for_each(|(i, x)| println!(\"{i}:{x}\"));\n ```\n",
      "adt": {}
    },
    "mm::tlb::OpsStack::clear_without_flush": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::tlb::OpsStack": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::tlb::OpsStack": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::iter::Map": [
      "Plain"
    ]
  },
  "path": 2440,
  "span": "ostd/src/mm/tlb.rs:369:5: 379:6",
  "src": "fn flush_all(&mut self) {\n        if self.need_flush_all() {\n            crate::arch::mm::tlb_flush_all_excluding_global();\n        } else {\n            self.ops_iter().for_each(|op| {\n                op.perform_on_current();\n            });\n        }\n\n        self.clear_without_flush();\n    }",
  "mir": "fn mm::tlb::OpsStack::flush_all(_1: &mut mm::tlb::OpsStack) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: &mm::tlb::OpsStack;\n    let  _4: ();\n    let  _5: ();\n    let mut _6: core::iter::Map<core::iter::Take<core::slice::Iter<'_, core::mem::MaybeUninit<mm::tlb::TlbFlushOp>>>, {closure@ostd/src/mm/tlb.rs:388:57: 388:61}>;\n    let mut _7: &mm::tlb::OpsStack;\n    let  _8: ();\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &(*_1);\n        _2 = mm::tlb::OpsStack::need_flush_all(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = arch::mm::tlb_flush_all_excluding_global() -> [return: bb6, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = mm::tlb::OpsStack::ops_iter(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = <core::iter::Map<core::iter::Take<core::slice::Iter<'_, core::mem::MaybeUninit<mm::tlb::TlbFlushOp>>>, {closure@ostd/src/mm/tlb.rs:388:57: 388:61}> as core::iter::Iterator>::for_each::<{closure@ostd/src/mm/tlb.rs:373:38: 373:42}>(move _6, ZeroSized: {closure@ostd/src/mm/tlb.rs:373:38: 373:42}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        goto -> bb6;\n    }\n    bb6: {\n        StorageDead(_2);\n        _8 = mm::tlb::OpsStack::clear_without_flush(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}