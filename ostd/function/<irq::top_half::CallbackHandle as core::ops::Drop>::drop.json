{
  "name": "<irq::top_half::CallbackHandle as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "sync::rwlock::RwLock::<T, G>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a write lock and spin-wait until it can be acquired.\n\n The calling thread will spin-wait until there are no other writers,\n upreaders or readers present. There is no guarantee for the order\n in which other readers or writers waiting simultaneously will\n obtain the lock.\n",
      "adt": {
        "sync::rwlock::RwLock": "ImmutableAsArgument",
        "sync::rwlock::RwLockWriteGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::position": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element in an iterator, returning its index.\n\n `position()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if one of them\n returns `true`, then `position()` returns [`Some(index)`]. If all of\n them return `false`, it returns [`None`].\n\n `position()` is short-circuiting; in other words, it will stop\n processing as soon as it finds a `true`.\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so if there are more\n than [`usize::MAX`] non-matching elements, it either produces the wrong\n result or panics. If overflow checks are enabled, a panic is\n guaranteed.\n\n # Panics\n\n This function might panic if the iterator has more than `usize::MAX`\n non-matching elements.\n\n [`Some(index)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().position(|x| x == 2), Some(1));\n\n assert_eq!(a.into_iter().position(|x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3, 4];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.position(|x| x >= 2), Some(1));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n\n // The returned index depends on iterator state\n assert_eq!(iter.position(|x| x == 4), Some(0));\n\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T, A>::swap_remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes an element from the vector and returns it.\n\n The removed element is replaced by the last element of the vector.\n\n This does not preserve ordering of the remaining elements, but is *O*(1).\n If you need to preserve the element order, use [`remove`] instead.\n\n [`remove`]: Vec::remove\n\n # Panics\n\n Panics if `index` is out of bounds.\n\n # Examples\n\n ```\n let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n\n assert_eq!(v.swap_remove(1), \"bar\");\n assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n\n assert_eq!(v.swap_remove(0), \"foo\");\n assert_eq!(v, [\"baz\", \"qux\"]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "irq::top_half::CallbackHandle": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "sync::rwlock::RwLock": [
      "Ref"
    ],
    "sync::rwlock::RwLockWriteGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "alloc::vec::Vec": [
      "Ref",
      "MutRef"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc::boxed::Box": [
      "Plain"
    ]
  },
  "path": 1821,
  "span": "ostd/src/irq/top_half.rs:178:5: 185:6",
  "src": "fn drop(&mut self) {\n        let mut callbacks = INNERS[self.irq_index as usize].callbacks.write();\n\n        let pos = callbacks\n            .iter()\n            .position(|element| core::ptr::from_ref(&**element).addr() == self.callback_addr);\n        let _ = callbacks.swap_remove(pos.unwrap());\n    }",
  "mir": "fn <irq::top_half::CallbackHandle as core::ops::Drop>::drop(_1: &mut irq::top_half::CallbackHandle) -> () {\n    let mut _0: ();\n    let mut _2: sync::rwlock::RwLockWriteGuard<'_, alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled>;\n    let mut _3: &sync::rwlock::RwLock<alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled>;\n    let  _4: &[irq::top_half::Inner; 224];\n    let  _5: usize;\n    let mut _6: u8;\n    let mut _7: bool;\n    let  _8: core::option::Option<usize>;\n    let mut _9: &mut core::slice::Iter<'_, alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>;\n    let mut _10: core::slice::Iter<'_, alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>;\n    let  _11: &[alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>];\n    let  _12: &alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>;\n    let mut _13: &sync::rwlock::RwLockWriteGuard<'_, alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled>;\n    let mut _14: {closure@ostd/src/irq/top_half.rs:183:23: 183:32};\n    let mut _15: &usize;\n    let mut _16: alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>;\n    let mut _17: &mut alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>;\n    let mut _18: &mut sync::rwlock::RwLockWriteGuard<'_, alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled>;\n    let mut _19: usize;\n    debug self => _1;\n    debug callbacks => _2;\n    debug pos => _8;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc867: &[irq::top_half::Inner; 224]};\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = ((*_1).0: u8);\n        _5 = move _6 as usize;\n        StorageDead(_6);\n        _7 = Lt(_5, 224_usize);\n        assert(move _7, \"index out of bounds: the length is {} but the index is {}\", 224_usize, _5) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &((*_4)[_5].0: sync::rwlock::RwLock<alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled>);\n        _2 = sync::rwlock::RwLock::<alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled>::write(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_13);\n        _13 = &_2;\n        _12 = <sync::rwlock::RwLockWriteGuard<'_, alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled> as core::ops::Deref>::deref(move _13) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _11 = <alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>> as core::ops::Deref>::deref(_12) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_13);\n        _10 = core::slice::<impl [alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>]>::iter(_11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = &mut _10;\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &((*_1).1: usize);\n        _14 = {closure@ostd/src/irq/top_half.rs:183:23: 183:32}(move _15);\n        StorageDead(_15);\n        _8 = <core::slice::Iter<'_, alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>> as core::iter::Iterator>::position::<{closure@ostd/src/irq/top_half.rs:183:23: 183:32}>(move _9, move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageDead(_9);\n        StorageDead(_10);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = &mut _2;\n        _17 = <sync::rwlock::RwLockWriteGuard<'_, alloc::vec::Vec<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>, sync::guard::WriteIrqDisabled> as core::ops::DerefMut>::deref_mut(move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = core::option::Option::<usize>::unwrap(_8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _16 = alloc::vec::Vec::<alloc::boxed::Box<dyn for<'a> core::ops::Fn(&'a arch::trap::TrapFrame) + core::marker::Send + core::marker::Sync>>::swap_remove(_17, move _19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        drop(_16) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        drop(_2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}