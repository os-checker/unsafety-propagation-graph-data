{
  "name": "arch::iommu::registers::IommuRegisters::new",
  "safe": true,
  "callees": {
    "arch::kernel::acpi::dmar::Dmar::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a instance from ACPI table.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "arch::kernel::acpi::dmar::Dmar": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::kernel::acpi::dmar::Dmar::remapping_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::kernel::acpi::dmar::Dmar": "ImmutableAsArgument",
        "core::slice::Iter": "Constructor"
      }
    },
    "core::iter::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Applies function to the elements of iterator and returns\n the first non-none result.\n\n `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n\n # Examples\n\n ```\n let a = [\"lol\", \"NaN\", \"2\", \"5\"];\n\n let first_number = a.iter().find_map(|s| s.parse().ok());\n\n assert_eq!(first_number, Some(2));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "io::io_mem::allocator::IoMemAllocatorBuilder::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes access to a specific memory I/O range.\n\n All drivers in OSTD must use this method to prevent peripheral drivers from accessing illegal memory I/O range.\n",
      "adt": {
        "core::ops::Range": "ImmutableAsArgument",
        "io::io_mem::allocator::IoMemAllocatorBuilder": "ImmutableAsArgument"
      }
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull` if `ptr` is non-null.\n\n # Panics during const evaluation\n\n This method will panic during const evaluation if the pointer cannot be\n determined to be null or not. See [`is_null`] for more information.\n\n [`is_null`]: ../primitive.pointer.html#method.is_null-1\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::<u32>::new(&mut x as *mut _).expect(\"ptr is null!\");\n\n if let Some(ptr) = NonNull::<u32>::new(std::ptr::null_mut()) {\n     unreachable!();\n }\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "arch::iommu::fault::init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the fault reporting function.\n\n # Safety\n\n The caller must ensure that the base address is a valid IOMMU base address and that it has\n exclusive ownership of the IOMMU fault event registers.\n",
      "adt": {
        "core::ptr::NonNull": "ImmutableAsArgument"
      }
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T>::new_read_only": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Turns the given pointer into a read-only `VolatileRef`.\n\n ## Safety\n\n - The pointer must be properly aligned.\n - It must be “dereferenceable” in the sense defined in the [`core::ptr`] documentation.\n - The pointer must point to an initialized instance of T.\n - You must enforce Rust’s aliasing rules, since the returned lifetime 'a is arbitrarily\n   chosen and does not necessarily reflect the actual lifetime of the data. In particular,\n   while this `VolatileRef` exists, the memory the pointer points to _must not get mutated_.\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an offset to a pointer (convenience for `.offset(count as isize)`).\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let s: &str = \"123\";\n let ptr: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap();\n\n unsafe {\n     println!(\"{}\", ptr.add(1).read() as char);\n     println!(\"{}\", ptr.add(2).read() as char);\n }\n ```\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T>::new_restricted": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Turns the given pointer into a `VolatileRef` instance with the given access.\n\n ## Safety\n\n - The pointer must be properly aligned.\n - It must be “dereferenceable” in the sense defined in the [`core::ptr`] documentation.\n - The pointer must point to an initialized instance of T.\n - You must enforce Rust’s aliasing rules, since the returned lifetime 'a is arbitrarily\n   chosen and does not necessarily reflect the actual lifetime of the data. In particular,\n   while this `VolatileRef` exists, the memory the pointer points to _must not get mutated_.\n   If the given `access` parameter allows write access, the pointer _must not get read\n   either_ while this `VolatileRef` exists.\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Turns the given pointer into a `VolatileRef`.\n\n ## Safety\n\n - The pointer must be properly aligned.\n - It must be “dereferenceable” in the sense defined in the [`core::ptr`] documentation.\n - The pointer must point to an initialized instance of T.\n - You must enforce Rust’s aliasing rules, since the returned lifetime 'a is arbitrarily\n   chosen and does not necessarily reflect the actual lifetime of the data. In particular,\n   while this `VolatileRef` exists, the memory the pointer points to must not get accessed\n   (_read or written_) through any other pointer.\n",
      "adt": {}
    },
    "arch::iommu::registers::invalidation::InvalidationRegisters::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an instance from the IOMMU base address.\n\n # Safety\n\n The caller must ensure that the base address is a valid IOMMU base address and that it has\n exclusive ownership of the IOMMU invalidation registers.\n",
      "adt": {
        "arch::iommu::registers::invalidation::InvalidationRegisters": "Constructor"
      }
    },
    "arch::iommu::registers::IommuRegisters::read_capability": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the capability of IOMMU\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "ImmutableAsArgument",
        "arch::iommu::registers::capability::Capability": "Constructor"
      }
    },
    "arch::iommu::registers::IommuRegisters::read_extended_capability": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the extended Capability of IOMMU\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "ImmutableAsArgument",
        "arch::iommu::registers::extended_cap::ExtendedCapability": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1753, kind: RigidTy(Adt(AdtDef(DefId { id: 3831, name: \"arch::kernel::acpi::dmar::Dmar\" }), GenericArgs([]))) })])"
    ],
    "arch::kernel::acpi::dmar::Dmar": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Rev": [
      "Plain",
      "MutRef"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "io::io_mem::allocator::IoMemAllocatorBuilder": [
      "Ref"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "volatile::VolatileRef": [
      "Plain"
    ],
    "arch::iommu::registers::invalidation::InvalidationRegisters": [
      "Plain"
    ],
    "arch::iommu::registers::IommuRegisters": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "arch::iommu::registers::capability::Capability": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapability": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::iommu::registers::IommuRegisters::new"
  },
  "span": "ostd/src/arch/x86/iommu/registers/mod.rs:266:5: 326:6",
  "src": "fn new(io_mem_builder: &IoMemAllocatorBuilder) -> Option<Self> {\n        let dmar = Dmar::new()?;\n        debug!(\"DMAR: {:#x?}\", dmar);\n\n        let base_address = dmar\n            .remapping_iter()\n            // TODO: Add support for multiple DMA remapping hardware unit definitions (DRHDs). Note\n            // that we use `rev()` here to select the last one, since DRHDs that control specific\n            // devices tend to be reported first.\n            //\n            // For example, Intel(R) Virtualization Technology for Directed I/O (Revision 5.0), 8.4\n            // DMA Remapping Hardware Unit Definition Structure says \"If a DRHD structure with\n            // INCLUDE_PCI_ALL flag Set is reported for a Segment, it must be enumerated by BIOS\n            // after all other DRHD structures for the same Segment\".\n            .rev()\n            .find_map(|remapping| match remapping {\n                Remapping::Drhd(drhd) => Some(drhd.register_base_addr()),\n                _ => None,\n            })\n            .expect(\"no DRHD structure found in the DMAR table\");\n        assert_ne!(base_address, 0, \"IOMMU address should not be zero\");\n        debug!(\"IOMMU base address: {:#x?}\", base_address);\n\n        io_mem_builder.remove(base_address as usize..(base_address as usize + PAGE_SIZE));\n        let base = NonNull::new(paddr_to_vaddr(base_address as usize) as *mut u8).unwrap();\n\n        // SAFETY:\n        // - We trust the ACPI tables (as well as the DRHD in them), from which the base address is\n        //   obtained, so it is a valid IOMMU base address.\n        // - `io_mem_builder.remove()` guarantees that we have exclusive ownership of all the IOMMU\n        //   registers.\n        let iommu_regs = unsafe {\n            fault::init(base);\n\n            Self {\n                version: VolatileRef::new_read_only(base.cast::<u32>()),\n                capability: VolatileRef::new_read_only(base.add(0x08).cast::<u64>()),\n                extended_capability: VolatileRef::new_read_only(base.add(0x10).cast::<u64>()),\n                global_command: VolatileRef::new_restricted(\n                    WriteOnly,\n                    base.add(0x18).cast::<u32>(),\n                ),\n                global_status: VolatileRef::new_read_only(base.add(0x1C).cast::<u32>()),\n                root_table_address: VolatileRef::new(base.add(0x20).cast::<u64>()),\n                context_command: VolatileRef::new(base.add(0x28).cast::<u64>()),\n\n                interrupt_remapping_table_addr: VolatileRef::new(base.add(0xb8).cast::<u64>()),\n\n                invalidate: InvalidationRegisters::new(base),\n            }\n        };\n\n        debug!(\"IOMMU registers:{:#x?}\", iommu_regs);\n        debug!(\"IOMMU capability:{:#x?}\", iommu_regs.read_capability());\n        debug!(\n            \"IOMMU extend capability:{:#x?}\",\n            iommu_regs.read_extended_capability()\n        );\n\n        Some(iommu_regs)\n    }",
  "mir": "fn arch::iommu::registers::IommuRegisters::new(_1: &io::io_mem::allocator::IoMemAllocatorBuilder) -> core::option::Option<arch::iommu::registers::IommuRegisters> {\n    let mut _0: core::option::Option<arch::iommu::registers::IommuRegisters>;\n    let  _2: arch::kernel::acpi::dmar::Dmar;\n    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, arch::kernel::acpi::dmar::Dmar>;\n    let mut _4: core::option::Option<arch::kernel::acpi::dmar::Dmar>;\n    let mut _5: isize;\n    let  _6: arch::kernel::acpi::dmar::Dmar;\n    let  _7: log::Level;\n    let mut _8: bool;\n    let mut _9: &log::Level;\n    let mut _10: &log::LevelFilter;\n    let mut _11: bool;\n    let mut _12: &log::Level;\n    let mut _13: &log::LevelFilter;\n    let  _14: log::LevelFilter;\n    let  _15: ();\n    let mut _16: core::fmt::Arguments<'_>;\n    let  _17: (&arch::kernel::acpi::dmar::Dmar,);\n    let mut _18: &arch::kernel::acpi::dmar::Dmar;\n    let  _19: [core::fmt::rt::Argument<'_>; 1];\n    let mut _20: core::fmt::rt::Argument<'_>;\n    let mut _21: &[u8; 13];\n    let  _22: &[core::fmt::rt::Argument<'_>; 1];\n    let  _23: &(&str, &str, &core::panic::Location<'_>);\n    let  _24: (&str, &str, &core::panic::Location<'_>);\n    let mut _25: &str;\n    let  _26: &core::panic::Location<'_>;\n    let  _27: u64;\n    let mut _28: core::option::Option<u64>;\n    let mut _29: &mut core::iter::Rev<core::slice::Iter<'_, arch::kernel::acpi::dmar::Remapping>>;\n    let mut _30: core::iter::Rev<core::slice::Iter<'_, arch::kernel::acpi::dmar::Remapping>>;\n    let mut _31: core::slice::Iter<'_, arch::kernel::acpi::dmar::Remapping>;\n    let mut _32: &arch::kernel::acpi::dmar::Dmar;\n    let mut _33: &str;\n    let mut _34: (&u64, &u64);\n    let mut _35: &u64;\n    let mut _36: &u64;\n    let  _37: &u64;\n    let  _38: &u64;\n    let mut _39: bool;\n    let mut _40: u64;\n    let mut _41: u64;\n    let  _42: core::panicking::AssertKind;\n    let  _43: !;\n    let mut _44: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _45: core::fmt::Arguments<'_>;\n    let  _46: log::Level;\n    let mut _47: bool;\n    let mut _48: &log::Level;\n    let mut _49: &log::LevelFilter;\n    let mut _50: bool;\n    let mut _51: &log::Level;\n    let mut _52: &log::LevelFilter;\n    let  _53: log::LevelFilter;\n    let  _54: ();\n    let mut _55: core::fmt::Arguments<'_>;\n    let  _56: (&u64,);\n    let mut _57: &u64;\n    let  _58: [core::fmt::rt::Argument<'_>; 1];\n    let mut _59: core::fmt::rt::Argument<'_>;\n    let mut _60: &[u8; 27];\n    let  _61: &[core::fmt::rt::Argument<'_>; 1];\n    let  _62: &(&str, &str, &core::panic::Location<'_>);\n    let  _63: (&str, &str, &core::panic::Location<'_>);\n    let mut _64: &str;\n    let  _65: &core::panic::Location<'_>;\n    let  _66: ();\n    let mut _67: core::ops::Range<usize>;\n    let mut _68: usize;\n    let mut _69: usize;\n    let mut _70: usize;\n    let mut _71: (usize, bool);\n    let  _72: core::ptr::NonNull<u8>;\n    let mut _73: core::option::Option<core::ptr::NonNull<u8>>;\n    let mut _74: *mut u8;\n    let mut _75: usize;\n    let mut _76: usize;\n    let  _77: arch::iommu::registers::IommuRegisters;\n    let  _78: ();\n    let mut _79: volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>;\n    let mut _80: core::ptr::NonNull<u32>;\n    let mut _81: volatile::VolatileRef<'_, u64, volatile::access::ReadOnly>;\n    let mut _82: core::ptr::NonNull<u64>;\n    let mut _83: core::ptr::NonNull<u8>;\n    let mut _84: volatile::VolatileRef<'_, u64, volatile::access::ReadOnly>;\n    let mut _85: core::ptr::NonNull<u64>;\n    let mut _86: core::ptr::NonNull<u8>;\n    let mut _87: volatile::VolatileRef<'_, u32, volatile::access::WriteOnly>;\n    let mut _88: core::ptr::NonNull<u32>;\n    let mut _89: core::ptr::NonNull<u8>;\n    let mut _90: volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>;\n    let mut _91: core::ptr::NonNull<u32>;\n    let mut _92: core::ptr::NonNull<u8>;\n    let mut _93: volatile::VolatileRef<'_, u64>;\n    let mut _94: core::ptr::NonNull<u64>;\n    let mut _95: core::ptr::NonNull<u8>;\n    let mut _96: volatile::VolatileRef<'_, u64>;\n    let mut _97: core::ptr::NonNull<u64>;\n    let mut _98: core::ptr::NonNull<u8>;\n    let mut _99: volatile::VolatileRef<'_, u64>;\n    let mut _100: core::ptr::NonNull<u64>;\n    let mut _101: core::ptr::NonNull<u8>;\n    let mut _102: arch::iommu::registers::invalidation::InvalidationRegisters;\n    let  _103: log::Level;\n    let mut _104: bool;\n    let mut _105: &log::Level;\n    let mut _106: &log::LevelFilter;\n    let mut _107: bool;\n    let mut _108: &log::Level;\n    let mut _109: &log::LevelFilter;\n    let  _110: log::LevelFilter;\n    let  _111: ();\n    let mut _112: core::fmt::Arguments<'_>;\n    let  _113: (&arch::iommu::registers::IommuRegisters,);\n    let mut _114: &arch::iommu::registers::IommuRegisters;\n    let  _115: [core::fmt::rt::Argument<'_>; 1];\n    let mut _116: core::fmt::rt::Argument<'_>;\n    let mut _117: &[u8; 23];\n    let  _118: &[core::fmt::rt::Argument<'_>; 1];\n    let  _119: &(&str, &str, &core::panic::Location<'_>);\n    let  _120: (&str, &str, &core::panic::Location<'_>);\n    let mut _121: &str;\n    let  _122: &core::panic::Location<'_>;\n    let  _123: log::Level;\n    let mut _124: bool;\n    let mut _125: &log::Level;\n    let mut _126: &log::LevelFilter;\n    let mut _127: bool;\n    let mut _128: &log::Level;\n    let mut _129: &log::LevelFilter;\n    let  _130: log::LevelFilter;\n    let  _131: ();\n    let mut _132: core::fmt::Arguments<'_>;\n    let  _133: (&arch::iommu::registers::capability::Capability,);\n    let mut _134: &arch::iommu::registers::capability::Capability;\n    let  _135: arch::iommu::registers::capability::Capability;\n    let mut _136: &arch::iommu::registers::IommuRegisters;\n    let  _137: [core::fmt::rt::Argument<'_>; 1];\n    let mut _138: core::fmt::rt::Argument<'_>;\n    let mut _139: &[u8; 24];\n    let  _140: &[core::fmt::rt::Argument<'_>; 1];\n    let  _141: &(&str, &str, &core::panic::Location<'_>);\n    let  _142: (&str, &str, &core::panic::Location<'_>);\n    let mut _143: &str;\n    let  _144: &core::panic::Location<'_>;\n    let  _145: log::Level;\n    let mut _146: bool;\n    let mut _147: &log::Level;\n    let mut _148: &log::LevelFilter;\n    let mut _149: bool;\n    let mut _150: &log::Level;\n    let mut _151: &log::LevelFilter;\n    let  _152: log::LevelFilter;\n    let  _153: ();\n    let mut _154: core::fmt::Arguments<'_>;\n    let  _155: (&arch::iommu::registers::extended_cap::ExtendedCapability,);\n    let mut _156: &arch::iommu::registers::extended_cap::ExtendedCapability;\n    let  _157: arch::iommu::registers::extended_cap::ExtendedCapability;\n    let mut _158: &arch::iommu::registers::IommuRegisters;\n    let  _159: [core::fmt::rt::Argument<'_>; 1];\n    let mut _160: core::fmt::rt::Argument<'_>;\n    let mut _161: &[u8; 31];\n    let  _162: &[core::fmt::rt::Argument<'_>; 1];\n    let  _163: &(&str, &str, &core::panic::Location<'_>);\n    let  _164: (&str, &str, &core::panic::Location<'_>);\n    let mut _165: &str;\n    let  _166: &core::panic::Location<'_>;\n    let mut _167: &arch::kernel::acpi::dmar::Dmar;\n    let mut _168: &u64;\n    let mut _169: &arch::iommu::registers::IommuRegisters;\n    let mut _170: &arch::iommu::registers::capability::Capability;\n    let mut _171: &arch::iommu::registers::extended_cap::ExtendedCapability;\n    debug io_mem_builder => _1;\n    debug dmar => _2;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _6;\n    debug lvl => _7;\n    debug args => _17;\n    debug args => _19;\n    debug base_address => _27;\n    debug left_val => _37;\n    debug right_val => _38;\n    debug kind => _42;\n    debug lvl => _46;\n    debug args => _56;\n    debug args => _58;\n    debug base => _72;\n    debug iommu_regs => _77;\n    debug lvl => _103;\n    debug args => _113;\n    debug args => _115;\n    debug lvl => _123;\n    debug args => _133;\n    debug args => _137;\n    debug lvl => _145;\n    debug args => _155;\n    debug args => _159;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = arch::kernel::acpi::dmar::Dmar::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <core::option::Option<arch::kernel::acpi::dmar::Dmar> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_6);\n        _6 = move ((_3 as variant#0).0: arch::kernel::acpi::dmar::Dmar);\n        _2 = move _6;\n        StorageDead(_6);\n        StorageDead(_3);\n        _7 = log::Level::Debug;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_7;\n        StorageLive(_10);\n        _10 = arch::iommu::registers::IommuRegisters::new::promoted[5];\n        _8 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _9, move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::option::Option<arch::iommu::registers::IommuRegisters> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb107;\n    }\n    bb7: {\n        switchInt(move _8) -> [0: bb17, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_7;\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = log::max_level() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _13 = &_14;\n        _11 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _12, move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _11) -> [0: bb16, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_2;\n        _17 = (move _18);\n        StorageDead(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _167 = (_17.0: &arch::kernel::acpi::dmar::Dmar);\n        _20 = core::fmt::rt::Argument::<'_>::new_debug::<arch::kernel::acpi::dmar::Dmar>(_167) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _19 = [move _20];\n        StorageDead(_20);\n        StorageLive(_21);\n        _21 = b\"\\x06DMAR: \\xc1 \\x00\\x80b\\x00\";\n        _22 = &_19;\n        _16 = core::fmt::Arguments::<'_>::new::<13, 1>(move _21, _22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = \"ostd::arch::iommu::registers\";\n        _26 = log::__private_api::loc() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _24 = (move _25, \"ostd::arch::iommu::registers\", _26);\n        StorageDead(_25);\n        _23 = &_24;\n        _15 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _16, _7, _23, ()) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_16);\n        StorageDead(_24);\n        StorageDead(_19);\n        StorageDead(_17);\n        goto -> bb18;\n    }\n    bb16: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &_2;\n        _31 = arch::kernel::acpi::dmar::Dmar::remapping_iter(move _32) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_32);\n        _30 = <core::slice::Iter<'_, arch::kernel::acpi::dmar::Remapping> as core::iter::Iterator>::rev(move _31) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _29 = &mut _30;\n        StorageDead(_31);\n        _28 = <core::iter::Rev<core::slice::Iter<'_, arch::kernel::acpi::dmar::Remapping>> as core::iter::Iterator>::find_map::<u64, {closure@ostd/src/arch/x86/iommu/registers/mod.rs:281:23: 281:34}>(move _29, ZeroSized: {closure@ostd/src/arch/x86/iommu/registers/mod.rs:281:23: 281:34}) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_29);\n        StorageLive(_33);\n        _33 = \"no DRHD structure found in the DMAR table\";\n        _27 = core::option::Option::<u64>::expect(move _28, move _33) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_33);\n        StorageDead(_28);\n        StorageDead(_30);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_27;\n        StorageLive(_36);\n        _36 = arch::iommu::registers::IommuRegisters::new::promoted[4];\n        _34 = (move _35, move _36);\n        StorageDead(_36);\n        StorageDead(_35);\n        _37 = (_34.0: &u64);\n        _38 = (_34.1: &u64);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = (*_37);\n        StorageLive(_41);\n        _41 = (*_38);\n        _39 = Eq(move _40, move _41);\n        switchInt(move _39) -> [0: bb25, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_41);\n        StorageDead(_40);\n        _42 = core::panicking::AssertKind::Ne;\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = core::fmt::Arguments::<'_>::from_str(\"IOMMU address should not be zero\") -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _44 = core::option::Option::Some(move _45);\n        StorageDead(_45);\n        _43 = core::panicking::assert_failed::<u64, u64>(_42, _37, _38, move _44) -> unwind unreachable;\n    }\n    bb25: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_34);\n        _46 = log::Level::Debug;\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = &_46;\n        StorageLive(_49);\n        _49 = arch::iommu::registers::IommuRegisters::new::promoted[3];\n        _47 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _48, move _49) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _47) -> [0: bb36, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = &_46;\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = log::max_level() -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _52 = &_53;\n        _50 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _51, move _52) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        switchInt(move _50) -> [0: bb35, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageDead(_51);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_27;\n        _56 = (move _57);\n        StorageDead(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        _168 = (_56.0: &u64);\n        _59 = core::fmt::rt::Argument::<'_>::new_debug::<u64>(_168) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _58 = [move _59];\n        StorageDead(_59);\n        StorageLive(_60);\n        _60 = b\"\\x14IOMMU base address: \\xc1 \\x00\\x80b\\x00\";\n        _61 = &_58;\n        _55 = core::fmt::Arguments::<'_>::new::<27, 1>(move _60, _61) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_60);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = \"ostd::arch::iommu::registers\";\n        _65 = log::__private_api::loc() -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        _63 = (move _64, \"ostd::arch::iommu::registers\", _65);\n        StorageDead(_64);\n        _62 = &_63;\n        _54 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _55, _46, _62, ()) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_55);\n        StorageDead(_63);\n        StorageDead(_58);\n        StorageDead(_56);\n        goto -> bb37;\n    }\n    bb35: {\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageDead(_51);\n        goto -> bb37;\n    }\n    bb36: {\n        StorageDead(_49);\n        StorageDead(_48);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_50);\n        StorageDead(_47);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = _27 as usize;\n        StorageLive(_69);\n        StorageLive(_70);\n        _70 = _27 as usize;\n        _71 = CheckedAdd(_70, mm::PAGE_SIZE);\n        assert(!move (_71.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _70, mm::PAGE_SIZE) -> [success: bb38, unwind unreachable];\n    }\n    bb38: {\n        _69 = move (_71.0: usize);\n        StorageDead(_70);\n        _67 = Range(move _68, move _69);\n        StorageDead(_69);\n        StorageDead(_68);\n        _66 = io::io_mem::allocator::IoMemAllocatorBuilder::remove(_1, move _67) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_67);\n        StorageLive(_73);\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = _27 as usize;\n        _75 = mm::kspace::paddr_to_vaddr(move _76) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_76);\n        _74 = move _75 as *mut u8;\n        StorageDead(_75);\n        _73 = core::ptr::NonNull::<u8>::new(move _74) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_74);\n        _72 = core::option::Option::<core::ptr::NonNull<u8>>::unwrap(move _73) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_73);\n        _78 = arch::iommu::fault::init(_72) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = core::ptr::NonNull::<u8>::cast::<u32>(_72) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _79 = volatile::VolatileRef::<'_, u32>::new_read_only(move _80) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_80);\n        StorageLive(_81);\n        StorageLive(_82);\n        StorageLive(_83);\n        _83 = core::ptr::NonNull::<u8>::add(_72, 8_usize) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _82 = core::ptr::NonNull::<u8>::cast::<u64>(move _83) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_83);\n        _81 = volatile::VolatileRef::<'_, u64>::new_read_only(move _82) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_82);\n        StorageLive(_84);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = core::ptr::NonNull::<u8>::add(_72, 16_usize) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _85 = core::ptr::NonNull::<u8>::cast::<u64>(move _86) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_86);\n        _84 = volatile::VolatileRef::<'_, u64>::new_read_only(move _85) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_85);\n        StorageLive(_87);\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = core::ptr::NonNull::<u8>::add(_72, 24_usize) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        _88 = core::ptr::NonNull::<u8>::cast::<u32>(move _89) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_89);\n        _87 = volatile::VolatileRef::<'_, u32>::new_restricted::<volatile::access::WriteOnly>(volatile::access::WriteOnly, move _88) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_88);\n        StorageLive(_90);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = core::ptr::NonNull::<u8>::add(_72, 28_usize) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        _91 = core::ptr::NonNull::<u8>::cast::<u32>(move _92) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_92);\n        _90 = volatile::VolatileRef::<'_, u32>::new_read_only(move _91) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_91);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = core::ptr::NonNull::<u8>::add(_72, 32_usize) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        _94 = core::ptr::NonNull::<u8>::cast::<u64>(move _95) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_95);\n        _93 = volatile::VolatileRef::<'_, u64>::new(move _94) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_94);\n        StorageLive(_96);\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = core::ptr::NonNull::<u8>::add(_72, 40_usize) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        _97 = core::ptr::NonNull::<u8>::cast::<u64>(move _98) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_98);\n        _96 = volatile::VolatileRef::<'_, u64>::new(move _97) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_97);\n        StorageLive(_99);\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = core::ptr::NonNull::<u8>::add(_72, 184_usize) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        _100 = core::ptr::NonNull::<u8>::cast::<u64>(move _101) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        StorageDead(_101);\n        _99 = volatile::VolatileRef::<'_, u64>::new(move _100) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_100);\n        StorageLive(_102);\n        _102 = arch::iommu::registers::invalidation::InvalidationRegisters::new(_72) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        _77 = IommuRegisters(move _79, move _81, move _84, move _87, move _90, move _93, move _96, move _99, move _102);\n        StorageDead(_102);\n        StorageDead(_99);\n        StorageDead(_96);\n        StorageDead(_93);\n        StorageDead(_90);\n        StorageDead(_87);\n        StorageDead(_84);\n        StorageDead(_81);\n        StorageDead(_79);\n        _103 = log::Level::Debug;\n        StorageLive(_104);\n        StorageLive(_105);\n        _105 = &_103;\n        StorageLive(_106);\n        _106 = arch::iommu::registers::IommuRegisters::new::promoted[2];\n        _104 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _105, move _106) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        switchInt(move _104) -> [0: bb78, otherwise: bb69];\n    }\n    bb69: {\n        StorageDead(_106);\n        StorageDead(_105);\n        StorageLive(_107);\n        StorageLive(_108);\n        _108 = &_103;\n        StorageLive(_109);\n        StorageLive(_110);\n        _110 = log::max_level() -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        _109 = &_110;\n        _107 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _108, move _109) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        switchInt(move _107) -> [0: bb77, otherwise: bb72];\n    }\n    bb72: {\n        StorageDead(_110);\n        StorageDead(_109);\n        StorageDead(_108);\n        StorageLive(_112);\n        StorageLive(_113);\n        StorageLive(_114);\n        _114 = &_77;\n        _113 = (move _114);\n        StorageDead(_114);\n        StorageLive(_115);\n        StorageLive(_116);\n        _169 = (_113.0: &arch::iommu::registers::IommuRegisters);\n        _116 = core::fmt::rt::Argument::<'_>::new_debug::<arch::iommu::registers::IommuRegisters>(_169) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        _115 = [move _116];\n        StorageDead(_116);\n        StorageLive(_117);\n        _117 = b\"\\x10IOMMU registers:\\xc1 \\x00\\x80b\\x00\";\n        _118 = &_115;\n        _112 = core::fmt::Arguments::<'_>::new::<23, 1>(move _117, _118) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_117);\n        StorageLive(_120);\n        StorageLive(_121);\n        _121 = \"ostd::arch::iommu::registers\";\n        _122 = log::__private_api::loc() -> [return: bb75, unwind unreachable];\n    }\n    bb75: {\n        _120 = (move _121, \"ostd::arch::iommu::registers\", _122);\n        StorageDead(_121);\n        _119 = &_120;\n        _111 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _112, _103, _119, ()) -> [return: bb76, unwind unreachable];\n    }\n    bb76: {\n        StorageDead(_112);\n        StorageDead(_120);\n        StorageDead(_115);\n        StorageDead(_113);\n        goto -> bb79;\n    }\n    bb77: {\n        StorageDead(_110);\n        StorageDead(_109);\n        StorageDead(_108);\n        goto -> bb79;\n    }\n    bb78: {\n        StorageDead(_106);\n        StorageDead(_105);\n        goto -> bb79;\n    }\n    bb79: {\n        StorageDead(_107);\n        StorageDead(_104);\n        _123 = log::Level::Debug;\n        StorageLive(_124);\n        StorageLive(_125);\n        _125 = &_123;\n        StorageLive(_126);\n        _126 = arch::iommu::registers::IommuRegisters::new::promoted[1];\n        _124 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _125, move _126) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        switchInt(move _124) -> [0: bb91, otherwise: bb81];\n    }\n    bb81: {\n        StorageDead(_126);\n        StorageDead(_125);\n        StorageLive(_127);\n        StorageLive(_128);\n        _128 = &_123;\n        StorageLive(_129);\n        StorageLive(_130);\n        _130 = log::max_level() -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        _129 = &_130;\n        _127 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _128, move _129) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        switchInt(move _127) -> [0: bb90, otherwise: bb84];\n    }\n    bb84: {\n        StorageDead(_130);\n        StorageDead(_129);\n        StorageDead(_128);\n        StorageLive(_132);\n        StorageLive(_133);\n        StorageLive(_134);\n        StorageLive(_135);\n        StorageLive(_136);\n        _136 = &_77;\n        _135 = arch::iommu::registers::IommuRegisters::read_capability(move _136) -> [return: bb85, unwind unreachable];\n    }\n    bb85: {\n        StorageDead(_136);\n        _134 = &_135;\n        _133 = (move _134);\n        StorageDead(_134);\n        StorageLive(_137);\n        StorageLive(_138);\n        _170 = (_133.0: &arch::iommu::registers::capability::Capability);\n        _138 = core::fmt::rt::Argument::<'_>::new_debug::<arch::iommu::registers::capability::Capability>(_170) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        _137 = [move _138];\n        StorageDead(_138);\n        StorageLive(_139);\n        _139 = b\"\\x11IOMMU capability:\\xc1 \\x00\\x80b\\x00\";\n        _140 = &_137;\n        _132 = core::fmt::Arguments::<'_>::new::<24, 1>(move _139, _140) -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        StorageDead(_139);\n        StorageLive(_142);\n        StorageLive(_143);\n        _143 = \"ostd::arch::iommu::registers\";\n        _144 = log::__private_api::loc() -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        _142 = (move _143, \"ostd::arch::iommu::registers\", _144);\n        StorageDead(_143);\n        _141 = &_142;\n        _131 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _132, _123, _141, ()) -> [return: bb89, unwind unreachable];\n    }\n    bb89: {\n        StorageDead(_132);\n        StorageDead(_142);\n        StorageDead(_137);\n        StorageDead(_135);\n        StorageDead(_133);\n        goto -> bb92;\n    }\n    bb90: {\n        StorageDead(_130);\n        StorageDead(_129);\n        StorageDead(_128);\n        goto -> bb92;\n    }\n    bb91: {\n        StorageDead(_126);\n        StorageDead(_125);\n        goto -> bb92;\n    }\n    bb92: {\n        StorageDead(_127);\n        StorageDead(_124);\n        _145 = log::Level::Debug;\n        StorageLive(_146);\n        StorageLive(_147);\n        _147 = &_145;\n        StorageLive(_148);\n        _148 = arch::iommu::registers::IommuRegisters::new::promoted[0];\n        _146 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _147, move _148) -> [return: bb93, unwind unreachable];\n    }\n    bb93: {\n        switchInt(move _146) -> [0: bb104, otherwise: bb94];\n    }\n    bb94: {\n        StorageDead(_148);\n        StorageDead(_147);\n        StorageLive(_149);\n        StorageLive(_150);\n        _150 = &_145;\n        StorageLive(_151);\n        StorageLive(_152);\n        _152 = log::max_level() -> [return: bb95, unwind unreachable];\n    }\n    bb95: {\n        _151 = &_152;\n        _149 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _150, move _151) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        switchInt(move _149) -> [0: bb103, otherwise: bb97];\n    }\n    bb97: {\n        StorageDead(_152);\n        StorageDead(_151);\n        StorageDead(_150);\n        StorageLive(_154);\n        StorageLive(_155);\n        StorageLive(_156);\n        StorageLive(_157);\n        StorageLive(_158);\n        _158 = &_77;\n        _157 = arch::iommu::registers::IommuRegisters::read_extended_capability(move _158) -> [return: bb98, unwind unreachable];\n    }\n    bb98: {\n        StorageDead(_158);\n        _156 = &_157;\n        _155 = (move _156);\n        StorageDead(_156);\n        StorageLive(_159);\n        StorageLive(_160);\n        _171 = (_155.0: &arch::iommu::registers::extended_cap::ExtendedCapability);\n        _160 = core::fmt::rt::Argument::<'_>::new_debug::<arch::iommu::registers::extended_cap::ExtendedCapability>(_171) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        _159 = [move _160];\n        StorageDead(_160);\n        StorageLive(_161);\n        _161 = b\"\\x18IOMMU extend capability:\\xc1 \\x00\\x80b\\x00\";\n        _162 = &_159;\n        _154 = core::fmt::Arguments::<'_>::new::<31, 1>(move _161, _162) -> [return: bb100, unwind unreachable];\n    }\n    bb100: {\n        StorageDead(_161);\n        StorageLive(_164);\n        StorageLive(_165);\n        _165 = \"ostd::arch::iommu::registers\";\n        _166 = log::__private_api::loc() -> [return: bb101, unwind unreachable];\n    }\n    bb101: {\n        _164 = (move _165, \"ostd::arch::iommu::registers\", _166);\n        StorageDead(_165);\n        _163 = &_164;\n        _153 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _154, _145, _163, ()) -> [return: bb102, unwind unreachable];\n    }\n    bb102: {\n        StorageDead(_154);\n        StorageDead(_164);\n        StorageDead(_159);\n        StorageDead(_157);\n        StorageDead(_155);\n        goto -> bb105;\n    }\n    bb103: {\n        StorageDead(_152);\n        StorageDead(_151);\n        StorageDead(_150);\n        goto -> bb105;\n    }\n    bb104: {\n        StorageDead(_148);\n        StorageDead(_147);\n        goto -> bb105;\n    }\n    bb105: {\n        StorageDead(_149);\n        StorageDead(_146);\n        _0 = core::option::Option::Some(_77);\n        drop(_2) -> [return: bb106, unwind unreachable];\n    }\n    bb106: {\n        StorageDead(_2);\n        goto -> bb107;\n    }\n    bb107: {\n        return;\n    }\n}\n",
  "doc": " Creates an instance from base address\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}