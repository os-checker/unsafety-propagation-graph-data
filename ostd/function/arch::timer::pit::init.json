{
  "name": "arch::timer::pit::init",
  "safe": true,
  "callees": {
    "io::io_port::IoPort::<T, A>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes to the I/O port\n",
      "adt": {
        "io::io_port::IoPort": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "io::io_port::IoPort": [
      "Ref"
    ],
    "arch::timer::pit::OperatingMode": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::timer::pit::init"
  },
  "span": "ostd/src/arch/x86/timer/pit.rs:171:1: 184:2",
  "src": "pub(crate) fn init(operating_mode: OperatingMode) {\n    // Set PIT mode\n    // Bit 0 is BCD/binary mode, which is always set to binary mode(value: 0)\n    MODE_COMMAND_PORT.write(\n        ((operating_mode as u8) << 1)\n            | ((AccessMode::LowAndHighByte as u8) << 4)\n            | ((Channel::Channel0 as u8) << 6),\n    );\n\n    // Set timer frequency\n    const CYCLE: u32 = TIMER_RATE / TIMER_FREQ as u32;\n    CHANNEL0_PORT.write((CYCLE & 0xFF) as _);\n    CHANNEL0_PORT.write((CYCLE >> 8) as _);\n}",
  "mir": "fn arch::timer::pit::init(_1: arch::timer::pit::OperatingMode) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: &io::io_port::IoPort<u8, x86_64::instructions::port::WriteOnlyAccess>;\n    let mut _4: u8;\n    let mut _5: u8;\n    let mut _6: u8;\n    let mut _7: u8;\n    let mut _8: u32;\n    let mut _9: bool;\n    let mut _10: u8;\n    let mut _11: u8;\n    let mut _12: (u8, bool);\n    let mut _13: u32;\n    let mut _14: bool;\n    let mut _15: u8;\n    let mut _16: u8;\n    let mut _17: (u8, bool);\n    let mut _18: u32;\n    let mut _19: bool;\n    let  _20: ();\n    let mut _21: &io::io_port::IoPort<u8, x86_64::instructions::port::WriteOnlyAccess>;\n    let mut _22: u8;\n    let mut _23: u32;\n    let  _24: ();\n    let mut _25: &io::io_port::IoPort<u8, x86_64::instructions::port::WriteOnlyAccess>;\n    let mut _26: u8;\n    let mut _27: u32;\n    let mut _28: u32;\n    let mut _29: bool;\n    debug operating_mode => _1;\n    bb0: {\n        StorageLive(_3);\n        _3 = {alloc593: &io::io_port::IoPort<u8, x86_64::instructions::port::WriteOnlyAccess>};\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _7 = discriminant(_1);\n        _8 = 1_i32 as u32;\n        _9 = Lt(move _8, 8_u32);\n        assert(move _9, \"attempt to shift left by `{}`, which would overflow\", 1_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = Shl(_7, 1_i32);\n        StorageLive(_10);\n        _12 = CheckedAdd(arch::timer::pit::AccessMode::LowAndHighByte::{constant#0}, 0_u8);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", arch::timer::pit::AccessMode::LowAndHighByte::{constant#0}, 0_u8) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _11 = move (_12.0: u8);\n        _13 = 4_i32 as u32;\n        _14 = Lt(move _13, 8_u32);\n        assert(move _14, \"attempt to shift left by `{}`, which would overflow\", 4_i32) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _10 = Shl(_11, 4_i32);\n        _5 = BitOr(move _6, move _10);\n        StorageDead(_10);\n        StorageDead(_6);\n        StorageLive(_15);\n        _17 = CheckedAdd(arch::timer::pit::Channel::Channel0::{constant#0}, 0_u8);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", arch::timer::pit::Channel::Channel0::{constant#0}, 0_u8) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _16 = move (_17.0: u8);\n        _18 = 6_i32 as u32;\n        _19 = Lt(move _18, 8_u32);\n        assert(move _19, \"attempt to shift left by `{}`, which would overflow\", 6_i32) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _15 = Shl(_16, 6_i32);\n        _4 = BitOr(move _5, move _15);\n        StorageDead(_15);\n        StorageDead(_5);\n        _2 = io::io_port::IoPort::<u8, x86_64::instructions::port::WriteOnlyAccess>::write(move _3, move _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_21);\n        _21 = {alloc581: &io::io_port::IoPort<u8, x86_64::instructions::port::WriteOnlyAccess>};\n        StorageLive(_23);\n        _23 = BitAnd(arch::timer::pit::init::CYCLE, 255_u32);\n        _22 = move _23 as u8;\n        StorageDead(_23);\n        _20 = io::io_port::IoPort::<u8, x86_64::instructions::port::WriteOnlyAccess>::write(move _21, _22) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_21);\n        StorageLive(_25);\n        _25 = {alloc581: &io::io_port::IoPort<u8, x86_64::instructions::port::WriteOnlyAccess>};\n        StorageLive(_27);\n        _28 = 8_i32 as u32;\n        _29 = Lt(move _28, 32_u32);\n        assert(move _29, \"attempt to shift right by `{}`, which would overflow\", 8_i32) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _27 = Shr(arch::timer::pit::init::CYCLE, 8_i32);\n        _26 = move _27 as u8;\n        StorageDead(_27);\n        _24 = io::io_port::IoPort::<u8, x86_64::instructions::port::WriteOnlyAccess>::write(move _25, _26) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_25);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}