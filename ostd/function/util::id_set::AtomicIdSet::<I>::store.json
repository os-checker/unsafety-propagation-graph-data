{
  "name": "util::id_set::AtomicIdSet::<I>::store",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::zip": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " 'Zips up' two iterators into a single iterator of pairs.\n\n `zip()` returns a new iterator that will iterate over two other\n iterators, returning a tuple where the first element comes from the\n first iterator, and the second element comes from the second iterator.\n\n In other words, it zips two iterators together, into a single one.\n\n If either iterator returns [`None`], [`next`] from the zipped iterator\n will return [`None`].\n If the zipped iterator has no more elements to return then each further attempt to advance\n it will first try to advance the first iterator at most one time and if it still yielded an item\n try to advance the second iterator at most one time.\n\n To 'undo' the result of zipping up two iterators, see [`unzip`].\n\n [`unzip`]: Iterator::unzip\n\n # Examples\n\n Basic usage:\n\n ```\n let s1 = \"abc\".chars();\n let s2 = \"def\".chars();\n\n let mut iter = s1.zip(s2);\n\n assert_eq!(iter.next(), Some(('a', 'd')));\n assert_eq!(iter.next(), Some(('b', 'e')));\n assert_eq!(iter.next(), Some(('c', 'f')));\n assert_eq!(iter.next(), None);\n ```\n\n Since the argument to `zip()` uses [`IntoIterator`], we can pass\n anything that can be converted into an [`Iterator`], not just an\n [`Iterator`] itself. For example, arrays (`[T]`) implement\n [`IntoIterator`], and so can be passed to `zip()` directly:\n\n ```\n let a1 = [1, 2, 3];\n let a2 = [4, 5, 6];\n\n let mut iter = a1.into_iter().zip(a2);\n\n assert_eq!(iter.next(), Some((1, 4)));\n assert_eq!(iter.next(), Some((2, 5)));\n assert_eq!(iter.next(), Some((3, 6)));\n assert_eq!(iter.next(), None);\n ```\n\n `zip()` is often used to zip an infinite iterator to a finite one.\n This works because the finite iterator will eventually return [`None`],\n ending the zipper. Zipping with `(0..)` can look a lot like [`enumerate`]:\n\n ```\n let enumerate: Vec<_> = \"foo\".chars().enumerate().collect();\n\n let zipper: Vec<_> = (0..).zip(\"foo\".chars()).collect();\n\n assert_eq!((0, 'f'), enumerate[0]);\n assert_eq!((0, 'f'), zipper[0]);\n\n assert_eq!((1, 'o'), enumerate[1]);\n assert_eq!((1, 'o'), zipper[1]);\n\n assert_eq!((2, 'o'), enumerate[2]);\n assert_eq!((2, 'o'), zipper[2]);\n ```\n\n If both iterators have roughly equivalent syntax, it may be more readable to use [`zip`]:\n\n ```\n use std::iter::zip;\n\n let a = [1, 2, 3];\n let b = [2, 3, 4];\n\n let mut zipped = zip(\n     a.into_iter().map(|x| x * 2).skip(1),\n     b.into_iter().map(|x| x * 2).skip(1),\n );\n\n assert_eq!(zipped.next(), Some((4, 6)));\n assert_eq!(zipped.next(), Some((6, 8)));\n assert_eq!(zipped.next(), None);\n ```\n\n compared to:\n\n ```\n # let a = [1, 2, 3];\n # let b = [2, 3, 4];\n #\n let mut zipped = a\n     .into_iter()\n     .map(|x| x * 2)\n     .skip(1)\n     .zip(b.into_iter().map(|x| x * 2).skip(1));\n #\n # assert_eq!(zipped.next(), Some((4, 6)));\n # assert_eq!(zipped.next(), Some((6, 8)));\n # assert_eq!(zipped.next(), None);\n ```\n\n [`enumerate`]: Iterator::enumerate\n [`next`]: Iterator::next\n [`zip`]: crate::iter::zip\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU64::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "smallvec::SmallVec": [
      "Ref"
    ],
    "util::id_set::AtomicIdSet": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "util::id_set::IdSet": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::iter::Zip": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7874, kind: RigidTy(Tuple([Ty { id: 2400, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2404, kind: RigidTy(Adt(AdtDef(DefId { id: 4239, name: \"core::sync::atomic::AtomicU64\" }), GenericArgs([]))) }, Not)) }, Ty { id: 711, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 59, kind: RigidTy(Uint(U64)) }, Not)) }])) }), Field(0, Ty { id: 2400, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2404, kind: RigidTy(Adt(AdtDef(DefId { id: 4239, name: \"core::sync::atomic::AtomicU64\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7874, kind: RigidTy(Tuple([Ty { id: 2400, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2404, kind: RigidTy(Adt(AdtDef(DefId { id: 4239, name: \"core::sync::atomic::AtomicU64\" }), GenericArgs([]))) }, Not)) }, Ty { id: 711, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 59, kind: RigidTy(Uint(U64)) }, Not)) }])) }), Field(1, Ty { id: 711, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 59, kind: RigidTy(Uint(U64)) }, Not)) })])"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::util::id_set::AtomicIdSet::<I>::store"
  },
  "span": "ostd/src/util/id_set.rs:401:5: 405:6",
  "src": "pub fn store(&self, value: &IdSet<I>, ordering: Ordering) {\n        for (part, new_part) in self.bits.iter().zip(value.bits.iter()) {\n            part.store(*new_part, ordering);\n        }\n    }",
  "mir": "fn util::id_set::AtomicIdSet::<I>::store(_1: &util::id_set::AtomicIdSet<I>, _2: &util::id_set::IdSet<I>, _3: core::sync::atomic::Ordering) -> () {\n    let mut _0: ();\n    let mut _4: core::iter::Zip<core::slice::Iter<'_, core::sync::atomic::AtomicU64>, core::slice::Iter<'_, u64>>;\n    let mut _5: core::iter::Zip<core::slice::Iter<'_, core::sync::atomic::AtomicU64>, core::slice::Iter<'_, u64>>;\n    let mut _6: core::slice::Iter<'_, core::sync::atomic::AtomicU64>;\n    let  _7: &[core::sync::atomic::AtomicU64];\n    let mut _8: &smallvec::SmallVec<[core::sync::atomic::AtomicU64; 2]>;\n    let mut _9: core::slice::Iter<'_, u64>;\n    let  _10: &[u64];\n    let mut _11: &smallvec::SmallVec<[u64; 2]>;\n    let mut _12: core::iter::Zip<core::slice::Iter<'_, core::sync::atomic::AtomicU64>, core::slice::Iter<'_, u64>>;\n    let mut _13: core::option::Option<(&core::sync::atomic::AtomicU64, &u64)>;\n    let mut _14: &mut core::iter::Zip<core::slice::Iter<'_, core::sync::atomic::AtomicU64>, core::slice::Iter<'_, u64>>;\n    let mut _15: isize;\n    let  _16: &core::sync::atomic::AtomicU64;\n    let  _17: &u64;\n    let  _18: ();\n    let mut _19: u64;\n    debug self => _1;\n    debug value => _2;\n    debug ordering => _3;\n    debug iter => _12;\n    debug part => _16;\n    debug new_part => _17;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_8);\n        _8 = &((*_1).0: smallvec::SmallVec<[core::sync::atomic::AtomicU64; 2]>);\n        _7 = <smallvec::SmallVec<[core::sync::atomic::AtomicU64; 2]> as core::ops::Deref>::deref(move _8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_8);\n        _6 = core::slice::<impl [core::sync::atomic::AtomicU64]>::iter(_7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_9);\n        StorageLive(_11);\n        _11 = &((*_2).0: smallvec::SmallVec<[u64; 2]>);\n        _10 = <smallvec::SmallVec<[u64; 2]> as core::ops::Deref>::deref(move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _9 = core::slice::<impl [u64]>::iter(_10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _5 = <core::slice::Iter<'_, core::sync::atomic::AtomicU64> as core::iter::Iterator>::zip::<core::slice::Iter<'_, u64>>(move _6, move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_6);\n        _4 = <core::iter::Zip<core::slice::Iter<'_, core::sync::atomic::AtomicU64>, core::slice::Iter<'_, u64>> as core::iter::IntoIterator>::into_iter(move _5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        StorageLive(_12);\n        _12 = move _4;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_13);\n        _14 = &mut _12;\n        _13 = <core::iter::Zip<core::slice::Iter<'_, core::sync::atomic::AtomicU64>, core::slice::Iter<'_, u64>> as core::iter::Iterator>::next(_14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = discriminant(_13);\n        switchInt(move _15) -> [0: bb11, 1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        _16 = (((_13 as variant#1).0: (&core::sync::atomic::AtomicU64, &u64)).0: &core::sync::atomic::AtomicU64);\n        StorageLive(_17);\n        _17 = (((_13 as variant#1).0: (&core::sync::atomic::AtomicU64, &u64)).1: &u64);\n        StorageLive(_19);\n        _19 = (*_17);\n        _18 = core::sync::atomic::AtomicU64::store(_16, move _19, _3) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_4);\n        return;\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_17);\n        StorageDead(_13);\n        goto -> bb7;\n    }\n}\n",
  "doc": " Stores a new value to the set with the given ordering.\n\n This operation is not atomic. When racing with a [`Self::load`]\n operation, that load may return a set that contains a portion of the\n new value and a portion of the old value. Load on each specific\n word is atomic, and follows the specified ordering.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}