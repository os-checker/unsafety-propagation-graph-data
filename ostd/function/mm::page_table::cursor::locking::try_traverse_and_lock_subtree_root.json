{
  "name": "mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root",
  "safe": true,
  "callees": {
    "mm::mem_obj::HasPaddr::paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the start physical address of the memory object.\n",
      "adt": {}
    },
    "core::ops::RangeInclusive::<Idx>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new inclusive range. Equivalent to writing `start..=end`.\n\n # Examples\n\n ```\n use std::ops::RangeInclusive;\n\n assert_eq!(3..=5, RangeInclusive::new(3, 5));\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::page_table::pte_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The index of a VA's PTE in a page table node at the given level.\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "mm::page_table::load_pte": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a page table entry with an atomic instruction.\n\n # Safety\n\n The safety preconditions are same as those of [`AtomicUsize::from_ptr`].\n",
      "adt": {}
    },
    "mm::page_table::PageTableEntryTrait::is_present": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns if the PTE points to something.\n\n For PTEs created by [`Self::new_absent`], this method should return\n false. For PTEs created by [`Self::new_page`] or [`Self::new_pt`]\n and modified with [`Self::set_prop`], this method should return true.\n",
      "adt": {}
    },
    "mm::page_table::PageTableEntryTrait::is_last": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns if the PTE maps a page rather than a child page table.\n\n The method needs to know the level of the page table where the PTE resides,\n since architectures like x86-64 have a huge bit only in intermediate levels.\n",
      "adt": {}
    },
    "mm::page_table::PageTableEntryTrait::paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the physical address from the PTE.\n\n The physical address recorded in the PTE is either:\n - the physical address of the next-level page table, or\n - the physical address of the page that the PTE maps to.\n",
      "adt": {}
    },
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "mm::page_table::node::PageTableGuard::<'rcu, C>::stray_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns if the page table node is detached from its parent.\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "MutableAsArgument"
      }
    },
    "mm::page_table::node::PageTableGuard::<'rcu, C>::entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows an entry in the node at a given index.\n\n # Panics\n\n Panics if the index is not within the bound of\n [`nr_subpage_per_huge<C>`].\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "MutableAsArgument",
        "mm::page_table::node::entry::Entry": "Constructor"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns if the entry does not map to anything.\n",
      "adt": {
        "mm::page_table::node::entry::Entry": "ImmutableAsArgument"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::alloc_if_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a new child page table node and replaces the entry with it.\n\n If the old entry is not none, the operation will fail and return `None`.\n Otherwise, the lock guard of the new child page table node is returned.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "mm::page_table::node::PageTableGuard": "Constructor",
        "mm::page_table::node::entry::Entry": "MutableAsArgument"
      }
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::is_node": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns if the entry maps to a page table node.\n",
      "adt": {
        "mm::page_table::node::entry::Entry": "ImmutableAsArgument"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::to_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a reference to the child.\n",
      "adt": {
        "mm::page_table::node::entry::Entry": "ImmutableAsArgument",
        "mm::page_table::node::child::ChildRef": "Constructor"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "MutRef"
    ],
    "mm::frame::Frame": [
      "Ref"
    ],
    "mm::page_table::PageTable": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::ops::RangeInclusive": [
      "Plain"
    ],
    "core::iter::Rev": [
      "Plain",
      "MutRef"
    ],
    "core::ops::Range": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "mm::page_table::node::PageTableGuard": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "mm::page_table::node::entry::Entry": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "mm::frame::frame_ref::FrameRef": [
      "Ref",
      "Plain"
    ],
    "mm::page_table::node::child::ChildRef": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 5653, kind: RigidTy(Adt(AdtDef(DefId { id: 5173, name: \"mm::frame::frame_ref::FrameRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 5429, kind: RigidTy(Adt(AdtDef(DefId { id: 5364, name: \"mm::page_table::node::PageTablePageMeta\" }), GenericArgs([Type(Ty { id: 1032, kind: Param(ParamTy { index: 0, name: \"C\" }) })]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root"
  },
  "span": "ostd/src/mm/page_table/cursor/locking.rs:90:1: 162:2",
  "src": "fn try_traverse_and_lock_subtree_root<'rcu, C: PageTableConfig>(\n    pt: &PageTable<C>,\n    guard: &'rcu dyn InAtomicMode,\n    va: &Range<Vaddr>,\n) -> Option<PageTableGuard<'rcu, C>> {\n    let mut cur_node_guard: Option<PageTableGuard<C>> = None;\n    let mut cur_pt_addr = pt.root.paddr();\n    for cur_level in (1..=C::NR_LEVELS).rev() {\n        let start_idx = pte_index::<C>(va.start, cur_level);\n        let level_too_high = {\n            let end_idx = pte_index::<C>(va.end - 1, cur_level);\n            cur_level > 1 && start_idx == end_idx\n        };\n        if !level_too_high {\n            break;\n        }\n\n        let cur_pt_ptr = paddr_to_vaddr(cur_pt_addr) as *mut C::E;\n        // SAFETY:\n        //  - The page table node is alive because (1) the root node is alive and\n        //    (2) all child nodes cannot be recycled because we're in the RCU critical section.\n        //  - The index is inside the bound, so the page table entry is valid.\n        //  - All page table entries are aligned and accessed with atomic operations only.\n        let cur_pte = unsafe { load_pte(cur_pt_ptr.add(start_idx), Ordering::Acquire) };\n\n        if cur_pte.is_present() {\n            if cur_pte.is_last(cur_level) {\n                break;\n            }\n            cur_pt_addr = cur_pte.paddr();\n            cur_node_guard = None;\n            continue;\n        }\n\n        // In case the child is absent, we should lock and allocate a new page table node.\n        let mut pt_guard = cur_node_guard.take().unwrap_or_else(|| {\n            // SAFETY: The node must be alive for at least `'rcu` since the\n            // address is read from the page table node.\n            let node_ref = unsafe { PageTableNodeRef::<'rcu, C>::borrow_paddr(cur_pt_addr) };\n            node_ref.lock(guard)\n        });\n        if *pt_guard.stray_mut() {\n            return None;\n        }\n\n        let mut cur_entry = pt_guard.entry(start_idx);\n        if cur_entry.is_none() {\n            let allocated_guard = cur_entry.alloc_if_none(guard).unwrap();\n            cur_pt_addr = allocated_guard.paddr();\n            cur_node_guard = Some(allocated_guard);\n        } else if cur_entry.is_node() {\n            let ChildRef::PageTable(pt) = cur_entry.to_ref() else {\n                unreachable!();\n            };\n            cur_pt_addr = pt.paddr();\n            cur_node_guard = None;\n        } else {\n            break;\n        }\n    }\n\n    let mut pt_guard = cur_node_guard.unwrap_or_else(|| {\n        // SAFETY: The node must be alive for at least `'rcu` since the\n        // address is read from the page table node.\n        let node_ref = unsafe { PageTableNodeRef::<'rcu, C>::borrow_paddr(cur_pt_addr) };\n        node_ref.lock(guard)\n    });\n    if *pt_guard.stray_mut() {\n        return None;\n    }\n\n    Some(pt_guard)\n}",
  "mir": "fn mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root(_1: &mm::page_table::PageTable<C>, _2: &dyn task::atomic_mode::InAtomicMode, _3: &core::ops::Range<usize>) -> core::option::Option<mm::page_table::node::PageTableGuard<'_, C>> {\n    let mut _0: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _4: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _5: usize;\n    let mut _6: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _7: core::iter::Rev<core::ops::RangeInclusive<u8>>;\n    let mut _8: core::iter::Rev<core::ops::RangeInclusive<u8>>;\n    let mut _9: core::ops::RangeInclusive<u8>;\n    let mut _10: core::iter::Rev<core::ops::RangeInclusive<u8>>;\n    let mut _11: core::option::Option<u8>;\n    let mut _12: &mut core::iter::Rev<core::ops::RangeInclusive<u8>>;\n    let mut _13: isize;\n    let  _14: u8;\n    let  _15: usize;\n    let mut _16: usize;\n    let  _17: bool;\n    let  _18: usize;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: bool;\n    let mut _23: bool;\n    let mut _24: *mut <C as mm::page_table::PageTableConfig>::E;\n    let mut _25: usize;\n    let mut _26: usize;\n    let  _27: <C as mm::page_table::PageTableConfig>::E;\n    let mut _28: *mut <C as mm::page_table::PageTableConfig>::E;\n    let mut _29: core::sync::atomic::Ordering;\n    let mut _30: bool;\n    let mut _31: &<C as mm::page_table::PageTableConfig>::E;\n    let mut _32: bool;\n    let mut _33: &<C as mm::page_table::PageTableConfig>::E;\n    let mut _34: usize;\n    let mut _35: &<C as mm::page_table::PageTableConfig>::E;\n    let mut _36: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _37: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _38: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _39: &mut core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _40: {closure@ostd/src/mm/page_table/cursor/locking.rs:125:65: 125:67};\n    let mut _41: &usize;\n    let mut _42: bool;\n    let mut _43: &mut bool;\n    let mut _44: &mut mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _45: mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _46: &mut mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _47: bool;\n    let mut _48: &mm::page_table::node::entry::Entry<'_, '_, C>;\n    let  _49: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _50: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _51: &mut mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _52: usize;\n    let  _53: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    let  _54: &mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _55: &mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _56: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _57: bool;\n    let mut _58: &mm::page_table::node::entry::Entry<'_, '_, C>;\n    let  _59: !;\n    let  _60: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _61: mm::page_table::node::child::ChildRef<'_, C>;\n    let mut _62: &mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _63: isize;\n    let mut _64: usize;\n    let  _65: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _66: &mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _67: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _68: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _69: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _70: {closure@ostd/src/mm/page_table/cursor/locking.rs:151:54: 151:56};\n    let mut _71: &usize;\n    let mut _72: bool;\n    let mut _73: &mut bool;\n    let mut _74: &mut mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _75: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _76: bool;\n    debug pt => _1;\n    debug guard => _2;\n    debug va => _3;\n    debug cur_node_guard => _4;\n    debug cur_pt_addr => _5;\n    debug iter => _10;\n    debug cur_level => _14;\n    debug start_idx => _15;\n    debug level_too_high => _17;\n    debug end_idx => _18;\n    debug cur_pt_ptr => _24;\n    debug cur_pte => _27;\n    debug pt_guard => _37;\n    debug cur_entry => _45;\n    debug allocated_guard => _49;\n    debug pt => _60;\n    debug pt_guard => _68;\n    bb0: {\n        _76 = false;\n        StorageLive(_4);\n        _76 = true;\n        _4 = core::option::Option::None;\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &((*_1).0: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>);\n        _5 = <mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>> as mm::mem_obj::HasPaddr>::paddr(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::ops::RangeInclusive::<u8>::new(1_u8, <C as mm::PagingConstsTrait>::NR_LEVELS) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = <core::ops::RangeInclusive<u8> as core::iter::Iterator>::rev(move _9) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        _7 = <core::iter::Rev<core::ops::RangeInclusive<u8>> as core::iter::IntoIterator>::into_iter(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = move _7;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_11);\n        _12 = &mut _10;\n        _11 = <core::iter::Rev<core::ops::RangeInclusive<u8>> as core::iter::Iterator>::next(_12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb57, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _14 = ((_11 as variant#1).0: u8);\n        StorageLive(_16);\n        _16 = ((*_3).0: usize);\n        _15 = mm::page_table::pte_index::<C>(move _16, _14) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = ((*_3).1: usize);\n        _21 = CheckedSub(_20, 1_usize);\n        assert(!move (_21.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _20, 1_usize) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _19 = move (_21.0: usize);\n        StorageDead(_20);\n        _18 = mm::page_table::pte_index::<C>(move _19, _14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = Gt(_14, 1_u8);\n        switchInt(move _22) -> [0: bb13, otherwise: bb12];\n    }\n    bb12: {\n        _17 = Eq(_15, _18);\n        goto -> bb14;\n    }\n    bb13: {\n        _17 = false;\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = _17;\n        switchInt(move _23) -> [0: bb15, otherwise: bb16];\n    }\n    bb15: {\n        StorageDead(_23);\n        goto -> bb56;\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = _5;\n        _25 = mm::kspace::paddr_to_vaddr(move _26) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_26);\n        _24 = move _25 as *mut <C as mm::page_table::PageTableConfig>::E;\n        StorageDead(_25);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = core::ptr::mut_ptr::<impl *mut <C as mm::page_table::PageTableConfig>::E>::add(_24, _15) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_29);\n        _29 = core::sync::atomic::Ordering::Acquire;\n        _27 = mm::page_table::load_pte::<<C as mm::page_table::PageTableConfig>::E>(move _28, move _29) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &_27;\n        _30 = <<C as mm::page_table::PageTableConfig>::E as mm::page_table::PageTableEntryTrait>::is_present(move _31) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        switchInt(move _30) -> [0: bb27, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_27;\n        _32 = <<C as mm::page_table::PageTableConfig>::E as mm::page_table::PageTableEntryTrait>::is_last(move _33, _14) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _32) -> [0: bb24, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_30);\n        goto -> bb55;\n    }\n    bb24: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_27;\n        _34 = <<C as mm::page_table::PageTableConfig>::E as mm::page_table::PageTableEntryTrait>::paddr(move _35) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_35);\n        _5 = move _34;\n        StorageDead(_34);\n        StorageLive(_36);\n        _36 = core::option::Option::None;\n        drop(_4) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _76 = true;\n        _4 = move _36;\n        StorageDead(_36);\n        StorageDead(_30);\n        StorageDead(_27);\n        StorageDead(_17);\n        StorageDead(_11);\n        goto -> bb5;\n    }\n    bb27: {\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &mut _4;\n        _38 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::take(move _39) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &_5;\n        _40 = {closure@ostd/src/mm/page_table/cursor/locking.rs:125:65: 125:67}(move _41, _2);\n        StorageDead(_41);\n        _37 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::unwrap_or_else::<{closure@ostd/src/mm/page_table/cursor/locking.rs:125:65: 125:67}>(move _38, move _40) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_40);\n        StorageDead(_38);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &mut _37;\n        _43 = mm::page_table::node::PageTableGuard::<'_, C>::stray_mut(move _44) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_44);\n        _42 = (*_43);\n        switchInt(move _42) -> [0: bb32, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_43);\n        _0 = core::option::Option::None;\n        StorageDead(_42);\n        drop(_37) -> [return: bb63, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &mut _37;\n        _45 = mm::page_table::node::PageTableGuard::<'_, C>::entry(move _46, _15) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = &_45;\n        _47 = mm::page_table::node::entry::Entry::<'_, '_, C>::is_none(move _48) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        switchInt(move _47) -> [0: bb42, otherwise: bb35];\n    }\n    bb35: {\n        StorageDead(_48);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = &mut _45;\n        _50 = mm::page_table::node::entry::Entry::<'_, '_, C>::alloc_if_none(move _51, _2) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_51);\n        _49 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::unwrap(move _50) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_50);\n        StorageLive(_52);\n        StorageLive(_55);\n        _55 = &_49;\n        _54 = <mm::page_table::node::PageTableGuard<'_, C> as core::ops::Deref>::deref(move _55) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        _53 = <mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>> as core::ops::Deref>::deref(_54) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_55);\n        _52 = <mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>> as mm::mem_obj::HasPaddr>::paddr(_53) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _5 = move _52;\n        StorageDead(_52);\n        StorageLive(_56);\n        _56 = core::option::Option::Some(_49);\n        drop(_4) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _76 = true;\n        _4 = move _56;\n        StorageDead(_56);\n        goto -> bb52;\n    }\n    bb42: {\n        StorageDead(_48);\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = &_45;\n        _57 = mm::page_table::node::entry::Entry::<'_, '_, C>::is_node(move _58) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        switchInt(move _57) -> [0: bb51, otherwise: bb44];\n    }\n    bb44: {\n        StorageDead(_58);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = &_45;\n        _61 = mm::page_table::node::entry::Entry::<'_, '_, C>::to_ref(move _62) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_62);\n        _63 = discriminant(_61);\n        switchInt(move _63) -> [0: bb46, otherwise: bb47];\n    }\n    bb46: {\n        StorageLive(_60);\n        _60 = move ((_61 as variant#0).0: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>);\n        StorageDead(_61);\n        StorageLive(_64);\n        StorageLive(_66);\n        _66 = &_60;\n        _65 = <mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>> as core::ops::Deref>::deref(move _66) -> [return: bb48, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_61);\n        _59 = core::panicking::panic(\"internal error: entered unreachable code\") -> unwind unreachable;\n    }\n    bb48: {\n        StorageDead(_66);\n        _64 = <mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>> as mm::mem_obj::HasPaddr>::paddr(_65) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _5 = move _64;\n        StorageDead(_64);\n        StorageLive(_67);\n        _67 = core::option::Option::None;\n        drop(_4) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _76 = true;\n        _4 = move _67;\n        StorageDead(_67);\n        StorageDead(_60);\n        StorageDead(_57);\n        goto -> bb52;\n    }\n    bb51: {\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageDead(_47);\n        StorageDead(_45);\n        drop(_37) -> [return: bb54, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_47);\n        StorageDead(_45);\n        drop(_37) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_37);\n        StorageDead(_27);\n        StorageDead(_17);\n        StorageDead(_11);\n        goto -> bb5;\n    }\n    bb54: {\n        StorageDead(_37);\n        goto -> bb55;\n    }\n    bb55: {\n        StorageDead(_27);\n        goto -> bb56;\n    }\n    bb56: {\n        StorageDead(_17);\n        goto -> bb57;\n    }\n    bb57: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_7);\n        StorageLive(_68);\n        StorageLive(_69);\n        _76 = false;\n        _69 = move _4;\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = &_5;\n        _70 = {closure@ostd/src/mm/page_table/cursor/locking.rs:151:54: 151:56}(move _71, _2);\n        StorageDead(_71);\n        _68 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::unwrap_or_else::<{closure@ostd/src/mm/page_table/cursor/locking.rs:151:54: 151:56}>(move _69, move _70) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageLive(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = &mut _68;\n        _73 = mm::page_table::node::PageTableGuard::<'_, C>::stray_mut(move _74) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_74);\n        _72 = (*_73);\n        switchInt(move _72) -> [0: bb61, otherwise: bb60];\n    }\n    bb60: {\n        StorageDead(_73);\n        _0 = core::option::Option::None;\n        StorageDead(_72);\n        drop(_68) -> [return: bb62, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_73);\n        StorageDead(_72);\n        StorageLive(_75);\n        _75 = move _68;\n        _0 = core::option::Option::Some(move _75);\n        StorageDead(_75);\n        StorageDead(_68);\n        StorageDead(_5);\n        _76 = false;\n        StorageDead(_4);\n        goto -> bb66;\n    }\n    bb62: {\n        StorageDead(_68);\n        goto -> bb64;\n    }\n    bb63: {\n        StorageDead(_37);\n        StorageDead(_27);\n        StorageDead(_17);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_7);\n        goto -> bb64;\n    }\n    bb64: {\n        StorageDead(_5);\n        switchInt(_76) -> [0: bb65, otherwise: bb67];\n    }\n    bb65: {\n        _76 = false;\n        StorageDead(_4);\n        goto -> bb66;\n    }\n    bb66: {\n        return;\n    }\n    bb67: {\n        drop(_4) -> [return: bb65, unwind unreachable];\n    }\n}\n",
  "doc": " Finds and locks an intermediate page table node that covers the range.\n\n If that node (or any of its ancestors) does not exist, we need to lock\n the parent and create it. After the creation the lock of the parent will\n be released and the new node will be locked.\n\n If this function founds that a locked node is stray (because of racing with\n page table recycling), it will return `None`. The caller should retry in\n this case to lock the proper node.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}