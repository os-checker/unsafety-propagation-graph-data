{
  "name": "arch::boot::multiboot::__multiboot_entry",
  "safe": false,
  "callees": {
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    },
    "boot::call_ostd_main": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls the OSTD-user defined entrypoint of the actual kernel.\n\n Any kernel that uses the `ostd` crate should define a function marked with\n `ostd::main` as the entrypoint.\n\n This function should be only called from the bootloader-specific module.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "arch::boot::multiboot::MultibootLegacyInfo": [
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "boot::EarlyBootInfo": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::boot::multiboot::__multiboot_entry"
  },
  "span": "ostd/src/arch/x86/boot/multiboot/mod.rs:373:1: 390:2",
  "src": "unsafe extern \"sysv64\" fn __multiboot_entry(boot_magic: u32, boot_params: u64) -> ! {\n    assert_eq!(boot_magic, MULTIBOOT_ENTRY_MAGIC);\n    let mb1_info =\n        unsafe { &*(paddr_to_vaddr(boot_params as usize) as *const MultibootLegacyInfo) };\n\n    use crate::boot::{EARLY_INFO, EarlyBootInfo, call_ostd_main};\n\n    EARLY_INFO.call_once(|| EarlyBootInfo {\n        bootloader_name: parse_bootloader_name(mb1_info).unwrap_or(\"Unknown Multiboot Loader\"),\n        kernel_cmdline: parse_kernel_commandline(mb1_info).unwrap_or(\"\"),\n        initramfs: parse_initramfs(mb1_info),\n        acpi_arg: parse_acpi_arg(mb1_info),\n        framebuffer_arg: parse_framebuffer_info(mb1_info),\n        memory_regions: parse_memory_regions(mb1_info),\n    });\n\n    call_ostd_main();\n}",
  "mir": "fn arch::boot::multiboot::__multiboot_entry(_1: u32, _2: u64) -> ! {\n    let mut _0: !;\n    let mut _3: (&u32, &u32);\n    let mut _4: &u32;\n    let mut _5: &u32;\n    let  _6: &u32;\n    let  _7: &u32;\n    let mut _8: bool;\n    let mut _9: u32;\n    let mut _10: u32;\n    let  _11: core::panicking::AssertKind;\n    let  _12: !;\n    let mut _13: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _14: &arch::boot::multiboot::MultibootLegacyInfo;\n    let  _15: *const arch::boot::multiboot::MultibootLegacyInfo;\n    let mut _16: usize;\n    let mut _17: usize;\n    let  _18: &boot::EarlyBootInfo;\n    let mut _19: &spin::once::Once<boot::EarlyBootInfo>;\n    let mut _20: {closure@ostd/src/arch/x86/boot/multiboot/mod.rs:380:26: 380:28};\n    let  _21: !;\n    debug boot_magic => _1;\n    debug boot_params => _2;\n    debug left_val => _6;\n    debug right_val => _7;\n    debug kind => _11;\n    debug mb1_info => _14;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_1;\n        StorageLive(_5);\n        _5 = arch::boot::multiboot::__multiboot_entry::promoted[0];\n        _3 = (move _4, move _5);\n        StorageDead(_5);\n        StorageDead(_4);\n        _6 = (_3.0: &u32);\n        _7 = (_3.1: &u32);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = (*_6);\n        StorageLive(_10);\n        _10 = (*_7);\n        _8 = Eq(move _9, move _10);\n        switchInt(move _8) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_3);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _2 as usize;\n        _16 = mm::kspace::paddr_to_vaddr(move _17) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageDead(_9);\n        _11 = core::panicking::AssertKind::Eq;\n        StorageLive(_13);\n        _13 = core::option::Option::None;\n        _12 = core::panicking::assert_failed::<u32, u32>(_11, _6, _7, move _13) -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_17);\n        _15 = move _16 as *const arch::boot::multiboot::MultibootLegacyInfo;\n        StorageDead(_16);\n        _14 = &(*_15);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        StorageLive(_20);\n        _20 = {closure@ostd/src/arch/x86/boot/multiboot/mod.rs:380:26: 380:28}(_14);\n        _18 = spin::once::Once::<boot::EarlyBootInfo>::call_once::<{closure@ostd/src/arch/x86/boot/multiboot/mod.rs:380:26: 380:28}>(move _19, move _20) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        _21 = boot::call_ostd_main() -> unwind unreachable;\n    }\n}\n",
  "doc": " The entry point of the Rust code portion of Asterinas (with multiboot parameters).\n\n # Safety\n\n - This function must be called only once at a proper timing in the BSP's boot assembly code.\n - The caller must follow C calling conventions and put the right arguments in registers.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}