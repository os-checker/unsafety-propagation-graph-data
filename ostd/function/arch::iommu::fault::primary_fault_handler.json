{
  "name": "arch::iommu::fault::primary_fault_handler",
  "safe": true,
  "callees": {
    "arch::iommu::fault::FaultEventRegisters::status": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::fault::FaultEventRegisters": "ImmutableAsArgument",
        "arch::iommu::fault::FaultStatus": "Constructor"
      }
    },
    "arch::iommu::fault::FaultStatus::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if all of the flags in `other` are contained within `self`.\n",
      "adt": {
        "arch::iommu::fault::FaultStatus": "ImmutableAsArgument"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::advance_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator by `n` elements.\n\n This method will eagerly skip `n` elements by calling [`next`] up to `n`\n times until [`None`] is encountered.\n\n `advance_by(n)` will return `Ok(())` if the iterator successfully advances by\n `n` elements, or a `Err(NonZero<usize>)` with value `k` if [`None`] is encountered,\n where `k` is remaining number of steps that could not be advanced because the iterator ran out.\n If `self` is empty and `n` is non-zero, then this returns `Err(n)`.\n Otherwise, `k` is always less than `n`.\n\n Calling `advance_by(0)` can do meaningful work, for example [`Flatten`]\n can advance its outer iterator until it finds an inner iterator that is not empty, which\n then often allows it to return a more accurate `size_hint()` than in its initial state.\n\n [`Flatten`]: crate::iter::Flatten\n [`next`]: Iterator::next\n\n # Examples\n\n ```\n #![feature(iter_advance_by)]\n\n use std::num::NonZero;\n\n let a = [1, 2, 3, 4];\n let mut iter = a.into_iter();\n\n assert_eq!(iter.advance_by(2), Ok(()));\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.advance_by(0), Ok(()));\n assert_eq!(iter.advance_by(100), Err(NonZero::new(99).unwrap())); // only `4` was skipped\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows this `VolatileRef` as a mutable [`VolatilePtr`].\n\n Use this method to do (partial) volatile reads or writes of the referenced data.\n",
      "adt": {}
    },
    "volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile read of the contained value.\n\n Returns a copy of the read value. Volatile reads are guaranteed not to be optimized\n away by the compiler, but by themselves do not have atomic ordering\n guarantees. To also get atomicity, consider looking at the `Atomic` wrapper types of\n the standard/`core` library.\n\n ## Examples\n\n ```rust\n use volatile::{VolatilePtr, access};\n use core::ptr::NonNull;\n\n let value = 42;\n let pointer = unsafe {\n     VolatilePtr::new_restricted(access::ReadOnly, NonNull::from(&value))\n };\n assert_eq!(pointer.read(), 42);\n ```\n",
      "adt": {}
    },
    "arch::iommu::fault::FaultRecording::is_fault": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::fault::FaultRecording": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::iommu::fault::FaultRecording::clear_fault": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::fault::FaultRecording": "MutableAsArgument"
      }
    },
    "volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile write, setting the contained value to the given `value`.\n\n Volatile writes are guaranteed to not be optimized away by the compiler, but by\n themselves do not have atomic ordering guarantees. To also get atomicity, consider\n looking at the `Atomic` wrapper types of the standard/`core` library.\n\n ## Example\n\n ```rust\n use volatile::VolatilePtr;\n\n let mut value = 42;\n let volatile = unsafe { VolatilePtr::new((&mut value).into()) };\n volatile.write(50);\n\n assert_eq!(volatile.read(), 50);\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "arch::iommu::fault::FaultStatus::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the specified flags in-place.\n",
      "adt": {
        "arch::iommu::fault::FaultStatus": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "arch::iommu::fault::FaultEventRegisters": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "arch::iommu::fault::FaultStatus": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 9, kind: RigidTy(Uint(U32)) })])",
      "MutRef"
    ],
    "alloc::vec::Vec": [
      "MutRef"
    ],
    "core::slice::IterMut": [
      "Plain",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1451, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1325, kind: RigidTy(Adt(AdtDef(DefId { id: 3571, name: \"volatile::VolatileRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 955, kind: RigidTy(Uint(U128)) }), Type(Ty { id: 1281, kind: RigidTy(Adt(AdtDef(DefId { id: 3610, name: \"volatile::access::ReadWrite\" }), GenericArgs([]))) })]))) }, Mut)) })])"
    ],
    "volatile::VolatileRef": [
      "MutRef"
    ],
    "volatile::VolatilePtr": [
      "Plain"
    ],
    "arch::iommu::fault::FaultRecording": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "Unknown([Field(0, Ty { id: 955, kind: RigidTy(Uint(U128)) })])"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::iommu::fault::primary_fault_handler"
  },
  "span": "ostd/src/arch/x86/iommu/fault.rs:264:1: 299:2",
  "src": "fn primary_fault_handler(fault_event_regs: &mut FaultEventRegisters) {\n    let mut fault_status = fault_event_regs.status();\n    if !fault_status.contains(FaultStatus::PPF) {\n        return;\n    }\n\n    let start_index = ((fault_event_regs.status().bits & FaultStatus::FRI.bits) >> 8) as usize;\n    let mut fault_iter = fault_event_regs.recordings.iter_mut();\n    fault_iter.advance_by(start_index).unwrap();\n    for raw_recording in fault_iter {\n        let raw_recording = raw_recording.as_mut_ptr();\n        let mut recording = FaultRecording(raw_recording.read());\n        if !recording.is_fault() {\n            break;\n        }\n\n        // Report\n        error!(\n            \"Catch iommu page fault, doing nothing. recording:{:x?}\",\n            recording\n        );\n\n        // Clear Fault field\n        recording.clear_fault();\n        raw_recording.write(recording.0);\n    }\n\n    if fault_status.contains(FaultStatus::PFO) {\n        info!(\"Primary fault overflow detected.\");\n        fault_status.remove(FaultStatus::PFO);\n        fault_event_regs\n            .status\n            .as_mut_ptr()\n            .write(fault_status.bits);\n    }\n}",
  "mir": "fn arch::iommu::fault::primary_fault_handler(_1: &mut arch::iommu::fault::FaultEventRegisters) -> () {\n    let mut _0: ();\n    let mut _2: arch::iommu::fault::FaultStatus;\n    let mut _3: &arch::iommu::fault::FaultEventRegisters;\n    let mut _4: bool;\n    let mut _5: &arch::iommu::fault::FaultStatus;\n    let  _6: usize;\n    let mut _7: u32;\n    let mut _8: u32;\n    let mut _9: u32;\n    let mut _10: arch::iommu::fault::FaultStatus;\n    let mut _11: &arch::iommu::fault::FaultEventRegisters;\n    let mut _12: u32;\n    let mut _13: arch::iommu::fault::FaultStatus;\n    let mut _14: u32;\n    let mut _15: bool;\n    let mut _16: core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>>;\n    let mut _17: &mut [volatile::VolatileRef<'_, u128>];\n    let mut _18: &mut alloc::vec::Vec<volatile::VolatileRef<'_, u128>>;\n    let  _19: ();\n    let mut _20: core::result::Result<(), core::num::NonZero<usize>>;\n    let mut _21: &mut core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>>;\n    let mut _22: core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>>;\n    let mut _23: core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>>;\n    let mut _24: core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>>;\n    let mut _25: core::option::Option<&mut volatile::VolatileRef<'_, u128>>;\n    let mut _26: &mut core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>>;\n    let mut _27: isize;\n    let  _28: &mut volatile::VolatileRef<'_, u128>;\n    let  _29: volatile::VolatilePtr<'_, u128>;\n    let mut _30: arch::iommu::fault::FaultRecording;\n    let mut _31: u128;\n    let mut _32: bool;\n    let mut _33: &arch::iommu::fault::FaultRecording;\n    let  _34: log::Level;\n    let mut _35: bool;\n    let mut _36: &log::Level;\n    let mut _37: &log::LevelFilter;\n    let mut _38: bool;\n    let mut _39: &log::Level;\n    let mut _40: &log::LevelFilter;\n    let  _41: log::LevelFilter;\n    let  _42: ();\n    let mut _43: core::fmt::Arguments<'_>;\n    let  _44: (&arch::iommu::fault::FaultRecording,);\n    let mut _45: &arch::iommu::fault::FaultRecording;\n    let  _46: [core::fmt::rt::Argument<'_>; 1];\n    let mut _47: core::fmt::rt::Argument<'_>;\n    let mut _48: &[u8; 56];\n    let  _49: &[core::fmt::rt::Argument<'_>; 1];\n    let  _50: &(&str, &str, &core::panic::Location<'_>);\n    let  _51: (&str, &str, &core::panic::Location<'_>);\n    let mut _52: &str;\n    let  _53: &core::panic::Location<'_>;\n    let  _54: ();\n    let mut _55: &mut arch::iommu::fault::FaultRecording;\n    let  _56: ();\n    let mut _57: u128;\n    let mut _58: bool;\n    let mut _59: &arch::iommu::fault::FaultStatus;\n    let  _60: log::Level;\n    let mut _61: bool;\n    let mut _62: &log::Level;\n    let mut _63: &log::LevelFilter;\n    let mut _64: bool;\n    let mut _65: &log::Level;\n    let mut _66: &log::LevelFilter;\n    let  _67: log::LevelFilter;\n    let  _68: ();\n    let mut _69: core::fmt::Arguments<'_>;\n    let  _70: &(&str, &str, &core::panic::Location<'_>);\n    let  _71: (&str, &str, &core::panic::Location<'_>);\n    let mut _72: &str;\n    let  _73: &core::panic::Location<'_>;\n    let  _74: ();\n    let mut _75: &mut arch::iommu::fault::FaultStatus;\n    let  _76: ();\n    let mut _77: volatile::VolatilePtr<'_, u32>;\n    let mut _78: &mut volatile::VolatileRef<'_, u32>;\n    let mut _79: u32;\n    let mut _80: &arch::iommu::fault::FaultRecording;\n    debug fault_event_regs => _1;\n    debug fault_status => _2;\n    debug start_index => _6;\n    debug fault_iter => _16;\n    debug iter => _24;\n    debug raw_recording => _28;\n    debug raw_recording => _29;\n    debug recording => _30;\n    debug lvl => _34;\n    debug args => _44;\n    debug args => _46;\n    debug lvl => _60;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &(*_1);\n        _2 = arch::iommu::fault::FaultEventRegisters::status(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_2;\n        _4 = arch::iommu::fault::FaultStatus::contains(move _5, arch::iommu::fault::FaultStatus::PPF) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(*_1);\n        _10 = arch::iommu::fault::FaultEventRegisters::status(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_2);\n        goto -> bb54;\n    }\n    bb5: {\n        StorageDead(_11);\n        _9 = (_10.0: u32);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = arch::iommu::fault::FaultStatus::FRI;\n        _12 = (_13.0: u32);\n        _8 = BitAnd(move _9, move _12);\n        StorageDead(_12);\n        StorageDead(_9);\n        _14 = 8_i32 as u32;\n        _15 = Lt(move _14, 32_u32);\n        assert(move _15, \"attempt to shift right by `{}`, which would overflow\", 8_i32) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _7 = Shr(move _8, 8_i32);\n        StorageDead(_8);\n        _6 = move _7 as usize;\n        StorageDead(_7);\n        StorageDead(_13);\n        StorageDead(_10);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = &mut ((*_1).5: alloc::vec::Vec<volatile::VolatileRef<'_, u128>>);\n        _17 = <alloc::vec::Vec<volatile::VolatileRef<'_, u128>> as core::ops::DerefMut>::deref_mut(move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        _16 = core::slice::<impl [volatile::VolatileRef<'_, u128>]>::iter_mut(_17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &mut _16;\n        _20 = <core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>> as core::iter::Iterator>::advance_by(move _21, _6) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        _19 = core::result::Result::<(), core::num::NonZero<usize>>::unwrap(move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = move _16;\n        _22 = <core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>> as core::iter::IntoIterator>::into_iter(move _23) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_23);\n        StorageLive(_24);\n        _24 = move _22;\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_25);\n        _26 = &mut _24;\n        _25 = <core::slice::IterMut<'_, volatile::VolatileRef<'_, u128>> as core::iter::Iterator>::next(_26) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _27 = discriminant(_25);\n        switchInt(move _27) -> [0: bb35, 1: bb15, otherwise: bb14];\n    }\n    bb14: {\n        unreachable;\n    }\n    bb15: {\n        _28 = move ((_25 as variant#1).0: &mut volatile::VolatileRef<'_, u128>);\n        _29 = volatile::VolatileRef::<'_, u128>::as_mut_ptr(_28) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u128>>::read(_29) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _30 = FaultRecording(move _31);\n        StorageDead(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_30;\n        _32 = arch::iommu::fault::FaultRecording::is_fault(move _33) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        switchInt(move _32) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_33);\n        StorageDead(_32);\n        _34 = log::Level::Error;\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &_34;\n        StorageLive(_37);\n        _37 = arch::iommu::fault::primary_fault_handler::promoted[0];\n        _35 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _36, move _37) -> [return: bb21, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_30);\n        goto -> bb35;\n    }\n    bb21: {\n        switchInt(move _35) -> [0: bb31, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &_34;\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = log::max_level() -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _40 = &_41;\n        _38 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _39, move _40) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        switchInt(move _38) -> [0: bb30, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &_30;\n        _44 = (move _45);\n        StorageDead(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _80 = (_44.0: &arch::iommu::fault::FaultRecording);\n        _47 = core::fmt::rt::Argument::<'_>::new_debug::<arch::iommu::fault::FaultRecording>(_80) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _46 = [move _47];\n        StorageDead(_47);\n        StorageLive(_48);\n        _48 = b\"1Catch iommu page fault, doing nothing. recording:\\xc1 \\x00\\x00b\\x00\";\n        _49 = &_46;\n        _43 = core::fmt::Arguments::<'_>::new::<56, 1>(move _48, _49) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_48);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = \"ostd::arch::iommu::fault\";\n        _53 = log::__private_api::loc() -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _51 = (move _52, \"ostd::arch::iommu::fault\", _53);\n        StorageDead(_52);\n        _50 = &_51;\n        _42 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _43, _34, _50, ()) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_43);\n        StorageDead(_51);\n        StorageDead(_46);\n        StorageDead(_44);\n        goto -> bb32;\n    }\n    bb30: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        goto -> bb32;\n    }\n    bb31: {\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_38);\n        StorageDead(_35);\n        StorageLive(_55);\n        _55 = &mut _30;\n        _54 = arch::iommu::fault::FaultRecording::clear_fault(move _55) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_55);\n        StorageLive(_57);\n        _57 = (_30.0: u128);\n        _56 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u128>>::write(_29, move _57) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_57);\n        StorageDead(_30);\n        StorageDead(_25);\n        goto -> bb12;\n    }\n    bb35: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_22);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = &_2;\n        _58 = arch::iommu::fault::FaultStatus::contains(move _59, arch::iommu::fault::FaultStatus::PFO) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        switchInt(move _58) -> [0: bb52, otherwise: bb37];\n    }\n    bb37: {\n        StorageDead(_59);\n        _60 = log::Level::Info;\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = &_60;\n        StorageLive(_63);\n        _63 = arch::iommu::fault::primary_fault_handler::promoted[1];\n        _61 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _62, move _63) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        switchInt(move _61) -> [0: bb47, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = &_60;\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = log::max_level() -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _66 = &_67;\n        _64 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _65, move _66) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        switchInt(move _64) -> [0: bb46, otherwise: bb42];\n    }\n    bb42: {\n        StorageDead(_67);\n        StorageDead(_66);\n        StorageDead(_65);\n        StorageLive(_69);\n        _69 = core::fmt::Arguments::<'_>::from_str(\"Primary fault overflow detected.\") -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = \"ostd::arch::iommu::fault\";\n        _73 = log::__private_api::loc() -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _71 = (move _72, \"ostd::arch::iommu::fault\", _73);\n        StorageDead(_72);\n        _70 = &_71;\n        _68 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _69, _60, _70, ()) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_69);\n        StorageDead(_71);\n        goto -> bb48;\n    }\n    bb46: {\n        StorageDead(_67);\n        StorageDead(_66);\n        StorageDead(_65);\n        goto -> bb48;\n    }\n    bb47: {\n        StorageDead(_63);\n        StorageDead(_62);\n        goto -> bb48;\n    }\n    bb48: {\n        StorageDead(_64);\n        StorageDead(_61);\n        StorageLive(_75);\n        _75 = &mut _2;\n        _74 = arch::iommu::fault::FaultStatus::remove(move _75, arch::iommu::fault::FaultStatus::PFO) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_75);\n        StorageLive(_77);\n        StorageLive(_78);\n        _78 = &mut ((*_1).0: volatile::VolatileRef<'_, u32>);\n        _77 = volatile::VolatileRef::<'_, u32>::as_mut_ptr(move _78) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_78);\n        StorageLive(_79);\n        _79 = (_2.0: u32);\n        _76 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u32>>::write(move _77, move _79) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_79);\n        StorageDead(_77);\n        goto -> bb53;\n    }\n    bb52: {\n        StorageDead(_59);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_58);\n        StorageDead(_16);\n        StorageDead(_2);\n        goto -> bb54;\n    }\n    bb54: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}