{
  "name": "mm::frame::Frame::<M>::from_unused",
  "safe": true,
  "callees": {
    "mm::frame::meta::MetaSlot::get_from_unused": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the metadata slot of a frame assuming it is unused.\n\n If successful, the function returns a pointer to the metadata slot.\n And the slot is initialized with the given metadata.\n\n The resulting reference count held by the returned pointer is\n [`REF_COUNT_UNIQUE`] if `as_unique_ptr` is `true`, otherwise `1`.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4520, kind: RigidTy(RawPtr(Ty { id: 4392, kind: RigidTy(Adt(AdtDef(DefId { id: 5045, name: \"mm::frame::meta::MetaSlot\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4515, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 4393, kind: RigidTy(Adt(AdtDef(DefId { id: 5079, name: \"mm::frame::meta::GetFrameError\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::frame::Frame": [
      "Plain"
    ]
  },
  "path": 2060,
  "span": "ostd/src/mm/frame/mod.rs:108:5: 113:6",
  "src": "pub fn from_unused(paddr: Paddr, metadata: M) -> Result<Self, GetFrameError> {\n        Ok(Self {\n            ptr: MetaSlot::get_from_unused(paddr, metadata, false)?,\n            _marker: PhantomData,\n        })\n    }",
  "mir": "fn mm::frame::Frame::<M>::from_unused(_1: usize, _2: M) -> core::result::Result<mm::frame::Frame<M>, mm::frame::meta::GetFrameError> {\n    let mut _0: core::result::Result<mm::frame::Frame<M>, mm::frame::meta::GetFrameError>;\n    let mut _3: mm::frame::Frame<M>;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>, *const mm::frame::meta::MetaSlot>;\n    let mut _5: core::result::Result<*const mm::frame::meta::MetaSlot, mm::frame::meta::GetFrameError>;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>;\n    let  _8: *const mm::frame::meta::MetaSlot;\n    debug paddr => _1;\n    debug metadata => _2;\n    debug residual => _7;\n    debug val => _8;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = mm::frame::meta::MetaSlot::get_from_unused::<M>(_1, _2, false) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <core::result::Result<*const mm::frame::meta::MetaSlot, mm::frame::meta::GetFrameError> as core::ops::Try>::branch(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _8 = ((_4 as variant#0).0: *const mm::frame::meta::MetaSlot);\n        _3 = Frame(_8, ZeroSized: core::marker::PhantomData<M>);\n        _0 = core::result::Result::Ok(move _3);\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb7;\n    }\n    bb5: {\n        _7 = move ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>);\n        _0 = <core::result::Result<mm::frame::Frame<M>, mm::frame::meta::GetFrameError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>>>::from_residual(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": " Gets a [`Frame`] with a specific usage from a raw, unused page.\n\n The caller should provide the initial metadata of the page.\n\n If the provided frame is not truly unused at the moment, it will return\n an error. If wanting to acquire a frame that is already in use, use\n [`Frame::from_in_use`] instead.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}