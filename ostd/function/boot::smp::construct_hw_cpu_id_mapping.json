{
  "name": "boot::smp::construct_hw_cpu_id_mapping",
  "safe": true,
  "callees": {
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the map.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n assert_eq!(a.len(), 0);\n a.insert(1, \"a\");\n assert_eq!(a.len(), 1);\n ```\n",
      "adt": {}
    },
    "cpu::id::num_cpus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of CPUs.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::values": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets an iterator over the values of the map, in order by key.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n a.insert(1, \"hello\");\n a.insert(2, \"goodbye\");\n\n let values: Vec<&str> = a.values().cloned().collect();\n assert_eq!(values, [\"hello\", \"goodbye\"]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::cloned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which [`clone`]s all of its elements.\n\n This is useful when you have an iterator over `&T`, but you need an\n iterator over `T`.\n\n There is no guarantee whatsoever about the `clone` method actually\n being called *or* optimized away. So code should not depend on\n either.\n\n [`clone`]: Clone::clone\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let v_cloned: Vec<_> = a.iter().cloned().collect();\n\n // cloned is the same as .map(|&x| x), for integers\n let v_map: Vec<_> = a.iter().map(|&x| x).collect();\n\n assert_eq!(v_cloned, [1, 2, 3]);\n assert_eq!(v_map, [1, 2, 3]);\n ```\n\n To get the best performance, try to clone late:\n\n ```\n let a = [vec![0_u8, 1, 2], vec![3, 4], vec![23]];\n // don't do this:\n let slower: Vec<_> = a.iter().cloned().filter(|s| s.len() == 1).collect();\n assert_eq!(&[vec![23]], &slower[..]);\n // instead call `cloned` late\n let faster: Vec<_> = a.iter().filter(|s| s.len() == 1).cloned().collect();\n assert_eq!(&[vec![23]], &faster[..]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T, A>::into_boxed_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the vector into [`Box<[T]>`][owned slice].\n\n Before doing the conversion, this method discards excess capacity like [`shrink_to_fit`].\n\n [owned slice]: Box\n [`shrink_to_fit`]: Vec::shrink_to_fit\n\n # Examples\n\n ```\n let v = vec![1, 2, 3];\n\n let slice = v.into_boxed_slice();\n ```\n\n Any excess capacity is removed:\n\n ```\n let mut vec = Vec::with_capacity(10);\n vec.extend([1, 2, 3]);\n\n assert!(vec.capacity() >= 10);\n let slice = vec.into_boxed_slice();\n assert_eq!(slice.into_vec().capacity(), 3);\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the map, removing all elements.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n a.insert(1, \"a\");\n a.clear();\n assert!(a.is_empty());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "alloc::collections::BTreeMap": [
      "Ref",
      "MutRef"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc::collections::btree_map::Values": [
      "Plain"
    ],
    "core::iter::Cloned": [
      "Plain"
    ],
    "alloc::vec::Vec": [
      "Plain"
    ],
    "alloc::boxed::Box": [
      "Plain"
    ]
  },
  "path": 1602,
  "span": "ostd/src/boot/smp.rs:207:1: 219:2",
  "src": "pub(crate) fn construct_hw_cpu_id_mapping() -> Box<[HwCpuId]> {\n    let mut hw_cpu_id_map = HW_CPU_ID_MAP.lock();\n    assert_eq!(hw_cpu_id_map.len(), crate::cpu::num_cpus());\n\n    let result = hw_cpu_id_map\n        .values()\n        .cloned()\n        .collect::<Vec<_>>()\n        .into_boxed_slice();\n    hw_cpu_id_map.clear();\n\n    result\n}",
  "mir": "fn boot::smp::construct_hw_cpu_id_mapping() -> alloc::boxed::Box<[arch::irq::ipi::HwCpuId]> {\n    let mut _0: alloc::boxed::Box<[arch::irq::ipi::HwCpuId]>;\n    let mut _1: sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled>;\n    let mut _2: &sync::spin::SpinLock<alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>>;\n    let mut _3: (&usize, &usize);\n    let mut _4: &usize;\n    let  _5: usize;\n    let  _6: &alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>;\n    let mut _7: &sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled>;\n    let mut _8: &usize;\n    let  _9: usize;\n    let  _10: &usize;\n    let  _11: &usize;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: usize;\n    let  _15: core::panicking::AssertKind;\n    let  _16: !;\n    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _18: alloc::vec::Vec<arch::irq::ipi::HwCpuId>;\n    let mut _19: core::iter::Cloned<alloc::collections::btree_map::Values<'_, u32, arch::irq::ipi::HwCpuId>>;\n    let mut _20: alloc::collections::btree_map::Values<'_, u32, arch::irq::ipi::HwCpuId>;\n    let  _21: &alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>;\n    let mut _22: &sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled>;\n    let  _23: ();\n    let mut _24: &mut alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>;\n    let mut _25: &mut sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled>;\n    debug hw_cpu_id_map => _1;\n    debug left_val => _10;\n    debug right_val => _11;\n    debug kind => _15;\n    debug result => _0;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        _2 = {alloc681: &sync::spin::SpinLock<alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>>};\n        _1 = sync::spin::SpinLock::<alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>>::lock(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &_1;\n        _6 = <sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled> as core::ops::Deref>::deref(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = alloc::collections::BTreeMap::<u32, arch::irq::ipi::HwCpuId>::len(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = &_5;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = cpu::id::num_cpus() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = &_9;\n        _3 = (move _4, move _8);\n        StorageDead(_8);\n        StorageDead(_4);\n        _10 = (_3.0: &usize);\n        _11 = (_3.1: &usize);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (*_10);\n        StorageLive(_14);\n        _14 = (*_11);\n        _12 = Eq(move _13, move _14);\n        switchInt(move _12) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_22);\n        _22 = &_1;\n        _21 = <sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled> as core::ops::Deref>::deref(move _22) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _15 = core::panicking::AssertKind::Eq;\n        StorageLive(_17);\n        _17 = core::option::Option::None;\n        _16 = core::panicking::assert_failed::<usize, usize>(_15, _10, _11, move _17) -> unwind unreachable;\n    }\n    bb7: {\n        StorageDead(_22);\n        _20 = alloc::collections::BTreeMap::<u32, arch::irq::ipi::HwCpuId>::values(_21) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _19 = <alloc::collections::btree_map::Values<'_, u32, arch::irq::ipi::HwCpuId> as core::iter::Iterator>::cloned::<'_, arch::irq::ipi::HwCpuId>(move _20) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_20);\n        _18 = <core::iter::Cloned<alloc::collections::btree_map::Values<'_, u32, arch::irq::ipi::HwCpuId>> as core::iter::Iterator>::collect::<alloc::vec::Vec<arch::irq::ipi::HwCpuId>>(move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        _0 = alloc::vec::Vec::<arch::irq::ipi::HwCpuId>::into_boxed_slice(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_18);\n        StorageLive(_25);\n        _25 = &mut _1;\n        _24 = <sync::spin::SpinLockGuard<'_, alloc::collections::BTreeMap<u32, arch::irq::ipi::HwCpuId>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _25) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_25);\n        _23 = alloc::collections::BTreeMap::<u32, arch::irq::ipi::HwCpuId>::clear(_24) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        drop(_1) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " Constructs a boxed slice that maps [`CpuId`] to [`HwCpuId`].\n\n # Panics\n\n This method will panic if it is called either before all APs have booted or more than once.\n\n [`CpuId`]: crate::cpu::CpuId\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}