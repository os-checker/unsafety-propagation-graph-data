{
  "name": "panic::print_stack_trace::callback",
  "safe": true,
  "callees": {
    "unwinding::abi::_Unwind_GetIP": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "unwinding::abi::_Unwind_FindEnclosingFunction": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_lower_hex": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "console::early_print": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prints formatted arguments to the console.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "unwinding::abi::_Unwind_GetGR": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "panic::gimli::X86_64::register_name": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The name of a register, or `None` if the register number is unknown.\n\n Only returns the primary name for registers that alias with others.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "core::num::<impl u16>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "panic::print_stack_trace::CallbackData": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "unwinding::abi::UnwindContext": [
      "Ref"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 74, kind: RigidTy(Uint(U16)) })])"
    ],
    "panic::gimli::Register": [
      "Plain"
    ],
    "unwinding::abi::UnwindReasonCode": [
      "Plain"
    ]
  },
  "path": 2522,
  "span": "ostd/src/panic.rs:75:5: 110:6",
  "src": "extern \"C\" fn callback(unwind_ctx: &UnwindContext<'_>, arg: *mut c_void) -> UnwindReasonCode {\n        let data = unsafe { &mut *(arg as *mut CallbackData) };\n        data.counter += 1;\n        let pc = _Unwind_GetIP(unwind_ctx);\n        if pc > 0 {\n            let fde_initial_address = _Unwind_FindEnclosingFunction(pc as *mut c_void) as usize;\n            early_println!(\n                \"{:4}: fn {:#18x} - pc {:#18x} / registers:\",\n                data.counter,\n                fde_initial_address,\n                pc,\n            );\n        }\n        // Print the first 8 general registers for any architecture. The register number follows\n        // the DWARF standard.\n        for i in 0..8u16 {\n            let reg_i = _Unwind_GetGR(unwind_ctx, i as i32);\n            cfg_if::cfg_if! {\n                if #[cfg(target_arch = \"x86_64\")] {\n                    let reg_name = gimli::X86_64::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else if #[cfg(target_arch = \"riscv64\")] {\n                    let reg_name = gimli::RiscV::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else if #[cfg(target_arch = \"aarch64\")] {\n                    let reg_name = gimli::AArch64::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else {\n                    let reg_name = \"unknown\";\n                }\n            }\n            if i.is_multiple_of(4) {\n                early_print!(\"\\n    \");\n            }\n            early_print!(\" {} {:#18x};\", reg_name, reg_i);\n        }\n        early_print!(\"\\n\\n\");\n        UnwindReasonCode::NO_REASON\n    }",
  "mir": "fn panic::print_stack_trace::callback(_1: &unwinding::abi::UnwindContext<'_>, _2: *mut core::ffi::c_void) -> unwinding::abi::UnwindReasonCode {\n    let mut _0: unwinding::abi::UnwindReasonCode;\n    let mut _3: &mut panic::print_stack_trace::CallbackData;\n    let mut _4: *mut panic::print_stack_trace::CallbackData;\n    let mut _5: (usize, bool);\n    let  _6: usize;\n    let mut _7: bool;\n    let  _8: usize;\n    let mut _9: *mut core::ffi::c_void;\n    let mut _10: *mut core::ffi::c_void;\n    let  _11: ();\n    let mut _12: core::fmt::Arguments<'_>;\n    let  _13: (&usize, &usize, &usize);\n    let mut _14: &usize;\n    let mut _15: &usize;\n    let mut _16: &usize;\n    let  _17: [core::fmt::rt::Argument<'_>; 3];\n    let mut _18: core::fmt::rt::Argument<'_>;\n    let mut _19: core::fmt::rt::Argument<'_>;\n    let mut _20: core::fmt::rt::Argument<'_>;\n    let mut _21: &[u8; 50];\n    let  _22: &[core::fmt::rt::Argument<'_>; 3];\n    let mut _23: core::ops::Range<u16>;\n    let mut _24: core::ops::Range<u16>;\n    let mut _25: core::ops::Range<u16>;\n    let mut _26: core::option::Option<u16>;\n    let mut _27: &mut core::ops::Range<u16>;\n    let mut _28: isize;\n    let  _29: u16;\n    let  _30: usize;\n    let mut _31: i32;\n    let  _32: &str;\n    let mut _33: core::option::Option<&str>;\n    let mut _34: panic::gimli::Register;\n    let mut _35: &str;\n    let mut _36: bool;\n    let  _37: ();\n    let mut _38: core::fmt::Arguments<'_>;\n    let  _39: ();\n    let mut _40: core::fmt::Arguments<'_>;\n    let  _41: (&&str, &usize);\n    let mut _42: &&str;\n    let mut _43: &usize;\n    let  _44: [core::fmt::rt::Argument<'_>; 2];\n    let mut _45: core::fmt::rt::Argument<'_>;\n    let mut _46: core::fmt::rt::Argument<'_>;\n    let mut _47: &[u8; 15];\n    let  _48: &[core::fmt::rt::Argument<'_>; 2];\n    let  _49: ();\n    let mut _50: core::fmt::Arguments<'_>;\n    let mut _51: &usize;\n    let mut _52: &usize;\n    let mut _53: &usize;\n    let mut _54: &&str;\n    let mut _55: &usize;\n    debug unwind_ctx => _1;\n    debug arg => _2;\n    debug data => _3;\n    debug pc => _6;\n    debug fde_initial_address => _8;\n    debug args => _13;\n    debug args => _17;\n    debug iter => _25;\n    debug i => _29;\n    debug reg_i => _30;\n    debug reg_name => _32;\n    debug args => _41;\n    debug args => _44;\n    bb0: {\n        StorageLive(_4);\n        _4 = _2 as *mut panic::print_stack_trace::CallbackData;\n        _3 = &mut (*_4);\n        _5 = CheckedAdd(((*_3).0: usize), 1_usize);\n        assert(!move (_5.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_3).0: usize), 1_usize) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        ((*_3).0: usize) = move (_5.0: usize);\n        _6 = unwinding::abi::_Unwind_GetIP(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = Gt(_6, 0_usize);\n        switchInt(move _7) -> [0: bb10, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _6 as *mut core::ffi::c_void;\n        _9 = unwinding::abi::_Unwind_FindEnclosingFunction(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = move _9 as usize;\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &((*_3).0: usize);\n        StorageLive(_15);\n        _15 = &_8;\n        StorageLive(_16);\n        _16 = &_6;\n        _13 = (move _14, move _15, move _16);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_17);\n        StorageLive(_18);\n        _51 = (_13.0: &usize);\n        _18 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_51) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_19);\n        _52 = (_13.1: &usize);\n        _19 = core::fmt::rt::Argument::<'_>::new_lower_hex::<usize>(_52) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_20);\n        _53 = (_13.2: &usize);\n        _20 = core::fmt::rt::Argument::<'_>::new_lower_hex::<usize>(_53) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _17 = [move _18, move _19, move _20];\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_21);\n        _21 = b\"\\xc3 \\x00\\x00h\\x04\\x00\\x05: fn \\xc3 \\x00\\x80h\\x12\\x00\\x06 - pc \\xc3 \\x00\\x80h\\x12\\x00\\x0e / registers:\\n\\x00\";\n        _22 = &_17;\n        _12 = core::fmt::Arguments::<'_>::new::<50, 3>(move _21, _22) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_21);\n        _11 = console::early_print(move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_17);\n        StorageDead(_13);\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_7);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = Range(0_u16, 8_u16);\n        _23 = <core::ops::Range<u16> as core::iter::IntoIterator>::into_iter(move _24) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        StorageLive(_25);\n        _25 = move _23;\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_26);\n        _27 = &mut _25;\n        _26 = <core::ops::Range<u16> as core::iter::Iterator>::next(_27) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _28 = discriminant(_26);\n        switchInt(move _28) -> [0: bb17, 1: bb16, otherwise: bb15];\n    }\n    bb15: {\n        unreachable;\n    }\n    bb16: {\n        _29 = ((_26 as variant#1).0: u16);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = _29 as i32;\n        _30 = unwinding::abi::_Unwind_GetGR(_1, move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageLive(_50);\n        _50 = core::fmt::Arguments::<'_>::from_str(\"\\n\\n\") -> [return: bb31, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = Register(_29);\n        _33 = panic::gimli::X86_64::register_name(move _34) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_34);\n        StorageLive(_35);\n        _35 = \"unknown\";\n        _32 = core::option::Option::<&str>::unwrap_or(move _33, move _35) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_35);\n        StorageDead(_33);\n        StorageLive(_36);\n        _36 = core::num::<impl u16>::is_multiple_of(_29, 4_u16) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        switchInt(move _36) -> [0: bb25, otherwise: bb22];\n    }\n    bb22: {\n        StorageLive(_38);\n        _38 = core::fmt::Arguments::<'_>::from_str(\"\\n    \") -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _37 = console::early_print(move _38) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_38);\n        goto -> bb26;\n    }\n    bb25: {\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_36);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &_32;\n        StorageLive(_43);\n        _43 = &_30;\n        _41 = (move _42, move _43);\n        StorageDead(_43);\n        StorageDead(_42);\n        StorageLive(_44);\n        StorageLive(_45);\n        _54 = (_41.0: &&str);\n        _45 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_54) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageLive(_46);\n        _55 = (_41.1: &usize);\n        _46 = core::fmt::rt::Argument::<'_>::new_lower_hex::<usize>(_55) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _44 = [move _45, move _46];\n        StorageDead(_46);\n        StorageDead(_45);\n        StorageLive(_47);\n        _47 = b\"\\x01 \\xc0\\x01 \\xc3 \\x00\\x80h\\x12\\x00\\x01;\\x00\";\n        _48 = &_44;\n        _40 = core::fmt::Arguments::<'_>::new::<15, 2>(move _47, _48) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_47);\n        _39 = console::early_print(move _40) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_40);\n        StorageDead(_44);\n        StorageDead(_41);\n        StorageDead(_32);\n        StorageDead(_30);\n        StorageDead(_26);\n        goto -> bb13;\n    }\n    bb31: {\n        _49 = console::early_print(move _50) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_50);\n        _0 = unwinding::abi::UnwindReasonCode::NO_REASON;\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}