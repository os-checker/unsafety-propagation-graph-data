{
  "name": "mm::frame::unique::UniqueFrame::<M>::reset_as_unused",
  "safe": true,
  "callees": {
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "mm::frame::unique::UniqueFrame::<M>::slot": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::frame::unique::UniqueFrame": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicU64::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    },
    "mm::frame::meta::MetaSlot::drop_last_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Drops the metadata and deallocates the frame.\n\n # Safety\n\n The caller should ensure that:\n  - the reference count is `0` (so we are the sole owner of the frame);\n  - the metadata is initialized;\n",
      "adt": {
        "mm::frame::meta::MetaSlot": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::frame::unique::UniqueFrame": [
      "Plain",
      "Ref"
    ],
    "core::mem::ManuallyDrop": [
      "Plain",
      "Ref"
    ],
    "mm::frame::meta::MetaSlot": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": 2031,
  "span": "ostd/src/mm/frame/unique.rs:110:5: 117:6",
  "src": "pub fn reset_as_unused(self) {\n        let this = ManuallyDrop::new(self);\n\n        this.slot().ref_count.store(0, Ordering::Release);\n        // SAFETY: We are the sole owner and the reference count is 0.\n        // The slot is initialized.\n        unsafe { this.slot().drop_last_in_place() };\n    }",
  "mir": "fn mm::frame::unique::UniqueFrame::<M>::reset_as_unused(_1: mm::frame::unique::UniqueFrame<M>) -> () {\n    let mut _0: ();\n    let  _2: core::mem::ManuallyDrop<mm::frame::unique::UniqueFrame<M>>;\n    let  _3: ();\n    let mut _4: &core::sync::atomic::AtomicU64;\n    let  _5: &mm::frame::meta::MetaSlot;\n    let  _6: &mm::frame::unique::UniqueFrame<M>;\n    let mut _7: &core::mem::ManuallyDrop<mm::frame::unique::UniqueFrame<M>>;\n    let mut _8: core::sync::atomic::Ordering;\n    let  _9: ();\n    let  _10: &mm::frame::meta::MetaSlot;\n    let  _11: &mm::frame::unique::UniqueFrame<M>;\n    let mut _12: &core::mem::ManuallyDrop<mm::frame::unique::UniqueFrame<M>>;\n    debug self => _1;\n    debug this => _2;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::ManuallyDrop::<mm::frame::unique::UniqueFrame<M>>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &_2;\n        _6 = <core::mem::ManuallyDrop<mm::frame::unique::UniqueFrame<M>> as core::ops::Deref>::deref(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = mm::frame::unique::UniqueFrame::<M>::slot(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = &((*_5).1: core::sync::atomic::AtomicU64);\n        StorageLive(_8);\n        _8 = core::sync::atomic::Ordering::Release;\n        _3 = core::sync::atomic::AtomicU64::store(move _4, 0_u64, move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_4);\n        StorageDead(_5);\n        StorageLive(_12);\n        _12 = &_2;\n        _11 = <core::mem::ManuallyDrop<mm::frame::unique::UniqueFrame<M>> as core::ops::Deref>::deref(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _10 = mm::frame::unique::UniqueFrame::<M>::slot(_11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = mm::frame::meta::MetaSlot::drop_last_in_place(_10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Resets the frame to unused without up-calling the allocator.\n\n This is solely useful for the allocator implementation/testing and\n is highly experimental. Usage of this function is discouraged.\n\n Usage of this function other than the allocator would actually leak\n the frame since the allocator would not be aware of the frame.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}