{
  "name": "smp::inter_processor_call",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "smp::IpiSender::inter_processor_call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes a function on other processors.\n\n See [`inter_processor_call`] for details. The purpose of exporting this\n method is to enable callers to check whether [`IPI_SENDER`] has been\n initialized.\n",
      "adt": {
        "smp::IpiSender": "ImmutableAsArgument",
        "util::id_set::IdSet": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "smp::IpiSender": [
      "Ref"
    ],
    "util::id_set::IdSet": [
      "Ref"
    ]
  },
  "path": 2535,
  "span": "ostd/src/smp.rs:34:1: 37:2",
  "src": "pub fn inter_processor_call(targets: &CpuSet, f: fn()) {\n    let ipi_sender = IPI_SENDER.get().unwrap();\n    ipi_sender.inter_processor_call(targets, f);\n}",
  "mir": "fn smp::inter_processor_call(_1: &util::id_set::IdSet<cpu::id::CpuId>, _2: fn()) -> () {\n    let mut _0: ();\n    let  _3: &smp::IpiSender;\n    let mut _4: core::option::Option<&smp::IpiSender>;\n    let mut _5: &spin::once::Once<smp::IpiSender>;\n    let  _6: ();\n    debug targets => _1;\n    debug f => _2;\n    debug ipi_sender => _3;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = {alloc1417: &spin::once::Once<smp::IpiSender>};\n        _4 = spin::once::Once::<smp::IpiSender>::get(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = core::option::Option::<&smp::IpiSender>::unwrap(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = smp::IpiSender::inter_processor_call(_3, _1, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        return;\n    }\n}\n",
  "doc": " Executes a function on other processors.\n\n The provided function `f` will be executed on all target processors\n specified by `targets`. It can also be executed on the current processor.\n The function should be short and non-blocking, as it will be executed in\n interrupt context with interrupts disabled.\n\n This function does not block until all the target processors acknowledges\n the interrupt. So if any of the target processors disables IRQs for too\n long that the controller cannot queue them, the function will not be\n executed.\n\n The function `f` will be executed asynchronously on the target processors.\n However if called on the current processor, it will be synchronous.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}