{
  "name": "arch::boot::smp::count_processors",
  "safe": true,
  "callees": {
    "arch::kernel::acpi::get_acpi_tables": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "acpi::AcpiTables": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "acpi::AcpiTables::<H>::find_table": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches through the ACPI table headers and attempts to locate the table with a matching `T::SIGNATURE`.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "acpi::PhysicalMapping::<H, T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "acpi::madt::Madt::entries": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::iter::Iterator::filter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which uses a closure to determine if an element\n should be yielded.\n\n Given an element the closure must return `true` or `false`. The returned\n iterator will yield only the elements for which the closure returns\n `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0i32, 1, 2];\n\n let mut iter = a.into_iter().filter(|x| x.is_positive());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `filter()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|x| **x > 1); // needs two *s!\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n It's common to instead use destructuring on the argument to strip away one:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&x| *x > 1); // both & and *\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n or both:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&&x| x > 1); // two &s\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n of these layers.\n\n Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n",
      "adt": {}
    },
    "core::iter::Iterator::count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the iterator, counting the number of iterations and returning it.\n\n This method will call [`next`] repeatedly until [`None`] is encountered,\n returning the number of times it saw [`Some`]. Note that [`next`] has to be\n called at least once even if the iterator does not have any elements.\n\n [`next`]: Iterator::next\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so counting elements of\n an iterator with more than [`usize::MAX`] elements either produces the\n wrong result or panics. If overflow checks are enabled, a panic is\n guaranteed.\n\n # Panics\n\n This function might panic if the iterator has more than [`usize::MAX`]\n elements.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert_eq!(a.iter().count(), 3);\n\n let a = [1, 2, 3, 4, 5];\n assert_eq!(a.iter().count(), 5);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 400, kind: RigidTy(Adt(AdtDef(DefId { id: 3048, name: \"acpi::AcpiTables\" }), GenericArgs([Type(Ty { id: 428, kind: RigidTy(Adt(AdtDef(DefId { id: 3075, name: \"arch::kernel::acpi::AcpiMemoryHandler\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 405, kind: RigidTy(Adt(AdtDef(DefId { id: 3050, name: \"acpi::PhysicalMapping\" }), GenericArgs([Type(Ty { id: 428, kind: RigidTy(Adt(AdtDef(DefId { id: 3075, name: \"arch::kernel::acpi::AcpiMemoryHandler\" }), GenericArgs([]))) }), Type(Ty { id: 429, kind: RigidTy(Adt(AdtDef(DefId { id: 3076, name: \"acpi::madt::Madt\" }), GenericArgs([]))) })]))) })])"
    ],
    "acpi::AcpiTables": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "acpi::PhysicalMapping": [
      "Plain",
      "Ref"
    ],
    "core::pin::Pin": [
      "Plain"
    ],
    "acpi::madt::MadtEntryIter": [
      "Plain"
    ],
    "core::iter::Filter": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::boot::smp::count_processors"
  },
  "span": "ostd/src/arch/x86/boot/smp.rs:54:1: 107:2",
  "src": "pub(crate) fn count_processors() -> Option<u32> {\n    let acpi_tables = get_acpi_tables()?;\n    let madt_table = acpi_tables.find_table::<acpi::madt::Madt>().ok()?;\n\n    // According to ACPI spec [1], \"If this bit [the Enabled bit] is set the processor is ready for\n    // use. If this bit is clear and the Online Capable bit is set, system hardware supports\n    // enabling this processor during OS runtime.\"\n    // [1]: https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/05_ACPI_Software_Programming_Model/ACPI_Software_Programming_Model.html#local-apic-flags\n    fn is_usable(flags: u32) -> bool {\n        const ENABLED: u32 = 0b01;\n        const ONLINE_CAPABLE: u32 = 0b10;\n\n        (flags & ENABLED) != 0 || (flags & ONLINE_CAPABLE) != 0\n    }\n\n    // According to ACPI spec [1], \"Logical processors with APIC ID values less than 255 (whether\n    // in XAPIC or X2APIC mode) must use the Processor Local APIC structure to convey their APIC\n    // information to OSPM [..] Logical processors with APIC ID values 255 and greater must use the\n    // Processor Local x2APIC structure [..]\"\n    // [1]: https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/05_ACPI_Software_Programming_Model/ACPI_Software_Programming_Model.html#processor-local-x2apic-structure\n    let is_dup_apic = |id: u32| -> bool {\n        // Check if the APIC entry also shows up as an x2APIC entry.\n        if madt_table.get().entries().any(|e| {\n            matches!(e, MadtEntry::LocalX2Apic(e)\n                if e.x2apic_id == id && is_usable(e.flags))\n        }) {\n            log::warn!(\n                \"Firmware bug: In MADT, APIC ID {} is also listed as an x2APIC ID\",\n                id,\n            );\n            true\n        } else {\n            false\n        }\n    };\n\n    let local_apic_counts = madt_table\n        .get()\n        .entries()\n        .filter(|e| match e {\n            MadtEntry::LocalX2Apic(entry) => {\n                log::trace!(\"Found a local x2APIC entry in MADT: {:?}\", entry);\n                is_usable(entry.flags)\n            }\n            MadtEntry::LocalApic(entry) => {\n                log::trace!(\"Found a local APIC entry in MADT: {:?}\", entry);\n                is_usable(entry.flags) && !is_dup_apic(entry.apic_id as u32)\n            }\n            _ => false,\n        })\n        .count();\n\n    Some(local_apic_counts as u32)\n}",
  "mir": "fn arch::boot::smp::count_processors() -> core::option::Option<u32> {\n    let mut _0: core::option::Option<u32>;\n    let  _1: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _2: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>;\n    let mut _3: core::option::Option<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>;\n    let mut _4: isize;\n    let  _5: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let  _6: acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let mut _7: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>>;\n    let mut _8: core::option::Option<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>>;\n    let mut _9: core::result::Result<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>, acpi::AcpiError>;\n    let mut _10: &acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _11: isize;\n    let  _12: acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let  _13: {closure@ostd/src/arch/x86/boot/smp.rs:74:23: 74:40};\n    let mut _14: &acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let  _15: usize;\n    let mut _16: core::iter::Filter<acpi::madt::MadtEntryIter<'_>, {closure@ostd/src/arch/x86/boot/smp.rs:93:17: 93:20}>;\n    let mut _17: acpi::madt::MadtEntryIter<'_>;\n    let mut _18: core::pin::Pin<&acpi::madt::Madt>;\n    let mut _19: &acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let mut _20: {closure@ostd/src/arch/x86/boot/smp.rs:93:17: 93:20};\n    let mut _21: &{closure@ostd/src/arch/x86/boot/smp.rs:74:23: 74:40};\n    let mut _22: u32;\n    debug acpi_tables => _1;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _5;\n    debug madt_table => _6;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _12;\n    debug is_dup_apic => _13;\n    debug local_apic_counts => _15;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = arch::kernel::acpi::get_acpi_tables() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = <core::option::Option<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>> as core::ops::Try>::branch(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_5);\n        _5 = move ((_2 as variant#0).0: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>);\n        _1 = move _5;\n        StorageDead(_5);\n        StorageDead(_2);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_1;\n        _9 = acpi::AcpiTables::<arch::kernel::acpi::AcpiMemoryHandler>::find_table::<acpi::madt::Madt>(move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::option::Option<u32> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_2);\n        goto -> bb19;\n    }\n    bb7: {\n        StorageDead(_10);\n        _8 = core::result::Result::<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>, acpi::AcpiError>::ok(move _9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        _7 = <core::option::Option<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>> as core::ops::Try>::branch(move _8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_8);\n        _11 = discriminant(_7);\n        switchInt(move _11) -> [0: bb10, 1: bb11, otherwise: bb3];\n    }\n    bb10: {\n        StorageLive(_12);\n        _12 = move ((_7 as variant#0).0: acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>);\n        _6 = move _12;\n        StorageDead(_12);\n        StorageDead(_7);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_6;\n        _13 = {closure@ostd/src/arch/x86/boot/smp.rs:74:23: 74:40}(move _14);\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_6;\n        _18 = acpi::PhysicalMapping::<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>::get(move _19) -> [return: bb13, unwind unreachable];\n    }\n    bb11: {\n        _0 = <core::option::Option<u32> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_7);\n        StorageDead(_6);\n        drop(_1) -> [return: bb19, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        _17 = acpi::madt::Madt::entries(move _18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_13;\n        _20 = {closure@ostd/src/arch/x86/boot/smp.rs:93:17: 93:20}(move _21);\n        StorageDead(_21);\n        _16 = <acpi::madt::MadtEntryIter<'_> as core::iter::Iterator>::filter::<{closure@ostd/src/arch/x86/boot/smp.rs:93:17: 93:20}>(move _17, move _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageDead(_17);\n        _15 = <core::iter::Filter<acpi::madt::MadtEntryIter<'_>, {closure@ostd/src/arch/x86/boot/smp.rs:93:17: 93:20}> as core::iter::Iterator>::count(move _16) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_16);\n        StorageLive(_22);\n        _22 = _15 as u32;\n        _0 = core::option::Option::Some(move _22);\n        StorageDead(_22);\n        StorageDead(_13);\n        drop(_6) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_6);\n        drop(_1) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_1);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_1);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": " Counts the number of processors.\n\n This function needs to be called after the OS initializes the ACPI table.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}