{
  "name": "boot::init_after_heap",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "boot::EarlyBootInfo": [
      "Ref"
    ],
    "boot::BootInfo": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::boot::init_after_heap"
  },
  "span": "ostd/src/boot/mod.rs:104:1: 114:2",
  "src": "pub(crate) fn init_after_heap() {\n    let boot_time_info = EARLY_INFO.get().unwrap();\n\n    INFO.call_once(|| BootInfo {\n        bootloader_name: boot_time_info.bootloader_name.to_string(),\n        kernel_cmdline: boot_time_info.kernel_cmdline.to_string(),\n        initramfs: boot_time_info.initramfs,\n        framebuffer_arg: boot_time_info.framebuffer_arg,\n        memory_regions: boot_time_info.memory_regions.to_vec(),\n    });\n}",
  "mir": "fn boot::init_after_heap() -> () {\n    let mut _0: ();\n    let  _1: &boot::EarlyBootInfo;\n    let mut _2: core::option::Option<&boot::EarlyBootInfo>;\n    let mut _3: &spin::once::Once<boot::EarlyBootInfo>;\n    let  _4: &boot::BootInfo;\n    let mut _5: &spin::once::Once<boot::BootInfo>;\n    let mut _6: {closure@ostd/src/boot/mod.rs:107:20: 107:22};\n    debug boot_time_info => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        _2 = spin::once::Once::<boot::EarlyBootInfo>::get(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _1 = core::option::Option::<&boot::EarlyBootInfo>::unwrap(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = {alloc716: &spin::once::Once<boot::BootInfo>};\n        StorageLive(_6);\n        _6 = {closure@ostd/src/boot/mod.rs:107:20: 107:22}(_1);\n        _4 = spin::once::Once::<boot::BootInfo>::call_once::<{closure@ostd/src/boot/mod.rs:107:20: 107:22}>(move _5, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Initializes the boot information.\n\n This function copies the boot-time accessible information to the heap to\n allow [`boot_info`] to work properly.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}