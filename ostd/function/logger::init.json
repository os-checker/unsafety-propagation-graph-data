{
  "name": "logger::init",
  "safe": true,
  "callees": {
    "logger::get_log_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "log::LevelFilter": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "log::set_max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the global maximum log level.\n\n Generally, this should only be called by the active logging implementation.\n\n Note that `Trace` is the maximum level, because it provides the maximum amount of detail in the emitted logs.\n",
      "adt": {}
    },
    "log::set_logger": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the global logger to a `&'static Log`.\n\n This function may only be called once in the lifetime of a program. Any log\n events that occur before the call to `set_logger` completes will be ignored.\n\n This function does not typically need to be called manually. Logger\n implementations should provide an initialization method that installs the\n logger internally.\n\n # Availability\n\n This method is available even when the `std` feature is disabled. However,\n it is currently unavailable on `thumbv6` targets, which lack support for\n some atomic operations which are used by this function. Even on those\n targets, [`set_logger_racy`] will be available.\n\n # Errors\n\n An error is returned if a logger has already been set.\n\n # Examples\n\n ```\n use log::{error, info, warn, Record, Level, Metadata, LevelFilter};\n\n static MY_LOGGER: MyLogger = MyLogger;\n\n struct MyLogger;\n\n impl log::Log for MyLogger {\n     fn enabled(&self, metadata: &Metadata) -> bool {\n         metadata.level() <= Level::Info\n     }\n\n     fn log(&self, record: &Record) {\n         if self.enabled(record.metadata()) {\n             println!(\"{} - {}\", record.level(), record.args());\n         }\n     }\n     fn flush(&self) {}\n }\n\n # fn main(){\n log::set_logger(&MY_LOGGER).unwrap();\n log::set_max_level(LevelFilter::Info);\n\n info!(\"hello log\");\n warn!(\"warning\");\n error!(\"oops\");\n # }\n ```\n\n [`set_logger_racy`]: fn.set_logger_racy.html\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "log::LevelFilter": [
      "Plain"
    ],
    "logger::Logger": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1841,
  "span": "ostd/src/logger.rs:41:1: 45:2",
  "src": "pub(crate) fn init() {\n    let level = get_log_level().unwrap_or(LevelFilter::Off);\n    log::set_max_level(level);\n    log::set_logger(&LOGGER).unwrap();\n}",
  "mir": "fn logger::init() -> () {\n    let mut _0: ();\n    let  _1: log::LevelFilter;\n    let mut _2: core::option::Option<log::LevelFilter>;\n    let mut _3: log::LevelFilter;\n    let  _4: ();\n    let  _5: ();\n    let mut _6: core::result::Result<(), log::SetLoggerError>;\n    let mut _7: &dyn log::Log;\n    let  _8: &logger::Logger;\n    debug level => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = logger::get_log_level() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = log::LevelFilter::Off;\n        _1 = core::option::Option::<log::LevelFilter>::unwrap_or(move _2, move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageDead(_2);\n        _4 = log::set_max_level(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _8 = {alloc1011: &logger::Logger};\n        _7 = _8 as &dyn log::Log;\n        _6 = log::set_logger(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = core::result::Result::<(), log::SetLoggerError>::unwrap(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Initializes the logger. Users should avoid using the log macros before this function is called.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}