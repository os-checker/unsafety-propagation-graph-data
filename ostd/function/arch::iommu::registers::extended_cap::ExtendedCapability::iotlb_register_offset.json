{
  "name": "arch::iommu::registers::extended_cap::ExtendedCapability::iotlb_register_offset",
  "safe": true,
  "callees": {},
  "adts": {
    "arch::iommu::registers::extended_cap::ExtendedCapability": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": 962,
  "span": "ostd/src/arch/x86/iommu/registers/extended_cap.rs:25:5: 28:6",
  "src": "pub const fn iotlb_register_offset(&self) -> u64 {\n        const IRO_MASK: u64 = 0x3FF << 8;\n        (self.0 & IRO_MASK) >> 8\n    }",
  "mir": "fn arch::iommu::registers::extended_cap::ExtendedCapability::iotlb_register_offset(_1: &arch::iommu::registers::extended_cap::ExtendedCapability) -> u64 {\n    let mut _0: u64;\n    let mut _2: u64;\n    let mut _3: u64;\n    let mut _4: u32;\n    let mut _5: bool;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).0: u64);\n        _2 = BitAnd(move _3, arch::iommu::registers::extended_cap::ExtendedCapability::iotlb_register_offset::IRO_MASK);\n        StorageDead(_3);\n        _4 = 8_i32 as u32;\n        _5 = Lt(move _4, 64_u32);\n        assert(move _5, \"attempt to shift right by `{}`, which would overflow\", 8_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Shr(move _2, 8_i32);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " IOTLB Register Offset. This field specifies the offset to the IOTLB registers relative\n to the register base address of this remapping hardware unit.\n\n If the register base address is X, and the value reported in this field is Y, the\n address for the IOTLB registers is calculated as X+(16*Y).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}