{
  "name": "boot::smp::ap_early_entry",
  "safe": false,
  "callees": {
    "cpu::init_on_ap": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the CPU module (the AP part).\n\n # Safety\n\n The caller must ensure that:\n 1. We're in the boot context of an AP.\n 2. The CPU ID of the AP is correct.\n",
      "adt": {}
    },
    "arch::enable_cpu_features": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::trap::init_on_cpu": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes interrupt handling on x86_64.\n\n This function will:\n - Switch to a new, CPU-local [GDT].\n - Switch to a new, CPU-local [TSS].\n - Switch to a new, global [IDT].\n - Enable the [`syscall`] instruction.\n\n [GDT]: https://wiki.osdev.org/GDT\n [IDT]: https://wiki.osdev.org/IDT\n [TSS]: https://wiki.osdev.org/Task_State_Segment\n [`syscall`]: https://www.felixcloutier.com/x86/syscall\n\n # Safety\n\n On the current CPU, this function must be called\n - only once and\n - before any trap can occur.\n",
      "adt": {}
    },
    "mm::kspace::activate_kernel_page_table": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Activates the kernel page table.\n\n All address translation of symbols in the boot sections must be manually\n done from now on.\n\n # Safety\n\n This function must only be called once per CPU.\n",
      "adt": {}
    },
    "arch::init_on_ap": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes application-processor-specific state.\n\n # Safety\n\n 1. This function must be called only once on each application processor.\n 2. This function must be called after the BSP's call to [`late_init_on_bsp`]\n    and before any other architecture-specific code in this module is called\n    on this AP.\n",
      "adt": {}
    },
    "arch::irq::ops::enable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::page_table::boot_pt::dismiss": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dismiss the boot page table.\n\n By calling it on a CPU, the caller claims that the boot page table is no\n longer needed on this CPU.\n\n # Safety\n\n The caller should ensure that:\n  - another legitimate page table is activated on this CPU;\n  - this function should be called only once per CPU;\n  - no [`with_borrow`] calls are performed on this CPU after this dismissal;\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "boot::smp::report_online_and_hw_cpu_id": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "spin::once::Once::<T, R>::wait": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Spins until the [`Once`] contains a value.\n\n Note that in releases prior to `0.7`, this function had the behaviour of [`Once::poll`].\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n",
      "adt": {}
    },
    "arch::mm::tlb_flush_all_excluding_global": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Flush all TLB entries except for the global-page entries.\n",
      "adt": {}
    },
    "task::Task::yield_now": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields execution so that another task may be scheduled.\n\n Note that this method cannot be simply named \"yield\" as the name is\n a Rust keyword.\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str_nonconst": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::boot::smp::ap_early_entry"
  },
  "span": "ostd/src/boot/smp.rs:137:1: 179:2",
  "src": "pub(crate) unsafe extern \"C\" fn ap_early_entry(cpu_id: u32) -> ! {\n    // SAFETY:\n    // 1. We're in the boot context of an AP.\n    // 2. The CPU ID of the AP is correct.\n    unsafe { crate::cpu::init_on_ap(cpu_id) };\n\n    crate::arch::enable_cpu_features();\n\n    // SAFETY: This is called only once on this AP in the boot context.\n    unsafe { crate::arch::trap::init_on_cpu() };\n\n    // SAFETY: This function is only called once on this AP.\n    unsafe { crate::mm::kspace::activate_kernel_page_table() };\n\n    // SAFETY: This function is only called once on this AP, after the BSP has\n    // done the architecture-specific initialization.\n    unsafe { crate::arch::init_on_ap() };\n\n    crate::arch::irq::enable_local();\n\n    // SAFETY:\n    // 1. The kernel page table is activated on this AP.\n    // 2. The function is called only once on this AP.\n    // 3. No remaining `with_borrow` invocations on this CPU from now on.\n    unsafe { crate::mm::page_table::boot_pt::dismiss() };\n\n    log::info!(\"Processor {} started. Spinning for tasks.\", cpu_id);\n\n    // Mark the AP as started. The BSP will resume execution once all the APs\n    // have been marked as such.\n    //\n    // From here to the following `tlb_flush_all_excluding_global`, there is no\n    // TLB coherence because the BSP may not be able to send IPIs to flush the\n    // TLBs. Do not perform complex operations during this period.\n    report_online_and_hw_cpu_id(cpu_id);\n    let ap_late_entry = AP_LATE_ENTRY.wait();\n    crate::arch::mm::tlb_flush_all_excluding_global();\n\n    ap_late_entry();\n\n    Task::yield_now();\n    unreachable!(\"`yield_now` in the boot context should not return\");\n}",
  "mir": "fn boot::smp::ap_early_entry(_1: u32) -> ! {\n    let mut _0: !;\n    let  _2: ();\n    let  _3: ();\n    let  _4: ();\n    let  _5: ();\n    let  _6: ();\n    let  _7: ();\n    let  _8: ();\n    let  _9: log::Level;\n    let mut _10: bool;\n    let mut _11: &log::Level;\n    let mut _12: &log::LevelFilter;\n    let mut _13: bool;\n    let mut _14: &log::Level;\n    let mut _15: &log::LevelFilter;\n    let  _16: log::LevelFilter;\n    let  _17: ();\n    let mut _18: core::fmt::Arguments<'_>;\n    let  _19: (&u32,);\n    let mut _20: &u32;\n    let  _21: [core::fmt::rt::Argument<'_>; 1];\n    let mut _22: core::fmt::rt::Argument<'_>;\n    let mut _23: &[u8; 43];\n    let  _24: &[core::fmt::rt::Argument<'_>; 1];\n    let  _25: &(&str, &str, &core::panic::Location<'_>);\n    let  _26: (&str, &str, &core::panic::Location<'_>);\n    let mut _27: &str;\n    let  _28: &core::panic::Location<'_>;\n    let  _29: ();\n    let  _30: &fn();\n    let mut _31: &spin::once::Once<fn()>;\n    let  _32: ();\n    let  _33: ();\n    let mut _34: fn();\n    let  _35: ();\n    let  _36: !;\n    let mut _37: core::fmt::Arguments<'_>;\n    let mut _38: &u32;\n    debug cpu_id => _1;\n    debug lvl => _9;\n    debug args => _19;\n    debug args => _21;\n    debug ap_late_entry => _30;\n    bb0: {\n        _2 = cpu::init_on_ap(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = arch::enable_cpu_features() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = arch::trap::init_on_cpu() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _5 = mm::kspace::activate_kernel_page_table() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = arch::init_on_ap() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _7 = arch::irq::ops::enable_local() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _8 = mm::page_table::boot_pt::dismiss() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = log::Level::Info;\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_9;\n        StorageLive(_12);\n        _12 = boot::smp::ap_early_entry::promoted[0];\n        _10 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _11, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _10) -> [0: bb18, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_9;\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = log::max_level() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _15 = &_16;\n        _13 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _14, move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _13) -> [0: bb17, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_1;\n        _19 = (move _20);\n        StorageDead(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _38 = (_19.0: &u32);\n        _22 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_38) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _21 = [move _22];\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = b\"\\nProcessor \\xc0\\x1d started. Spinning for tasks.\\x00\";\n        _24 = &_21;\n        _18 = core::fmt::Arguments::<'_>::new::<43, 1>(move _23, _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = \"ostd::boot::smp\";\n        _28 = log::__private_api::loc() -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _26 = (move _27, \"ostd::boot::smp\", _28);\n        StorageDead(_27);\n        _25 = &_26;\n        _17 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _18, _9, _25, ()) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_18);\n        StorageDead(_26);\n        StorageDead(_21);\n        StorageDead(_19);\n        goto -> bb19;\n    }\n    bb17: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_13);\n        StorageDead(_10);\n        _29 = boot::smp::report_online_and_hw_cpu_id(_1) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = {alloc699: &spin::once::Once<fn()>};\n        _30 = spin::once::Once::<fn()>::wait(move _31) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_31);\n        _32 = arch::mm::tlb_flush_all_excluding_global() -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_34);\n        _34 = (*_30);\n        _33 = move _34() -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_34);\n        _35 = task::Task::yield_now() -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageLive(_37);\n        _37 = core::fmt::Arguments::<'_>::from_str_nonconst(\"internal error: entered unreachable code: `yield_now` in the boot context should not return\") -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _36 = core::panicking::panic_fmt(move _37) -> unwind unreachable;\n    }\n}\n",
  "doc": " The AP's entry point of the Rust code portion of Asterinas.\n\n # Safety\n\n - This function must be called only once on each AP at a proper timing in the AP's boot\n   assembly code, or via a thin Rust wrapper that does not access uninitialized AP states.\n - The caller must follow C calling conventions and put the right arguments in registers.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}