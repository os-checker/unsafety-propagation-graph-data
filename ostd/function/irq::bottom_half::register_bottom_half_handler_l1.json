{
  "name": "irq::bottom_half::register_bottom_half_handler_l1",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": 1796,
  "span": "ostd/src/irq/bottom_half.rs:20:1: 24:2",
  "src": "pub fn register_bottom_half_handler_l1(\n    func: fn(DisabledLocalIrqGuard, u8) -> DisabledLocalIrqGuard,\n) {\n    BOTTOM_HALF_HANDLER_L1.call_once(|| func);\n}",
  "mir": "fn irq::bottom_half::register_bottom_half_handler_l1(_1: fn(irq::guard::DisabledLocalIrqGuard, u8) -> irq::guard::DisabledLocalIrqGuard) -> () {\n    let mut _0: ();\n    let  _2: &fn(irq::guard::DisabledLocalIrqGuard, u8) -> irq::guard::DisabledLocalIrqGuard;\n    let mut _3: &spin::once::Once<fn(irq::guard::DisabledLocalIrqGuard, u8) -> irq::guard::DisabledLocalIrqGuard>;\n    let mut _4: {closure@ostd/src/irq/bottom_half.rs:23:38: 23:40};\n    let mut _5: &fn(irq::guard::DisabledLocalIrqGuard, u8) -> irq::guard::DisabledLocalIrqGuard;\n    debug func => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = {alloc828: &spin::once::Once<fn(irq::guard::DisabledLocalIrqGuard, u8) -> irq::guard::DisabledLocalIrqGuard>};\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_1;\n        _4 = {closure@ostd/src/irq/bottom_half.rs:23:38: 23:40}(move _5);\n        StorageDead(_5);\n        _2 = spin::once::Once::<fn(irq::guard::DisabledLocalIrqGuard, u8) -> irq::guard::DisabledLocalIrqGuard>::call_once::<{closure@ostd/src/irq/bottom_half.rs:23:38: 23:40}>(move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Registers a bottom half callback to be executed at interrupt level 1.\n\n The callback takes a [`DisabledLocalIrqGuard`] as the first argument.\n This allows the callback to drop the guard\n in order to re-enable IRQs on the current CPU.\n The callback requires returning a `DisabledLocalIrqGuard`,\n thus ensuring that local IRQs are disabled by the end of the callback.\n The second argument is the IRQ number being processed.\n\n The function may be called only once; subsequent calls take no effect.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}