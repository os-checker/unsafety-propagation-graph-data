{
  "name": "cpu::id::current::<impl cpu::id::CpuId>::current_racy",
  "safe": true,
  "callees": {
    "cpu::local::cell::CpuLocalCell::<T>::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the value of the per-CPU object in a single instruction.\n\n Note that this memory operation will not be elided or reordered by the\n compiler since it is a black-box.\n",
      "adt": {
        "cpu::local::cell::CpuLocalCell": "MutableAsArgument"
      }
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "util::id_set::Id::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an ID instance given a raw ID number.\n\n # Safety\n\n The given number must be less than `Self::cardinality()`.\n",
      "adt": {}
    }
  },
  "adts": {
    "cpu::local::cell::CpuLocalCell": [
      "Ref"
    ],
    "cpu::id::CpuId": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::cpu::id::current::<impl cpu::id::CpuId>::current_racy"
  },
  "span": "ostd/src/cpu/id.rs:146:9: 153:10",
  "src": "pub fn current_racy() -> Self {\n            #[cfg(debug_assertions)]\n            assert!(IS_CURRENT_CPU_INITED.load());\n\n            let current_raw_id = CURRENT_CPU.load();\n            // SAFETY: The CPU-local value is initialized to a correct one.\n            unsafe { Self::new_unchecked(current_raw_id) }\n        }",
  "mir": "fn cpu::id::current::<impl cpu::id::CpuId>::current_racy() -> cpu::id::CpuId {\n    let mut _0: cpu::id::CpuId;\n    let mut _1: bool;\n    let mut _2: &cpu::local::cell::CpuLocalCell<bool>;\n    let mut _3: !;\n    let  _4: u32;\n    let mut _5: &cpu::local::cell::CpuLocalCell<u32>;\n    debug current_raw_id => _4;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        _2 = {alloc763: &cpu::local::cell::CpuLocalCell<bool>};\n        _1 = cpu::local::cell::CpuLocalCell::<bool>::load(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _1) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageDead(_1);\n        StorageLive(_5);\n        _5 = {alloc760: &cpu::local::cell::CpuLocalCell<u32>};\n        _4 = cpu::local::cell::CpuLocalCell::<u32>::load(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        _3 = core::panicking::panic(\"assertion failed: IS_CURRENT_CPU_INITED.load()\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_5);\n        _0 = <cpu::id::CpuId as util::id_set::Id>::new_unchecked(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": " Returns the ID of the current CPU.\n\n This function is safe to call, but is vulnerable to races. The returned CPU\n ID may be outdated if the task migrates to another CPU.\n\n To ensure that the CPU ID is up-to-date, do it under any guards that\n implement the [`PinCurrentCpu`] trait.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}