{
  "name": "io::io_mem::allocator::IoMemAllocatorBuilder::new",
  "safe": false,
  "callees": {
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc::vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "util::range_alloc::RangeAllocator::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "util::range_alloc::RangeAllocator": "Constructor"
      }
    },
    "alloc::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    }
  },
  "adts": {
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "alloc::vec::Vec": [
      "Ref",
      "Plain",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "alloc::vec::IntoIter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "util::range_alloc::RangeAllocator": [
      "Plain"
    ],
    "io::io_mem::allocator::IoMemAllocatorBuilder": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::io::io_mem::allocator::IoMemAllocatorBuilder::new"
  },
  "span": "ostd/src/io/io_mem/allocator.rs:90:5: 100:6",
  "src": "pub(crate) unsafe fn new(ranges: Vec<Range<usize>>) -> Self {\n        info!(\n            \"Creating new I/O memory allocator builder, ranges: {:#x?}\",\n            ranges\n        );\n        let mut allocators = Vec::with_capacity(ranges.len());\n        for range in ranges {\n            allocators.push(RangeAllocator::new(range));\n        }\n        Self { allocators }\n    }",
  "mir": "fn io::io_mem::allocator::IoMemAllocatorBuilder::new(_1: alloc::vec::Vec<core::ops::Range<usize>>) -> io::io_mem::allocator::IoMemAllocatorBuilder {\n    let mut _0: io::io_mem::allocator::IoMemAllocatorBuilder;\n    let  _2: log::Level;\n    let mut _3: bool;\n    let mut _4: &log::Level;\n    let mut _5: &log::LevelFilter;\n    let mut _6: bool;\n    let mut _7: &log::Level;\n    let mut _8: &log::LevelFilter;\n    let  _9: log::LevelFilter;\n    let  _10: ();\n    let mut _11: core::fmt::Arguments<'_>;\n    let  _12: (&alloc::vec::Vec<core::ops::Range<usize>>,);\n    let mut _13: &alloc::vec::Vec<core::ops::Range<usize>>;\n    let  _14: [core::fmt::rt::Argument<'_>; 1];\n    let mut _15: core::fmt::rt::Argument<'_>;\n    let mut _16: &[u8; 58];\n    let  _17: &[core::fmt::rt::Argument<'_>; 1];\n    let  _18: &(&str, &str, &core::panic::Location<'_>);\n    let  _19: (&str, &str, &core::panic::Location<'_>);\n    let mut _20: &str;\n    let  _21: &core::panic::Location<'_>;\n    let mut _22: alloc::vec::Vec<util::range_alloc::RangeAllocator>;\n    let mut _23: usize;\n    let mut _24: &alloc::vec::Vec<core::ops::Range<usize>>;\n    let mut _25: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _26: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _27: core::option::Option<core::ops::Range<usize>>;\n    let mut _28: &mut alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _29: isize;\n    let  _30: core::ops::Range<usize>;\n    let  _31: ();\n    let mut _32: &mut alloc::vec::Vec<util::range_alloc::RangeAllocator>;\n    let mut _33: util::range_alloc::RangeAllocator;\n    let mut _34: alloc::vec::Vec<util::range_alloc::RangeAllocator>;\n    let mut _35: &alloc::vec::Vec<core::ops::Range<usize>>;\n    debug ranges => _1;\n    debug lvl => _2;\n    debug args => _12;\n    debug args => _14;\n    debug allocators => _22;\n    debug iter => _26;\n    debug range => _30;\n    bb0: {\n        _2 = log::Level::Info;\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_2;\n        StorageLive(_5);\n        _5 = io::io_mem::allocator::IoMemAllocatorBuilder::new::promoted[0];\n        _3 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb11, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_2;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = log::max_level() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &_9;\n        _6 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _7, move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _6) -> [0: bb10, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_1;\n        _12 = (move _13);\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _35 = (_12.0: &alloc::vec::Vec<core::ops::Range<usize>>);\n        _15 = core::fmt::rt::Argument::<'_>::new_debug::<alloc::vec::Vec<core::ops::Range<usize>>>(_35) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _14 = [move _15];\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = b\"3Creating new I/O memory allocator builder, ranges: \\xc1 \\x00\\x80b\\x00\";\n        _17 = &_14;\n        _11 = core::fmt::Arguments::<'_>::new::<58, 1>(move _16, _17) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = \"ostd::io::io_mem::allocator\";\n        _21 = log::__private_api::loc() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _19 = (move _20, \"ostd::io::io_mem::allocator\", _21);\n        StorageDead(_20);\n        _18 = &_19;\n        _10 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _11, _2, _18, ()) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_19);\n        StorageDead(_14);\n        StorageDead(_12);\n        goto -> bb12;\n    }\n    bb10: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_1;\n        _23 = alloc::vec::Vec::<core::ops::Range<usize>>::len(move _24) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_24);\n        _22 = alloc::vec::Vec::<util::range_alloc::RangeAllocator>::with_capacity(move _23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageLive(_25);\n        _25 = <alloc::vec::Vec<core::ops::Range<usize>> as core::iter::IntoIterator>::into_iter(_1) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_26);\n        _26 = move _25;\n        goto -> bb16;\n    }\n    bb16: {\n        StorageLive(_27);\n        _28 = &mut _26;\n        _27 = <alloc::vec::IntoIter<core::ops::Range<usize>> as core::iter::Iterator>::next(_28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _29 = discriminant(_27);\n        switchInt(move _29) -> [0: bb20, 1: bb19, otherwise: bb18];\n    }\n    bb18: {\n        unreachable;\n    }\n    bb19: {\n        _30 = move ((_27 as variant#1).0: core::ops::Range<usize>);\n        StorageLive(_32);\n        _32 = &mut _22;\n        StorageLive(_33);\n        _33 = util::range_alloc::RangeAllocator::new(_30) -> [return: bb21, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_27);\n        drop(_26) -> [return: bb23, unwind unreachable];\n    }\n    bb21: {\n        _31 = alloc::vec::Vec::<util::range_alloc::RangeAllocator>::push(move _32, move _33) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_27);\n        goto -> bb16;\n    }\n    bb23: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_34);\n        _34 = move _22;\n        _0 = IoMemAllocatorBuilder(move _34);\n        StorageDead(_34);\n        StorageDead(_22);\n        return;\n    }\n}\n",
  "doc": " Initializes memory I/O region for devices.\n\n # Safety\n\n 1. This function must be called at most once.\n 2. This function must be called after the kernel page table is activated\n    on the bootstrapping processor.\n 3. The caller must ensure the range doesn't belong to physical memory.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}