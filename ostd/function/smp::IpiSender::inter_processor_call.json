{
  "name": "smp::IpiSender::inter_processor_call",
  "safe": true,
  "callees": {
    "irq::guard::disable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables all IRQs on the current CPU (i.e., locally).\n\n This function returns a guard object, which will automatically enable local IRQs again when\n it is dropped. This function works correctly even when it is called in a _nested_ way.\n The local IRQs shall only be re-enabled when the most outer guard is dropped.\n\n This function can play nicely with [`SpinLock`] as the type uses this function internally.\n One can invoke this function even after acquiring a spin lock. And the reversed order is also ok.\n\n [`SpinLock`]: crate::sync::SpinLock\n\n # Example\n\n ```rust\n use ostd::irq;\n\n {\n     let _ = irq::disable_local();\n     todo!(\"do something when irqs are disabled\");\n }\n ```\n",
      "adt": {
        "irq::guard::DisabledLocalIrqGuard": "Constructor"
      }
    },
    "cpu::id::current::PinCurrentCpu::current_cpu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the ID of the current CPU.\n",
      "adt": {
        "cpu::id::CpuId": "Constructor"
      }
    },
    "util::id_set::IdSet::<I>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Iterates over all IDs in the set.\n\n The iteration is guaranteed to be in ascending order.\n",
      "adt": {
        "util::id_set::IdSet": "ImmutableAsArgument",
        "core::iter::Map": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "cpu::local::CpuLocal::<T, S>::get_on_cpu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets access to the CPU-local value on a specific CPU.\n\n This allows the caller to access CPU-local data from a remote CPU,\n so the data type must be `Sync`.\n",
      "adt": {
        "cpu::local::CpuLocal": "ImmutableAsArgument"
      }
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "alloc::collections::VecDeque::<T, A>::push_back": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut buf = VecDeque::new();\n buf.push_back(1);\n buf.push_back(3);\n assert_eq!(3, *buf.back().unwrap());\n ```\n",
      "adt": {}
    },
    "util::id_set::Id::as_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an [`usize`] from the [`Id`]'s corresponding [`u32`].\n",
      "adt": {}
    },
    "arch::irq::ipi::send_ipi": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sends a general inter-processor interrupt (IPI) to the specified CPU.\n",
      "adt": {}
    }
  },
  "adts": {
    "irq::guard::DisabledLocalIrqGuard": [
      "Plain",
      "Ref"
    ],
    "cpu::id::CpuId": [
      "Plain",
      "Ref"
    ],
    "util::id_set::IdSet": [
      "Ref"
    ],
    "core::iter::Map": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2350, kind: RigidTy(Adt(AdtDef(DefId { id: 4216, name: \"cpu::id::CpuId\" }), GenericArgs([]))) })])"
    ],
    "cpu::local::CpuLocal": [
      "Ref"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "alloc::collections::VecDeque": [
      "MutRef"
    ],
    "alloc::boxed::Box": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6443, kind: RigidTy(Adt(AdtDef(DefId { id: 3281, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 3167, kind: RigidTy(Slice(Ty { id: 2043, kind: RigidTy(Adt(AdtDef(DefId { id: 3960, name: \"arch::irq::ipi::HwCpuId\" }), GenericArgs([]))) })) })]))) }), Field(0, Ty { id: 6444, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 3167, kind: RigidTy(Slice(Ty { id: 2043, kind: RigidTy(Adt(AdtDef(DefId { id: 3960, name: \"arch::irq::ipi::HwCpuId\" }), GenericArgs([]))) })) })]))) })])"
    ],
    "smp::IpiSender": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "arch::irq::ipi::HwCpuId": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::smp::IpiSender::inter_processor_call"
  },
  "span": "ostd/src/smp.rs:56:5: 79:6",
  "src": "pub(crate) fn inter_processor_call(&self, targets: &CpuSet, f: fn()) {\n        let irq_guard = irq::disable_local();\n        let this_cpu_id = irq_guard.current_cpu();\n\n        let mut call_on_self = false;\n        for cpu_id in targets.iter() {\n            if cpu_id == this_cpu_id {\n                call_on_self = true;\n                continue;\n            }\n            CALL_QUEUES.get_on_cpu(cpu_id).lock().push_back(f);\n        }\n        for cpu_id in targets.iter() {\n            if cpu_id == this_cpu_id {\n                continue;\n            }\n            let hw_cpu_id = self.hw_cpu_ids[cpu_id.as_usize()];\n            crate::arch::irq::send_ipi(hw_cpu_id, &irq_guard as _);\n        }\n        if call_on_self {\n            // Execute the function synchronously.\n            f();\n        }\n    }",
  "mir": "fn smp::IpiSender::inter_processor_call(_1: &smp::IpiSender, _2: &util::id_set::IdSet<cpu::id::CpuId>, _3: fn()) -> () {\n    let mut _0: ();\n    let  _4: irq::guard::DisabledLocalIrqGuard;\n    let  _5: cpu::id::CpuId;\n    let mut _6: &irq::guard::DisabledLocalIrqGuard;\n    let mut _7: bool;\n    let mut _8: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _9: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _10: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _11: core::option::Option<cpu::id::CpuId>;\n    let mut _12: &mut core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _13: isize;\n    let  _14: cpu::id::CpuId;\n    let mut _15: bool;\n    let mut _16: &cpu::id::CpuId;\n    let mut _17: &cpu::id::CpuId;\n    let  _18: ();\n    let mut _19: &mut alloc::collections::VecDeque<fn()>;\n    let mut _20: &mut sync::spin::SpinLockGuard<'_, alloc::collections::VecDeque<fn()>, sync::guard::PreemptDisabled>;\n    let mut _21: sync::spin::SpinLockGuard<'_, alloc::collections::VecDeque<fn()>, sync::guard::PreemptDisabled>;\n    let  _22: &sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>;\n    let mut _23: &cpu::local::CpuLocal<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>>>;\n    let mut _24: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _25: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _26: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _27: core::option::Option<cpu::id::CpuId>;\n    let mut _28: &mut core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let mut _29: isize;\n    let  _30: cpu::id::CpuId;\n    let mut _31: bool;\n    let mut _32: &cpu::id::CpuId;\n    let mut _33: &cpu::id::CpuId;\n    let  _34: arch::irq::ipi::HwCpuId;\n    let  _35: usize;\n    let mut _36: usize;\n    let mut _37: bool;\n    let  _38: ();\n    let mut _39: &dyn cpu::id::current::PinCurrentCpu;\n    let  _40: &irq::guard::DisabledLocalIrqGuard;\n    let mut _41: bool;\n    let  _42: ();\n    let mut _43: alloc::boxed::Box<[arch::irq::ipi::HwCpuId]>;\n    let mut _44: alloc::boxed::Box<[arch::irq::ipi::HwCpuId]>;\n    let mut _45: *const [arch::irq::ipi::HwCpuId];\n    let mut _46: *const [arch::irq::ipi::HwCpuId];\n    debug self => _1;\n    debug targets => _2;\n    debug f => _3;\n    debug irq_guard => _4;\n    debug this_cpu_id => _5;\n    debug call_on_self => _7;\n    debug iter => _10;\n    debug cpu_id => _14;\n    debug iter => _26;\n    debug cpu_id => _30;\n    debug hw_cpu_id => _34;\n    bb0: {\n        StorageLive(_4);\n        _4 = irq::guard::disable_local() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_4;\n        _5 = <irq::guard::DisabledLocalIrqGuard as cpu::id::current::PinCurrentCpu>::current_cpu(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = false;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = util::id_set::IdSet::<cpu::id::CpuId>::iter(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = <core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}> as core::iter::IntoIterator>::into_iter(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageLive(_10);\n        _10 = move _8;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_11);\n        _12 = &mut _10;\n        _11 = <core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}> as core::iter::Iterator>::next(_12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _14 = ((_11 as variant#1).0: cpu::id::CpuId);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_14;\n        StorageLive(_17);\n        _17 = &_5;\n        _15 = <cpu::id::CpuId as core::cmp::PartialEq>::eq(move _16, move _17) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = util::id_set::IdSet::<cpu::id::CpuId>::iter(_2) -> [return: bb18, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _15) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _7 = true;\n        StorageDead(_15);\n        StorageDead(_11);\n        goto -> bb5;\n    }\n    bb12: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_23);\n        _23 = {alloc1434: &cpu::local::CpuLocal<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>>>};\n        _22 = cpu::local::CpuLocal::<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>>>::get_on_cpu(move _23, _14) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_23);\n        _21 = sync::spin::SpinLock::<alloc::collections::VecDeque<fn()>>::lock(_22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _20 = &mut _21;\n        _19 = <sync::spin::SpinLockGuard<'_, alloc::collections::VecDeque<fn()>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        _18 = alloc::collections::VecDeque::<fn()>::push_back(_19, _3) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        drop(_21) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_21);\n        StorageDead(_11);\n        goto -> bb5;\n    }\n    bb18: {\n        _24 = <core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}> as core::iter::IntoIterator>::into_iter(move _25) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_25);\n        StorageLive(_26);\n        _26 = move _24;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_27);\n        _28 = &mut _26;\n        _27 = <core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}> as core::iter::Iterator>::next(_28) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _29 = discriminant(_27);\n        switchInt(move _29) -> [0: bb23, 1: bb22, otherwise: bb7];\n    }\n    bb22: {\n        _30 = ((_27 as variant#1).0: cpu::id::CpuId);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &_30;\n        StorageLive(_33);\n        _33 = &_5;\n        _31 = <cpu::id::CpuId as core::cmp::PartialEq>::eq(move _32, move _33) -> [return: bb24, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_24);\n        StorageLive(_41);\n        _41 = _7;\n        switchInt(move _41) -> [0: bb32, otherwise: bb30];\n    }\n    bb24: {\n        switchInt(move _31) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_27);\n        goto -> bb20;\n    }\n    bb26: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_35);\n        _35 = <cpu::id::CpuId as util::id_set::Id>::as_usize(_30) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _43 = ((*_1).0: alloc::boxed::Box<[arch::irq::ipi::HwCpuId]>);\n        _45 = ((_43.0: core::ptr::Unique<[arch::irq::ipi::HwCpuId]>).0: core::ptr::NonNull<[arch::irq::ipi::HwCpuId]>) as *const [arch::irq::ipi::HwCpuId];\n        _36 = PtrMetadata(_45);\n        _37 = Lt(_35, _36);\n        assert(move _37, \"index out of bounds: the length is {} but the index is {}\", move _36, _35) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _44 = ((*_1).0: alloc::boxed::Box<[arch::irq::ipi::HwCpuId]>);\n        _46 = ((_44.0: core::ptr::Unique<[arch::irq::ipi::HwCpuId]>).0: core::ptr::NonNull<[arch::irq::ipi::HwCpuId]>) as *const [arch::irq::ipi::HwCpuId];\n        _34 = (*_46)[_35];\n        StorageDead(_35);\n        _40 = &_4;\n        _39 = _40 as &dyn cpu::id::current::PinCurrentCpu;\n        _38 = arch::irq::ipi::send_ipi(_34, _39) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_27);\n        goto -> bb20;\n    }\n    bb30: {\n        _42 = _3() -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_41);\n        StorageDead(_7);\n        StorageDead(_5);\n        drop(_4) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Executes a function on other processors.\n\n See [`inter_processor_call`] for details. The purpose of exporting this\n method is to enable callers to check whether [`IPI_SENDER`] has been\n initialized.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}