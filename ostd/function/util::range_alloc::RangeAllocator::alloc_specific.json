{
  "name": "util::range_alloc::RangeAllocator::alloc_specific",
  "safe": true,
  "callees": {
    "core::ops::Range::<Idx>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the range contains no items.\n\n # Examples\n\n ```\n assert!(!(3..5).is_empty());\n assert!( (3..3).is_empty());\n assert!( (3..2).is_empty());\n ```\n\n The range is empty if either side is incomparable:\n\n ```\n assert!(!(3.0..5.0).is_empty());\n assert!( (3.0..f32::NAN).is_empty());\n assert!( (f32::NAN..5.0).is_empty());\n ```\n",
      "adt": {}
    },
    "util::range_alloc::RangeAllocator::get_freelist_guard": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "util::range_alloc::RangeAllocator": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor",
        "core::option::Option": "Constructor",
        "alloc::collections::BTreeMap": "Constructor",
        "util::range_alloc::FreeRange": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets an iterator over the entries of the map, sorted by key.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(3, \"c\");\n map.insert(2, \"b\");\n map.insert(1, \"a\");\n\n for (key, value) in map.iter() {\n     println!(\"{key}: {value}\");\n }\n\n let (first_key, first_value) = map.iter().next().unwrap();\n assert_eq!((*first_key, *first_value), (1, \"a\"));\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the value corresponding to the key.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n if let Some(x) = map.get_mut(&1) {\n     *x = \"b\";\n }\n assert_eq!(map[&1], \"b\");\n ```\n",
      "adt": {}
    },
    "util::range_alloc::FreeRange::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "util::range_alloc::FreeRange": "Constructor"
      }
    },
    "alloc::collections::BTreeMap::<K, V, A>::insert": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a key-value pair into the map.\n\n If the map did not have this key present, `None` is returned.\n\n If the map did have this key present, the value is updated, and the old\n value is returned. The key is not updated, though; this matters for\n types that can be `==` without being identical. See the [module-level\n documentation] for more.\n\n [module-level documentation]: index.html#insert-and-complex-keys\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n assert_eq!(map.insert(37, \"a\"), None);\n assert_eq!(map.is_empty(), false);\n\n map.insert(37, \"b\");\n assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n assert_eq!(map[&37], \"c\");\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ops::Range": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "util::range_alloc::RangeAllocator": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7910, kind: RigidTy(Tuple([Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) }, Ty { id: 7911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Not)) }])) }), Field(0, Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7910, kind: RigidTy(Tuple([Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) }, Ty { id: 7911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Not)) }])) }), Field(1, Ty { id: 7911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7914, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Mut)) })])",
      "Ref"
    ],
    "alloc::collections::BTreeMap": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "alloc::collections::btree_map::Iter": [
      "Plain",
      "MutRef"
    ],
    "util::range_alloc::FreeRange": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "Plain"
    ]
  },
  "path": 2957,
  "span": "ostd/src/util/range_alloc.rs:30:5: 70:6",
  "src": "pub fn alloc_specific(&self, allocate_range: &Range<usize>) -> Result<(), RangeAllocError> {\n        if allocate_range.is_empty() {\n            return Err(RangeAllocError);\n        }\n\n        let mut lock_guard = self.get_freelist_guard();\n        let freelist = lock_guard.as_mut().unwrap();\n        let mut target_node = None;\n        let mut left_length = 0;\n        let mut right_length = 0;\n\n        for (key, value) in freelist.iter() {\n            if value.block.end >= allocate_range.end && value.block.start <= allocate_range.start {\n                target_node = Some(*key);\n                left_length = allocate_range.start - value.block.start;\n                right_length = value.block.end - allocate_range.end;\n                break;\n            }\n        }\n\n        if let Some(key) = target_node {\n            if left_length == 0 {\n                freelist.remove(&key);\n            } else if let Some(freenode) = freelist.get_mut(&key) {\n                freenode.block.end = allocate_range.start;\n            }\n\n            if right_length != 0 {\n                freelist.insert(\n                    allocate_range.end,\n                    FreeRange::new(allocate_range.end..(allocate_range.end + right_length)),\n                );\n            }\n        }\n\n        if target_node.is_some() {\n            Ok(())\n        } else {\n            Err(RangeAllocError)\n        }\n    }",
  "mir": "fn util::range_alloc::RangeAllocator::alloc_specific(_1: &util::range_alloc::RangeAllocator, _2: &core::ops::Range<usize>) -> core::result::Result<(), util::range_alloc::RangeAllocError> {\n    let mut _0: core::result::Result<(), util::range_alloc::RangeAllocError>;\n    let mut _3: bool;\n    let mut _4: sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled>;\n    let  _5: &mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>;\n    let mut _6: core::option::Option<&mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>;\n    let mut _7: &mut core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>;\n    let mut _8: &mut sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled>;\n    let mut _9: core::option::Option<usize>;\n    let mut _10: usize;\n    let mut _11: usize;\n    let mut _12: alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _13: alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _14: &alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>;\n    let mut _15: alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _16: core::option::Option<(&usize, &util::range_alloc::FreeRange)>;\n    let mut _17: &mut alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _18: isize;\n    let  _19: &usize;\n    let  _20: &util::range_alloc::FreeRange;\n    let mut _21: bool;\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: bool;\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: core::option::Option<usize>;\n    let mut _28: usize;\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: (usize, bool);\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: (usize, bool);\n    let mut _35: isize;\n    let  _36: usize;\n    let mut _37: usize;\n    let  _38: core::option::Option<util::range_alloc::FreeRange>;\n    let  _39: &usize;\n    let mut _40: core::option::Option<&mut util::range_alloc::FreeRange>;\n    let  _41: &usize;\n    let mut _42: isize;\n    let  _43: &mut util::range_alloc::FreeRange;\n    let mut _44: usize;\n    let mut _45: usize;\n    let  _46: core::option::Option<util::range_alloc::FreeRange>;\n    let mut _47: usize;\n    let mut _48: util::range_alloc::FreeRange;\n    let mut _49: core::ops::Range<usize>;\n    let mut _50: usize;\n    let mut _51: usize;\n    let mut _52: usize;\n    let mut _53: usize;\n    let mut _54: (usize, bool);\n    let mut _55: bool;\n    let mut _56: &core::option::Option<usize>;\n    debug self => _1;\n    debug allocate_range => _2;\n    debug lock_guard => _4;\n    debug freelist => _5;\n    debug target_node => _9;\n    debug left_length => _10;\n    debug right_length => _11;\n    debug iter => _15;\n    debug key => _19;\n    debug value => _20;\n    debug key => _36;\n    debug freenode => _43;\n    bb0: {\n        StorageLive(_3);\n        _3 = core::ops::Range::<usize>::is_empty(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        _0 = core::result::Result::Err(util::range_alloc::RangeAllocError);\n        StorageDead(_3);\n        goto -> bb42;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = util::range_alloc::RangeAllocator::get_freelist_guard(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_6);\n        StorageLive(_8);\n        _8 = &mut _4;\n        _7 = <sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _6 = core::option::Option::<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>::as_mut(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _5 = core::option::Option::<&mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>::unwrap(move _6) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_6);\n        StorageLive(_9);\n        _9 = core::option::Option::None;\n        StorageLive(_10);\n        _10 = 0_usize;\n        StorageLive(_11);\n        _11 = 0_usize;\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &(*_5);\n        _13 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::iter(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        _12 = <alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange> as core::iter::IntoIterator>::into_iter(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = move _12;\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_16);\n        _17 = &mut _15;\n        _16 = <alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange> as core::iter::Iterator>::next(_17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb21, 1: bb13, otherwise: bb12];\n    }\n    bb12: {\n        unreachable;\n    }\n    bb13: {\n        StorageLive(_19);\n        _19 = (((_16 as variant#1).0: (&usize, &util::range_alloc::FreeRange)).0: &usize);\n        StorageLive(_20);\n        _20 = (((_16 as variant#1).0: (&usize, &util::range_alloc::FreeRange)).1: &util::range_alloc::FreeRange);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = (((*_20).0: core::ops::Range<usize>).1: usize);\n        StorageLive(_23);\n        _23 = ((*_2).1: usize);\n        _21 = Ge(move _22, move _23);\n        switchInt(move _21) -> [0: bb19, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = (((*_20).0: core::ops::Range<usize>).0: usize);\n        StorageLive(_26);\n        _26 = ((*_2).0: usize);\n        _24 = Le(move _25, move _26);\n        switchInt(move _24) -> [0: bb18, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = (*_19);\n        _27 = core::option::Option::Some(move _28);\n        StorageDead(_28);\n        _9 = move _27;\n        StorageDead(_27);\n        StorageLive(_29);\n        _29 = ((*_2).0: usize);\n        StorageLive(_30);\n        _30 = (((*_20).0: core::ops::Range<usize>).0: usize);\n        _31 = CheckedSub(_29, _30);\n        assert(!move (_31.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _29, move _30) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _10 = move (_31.0: usize);\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_32);\n        _32 = (((*_20).0: core::ops::Range<usize>).1: usize);\n        StorageLive(_33);\n        _33 = ((*_2).1: usize);\n        _34 = CheckedSub(_32, _33);\n        assert(!move (_34.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _32, move _33) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _11 = move (_34.0: usize);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb21;\n    }\n    bb18: {\n        StorageDead(_26);\n        StorageDead(_25);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_16);\n        goto -> bb10;\n    }\n    bb21: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_12);\n        _35 = discriminant(_9);\n        switchInt(move _35) -> [1: bb22, 0: bb36, otherwise: bb12];\n    }\n    bb22: {\n        StorageLive(_36);\n        _36 = ((_9 as variant#1).0: usize);\n        StorageLive(_37);\n        _37 = _10;\n        switchInt(move _37) -> [0: bb23, otherwise: bb25];\n    }\n    bb23: {\n        StorageDead(_37);\n        StorageLive(_38);\n        _39 = &_36;\n        _38 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::remove::<usize>(_5, _39) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_38);\n        goto -> bb29;\n    }\n    bb25: {\n        StorageDead(_37);\n        StorageLive(_40);\n        _41 = &_36;\n        _40 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::get_mut::<usize>(_5, _41) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _42 = discriminant(_40);\n        switchInt(move _42) -> [1: bb27, 0: bb28, otherwise: bb12];\n    }\n    bb27: {\n        StorageLive(_43);\n        _43 = move ((_40 as variant#1).0: &mut util::range_alloc::FreeRange);\n        StorageLive(_44);\n        _44 = ((*_2).0: usize);\n        (((*_43).0: core::ops::Range<usize>).1: usize) = move _44;\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageDead(_40);\n        goto -> bb29;\n    }\n    bb28: {\n        StorageDead(_40);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageLive(_45);\n        _45 = _11;\n        switchInt(move _45) -> [0: bb34, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = ((*_2).1: usize);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = ((*_2).1: usize);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = ((*_2).1: usize);\n        StorageLive(_53);\n        _53 = _11;\n        _54 = CheckedAdd(_52, _53);\n        assert(!move (_54.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _52, move _53) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _51 = move (_54.0: usize);\n        StorageDead(_53);\n        StorageDead(_52);\n        _49 = Range(move _50, move _51);\n        StorageDead(_51);\n        StorageDead(_50);\n        _48 = util::range_alloc::FreeRange::new(move _49) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_49);\n        _46 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::insert(_5, move _47, move _48) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageDead(_46);\n        goto -> bb35;\n    }\n    bb34: {\n        StorageDead(_45);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_36);\n        goto -> bb36;\n    }\n    bb36: {\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = &_9;\n        _55 = core::option::Option::<usize>::is_some(move _56) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        switchInt(move _55) -> [0: bb39, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_56);\n        _0 = core::result::Result::Ok(());\n        goto -> bb40;\n    }\n    bb39: {\n        StorageDead(_56);\n        _0 = core::result::Result::Err(util::range_alloc::RangeAllocError);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageDead(_55);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        drop(_4) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_4);\n        goto -> bb42;\n    }\n    bb42: {\n        return;\n    }\n}\n",
  "doc": " Allocates a specific kernel virtual area.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}