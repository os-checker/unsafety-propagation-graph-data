{
  "name": "arch::iommu::invalidate::init",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::registers::IommuRegisters::read_extended_capability": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the extended Capability of IOMMU\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "ImmutableAsArgument",
        "arch::iommu::registers::extended_cap::ExtendedCapability": "Constructor"
      }
    },
    "arch::iommu::registers::extended_cap::ExtendedCapability::flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extended capability flags\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapability": "ImmutableAsArgument",
        "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": "Constructor"
      }
    },
    "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if all of the flags in `other` are contained within `self`.\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": "ImmutableAsArgument"
      }
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "arch::iommu::registers::IommuRegisters": [
      "Ref"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapability": [
      "Plain",
      "Ref"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": [
      "Plain",
      "Ref"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::iommu::invalidate::init"
  },
  "span": "ostd/src/arch/x86/iommu/invalidate/mod.rs:13:1: 31:2",
  "src": "pub(super) fn init() {\n    let mut iommu_regs = IOMMU_REGS.get().unwrap().lock();\n    if !iommu_regs\n        .read_extended_capability()\n        .flags()\n        .contains(ExtendedCapabilityFlags::QI)\n    {\n        warn!(\"[IOMMU] Queued invalidation not supported\");\n        return;\n    }\n\n    QUEUE.call_once(|| {\n        let queue = Queue::new();\n        iommu_regs.enable_queued_invalidation(&queue);\n        SpinLock::new(queue)\n    });\n\n    info!(\"[IOMMU] Queued invalidation is enabled\");\n}",
  "mir": "fn arch::iommu::invalidate::init() -> () {\n    let mut _0: ();\n    let mut _1: sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _2: &sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let mut _3: core::option::Option<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let mut _4: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let mut _5: bool;\n    let mut _6: &arch::iommu::registers::extended_cap::ExtendedCapabilityFlags;\n    let  _7: arch::iommu::registers::extended_cap::ExtendedCapabilityFlags;\n    let mut _8: &arch::iommu::registers::extended_cap::ExtendedCapability;\n    let  _9: arch::iommu::registers::extended_cap::ExtendedCapability;\n    let  _10: &arch::iommu::registers::IommuRegisters;\n    let mut _11: &sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _12: log::Level;\n    let mut _13: bool;\n    let mut _14: &log::Level;\n    let mut _15: &log::LevelFilter;\n    let mut _16: bool;\n    let mut _17: &log::Level;\n    let mut _18: &log::LevelFilter;\n    let  _19: log::LevelFilter;\n    let  _20: ();\n    let mut _21: core::fmt::Arguments<'_>;\n    let  _22: &(&str, &str, &core::panic::Location<'_>);\n    let  _23: (&str, &str, &core::panic::Location<'_>);\n    let mut _24: &str;\n    let  _25: &core::panic::Location<'_>;\n    let  _26: &sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>;\n    let mut _27: &spin::once::Once<sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>;\n    let mut _28: {closure@ostd/src/arch/x86/iommu/invalidate/mod.rs:24:21: 24:23};\n    let mut _29: &mut sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _30: log::Level;\n    let mut _31: bool;\n    let mut _32: &log::Level;\n    let mut _33: &log::LevelFilter;\n    let mut _34: bool;\n    let mut _35: &log::Level;\n    let mut _36: &log::LevelFilter;\n    let  _37: log::LevelFilter;\n    let  _38: ();\n    let mut _39: core::fmt::Arguments<'_>;\n    let  _40: &(&str, &str, &core::panic::Location<'_>);\n    let  _41: (&str, &str, &core::panic::Location<'_>);\n    let mut _42: &str;\n    let  _43: &core::panic::Location<'_>;\n    debug iommu_regs => _1;\n    debug lvl => _12;\n    debug lvl => _30;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc227: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>};\n        _3 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::get(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = core::option::Option::<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::unwrap(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _1 = sync::spin::SpinLock::<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>::lock(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_11);\n        _11 = &_1;\n        _10 = <sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled> as core::ops::Deref>::deref(move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        _9 = arch::iommu::registers::IommuRegisters::read_extended_capability(_10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = &_9;\n        _7 = arch::iommu::registers::extended_cap::ExtendedCapability::flags(move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _6 = &_7;\n        StorageDead(_8);\n        _5 = arch::iommu::registers::extended_cap::ExtendedCapabilityFlags::contains(move _6, arch::iommu::registers::extended_cap::ExtendedCapabilityFlags::QI) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _5) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = {alloc203: &spin::once::Once<sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>};\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &mut _1;\n        _28 = {closure@ostd/src/arch/x86/iommu/invalidate/mod.rs:24:21: 24:23}(move _29);\n        StorageDead(_29);\n        _26 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>::call_once::<{closure@ostd/src/arch/x86/iommu/invalidate/mod.rs:24:21: 24:23}>(move _27, move _28) -> [return: bb21, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        StorageDead(_9);\n        StorageDead(_7);\n        _12 = log::Level::Warn;\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_12;\n        StorageLive(_15);\n        _15 = arch::iommu::invalidate::init::promoted[1];\n        _13 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _14, move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _13) -> [0: bb19, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_12;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = log::max_level() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = &_19;\n        _16 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _17, move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _16) -> [0: bb18, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_21);\n        _21 = core::fmt::Arguments::<'_>::from_str(\"[IOMMU] Queued invalidation not supported\") -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = \"ostd::arch::iommu::invalidate\";\n        _25 = log::__private_api::loc() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _23 = (move _24, \"ostd::arch::iommu::invalidate\", _25);\n        StorageDead(_24);\n        _22 = &_23;\n        _20 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _21, _12, _22, ()) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_21);\n        StorageDead(_23);\n        goto -> bb20;\n    }\n    bb18: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageDead(_5);\n        drop(_1) -> [return: bb34, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_26);\n        _30 = log::Level::Info;\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &_30;\n        StorageLive(_33);\n        _33 = arch::iommu::invalidate::init::promoted[0];\n        _31 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _32, move _33) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _31) -> [0: bb31, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_30;\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = log::max_level() -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _36 = &_37;\n        _34 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _35, move _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _34) -> [0: bb30, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_39);\n        _39 = core::fmt::Arguments::<'_>::from_str(\"[IOMMU] Queued invalidation is enabled\") -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = \"ostd::arch::iommu::invalidate\";\n        _43 = log::__private_api::loc() -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _41 = (move _42, \"ostd::arch::iommu::invalidate\", _43);\n        StorageDead(_42);\n        _40 = &_41;\n        _38 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _39, _30, _40, ()) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_39);\n        StorageDead(_41);\n        goto -> bb32;\n    }\n    bb30: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_35);\n        goto -> bb32;\n    }\n    bb31: {\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_34);\n        StorageDead(_31);\n        drop(_1) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_1);\n        goto -> bb35;\n    }\n    bb34: {\n        StorageDead(_1);\n        goto -> bb35;\n    }\n    bb35: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}