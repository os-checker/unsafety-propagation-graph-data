{
  "name": "init",
  "safe": false,
  "callees": {
    "arch::enable_cpu_features": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::frame::allocator::init_early_allocator": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the early frame allocator.\n\n [`early_alloc`] should be used after this initialization. After [`init`], the\n early allocator.\n\n # Safety\n\n This function should be called only once after the memory regions are ready.\n",
      "adt": {}
    },
    "tdx_guest::tdx_is_enabled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::serial::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the serial port.\n",
      "adt": {}
    },
    "logger::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the logger. Users should avoid using the log macros before this function is called.\n",
      "adt": {}
    },
    "cpu::init_on_bsp": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the CPU module (the BSP part).\n\n # Safety\n\n The caller must ensure that\n 1. We're in the boot context of the BSP and APs have not yet booted.\n 2. The number of CPUs is available.\n 3. CPU-local storage has NOT been used.\n",
      "adt": {}
    },
    "mm::frame::meta::init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the metadata of all physical frames.\n\n The function returns a list of `Frame`s containing the metadata.\n\n # Safety\n\n This function should be called only once and only on the BSP,\n before any APs are started.\n",
      "adt": {
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "mm::frame::allocator::init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the global frame allocator.\n\n It just does adds the frames to the global frame allocator. Calling it\n multiple times would be not safe.\n\n # Safety\n\n This function should be called only once.\n",
      "adt": {}
    },
    "mm::kspace::init_kernel_page_table": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the kernel page table.\n\n This function should be called after:\n  - the page allocator and the heap allocator are initialized;\n  - the memory regions are initialized.\n\n This function should be called before:\n  - any initializer that modifies the kernel page table.\n",
      "adt": {
        "mm::frame::segment::Segment": "ImmutableAsArgument"
      }
    },
    "mm::kspace::activate_kernel_page_table": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Activates the kernel page table.\n\n All address translation of symbols in the boot sections must be manually\n done from now on.\n\n # Safety\n\n This function must only be called once per CPU.\n",
      "adt": {}
    },
    "sync::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "boot::init_after_heap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the boot information.\n\n This function copies the boot-time accessible information to the heap to\n allow [`boot_info`] to work properly.\n",
      "adt": {}
    },
    "arch::late_init_on_bsp": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Architecture-specific initialization on the bootstrapping processor.\n\n It should be called when the heap and frame allocators are available.\n\n # Safety\n\n 1. This function must be called only once in the boot context of the\n    bootstrapping processor.\n 2. This function must be called after the kernel page table is activated on\n    the bootstrapping processor.\n",
      "adt": {}
    },
    "smp::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::page_table::boot_pt::dismiss": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dismiss the boot page table.\n\n By calling it on a CPU, the caller claims that the boot page table is no\n longer needed on this CPU.\n\n # Safety\n\n The caller should ensure that:\n  - another legitimate page table is activated on this CPU;\n  - this function should be called only once per CPU;\n  - no [`with_borrow`] calls are performed on this CPU after this dismissal;\n",
      "adt": {}
    },
    "arch::irq::ops::enable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "invoke_ffi_init_funcs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invoke the initialization functions defined in the FFI.\n The component system uses this function to call the initialization functions of\n the components.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the bool.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n some_bool.store(false, Ordering::Relaxed);\n assert_eq!(some_bool.load(Ordering::Relaxed), false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::segment::Segment": [
      "Plain"
    ],
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::init"
  },
  "span": "ostd/src/lib.rs:72:1: 132:2",
  "src": "unsafe fn init() {\n    arch::enable_cpu_features();\n\n    // SAFETY: This function is called only once, before `allocator::init`\n    // and after memory regions are initialized.\n    unsafe { mm::frame::allocator::init_early_allocator() };\n\n    #[cfg(target_arch = \"x86_64\")]\n    arch::if_tdx_enabled!({\n    } else {\n        arch::serial::init();\n    });\n    #[cfg(not(target_arch = \"x86_64\"))]\n    arch::serial::init();\n\n    logger::init();\n\n    // SAFETY:\n    //  1. They are only called once in the boot context of the BSP.\n    //  2. The number of CPUs are available because ACPI has been initialized.\n    //  3. CPU-local storage has NOT been used.\n    unsafe { cpu::init_on_bsp() };\n\n    // SAFETY: We are on the BSP and APs are not yet started.\n    let meta_pages = unsafe { mm::frame::meta::init() };\n    // The frame allocator should be initialized immediately after the metadata\n    // is initialized. Otherwise the boot page table can't allocate frames.\n    // SAFETY: This function is called only once.\n    unsafe { mm::frame::allocator::init() };\n\n    mm::kspace::init_kernel_page_table(meta_pages);\n\n    // SAFETY: This function is called only once on the BSP.\n    unsafe { mm::kspace::activate_kernel_page_table() };\n\n    sync::init();\n\n    boot::init_after_heap();\n\n    // SAFETY: This function is called only once on the BSP.\n    unsafe { arch::late_init_on_bsp() };\n\n    #[cfg(target_arch = \"x86_64\")]\n    arch::if_tdx_enabled!({\n        arch::serial::init();\n    });\n\n    smp::init();\n\n    // SAFETY:\n    // 1. The kernel page table is activated on the BSP.\n    // 2. The function is called only once on the BSP.\n    // 3. No remaining `with_borrow` invocations from now.\n    unsafe { crate::mm::page_table::boot_pt::dismiss() };\n\n    arch::irq::enable_local();\n\n    invoke_ffi_init_funcs();\n\n    IN_BOOTSTRAP_CONTEXT.store(false, Ordering::Relaxed);\n}",
  "mir": "fn init() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let  _2: ();\n    let mut _3: bool;\n    let  _4: ();\n    let  _5: ();\n    let  _6: ();\n    let  _7: mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta>;\n    let  _8: ();\n    let  _9: ();\n    let  _10: ();\n    let  _11: ();\n    let  _12: ();\n    let  _13: ();\n    let mut _14: bool;\n    let  _15: ();\n    let  _16: ();\n    let  _17: ();\n    let  _18: ();\n    let  _19: ();\n    let  _20: ();\n    let mut _21: &core::sync::atomic::AtomicBool;\n    let mut _22: core::sync::atomic::Ordering;\n    debug meta_pages => _7;\n    bb0: {\n        _1 = arch::enable_cpu_features() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = mm::frame::allocator::init_early_allocator() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_3);\n        _3 = tdx_guest::tdx_is_enabled() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _3) -> [0: bb4, otherwise: bb5];\n    }\n    bb4: {\n        _4 = arch::serial::init() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_3);\n        _5 = logger::init() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _6 = cpu::init_on_bsp() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _7 = mm::frame::meta::init() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _8 = mm::frame::allocator::init() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _9 = mm::kspace::init_kernel_page_table(_7) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _10 = mm::kspace::activate_kernel_page_table() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _11 = sync::init() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _12 = boot::init_after_heap() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _13 = arch::late_init_on_bsp() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_14);\n        _14 = tdx_guest::tdx_is_enabled() -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _14) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        _15 = arch::serial::init() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_14);\n        _16 = smp::init() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _17 = mm::page_table::boot_pt::dismiss() -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _18 = arch::irq::ops::enable_local() -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _19 = invoke_ffi_init_funcs() -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_21);\n        _21 = {alloc1600: &core::sync::atomic::AtomicBool};\n        StorageLive(_22);\n        _22 = core::sync::atomic::Ordering::Relaxed;\n        _20 = core::sync::atomic::AtomicBool::store(move _21, false, move _22) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_22);\n        StorageDead(_21);\n        return;\n    }\n}\n",
  "doc": " Initializes OSTD.\n\n This function represents the first phase booting up the system. It makes\n all functionalities of OSTD available after the call.\n\n # Safety\n\n This function should be called only once and only on the BSP.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}