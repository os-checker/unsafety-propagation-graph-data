{
  "name": "arch::cpu::extension::init",
  "safe": true,
  "callees": {
    "arch::cpu::extension::IsaExtensions::empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an empty set of flags.\n",
      "adt": {
        "arch::cpu::extension::IsaExtensions": "Constructor"
      }
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "arch::cpu::cpuid::cpuid": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the CPUID instruction for the given leaf and subleaf.\n\n This method will return `None` if the leaf is not supported.\n",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::ops::BitOrAssign::bitor_assign": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `|=` operation.\n\n # Examples\n\n ```\n let mut x = true;\n x |= false;\n assert_eq!(x, true);\n\n let mut x = false;\n x |= false;\n assert_eq!(x, false);\n\n let mut x: u8 = 5;\n x |= 1;\n assert_eq!(x, 5);\n\n let mut x: u8 = 5;\n x |= 2;\n assert_eq!(x, 7);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "arch::cpu::extension::IsaExtensions": [
      "Plain",
      "MutRef",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 815, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 842, kind: RigidTy(Adt(AdtDef(DefId { id: 3349, name: \"arch::cpu::extension::ExtensionLeaf\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 782, kind: RigidTy(Adt(AdtDef(DefId { id: 3332, name: \"core::arch::x86_64::CpuidResult\" }), GenericArgs([]))) }), Field(1, Ty { id: 9, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 782, kind: RigidTy(Adt(AdtDef(DefId { id: 3332, name: \"core::arch::x86_64::CpuidResult\" }), GenericArgs([]))) }), Field(2, Ty { id: 9, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 782, kind: RigidTy(Adt(AdtDef(DefId { id: 3332, name: \"core::arch::x86_64::CpuidResult\" }), GenericArgs([]))) }), Field(3, Ty { id: 9, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 820, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 844, kind: RigidTy(Adt(AdtDef(DefId { id: 3353, name: \"arch::cpu::extension::ExtensionData\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "arch::cpu::extension::ExtensionLeaf": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "arch::cpu::extension::ExtensionData": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::cpu::extension::init"
  },
  "span": "ostd/src/arch/x86/cpu/extension.rs:13:1: 36:2",
  "src": "pub(in crate::arch) fn init() {\n    let mut global_isa_extensions = IsaExtensions::empty();\n\n    for ext_leaf in EXTENSION_TABLE.iter() {\n        let Some(CpuidResult { ebx, ecx, edx, .. }) = cpuid(ext_leaf.leaf, ext_leaf.subleaf) else {\n            continue;\n        };\n\n        for ext_data in ext_leaf.data.iter() {\n            let bits = match ext_data.reg {\n                Reg::Ebx => ebx,\n                Reg::Ecx => ecx,\n                Reg::Edx => edx,\n            };\n            if bits & (1 << ext_data.bit) != 0 {\n                global_isa_extensions |= ext_data.flag;\n            }\n        }\n    }\n\n    log::info!(\"Detected ISA extensions: {:?}\", global_isa_extensions);\n\n    GLOBAL_ISA_EXTENSIONS.call_once(|| global_isa_extensions);\n}",
  "mir": "fn arch::cpu::extension::init() -> () {\n    let mut _0: ();\n    let mut _1: arch::cpu::extension::IsaExtensions;\n    let mut _2: core::slice::Iter<'_, arch::cpu::extension::ExtensionLeaf>;\n    let mut _3: core::slice::Iter<'_, arch::cpu::extension::ExtensionLeaf>;\n    let mut _4: &[arch::cpu::extension::ExtensionLeaf];\n    let mut _5: core::slice::Iter<'_, arch::cpu::extension::ExtensionLeaf>;\n    let mut _6: core::option::Option<&arch::cpu::extension::ExtensionLeaf>;\n    let mut _7: &mut core::slice::Iter<'_, arch::cpu::extension::ExtensionLeaf>;\n    let mut _8: isize;\n    let  _9: &arch::cpu::extension::ExtensionLeaf;\n    let  _10: u32;\n    let  _11: u32;\n    let  _12: u32;\n    let mut _13: core::option::Option<core::arch::x86_64::CpuidResult>;\n    let mut _14: u32;\n    let mut _15: u32;\n    let mut _16: isize;\n    let mut _17: core::slice::Iter<'_, arch::cpu::extension::ExtensionData>;\n    let mut _18: core::slice::Iter<'_, arch::cpu::extension::ExtensionData>;\n    let mut _19: core::slice::Iter<'_, arch::cpu::extension::ExtensionData>;\n    let mut _20: core::option::Option<&arch::cpu::extension::ExtensionData>;\n    let mut _21: &mut core::slice::Iter<'_, arch::cpu::extension::ExtensionData>;\n    let mut _22: isize;\n    let  _23: &arch::cpu::extension::ExtensionData;\n    let  _24: u32;\n    let mut _25: isize;\n    let mut _26: u32;\n    let mut _27: u32;\n    let mut _28: u32;\n    let mut _29: u32;\n    let mut _30: bool;\n    let  _31: ();\n    let mut _32: &mut arch::cpu::extension::IsaExtensions;\n    let mut _33: arch::cpu::extension::IsaExtensions;\n    let  _34: log::Level;\n    let mut _35: bool;\n    let mut _36: &log::Level;\n    let mut _37: &log::LevelFilter;\n    let mut _38: bool;\n    let mut _39: &log::Level;\n    let mut _40: &log::LevelFilter;\n    let  _41: log::LevelFilter;\n    let  _42: ();\n    let mut _43: core::fmt::Arguments<'_>;\n    let  _44: (&arch::cpu::extension::IsaExtensions,);\n    let mut _45: &arch::cpu::extension::IsaExtensions;\n    let  _46: [core::fmt::rt::Argument<'_>; 1];\n    let mut _47: core::fmt::rt::Argument<'_>;\n    let mut _48: &[u8; 28];\n    let  _49: &[core::fmt::rt::Argument<'_>; 1];\n    let  _50: &(&str, &str, &core::panic::Location<'_>);\n    let  _51: (&str, &str, &core::panic::Location<'_>);\n    let mut _52: &str;\n    let  _53: &core::panic::Location<'_>;\n    let  _54: &arch::cpu::extension::IsaExtensions;\n    let mut _55: &spin::once::Once<arch::cpu::extension::IsaExtensions>;\n    let mut _56: {closure@ostd/src/arch/x86/cpu/extension.rs:35:37: 35:39};\n    let mut _57: &arch::cpu::extension::IsaExtensions;\n    let mut _58: &[arch::cpu::extension::ExtensionData];\n    let mut _59: &arch::cpu::extension::IsaExtensions;\n    debug global_isa_extensions => _1;\n    debug iter => _5;\n    debug ext_leaf => _9;\n    debug ebx => _10;\n    debug ecx => _11;\n    debug edx => _12;\n    debug iter => _19;\n    debug ext_data => _23;\n    debug bits => _24;\n    debug lvl => _34;\n    debug args => _44;\n    debug args => _46;\n    bb0: {\n        StorageLive(_1);\n        _1 = arch::cpu::extension::IsaExtensions::empty() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = arch::cpu::extension::EXTENSION_TABLE;\n        _3 = core::slice::<impl [arch::cpu::extension::ExtensionLeaf]>::iter(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _2 = <core::slice::Iter<'_, arch::cpu::extension::ExtensionLeaf> as core::iter::IntoIterator>::into_iter(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = move _2;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_6);\n        _7 = &mut _5;\n        _6 = <core::slice::Iter<'_, arch::cpu::extension::ExtensionLeaf> as core::iter::Iterator>::next(_7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = discriminant(_6);\n        switchInt(move _8) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageLive(_9);\n        _9 = ((_6 as variant#1).0: &arch::cpu::extension::ExtensionLeaf);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ((*_9).0: u32);\n        StorageLive(_15);\n        _15 = ((*_9).1: u32);\n        _13 = arch::cpu::cpuid::cpuid(move _14, move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_2);\n        _34 = log::Level::Info;\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &_34;\n        StorageLive(_37);\n        _37 = arch::cpu::extension::init::promoted[0];\n        _35 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _36, move _37) -> [return: bb27, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _16 = discriminant(_13);\n        switchInt(move _16) -> [1: bb10, 0: bb11, otherwise: bb6];\n    }\n    bb10: {\n        StorageLive(_10);\n        _10 = (((_13 as variant#1).0: core::arch::x86_64::CpuidResult).1: u32);\n        StorageLive(_11);\n        _11 = (((_13 as variant#1).0: core::arch::x86_64::CpuidResult).2: u32);\n        StorageLive(_12);\n        _12 = (((_13 as variant#1).0: core::arch::x86_64::CpuidResult).3: u32);\n        StorageDead(_13);\n        StorageLive(_17);\n        StorageLive(_18);\n        _58 = ((*_9).2: &[arch::cpu::extension::ExtensionData]);\n        _18 = core::slice::<impl [arch::cpu::extension::ExtensionData]>::iter(_58) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_9);\n        StorageDead(_6);\n        goto -> bb4;\n    }\n    bb12: {\n        _17 = <core::slice::Iter<'_, arch::cpu::extension::ExtensionData> as core::iter::IntoIterator>::into_iter(move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = move _17;\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_20);\n        _21 = &mut _19;\n        _20 = <core::slice::Iter<'_, arch::cpu::extension::ExtensionData> as core::iter::Iterator>::next(_21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _22 = discriminant(_20);\n        switchInt(move _22) -> [0: bb17, 1: bb16, otherwise: bb6];\n    }\n    bb16: {\n        StorageLive(_23);\n        _23 = ((_20 as variant#1).0: &arch::cpu::extension::ExtensionData);\n        StorageLive(_24);\n        _25 = discriminant(((*_23).0: arch::cpu::extension::Reg));\n        switchInt(move _25) -> [0: bb20, 1: bb19, 2: bb18, otherwise: bb6];\n    }\n    bb17: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_17);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_6);\n        goto -> bb4;\n    }\n    bb18: {\n        _24 = _12;\n        goto -> bb21;\n    }\n    bb19: {\n        _24 = _11;\n        goto -> bb21;\n    }\n    bb20: {\n        _24 = _10;\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = _24;\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = ((*_23).1: u32);\n        _30 = Lt(_29, 32_u32);\n        assert(move _30, \"attempt to shift left by `{}`, which would overflow\", _29) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _28 = Shl(1_u32, move _29);\n        StorageDead(_29);\n        _26 = BitAnd(move _27, move _28);\n        StorageDead(_28);\n        StorageDead(_27);\n        switchInt(move _26) -> [0: bb25, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_26);\n        StorageLive(_32);\n        _32 = &mut _1;\n        StorageLive(_33);\n        _33 = ((*_23).2: arch::cpu::extension::IsaExtensions);\n        _31 = <arch::cpu::extension::IsaExtensions as core::ops::BitOrAssign>::bitor_assign(move _32, move _33) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb26;\n    }\n    bb25: {\n        StorageDead(_26);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_20);\n        goto -> bb14;\n    }\n    bb27: {\n        switchInt(move _35) -> [0: bb37, otherwise: bb28];\n    }\n    bb28: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &_34;\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = log::max_level() -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _40 = &_41;\n        _38 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _39, move _40) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        switchInt(move _38) -> [0: bb36, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &_1;\n        _44 = (move _45);\n        StorageDead(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _59 = (_44.0: &arch::cpu::extension::IsaExtensions);\n        _47 = core::fmt::rt::Argument::<'_>::new_debug::<arch::cpu::extension::IsaExtensions>(_59) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _46 = [move _47];\n        StorageDead(_47);\n        StorageLive(_48);\n        _48 = b\"\\x19Detected ISA extensions: \\xc0\\x00\";\n        _49 = &_46;\n        _43 = core::fmt::Arguments::<'_>::new::<28, 1>(move _48, _49) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_48);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = \"ostd::arch::cpu::extension\";\n        _53 = log::__private_api::loc() -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _51 = (move _52, \"ostd::arch::cpu::extension\", _53);\n        StorageDead(_52);\n        _50 = &_51;\n        _42 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _43, _34, _50, ()) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_43);\n        StorageDead(_51);\n        StorageDead(_46);\n        StorageDead(_44);\n        goto -> bb38;\n    }\n    bb36: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        goto -> bb38;\n    }\n    bb37: {\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_38);\n        StorageDead(_35);\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = {alloc83: &spin::once::Once<arch::cpu::extension::IsaExtensions>};\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_1;\n        _56 = {closure@ostd/src/arch/x86/cpu/extension.rs:35:37: 35:39}(move _57);\n        StorageDead(_57);\n        _54 = spin::once::Once::<arch::cpu::extension::IsaExtensions>::call_once::<{closure@ostd/src/arch/x86/cpu/extension.rs:35:37: 35:39}>(move _55, move _56) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " Detects available x86 ISA extensions.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}