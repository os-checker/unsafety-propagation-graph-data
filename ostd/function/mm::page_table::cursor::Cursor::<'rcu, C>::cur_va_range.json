{
  "name": "mm::page_table::cursor::Cursor::<'rcu, C>::cur_va_range",
  "safe": true,
  "callees": {
    "mm::page_size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The page size at a given level.\n",
      "adt": {}
    },
    "align_ext::AlignExt::align_down": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns to the greatest number that is smaller than or equal to\n `self` and is a multiple of the given power of two.\n\n The method panics if `power_of_two` is not a\n power of two or is smaller than 2 or the calculation overflows\n because `self` is too large. In release mode,\n\n # Examples\n\n ```\n use crate::align_ext::AlignExt;\n assert_eq!(12usize.align_down(2), 12);\n assert_eq!(12usize.align_down(4), 12);\n assert_eq!(12usize.align_down(8), 8);\n assert_eq!(12usize.align_down(16), 0);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::page_table::cursor::Cursor": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": 2349,
  "span": "ostd/src/mm/page_table/cursor/mod.rs:352:5: 356:6",
  "src": "fn cur_va_range(&self) -> Range<Vaddr> {\n        let entry_size = page_size::<C>(self.level);\n        let entry_start = self.va.align_down(entry_size);\n        entry_start..entry_start + entry_size\n    }",
  "mir": "fn mm::page_table::cursor::Cursor::<'rcu, C>::cur_va_range(_1: &mm::page_table::cursor::Cursor<'_, C>) -> core::ops::Range<usize> {\n    let mut _0: core::ops::Range<usize>;\n    let  _2: usize;\n    let mut _3: u8;\n    let  _4: usize;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: (usize, bool);\n    debug self => _1;\n    debug entry_size => _2;\n    debug entry_start => _4;\n    bb0: {\n        StorageLive(_3);\n        _3 = ((*_1).2: u8);\n        _2 = mm::page_size::<C>(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = ((*_1).4: usize);\n        _4 = <usize as align_ext::AlignExt>::align_down(move _5, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _7 = CheckedAdd(_4, _2);\n        assert(!move (_7.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, _2) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = move (_7.0: usize);\n        _0 = Range(_4, move _6);\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Gets the virtual address range that the current entry covers.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}