{
  "name": "mm::page_table::cursor::Cursor::<'rcu, C>::find_next_impl",
  "safe": true,
  "callees": {
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::cur_va_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the virtual address range that the current entry covers.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "ImmutableAsArgument",
        "core::ops::Range": "Constructor"
      }
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::cur_entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument",
        "mm::page_table::node::entry::Entry": "Constructor"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::to_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a reference to the child.\n",
      "adt": {
        "mm::page_table::node::entry::Entry": "ImmutableAsArgument",
        "mm::page_table::node::child::ChildRef": "Constructor"
      }
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::move_forward": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Traverses forward to the end of [`Self::cur_va_range`].\n\n If reached the end of the current page table node, it (recursively)\n moves itself up to the next page of the parent page.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument"
      }
    },
    "mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'a, mm::page_table::node::PageTablePageMeta<C>>>::make_guard_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new [`PageTableGuard`] without checking if the page table lock is held.\n\n # Safety\n\n This function must be called if this task logically holds the lock.\n\n Calling this function when a guard is already created is undefined behavior\n unless that guard was already forgotten.\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "mm::page_table::node::PageTableGuard::<'rcu, C>::nr_children": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the number of valid PTEs in the node.\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "ImmutableAsArgument"
      }
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::push_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Goes down a level to a child page table.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument",
        "mm::page_table::node::PageTableGuard": "ImmutableAsArgument"
      }
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::split_if_mapped_huge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the entry to smaller pages if it maps to a huge page.\n\n If the entry does map to a huge page, it is split into smaller pages\n mapped by a child page table node. The new child page table node\n is returned.\n\n If the entry does not map to a untracked huge page, the method returns\n `None`.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "mm::page_table::node::entry::Entry": "MutableAsArgument",
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::page_table::cursor::Cursor": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "Deref",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "mm::page_table::node::entry::Entry": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "mm::page_table::node::child::ChildRef": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 5457, kind: RigidTy(Adt(AdtDef(DefId { id: 5173, name: \"mm::frame::frame_ref::FrameRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 5461, kind: RigidTy(Adt(AdtDef(DefId { id: 5364, name: \"mm::page_table::node::PageTablePageMeta\" }), GenericArgs([Type(Ty { id: 1116, kind: Param(ParamTy { index: 1, name: \"C\" }) })]))) })]))) })])"
    ],
    "mm::frame::frame_ref::FrameRef": [
      "Plain"
    ],
    "mm::page_table::node::PageTableGuard": [
      "Plain",
      "Ref"
    ],
    "core::mem::ManuallyDrop": [
      "Plain"
    ]
  },
  "path": 2351,
  "span": "ostd/src/mm/page_table/cursor/mod.rs:216:5: 275:6",
  "src": "fn find_next_impl(\n        &mut self,\n        len: usize,\n        find_unmap_subtree: bool,\n        split_huge: bool,\n    ) -> Option<Vaddr> {\n        assert_eq!(len % C::BASE_PAGE_SIZE, 0);\n        let end = self.va + len;\n        assert!(end <= self.barrier_va.end);\n        debug_assert_eq!(end % C::BASE_PAGE_SIZE, 0);\n\n        let rcu_guard = self.rcu_guard;\n\n        while self.va < end {\n            let cur_va = self.va;\n            let cur_va_range = self.cur_va_range();\n            let cur_entry_fits_range = cur_va == cur_va_range.start && cur_va_range.end <= end;\n\n            let mut cur_entry = self.cur_entry();\n            match cur_entry.to_ref() {\n                ChildRef::PageTable(pt) => {\n                    if find_unmap_subtree\n                        && cur_entry_fits_range\n                        && (C::TOP_LEVEL_CAN_UNMAP || self.level != C::NR_LEVELS)\n                    {\n                        return Some(cur_va);\n                    }\n\n                    // SAFETY: The `pt` must be locked and no other guards exist.\n                    let pt_guard = unsafe { pt.make_guard_unchecked(rcu_guard) };\n                    // If there's no mapped PTEs in the next level, we can\n                    // skip to save time.\n                    if pt_guard.nr_children() != 0 {\n                        self.push_level(pt_guard);\n                    } else {\n                        let _ = ManuallyDrop::new(pt_guard);\n                        self.move_forward();\n                    }\n                    continue;\n                }\n                ChildRef::None => {\n                    self.move_forward();\n                    continue;\n                }\n                ChildRef::Frame(_, _, _) => {\n                    if cur_entry_fits_range || !split_huge {\n                        return Some(cur_va);\n                    }\n\n                    let split_child = cur_entry\n                        .split_if_mapped_huge(rcu_guard)\n                        .expect(\"The entry must be a huge page\");\n                    self.push_level(split_child);\n                    continue;\n                }\n            }\n        }\n\n        None\n    }",
  "mir": "fn mm::page_table::cursor::Cursor::<'rcu, C>::find_next_impl(_1: &mut mm::page_table::cursor::Cursor<'_, C>, _2: usize, _3: bool, _4: bool) -> core::option::Option<usize> {\n    let mut _0: core::option::Option<usize>;\n    let mut _5: (&usize, &usize);\n    let mut _6: &usize;\n    let  _7: usize;\n    let mut _8: bool;\n    let mut _9: &usize;\n    let  _10: &usize;\n    let  _11: &usize;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: usize;\n    let  _15: core::panicking::AssertKind;\n    let  _16: !;\n    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _18: usize;\n    let mut _19: usize;\n    let mut _20: (usize, bool);\n    let mut _21: bool;\n    let mut _22: usize;\n    let mut _23: !;\n    let mut _24: (&usize, &usize);\n    let mut _25: &usize;\n    let  _26: usize;\n    let mut _27: bool;\n    let mut _28: &usize;\n    let  _29: &usize;\n    let  _30: &usize;\n    let mut _31: bool;\n    let mut _32: usize;\n    let mut _33: usize;\n    let  _34: core::panicking::AssertKind;\n    let  _35: !;\n    let mut _36: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _37: &dyn task::atomic_mode::InAtomicMode;\n    let mut _38: bool;\n    let mut _39: usize;\n    let  _40: usize;\n    let  _41: core::ops::Range<usize>;\n    let mut _42: &mm::page_table::cursor::Cursor<'_, C>;\n    let  _43: bool;\n    let mut _44: bool;\n    let mut _45: usize;\n    let mut _46: usize;\n    let mut _47: mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _48: mm::page_table::node::child::ChildRef<'_, C>;\n    let mut _49: &mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _50: isize;\n    let  _51: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _52: bool;\n    let mut _53: bool;\n    let mut _54: u8;\n    let  _55: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _56: u16;\n    let mut _57: &mm::page_table::node::PageTableGuard<'_, C>;\n    let  _58: ();\n    let mut _59: core::mem::ManuallyDrop<mm::page_table::node::PageTableGuard<'_, C>>;\n    let  _60: ();\n    let  _61: ();\n    let mut _62: bool;\n    let  _63: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _64: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _65: &mut mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _66: &str;\n    let  _67: ();\n    debug self => _1;\n    debug len => _2;\n    debug find_unmap_subtree => _3;\n    debug split_huge => _4;\n    debug left_val => _10;\n    debug right_val => _11;\n    debug kind => _15;\n    debug end => _18;\n    debug left_val => _29;\n    debug right_val => _30;\n    debug kind => _34;\n    debug rcu_guard => _37;\n    debug cur_va => _40;\n    debug cur_va_range => _41;\n    debug cur_entry_fits_range => _43;\n    debug cur_entry => _47;\n    debug pt => _51;\n    debug pt_guard => _55;\n    debug split_child => _63;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _8 = Eq(<C as mm::PagingConstsTrait>::BASE_PAGE_SIZE, 0_usize);\n        assert(!move _8, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _2) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = Rem(_2, <C as mm::PagingConstsTrait>::BASE_PAGE_SIZE);\n        _6 = &_7;\n        StorageLive(_9);\n        _9 = mm::page_table::cursor::Cursor::<'_, C>::find_next_impl::promoted[1];\n        _5 = (move _6, move _9);\n        StorageDead(_9);\n        StorageDead(_6);\n        _10 = (_5.0: &usize);\n        _11 = (_5.1: &usize);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (*_10);\n        StorageLive(_14);\n        _14 = (*_11);\n        _12 = Eq(move _13, move _14);\n        switchInt(move _12) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageLive(_19);\n        _19 = ((*_1).4: usize);\n        _20 = CheckedAdd(_19, _2);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _19, _2) -> [success: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _15 = core::panicking::AssertKind::Eq;\n        StorageLive(_17);\n        _17 = core::option::Option::None;\n        _16 = core::panicking::assert_failed::<usize, usize>(_15, _10, _11, move _17) -> unwind unreachable;\n    }\n    bb4: {\n        _18 = move (_20.0: usize);\n        StorageDead(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = (((*_1).5: core::ops::Range<usize>).1: usize);\n        _21 = Le(_18, move _22);\n        switchInt(move _21) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _27 = Eq(<C as mm::PagingConstsTrait>::BASE_PAGE_SIZE, 0_usize);\n        assert(!move _27, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _18) -> [success: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_22);\n        _23 = core::panicking::panic(\"assertion failed: end <= self.barrier_va.end\") -> unwind unreachable;\n    }\n    bb7: {\n        _26 = Rem(_18, <C as mm::PagingConstsTrait>::BASE_PAGE_SIZE);\n        _25 = &_26;\n        StorageLive(_28);\n        _28 = mm::page_table::cursor::Cursor::<'_, C>::find_next_impl::promoted[0];\n        _24 = (move _25, move _28);\n        StorageDead(_28);\n        StorageDead(_25);\n        _29 = (_24.0: &usize);\n        _30 = (_24.1: &usize);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = (*_29);\n        StorageLive(_33);\n        _33 = (*_30);\n        _31 = Eq(move _32, move _33);\n        switchInt(move _31) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_26);\n        StorageDead(_24);\n        _37 = ((*_1).1: &dyn task::atomic_mode::InAtomicMode);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_33);\n        StorageDead(_32);\n        _34 = core::panicking::AssertKind::Eq;\n        StorageLive(_36);\n        _36 = core::option::Option::None;\n        _35 = core::panicking::assert_failed::<usize, usize>(_34, _29, _30, move _36) -> unwind unreachable;\n    }\n    bb10: {\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = ((*_1).4: usize);\n        _38 = Lt(move _39, _18);\n        switchInt(move _38) -> [0: bb44, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_39);\n        _40 = ((*_1).4: usize);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &(*_1);\n        _41 = mm::page_table::cursor::Cursor::<'_, C>::cur_va_range(move _42) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = (_41.0: usize);\n        _44 = Eq(_40, move _45);\n        switchInt(move _44) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_45);\n        StorageLive(_46);\n        _46 = (_41.1: usize);\n        _43 = Le(move _46, _18);\n        StorageDead(_46);\n        goto -> bb15;\n    }\n    bb14: {\n        StorageDead(_45);\n        _43 = false;\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_44);\n        StorageLive(_47);\n        _47 = mm::page_table::cursor::Cursor::<'_, C>::cur_entry(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &_47;\n        _48 = mm::page_table::node::entry::Entry::<'_, '_, C>::to_ref(move _49) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_49);\n        _50 = discriminant(_48);\n        switchInt(move _50) -> [0: bb21, 1: bb19, 2: bb20, otherwise: bb18];\n    }\n    bb18: {\n        unreachable;\n    }\n    bb19: {\n        StorageLive(_62);\n        _62 = _43;\n        switchInt(move _62) -> [0: bb38, otherwise: bb39];\n    }\n    bb20: {\n        _61 = mm::page_table::cursor::Cursor::<'_, C>::move_forward(_1) -> [return: bb37, unwind unreachable];\n    }\n    bb21: {\n        _51 = move ((_48 as variant#0).0: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>);\n        switchInt(_3) -> [0: bb28, otherwise: bb22];\n    }\n    bb22: {\n        StorageLive(_52);\n        _52 = _43;\n        switchInt(move _52) -> [0: bb28, otherwise: bb23];\n    }\n    bb23: {\n        switchInt(<C as mm::page_table::PageTableConfig>::TOP_LEVEL_CAN_UNMAP) -> [0: bb24, otherwise: bb26];\n    }\n    bb24: {\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = ((*_1).2: u8);\n        _53 = Ne(move _54, <C as mm::PagingConstsTrait>::NR_LEVELS);\n        switchInt(move _53) -> [0: bb27, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_54);\n        goto -> bb26;\n    }\n    bb26: {\n        _0 = core::option::Option::Some(_40);\n        StorageDead(_53);\n        StorageDead(_52);\n        goto -> bb46;\n    }\n    bb27: {\n        StorageDead(_54);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_53);\n        StorageDead(_52);\n        _55 = mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>>::make_guard_unchecked::<'_>(_51, _37) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_55;\n        _56 = mm::page_table::node::PageTableGuard::<'_, C>::nr_children(move _57) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_57);\n        switchInt(move _56) -> [0: bb33, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_56);\n        _58 = mm::page_table::cursor::Cursor::<'_, C>::push_level(_1, _55) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        goto -> bb36;\n    }\n    bb33: {\n        StorageDead(_56);\n        StorageLive(_59);\n        _59 = core::mem::ManuallyDrop::<mm::page_table::node::PageTableGuard<'_, C>>::new(_55) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_59);\n        _60 = mm::page_table::cursor::Cursor::<'_, C>::move_forward(_1) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        goto -> bb36;\n    }\n    bb36: {\n        goto -> bb45;\n    }\n    bb37: {\n        goto -> bb45;\n    }\n    bb38: {\n        switchInt(_4) -> [0: bb39, otherwise: bb40];\n    }\n    bb39: {\n        _0 = core::option::Option::Some(_40);\n        StorageDead(_62);\n        goto -> bb46;\n    }\n    bb40: {\n        StorageDead(_62);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = &mut _47;\n        _64 = mm::page_table::node::entry::Entry::<'_, '_, C>::split_if_mapped_huge(move _65, _37) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_65);\n        StorageLive(_66);\n        _66 = \"The entry must be a huge page\";\n        _63 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::expect(move _64, move _66) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_66);\n        StorageDead(_64);\n        _67 = mm::page_table::cursor::Cursor::<'_, C>::push_level(_1, _63) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        goto -> bb45;\n    }\n    bb44: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _0 = core::option::Option::None;\n        goto -> bb47;\n    }\n    bb45: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageDead(_43);\n        StorageDead(_41);\n        StorageDead(_38);\n        goto -> bb10;\n    }\n    bb46: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageDead(_43);\n        StorageDead(_41);\n        StorageDead(_38);\n        goto -> bb47;\n    }\n    bb47: {\n        return;\n    }\n}\n",
  "doc": " Moves the cursor forward to the next fragment in the range.\n\n See [`Self::find_next`] for more details. Other than the semantics\n provided by [`Self::find_next`], this method also supports finding non-\n leaf entries and splitting huge pages if necessary.\n\n `find_unmap_subtree` specifies whether the cursor should stop at the\n highest possible level for unmapping. If `false`, the cursor will only\n stop at leaf entries.\n\n `split_huge` specifies whether the cursor should split huge pages when\n it finds a huge page that is mapped over the required range (`len`).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}