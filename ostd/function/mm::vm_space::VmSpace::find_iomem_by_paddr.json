{
  "name": "mm::vm_space::VmSpace::find_iomem_by_paddr",
  "safe": true,
  "callees": {
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::mem_obj::HasPaddr::paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the start physical address of the memory object.\n",
      "adt": {}
    },
    "mm::mem_obj::HasSize::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the memory object in bytes.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "mm::vm_space::VmSpace": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "Ref"
    ],
    "alloc::vec::Vec": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3713, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3568, kind: RigidTy(Adt(AdtDef(DefId { id: 3873, name: \"io::io_mem::IoMem\" }), GenericArgs([Type(Ty { id: 3582, kind: RigidTy(Adt(AdtDef(DefId { id: 4737, name: \"io::io_mem::Insensitive\" }), GenericArgs([]))) })]))) }, Not)) })])"
    ],
    "io::io_mem::IoMem": [
      "Ref",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::vm_space::VmSpace::find_iomem_by_paddr"
  },
  "span": "ostd/src/mm/vm_space.rs:245:5: 256:6",
  "src": "fn find_iomem_by_paddr(&self, paddr: Paddr) -> Option<(IoMem, usize)> {\n        let iomems = self.iomems.lock();\n        for iomem in iomems.iter() {\n            let start = iomem.paddr();\n            let end = start + iomem.size();\n            if paddr >= start && paddr < end {\n                let offset = paddr - start;\n                return Some((iomem.clone(), offset));\n            }\n        }\n        None\n    }",
  "mir": "fn mm::vm_space::VmSpace::find_iomem_by_paddr(_1: &mm::vm_space::VmSpace, _2: usize) -> core::option::Option<(io::io_mem::IoMem, usize)> {\n    let mut _0: core::option::Option<(io::io_mem::IoMem, usize)>;\n    let  _3: sync::spin::SpinLockGuard<'_, alloc::vec::Vec<io::io_mem::IoMem>, sync::guard::PreemptDisabled>;\n    let mut _4: &sync::spin::SpinLock<alloc::vec::Vec<io::io_mem::IoMem>>;\n    let mut _5: core::slice::Iter<'_, io::io_mem::IoMem>;\n    let mut _6: core::slice::Iter<'_, io::io_mem::IoMem>;\n    let  _7: &[io::io_mem::IoMem];\n    let  _8: &alloc::vec::Vec<io::io_mem::IoMem>;\n    let mut _9: &sync::spin::SpinLockGuard<'_, alloc::vec::Vec<io::io_mem::IoMem>, sync::guard::PreemptDisabled>;\n    let mut _10: core::slice::Iter<'_, io::io_mem::IoMem>;\n    let mut _11: core::option::Option<&io::io_mem::IoMem>;\n    let mut _12: &mut core::slice::Iter<'_, io::io_mem::IoMem>;\n    let mut _13: isize;\n    let  _14: &io::io_mem::IoMem;\n    let  _15: usize;\n    let  _16: usize;\n    let mut _17: usize;\n    let mut _18: (usize, bool);\n    let mut _19: bool;\n    let mut _20: bool;\n    let  _21: usize;\n    let mut _22: (usize, bool);\n    let mut _23: (io::io_mem::IoMem, usize);\n    let mut _24: io::io_mem::IoMem;\n    debug self => _1;\n    debug paddr => _2;\n    debug iomems => _3;\n    debug iter => _10;\n    debug iomem => _14;\n    debug start => _15;\n    debug end => _16;\n    debug offset => _21;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).2: sync::spin::SpinLock<alloc::vec::Vec<io::io_mem::IoMem>>);\n        _3 = sync::spin::SpinLock::<alloc::vec::Vec<io::io_mem::IoMem>>::lock(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_9);\n        _9 = &_3;\n        _8 = <sync::spin::SpinLockGuard<'_, alloc::vec::Vec<io::io_mem::IoMem>, sync::guard::PreemptDisabled> as core::ops::Deref>::deref(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _7 = <alloc::vec::Vec<io::io_mem::IoMem> as core::ops::Deref>::deref(_8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        _6 = core::slice::<impl [io::io_mem::IoMem]>::iter(_7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _5 = <core::slice::Iter<'_, io::io_mem::IoMem> as core::iter::IntoIterator>::into_iter(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = move _5;\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_11);\n        _12 = &mut _10;\n        _11 = <core::slice::Iter<'_, io::io_mem::IoMem> as core::iter::Iterator>::next(_12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb10, 1: bb9, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _14 = ((_11 as variant#1).0: &io::io_mem::IoMem);\n        _15 = <io::io_mem::IoMem as mm::mem_obj::HasPaddr>::paddr(_14) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_5);\n        _0 = core::option::Option::None;\n        drop(_3) -> [return: bb21, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_17);\n        _17 = <io::io_mem::IoMem as mm::mem_obj::HasSize>::size(_14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = CheckedAdd(_15, _17);\n        assert(!move (_18.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _15, move _17) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _16 = move (_18.0: usize);\n        StorageDead(_17);\n        StorageLive(_19);\n        _19 = Ge(_2, _15);\n        switchInt(move _19) -> [0: bb19, otherwise: bb14];\n    }\n    bb14: {\n        StorageLive(_20);\n        _20 = Lt(_2, _16);\n        switchInt(move _20) -> [0: bb18, otherwise: bb15];\n    }\n    bb15: {\n        _22 = CheckedSub(_2, _15);\n        assert(!move (_22.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, _15) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _21 = move (_22.0: usize);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = <io::io_mem::IoMem as core::clone::Clone>::clone(_14) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _23 = (move _24, _21);\n        StorageDead(_24);\n        _0 = core::option::Option::Some(move _23);\n        StorageDead(_23);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_5);\n        drop(_3) -> [return: bb22, unwind unreachable];\n    }\n    bb18: {\n        goto -> bb20;\n    }\n    bb19: {\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_11);\n        goto -> bb6;\n    }\n    bb21: {\n        StorageDead(_3);\n        goto -> bb23;\n    }\n    bb22: {\n        StorageDead(_3);\n        goto -> bb23;\n    }\n    bb23: {\n        return;\n    }\n}\n",
  "doc": " Finds the [`IoMem`] that contains the given physical address.\n\n It is a private method for internal use only. Please refer to\n [`CursorMut::find_iomem_by_paddr`] for more details.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}