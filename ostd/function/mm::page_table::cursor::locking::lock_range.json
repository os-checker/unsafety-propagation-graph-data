{
  "name": "mm::page_table::cursor::locking::lock_range",
  "safe": true,
  "callees": {
    "mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds and locks an intermediate page table node that covers the range.\n\n If that node (or any of its ancestors) does not exist, we need to lock\n the parent and create it. After the creation the lock of the parent will\n be released and the new node will be locked.\n\n If this function founds that a locked node is stray (because of racing with\n page table recycling), it will return `None`. The caller should retry in\n this case to lock the proper node.\n",
      "adt": {
        "mm::page_table::PageTable": "ImmutableAsArgument",
        "core::ops::Range": "ImmutableAsArgument",
        "core::option::Option": "Constructor",
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::frame::Frame": "ImmutableAsArgument"
      }
    },
    "mm::page_size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The page size at a given level.\n",
      "adt": {}
    },
    "align_ext::AlignExt::align_down": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns to the greatest number that is smaller than or equal to\n `self` and is a multiple of the given power of two.\n\n The method panics if `power_of_two` is not a\n power of two or is smaller than 2 or the calculation overflows\n because `self` is too large. In release mode,\n\n # Examples\n\n ```\n use crate::align_ext::AlignExt;\n assert_eq!(12usize.align_down(2), 12);\n assert_eq!(12usize.align_down(4), 12);\n assert_eq!(12usize.align_down(8), 8);\n assert_eq!(12usize.align_down(16), 0);\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "mm::page_table::cursor::locking::dfs_acquire_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the locks for the given range in the sub-tree rooted at the node.\n\n `cur_node_va` must be the virtual address of the `cur_node`. The `va_range`\n must be within the range of the `cur_node`. The range must not be empty.\n\n The function will forget all the [`PageTableGuard`] objects in the sub-tree.\n",
      "adt": {
        "core::ops::Range": "MutableAsArgument",
        "mm::page_table::node::PageTableGuard": "MutableAsArgument"
      }
    },
    "core::array::from_fn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an array where each element is produced by calling `f` with\n that element's index while walking forward through the array.\n\n This is essentially the same as writing\n ```text\n [f(0), f(1), f(2), â€¦, f(N - 2), f(N - 1)]\n ```\n and is similar to `(0..i).map(f)`, just for arrays not iterators.\n\n If `N == 0`, this produces an empty array without ever calling `f`.\n\n # Example\n\n ```rust\n // type inference is helping us here, the way `from_fn` knows how many\n // elements to produce is the length of array down there: only arrays of\n // equal lengths can be compared, so the const generic parameter `N` is\n // inferred to be 5, thus creating array of 5 elements.\n\n let array = core::array::from_fn(|i| i);\n // indexes are:    0  1  2  3  4\n assert_eq!(array, [0, 1, 2, 3, 4]);\n\n let array2: [usize; 8] = core::array::from_fn(|i| i * 2);\n // indexes are:     0  1  2  3  4  5   6   7\n assert_eq!(array2, [0, 2, 4, 6, 8, 10, 12, 14]);\n\n let bool_arr = core::array::from_fn::<_, 5, _>(|i| i % 2 == 0);\n // indexes are:       0     1      2     3      4\n assert_eq!(bool_arr, [true, false, true, false, true]);\n ```\n\n You can also capture things, for example to create an array full of clones\n where you can't just use `[item; N]` because it's not `Copy`:\n ```\n # // TBH `array::repeat` would be better for this, but it's not stable yet.\n let my_string = String::from(\"Hello\");\n let clones: [String; 42] = std::array::from_fn(|_| my_string.clone());\n assert!(clones.iter().all(|x| *x == my_string));\n ```\n\n The array is generated in ascending index order, starting from the front\n and going towards the back, so you can use closures with mutable state:\n ```\n let mut state = 1;\n let a = std::array::from_fn(|_| { let x = state; state *= 2; x });\n assert_eq!(a, [1, 2, 4, 8, 16, 32]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::page_table::PageTable": [
      "Ref"
    ],
    "core::ops::Range": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5640, kind: RigidTy(Adt(AdtDef(DefId { id: 5378, name: \"mm::page_table::node::PageTableGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 1032, kind: Param(ParamTy { index: 0, name: \"C\" }) })]))) })])"
    ],
    "mm::page_table::node::PageTableGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "mm::frame::frame_ref::FrameRef": [
      "Ref"
    ],
    "mm::frame::Frame": [
      "Ref"
    ],
    "mm::page_table::cursor::Cursor": [
      "Plain"
    ]
  },
  "path": 2341,
  "span": "ostd/src/mm/page_table/cursor/locking.rs:21:1: 56:2",
  "src": "pub(super) fn lock_range<'rcu, C: PageTableConfig>(\n    pt: &'rcu PageTable<C>,\n    guard: &'rcu dyn InAtomicMode,\n    va: &Range<Vaddr>,\n) -> Cursor<'rcu, C> {\n    // The re-try loop of finding the sub-tree root.\n    //\n    // If we locked a stray node, we need to re-try. Otherwise, although\n    // there are no safety concerns, the operations of a cursor on an stray\n    // sub-tree will not see the current state and will not change the current\n    // state, breaking serializability.\n    let mut subtree_root = loop {\n        if let Some(subtree_root) = try_traverse_and_lock_subtree_root(pt, guard, va) {\n            break subtree_root;\n        }\n    };\n\n    // Once we have locked the sub-tree that is not stray, we won't read any\n    // stray nodes in the following traversal since we must lock before reading.\n    let guard_level = subtree_root.level();\n    let cur_node_va = va.start.align_down(page_size::<C>(guard_level + 1));\n    dfs_acquire_lock(guard, &mut subtree_root, cur_node_va, va.clone());\n\n    let mut path = core::array::from_fn(|_| None);\n    path[guard_level as usize - 1] = Some(subtree_root);\n\n    Cursor::<'rcu, C> {\n        path,\n        rcu_guard: guard,\n        level: guard_level,\n        guard_level,\n        va: va.start,\n        barrier_va: va.clone(),\n        _phantom: PhantomData,\n    }\n}",
  "mir": "fn mm::page_table::cursor::locking::lock_range(_1: &mm::page_table::PageTable<C>, _2: &dyn task::atomic_mode::InAtomicMode, _3: &core::ops::Range<usize>) -> mm::page_table::cursor::Cursor<'_, C> {\n    let mut _0: mm::page_table::cursor::Cursor<'_, C>;\n    let mut _4: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _5: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _6: isize;\n    let  _7: mm::page_table::node::PageTableGuard<'_, C>;\n    let  _8: u8;\n    let  _9: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    let  _10: &mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _11: &mm::page_table::node::PageTableGuard<'_, C>;\n    let  _12: usize;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: u8;\n    let mut _16: (u8, bool);\n    let  _17: ();\n    let mut _18: &mut mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _19: core::ops::Range<usize>;\n    let mut _20: [core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>; 4];\n    let mut _21: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _22: mm::page_table::node::PageTableGuard<'_, C>;\n    let  _23: usize;\n    let mut _24: usize;\n    let mut _25: (usize, bool);\n    let mut _26: bool;\n    let mut _27: [core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>; 4];\n    let mut _28: usize;\n    let mut _29: core::ops::Range<usize>;\n    debug pt => _1;\n    debug guard => _2;\n    debug va => _3;\n    debug subtree_root => _4;\n    debug subtree_root => _7;\n    debug guard_level => _8;\n    debug cur_node_va => _12;\n    debug path => _20;\n    bb0: {\n        StorageLive(_4);\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root::<C>(_1, _2, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = discriminant(_5);\n        switchInt(move _6) -> [1: bb3, 0: bb17, otherwise: bb18];\n    }\n    bb3: {\n        StorageLive(_7);\n        _7 = move ((_5 as variant#1).0: mm::page_table::node::PageTableGuard<'_, C>);\n        _4 = move _7;\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageLive(_11);\n        _11 = &_4;\n        _10 = <mm::page_table::node::PageTableGuard<'_, C> as core::ops::Deref>::deref(move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = <mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>> as core::ops::Deref>::deref(_10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        _8 = mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::level(_9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_13);\n        _13 = ((*_3).0: usize);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = CheckedAdd(_8, 1_u8);\n        assert(!move (_16.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _8, 1_u8) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _15 = move (_16.0: u8);\n        _14 = mm::page_size::<C>(move _15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        _12 = <usize as align_ext::AlignExt>::align_down(move _13, move _14) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _18 = &mut _4;\n        StorageLive(_19);\n        _19 = <core::ops::Range<usize> as core::clone::Clone>::clone(_3) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _17 = mm::page_table::cursor::locking::dfs_acquire_lock::<C>(_2, _18, _12, move _19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = core::array::from_fn::<core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>, 4, {closure@ostd/src/mm/page_table/cursor/locking.rs:44:41: 44:44}>(ZeroSized: {closure@ostd/src/mm/page_table/cursor/locking.rs:44:41: 44:44}) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = move _4;\n        _21 = core::option::Option::Some(move _22);\n        StorageDead(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = _8 as usize;\n        _25 = CheckedSub(_24, 1_usize);\n        assert(!move (_25.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _24, 1_usize) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _23 = move (_25.0: usize);\n        StorageDead(_24);\n        _26 = Lt(_23, 4_usize);\n        assert(move _26, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _23) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        drop(_20[_23]) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20[_23] = move _21;\n        StorageDead(_21);\n        StorageDead(_23);\n        StorageLive(_27);\n        _27 = move _20;\n        StorageLive(_28);\n        _28 = ((*_3).0: usize);\n        StorageLive(_29);\n        _29 = <core::ops::Range<usize> as core::clone::Clone>::clone(_3) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _0 = Cursor(move _27, _2, _8, _8, move _28, move _29, ZeroSized: core::marker::PhantomData<&mm::page_table::PageTable<C>>);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_20);\n        StorageDead(_4);\n        return;\n    }\n    bb17: {\n        StorageDead(_5);\n        goto -> bb1;\n    }\n    bb18: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}