{
  "name": "mm::frame::meta::init",
  "safe": false,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::filter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which uses a closure to determine if an element\n should be yielded.\n\n Given an element the closure must return `true` or `false`. The returned\n iterator will yield only the elements for which the closure returns\n `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0i32, 1, 2];\n\n let mut iter = a.into_iter().filter(|x| x.is_positive());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `filter()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|x| **x > 1); // needs two *s!\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n It's common to instead use destructuring on the argument to strip away one:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&x| *x > 1); // both & and *\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n or both:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&&x| x > 1); // two &s\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n of these layers.\n\n Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the maximum element of an iterator.\n\n If several elements are equally maximum, the last element is\n returned. If the iterator is empty, [`None`] is returned.\n\n Note that [`f32`]/[`f64`] doesn't implement [`Ord`] due to NaN being\n incomparable. You can work around this by using [`Iterator::reduce`]:\n ```\n assert_eq!(\n     [2.4, f32::NAN, 1.3]\n         .into_iter()\n         .reduce(f32::max)\n         .unwrap_or(0.),\n     2.4\n );\n ```\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n let b: [u32; 0] = [];\n\n assert_eq!(a.into_iter().max(), Some(3));\n assert_eq!(b.into_iter().max(), None);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_lower_hex": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::frame::meta::add_temp_linear_mapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a temporary linear mapping for the metadata frames.\n\n We only assume boot page table to contain 4G linear mapping. Thus if the\n physical memory is huge we end up depleted of linear virtual memory for\n initializing metadata.\n",
      "adt": {}
    },
    "mm::page_size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The page size at a given level.\n",
      "adt": {}
    },
    "mm::frame::meta::alloc_meta_frames": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::page_table::boot_pt::with_borrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The accessor to the boot page table singleton [`BootPageTable`].\n\n The user should provide a closure to access the boot page table. The\n function will acquire the lock and call the closure with a mutable\n reference to the boot page table as the argument.\n\n The boot page table will be dropped when all CPUs have dismissed it.\n This function will return an [`Err`] if the boot page table is dropped.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicUsize::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    },
    "spin::mutex::Mutex::<T, R>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks the [`Mutex`] and returns a guard that permits access to the inner data.\n\n The returned value may be dereferenced for data access\n and the lock will be dropped when the guard falls out of scope.\n\n ```\n let lock = spin::Mutex::new(0);\n {\n     let mut data = lock.lock();\n     // The lock is now locked and the data can be accessed\n     *data += 1;\n     // The lock is implicitly dropped at the end of the scope\n }\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&Option<T>` to `Option<&T>`.\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n reference to the value inside the original.\n\n [`map`]: Option::map\n [String]: ../../std/string/struct.String.html \"String\"\n [`String`]: ../../std/string/struct.String.html \"String\"\n\n ```\n let text: Option<String> = Some(\"Hello, world!\".to_string());\n // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n // then consume *that* with `map`, leaving `text` on the stack.\n let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n println!(\"still can print text: {text:?}\");\n ```\n",
      "adt": {}
    },
    "mm::frame::allocator::EarlyFrameAllocator::allocated_regions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::ops::Range": "Constructor",
        "mm::frame::allocator::EarlyFrameAllocator": "ImmutableAsArgument"
      }
    },
    "util::ops::range_difference": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the [difference] of two [`Range`]s, i.e., `a - b`.\n\n This method will return 0, 1, or 2 ranges. All returned ranges are\n guaranteed to be non-empty and non-overlapping. The returned ranges\n will be sorted in ascending order.\n\n [difference]: https://en.wikipedia.org/wiki/Set_(mathematics)#Set_difference\n",
      "adt": {
        "core::iter::Filter": "Constructor",
        "core::ops::Range": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::frame::segment::Segment::<M>::from_unused": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new [`Segment`] from unused frames.\n\n The caller must provide a closure to initialize metadata for all the frames.\n The closure receives the physical address of the frame and returns the\n metadata, which is similar to [`core::array::from_fn`].\n\n It returns an error if:\n  - the physical address is invalid or not aligned;\n  - any of the frames cannot be created with a specific reason.\n\n # Panics\n\n It panics if the range is empty.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "mm::frame::meta::mark_unusable_ranges": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "boot::EarlyBootInfo": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))"
    ],
    "boot::memory_region::MemoryRegionArray": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Filter": [
      "Plain",
      "MutRef"
    ],
    "core::iter::Map": [
      "Plain"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Field(1, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Ref"
    ],
    "spin::mutex::Mutex": [
      "Ref"
    ],
    "spin::MutexGuard": [
      "Plain",
      "Ref"
    ],
    "mm::frame::allocator::EarlyFrameAllocator": [
      "Ref"
    ],
    "mm::frame::segment::Segment": [
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "Plain"
    ]
  },
  "path": 1969,
  "span": "ostd/src/mm/frame/meta.rs:456:1: 520:2",
  "src": "pub(crate) unsafe fn init() -> Segment<MetaPageMeta> {\n    let max_paddr = {\n        let regions = &crate::boot::EARLY_INFO.get().unwrap().memory_regions;\n        regions\n            .iter()\n            .filter(|r| r.typ().is_physical())\n            .map(|r| r.base() + r.len())\n            .max()\n            .unwrap()\n    };\n\n    info!(\n        \"Initializing frame metadata for physical memory up to {:x}\",\n        max_paddr\n    );\n\n    // In RISC-V, the boot page table has mapped the 512GB memory,\n    // so we don't need to add temporary linear mapping.\n    // In LoongArch, the DWM0 has mapped the whole memory,\n    // so we don't need to add temporary linear mapping.\n    #[cfg(target_arch = \"x86_64\")]\n    add_temp_linear_mapping(max_paddr);\n\n    let tot_nr_frames = max_paddr / page_size::<PagingConsts>(1);\n    let (nr_meta_pages, meta_pages) = alloc_meta_frames(tot_nr_frames);\n\n    // Map the metadata frames.\n    boot_pt::with_borrow(|boot_pt| {\n        for i in 0..nr_meta_pages {\n            let frame_paddr = meta_pages + i * PAGE_SIZE;\n            let vaddr = mapping::frame_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n            let prop = PageProperty {\n                flags: PageFlags::RW,\n                cache: CachePolicy::Writeback,\n                priv_flags: PrivilegedPageFlags::GLOBAL,\n            };\n            // SAFETY: we are doing the metadata mappings for the kernel.\n            unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n        }\n    })\n    .unwrap();\n\n    // Now the metadata frames are mapped, we can initialize the metadata.\n    super::MAX_PADDR.store(max_paddr, Ordering::Relaxed);\n\n    let meta_page_range = meta_pages..meta_pages + nr_meta_pages * PAGE_SIZE;\n\n    let (range_1, range_2) = allocator::EARLY_ALLOCATOR\n        .lock()\n        .as_ref()\n        .unwrap()\n        .allocated_regions();\n    for r in range_difference(&range_1, &meta_page_range) {\n        let early_seg = Segment::from_unused(r, |_| EarlyAllocatedFrameMeta).unwrap();\n        let _ = ManuallyDrop::new(early_seg);\n    }\n    for r in range_difference(&range_2, &meta_page_range) {\n        let early_seg = Segment::from_unused(r, |_| EarlyAllocatedFrameMeta).unwrap();\n        let _ = ManuallyDrop::new(early_seg);\n    }\n\n    mark_unusable_ranges();\n\n    Segment::from_unused(meta_page_range, |_| MetaPageMeta {}).unwrap()\n}",
  "mir": "fn mm::frame::meta::init() -> mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta> {\n    let mut _0: mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta>;\n    let  _1: usize;\n    let  _2: &boot::memory_region::MemoryRegionArray<512>;\n    let  _3: &boot::EarlyBootInfo;\n    let mut _4: core::option::Option<&boot::EarlyBootInfo>;\n    let mut _5: &spin::once::Once<boot::EarlyBootInfo>;\n    let mut _6: core::option::Option<usize>;\n    let mut _7: core::iter::Map<core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/mm/frame/meta.rs:461:21: 461:24}>, {closure@ostd/src/mm/frame/meta.rs:462:18: 462:21}>;\n    let mut _8: core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/mm/frame/meta.rs:461:21: 461:24}>;\n    let mut _9: core::slice::Iter<'_, boot::memory_region::MemoryRegion>;\n    let  _10: &[boot::memory_region::MemoryRegion];\n    let  _11: log::Level;\n    let mut _12: bool;\n    let mut _13: &log::Level;\n    let mut _14: &log::LevelFilter;\n    let mut _15: bool;\n    let mut _16: &log::Level;\n    let mut _17: &log::LevelFilter;\n    let  _18: log::LevelFilter;\n    let  _19: ();\n    let mut _20: core::fmt::Arguments<'_>;\n    let  _21: (&usize,);\n    let mut _22: &usize;\n    let  _23: [core::fmt::rt::Argument<'_>; 1];\n    let mut _24: core::fmt::rt::Argument<'_>;\n    let mut _25: &[u8; 57];\n    let  _26: &[core::fmt::rt::Argument<'_>; 1];\n    let  _27: &(&str, &str, &core::panic::Location<'_>);\n    let  _28: (&str, &str, &core::panic::Location<'_>);\n    let mut _29: &str;\n    let  _30: &core::panic::Location<'_>;\n    let  _31: ();\n    let  _32: usize;\n    let mut _33: usize;\n    let mut _34: bool;\n    let  _35: usize;\n    let  _36: usize;\n    let mut _37: (usize, usize);\n    let  _38: ();\n    let mut _39: core::result::Result<(), ()>;\n    let mut _40: {closure@ostd/src/mm/frame/meta.rs:483:26: 483:35};\n    let mut _41: &usize;\n    let mut _42: &usize;\n    let  _43: ();\n    let mut _44: &core::sync::atomic::AtomicUsize;\n    let mut _45: core::sync::atomic::Ordering;\n    let  _46: core::ops::Range<usize>;\n    let mut _47: usize;\n    let mut _48: usize;\n    let mut _49: (usize, bool);\n    let mut _50: (usize, bool);\n    let  _51: core::ops::Range<usize>;\n    let  _52: core::ops::Range<usize>;\n    let mut _53: (core::ops::Range<usize>, core::ops::Range<usize>);\n    let  _54: &mm::frame::allocator::EarlyFrameAllocator;\n    let mut _55: core::option::Option<&mm::frame::allocator::EarlyFrameAllocator>;\n    let  _56: &core::option::Option<mm::frame::allocator::EarlyFrameAllocator>;\n    let mut _57: &spin::MutexGuard<'_, core::option::Option<mm::frame::allocator::EarlyFrameAllocator>>;\n    let  _58: spin::MutexGuard<'_, core::option::Option<mm::frame::allocator::EarlyFrameAllocator>>;\n    let mut _59: &spin::mutex::Mutex<core::option::Option<mm::frame::allocator::EarlyFrameAllocator>>;\n    let mut _60: core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let mut _61: core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let  _62: &core::ops::Range<usize>;\n    let  _63: &core::ops::Range<usize>;\n    let mut _64: core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let mut _65: core::option::Option<core::ops::Range<usize>>;\n    let mut _66: &mut core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let mut _67: isize;\n    let  _68: core::ops::Range<usize>;\n    let  _69: mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>;\n    let mut _70: core::result::Result<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>, mm::frame::meta::GetFrameError>;\n    let mut _71: core::mem::ManuallyDrop<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>>;\n    let mut _72: core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let mut _73: core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let  _74: &core::ops::Range<usize>;\n    let  _75: &core::ops::Range<usize>;\n    let mut _76: core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let mut _77: core::option::Option<core::ops::Range<usize>>;\n    let mut _78: &mut core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}>;\n    let mut _79: isize;\n    let  _80: core::ops::Range<usize>;\n    let  _81: mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>;\n    let mut _82: core::result::Result<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>, mm::frame::meta::GetFrameError>;\n    let mut _83: core::mem::ManuallyDrop<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>>;\n    let  _84: ();\n    let mut _85: core::result::Result<mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta>, mm::frame::meta::GetFrameError>;\n    let mut _86: &usize;\n    debug max_paddr => _1;\n    debug regions => _2;\n    debug lvl => _11;\n    debug args => _21;\n    debug args => _23;\n    debug tot_nr_frames => _32;\n    debug nr_meta_pages => _35;\n    debug meta_pages => _36;\n    debug meta_page_range => _46;\n    debug range_1 => _51;\n    debug range_2 => _52;\n    debug iter => _64;\n    debug r => _68;\n    debug early_seg => _69;\n    debug iter => _76;\n    debug r => _80;\n    debug early_seg => _81;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        _4 = spin::once::Once::<boot::EarlyBootInfo>::get(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = core::option::Option::<&boot::EarlyBootInfo>::unwrap(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _2 = &((*_3).5: boot::memory_region::MemoryRegionArray<512>);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _10 = <boot::memory_region::MemoryRegionArray<512> as core::ops::Deref>::deref(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = core::slice::<impl [boot::memory_region::MemoryRegion]>::iter(_10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = <core::slice::Iter<'_, boot::memory_region::MemoryRegion> as core::iter::Iterator>::filter::<{closure@ostd/src/mm/frame/meta.rs:461:21: 461:24}>(move _9, ZeroSized: {closure@ostd/src/mm/frame/meta.rs:461:21: 461:24}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _7 = <core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/mm/frame/meta.rs:461:21: 461:24}> as core::iter::Iterator>::map::<usize, {closure@ostd/src/mm/frame/meta.rs:462:18: 462:21}>(move _8, ZeroSized: {closure@ostd/src/mm/frame/meta.rs:462:18: 462:21}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        _6 = <core::iter::Map<core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/mm/frame/meta.rs:461:21: 461:24}>, {closure@ostd/src/mm/frame/meta.rs:462:18: 462:21}> as core::iter::Iterator>::max(move _7) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_7);\n        _1 = core::option::Option::<usize>::unwrap(move _6) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_3);\n        _11 = log::Level::Info;\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_11;\n        StorageLive(_14);\n        _14 = mm::frame::meta::init::promoted[0];\n        _12 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _13, move _14) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _12) -> [0: bb19, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_11;\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = log::max_level() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _17 = &_18;\n        _15 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _16, move _17) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _15) -> [0: bb18, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_1;\n        _21 = (move _22);\n        StorageDead(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _86 = (_21.0: &usize);\n        _24 = core::fmt::rt::Argument::<'_>::new_lower_hex::<usize>(_86) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _23 = [move _24];\n        StorageDead(_24);\n        StorageLive(_25);\n        _25 = b\"6Initializing frame metadata for physical memory up to \\xc0\\x00\";\n        _26 = &_23;\n        _20 = core::fmt::Arguments::<'_>::new::<57, 1>(move _25, _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = \"ostd::mm::frame::meta\";\n        _30 = log::__private_api::loc() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _28 = (move _29, \"ostd::mm::frame::meta\", _30);\n        StorageDead(_29);\n        _27 = &_28;\n        _19 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _20, _11, _27, ()) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_20);\n        StorageDead(_28);\n        StorageDead(_23);\n        StorageDead(_21);\n        goto -> bb20;\n    }\n    bb18: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_15);\n        StorageDead(_12);\n        _31 = mm::frame::meta::add_temp_linear_mapping(_1) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_33);\n        _33 = mm::page_size::<arch::mm::PagingConsts>(1_u8) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _34 = Eq(_33, 0_usize);\n        assert(!move _34, \"attempt to divide `{}` by zero\", _1) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _32 = Div(_1, move _33);\n        StorageDead(_33);\n        StorageLive(_37);\n        _37 = mm::frame::meta::alloc_meta_frames(_32) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _35 = (_37.0: usize);\n        _36 = (_37.1: usize);\n        StorageDead(_37);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &_35;\n        StorageLive(_42);\n        _42 = &_36;\n        _40 = {closure@ostd/src/mm/frame/meta.rs:483:26: 483:35}(move _41, move _42);\n        StorageDead(_42);\n        StorageDead(_41);\n        _39 = mm::page_table::boot_pt::with_borrow::<{closure@ostd/src/mm/frame/meta.rs:483:26: 483:35}, ()>(move _40) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_40);\n        _38 = core::result::Result::<(), ()>::unwrap(move _39) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_39);\n        StorageLive(_44);\n        _44 = {alloc1230: &core::sync::atomic::AtomicUsize};\n        StorageLive(_45);\n        _45 = core::sync::atomic::Ordering::Relaxed;\n        _43 = core::sync::atomic::AtomicUsize::store(move _44, _1, move _45) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_45);\n        StorageDead(_44);\n        StorageLive(_47);\n        StorageLive(_48);\n        _49 = CheckedMul(_35, mm::PAGE_SIZE);\n        assert(!move (_49.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _35, mm::PAGE_SIZE) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _48 = move (_49.0: usize);\n        _50 = CheckedAdd(_36, _48);\n        assert(!move (_50.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _36, move _48) -> [success: bb29, unwind unreachable];\n    }\n    bb29: {\n        _47 = move (_50.0: usize);\n        StorageDead(_48);\n        _46 = Range(_36, move _47);\n        StorageDead(_47);\n        StorageLive(_53);\n        StorageLive(_55);\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = {alloc1161: &spin::mutex::Mutex<core::option::Option<mm::frame::allocator::EarlyFrameAllocator>>};\n        _58 = spin::mutex::Mutex::<core::option::Option<mm::frame::allocator::EarlyFrameAllocator>>::lock(move _59) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        _57 = &_58;\n        _56 = <spin::MutexGuard<'_, core::option::Option<mm::frame::allocator::EarlyFrameAllocator>> as core::ops::Deref>::deref(move _57) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_59);\n        StorageDead(_57);\n        _55 = core::option::Option::<mm::frame::allocator::EarlyFrameAllocator>::as_ref(_56) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _54 = core::option::Option::<&mm::frame::allocator::EarlyFrameAllocator>::unwrap(move _55) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_55);\n        _53 = mm::frame::allocator::EarlyFrameAllocator::allocated_regions(_54) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageLive(_51);\n        _51 = move (_53.0: core::ops::Range<usize>);\n        StorageLive(_52);\n        _52 = move (_53.1: core::ops::Range<usize>);\n        drop(_58) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_58);\n        StorageDead(_53);\n        StorageLive(_60);\n        StorageLive(_61);\n        _62 = &_51;\n        _63 = &_46;\n        _61 = util::ops::range_difference::<usize>(_62, _63) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _60 = <core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}> as core::iter::IntoIterator>::into_iter(move _61) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_61);\n        StorageLive(_64);\n        _64 = move _60;\n        goto -> bb38;\n    }\n    bb38: {\n        StorageLive(_65);\n        _66 = &mut _64;\n        _65 = <core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}> as core::iter::Iterator>::next(_66) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _67 = discriminant(_65);\n        switchInt(move _67) -> [0: bb42, 1: bb41, otherwise: bb40];\n    }\n    bb40: {\n        unreachable;\n    }\n    bb41: {\n        _68 = move ((_65 as variant#1).0: core::ops::Range<usize>);\n        StorageLive(_70);\n        _70 = mm::frame::segment::Segment::<mm::frame::allocator::EarlyAllocatedFrameMeta>::from_unused::<{closure@ostd/src/mm/frame/meta.rs:509:49: 509:52}>(_68, ZeroSized: {closure@ostd/src/mm/frame/meta.rs:509:49: 509:52}) -> [return: bb43, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_65);\n        drop(_64) -> [return: bb46, unwind unreachable];\n    }\n    bb43: {\n        _69 = core::result::Result::<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>, mm::frame::meta::GetFrameError>::unwrap(move _70) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_70);\n        StorageLive(_71);\n        _71 = core::mem::ManuallyDrop::<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>>::new(_69) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_71);\n        StorageDead(_65);\n        goto -> bb38;\n    }\n    bb46: {\n        StorageDead(_64);\n        StorageDead(_60);\n        StorageLive(_72);\n        StorageLive(_73);\n        _74 = &_52;\n        _75 = &_46;\n        _73 = util::ops::range_difference::<usize>(_74, _75) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _72 = <core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}> as core::iter::IntoIterator>::into_iter(move _73) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_73);\n        StorageLive(_76);\n        _76 = move _72;\n        goto -> bb49;\n    }\n    bb49: {\n        StorageLive(_77);\n        _78 = &mut _76;\n        _77 = <core::iter::Filter<core::array::IntoIter<core::ops::Range<usize>, 2>, {closure@ostd/src/util/ops.rs:24:26: 24:29}> as core::iter::Iterator>::next(_78) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _79 = discriminant(_77);\n        switchInt(move _79) -> [0: bb52, 1: bb51, otherwise: bb40];\n    }\n    bb51: {\n        _80 = move ((_77 as variant#1).0: core::ops::Range<usize>);\n        StorageLive(_82);\n        _82 = mm::frame::segment::Segment::<mm::frame::allocator::EarlyAllocatedFrameMeta>::from_unused::<{closure@ostd/src/mm/frame/meta.rs:513:49: 513:52}>(_80, ZeroSized: {closure@ostd/src/mm/frame/meta.rs:513:49: 513:52}) -> [return: bb53, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_77);\n        drop(_76) -> [return: bb56, unwind unreachable];\n    }\n    bb53: {\n        _81 = core::result::Result::<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>, mm::frame::meta::GetFrameError>::unwrap(move _82) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_82);\n        StorageLive(_83);\n        _83 = core::mem::ManuallyDrop::<mm::frame::segment::Segment<mm::frame::allocator::EarlyAllocatedFrameMeta>>::new(_81) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_83);\n        StorageDead(_77);\n        goto -> bb49;\n    }\n    bb56: {\n        StorageDead(_76);\n        StorageDead(_72);\n        _84 = mm::frame::meta::mark_unusable_ranges() -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageLive(_85);\n        _85 = mm::frame::segment::Segment::<mm::frame::meta::MetaPageMeta>::from_unused::<{closure@ostd/src/mm/frame/meta.rs:519:43: 519:46}>(_46, ZeroSized: {closure@ostd/src/mm/frame/meta.rs:519:43: 519:46}) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        _0 = core::result::Result::<mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta>, mm::frame::meta::GetFrameError>::unwrap(move _85) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_85);\n        StorageDead(_52);\n        StorageDead(_51);\n        return;\n    }\n}\n",
  "doc": " Initializes the metadata of all physical frames.\n\n The function returns a list of `Frame`s containing the metadata.\n\n # Safety\n\n This function should be called only once and only on the BSP,\n before any APs are started.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}