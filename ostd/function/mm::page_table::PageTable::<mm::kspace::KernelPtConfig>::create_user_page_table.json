{
  "name": "mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::create_user_page_table",
  "safe": true,
  "callees": {
    "mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a new empty page table node.\n",
      "adt": {
        "mm::frame::Frame": "Constructor"
      }
    },
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "mm::frame::Frame::<M>::borrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows a reference from the given frame.\n",
      "adt": {
        "mm::frame::Frame": "ImmutableAsArgument",
        "mm::frame::frame_ref::FrameRef": "Constructor"
      }
    },
    "mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'a, mm::page_table::node::PageTablePageMeta<C>>>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks the page table node.\n\n An atomic mode guard is required to\n  1. prevent deadlocks;\n  2. provide a lifetime (`'rcu`) that the nodes are guaranteed to outlive.\n",
      "adt": {
        "mm::frame::frame_ref::FrameRef": "ImmutableAsArgument",
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::page_table::node::PageTableGuard::<'rcu, C>::entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows an entry in the node at a given index.\n\n # Panics\n\n Panics if the index is not within the bound of\n [`nr_subpage_per_huge<C>`].\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "MutableAsArgument",
        "mm::page_table::node::entry::Entry": "Constructor"
      }
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::to_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a reference to the child.\n",
      "adt": {
        "mm::page_table::node::entry::Entry": "ImmutableAsArgument",
        "mm::page_table::node::child::ChildRef": "Constructor"
      }
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "mm::mem_obj::HasPaddr::paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the start physical address of the memory object.\n",
      "adt": {}
    },
    "mm::page_table::PageTableEntryTrait::new_pt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new PTE that maps to a child page table.\n",
      "adt": {}
    },
    "mm::page_table::node::PageTableGuard::<'rcu, C>::write_pte": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a page table entry at a given index.\n\n This operation will leak the old child if the old PTE is present.\n\n # Safety\n\n The caller must ensure that:\n  1. The index must be within the bound;\n  2. The PTE must represent a [`Child`] in the same [`PageTableConfig`]\n     and at the right paging level (`self.level() - 1`).\n  3. The page table node will have the ownership of the [`Child`]\n     after this method.\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::frame::Frame": [
      "Plain",
      "Ref"
    ],
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ],
    "mm::page_table::PageTable": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain",
      "Ref"
    ],
    "mm::frame::frame_ref::FrameRef": [
      "Plain",
      "Ref"
    ],
    "mm::page_table::node::PageTableGuard": [
      "Plain",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "mm::page_table::node::entry::Entry": [
      "Plain",
      "Ref"
    ],
    "mm::page_table::node::child::ChildRef": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 5971, kind: RigidTy(Adt(AdtDef(DefId { id: 5173, name: \"mm::frame::frame_ref::FrameRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 5977, kind: RigidTy(Adt(AdtDef(DefId { id: 5364, name: \"mm::page_table::node::PageTablePageMeta\" }), GenericArgs([Type(Ty { id: 5353, kind: RigidTy(Adt(AdtDef(DefId { id: 5341, name: \"mm::kspace::KernelPtConfig\" }), GenericArgs([]))) })]))) })]))) })])"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "arch::mm::PageTableEntry": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::create_user_page_table"
  },
  "span": "ostd/src/mm/page_table/mod.rs:318:5: 356:6",
  "src": "pub(in crate::mm) fn create_user_page_table(&'static self) -> PageTable<UserPtConfig> {\n        let new_root = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n\n        let preempt_guard = disable_preempt();\n        let mut root_node = self.root.borrow().lock(&preempt_guard);\n        let mut new_node = new_root.borrow().lock(&preempt_guard);\n\n        const {\n            assert!(!KernelPtConfig::TOP_LEVEL_CAN_UNMAP);\n            assert!(\n                UserPtConfig::TOP_LEVEL_INDEX_RANGE.end\n                    <= KernelPtConfig::TOP_LEVEL_INDEX_RANGE.start\n            );\n        }\n\n        for i in KernelPtConfig::TOP_LEVEL_INDEX_RANGE {\n            let root_entry = root_node.entry(i);\n            let child = root_entry.to_ref();\n            let ChildRef::PageTable(pt) = child else {\n                panic!(\"The kernel page table doesn't contain shared nodes\");\n            };\n\n            // We do not add additional reference count specifically for the\n            // shared kernel page tables. It requires user page tables to\n            // outlive the kernel page table, which is trivially true.\n            // See also `<PageTablePageMeta as AnyFrameMeta>::on_drop`.\n            let pt_addr = pt.paddr();\n            let pte = PageTableEntry::new_pt(pt_addr);\n            // SAFETY: The index is within the bounds and the PTE is at the\n            // correct paging level. However, neither it's a `UserPtConfig`\n            // child nor the node has the ownership of the child. It is\n            // still safe because `UserPtConfig::TOP_LEVEL_INDEX_RANGE`\n            // guarantees that the cursor won't access it.\n            unsafe { new_node.write_pte(i, pte) };\n        }\n        drop(new_node);\n\n        PageTable::<UserPtConfig> { root: new_root }\n    }",
  "mir": "fn mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::create_user_page_table(_1: &mm::page_table::PageTable<mm::kspace::KernelPtConfig>) -> mm::page_table::PageTable<mm::vm_space::UserPtConfig> {\n    let mut _0: mm::page_table::PageTable<mm::vm_space::UserPtConfig>;\n    let  _2: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::vm_space::UserPtConfig>>;\n    let  _3: task::preempt::guard::DisabledPreemptGuard;\n    let mut _4: mm::page_table::node::PageTableGuard<'_, mm::kspace::KernelPtConfig>;\n    let mut _5: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>;\n    let mut _6: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>;\n    let mut _7: &dyn task::atomic_mode::InAtomicMode;\n    let  _8: &task::preempt::guard::DisabledPreemptGuard;\n    let mut _9: mm::page_table::node::PageTableGuard<'_, mm::vm_space::UserPtConfig>;\n    let mut _10: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::vm_space::UserPtConfig>>;\n    let mut _11: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::vm_space::UserPtConfig>>;\n    let mut _12: &dyn task::atomic_mode::InAtomicMode;\n    let  _13: &task::preempt::guard::DisabledPreemptGuard;\n    let mut _14: core::ops::Range<usize>;\n    let mut _15: core::ops::Range<usize>;\n    let mut _16: core::option::Option<usize>;\n    let mut _17: &mut core::ops::Range<usize>;\n    let mut _18: isize;\n    let  _19: usize;\n    let  _20: mm::page_table::node::entry::Entry<'_, '_, mm::kspace::KernelPtConfig>;\n    let mut _21: &mut mm::page_table::node::PageTableGuard<'_, mm::kspace::KernelPtConfig>;\n    let  _22: mm::page_table::node::child::ChildRef<'_, mm::kspace::KernelPtConfig>;\n    let mut _23: &mm::page_table::node::entry::Entry<'_, '_, mm::kspace::KernelPtConfig>;\n    let  _24: !;\n    let mut _25: core::fmt::Arguments<'_>;\n    let  _26: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>;\n    let mut _27: isize;\n    let  _28: usize;\n    let  _29: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>;\n    let mut _30: &mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>;\n    let  _31: arch::mm::PageTableEntry;\n    let  _32: ();\n    let mut _33: &mut mm::page_table::node::PageTableGuard<'_, mm::vm_space::UserPtConfig>;\n    let  _34: ();\n    let mut _35: mm::page_table::node::PageTableGuard<'_, mm::vm_space::UserPtConfig>;\n    debug self => _1;\n    debug new_root => _2;\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug root_node => _4;\n    debug new_node => _9;\n    debug iter => _15;\n    debug i => _19;\n    debug root_entry => _20;\n    debug child => _22;\n    debug pt => _26;\n    debug pt_addr => _28;\n    debug pte => _31;\n    bb0: {\n        _2 = mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::vm_space::UserPtConfig>>>::alloc(<arch::mm::PagingConsts as mm::PagingConstsTrait>::NR_LEVELS) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = task::preempt::guard::disable_preempt() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &((*_1).0: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>);\n        _5 = mm::frame::Frame::<mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>::borrow(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _8 = &_3;\n        _7 = _8 as &dyn task::atomic_mode::InAtomicMode;\n        _4 = mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>>::lock::<'_>(move _5, move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_2;\n        _10 = mm::frame::Frame::<mm::page_table::node::PageTablePageMeta<mm::vm_space::UserPtConfig>>::borrow(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageLive(_12);\n        _13 = &_3;\n        _12 = _13 as &dyn task::atomic_mode::InAtomicMode;\n        _9 = mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::vm_space::UserPtConfig>>>::lock::<'_>(move _10, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_10);\n        StorageLive(_14);\n        _14 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(<mm::kspace::KernelPtConfig as mm::page_table::PageTableConfig>::TOP_LEVEL_INDEX_RANGE) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_15);\n        _15 = move _14;\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_16);\n        _17 = &mut _15;\n        _16 = <core::ops::Range<usize> as core::iter::Iterator>::next(_17) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb12, 1: bb11, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _19 = ((_16 as variant#1).0: usize);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &mut _4;\n        _20 = mm::page_table::node::PageTableGuard::<'_, mm::kspace::KernelPtConfig>::entry(move _21, _19) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_35);\n        _35 = move _9;\n        _34 = core::mem::drop::<mm::page_table::node::PageTableGuard<'_, mm::vm_space::UserPtConfig>>(move _35) -> [return: bb22, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_20;\n        _22 = mm::page_table::node::entry::Entry::<'_, '_, mm::kspace::KernelPtConfig>::to_ref(move _23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        _27 = discriminant(_22);\n        switchInt(move _27) -> [0: bb17, otherwise: bb15];\n    }\n    bb15: {\n        StorageLive(_25);\n        _25 = core::fmt::Arguments::<'_>::from_str(\"The kernel page table doesn't contain shared nodes\") -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _24 = core::panicking::panic_fmt(move _25) -> unwind unreachable;\n    }\n    bb17: {\n        StorageLive(_26);\n        _26 = move ((_22 as variant#0).0: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>>);\n        StorageLive(_30);\n        _30 = &_26;\n        _29 = <mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>> as core::ops::Deref>::deref(move _30) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        _28 = <mm::frame::Frame<mm::page_table::node::PageTablePageMeta<mm::kspace::KernelPtConfig>> as mm::mem_obj::HasPaddr>::paddr(_29) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _31 = <arch::mm::PageTableEntry as mm::page_table::PageTableEntryTrait>::new_pt(_28) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_33);\n        _33 = &mut _9;\n        _32 = mm::page_table::node::PageTableGuard::<'_, mm::vm_space::UserPtConfig>::write_pte(move _33, _19, _31) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        StorageDead(_26);\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageDead(_16);\n        goto -> bb8;\n    }\n    bb22: {\n        StorageDead(_35);\n        _0 = PageTable(_2);\n        StorageDead(_9);\n        drop(_4) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_4);\n        drop(_3) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        return;\n    }\n}\n",
  "doc": " Create a new user page table.\n\n This should be the only way to create the user page table, that is to\n duplicate the kernel page table with all the kernel mappings shared.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}