{
  "name": "arch::boot::multiboot::parse_as_cstr",
  "safe": false,
  "callees": {
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    },
    "core::ffi::CStr::to_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.\n\n If the contents of the `CStr` are valid UTF-8 data, this\n function will return the corresponding <code>&[str]</code> slice. Otherwise,\n it will return an error with details of where UTF-8 validation failed.\n\n [str]: prim@str \"str\"\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_str(), Ok(\"foo\"));\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 132,
  "span": "ostd/src/arch/x86/boot/multiboot/mod.rs:29:1: 39:2",
  "src": "unsafe fn parse_as_cstr<'a>(ptr: u32) -> Option<&'a str> {\n    if ptr == 0 {\n        return None;\n    }\n\n    let name_ptr = paddr_to_vaddr(ptr as usize) as *const core::ffi::c_char;\n    // SAFETY: The safety is upheld by the caller.\n    let name_cstr = unsafe { core::ffi::CStr::from_ptr(name_ptr) };\n\n    name_cstr.to_str().ok()\n}",
  "mir": "fn arch::boot::multiboot::parse_as_cstr(_1: u32) -> core::option::Option<&str> {\n    let mut _0: core::option::Option<&str>;\n    let  _2: *const i8;\n    let mut _3: usize;\n    let mut _4: usize;\n    let  _5: &core::ffi::CStr;\n    let mut _6: core::result::Result<&str, core::str::Utf8Error>;\n    debug ptr => _1;\n    debug name_ptr => _2;\n    debug name_cstr => _5;\n    bb0: {\n        switchInt(_1) -> [0: bb1, otherwise: bb2];\n    }\n    bb1: {\n        _0 = core::option::Option::None;\n        goto -> bb7;\n    }\n    bb2: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = _1 as usize;\n        _3 = mm::kspace::paddr_to_vaddr(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _2 = move _3 as *const i8;\n        StorageDead(_3);\n        _5 = core::ffi::CStr::from_ptr::<'_>(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_6);\n        _6 = core::ffi::CStr::to_str(_5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = core::result::Result::<&str, core::str::Utf8Error>::ok(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}