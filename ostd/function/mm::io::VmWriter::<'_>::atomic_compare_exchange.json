{
  "name": "mm::io::VmWriter::<'_>::atomic_compare_exchange",
  "safe": true,
  "callees": {
    "mm::io::VmWriter::<'_, Fallibility>::avail": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes for the available space.\n",
      "adt": {
        "mm::io::VmWriter": "ImmutableAsArgument"
      }
    },
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "mm::io::VmReader::<'_, Fallibility>::remain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes for the remaining data.\n",
      "adt": {
        "mm::io::VmReader": "ImmutableAsArgument"
      }
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast_const": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes constness without changing the type.\n\n This is a bit safer than `as` because it wouldn't silently change the type if the code is\n refactored.\n\n While not strictly required (`*mut T` coerces to `*const T`), this is provided for symmetry\n with [`cast_mut`] on `*const T` and may have documentation value if used instead of implicit\n coercion.\n\n [`cast_mut`]: pointer::cast_mut\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_aligned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether the pointer is properly aligned for `T`.\n\n # Examples\n\n ```\n // On some platforms, the alignment of i32 is less than 4.\n #[repr(align(4))]\n struct AlignedI32(i32);\n\n let mut data = AlignedI32(42);\n let ptr = &mut data as *mut AlignedI32;\n\n assert!(ptr.is_aligned());\n assert!(!ptr.wrapping_byte_add(1).is_aligned());\n ```\n",
      "adt": {}
    },
    "mm::io::PodAtomic::atomic_cmpxchg_fallible": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Atomically compares and exchanges a value.\n This function will return errors if encountering an unresolvable page fault.\n\n Returns the previous value.\n `new_val` will be written if and only if the previous value is equal to `old_val`.\n\n # Safety\n\n - `ptr` must either be [valid] for writes of `size_of::<T>()` bytes or be in user\n   space for `size_of::<T>()` bytes.\n - `ptr` must be aligned on an `align_of::<T>()`-byte boundary.\n\n [valid]: crate::mm::io#safety\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::io::VmWriter": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "mm::io::VmReader": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "error::Error": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 38, kind: Param(ParamTy { index: 1, name: \"T\" }) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::io::VmWriter::<'_>::atomic_compare_exchange"
  },
  "span": "ostd/src/mm/io.rs:892:5: 917:6",
  "src": "pub fn atomic_compare_exchange<T>(\n        &self,\n        reader: &VmReader,\n        old_val: T,\n        new_val: T,\n    ) -> Result<(T, bool)>\n    where\n        T: PodAtomic + Eq,\n    {\n        if self.avail() < size_of::<T>() || reader.remain() < size_of::<T>() {\n            return Err(Error::InvalidArgs);\n        }\n\n        assert_eq!(self.cursor.cast_const(), reader.cursor);\n\n        let cursor = self.cursor.cast::<T>();\n        assert!(cursor.is_aligned());\n\n        // SAFETY:\n        // 1. The cursor is either valid for reading and writing or in user space for\n        //    `size_of::<T>()` bytes.\n        // 2. The cursor is aligned on an `align_of::<T>()`-byte boundary.\n        let cur_val = unsafe { T::atomic_cmpxchg_fallible(cursor, old_val, new_val)? };\n\n        Ok((cur_val, old_val == cur_val))\n    }",
  "mir": "fn mm::io::VmWriter::<'_>::atomic_compare_exchange(_1: &mm::io::VmWriter<'_>, _2: &mm::io::VmReader<'_>, _3: T, _4: T) -> core::result::Result<(T, bool), error::Error> {\n    let mut _0: core::result::Result<(T, bool), error::Error>;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: error::Error;\n    let mut _12: (&*const u8, &*const u8);\n    let mut _13: &*const u8;\n    let  _14: *const u8;\n    let mut _15: *mut u8;\n    let mut _16: &*const u8;\n    let  _17: &*const u8;\n    let  _18: &*const u8;\n    let mut _19: bool;\n    let mut _20: *const u8;\n    let mut _21: *const u8;\n    let  _22: core::panicking::AssertKind;\n    let  _23: !;\n    let mut _24: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _25: *mut T;\n    let mut _26: *mut u8;\n    let mut _27: bool;\n    let mut _28: !;\n    let  _29: T;\n    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, T>;\n    let mut _31: core::result::Result<T, error::Error>;\n    let mut _32: T;\n    let mut _33: isize;\n    let  _34: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _35: T;\n    let mut _36: (T, bool);\n    let mut _37: T;\n    let mut _38: bool;\n    let mut _39: &T;\n    let mut _40: &T;\n    debug self => _1;\n    debug reader => _2;\n    debug old_val => _3;\n    debug new_val => _4;\n    debug left_val => _17;\n    debug right_val => _18;\n    debug kind => _22;\n    debug cursor => _25;\n    debug cur_val => _29;\n    debug residual => _34;\n    debug val => _35;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = mm::io::VmWriter::<'_>::avail(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_7);\n        _7 = core::mem::size_of::<T>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = Lt(move _6, move _7);\n        switchInt(move _5) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb8;\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = mm::io::VmReader::<'_>::remain(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_10);\n        _10 = core::mem::size_of::<T>() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _8 = Lt(move _9, move _10);\n        switchInt(move _8) -> [0: bb9, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_11);\n        _11 = error::Error::InvalidArgs;\n        _0 = core::result::Result::Err(move _11);\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageDead(_5);\n        goto -> bb24;\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = ((*_1).0: *mut u8);\n        _14 = core::ptr::mut_ptr::<impl *mut u8>::cast_const(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        _13 = &_14;\n        StorageLive(_16);\n        _16 = &((*_2).0: *const u8);\n        _12 = (move _13, move _16);\n        StorageDead(_16);\n        StorageDead(_13);\n        _17 = (_12.0: &*const u8);\n        _18 = (_12.1: &*const u8);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = (*_17);\n        StorageLive(_21);\n        _21 = (*_18);\n        _19 = Eq(move _20, move _21);\n        switchInt(move _19) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageLive(_26);\n        _26 = ((*_1).0: *mut u8);\n        _25 = core::ptr::mut_ptr::<impl *mut u8>::cast::<T>(move _26) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_21);\n        StorageDead(_20);\n        _22 = core::panicking::AssertKind::Eq;\n        StorageLive(_24);\n        _24 = core::option::Option::None;\n        _23 = core::panicking::assert_failed::<*const u8, *const u8>(_22, _17, _18, move _24) -> unwind unreachable;\n    }\n    bb13: {\n        StorageDead(_26);\n        StorageLive(_27);\n        _27 = core::ptr::mut_ptr::<impl *mut T>::is_aligned(_25) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _27) -> [0: bb16, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_27);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _3;\n        _31 = <T as mm::io::PodAtomic>::atomic_cmpxchg_fallible(_25, move _32, _4) -> [return: bb17, unwind unreachable];\n    }\n    bb16: {\n        _28 = core::panicking::panic(\"assertion failed: cursor.is_aligned()\") -> unwind unreachable;\n    }\n    bb17: {\n        StorageDead(_32);\n        _30 = <core::result::Result<T, error::Error> as core::ops::Try>::branch(move _31) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        _33 = discriminant(_30);\n        switchInt(move _33) -> [0: bb20, 1: bb21, otherwise: bb19];\n    }\n    bb19: {\n        unreachable;\n    }\n    bb20: {\n        StorageLive(_35);\n        _35 = ((_30 as variant#0).0: T);\n        _29 = _35;\n        StorageDead(_35);\n        StorageDead(_30);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = _29;\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &_3;\n        StorageLive(_40);\n        _40 = &_29;\n        _38 = <T as core::cmp::PartialEq>::eq(move _39, move _40) -> [return: bb23, unwind unreachable];\n    }\n    bb21: {\n        _34 = ((_30 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<(T, bool), error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_34) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb24;\n    }\n    bb23: {\n        StorageDead(_40);\n        StorageDead(_39);\n        _36 = (move _37, move _38);\n        StorageDead(_38);\n        StorageDead(_37);\n        _0 = core::result::Result::Ok(move _36);\n        StorageDead(_36);\n        StorageDead(_29);\n        goto -> bb24;\n    }\n    bb24: {\n        return;\n    }\n}\n",
  "doc": " Atomically compares and exchanges a `PodAtomic` value.\n\n This method compares `old_val` with the value pointed by `self` and, if they are equal,\n updates it with `new_val`.\n\n The value that was previously in memory will be returned, along with a boolean denoting\n whether the compare-and-exchange succeeds. The caller usually wants to retry if this\n flag is false, passing the most recent value that was returned by this method.\n\n The caller is required to provide a reader which points to the exact same memory location\n to ensure that reading from the memory is allowed.\n\n Regardless of whether it is successful, the cursors of the reader and writer will not move.\n\n This method only guarantees the atomicity of the specific operation. There are no\n synchronization constraints on other memory accesses. This aligns with the [Relaxed\n ordering](https://en.cppreference.com/w/cpp/atomic/memory_order.html#Relaxed_ordering)\n specified in the C++11 memory model.\n\n Since the operation does not involve memory locks, it can't prevent the [ABA\n problem](https://en.wikipedia.org/wiki/ABA_problem).\n\n This method will fail with errors if:\n  1. the remaining space of the reader or the available space of the writer are less than\n     `size_of::<T>()` bytes, or\n  2. the memory operation fails due to an unresolvable page fault.\n\n # Panics\n\n This method will panic if:\n  1. the reader and the writer does not point to the same memory location, or\n  2. the memory location is not aligned on an `align_of::<T>()`-byte boundary.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}