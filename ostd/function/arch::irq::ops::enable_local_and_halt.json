{
  "name": "arch::irq::ops::enable_local_and_halt",
  "safe": true,
  "callees": {},
  "adts": {},
  "path": 1157,
  "span": "ostd/src/arch/x86/irq/ops.rs:25:1: 38:2",
  "src": "pub(crate) fn enable_local_and_halt() {\n    // SAFETY:\n    // 1. `sti` is safe to use because its safety requirement is upheld by the caller.\n    // 2. `hlt` is safe to use because it halts the CPU for interrupts.\n    unsafe {\n        // Intel(R) 64 and IA-32 Architectures Software Developer's Manual says:\n        // \"If IF = 0, maskable hardware interrupts remain inhibited on the instruction boundary\n        // following an execution of STI.\"\n        //\n        // So interrupts will only occur at or after the HLT instruction, which guarantee that\n        // interrupts won't occur between enabling the local IRQs and halting the CPU.\n        core::arch::asm!(\"sti\", \"hlt\", options(nomem, nostack, preserves_flags),)\n    };\n}",
  "mir": "fn arch::irq::ops::enable_local_and_halt() -> () {\n    let mut _0: ();\n    bb0: {\n        InlineAsm -> [goto: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Enables local IRQs and halts the CPU to wait for interrupts.\n\n This method guarantees that no interrupts can occur in the middle. In other words, IRQs must\n either have been processed before this method is called, or they must wake the CPU up from the\n halting state.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}