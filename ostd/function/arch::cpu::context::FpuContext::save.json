{
  "name": "arch::cpu::context::FpuContext::save",
  "safe": true,
  "callees": {
    "arch::cpu::context::FpuContext::as_bytes_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the FPU context as a mutable byte slice.\n",
      "adt": {
        "arch::cpu::context::FpuContext": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::is_completed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the value has been initialized.\n\n This is done using [`Acquire`](core::sync::atomic::Ordering::Acquire) ordering, and\n therefore it is safe to access the value directly via\n [`get_unchecked`](Self::get_unchecked) if this returns true.\n",
      "adt": {}
    },
    "core::arch::x86_64::_xsave64": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a full or partial save of the enabled processor states to memory at\n `mem_addr`.\n\n State is saved based on bits `[62:0]` in `save_mask` and XCR0.\n `mem_addr` must be aligned on a 64-byte boundary.\n\n The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,” of\n Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_xsave64)\n",
      "adt": {}
    },
    "core::arch::x86_64::_fxsave64": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saves the `x87` FPU, `MMX` technology, `XMM`, and `MXCSR` registers to the\n 512-byte-long 16-byte-aligned memory region `mem_addr`.\n\n A misaligned destination operand raises a general-protection (#GP) or an\n alignment check exception (#AC).\n\n See [`FXSAVE`][fxsave] and [`FXRSTOR`][fxrstor].\n\n [fxsave]: http://www.felixcloutier.com/x86/FXSAVE.html\n [fxrstor]: http://www.felixcloutier.com/x86/FXRSTOR.html\n\n [Intel's documentation](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_fxsave64)\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "arch::cpu::context::FpuContext": [
      "MutRef"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::cpu::context::FpuContext::save"
  },
  "span": "ostd/src/arch/x86/cpu/context/mod.rs:520:5: 530:6",
  "src": "pub fn save(&mut self) {\n        let mem_addr = self.as_bytes_mut().as_mut_ptr();\n\n        if XSTATE_MAX_FEATURES.is_completed() {\n            unsafe { _xsave64(mem_addr, XFEATURE_MASK_USER_RESTORE) };\n        } else {\n            unsafe { _fxsave64(mem_addr) };\n        }\n\n        debug!(\"Save FPU context\");\n    }",
  "mir": "fn arch::cpu::context::FpuContext::save(_1: &mut arch::cpu::context::FpuContext) -> () {\n    let mut _0: ();\n    let  _2: *mut u8;\n    let mut _3: &mut [u8];\n    let mut _4: bool;\n    let mut _5: &spin::once::Once<u64>;\n    let  _6: ();\n    let  _7: ();\n    let  _8: log::Level;\n    let mut _9: bool;\n    let mut _10: &log::Level;\n    let mut _11: &log::LevelFilter;\n    let mut _12: bool;\n    let mut _13: &log::Level;\n    let mut _14: &log::LevelFilter;\n    let  _15: log::LevelFilter;\n    let  _16: ();\n    let mut _17: core::fmt::Arguments<'_>;\n    let  _18: &(&str, &str, &core::panic::Location<'_>);\n    let  _19: (&str, &str, &core::panic::Location<'_>);\n    let mut _20: &str;\n    let  _21: &core::panic::Location<'_>;\n    debug self => _1;\n    debug mem_addr => _2;\n    debug lvl => _8;\n    bb0: {\n        _3 = arch::cpu::context::FpuContext::as_bytes_mut(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::slice::<impl [u8]>::as_mut_ptr(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = {alloc24: &spin::once::Once<u64>};\n        _4 = spin::once::Once::<u64>::is_completed(move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _4) -> [0: bb6, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_5);\n        _6 = core::arch::x86_64::_xsave64(_2, arch::cpu::context::XFEATURE_MASK_USER_RESTORE) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        goto -> bb8;\n    }\n    bb6: {\n        StorageDead(_5);\n        _7 = core::arch::x86_64::_fxsave64(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_4);\n        _8 = log::Level::Debug;\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_8;\n        StorageLive(_11);\n        _11 = arch::cpu::context::FpuContext::save::promoted[0];\n        _9 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _10, move _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _9) -> [0: bb18, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_8;\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = log::max_level() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _14 = &_15;\n        _12 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _13, move _14) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _12) -> [0: bb17, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_17);\n        _17 = core::fmt::Arguments::<'_>::from_str(\"Save FPU context\") -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = \"ostd::arch::cpu::context\";\n        _21 = log::__private_api::loc() -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _19 = (move _20, \"ostd::arch::cpu::context\", _21);\n        StorageDead(_20);\n        _18 = &_19;\n        _16 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _17, _8, _18, ()) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_17);\n        StorageDead(_19);\n        goto -> bb19;\n    }\n    bb17: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_12);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": " Saves CPU's current FPU context to this instance.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}