{
  "name": "arch::iommu::dma_remapping::context_table::ContextTable::get_or_create_page_table",
  "safe": true,
  "callees": {
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "mm::io::VmIo::read_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads a value of a specified type at a specified offset.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "arch::iommu::dma_remapping::context_table::ContextEntry::is_present": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::dma_remapping::context_table::ContextEntry": "ImmutableAsArgument"
      }
    },
    "arch::iommu::dma_remapping::context_table::ContextEntry::second_stage_pointer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the second stage page translation pointer.\n\n This function will not right shift the value after the `and` operation.\n",
      "adt": {
        "arch::iommu::dma_remapping::context_table::ContextEntry": "ImmutableAsArgument"
      }
    },
    "mm::page_table::PageTable::<C>::empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new empty page table.\n\n Useful for the IOMMU page tables only.\n",
      "adt": {
        "mm::page_table::PageTable": "Constructor"
      }
    },
    "mm::page_table::PageTable::<C>::root_paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The physical address of the root page table.\n\n Obtaining the physical address of the root page table is safe, however, using it or\n providing it to the hardware will be unsafe since the page table node may be dropped,\n resulting in UAF.\n",
      "adt": {
        "mm::page_table::PageTable": "ImmutableAsArgument"
      }
    },
    "alloc::collections::BTreeMap::<K, V, A>::insert": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a key-value pair into the map.\n\n If the map did not have this key present, `None` is returned.\n\n If the map did have this key present, the value is updated, and the old\n value is returned. The key is not updated, though; this matters for\n types that can be `==` without being identical. See the [module-level\n documentation] for more.\n\n [module-level documentation]: index.html#insert-and-complex-keys\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n assert_eq!(map.insert(37, \"a\"), None);\n assert_eq!(map.is_empty(), false);\n\n map.insert(37, \"b\");\n assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n assert_eq!(map[&37], \"c\");\n ```\n",
      "adt": {}
    },
    "mm::io::VmIo::write_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a value of a specified type at a specified offset.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "alloc::collections::BTreeMap::<K, V, A>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the value corresponding to the key.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n if let Some(x) = map.get_mut(&1) {\n     *x = \"b\";\n }\n assert_eq!(map[&1], \"b\");\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::Frame": [
      "Ref"
    ],
    "arch::iommu::dma_remapping::context_table::ContextTable": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "arch::iommu::dma_remapping::PciDeviceLocation": [
      "Unknown([Field(1, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Field(2, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "arch::iommu::dma_remapping::context_table::ContextEntry": [
      "Plain",
      "Ref"
    ],
    "alloc::collections::BTreeMap": [
      "MutRef"
    ],
    "mm::page_table::PageTable": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 469,
  "span": "ostd/src/arch/x86/iommu/dma_remapping/context_table.rs:257:5: 286:6",
  "src": "fn get_or_create_page_table(\n        &mut self,\n        device: PciDeviceLocation,\n    ) -> &mut PageTable<IommuPtConfig> {\n        let bus_entry = self\n            .entries_frame\n            .read_val::<ContextEntry>(\n                (device.device as usize * 8 + device.function as usize) * size_of::<ContextEntry>(),\n            )\n            .unwrap();\n\n        if !bus_entry.is_present() {\n            let table = PageTable::<IommuPtConfig>::empty();\n            let address = table.root_paddr();\n            self.page_tables.insert(address, table);\n            let entry = ContextEntry(address as u128 | 3 | 0x1_0000_0000_0000_0000);\n            self.entries_frame\n                .write_val::<ContextEntry>(\n                    (device.device as usize * 8 + device.function as usize)\n                        * size_of::<ContextEntry>(),\n                    &entry,\n                )\n                .unwrap();\n            self.page_tables.get_mut(&address).unwrap()\n        } else {\n            self.page_tables\n                .get_mut(&(bus_entry.second_stage_pointer() as usize))\n                .unwrap()\n        }\n    }",
  "mir": "fn arch::iommu::dma_remapping::context_table::ContextTable::get_or_create_page_table(_1: &mut arch::iommu::dma_remapping::context_table::ContextTable, _2: arch::iommu::dma_remapping::PciDeviceLocation) -> &mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig> {\n    let mut _0: &mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let  _3: arch::iommu::dma_remapping::context_table::ContextEntry;\n    let mut _4: core::result::Result<arch::iommu::dma_remapping::context_table::ContextEntry, error::Error>;\n    let mut _5: &mm::frame::Frame<()>;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: usize;\n    let mut _10: u8;\n    let mut _11: (usize, bool);\n    let mut _12: usize;\n    let mut _13: u8;\n    let mut _14: (usize, bool);\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let mut _17: &mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _18: bool;\n    let mut _19: &arch::iommu::dma_remapping::context_table::ContextEntry;\n    let  _20: mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let  _21: usize;\n    let mut _22: &mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let  _23: core::option::Option<mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let mut _24: &mut alloc::collections::BTreeMap<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let  _25: arch::iommu::dma_remapping::context_table::ContextEntry;\n    let mut _26: u128;\n    let mut _27: u128;\n    let mut _28: u128;\n    let  _29: ();\n    let mut _30: core::result::Result<(), error::Error>;\n    let mut _31: &mm::frame::Frame<()>;\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: u8;\n    let mut _37: (usize, bool);\n    let mut _38: usize;\n    let mut _39: u8;\n    let mut _40: (usize, bool);\n    let mut _41: usize;\n    let mut _42: (usize, bool);\n    let  _43: &arch::iommu::dma_remapping::context_table::ContextEntry;\n    let mut _44: &mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _45: core::option::Option<&mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let mut _46: &mut alloc::collections::BTreeMap<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let  _47: &usize;\n    let mut _48: &mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _49: core::option::Option<&mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let mut _50: &mut alloc::collections::BTreeMap<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let  _51: &usize;\n    let  _52: usize;\n    let mut _53: u64;\n    let mut _54: &arch::iommu::dma_remapping::context_table::ContextEntry;\n    debug self => _1;\n    debug device => _2;\n    debug bus_entry => _3;\n    debug table => _20;\n    debug address => _21;\n    debug entry => _25;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: mm::frame::Frame<()>);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (_2.1: u8);\n        _9 = move _10 as usize;\n        StorageDead(_10);\n        _11 = CheckedMul(_9, 8_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _9, 8_usize) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _8 = move (_11.0: usize);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (_2.2: u8);\n        _12 = move _13 as usize;\n        StorageDead(_13);\n        _14 = CheckedAdd(_8, _12);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _8, move _12) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _7 = move (_14.0: usize);\n        StorageDead(_12);\n        StorageDead(_8);\n        StorageLive(_15);\n        _15 = core::mem::size_of::<arch::iommu::dma_remapping::context_table::ContextEntry>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _16 = CheckedMul(_7, _15);\n        assert(!move (_16.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _7, move _15) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = move (_16.0: usize);\n        StorageDead(_15);\n        StorageDead(_7);\n        _4 = <mm::frame::Frame<()> as mm::io::VmIo>::read_val::<arch::iommu::dma_remapping::context_table::ContextEntry>(move _5, move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_5);\n        _3 = core::result::Result::<arch::iommu::dma_remapping::context_table::ContextEntry, error::Error>::unwrap(move _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_3;\n        _18 = arch::iommu::dma_remapping::context_table::ContextEntry::is_present(move _19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _18) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_19);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = &mut ((*_1).1: alloc::collections::BTreeMap<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>);\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &_3;\n        _53 = arch::iommu::dma_remapping::context_table::ContextEntry::second_stage_pointer(move _54) -> [return: bb22, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        _20 = mm::page_table::PageTable::<arch::iommu::dma_remapping::second_stage::IommuPtConfig>::empty() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_22);\n        _22 = &_20;\n        _21 = mm::page_table::PageTable::<arch::iommu::dma_remapping::second_stage::IommuPtConfig>::root_paddr(move _22) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &mut ((*_1).1: alloc::collections::BTreeMap<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>);\n        _23 = alloc::collections::BTreeMap::<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>::insert(move _24, _21, _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        drop(_23) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = _21 as u128;\n        _27 = BitOr(move _28, 3_u128);\n        StorageDead(_28);\n        _26 = BitOr(move _27, 18446744073709551616_u128);\n        StorageDead(_27);\n        _25 = ContextEntry(move _26);\n        StorageDead(_26);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &((*_1).0: mm::frame::Frame<()>);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = (_2.1: u8);\n        _35 = move _36 as usize;\n        StorageDead(_36);\n        _37 = CheckedMul(_35, 8_usize);\n        assert(!move (_37.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _35, 8_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _34 = move (_37.0: usize);\n        StorageDead(_35);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = (_2.2: u8);\n        _38 = move _39 as usize;\n        StorageDead(_39);\n        _40 = CheckedAdd(_34, _38);\n        assert(!move (_40.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _34, move _38) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _33 = move (_40.0: usize);\n        StorageDead(_38);\n        StorageDead(_34);\n        StorageLive(_41);\n        _41 = core::mem::size_of::<arch::iommu::dma_remapping::context_table::ContextEntry>() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _42 = CheckedMul(_33, _41);\n        assert(!move (_42.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _33, move _41) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _32 = move (_42.0: usize);\n        StorageDead(_41);\n        StorageDead(_33);\n        _43 = &_25;\n        _30 = <mm::frame::Frame<()> as mm::io::VmIo>::write_val::<arch::iommu::dma_remapping::context_table::ContextEntry>(move _31, move _32, _43) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _29 = core::result::Result::<(), error::Error>::unwrap(move _30) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_30);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &mut ((*_1).1: alloc::collections::BTreeMap<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>);\n        _47 = &_21;\n        _45 = alloc::collections::BTreeMap::<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>::get_mut::<usize>(move _46, _47) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_46);\n        _44 = core::option::Option::<&mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>::unwrap(move _45) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_45);\n        StorageDead(_25);\n        _17 = _44;\n        goto -> bb25;\n    }\n    bb22: {\n        StorageDead(_54);\n        _52 = move _53 as usize;\n        StorageDead(_53);\n        _51 = &_52;\n        _49 = alloc::collections::BTreeMap::<usize, mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>::get_mut::<usize>(move _50, _51) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_50);\n        _48 = core::option::Option::<&mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>::unwrap(move _49) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _17 = _48;\n        StorageDead(_52);\n        StorageDead(_49);\n        StorageDead(_48);\n        goto -> bb25;\n    }\n    bb25: {\n        _0 = _17;\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}