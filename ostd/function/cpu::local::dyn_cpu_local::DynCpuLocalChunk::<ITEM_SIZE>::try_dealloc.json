{
  "name": "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc",
  "safe": true,
  "callees": {
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::get_item_index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the index of a dynamically-allocated CPU-local object\n within the chunk.\n\n Returns `None` if the object does not belong to the chunk.\n",
      "adt": {
        "cpu::local::CpuLocal": "ImmutableAsArgument",
        "cpu::local::dyn_cpu_local::DynCpuLocalChunk": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "bitvec::slice::BitSlice::<T, O>::set": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a new value into a single bit.\n\n This is the replacement for `*slice[index] = value;`, as `bitvec` is not\n able to express that under the current `IndexMut` API signature.\n\n ## Parameters\n\n - `&mut self`\n - `index`: The bit-index to set. It must be in `0 .. self.len()`.\n - `value`: The new bit-value to write into the bit at `index`.\n\n ## Panics\n\n This panics if `index` is out of bounds.\n\n ## Examples\n\n ```rust\n use bitvec::prelude::*;\n\n let bits = bits![mut 0, 1];\n bits.set(0, true);\n bits.set(1, false);\n\n assert_eq!(bits, bits![1, 0]);\n ```\n",
      "adt": {}
    },
    "cpu::id::all_cpus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over all CPUs.\n",
      "adt": {
        "core::iter::Map": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "cpu::local::AnyStorage::get_mut_ptr_on_target": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the `mut` pointer for the object on a target CPU.\n\n This method is intended for use when initializing or dropping the storage.\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "cpu::local::CpuLocal": [
      "Ref",
      "Plain",
      "Unknown([Field(0, Ty { id: 3381, kind: RigidTy(Adt(AdtDef(DefId { id: 4628, name: \"cpu::local::dyn_cpu_local::DynamicStorage\" }), GenericArgs([Type(Ty { id: 38, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])"
    ],
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2350, kind: RigidTy(Adt(AdtDef(DefId { id: 4216, name: \"cpu::id::CpuId\" }), GenericArgs([]))) })])"
    ],
    "bitvec::vec::BitVec": [
      "MutRef"
    ],
    "bitvec::slice::BitSlice": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain",
      "MutRef"
    ],
    "cpu::id::CpuId": [
      "Plain"
    ],
    "cpu::local::dyn_cpu_local::DynamicStorage": [
      "MutRef"
    ],
    "core::mem::ManuallyDrop": [
      "Plain"
    ]
  },
  "path": 1678,
  "span": "ostd/src/cpu/local/dyn_cpu_local.rs:198:5: 227:6",
  "src": "pub fn try_dealloc<T>(\n        &mut self,\n        mut cpu_local: CpuLocal<T, DynamicStorage<T>>,\n    ) -> core::result::Result<(), CpuLocal<T, DynamicStorage<T>>> {\n        let Some(index) = self.get_item_index(&cpu_local) else {\n            return Err(cpu_local);\n        };\n\n        self.bitmap.set(index, false);\n        for cpu in all_cpus() {\n            let ptr = cpu_local.storage.get_mut_ptr_on_target(cpu);\n            // SAFETY:\n            //  - `ptr` is valid for both reads and writes, because:\n            //    - The pointer of the CPU-local object on `cpu` is\n            //      non-null and dereferenceable.\n            //    - We can mutably borrow the CPU-local object on `cpu`\n            //      because we have the exclusive access to `cpu_local`.\n            //  - The pointer of the CPU-local object is properly aligned.\n            //  - The pointer of the CPU-local object points to a valid\n            //    instance of `T`.\n            //  - After the deallocation, no one will access the\n            //    dropped CPU-local object, since we explicitly forget\n            //    the `cpu_local`.\n            unsafe {\n                core::ptr::drop_in_place(ptr);\n            }\n        }\n        let _ = ManuallyDrop::new(cpu_local);\n        Ok(())\n    }",
  "mir": "fn cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc(_1: &mut cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>, _2: cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>) -> core::result::Result<(), cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>> {\n    let mut _0: core::result::Result<(), cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>;\n    let mut _3: cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>;\n    let  _4: usize;\n    let mut _5: core::option::Option<usize>;\n    let  _6: &cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>;\n    let mut _7: isize;\n    let  _8: ();\n    let mut _9: &mut bitvec::slice::BitSlice;\n    let mut _10: &mut bitvec::vec::BitVec;\n    let mut _11: core::iter::Map<core::ops::Range<usize>, {closure@ostd/src/cpu/id.rs:76:25: 76:33}>;\n    let mut _12: core::iter::Map<core::ops::Range<usize>, {closure@ostd/src/cpu/id.rs:76:25: 76:33}>;\n    let mut _13: core::iter::Map<core::ops::Range<usize>, {closure@ostd/src/cpu/id.rs:76:25: 76:33}>;\n    let mut _14: core::option::Option<cpu::id::CpuId>;\n    let mut _15: &mut core::iter::Map<core::ops::Range<usize>, {closure@ostd/src/cpu/id.rs:76:25: 76:33}>;\n    let mut _16: isize;\n    let  _17: cpu::id::CpuId;\n    let  _18: *mut T;\n    let mut _19: &mut cpu::local::dyn_cpu_local::DynamicStorage<T>;\n    let  _20: ();\n    let mut _21: core::mem::ManuallyDrop<cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>;\n    let mut _22: cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>;\n    debug self => _1;\n    debug cpu_local => _2;\n    debug index => _4;\n    debug iter => _13;\n    debug cpu => _17;\n    debug ptr => _18;\n    bb0: {\n        StorageLive(_5);\n        _6 = &_2;\n        _5 = cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::get_item_index::<T>(_1, _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [1: bb2, 0: bb3, otherwise: bb10];\n    }\n    bb2: {\n        _4 = ((_5 as variant#1).0: usize);\n        StorageDead(_5);\n        StorageLive(_10);\n        _10 = &mut ((*_1).1: bitvec::vec::BitVec);\n        _9 = <bitvec::vec::BitVec as core::ops::DerefMut>::deref_mut(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_3);\n        _3 = move _2;\n        _0 = core::result::Result::Err(move _3);\n        StorageDead(_3);\n        goto -> bb16;\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = bitvec::slice::BitSlice::set(_9, _4, false) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = cpu::id::all_cpus() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = <core::iter::Map<core::ops::Range<usize>, {closure@ostd/src/cpu/id.rs:76:25: 76:33}> as core::iter::IntoIterator>::into_iter(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageLive(_13);\n        _13 = move _11;\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_14);\n        _15 = &mut _13;\n        _14 = <core::iter::Map<core::ops::Range<usize>, {closure@ostd/src/cpu/id.rs:76:25: 76:33}> as core::iter::Iterator>::next(_15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _16 = discriminant(_14);\n        switchInt(move _16) -> [0: bb12, 1: bb11, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _17 = ((_14 as variant#1).0: cpu::id::CpuId);\n        StorageLive(_19);\n        _19 = &mut (_2.0: cpu::local::dyn_cpu_local::DynamicStorage<T>);\n        _18 = <cpu::local::dyn_cpu_local::DynamicStorage<T> as cpu::local::AnyStorage<T>>::get_mut_ptr_on_target(move _19, _17) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = move _2;\n        _21 = core::mem::ManuallyDrop::<cpu::local::CpuLocal<T, cpu::local::dyn_cpu_local::DynamicStorage<T>>>::new(move _22) -> [return: bb15, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        _20 = core::ptr::drop_in_place::<T>(_18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_14);\n        goto -> bb8;\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _0 = core::result::Result::Ok(());\n        goto -> bb16;\n    }\n    bb16: {\n        return;\n    }\n}\n",
  "doc": " Attempts to deallocate a previously allocated CPU-local object.\n\n Returns `Err(cpu_local)` if the object does not belong to this chunk.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}