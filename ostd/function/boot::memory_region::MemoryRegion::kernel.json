{
  "name": "boot::memory_region::MemoryRegion::kernel",
  "safe": true,
  "callees": {
    "boot::memory_region::MemoryRegion::kernel::__kernel_start": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::kspace::kernel_loaded_offset": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The kernel code is linear mapped to this address.\n\n FIXME: This offset should be randomly chosen by the loader or the\n boot compatibility layer. But we disabled it because OSTD\n doesn't support relocatable kernel yet.\n",
      "adt": {}
    },
    "boot::memory_region::MemoryRegion::kernel::__kernel_end": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "boot::memory_region::MemoryRegionType": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegion": [
      "Plain"
    ]
  },
  "path": 1579,
  "span": "ostd/src/boot/memory_region.rs:79:5: 90:6",
  "src": "pub fn kernel() -> Self {\n        // These are physical addresses provided by the linker script.\n        unsafe extern \"C\" {\n            fn __kernel_start();\n            fn __kernel_end();\n        }\n        MemoryRegion {\n            base: __kernel_start as *const () as usize - kernel_loaded_offset(),\n            len: __kernel_end as *const () as usize - __kernel_start as *const () as usize,\n            typ: MemoryRegionType::Kernel,\n        }\n    }",
  "mir": "fn boot::memory_region::MemoryRegion::kernel() -> boot::memory_region::MemoryRegion {\n    let mut _0: boot::memory_region::MemoryRegion;\n    let mut _1: usize;\n    let mut _2: usize;\n    let mut _3: *const ();\n    let mut _4: unsafe extern \"C\" fn();\n    let mut _5: usize;\n    let mut _6: (usize, bool);\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: *const ();\n    let mut _10: unsafe extern \"C\" fn();\n    let mut _11: usize;\n    let mut _12: *const ();\n    let mut _13: unsafe extern \"C\" fn();\n    let mut _14: (usize, bool);\n    let mut _15: boot::memory_region::MemoryRegionType;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = boot::memory_region::MemoryRegion::kernel::__kernel_start as unsafe extern \"C\" fn();\n        _3 = move _4 as *const ();\n        StorageDead(_4);\n        _2 = move _3 as usize;\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = mm::kspace::kernel_loaded_offset() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = CheckedSub(_2, _5);\n        assert(!move (_6.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _2, move _5) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _1 = move (_6.0: usize);\n        StorageDead(_5);\n        StorageDead(_2);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = boot::memory_region::MemoryRegion::kernel::__kernel_end as unsafe extern \"C\" fn();\n        _9 = move _10 as *const ();\n        StorageDead(_10);\n        _8 = move _9 as usize;\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = boot::memory_region::MemoryRegion::kernel::__kernel_start as unsafe extern \"C\" fn();\n        _12 = move _13 as *const ();\n        StorageDead(_13);\n        _11 = move _12 as usize;\n        StorageDead(_12);\n        _14 = CheckedSub(_8, _11);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _8, move _11) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = move (_14.0: usize);\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageLive(_15);\n        _15 = boot::memory_region::MemoryRegionType::Kernel;\n        _0 = MemoryRegion(move _1, move _7, move _15);\n        StorageDead(_15);\n        StorageDead(_7);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " Constructs a memory region where kernel sections are loaded.\n\n Most boot protocols do not mark the place where the kernel loads as unusable. In this case,\n we need to explicitly construct and append this memory region.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}