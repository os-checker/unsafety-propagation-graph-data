{
  "name": "mm::frame::meta::MetaSlot::drop_meta_in_place",
  "safe": false,
  "callees": {
    "mm::frame::meta::MetaSlot::frame_paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the corresponding frame's physical address.\n",
      "adt": {
        "mm::frame::meta::MetaSlot": "MutableAsArgument"
      }
    },
    "core::cell::UnsafeCell::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the wrapped value.\n\n This can be cast to a pointer of any kind. When creating references, you must uphold the\n aliasing rules; see [the type-level docs][UnsafeCell#aliasing-rules] for more discussion and\n caveats.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let uc = UnsafeCell::new(5);\n\n let five = uc.get();\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::assume_init_read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n to the usual drop handling.\n\n Whenever possible, it is preferable to use [`assume_init`] instead, which\n prevents duplicating the content of the `MaybeUninit<T>`.\n\n # Safety\n\n It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n state. Calling this when the content is not yet fully initialized causes undefined\n behavior. The [type-level documentation][inv] contains more information about\n this initialization invariant.\n\n Moreover, similar to the [`ptr::read`] function, this function creates a\n bitwise copy of the contents, regardless whether the contained type\n implements the [`Copy`] trait or not. When using multiple copies of the\n data (by calling `assume_init_read` multiple times, or first calling\n `assume_init_read` and then [`assume_init`]), it is your responsibility\n to ensure that data may indeed be duplicated.\n\n [inv]: #initialization-invariant\n [`assume_init`]: MaybeUninit::assume_init\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<u32>::uninit();\n x.write(13);\n let x1 = unsafe { x.assume_init_read() };\n // `u32` is `Copy`, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(None);\n let x1 = unsafe { x.assume_init_read() };\n // Duplicating a `None` value is okay, so we may read multiple times.\n let x2 = unsafe { x.assume_init_read() };\n assert_eq!(x1, x2);\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n x.write(Some(vec![0, 1, 2]));\n let x1 = unsafe { x.assume_init_read() };\n let x2 = unsafe { x.assume_init_read() };\n // We now created two copies of the same vector, leading to a double-free ⚠️ when\n // they both get dropped!\n ```\n",
      "adt": {}
    },
    "core::ptr::from_raw_parts_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the same functionality as [`from_raw_parts`], except that a\n raw `*mut` pointer is returned, as opposed to a raw `*const` pointer.\n\n See the documentation of [`from_raw_parts`] for more details.\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "mm::io::VmReader::<'a, mm::io::Infallible>::from_kernel_space": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a `VmReader` from a pointer and a length, which represents\n a memory range in kernel space.\n\n # Safety\n\n `ptr` must be [valid] for reads of `len` bytes during the entire lifetime `a`.\n\n [valid]: crate::mm::io#safety\n",
      "adt": {
        "mm::io::VmReader": "Constructor"
      }
    },
    "mm::frame::meta::AnyFrameMeta::on_drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Called when the last handle to the frame is dropped.\n",
      "adt": {
        "mm::io::VmReader": "MutableAsArgument"
      }
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::meta::MetaSlot": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::cell::UnsafeCell": [
      "Ref"
    ],
    "core::mem::MaybeUninit": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::ptr::DynMetadata": [
      "Plain"
    ],
    "mm::io::VmReader": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 1981,
  "span": "ostd/src/mm/frame/meta.rs:414:5: 439:6",
  "src": "pub(super) unsafe fn drop_meta_in_place(&self) {\n        let paddr = self.frame_paddr();\n\n        // SAFETY: We have exclusive access to the frame metadata.\n        let vtable_ptr = unsafe { &mut *self.vtable_ptr.get() };\n        // SAFETY: The frame metadata is initialized and valid.\n        let vtable_ptr = unsafe { vtable_ptr.assume_init_read() };\n\n        let meta_ptr: *mut dyn AnyFrameMeta =\n            core::ptr::from_raw_parts_mut(self.storage.get(), vtable_ptr);\n\n        // SAFETY: The implementer of the frame metadata decides that if the frame\n        // is safe to be read or not.\n        let mut reader =\n            unsafe { VmReader::from_kernel_space(paddr_to_vaddr(paddr) as *const u8, PAGE_SIZE) };\n\n        // SAFETY: `ptr` points to the metadata storage which is valid to be mutably borrowed under\n        // `vtable_ptr` because the metadata is valid, the vtable is correct, and we have the exclusive\n        // access to the frame metadata.\n        unsafe {\n            // Invoke the custom `on_drop` handler.\n            (*meta_ptr).on_drop(&mut reader);\n            // Drop the frame metadata.\n            core::ptr::drop_in_place(meta_ptr);\n        }\n    }",
  "mir": "fn mm::frame::meta::MetaSlot::drop_meta_in_place(_1: &mm::frame::meta::MetaSlot) -> () {\n    let mut _0: ();\n    let  _2: usize;\n    let mut _3: &mut core::mem::MaybeUninit<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>;\n    let mut _4: *mut core::mem::MaybeUninit<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>;\n    let mut _5: &core::cell::UnsafeCell<core::mem::MaybeUninit<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>>;\n    let  _6: core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>;\n    let mut _7: &core::mem::MaybeUninit<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>;\n    let  _8: *mut dyn mm::frame::meta::AnyFrameMeta;\n    let mut _9: *mut [u8; 40];\n    let mut _10: &core::cell::UnsafeCell<[u8; 40]>;\n    let mut _11: mm::io::VmReader<'_, mm::io::Infallible>;\n    let mut _12: *const u8;\n    let mut _13: usize;\n    let  _14: ();\n    let mut _15: &mut dyn mm::frame::meta::AnyFrameMeta;\n    let mut _16: &mut mm::io::VmReader<'_, mm::io::Infallible>;\n    let  _17: ();\n    debug self => _1;\n    debug paddr => _2;\n    debug vtable_ptr => _3;\n    debug vtable_ptr => _6;\n    debug meta_ptr => _8;\n    debug reader => _11;\n    bb0: {\n        _2 = mm::frame::meta::MetaSlot::frame_paddr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).2: core::cell::UnsafeCell<core::mem::MaybeUninit<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>>);\n        _4 = core::cell::UnsafeCell::<core::mem::MaybeUninit<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>>::get(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = &mut (*_4);\n        StorageLive(_7);\n        _7 = &(*_3);\n        _6 = core::mem::MaybeUninit::<core::ptr::DynMetadata<dyn mm::frame::meta::AnyFrameMeta>>::assume_init_read(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &((*_1).0: core::cell::UnsafeCell<[u8; 40]>);\n        _9 = core::cell::UnsafeCell::<[u8; 40]>::get(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = core::ptr::from_raw_parts_mut::<dyn mm::frame::meta::AnyFrameMeta, [u8; 40]>(move _9, _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = mm::kspace::paddr_to_vaddr(_2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = move _13 as *const u8;\n        StorageDead(_13);\n        _11 = mm::io::VmReader::<'_, mm::io::Infallible>::from_kernel_space(move _12, mm::PAGE_SIZE) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageLive(_15);\n        _15 = &mut (*_8);\n        _16 = &mut _11;\n        _14 = <dyn mm::frame::meta::AnyFrameMeta as mm::frame::meta::AnyFrameMeta>::on_drop(move _15, _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        _17 = core::ptr::drop_in_place::<dyn mm::frame::meta::AnyFrameMeta>(_8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Drops the metadata of a slot in place.\n\n After this operation, the metadata becomes uninitialized. Any access to the\n metadata is undefined behavior unless it is re-initialized by [`Self::write_meta`].\n\n # Safety\n\n The caller should ensure that:\n  - the reference count is `0` (so we are the sole owner of the frame);\n  - the metadata is initialized;\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}