{
  "name": "<arch::iommu::registers::extended_cap::ExtendedCapability as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "arch::iommu::registers::extended_cap::ExtendedCapability::flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extended capability flags\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapability": "ImmutableAsArgument",
        "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": "Constructor"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "arch::iommu::registers::extended_cap::ExtendedCapability::maximum_handle_mask": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maximum Handle Mask Value, indicates the maximum supported value for the Interrupt\n Mask (IM) field in the Interrupt Entry Cache Invalidation Descriptorr (iec_inv_dsc).\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapability": "ImmutableAsArgument"
      }
    },
    "arch::iommu::registers::extended_cap::ExtendedCapability::pasid_size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " PASID Size Supported, indicates the PASID size supported by the remapping hardware\n for requests-with-PASID. A value of N in this field indicates hardware supports\n PASID field of N+1 bits.\n\n This field is unused and reported as 0 if Scalable Mode Translation Support (SMTS)\n field is Clear.\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapability": "ImmutableAsArgument"
      }
    },
    "arch::iommu::registers::extended_cap::ExtendedCapability::iotlb_register_offset": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " IOTLB Register Offset. This field specifies the offset to the IOTLB registers relative\n to the register base address of this remapping hardware unit.\n\n If the register base address is X, and the value reported in this field is Y, the\n address for the IOTLB registers is calculated as X+(16*Y).\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapability": "ImmutableAsArgument"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finishes output and returns any error encountered.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     baz: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .field(\"baz\", &self.baz)\n            .finish() // You need to call it to \"finish\" the\n                      // struct formatting.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, baz: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, baz: \"Hello World\" }\"#,\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapability": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::<arch::iommu::registers::extended_cap::ExtendedCapability as core::fmt::Debug>::fmt"
  },
  "span": "ostd/src/arch/x86/iommu/registers/extended_cap.rs:50:5: 58:6",
  "src": "fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"ExtendedCapability\")\n            .field(\"flags\", &self.flags())\n            .field(\"maximum_handle_mask\", &self.maximum_handle_mask())\n            .field(\"pasid_size\", &self.pasid_size())\n            .field(\"iotlb_register_offset\", &self.iotlb_register_offset())\n            .field(\"raw\", &self.0)\n            .finish()\n    }",
  "mir": "fn <arch::iommu::registers::extended_cap::ExtendedCapability as core::fmt::Debug>::fmt(_1: &arch::iommu::registers::extended_cap::ExtendedCapability, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _7: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _8: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _9: core::fmt::DebugStruct<'_, '_>;\n    let mut _10: &str;\n    let mut _11: &str;\n    let mut _12: &dyn core::fmt::Debug;\n    let  _13: &arch::iommu::registers::extended_cap::ExtendedCapabilityFlags;\n    let  _14: arch::iommu::registers::extended_cap::ExtendedCapabilityFlags;\n    let mut _15: &str;\n    let mut _16: &dyn core::fmt::Debug;\n    let  _17: &u64;\n    let  _18: u64;\n    let mut _19: &str;\n    let mut _20: &dyn core::fmt::Debug;\n    let  _21: &u64;\n    let  _22: u64;\n    let mut _23: &str;\n    let mut _24: &dyn core::fmt::Debug;\n    let  _25: &u64;\n    let  _26: u64;\n    let mut _27: &str;\n    let mut _28: &dyn core::fmt::Debug;\n    let  _29: &u64;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = \"ExtendedCapability\";\n        _9 = core::fmt::Formatter::<'_>::debug_struct(_2, move _10) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _8 = &mut _9;\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = \"flags\";\n        StorageLive(_12);\n        StorageLive(_14);\n        _14 = arch::iommu::registers::extended_cap::ExtendedCapability::flags(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _13 = &_14;\n        _12 = _13 as &dyn core::fmt::Debug;\n        _7 = core::fmt::DebugStruct::<'_, '_>::field(move _8, move _11, move _12) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageLive(_15);\n        _15 = \"maximum_handle_mask\";\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = arch::iommu::registers::extended_cap::ExtendedCapability::maximum_handle_mask(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _17 = &_18;\n        _16 = _17 as &dyn core::fmt::Debug;\n        _6 = core::fmt::DebugStruct::<'_, '_>::field(_7, move _15, move _16) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_19);\n        _19 = \"pasid_size\";\n        StorageLive(_20);\n        StorageLive(_22);\n        _22 = arch::iommu::registers::extended_cap::ExtendedCapability::pasid_size(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _21 = &_22;\n        _20 = _21 as &dyn core::fmt::Debug;\n        _5 = core::fmt::DebugStruct::<'_, '_>::field(_6, move _19, move _20) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_23);\n        _23 = \"iotlb_register_offset\";\n        StorageLive(_24);\n        StorageLive(_26);\n        _26 = arch::iommu::registers::extended_cap::ExtendedCapability::iotlb_register_offset(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _25 = &_26;\n        _24 = _25 as &dyn core::fmt::Debug;\n        _4 = core::fmt::DebugStruct::<'_, '_>::field(_5, move _23, move _24) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_27);\n        _27 = \"raw\";\n        StorageLive(_28);\n        _29 = &((*_1).0: u64);\n        _28 = _29 as &dyn core::fmt::Debug;\n        _3 = core::fmt::DebugStruct::<'_, '_>::field(_4, move _27, move _28) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_28);\n        StorageDead(_27);\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish(_3) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_26);\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_14);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}