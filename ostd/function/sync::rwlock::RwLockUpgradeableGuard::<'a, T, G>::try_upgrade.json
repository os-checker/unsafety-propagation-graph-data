{
  "name": "sync::rwlock::RwLockUpgradeableGuard::<'a, T, G>::try_upgrade",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicUsize::compare_exchange": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer if the current value is the same as\n the `current` value.\n\n The return value is a result indicating whether the new value was written and\n containing the previous value. On success this value is guaranteed to be equal to\n `current`.\n\n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. `success` describes the required ordering for the\n read-modify-write operation that takes place if the comparison with `current` succeeds.\n `failure` describes the required ordering for the load operation that takes place when\n the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.compare_exchange(5, 10,\n                                      Ordering::Acquire,\n                                      Ordering::Relaxed),\n            Ok(5));\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n\n assert_eq!(some_var.compare_exchange(6, 12,\n                                      Ordering::SeqCst,\n                                      Ordering::Acquire),\n            Err(10));\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n\n # Considerations\n\n `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n of CAS operations. In particular, a load of the value followed by a successful\n `compare_exchange` with the previous load *does not ensure* that other threads have not\n changed the value in the interim! This is usually important when the *equality* check in\n the `compare_exchange` is being used to check the *identity* of a value, but equality\n does not necessarily imply identity. This is a particularly common case for pointers, as\n a pointer holding the same address does not imply that the same object exists at that\n address! In this case, `compare_exchange` can lead to the [ABA problem].\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::is_ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Ok`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_ok(), true);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_ok(), false);\n ```\n",
      "adt": {}
    },
    "sync::guard::GuardTransfer::transfer_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Atomically transfers the current guard to a new instance.\n\n This function ensures that there are no 'gaps' between the destruction of the old guard and\n the creation of the new guard, thereby maintaining the atomicity of guard transitions.\n\n The original guard must be dropped immediately after calling this method.\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::rwlock::RwLock": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "sync::rwlock::RwLockUpgradeableGuard": [
      "Unknown([Field(1, Ty { id: 6994, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 6995, kind: RigidTy(Adt(AdtDef(DefId { id: 4828, name: \"sync::rwlock::RwLock\" }), GenericArgs([Type(Ty { id: 38, kind: Param(ParamTy { index: 1, name: \"T\" }) }), Type(Ty { id: 6989, kind: Param(ParamTy { index: 2, name: \"G\" }) })]))) }, Not)) })])",
      "Unknown([Field(0, Ty { id: 7007, kind: Alias(Projection, AliasTy { def_id: AliasDef(DefId { id: 5838, name: \"sync::guard::SpinGuardian::Guard\" }), args: GenericArgs([Type(Ty { id: 6989, kind: Param(ParamTy { index: 2, name: \"G\" }) })]) }) })])",
      "Plain"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Ref"
    ],
    "sync::rwlock::RwLockWriteGuard": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::sync::rwlock::RwLockUpgradeableGuard::<'a, T, G>::try_upgrade"
  },
  "span": "ostd/src/sync/rwlock.rs:363:5: 378:6",
  "src": "pub fn try_upgrade(mut self) -> Result<RwLockWriteGuard<'a, T, G>, Self> {\n        let res = self.inner.lock.compare_exchange(\n            UPGRADEABLE_READER | BEING_UPGRADED,\n            WRITER | UPGRADEABLE_READER,\n            AcqRel,\n            Relaxed,\n        );\n        if res.is_ok() {\n            let inner = self.inner;\n            let guard = self.guard.transfer_to();\n            drop(self);\n            Ok(RwLockWriteGuard { inner, guard })\n        } else {\n            Err(self)\n        }\n    }",
  "mir": "fn sync::rwlock::RwLockUpgradeableGuard::<'a, T, G>::try_upgrade(_1: sync::rwlock::RwLockUpgradeableGuard<'_, T, G>) -> core::result::Result<sync::rwlock::RwLockWriteGuard<'_, T, G>, sync::rwlock::RwLockUpgradeableGuard<'_, T, G>> {\n    let mut _0: core::result::Result<sync::rwlock::RwLockWriteGuard<'_, T, G>, sync::rwlock::RwLockUpgradeableGuard<'_, T, G>>;\n    let  _2: core::result::Result<usize, usize>;\n    let mut _3: &core::sync::atomic::AtomicUsize;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: core::sync::atomic::Ordering;\n    let mut _7: core::sync::atomic::Ordering;\n    let mut _8: bool;\n    let mut _9: &core::result::Result<usize, usize>;\n    let  _10: &sync::rwlock::RwLock<T, G>;\n    let  _11: <G as sync::guard::SpinGuardian>::Guard;\n    let mut _12: &mut <G as sync::guard::SpinGuardian>::Guard;\n    let  _13: ();\n    let mut _14: sync::rwlock::RwLockUpgradeableGuard<'_, T, G>;\n    let mut _15: sync::rwlock::RwLockWriteGuard<'_, T, G>;\n    let mut _16: sync::rwlock::RwLockUpgradeableGuard<'_, T, G>;\n    let mut _17: &sync::rwlock::RwLock<T, G>;\n    debug self => _1;\n    debug res => _2;\n    debug inner => _10;\n    debug guard => _11;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _17 = (_1.1: &sync::rwlock::RwLock<T, G>);\n        _3 = &((*_17).1: core::sync::atomic::AtomicUsize);\n        StorageLive(_4);\n        _4 = BitOr(sync::rwlock::UPGRADEABLE_READER, sync::rwlock::BEING_UPGRADED);\n        StorageLive(_5);\n        _5 = BitOr(sync::rwlock::WRITER, sync::rwlock::UPGRADEABLE_READER);\n        StorageLive(_6);\n        _6 = core::sync::atomic::Ordering::AcqRel;\n        StorageLive(_7);\n        _7 = core::sync::atomic::Ordering::Relaxed;\n        _2 = core::sync::atomic::AtomicUsize::compare_exchange(move _3, move _4, move _5, move _6, move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_2;\n        _8 = core::result::Result::<usize, usize>::is_ok(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _8) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_9);\n        _10 = (_1.1: &sync::rwlock::RwLock<T, G>);\n        StorageLive(_12);\n        _12 = &mut (_1.0: <G as sync::guard::SpinGuardian>::Guard);\n        _11 = <<G as sync::guard::SpinGuardian>::Guard as sync::guard::GuardTransfer>::transfer_to(move _12) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_12);\n        StorageLive(_14);\n        _14 = move _1;\n        _13 = core::mem::drop::<sync::rwlock::RwLockUpgradeableGuard<'_, T, G>>(move _14) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageLive(_15);\n        _15 = RwLockWriteGuard(_11, _10);\n        _0 = core::result::Result::Ok(move _15);\n        StorageDead(_15);\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_16);\n        _16 = move _1;\n        _0 = core::result::Result::Err(move _16);\n        StorageDead(_16);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Attempts to upgrade this upread guard to a write guard atomically.\n\n This function will never spin-wait and will return immediately.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}