{
  "name": "<mm::io::VmReader<'a> as mm::io::FallibleVmRead<mm::io::Fallible>>::read_fallible",
  "safe": true,
  "callees": {
    "mm::io::VmReader::<'_, Fallibility>::remain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes for the remaining data.\n",
      "adt": {
        "mm::io::VmReader": "ImmutableAsArgument"
      }
    },
    "mm::io::VmWriter::<'_, Fallibility>::avail": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes for the available space.\n",
      "adt": {
        "mm::io::VmWriter": "ImmutableAsArgument"
      }
    },
    "core::cmp::Ord::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.min(2), 1);\n assert_eq!(2.min(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").min(Equal(\"other\")).0, \"self\");\n ```\n",
      "adt": {}
    },
    "mm::io::memcpy_fallible": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `len` bytes from `src` to `dst`.\n This function will early stop copying if encountering an unresolvable page fault.\n\n Returns the number of successfully copied bytes.\n\n In the following cases, this method may cause unexpected bytes to be copied, but will not cause\n safety problems as long as the safety requirements are met:\n - The source and destination overlap.\n - The current context is not associated with valid user space (e.g., in the kernel thread).\n\n # Safety\n\n - `src` must either be [valid] for reads of `len` bytes or be in user space for `len` bytes.\n - `dst` must either be [valid] for writes of `len` bytes or be in user space for `len` bytes.\n\n [valid]: crate::mm::io#safety\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an unsigned offset to a pointer using wrapping arithmetic.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n This operation itself is always safe, but using the resulting pointer is not.\n\n The resulting pointer \"remembers\" the [allocation] that `self` points to; it must not\n be used to read or write other allocations.\n\n In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n `x` and `y` point into the same allocation.\n\n Compared to [`add`], this method basically delays the requirement of staying within the\n same allocation: [`add`] is immediate Undefined Behavior when crossing object\n boundaries; `wrapping_add` produces a pointer but still leads to Undefined Behavior if a\n pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`add`]\n can be optimized better and is thus preferable in performance-sensitive code.\n\n The delayed check only considers the value of the pointer that was dereferenced, not the\n intermediate values used during the computation of the final result. For example,\n `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n allocation and then re-entering it later is permitted.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n # use std::fmt::Write;\n // Iterate using a raw pointer in increments of two elements\n let data = [1u8, 2, 3, 4, 5];\n let mut ptr: *const u8 = data.as_ptr();\n let step = 2;\n let end_rounded_up = ptr.wrapping_add(6);\n\n let mut out = String::new();\n while ptr != end_rounded_up {\n     unsafe {\n         write!(&mut out, \"{}, \", *ptr)?;\n     }\n     ptr = ptr.wrapping_add(step);\n }\n assert_eq!(out, \"1, 3, 5, \");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an unsigned offset to a pointer using wrapping arithmetic.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n This operation itself is always safe, but using the resulting pointer is not.\n\n The resulting pointer \"remembers\" the [allocation] that `self` points to; it must not\n be used to read or write other allocations.\n\n In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n `x` and `y` point into the same allocation.\n\n Compared to [`add`], this method basically delays the requirement of staying within the\n same allocation: [`add`] is immediate Undefined Behavior when crossing object\n boundaries; `wrapping_add` produces a pointer but still leads to Undefined Behavior if a\n pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`add`]\n can be optimized better and is thus preferable in performance-sensitive code.\n\n The delayed check only considers the value of the pointer that was dereferenced, not the\n intermediate values used during the computation of the final result. For example,\n `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n allocation and then re-entering it later is permitted.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n // Iterate using a raw pointer in increments of two elements\n let data = [1u8, 2, 3, 4, 5];\n let mut ptr: *const u8 = data.as_ptr();\n let step = 2;\n let end_rounded_up = ptr.wrapping_add(6);\n\n // This loop prints \"1, 3, 5, \"\n while ptr != end_rounded_up {\n     unsafe {\n         print!(\"{}, \", *ptr);\n     }\n     ptr = ptr.wrapping_add(step);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::io::VmReader": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "mm::io::VmWriter": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "error::Error": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::<mm::io::VmReader<'a> as mm::io::FallibleVmRead<mm::io::Fallible>>::read_fallible"
  },
  "span": "ostd/src/mm/io.rs:382:13: 403:14",
  "src": "fn read_fallible(\n                &mut self,\n                writer: &mut VmWriter<'_, $writer_fallibility>,\n            ) -> core::result::Result<usize, (Error, usize)> {\n                let copy_len = self.remain().min(writer.avail());\n                if copy_len == 0 {\n                    return Ok(0);\n                }\n\n                // SAFETY: The source and destination are subsets of memory ranges specified by\n                // the reader and writer, so they are either valid for reading and writing or in\n                // user space.\n                let copied_len = unsafe { memcpy_fallible(writer.cursor, self.cursor, copy_len) };\n                self.cursor = self.cursor.wrapping_add(copied_len);\n                writer.cursor = writer.cursor.wrapping_add(copied_len);\n\n                if copied_len < copy_len {\n                    Err((Error::PageFault, copied_len))\n                } else {\n                    Ok(copied_len)\n                }\n            }",
  "mir": "fn <mm::io::VmReader<'a> as mm::io::FallibleVmRead<mm::io::Fallible>>::read_fallible(_1: &mut mm::io::VmReader<'_>, _2: &mut mm::io::VmWriter<'_>) -> core::result::Result<usize, (error::Error, usize)> {\n    let mut _0: core::result::Result<usize, (error::Error, usize)>;\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: &mm::io::VmReader<'_>;\n    let mut _6: usize;\n    let mut _7: &mm::io::VmWriter<'_>;\n    let  _8: usize;\n    let mut _9: *mut u8;\n    let mut _10: *const u8;\n    let mut _11: *const u8;\n    let mut _12: *const u8;\n    let mut _13: *mut u8;\n    let mut _14: *mut u8;\n    let mut _15: bool;\n    let mut _16: (error::Error, usize);\n    let mut _17: error::Error;\n    debug self => _1;\n    debug writer => _2;\n    debug copy_len => _3;\n    debug copied_len => _8;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = mm::io::VmReader::<'_>::remain(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_2);\n        _6 = mm::io::VmWriter::<'_>::avail(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _3 = <usize as core::cmp::Ord>::min(move _4, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_4);\n        switchInt(_3) -> [0: bb4, otherwise: bb5];\n    }\n    bb4: {\n        _0 = core::result::Result::Ok(0_usize);\n        goto -> bb12;\n    }\n    bb5: {\n        StorageLive(_9);\n        _9 = ((*_2).0: *mut u8);\n        StorageLive(_10);\n        _10 = ((*_1).0: *const u8);\n        _8 = mm::io::memcpy_fallible(move _9, move _10, _3) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = ((*_1).0: *const u8);\n        _11 = core::ptr::const_ptr::<impl *const u8>::wrapping_add(move _12, _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        ((*_1).0: *const u8) = move _11;\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ((*_2).0: *mut u8);\n        _13 = core::ptr::mut_ptr::<impl *mut u8>::wrapping_add(move _14, _8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        ((*_2).0: *mut u8) = move _13;\n        StorageDead(_13);\n        StorageLive(_15);\n        _15 = Lt(_8, _3);\n        switchInt(move _15) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = error::Error::PageFault;\n        _16 = (move _17, _8);\n        StorageDead(_17);\n        _0 = core::result::Result::Err(move _16);\n        StorageDead(_16);\n        goto -> bb11;\n    }\n    bb10: {\n        _0 = core::result::Result::Ok(_8);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_15);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}