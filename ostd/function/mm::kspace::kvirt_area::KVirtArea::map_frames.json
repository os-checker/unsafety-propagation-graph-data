{
  "name": "mm::kspace::kvirt_area::KVirtArea::map_frames",
  "safe": true,
  "callees": {
    "core::num::<impl usize>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "util::range_alloc::RangeAllocator::alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a range specific by the `size`.\n\n This is currently implemented with a simple FIRST-FIT algorithm.\n",
      "adt": {
        "util::range_alloc::RangeAllocator": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "core::ops::Range": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "mm::page_table::PageTable::<C>::cursor_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new cursor exclusively accessing the virtual address range for mapping.\n\n If another cursor is already accessing the range, the new cursor may wait until the\n previous cursor is dropped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "core::ops::Range": "ImmutableAsArgument",
        "mm::page_table::PageTable": "ImmutableAsArgument",
        "mm::page_table::cursor::CursorMut": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::frame::Frame::<(dyn mm::frame::meta::AnyFrameMeta + 'static)>::from_unsized": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a [`Frame`] with a specific metadata type into a\n [`Frame<dyn AnyFrameMeta>`].\n\n This exists because:\n\n ```ignore\n impl<M: AnyFrameMeta + ?Sized> From<Frame<M>> for Frame<dyn AnyFrameMeta>\n ```\n\n will conflict with `impl<T> core::convert::From<T> for T` in crate `core`.\n",
      "adt": {
        "mm::frame::Frame": "Constructor"
      }
    },
    "mm::page_table::cursor::CursorMut::<'rcu, C>::map": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps the item starting from the current address to a physical address range.\n\n If the current address has already mapped pages, it will do a re-map,\n taking out the old physical address and replacing it with the new one.\n This function will return [`Err`] with a [`PageTableFrag`], the not\n mapped item. The caller should drop it after TLB coherence.\n\n If there is no mapped pages in the specified virtual address range,\n the function will return [`None`].\n\n # Panics\n\n This function will panic if\n  - the virtual address range to be mapped is out of the locked range;\n  - the current virtual address is not aligned to the page size of the\n    item to be mapped;\n\n # Safety\n\n The caller should ensure that\n  - the range being mapped does not affect kernel's memory safety;\n  - the physical address to be mapped is valid and safe to use;\n",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::page_table::cursor::CursorMut": "MutableAsArgument"
      }
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "util::range_alloc::RangeAllocator": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5339, kind: RigidTy(Adt(AdtDef(DefId { id: 3414, name: \"mm::frame::Frame\" }), GenericArgs([Type(Ty { id: 44, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "mm::page_table::PageTable": [
      "Ref"
    ],
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ],
    "mm::page_table::cursor::CursorMut": [
      "Plain",
      "MutRef"
    ],
    "mm::frame::Frame": [
      "Plain"
    ],
    "mm::kspace::MappedItem": [
      "Plain"
    ],
    "mm::page_prop::PageProperty": [
      "Plain"
    ],
    "mm::kspace::kvirt_area::KVirtArea": [
      "Plain"
    ]
  },
  "path": 2181,
  "span": "ostd/src/mm/kspace/kvirt_area.rs:99:5: 125:6",
  "src": "pub fn map_frames<T: AnyFrameMeta + ?Sized>(\n        area_size: usize,\n        map_offset: usize,\n        frames: impl Iterator<Item = Frame<T>>,\n        prop: PageProperty,\n    ) -> Self {\n        assert!(area_size.is_multiple_of(PAGE_SIZE));\n        assert!(map_offset.is_multiple_of(PAGE_SIZE));\n\n        let range = KVIRT_AREA_ALLOCATOR.alloc(area_size).unwrap();\n        let cursor_range = range.start + map_offset..range.end;\n\n        let page_table = KERNEL_PAGE_TABLE.get().unwrap();\n        let preempt_guard = disable_preempt();\n        let mut cursor = page_table\n            .cursor_mut(&preempt_guard, &cursor_range)\n            .unwrap();\n\n        for frame in frames.into_iter() {\n            // SAFETY: The constructor of the `KVirtArea` has already ensured\n            // that this mapping does not affect kernel's memory safety.\n            unsafe { cursor.map(MappedItem::Tracked(Frame::from_unsized(frame), prop)) }\n                .expect(\"Failed to map frame in a new `KVirtArea`\");\n        }\n\n        Self { range }\n    }",
  "mir": "fn mm::kspace::kvirt_area::KVirtArea::map_frames(_1: usize, _2: usize, _3: impl Iterator<Item = Frame<T>>, _4: mm::page_prop::PageProperty) -> mm::kspace::kvirt_area::KVirtArea {\n    let mut _0: mm::kspace::kvirt_area::KVirtArea;\n    let mut _5: bool;\n    let mut _6: !;\n    let mut _7: bool;\n    let mut _8: !;\n    let  _9: core::ops::Range<usize>;\n    let mut _10: core::result::Result<core::ops::Range<usize>, util::range_alloc::RangeAllocError>;\n    let mut _11: &util::range_alloc::RangeAllocator;\n    let  _12: core::ops::Range<usize>;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: (usize, bool);\n    let mut _16: usize;\n    let  _17: &mm::page_table::PageTable<mm::kspace::KernelPtConfig>;\n    let mut _18: core::option::Option<&mm::page_table::PageTable<mm::kspace::KernelPtConfig>>;\n    let mut _19: &spin::once::Once<mm::page_table::PageTable<mm::kspace::KernelPtConfig>>;\n    let  _20: task::preempt::guard::DisabledPreemptGuard;\n    let mut _21: mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _22: core::result::Result<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>;\n    let  _23: &task::preempt::guard::DisabledPreemptGuard;\n    let  _24: &core::ops::Range<usize>;\n    let mut _25: impl Iterator<Item = Frame<T>>;\n    let mut _26: impl Iterator<Item = Frame<T>>;\n    let mut _27: impl Iterator<Item = Frame<T>>;\n    let mut _28: core::option::Option<mm::frame::Frame<T>>;\n    let mut _29: &mut impl Iterator<Item = Frame<T>>;\n    let mut _30: isize;\n    let  _31: mm::frame::Frame<T>;\n    let  _32: ();\n    let mut _33: core::result::Result<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>;\n    let mut _34: &mut mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _35: mm::kspace::MappedItem;\n    let mut _36: mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>;\n    let mut _37: &str;\n    debug area_size => _1;\n    debug map_offset => _2;\n    debug frames => _3;\n    debug prop => _4;\n    debug range => _9;\n    debug cursor_range => _12;\n    debug page_table => _17;\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug cursor => _21;\n    debug iter => _27;\n    debug frame => _31;\n    bb0: {\n        StorageLive(_5);\n        _5 = core::num::<impl usize>::is_multiple_of(_1, mm::PAGE_SIZE) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _5) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_7);\n        _7 = core::num::<impl usize>::is_multiple_of(_2, mm::PAGE_SIZE) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        _6 = core::panicking::panic(\"assertion failed: area_size.is_multiple_of(PAGE_SIZE)\") -> unwind unreachable;\n    }\n    bb4: {\n        switchInt(move _7) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = {alloc1241: &util::range_alloc::RangeAllocator};\n        _10 = util::range_alloc::RangeAllocator::alloc(move _11, _1) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        _8 = core::panicking::panic(\"assertion failed: map_offset.is_multiple_of(PAGE_SIZE)\") -> unwind unreachable;\n    }\n    bb7: {\n        StorageDead(_11);\n        _9 = core::result::Result::<core::ops::Range<usize>, util::range_alloc::RangeAllocError>::unwrap(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = (_9.0: usize);\n        _15 = CheckedAdd(_14, _2);\n        assert(!move (_15.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _14, _2) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _13 = move (_15.0: usize);\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = (_9.1: usize);\n        _12 = Range(move _13, move _16);\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = {alloc1275: &spin::once::Once<mm::page_table::PageTable<mm::kspace::KernelPtConfig>>};\n        _18 = spin::once::Once::<mm::page_table::PageTable<mm::kspace::KernelPtConfig>>::get(move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        _17 = core::option::Option::<&mm::page_table::PageTable<mm::kspace::KernelPtConfig>>::unwrap(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_18);\n        _20 = task::preempt::guard::disable_preempt() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_21);\n        StorageLive(_22);\n        _23 = &_20;\n        _24 = &_12;\n        _22 = mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::cursor_mut::<task::preempt::guard::DisabledPreemptGuard>(_17, _23, _24) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _21 = core::result::Result::<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>::unwrap(move _22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_22);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = <impl Iterator<Item = Frame<T>> as core::iter::IntoIterator>::into_iter(_3) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _25 = <impl Iterator<Item = Frame<T>> as core::iter::IntoIterator>::into_iter(move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        StorageLive(_27);\n        _27 = move _25;\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_28);\n        _29 = &mut _27;\n        _28 = <impl Iterator<Item = Frame<T>> as core::iter::Iterator>::next(_29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _30 = discriminant(_28);\n        switchInt(move _30) -> [0: bb21, 1: bb20, otherwise: bb19];\n    }\n    bb19: {\n        unreachable;\n    }\n    bb20: {\n        _31 = move ((_28 as variant#1).0: mm::frame::Frame<T>);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _21;\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = mm::frame::Frame::<(dyn mm::frame::meta::AnyFrameMeta + 'static)>::from_unsized::<T>(_31) -> [return: bb22, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_28);\n        drop(_27) -> [return: bb25, unwind unreachable];\n    }\n    bb22: {\n        _35 = mm::kspace::MappedItem::Tracked(move _36, _4);\n        StorageDead(_36);\n        _33 = mm::page_table::cursor::CursorMut::<'_, mm::kspace::KernelPtConfig>::map(move _34, move _35) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_37);\n        _37 = \"Failed to map frame in a new `KVirtArea`\";\n        _32 = core::result::Result::<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>::expect(move _33, move _37) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_37);\n        StorageDead(_33);\n        StorageDead(_28);\n        goto -> bb17;\n    }\n    bb25: {\n        StorageDead(_27);\n        StorageDead(_25);\n        _0 = KVirtArea(_9);\n        drop(_21) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_21);\n        drop(_20) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_12);\n        return;\n    }\n}\n",
  "doc": " Create a kernel virtual area and map tracked pages into it.\n\n The created virtual area will have a size of `area_size`, and the pages\n will be mapped starting from `map_offset` in the area.\n\n # Panics\n\n This function panics if\n  - the area size is not a multiple of [`PAGE_SIZE`];\n  - the map offset is not aligned to [`PAGE_SIZE`];\n  - the map offset plus the size of the pages exceeds the area size.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}