{
  "name": "mm::heap::slot::HeapSlot::alloc_large",
  "safe": true,
  "callees": {
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_segment_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a contiguous range of frames with additional metadata.\n\n The returned [`Segment`] contains at least one frame. The method returns\n an error if the number of frames is zero.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "mm::frame::segment::Segment::<M>::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forgets the [`Segment`] and gets a raw range of physical addresses.\n",
      "adt": {
        "core::ops::Range": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull` if `ptr` is non-null.\n\n # Panics during const evaluation\n\n This method will panic during const evaluation if the pointer cannot be\n determined to be null or not. See [`is_null`] for more information.\n\n [`is_null`]: ../primitive.pointer.html#method.is_null-1\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::<u32>::new(&mut x as *mut _).expect(\"ptr is null!\");\n\n if let Some(ptr) = NonNull::<u32>::new(std::ptr::null_mut()) {\n     unreachable!();\n }\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4987, kind: RigidTy(Adt(AdtDef(DefId { id: 3684, name: \"mm::frame::segment::Segment\" }), GenericArgs([Type(Ty { id: 4993, kind: RigidTy(Adt(AdtDef(DefId { id: 5222, name: \"mm::heap::slot::LargeAllocFrameMeta\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::frame::segment::Segment": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "mm::heap::slot::SlotInfo": [
      "Plain"
    ],
    "mm::heap::slot::HeapSlot": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::heap::slot::HeapSlot::alloc_large"
  },
  "span": "ostd/src/mm/heap/slot.rs:82:5: 100:6",
  "src": "pub fn alloc_large(size: usize) -> Result<Self, AllocError> {\n        assert_eq!(size % PAGE_SIZE, 0);\n        let nframes = size / PAGE_SIZE;\n        let segment = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_segment_with(nframes, |_| LargeAllocFrameMeta)\n            .map_err(|_| {\n                log::error!(\"Failed to allocate a large slot\");\n                AllocError\n            })?;\n\n        let paddr_range = segment.into_raw();\n        let vaddr = paddr_to_vaddr(paddr_range.start);\n\n        Ok(Self {\n            addr: NonNull::new(vaddr as *mut u8).unwrap(),\n            info: SlotInfo::LargeSlot(size),\n        })\n    }",
  "mir": "fn mm::heap::slot::HeapSlot::alloc_large(_1: usize) -> core::result::Result<mm::heap::slot::HeapSlot, core::alloc::AllocError> {\n    let mut _0: core::result::Result<mm::heap::slot::HeapSlot, core::alloc::AllocError>;\n    let mut _2: (&usize, &usize);\n    let mut _3: &usize;\n    let  _4: usize;\n    let mut _5: bool;\n    let mut _6: &usize;\n    let  _7: &usize;\n    let  _8: &usize;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: usize;\n    let  _12: core::panicking::AssertKind;\n    let  _13: !;\n    let mut _14: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _15: usize;\n    let mut _16: bool;\n    let mut _17: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::alloc::AllocError>, mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>>;\n    let mut _18: core::result::Result<mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>, core::alloc::AllocError>;\n    let mut _19: core::result::Result<mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>, error::Error>;\n    let mut _20: &mm::frame::allocator::FrameAllocOptions;\n    let  _21: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _22: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _23: mm::frame::allocator::FrameAllocOptions;\n    let mut _24: isize;\n    let  _25: mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>;\n    let  _26: core::ops::Range<usize>;\n    let  _27: usize;\n    let mut _28: usize;\n    let mut _29: mm::heap::slot::HeapSlot;\n    let mut _30: core::ptr::NonNull<u8>;\n    let mut _31: core::option::Option<core::ptr::NonNull<u8>>;\n    let mut _32: *mut u8;\n    let mut _33: mm::heap::slot::SlotInfo;\n    debug size => _1;\n    debug left_val => _7;\n    debug right_val => _8;\n    debug kind => _12;\n    debug nframes => _15;\n    debug segment => _25;\n    debug residual => core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError);\n    debug val => _25;\n    debug paddr_range => _26;\n    debug vaddr => _27;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _5, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _1) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = Rem(_1, mm::PAGE_SIZE);\n        _3 = &_4;\n        StorageLive(_6);\n        _6 = mm::heap::slot::HeapSlot::alloc_large::promoted[0];\n        _2 = (move _3, move _6);\n        StorageDead(_6);\n        StorageDead(_3);\n        _7 = (_2.0: &usize);\n        _8 = (_2.1: &usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (*_7);\n        StorageLive(_11);\n        _11 = (*_8);\n        _9 = Eq(move _10, move _11);\n        switchInt(move _9) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_4);\n        StorageDead(_2);\n        _16 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _16, \"attempt to divide `{}` by zero\", _1) -> [success: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = core::panicking::AssertKind::Eq;\n        StorageLive(_14);\n        _14 = core::option::Option::None;\n        _13 = core::panicking::assert_failed::<usize, usize>(_12, _7, _8, move _14) -> unwind unreachable;\n    }\n    bb4: {\n        _15 = Div(_1, mm::PAGE_SIZE);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _22 = &mut _23;\n        _21 = mm::frame::allocator::FrameAllocOptions::zeroed(move _22, false) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _20 = &(*_21);\n        StorageDead(_22);\n        _19 = mm::frame::allocator::FrameAllocOptions::alloc_segment_with::<mm::heap::slot::LargeAllocFrameMeta, {closure@ostd/src/mm/heap/slot.rs:87:42: 87:45}>(move _20, _15, ZeroSized: {closure@ostd/src/mm/heap/slot.rs:87:42: 87:45}) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_20);\n        _18 = core::result::Result::<mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>, error::Error>::map_err::<core::alloc::AllocError, {closure@ostd/src/mm/heap/slot.rs:88:22: 88:25}>(move _19, ZeroSized: {closure@ostd/src/mm/heap/slot.rs:88:22: 88:25}) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_19);\n        _17 = <core::result::Result<mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>, core::alloc::AllocError> as core::ops::Try>::branch(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        _24 = discriminant(_17);\n        switchInt(move _24) -> [0: bb11, 1: bb12, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _25 = move ((_17 as variant#0).0: mm::frame::segment::Segment<mm::heap::slot::LargeAllocFrameMeta>);\n        StorageDead(_23);\n        StorageDead(_21);\n        StorageDead(_17);\n        StorageLive(_26);\n        _26 = mm::frame::segment::Segment::<mm::heap::slot::LargeAllocFrameMeta>::into_raw(_25) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _0 = <core::result::Result<mm::heap::slot::HeapSlot, core::alloc::AllocError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::alloc::AllocError>>>::from_residual(core::result::Result::<core::convert::Infallible, core::alloc::AllocError>::Err(core::alloc::AllocError)) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_23);\n        StorageDead(_21);\n        StorageDead(_17);\n        goto -> bb18;\n    }\n    bb14: {\n        StorageLive(_28);\n        _28 = (_26.0: usize);\n        _27 = mm::kspace::paddr_to_vaddr(move _28) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _27 as *mut u8;\n        _31 = core::ptr::NonNull::<u8>::new(move _32) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_32);\n        _30 = core::option::Option::<core::ptr::NonNull<u8>>::unwrap(move _31) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_31);\n        StorageLive(_33);\n        _33 = mm::heap::slot::SlotInfo::LargeSlot(_1);\n        _29 = HeapSlot(move _30, move _33);\n        StorageDead(_33);\n        StorageDead(_30);\n        _0 = core::result::Result::Ok(move _29);\n        StorageDead(_29);\n        StorageDead(_26);\n        goto -> bb18;\n    }\n    bb18: {\n        return;\n    }\n}\n",
  "doc": " Allocates a large slot.\n\n This function allocates in units of [`PAGE_SIZE`] bytes.\n\n This function returns an error if the frame allocation fails.\n\n # Panics\n\n This function panics if the size is not a multiple of [`PAGE_SIZE`].\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}