{
  "name": "mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::alloc",
  "safe": true,
  "callees": {
    "mm::page_table::node::PageTablePageMeta::<C>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::page_table::node::PageTablePageMeta": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_frame_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a single frame with additional metadata.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::Frame": "Constructor"
      }
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "mm::page_table::PageTableEntryTrait::new_absent": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a PTE that points to nothing.\n\n Note that currently the implementation requires a zeroed PTE to be an absent PTE.\n",
      "adt": {}
    },
    "mm::page_table::PageTableEntryTrait::as_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the PTE into a raw `usize` value.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::page_table::node::PageTablePageMeta": [
      "Plain"
    ],
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "mm::frame::Frame": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::alloc"
  },
  "span": "ostd/src/mm/page_table/node/mod.rs:70:5: 80:6",
  "src": "pub(super) fn alloc(level: PagingLevel) -> Self {\n        let meta = PageTablePageMeta::new(level);\n        let frame = FrameAllocOptions::new()\n            .zeroed(true)\n            .alloc_frame_with(meta)\n            .expect(\"Failed to allocate a page table node\");\n        // The allocated frame is zeroed. Make sure zero is absent PTE.\n        debug_assert_eq!(C::E::new_absent().as_usize(), 0);\n\n        frame\n    }",
  "mir": "fn mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::alloc(_1: u8) -> mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>> {\n    let mut _0: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    let  _2: mm::page_table::node::PageTablePageMeta<C>;\n    let mut _3: core::result::Result<mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>, error::Error>;\n    let mut _4: &mm::frame::allocator::FrameAllocOptions;\n    let  _5: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _6: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _7: mm::frame::allocator::FrameAllocOptions;\n    let mut _8: &str;\n    let mut _9: (&usize, &usize);\n    let mut _10: &usize;\n    let  _11: usize;\n    let mut _12: <C as mm::page_table::PageTableConfig>::E;\n    let mut _13: &usize;\n    let  _14: &usize;\n    let  _15: &usize;\n    let mut _16: bool;\n    let mut _17: usize;\n    let mut _18: usize;\n    let  _19: core::panicking::AssertKind;\n    let  _20: !;\n    let mut _21: core::option::Option<core::fmt::Arguments<'_>>;\n    debug level => _1;\n    debug meta => _2;\n    debug frame => _0;\n    debug left_val => _14;\n    debug right_val => _15;\n    debug kind => _19;\n    bb0: {\n        _2 = mm::page_table::node::PageTablePageMeta::<C>::new(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = &mut _7;\n        _5 = mm::frame::allocator::FrameAllocOptions::zeroed(move _6, true) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = &(*_5);\n        StorageDead(_6);\n        _3 = mm::frame::allocator::FrameAllocOptions::alloc_frame_with::<mm::page_table::node::PageTablePageMeta<C>>(move _4, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageLive(_8);\n        _8 = \"Failed to allocate a page table node\";\n        _0 = core::result::Result::<mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>, error::Error>::expect(move _3, move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_3);\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = <<C as mm::page_table::PageTableConfig>::E as mm::page_table::PageTableEntryTrait>::new_absent() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = <<C as mm::page_table::PageTableConfig>::E as mm::page_table::PageTableEntryTrait>::as_usize(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _10 = &_11;\n        StorageLive(_13);\n        _13 = mm::page_table::node::<impl mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>>::alloc::promoted[0];\n        _9 = (move _10, move _13);\n        StorageDead(_13);\n        StorageDead(_10);\n        _14 = (_9.0: &usize);\n        _15 = (_9.1: &usize);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (*_14);\n        StorageLive(_18);\n        _18 = (*_15);\n        _16 = Eq(move _17, move _18);\n        switchInt(move _16) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_11);\n        StorageDead(_9);\n        return;\n    }\n    bb9: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _19 = core::panicking::AssertKind::Eq;\n        StorageLive(_21);\n        _21 = core::option::Option::None;\n        _20 = core::panicking::assert_failed::<usize, usize>(_19, _14, _15, move _21) -> unwind unreachable;\n    }\n}\n",
  "doc": " Allocates a new empty page table node.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}