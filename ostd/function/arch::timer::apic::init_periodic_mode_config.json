{
  "name": "arch::timer::apic::init_periodic_mode_config",
  "safe": true,
  "callees": {
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "irq::top_half::IrqLine::alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates an available IRQ line.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "irq::top_half::IrqLine": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "irq::top_half::IrqLine::on_active": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Registers a callback that will be invoked when the IRQ is active.\n\n For each IRQ line, multiple callbacks may be registered.\n",
      "adt": {
        "irq::top_half::IrqLine": "MutableAsArgument"
      }
    },
    "arch::timer::apic::init_periodic_mode_config::pit_callback": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::timer::pit::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::timer::pit::enable_interrupt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables the interrupt line that is connected to the PIT.\n",
      "adt": {
        "arch::irq::chip::MappedIrqLine": "Constructor"
      }
    },
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "arch::kernel::apic::get_or_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the local APIC instance of the current CPU.\n\n The reference to the APIC instance will not outlive the given\n [`PinCurrentCpu`] guard and the APIC instance does not implement\n [`Sync`], so it is safe to assume that the APIC instance belongs\n to the current CPU. Note that interrupts are not disabled, so the\n APIC instance may be accessed concurrently by interrupt handlers.\n\n At the first time the function is called, the local APIC instance\n is initialized and enabled if it was not enabled beforehand.\n\n # Examples\n\n ```rust\n use ostd::{\n     arch::x86::kernel::apic,\n     task::disable_preempt,\n };\n\n let preempt_guard = disable_preempt();\n let apic = apic::get_or_init(&preempt_guard as _);\n\n let ticks = apic.timer_current_count();\n apic.set_timer_init_count(0);\n ```\n",
      "adt": {}
    },
    "arch::kernel::apic::ApicTimer::set_timer_div_config": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets timer divide config register.\n",
      "adt": {}
    },
    "arch::kernel::apic::ApicTimer::set_timer_init_count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the initial timer count, the APIC timer will count down from this value.\n",
      "adt": {}
    },
    "arch::irq::ops::enable_local_and_halt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables local IRQs and halts the CPU to wait for interrupts.\n\n This method guarantees that no interrupts can occur in the middle. In other words, IRQs must\n either have been processed before this method is called, or they must wake the CPU up from the\n halting state.\n",
      "adt": {}
    },
    "arch::irq::ops::disable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "spin::once::Once::<T, R>::is_completed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the value has been initialized.\n\n This is done using [`Acquire`](core::sync::atomic::Ordering::Acquire) ordering, and\n therefore it is safe to access the value directly via\n [`get_unchecked`](Self::get_unchecked) if this returns true.\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "irq::top_half::IrqLine": [
      "Plain",
      "MutRef"
    ],
    "arch::timer::pit::OperatingMode": [
      "Plain"
    ],
    "arch::irq::chip::MappedIrqLine": [
      "Plain"
    ],
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ],
    "arch::kernel::apic::DivideConfig": [
      "Plain"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::timer::apic::init_periodic_mode_config"
  },
  "span": "ostd/src/arch/x86/timer/apic.rs:104:1: 171:2",
  "src": "fn init_periodic_mode_config() {\n    info!(\"[Timer]: Enable APIC periodic mode\");\n\n    // Allocate IRQ\n    let mut irq = IrqLine::alloc().unwrap();\n    irq.on_active(pit_callback);\n\n    // Enable PIT\n    super::pit::init(OperatingMode::RateGenerator);\n    let irq = super::pit::enable_interrupt(irq);\n\n    // Set APIC timer count\n    let preempt_guard = disable_preempt();\n    let apic = apic::get_or_init(&preempt_guard as _);\n    apic.set_timer_div_config(DivideConfig::Divide64);\n    apic.set_timer_init_count(0xFFFF_FFFF);\n\n    // Wait until `CONFIG` is ready\n    loop {\n        crate::arch::irq::enable_local_and_halt();\n\n        // Disable local IRQs so they won't come after checking `CONFIG`\n        // but before halting the CPU.\n        crate::arch::irq::disable_local();\n\n        if CONFIG.is_completed() {\n            break;\n        }\n    }\n\n    // Disable PIT\n    drop(irq);\n\n    fn pit_callback(_trap_frame: &TrapFrame) {\n        static IN_TIME: AtomicU64 = AtomicU64::new(0);\n        static APIC_FIRST_COUNT: AtomicU64 = AtomicU64::new(0);\n        // Set a certain times of callbacks to calculate the frequency\n        // The number of callbacks needed to calculate the APIC timer frequency.\n        // This is set to 1/10th of the TIMER_FREQ to ensure enough samples for accurate calculation.\n        const CALLBACK_TIMES: u64 = TIMER_FREQ / 10;\n\n        let preempt_guard = disable_preempt();\n        let apic = apic::get_or_init(&preempt_guard as _);\n\n        let apic_current_count = 0xFFFF_FFFF - apic.timer_current_count();\n\n        if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || CONFIG.is_completed() {\n            if IN_TIME.load(Ordering::Relaxed) == 0 {\n                APIC_FIRST_COUNT.store(apic_current_count, Ordering::Relaxed);\n            }\n            IN_TIME.fetch_add(1, Ordering::Relaxed);\n            return;\n        }\n\n        // Stop APIC Timer\n        apic.set_timer_init_count(0);\n\n        let apic_first_count = APIC_FIRST_COUNT.load(Ordering::Relaxed);\n        let apic_init_count = (apic_current_count - apic_first_count) / CALLBACK_TIMES;\n        info!(\n            \"APIC timer: first {:#x}, current {:#x}, init {:#x}\",\n            apic_first_count, apic_current_count, apic_init_count,\n        );\n        CONFIG.call_once(|| Config::PeriodicMode {\n            init_count: apic_init_count,\n        });\n    }\n}",
  "mir": "fn arch::timer::apic::init_periodic_mode_config() -> () {\n    let mut _0: ();\n    let  _1: log::Level;\n    let mut _2: bool;\n    let mut _3: &log::Level;\n    let mut _4: &log::LevelFilter;\n    let mut _5: bool;\n    let mut _6: &log::Level;\n    let mut _7: &log::LevelFilter;\n    let  _8: log::LevelFilter;\n    let  _9: ();\n    let mut _10: core::fmt::Arguments<'_>;\n    let  _11: &(&str, &str, &core::panic::Location<'_>);\n    let  _12: (&str, &str, &core::panic::Location<'_>);\n    let mut _13: &str;\n    let  _14: &core::panic::Location<'_>;\n    let mut _15: irq::top_half::IrqLine;\n    let mut _16: core::result::Result<irq::top_half::IrqLine, error::Error>;\n    let  _17: ();\n    let mut _18: &mut irq::top_half::IrqLine;\n    let  _19: ();\n    let mut _20: arch::timer::pit::OperatingMode;\n    let  _21: arch::irq::chip::MappedIrqLine;\n    let mut _22: irq::top_half::IrqLine;\n    let  _23: task::preempt::guard::DisabledPreemptGuard;\n    let  _24: &dyn arch::kernel::apic::Apic;\n    let mut _25: &dyn cpu::id::current::PinCurrentCpu;\n    let  _26: &task::preempt::guard::DisabledPreemptGuard;\n    let  _27: ();\n    let mut _28: arch::kernel::apic::DivideConfig;\n    let  _29: ();\n    let  _30: ();\n    let  _31: ();\n    let mut _32: bool;\n    let mut _33: &spin::once::Once<arch::timer::apic::Config>;\n    let  _34: ();\n    debug lvl => _1;\n    debug irq => _15;\n    debug irq => _21;\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug apic => _24;\n    bb0: {\n        _1 = log::Level::Info;\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &_1;\n        StorageLive(_4);\n        _4 = arch::timer::apic::init_periodic_mode_config::promoted[0];\n        _2 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb10, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_1;\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = log::max_level() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = &_8;\n        _5 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _6, move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb9, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = core::fmt::Arguments::<'_>::from_str(\"[Timer]: Enable APIC periodic mode\") -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = \"ostd::arch::timer::apic\";\n        _14 = log::__private_api::loc() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = (move _13, \"ostd::arch::timer::apic\", _14);\n        StorageDead(_13);\n        _11 = &_12;\n        _9 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _10, _1, _11, ()) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_12);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_5);\n        StorageDead(_2);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = irq::top_half::IrqLine::alloc() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _15 = core::result::Result::<irq::top_half::IrqLine, error::Error>::unwrap(move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        StorageLive(_18);\n        _18 = &mut _15;\n        _17 = irq::top_half::IrqLine::on_active::<for<'a> fn(&'a arch::trap::TrapFrame) {arch::timer::apic::init_periodic_mode_config::pit_callback}>(move _18, arch::timer::apic::init_periodic_mode_config::pit_callback) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = arch::timer::pit::OperatingMode::RateGenerator;\n        _19 = arch::timer::pit::init(move _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = move _15;\n        _21 = arch::timer::pit::enable_interrupt(move _22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        _23 = task::preempt::guard::disable_preempt() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _26 = &_23;\n        _25 = _26 as &dyn cpu::id::current::PinCurrentCpu;\n        _24 = arch::kernel::apic::get_or_init(_25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_28);\n        _28 = arch::kernel::apic::DivideConfig::Divide64;\n        _27 = <dyn arch::kernel::apic::Apic as arch::kernel::apic::ApicTimer>::set_timer_div_config(_24, move _28) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_28);\n        _29 = <dyn arch::kernel::apic::Apic as arch::kernel::apic::ApicTimer>::set_timer_init_count(_24, 4294967295_u64) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        goto -> bb21;\n    }\n    bb21: {\n        _30 = arch::irq::ops::enable_local_and_halt() -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _31 = arch::irq::ops::disable_local() -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = {alloc538: &spin::once::Once<arch::timer::apic::Config>};\n        _32 = spin::once::Once::<arch::timer::apic::Config>::is_completed(move _33) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        switchInt(move _32) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_33);\n        StorageDead(_32);\n        _34 = core::mem::drop::<arch::irq::chip::MappedIrqLine>(_21) -> [return: bb27, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb21;\n    }\n    bb27: {\n        drop(_23) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_15);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}