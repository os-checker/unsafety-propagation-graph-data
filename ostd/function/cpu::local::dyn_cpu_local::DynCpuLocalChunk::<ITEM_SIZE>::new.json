{
  "name": "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::new",
  "safe": true,
  "callees": {
    "cpu::id::num_cpus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of CPUs.\n",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "core::num::<impl usize>::div_ceil": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n\n # Panics\n\n This function will panic if `rhs` is zero.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_segment_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a contiguous range of frames with additional metadata.\n\n The returned [`Segment`] contains at least one frame. The method returns\n an error if the number of frames is zero.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "bitvec::vec::BitVec::<T, O>::repeat": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new bit-vector by repeating a bit for the desired length.\n\n ## Examples\n\n ```rust\n use bitvec::prelude::*;\n\n let zeros = BitVec::<u8, Msb0>::repeat(false, 50);\n let ones = BitVec::<u16, Lsb0>::repeat(true, 50);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3337, kind: RigidTy(Adt(AdtDef(DefId { id: 3684, name: \"mm::frame::segment::Segment\" }), GenericArgs([Type(Ty { id: 3347, kind: RigidTy(Adt(AdtDef(DefId { id: 4665, name: \"cpu::local::dyn_cpu_local::DynCpuLocalMeta\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::frame::segment::Segment": [
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "Plain"
    ],
    "bitvec::vec::BitVec": [
      "Plain"
    ],
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk": [
      "Plain"
    ]
  },
  "path": 1676,
  "span": "ostd/src/cpu/local/dyn_cpu_local.rs:132:5: 145:6",
  "src": "pub fn new() -> Result<Self> {\n        let total_chunk_size = CHUNK_SIZE * num_cpus();\n        let segment = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_segment_with(total_chunk_size.div_ceil(PAGE_SIZE), |_| DynCpuLocalMeta)?;\n\n        let num_items = CHUNK_SIZE / ITEM_SIZE;\n        const { assert!(CHUNK_SIZE.is_multiple_of(ITEM_SIZE)) };\n\n        Ok(Self {\n            segment: ManuallyDrop::new(segment),\n            bitmap: bitvec![0; num_items],\n        })\n    }",
  "mir": "fn cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::new() -> core::result::Result<cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>, error::Error> {\n    let mut _0: core::result::Result<cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>, error::Error>;\n    let  _1: usize;\n    let mut _2: usize;\n    let mut _3: (usize, bool);\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>>;\n    let mut _5: core::result::Result<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>, error::Error>;\n    let mut _6: &mm::frame::allocator::FrameAllocOptions;\n    let  _7: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _8: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _9: mm::frame::allocator::FrameAllocOptions;\n    let mut _10: usize;\n    let mut _11: isize;\n    let  _12: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _13: mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>;\n    let  _14: usize;\n    let mut _15: bool;\n    let mut _16: cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>;\n    let mut _17: core::mem::ManuallyDrop<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>>;\n    let mut _18: bitvec::vec::BitVec;\n    let mut _19: bool;\n    debug total_chunk_size => _1;\n    debug segment => _13;\n    debug residual => _12;\n    debug val => _13;\n    debug num_items => _14;\n    bb0: {\n        StorageLive(_2);\n        _2 = cpu::id::num_cpus() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = CheckedMul(cpu::local::dyn_cpu_local::CHUNK_SIZE, _2);\n        assert(!move (_3.1: bool), \"attempt to compute `{} * {}`, which would overflow\", cpu::local::dyn_cpu_local::CHUNK_SIZE, move _2) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _1 = move (_3.0: usize);\n        StorageDead(_2);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &mut _9;\n        _7 = mm::frame::allocator::FrameAllocOptions::zeroed(move _8, false) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = &(*_7);\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = core::num::<impl usize>::div_ceil(_1, mm::PAGE_SIZE) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _5 = mm::frame::allocator::FrameAllocOptions::alloc_segment_with::<cpu::local::dyn_cpu_local::DynCpuLocalMeta, {closure@ostd/src/cpu/local/dyn_cpu_local.rs:136:71: 136:74}>(move _6, move _10, ZeroSized: {closure@ostd/src/cpu/local/dyn_cpu_local.rs:136:71: 136:74}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageDead(_6);\n        _4 = <core::result::Result<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>, error::Error> as core::ops::Try>::branch(move _5) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_5);\n        _11 = discriminant(_4);\n        switchInt(move _11) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _13 = move ((_4 as variant#0).0: mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>);\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageDead(_4);\n        _15 = Eq(ITEM_SIZE, 0_usize);\n        assert(!move _15, \"attempt to divide `{}` by zero\", cpu::local::dyn_cpu_local::CHUNK_SIZE) -> [success: bb12, unwind unreachable];\n    }\n    bb10: {\n        _12 = ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_12) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb15;\n    }\n    bb12: {\n        _14 = Div(cpu::local::dyn_cpu_local::CHUNK_SIZE, ITEM_SIZE);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = core::mem::ManuallyDrop::<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>>::new(_13) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = Ne(0_i32, 0_i32);\n        _18 = bitvec::vec::BitVec::repeat(move _19, _14) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_19);\n        _16 = DynCpuLocalChunk(move _17, move _18);\n        StorageDead(_18);\n        StorageDead(_17);\n        _0 = core::result::Result::Ok(move _16);\n        StorageDead(_16);\n        goto -> bb15;\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": " Creates a new dynamically-allocated CPU-local chunk.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}