{
  "name": "arch::iommu::registers::capability::Capability::fault_recording_register_offset",
  "safe": true,
  "callees": {},
  "adts": {
    "arch::iommu::registers::capability::Capability": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::iommu::registers::capability::Capability::fault_recording_register_offset"
  },
  "span": "ostd/src/arch/x86/iommu/registers/capability.rs:66:5: 69:6",
  "src": "pub const fn fault_recording_register_offset(&self) -> u64 {\n        const FRO_MASK: u64 = 0x3FF << 24;\n        (self.0 & FRO_MASK) >> 24\n    }",
  "mir": "fn arch::iommu::registers::capability::Capability::fault_recording_register_offset(_1: &arch::iommu::registers::capability::Capability) -> u64 {\n    let mut _0: u64;\n    let mut _2: u64;\n    let mut _3: u64;\n    let mut _4: u32;\n    let mut _5: bool;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).0: u64);\n        _2 = BitAnd(move _3, arch::iommu::registers::capability::Capability::fault_recording_register_offset::FRO_MASK);\n        StorageDead(_3);\n        _4 = 24_i32 as u32;\n        _5 = Lt(move _4, 64_u32);\n        assert(move _5, \"attempt to shift right by `{}`, which would overflow\", 24_i32) -> [success: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Shr(move _2, 24_i32);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Fault-recording Register offset, specifies the offset of the first fault recording\n register relative to the register base address of this remapping hardware unit.\n\n If the register base address is X, and the value reported in this field\n is Y, the address for the first fault recording register is calculated as X+(16*Y).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}