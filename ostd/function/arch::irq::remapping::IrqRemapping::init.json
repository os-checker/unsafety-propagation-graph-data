{
  "name": "arch::irq::remapping::IrqRemapping::init",
  "safe": true,
  "callees": {
    "arch::iommu::interrupt_remapping::has_interrupt_remapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "arch::irq::remapping::IrqRemapping": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "arch::iommu::interrupt_remapping::IrtEntryHandle": [
      "Ref"
    ]
  },
  "path": 1161,
  "span": "ostd/src/arch/x86/irq/remapping.rs:20:5: 31:6",
  "src": "pub(crate) fn init(&self, irq_num: u8) {\n        if !has_interrupt_remapping() {\n            return;\n        }\n\n        self.entry.call_once(|| {\n            // Allocate and enable the IRT entry.\n            let handle = alloc_irt_entry().unwrap();\n            handle.enable(irq_num as u32);\n            handle\n        });\n    }",
  "mir": "fn arch::irq::remapping::IrqRemapping::init(_1: &arch::irq::remapping::IrqRemapping, _2: u8) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let  _4: &arch::iommu::interrupt_remapping::IrtEntryHandle;\n    let mut _5: &spin::once::Once<arch::iommu::interrupt_remapping::IrtEntryHandle>;\n    let mut _6: {closure@ostd/src/arch/x86/irq/remapping.rs:25:30: 25:32};\n    let mut _7: &u8;\n    debug self => _1;\n    debug irq_num => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = arch::iommu::interrupt_remapping::has_interrupt_remapping() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb2, otherwise: bb3];\n    }\n    bb2: {\n        StorageDead(_3);\n        goto -> bb5;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: spin::once::Once<arch::iommu::interrupt_remapping::IrtEntryHandle>);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_2;\n        _6 = {closure@ostd/src/arch/x86/irq/remapping.rs:25:30: 25:32}(move _7);\n        StorageDead(_7);\n        _4 = spin::once::Once::<arch::iommu::interrupt_remapping::IrtEntryHandle>::call_once::<{closure@ostd/src/arch/x86/irq/remapping.rs:25:30: 25:32}>(move _5, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb5;\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": " Initializes the remapping entry for the specific IRQ number.\n\n This will do nothing if the entry is already initialized or interrupt\n remapping is disabled or not supported by the architecture.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}