{
  "name": "arch::irq::ops::enable_local",
  "safe": true,
  "callees": {
    "x86_64::instructions::interrupts::enable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enable interrupts.\n\n This is a wrapper around the `sti` instruction.\n",
      "adt": {}
    },
    "x86_64::instructions::nop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the `nop` instructions, which performs no operation (i.e. does nothing).\n\n This operation is useful to work around the LLVM bug that endless loops are illegally\n optimized away (see [the issue](https://github.com/rust-lang/rust/issues/28728)). By invoking this\n instruction (which is marked as volatile), the compiler should no longer optimize the\n endless loop away.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "ostd::arch::irq::ops::enable_local"
  },
  "span": "ostd/src/arch/x86/irq/ops.rs:9:1: 15:2",
  "src": "pub(crate) fn enable_local() {\n    x86_64::instructions::interrupts::enable();\n    // When emulated with QEMU, interrupts may not be delivered if a STI instruction is immediately\n    // followed by a RET instruction. It is a BUG of QEMU, see the following patch for details.\n    // https://lore.kernel.org/qemu-devel/20231210190147.129734-2-lrh2000@pku.edu.cn/\n    x86_64::instructions::nop();\n}",
  "mir": "fn arch::irq::ops::enable_local() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let  _2: ();\n    bb0: {\n        _1 = x86_64::instructions::interrupts::enable() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = x86_64::instructions::nop() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}