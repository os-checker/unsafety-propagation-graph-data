{
  "name": "arch::timer::apic::init_deadline_mode_config",
  "safe": true,
  "callees": {
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::tsc_freq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the frequency of TSC. The unit is Hz.\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "arch::timer::apic::Config": [
      "Ref"
    ]
  },
  "path": 1501,
  "span": "ostd/src/arch/x86/timer/apic.rs:97:1: 102:2",
  "src": "fn init_deadline_mode_config() {\n    info!(\"[Timer]: Enable APIC TSC deadline mode\");\n\n    let tsc_interval = tsc_freq() / TIMER_FREQ;\n    CONFIG.call_once(|| Config::DeadlineMode { tsc_interval });\n}",
  "mir": "fn arch::timer::apic::init_deadline_mode_config() -> () {\n    let mut _0: ();\n    let  _1: log::Level;\n    let mut _2: bool;\n    let mut _3: &log::Level;\n    let mut _4: &log::LevelFilter;\n    let mut _5: bool;\n    let mut _6: &log::Level;\n    let mut _7: &log::LevelFilter;\n    let  _8: log::LevelFilter;\n    let  _9: ();\n    let mut _10: core::fmt::Arguments<'_>;\n    let  _11: &(&str, &str, &core::panic::Location<'_>);\n    let  _12: (&str, &str, &core::panic::Location<'_>);\n    let mut _13: &str;\n    let  _14: &core::panic::Location<'_>;\n    let  _15: u64;\n    let mut _16: u64;\n    let mut _17: bool;\n    let  _18: &arch::timer::apic::Config;\n    let mut _19: &spin::once::Once<arch::timer::apic::Config>;\n    let mut _20: {closure@ostd/src/arch/x86/timer/apic.rs:101:22: 101:24};\n    let mut _21: &u64;\n    debug lvl => _1;\n    debug tsc_interval => _15;\n    bb0: {\n        _1 = log::Level::Info;\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &_1;\n        StorageLive(_4);\n        _4 = arch::timer::apic::init_deadline_mode_config::promoted[0];\n        _2 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb10, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_1;\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = log::max_level() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = &_8;\n        _5 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _6, move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb9, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = core::fmt::Arguments::<'_>::from_str(\"[Timer]: Enable APIC TSC deadline mode\") -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = \"ostd::arch::timer::apic\";\n        _14 = log::__private_api::loc() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = (move _13, \"ostd::arch::timer::apic\", _14);\n        StorageDead(_13);\n        _11 = &_12;\n        _9 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _10, _1, _11, ()) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_12);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_5);\n        StorageDead(_2);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = arch::tsc_freq() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _17 = Eq(timer::TIMER_FREQ, 0_u64);\n        assert(!move _17, \"attempt to divide `{}` by zero\", _16) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _15 = Div(move _16, timer::TIMER_FREQ);\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = {alloc538: &spin::once::Once<arch::timer::apic::Config>};\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_15;\n        _20 = {closure@ostd/src/arch/x86/timer/apic.rs:101:22: 101:24}(move _21);\n        StorageDead(_21);\n        _18 = spin::once::Once::<arch::timer::apic::Config>::call_once::<{closure@ostd/src/arch/x86/timer/apic.rs:101:22: 101:24}>(move _19, move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_15);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}