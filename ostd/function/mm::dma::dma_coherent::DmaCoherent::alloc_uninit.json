{
  "name": "mm::dma::dma_coherent::DmaCoherent::alloc_uninit",
  "safe": true,
  "callees": {
    "mm::dma::util::cvm_need_private_protection": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_segment": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a contiguous range of untyped frames without metadata.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "mm::mem_obj::HasPaddrRange::paddr_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the physical address range of the memory object.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "mm::dma::util::alloc_kva": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::kspace::kvirt_area::KVirtArea": "Constructor"
      }
    },
    "mm::dma::util::prepare_dma": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prepares a physical address range for DMA mapping.\n\n If DMA remapping is enabled, the function allocates device addresses, maps\n the given physical address range to them, and returns the start device\n address.\n\n # Safety\n\n The provided physical address range must be untyped DMA memory that\n outlives the following [`unprepare_dma()`] call.\n",
      "adt": {
        "core::ops::Range": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1626, kind: RigidTy(Adt(AdtDef(DefId { id: 3684, name: \"mm::frame::segment::Segment\" }), GenericArgs([Type(Ty { id: 107, kind: RigidTy(Tuple([])) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4015, kind: RigidTy(Tuple([Ty { id: 3653, kind: RigidTy(Adt(AdtDef(DefId { id: 4769, name: \"mm::kspace::kvirt_area::KVirtArea\" }), GenericArgs([]))) }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }])) })])"
    ],
    "mm::frame::segment::Segment": [
      "Plain",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4017, kind: RigidTy(Adt(AdtDef(DefId { id: 4915, name: \"mm::dma::dma_coherent::Inner\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Ref"
    ],
    "mm::dma::dma_coherent::Inner": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4017, kind: RigidTy(Adt(AdtDef(DefId { id: 4915, name: \"mm::dma::dma_coherent::Inner\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "mm::kspace::kvirt_area::KVirtArea": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3653, kind: RigidTy(Adt(AdtDef(DefId { id: 4769, name: \"mm::kspace::kvirt_area::KVirtArea\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "mm::dma::dma_coherent::DmaCoherent": [
      "Plain"
    ]
  },
  "path": 1861,
  "span": "ostd/src/mm/dma/dma_coherent.rs:56:5: 80:6",
  "src": "pub fn alloc_uninit(nframes: usize, is_cache_coherent: bool) -> Result<Self, Error> {\n        let cvm = cvm_need_private_protection();\n\n        let (inner, paddr_range) = if is_cache_coherent && !cvm {\n            let segment = FrameAllocOptions::new()\n                .zeroed(false)\n                .alloc_segment(nframes)?;\n            let paddr_range = segment.paddr_range();\n\n            (Inner::Segment(segment), paddr_range)\n        } else {\n            let (kva, paddr) = alloc_kva(nframes, is_cache_coherent)?;\n\n            (Inner::Kva(kva, paddr), paddr..paddr + nframes * PAGE_SIZE)\n        };\n\n        // SAFETY: The physical address range is untyped DMA memory before `drop`.\n        let map_daddr = unsafe { prepare_dma(&paddr_range) };\n\n        Ok(Self {\n            inner,\n            map_daddr,\n            is_cache_coherent,\n        })\n    }",
  "mir": "fn mm::dma::dma_coherent::DmaCoherent::alloc_uninit(_1: usize, _2: bool) -> core::result::Result<mm::dma::dma_coherent::DmaCoherent, error::Error> {\n    let mut _0: core::result::Result<mm::dma::dma_coherent::DmaCoherent, error::Error>;\n    let  _3: bool;\n    let  _4: mm::dma::dma_coherent::Inner;\n    let  _5: core::ops::Range<usize>;\n    let mut _6: (mm::dma::dma_coherent::Inner, core::ops::Range<usize>);\n    let  _7: mm::frame::segment::Segment<()>;\n    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::segment::Segment<()>>;\n    let mut _9: core::result::Result<mm::frame::segment::Segment<()>, error::Error>;\n    let mut _10: &mm::frame::allocator::FrameAllocOptions;\n    let  _11: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _12: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _13: mm::frame::allocator::FrameAllocOptions;\n    let mut _14: isize;\n    let  _15: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _16: mm::frame::segment::Segment<()>;\n    let  _17: core::ops::Range<usize>;\n    let mut _18: &mm::frame::segment::Segment<()>;\n    let mut _19: mm::dma::dma_coherent::Inner;\n    let  _20: mm::kspace::kvirt_area::KVirtArea;\n    let  _21: usize;\n    let mut _22: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, (mm::kspace::kvirt_area::KVirtArea, usize)>;\n    let mut _23: core::result::Result<(mm::kspace::kvirt_area::KVirtArea, usize), error::Error>;\n    let mut _24: isize;\n    let  _25: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _26: (mm::kspace::kvirt_area::KVirtArea, usize);\n    let mut _27: mm::dma::dma_coherent::Inner;\n    let mut _28: core::ops::Range<usize>;\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: (usize, bool);\n    let mut _32: (usize, bool);\n    let  _33: core::option::Option<usize>;\n    let  _34: &core::ops::Range<usize>;\n    let mut _35: mm::dma::dma_coherent::DmaCoherent;\n    debug nframes => _1;\n    debug is_cache_coherent => _2;\n    debug cvm => _3;\n    debug inner => _4;\n    debug paddr_range => _5;\n    debug segment => _7;\n    debug residual => _15;\n    debug val => _16;\n    debug paddr_range => _17;\n    debug kva => _20;\n    debug paddr => _21;\n    debug residual => _25;\n    debug val => _26;\n    debug map_daddr => _33;\n    bb0: {\n        _3 = mm::dma::util::cvm_need_private_protection() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        switchInt(_2) -> [0: bb13, otherwise: bb2];\n    }\n    bb2: {\n        switchInt(_3) -> [0: bb3, otherwise: bb13];\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _12 = &mut _13;\n        _11 = mm::frame::allocator::FrameAllocOptions::zeroed(move _12, false) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = &(*_11);\n        StorageDead(_12);\n        _9 = mm::frame::allocator::FrameAllocOptions::alloc_segment(move _10, _1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        _8 = <core::result::Result<mm::frame::segment::Segment<()>, error::Error> as core::ops::Try>::branch(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        _14 = discriminant(_8);\n        switchInt(move _14) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageLive(_16);\n        _16 = move ((_8 as variant#0).0: mm::frame::segment::Segment<()>);\n        _7 = move _16;\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageLive(_18);\n        _18 = &_7;\n        _17 = <mm::frame::segment::Segment<()> as mm::mem_obj::HasPaddrRange>::paddr_range(move _18) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _15 = ((_8 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::dma::dma_coherent::DmaCoherent, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageDead(_8);\n        goto -> bb23;\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = mm::dma::dma_coherent::Inner::Segment(_7);\n        _6 = (move _19, _17);\n        StorageDead(_19);\n        goto -> bb21;\n    }\n    bb13: {\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = mm::dma::util::alloc_kva(_1, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _22 = <core::result::Result<(mm::kspace::kvirt_area::KVirtArea, usize), error::Error> as core::ops::Try>::branch(move _23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        _24 = discriminant(_22);\n        switchInt(move _24) -> [0: bb16, 1: bb17, otherwise: bb8];\n    }\n    bb16: {\n        _26 = move ((_22 as variant#0).0: (mm::kspace::kvirt_area::KVirtArea, usize));\n        _20 = (_26.0: mm::kspace::kvirt_area::KVirtArea);\n        _21 = (_26.1: usize);\n        StorageDead(_22);\n        StorageLive(_27);\n        _27 = mm::dma::dma_coherent::Inner::Kva(_20, _21);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _31 = CheckedMul(_1, mm::PAGE_SIZE);\n        assert(!move (_31.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _1, mm::PAGE_SIZE) -> [success: bb19, unwind unreachable];\n    }\n    bb17: {\n        _25 = ((_22 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::dma::dma_coherent::DmaCoherent, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_22);\n        goto -> bb23;\n    }\n    bb19: {\n        _30 = move (_31.0: usize);\n        _32 = CheckedAdd(_21, _30);\n        assert(!move (_32.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _21, move _30) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _29 = move (_32.0: usize);\n        StorageDead(_30);\n        _28 = Range(_21, move _29);\n        StorageDead(_29);\n        _6 = (move _27, move _28);\n        StorageDead(_28);\n        StorageDead(_27);\n        goto -> bb21;\n    }\n    bb21: {\n        _4 = move (_6.0: mm::dma::dma_coherent::Inner);\n        StorageLive(_5);\n        _5 = move (_6.1: core::ops::Range<usize>);\n        StorageDead(_6);\n        _34 = &_5;\n        _33 = mm::dma::util::prepare_dma(_34) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_35);\n        _35 = DmaCoherent(_4, _33, _2);\n        _0 = core::result::Result::Ok(move _35);\n        StorageDead(_35);\n        StorageDead(_5);\n        goto -> bb24;\n    }\n    bb23: {\n        StorageDead(_6);\n        goto -> bb24;\n    }\n    bb24: {\n        return;\n    }\n}\n",
  "doc": " Allocates a region of physical memory for coherent DMA access\n without initialization.\n\n This method is the same as [`DmaCoherent::alloc`]\n except that it skips zeroing the memory of newly-allocated DMA region.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}