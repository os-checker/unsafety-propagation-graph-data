{
  "name": "<cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the chunk is empty.\n",
      "adt": {
        "cpu::local::dyn_cpu_local::DynCpuLocalChunk": "ImmutableAsArgument"
      }
    },
    "core::mem::ManuallyDrop::<T>::drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Manually drops the contained value.\n\n This is exactly equivalent to calling [`ptr::drop_in_place`] with a\n pointer to the contained value. As such, unless the contained value is a\n packed struct, the destructor will be called in-place without moving the\n value, and thus can be used to safely drop [pinned] data.\n\n If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n\n # Safety\n\n This function runs the destructor of the contained value. Other than changes made by\n the destructor itself, the memory is left unchanged, and so as far as the compiler is\n concerned still holds a bit-pattern which is valid for the type `T`.\n\n However, this \"zombie\" value should not be exposed to safe code, and this function\n should not be called more than once. To use a value after it's been dropped, or drop\n a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n This is normally prevented by the type system, but users of `ManuallyDrop` must\n uphold those guarantees without assistance from the compiler.\n\n [pinned]: crate::pin\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "cpu::local::dyn_cpu_local::DynCpuLocalChunk": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::mem::ManuallyDrop": [
      "MutRef"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 1671,
  "span": "ostd/src/cpu/local/dyn_cpu_local.rs:241:5: 251:6",
  "src": "fn drop(&mut self) {\n        if self.is_empty() {\n            // SAFETY: The `segment` does not contain any CPU-local objects.\n            // It is the last time the `segment` is accessed, and it will be\n            // dropped only once.\n            unsafe { ManuallyDrop::drop(&mut self.segment) }\n        } else {\n            // Leak the `segment` and panic.\n            panic!(\"Dropping `DynCpuLocalChunk` while some CPU-local objects are still alive\");\n        }\n    }",
  "mir": "fn <cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE> as core::ops::Drop>::drop(_1: &mut cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: &cpu::local::dyn_cpu_local::DynCpuLocalChunk<ITEM_SIZE>;\n    let mut _4: &mut core::mem::ManuallyDrop<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>>;\n    let  _5: !;\n    let mut _6: core::fmt::Arguments<'_>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &(*_1);\n        _2 = cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::is_empty(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = &mut ((*_1).0: core::mem::ManuallyDrop<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>>);\n        _0 = core::mem::ManuallyDrop::<mm::frame::segment::Segment<cpu::local::dyn_cpu_local::DynCpuLocalMeta>>::drop(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        return;\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageLive(_6);\n        _6 = core::fmt::Arguments::<'_>::from_str(\"Dropping `DynCpuLocalChunk` while some CPU-local objects are still alive\") -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _5 = core::panicking::panic_fmt(move _6) -> unwind unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}