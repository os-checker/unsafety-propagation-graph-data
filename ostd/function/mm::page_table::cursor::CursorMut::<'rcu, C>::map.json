{
  "name": "mm::page_table::cursor::CursorMut::<'rcu, C>::map",
  "safe": false,
  "callees": {
    "mm::page_table::PageTableConfig::item_into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes the item and returns the physical address, the paging level,\n and the page property.\n\n The ownership of the item will be consumed, i.e., the item will be\n forgotten after this function is called.\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "mm::page_size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The page size at a given level.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::pop_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Goes up a level.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument"
      }
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::cur_entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument",
        "mm::page_table::node::entry::Entry": "Constructor"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::to_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a reference to the child.\n",
      "adt": {
        "mm::page_table::node::entry::Entry": "ImmutableAsArgument",
        "mm::page_table::node::child::ChildRef": "Constructor"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::split_if_mapped_huge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the entry to smaller pages if it maps to a huge page.\n\n If the entry does map to a huge page, it is split into smaller pages\n mapped by a child page table node. The new child page table node\n is returned.\n\n If the entry does not map to a untracked huge page, the method returns\n `None`.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "mm::page_table::node::entry::Entry": "MutableAsArgument",
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "mm::page_table::node::entry::Entry::<'a, 'rcu, C>::alloc_if_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a new child page table node and replaces the entry with it.\n\n If the old entry is not none, the operation will fail and return `None`.\n Otherwise, the lock guard of the new child page table node is returned.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "mm::page_table::node::entry::Entry": "MutableAsArgument",
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'a, mm::page_table::node::PageTablePageMeta<C>>>::make_guard_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new [`PageTableGuard`] without checking if the page table lock is held.\n\n # Safety\n\n This function must be called if this task logically holds the lock.\n\n Calling this function when a guard is already created is undefined behavior\n unless that guard was already forgotten.\n",
      "adt": {
        "mm::page_table::node::PageTableGuard": "Constructor"
      }
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::push_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Goes down a level to a child page table.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument",
        "mm::page_table::node::PageTableGuard": "ImmutableAsArgument"
      }
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "mm::page_table::cursor::CursorMut::<'rcu, C>::replace_cur_entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::page_table::cursor::CursorMut": "MutableAsArgument",
        "core::option::Option": "Constructor",
        "mm::page_table::cursor::PageTableFrag": "Constructor"
      }
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::move_forward": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Traverses forward to the end of [`Self::cur_va_range`].\n\n If reached the end of the current page table node, it (recursively)\n moves itself up to the next page of the parent page.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::page_table::cursor::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "mm::page_prop::PageProperty": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Field(2, Ty { id: 1097, kind: RigidTy(Adt(AdtDef(DefId { id: 3471, name: \"mm::page_prop::PageProperty\" }), GenericArgs([]))) })])"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5827, kind: RigidTy(Adt(AdtDef(DefId { id: 5332, name: \"mm::page_table::cursor::PageTableFrag\" }), GenericArgs([Type(Ty { id: 1116, kind: Param(ParamTy { index: 1, name: \"C\" }) })]))) })])"
    ],
    "mm::page_table::cursor::Cursor": [
      "MutRef"
    ],
    "mm::page_table::node::entry::Entry": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "mm::page_table::node::child::ChildRef": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 5457, kind: RigidTy(Adt(AdtDef(DefId { id: 5173, name: \"mm::frame::frame_ref::FrameRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 5461, kind: RigidTy(Adt(AdtDef(DefId { id: 5364, name: \"mm::page_table::node::PageTablePageMeta\" }), GenericArgs([Type(Ty { id: 1116, kind: Param(ParamTy { index: 1, name: \"C\" }) })]))) })]))) })])"
    ],
    "mm::frame::frame_ref::FrameRef": [
      "Plain"
    ],
    "mm::page_table::node::PageTableGuard": [
      "Plain"
    ],
    "mm::page_table::node::child::Child": [
      "Plain"
    ],
    "mm::page_table::cursor::PageTableFrag": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::page_table::cursor::CursorMut::<'rcu, C>::map"
  },
  "span": "ostd/src/mm/page_table/cursor/mod.rs:459:5: 504:6",
  "src": "pub unsafe fn map(&mut self, item: C::Item) -> Result<(), PageTableFrag<C>> {\n        assert!(self.0.va < self.0.barrier_va.end);\n        let (pa, level, prop) = C::item_into_raw(item);\n        assert!(level <= C::HIGHEST_TRANSLATION_LEVEL);\n        let size = page_size::<C>(level);\n        assert_eq!(self.0.va % size, 0);\n        let end = self.0.va + size;\n        assert!(end <= self.0.barrier_va.end);\n\n        let rcu_guard = self.0.rcu_guard;\n\n        // Adjust ourselves to the level of the item.\n        while self.0.level != level {\n            if self.0.level < level {\n                self.0.pop_level();\n                continue;\n            }\n            // We are at a higher level, go down.\n            let mut cur_entry = self.0.cur_entry();\n            match cur_entry.to_ref() {\n                ChildRef::PageTable(pt) => {\n                    // SAFETY: The `pt` must be locked and no other guards exist.\n                    let pt_guard = unsafe { pt.make_guard_unchecked(rcu_guard) };\n                    self.0.push_level(pt_guard);\n                }\n                ChildRef::None => {\n                    let child_guard = cur_entry.alloc_if_none(rcu_guard).unwrap();\n                    self.0.push_level(child_guard);\n                }\n                ChildRef::Frame(_, _, _) => {\n                    let split_child = cur_entry.split_if_mapped_huge(rcu_guard).unwrap();\n                    self.0.push_level(split_child);\n                }\n            }\n        }\n\n        let frag = self.replace_cur_entry(Child::Frame(pa, level, prop));\n\n        self.0.move_forward();\n\n        if let Some(frag) = frag {\n            Err(frag)\n        } else {\n            Ok(())\n        }\n    }",
  "mir": "fn mm::page_table::cursor::CursorMut::<'rcu, C>::map(_1: &mut mm::page_table::cursor::CursorMut<'_, C>, _2: <C as mm::page_table::PageTableConfig>::Item) -> core::result::Result<(), mm::page_table::cursor::PageTableFrag<C>> {\n    let mut _0: core::result::Result<(), mm::page_table::cursor::PageTableFrag<C>>;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: !;\n    let  _7: usize;\n    let  _8: u8;\n    let  _9: mm::page_prop::PageProperty;\n    let mut _10: (usize, u8, mm::page_prop::PageProperty);\n    let mut _11: bool;\n    let mut _12: !;\n    let  _13: usize;\n    let mut _14: (&usize, &usize);\n    let mut _15: &usize;\n    let  _16: usize;\n    let mut _17: usize;\n    let mut _18: bool;\n    let mut _19: &usize;\n    let  _20: &usize;\n    let  _21: &usize;\n    let mut _22: bool;\n    let mut _23: usize;\n    let mut _24: usize;\n    let  _25: core::panicking::AssertKind;\n    let  _26: !;\n    let mut _27: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _28: usize;\n    let mut _29: usize;\n    let mut _30: (usize, bool);\n    let mut _31: bool;\n    let mut _32: usize;\n    let mut _33: !;\n    let  _34: &dyn task::atomic_mode::InAtomicMode;\n    let mut _35: bool;\n    let mut _36: u8;\n    let mut _37: bool;\n    let mut _38: u8;\n    let  _39: ();\n    let mut _40: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let mut _41: mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _42: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let mut _43: mm::page_table::node::child::ChildRef<'_, C>;\n    let mut _44: &mm::page_table::node::entry::Entry<'_, '_, C>;\n    let mut _45: isize;\n    let  _46: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>;\n    let  _47: mm::page_table::node::PageTableGuard<'_, C>;\n    let  _48: ();\n    let mut _49: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let  _50: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _51: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _52: &mut mm::page_table::node::entry::Entry<'_, '_, C>;\n    let  _53: ();\n    let mut _54: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let  _55: mm::page_table::node::PageTableGuard<'_, C>;\n    let mut _56: core::option::Option<mm::page_table::node::PageTableGuard<'_, C>>;\n    let mut _57: &mut mm::page_table::node::entry::Entry<'_, '_, C>;\n    let  _58: ();\n    let mut _59: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let  _60: core::option::Option<mm::page_table::cursor::PageTableFrag<C>>;\n    let mut _61: mm::page_table::node::child::Child<C>;\n    let  _62: ();\n    let mut _63: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let mut _64: isize;\n    let  _65: mm::page_table::cursor::PageTableFrag<C>;\n    debug self => _1;\n    debug item => _2;\n    debug pa => _7;\n    debug level => _8;\n    debug prop => _9;\n    debug size => _13;\n    debug left_val => _20;\n    debug right_val => _21;\n    debug kind => _25;\n    debug end => _28;\n    debug rcu_guard => _34;\n    debug cur_entry => _41;\n    debug pt => _46;\n    debug pt_guard => _47;\n    debug child_guard => _50;\n    debug split_child => _55;\n    debug frag => _60;\n    debug frag => _65;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = (((*_1).0: mm::page_table::cursor::Cursor<'_, C>).4: usize);\n        StorageLive(_5);\n        _5 = ((((*_1).0: mm::page_table::cursor::Cursor<'_, C>).5: core::ops::Range<usize>).1: usize);\n        _3 = Lt(move _4, move _5);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_10);\n        _10 = <C as mm::page_table::PageTableConfig>::item_into_raw(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _6 = core::panicking::panic(\"assertion failed: self.0.va < self.0.barrier_va.end\") -> unwind unreachable;\n    }\n    bb3: {\n        _7 = (_10.0: usize);\n        _8 = (_10.1: u8);\n        _9 = (_10.2: mm::page_prop::PageProperty);\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = Le(_8, <C as mm::PagingConstsTrait>::HIGHEST_TRANSLATION_LEVEL);\n        switchInt(move _11) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_11);\n        _13 = mm::page_size::<C>(_8) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        _12 = core::panicking::panic(\"assertion failed: level <= C::HIGHEST_TRANSLATION_LEVEL\") -> unwind unreachable;\n    }\n    bb6: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = (((*_1).0: mm::page_table::cursor::Cursor<'_, C>).4: usize);\n        _18 = Eq(_13, 0_usize);\n        assert(!move _18, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _17) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _16 = Rem(move _17, _13);\n        StorageDead(_17);\n        _15 = &_16;\n        StorageLive(_19);\n        _19 = mm::page_table::cursor::CursorMut::<'_, C>::map::promoted[0];\n        _14 = (move _15, move _19);\n        StorageDead(_19);\n        StorageDead(_15);\n        _20 = (_14.0: &usize);\n        _21 = (_14.1: &usize);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = (*_20);\n        StorageLive(_24);\n        _24 = (*_21);\n        _22 = Eq(move _23, move _24);\n        switchInt(move _22) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageLive(_29);\n        _29 = (((*_1).0: mm::page_table::cursor::Cursor<'_, C>).4: usize);\n        _30 = CheckedAdd(_29, _13);\n        assert(!move (_30.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _29, _13) -> [success: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_24);\n        StorageDead(_23);\n        _25 = core::panicking::AssertKind::Eq;\n        StorageLive(_27);\n        _27 = core::option::Option::None;\n        _26 = core::panicking::assert_failed::<usize, usize>(_25, _20, _21, move _27) -> unwind unreachable;\n    }\n    bb10: {\n        _28 = move (_30.0: usize);\n        StorageDead(_29);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = ((((*_1).0: mm::page_table::cursor::Cursor<'_, C>).5: core::ops::Range<usize>).1: usize);\n        _31 = Le(_28, move _32);\n        switchInt(move _31) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _34 = (((*_1).0: mm::page_table::cursor::Cursor<'_, C>).1: &dyn task::atomic_mode::InAtomicMode);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_32);\n        _33 = core::panicking::panic(\"assertion failed: end <= self.0.barrier_va.end\") -> unwind unreachable;\n    }\n    bb13: {\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = (((*_1).0: mm::page_table::cursor::Cursor<'_, C>).2: u8);\n        _35 = Ne(move _36, _8);\n        switchInt(move _35) -> [0: bb33, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = (((*_1).0: mm::page_table::cursor::Cursor<'_, C>).2: u8);\n        _37 = Lt(move _38, _8);\n        switchInt(move _37) -> [0: bb17, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_38);\n        StorageLive(_40);\n        _40 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _39 = mm::page_table::cursor::Cursor::<'_, C>::pop_level(move _40) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_40);\n        StorageDead(_37);\n        StorageDead(_35);\n        goto -> bb13;\n    }\n    bb17: {\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _41 = mm::page_table::cursor::Cursor::<'_, C>::cur_entry(move _42) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &_41;\n        _43 = mm::page_table::node::entry::Entry::<'_, '_, C>::to_ref(move _44) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_44);\n        _45 = discriminant(_43);\n        switchInt(move _45) -> [0: bb23, 1: bb21, 2: bb22, otherwise: bb20];\n    }\n    bb20: {\n        unreachable;\n    }\n    bb21: {\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &mut _41;\n        _56 = mm::page_table::node::entry::Entry::<'_, '_, C>::split_if_mapped_huge(move _57, _34) -> [return: bb29, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &mut _41;\n        _51 = mm::page_table::node::entry::Entry::<'_, '_, C>::alloc_if_none(move _52, _34) -> [return: bb26, unwind unreachable];\n    }\n    bb23: {\n        _46 = move ((_43 as variant#0).0: mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>);\n        _47 = mm::page_table::node::<impl mm::frame::frame_ref::FrameRef<'_, mm::page_table::node::PageTablePageMeta<C>>>::make_guard_unchecked::<'_>(_46, _34) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageLive(_49);\n        _49 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _48 = mm::page_table::cursor::Cursor::<'_, C>::push_level(move _49, _47) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_49);\n        goto -> bb32;\n    }\n    bb26: {\n        StorageDead(_52);\n        _50 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::unwrap(move _51) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_51);\n        StorageLive(_54);\n        _54 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _53 = mm::page_table::cursor::Cursor::<'_, C>::push_level(move _54, _50) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_54);\n        goto -> bb32;\n    }\n    bb29: {\n        StorageDead(_57);\n        _55 = core::option::Option::<mm::page_table::node::PageTableGuard<'_, C>>::unwrap(move _56) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_56);\n        StorageLive(_59);\n        _59 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _58 = mm::page_table::cursor::Cursor::<'_, C>::push_level(move _59, _55) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_59);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_43);\n        StorageDead(_41);\n        StorageDead(_35);\n        goto -> bb13;\n    }\n    bb33: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = mm::page_table::node::child::Child::Frame(_7, _8, _9);\n        _60 = mm::page_table::cursor::CursorMut::<'_, C>::replace_cur_entry(_1, move _61) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_61);\n        StorageLive(_63);\n        _63 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _62 = mm::page_table::cursor::Cursor::<'_, C>::move_forward(move _63) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_63);\n        _64 = discriminant(_60);\n        switchInt(move _64) -> [1: bb36, 0: bb37, otherwise: bb20];\n    }\n    bb36: {\n        _65 = move ((_60 as variant#1).0: mm::page_table::cursor::PageTableFrag<C>);\n        _0 = core::result::Result::Err(_65);\n        goto -> bb38;\n    }\n    bb37: {\n        _0 = core::result::Result::Ok(());\n        goto -> bb38;\n    }\n    bb38: {\n        StorageDead(_60);\n        return;\n    }\n}\n",
  "doc": " Maps the item starting from the current address to a physical address range.\n\n If the current address has already mapped pages, it will do a re-map,\n taking out the old physical address and replacing it with the new one.\n This function will return [`Err`] with a [`PageTableFrag`], the not\n mapped item. The caller should drop it after TLB coherence.\n\n If there is no mapped pages in the specified virtual address range,\n the function will return [`None`].\n\n # Panics\n\n This function will panic if\n  - the virtual address range to be mapped is out of the locked range;\n  - the current virtual address is not aligned to the page size of the\n    item to be mapped;\n\n # Safety\n\n The caller should ensure that\n  - the range being mapped does not affect kernel's memory safety;\n  - the physical address to be mapped is valid and safe to use;\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}