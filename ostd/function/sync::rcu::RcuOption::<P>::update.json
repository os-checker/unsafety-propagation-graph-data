{
  "name": "sync::rcu::RcuOption::<P>::update",
  "safe": true,
  "callees": {
    "sync::rcu::RcuInner::<P>::update": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::rcu::RcuInner": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sync::rcu::RcuInner": [
      "Ref"
    ],
    "sync::rcu::RcuOption": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::sync::rcu::RcuOption::<P>::update"
  },
  "span": "ostd/src/sync/rcu/mod.rs:321:5: 323:6",
  "src": "pub fn update(&self, new_ptr: Option<P>) {\n        self.0.update(new_ptr);\n    }",
  "mir": "fn sync::rcu::RcuOption::<P>::update(_1: &sync::rcu::RcuOption<P>, _2: core::option::Option<P>) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: &sync::rcu::RcuInner<P>;\n    debug self => _1;\n    debug new_ptr => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &((*_1).0: sync::rcu::RcuInner<P>);\n        _3 = sync::rcu::RcuInner::<P>::update(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Replaces the current pointer with a null pointer.\n\n This function updates the pointer to the new pointer regardless of the\n original pointer. If the original pointer is not NULL, it will be\n dropped after the grace period.\n\n Oftentimes this function is not recommended unless you have\n synchronized writes with locks. Otherwise, you can use [`Self::read`]\n and then [`RcuOptionReadGuard::compare_exchange`] to update the pointer.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}