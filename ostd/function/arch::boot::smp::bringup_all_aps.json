{
  "name": "arch::boot::smp::bringup_all_aps",
  "safe": false,
  "callees": {
    "arch::boot::smp::copy_ap_boot_code": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller must ensure the memory region to be filled with AP boot code is valid to write.\n",
      "adt": {}
    },
    "arch::boot::smp::fill_boot_info_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n This function writes to the static mutable variable `__ap_boot_info_array_pointer`.\n The caller must ensure exclusive access to this variable.\n",
      "adt": {}
    },
    "arch::boot::smp::fill_boot_pt_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n This function writes to the static mutable variable `__boot_page_table_pointer`.\n The caller must ensure exclusive access to this variable.\n",
      "adt": {}
    },
    "tdx_guest::tdx_is_enabled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::boot::smp::wake_up_aps_via_mailbox": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wakes up all application processors via the ACPI multiprocessor mailbox structure.\n\n # Safety\n\n The safety preconditions are the same as [`send_boot_ipis`].\n",
      "adt": {}
    },
    "arch::boot::smp::send_boot_ipis": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sends IPIs to notify all application processors to boot.\n\n Follow the INIT-SIPI-SIPI IPI sequence.\n Here, we don't check whether there is an AP that failed to start,\n but send the second SIPI directly (checking whether each core is\n started successfully one by one will bring extra overhead). For\n APs that have been started, this signal will not bring any cost.\n\n # Safety\n\n The caller must ensure that all application processors can be\n safely booted by ensuring that:\n 1. We're in the boot context of the BSP and all APs have not yet\n    been booted.\n 2. We've properly prepared all the resources for the application\n    processors to boot successfully (e.g., each AP's page table\n    and stack).\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "ostd::arch::boot::smp::bringup_all_aps"
  },
  "span": "ostd/src/arch/x86/boot/smp.rs:117:1: 132:2",
  "src": "pub(crate) unsafe fn bringup_all_aps(info_ptr: *const PerApRawInfo, pt_ptr: Paddr, num_cpus: u32) {\n    // SAFETY: The code and data to boot AP is valid to write because\n    // there are no readers and we are the only writer at this point.\n    unsafe {\n        copy_ap_boot_code();\n        fill_boot_info_ptr(info_ptr);\n        fill_boot_pt_ptr(pt_ptr);\n    }\n\n    // SAFETY: We've properly prepared all the resources to boot APs.\n    if_tdx_enabled!({\n        unsafe { wake_up_aps_via_mailbox(num_cpus) };\n    } else {\n        unsafe { send_boot_ipis() };\n    });\n}",
  "mir": "fn arch::boot::smp::bringup_all_aps(_1: *const boot::smp::PerApRawInfo, _2: usize, _3: u32) -> () {\n    let mut _0: ();\n    let  _4: ();\n    let  _5: ();\n    let  _6: ();\n    let mut _7: bool;\n    let  _8: ();\n    let  _9: ();\n    debug info_ptr => _1;\n    debug pt_ptr => _2;\n    debug num_cpus => _3;\n    bb0: {\n        _4 = arch::boot::smp::copy_ap_boot_code() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = arch::boot::smp::fill_boot_info_ptr(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = arch::boot::smp::fill_boot_pt_ptr(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_7);\n        _7 = tdx_guest::tdx_is_enabled() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _7) -> [0: bb7, otherwise: bb5];\n    }\n    bb5: {\n        _8 = arch::boot::smp::wake_up_aps_via_mailbox(_3) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb8;\n    }\n    bb7: {\n        _9 = arch::boot::smp::send_boot_ipis() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": " Brings up all application processors.\n\n # Safety\n\n The caller must ensure that\n 1. we're in the boot context of the BSP,\n 2. all APs have not yet been booted, and\n 3. the arguments are valid to boot APs.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}