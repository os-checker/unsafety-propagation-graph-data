{
  "name": "sync::rcu::RcuOptionReadGuard::<'_, P>::compare_exchange",
  "safe": true,
  "callees": {
    "sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sync::rcu::RcuReadGuardInner": [
      "Plain"
    ],
    "sync::rcu::RcuOptionReadGuard": [
      "Unknown([Field(0, Ty { id: 6791, kind: RigidTy(Adt(AdtDef(DefId { id: 5763, name: \"sync::rcu::RcuReadGuardInner\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 443, kind: Param(ParamTy { index: 1, name: \"P\" }) })]))) })])",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::sync::rcu::RcuOptionReadGuard::<'_, P>::compare_exchange"
  },
  "span": "ostd/src/sync/rcu/mod.rs:406:5: 408:6",
  "src": "pub fn compare_exchange(self, new_ptr: Option<P>) -> Result<(), Option<P>> {\n        self.0.compare_exchange(new_ptr)\n    }",
  "mir": "fn sync::rcu::RcuOptionReadGuard::<'_, P>::compare_exchange(_1: sync::rcu::RcuOptionReadGuard<'_, P>, _2: core::option::Option<P>) -> core::result::Result<(), core::option::Option<P>> {\n    let mut _0: core::result::Result<(), core::option::Option<P>>;\n    let mut _3: sync::rcu::RcuReadGuardInner<'_, P>;\n    debug self => _1;\n    debug new_ptr => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = move (_1.0: sync::rcu::RcuReadGuardInner<'_, P>);\n        _0 = sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Tries to replace the already read pointer with a new pointer\n (or none).\n\n If another thread has updated the pointer after the read, this\n function will fail, and returns the given pointer back. Otherwise,\n it will replace the pointer with the new one and drop the old pointer\n after the grace period.\n\n If spinning on [`RcuOption::read`] and this function, it is recommended\n to relax the CPU or yield the task on failure. Otherwise contention\n will occur.\n\n This API does not help to avoid\n [the ABA problem](https://en.wikipedia.org/wiki/ABA_problem).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}