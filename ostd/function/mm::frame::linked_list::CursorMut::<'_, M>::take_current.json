{
  "name": "mm::frame::linked_list::CursorMut::<'_, M>::take_current",
  "safe": true,
  "callees": {
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the underlying `*mut` pointer.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x).expect(\"ptr is null!\");\n\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 0);\n\n unsafe { *ptr.as_ptr() += 2; }\n let x_value = unsafe { *ptr.as_ptr() };\n assert_eq!(x_value, 2);\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "mm::frame::meta::mapping::meta_to_frame": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a virtual address of the metadata slot to the physical address of the frame.\n",
      "adt": {}
    },
    "mm::frame::unique::UniqueFrame::<M>::from_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Restores a raw physical address back into a unique frame.\n\n # Safety\n\n The caller must ensure that the physical address is valid and points to\n a forgotten frame that was previously casted by [`Self::into_raw`].\n",
      "adt": {
        "mm::frame::unique::UniqueFrame": "Constructor"
      }
    },
    "mm::frame::unique::UniqueFrame::<M>::meta": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the metadata of this page.\n",
      "adt": {
        "mm::frame::unique::UniqueFrame": "ImmutableAsArgument"
      }
    },
    "mm::frame::unique::UniqueFrame::<M>::meta_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the mutable metadata of this page.\n",
      "adt": {
        "mm::frame::unique::UniqueFrame": "MutableAsArgument"
      }
    },
    "core::ptr::NonNull::<T>::as_mut": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a unique reference to the value. If the value may be uninitialized, [`as_uninit_mut`]\n must be used instead.\n\n For the shared counterpart see [`as_ref`].\n\n [`as_uninit_mut`]: NonNull::as_uninit_mut\n [`as_ref`]: NonNull::as_ref\n\n # Safety\n\n When calling this method, you have to ensure that\n the pointer is [convertible to a reference](crate::ptr#pointer-to-reference-conversion).\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let mut ptr = NonNull::new(&mut x).expect(\"null pointer\");\n\n let x_ref = unsafe { ptr.as_mut() };\n assert_eq!(*x_ref, 0);\n *x_ref += 2;\n assert_eq!(*x_ref, 2);\n ```\n\n [the module documentation]: crate::ptr#safety\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "mm::frame::unique::UniqueFrame::<M>::slot": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::frame::unique::UniqueFrame": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicU64::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "MutRef",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4413, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 4418, kind: RigidTy(Adt(AdtDef(DefId { id: 5035, name: \"mm::frame::linked_list::Link\" }), GenericArgs([Type(Ty { id: 4368, kind: Param(ParamTy { index: 1, name: \"M\" }) })]))) })]))) })])",
      "Ref",
      "Unknown([Field(0, Ty { id: 4444, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 4410, kind: RigidTy(Adt(AdtDef(DefId { id: 2756, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 4413, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 4418, kind: RigidTy(Adt(AdtDef(DefId { id: 5035, name: \"mm::frame::linked_list::Link\" }), GenericArgs([Type(Ty { id: 4368, kind: Param(ParamTy { index: 1, name: \"M\" }) })]))) })]))) })]))) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 4444, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 4410, kind: RigidTy(Adt(AdtDef(DefId { id: 2756, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 4413, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 4418, kind: RigidTy(Adt(AdtDef(DefId { id: 5035, name: \"mm::frame::linked_list::Link\" }), GenericArgs([Type(Ty { id: 4368, kind: Param(ParamTy { index: 1, name: \"M\" }) })]))) })]))) })]))) }, Not)) })])"
    ],
    "mm::frame::linked_list::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4413, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 4418, kind: RigidTy(Adt(AdtDef(DefId { id: 5035, name: \"mm::frame::linked_list::Link\" }), GenericArgs([Type(Ty { id: 4368, kind: Param(ParamTy { index: 1, name: \"M\" }) })]))) })]))) })])"
    ],
    "core::ptr::NonNull": [
      "Plain",
      "MutRef"
    ],
    "mm::frame::unique::UniqueFrame": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "mm::frame::linked_list::Link": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "mm::frame::linked_list::LinkedList": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "mm::frame::meta::MetaSlot": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": 1938,
  "span": "ostd/src/mm/frame/linked_list.rs:283:5: 326:6",
  "src": "pub fn take_current(&mut self) -> Option<UniqueFrame<Link<M>>> {\n        let current = self.current?;\n\n        let mut frame = {\n            let meta_ptr = current.as_ptr() as *mut MetaSlot;\n            let paddr = mapping::meta_to_frame::<PagingConsts>(meta_ptr as Vaddr);\n            // SAFETY: The frame was forgotten when inserted into the linked list.\n            unsafe { UniqueFrame::<Link<M>>::from_raw(paddr) }\n        };\n\n        let next_ptr = frame.meta().next;\n        if let Some(prev) = &mut frame.meta_mut().prev {\n            // SAFETY: We own the previous node by `&mut self` and the node is\n            // initialized.\n            let prev_mut = unsafe { prev.as_mut() };\n\n            debug_assert_eq!(prev_mut.next, Some(current));\n            prev_mut.next = next_ptr;\n        } else {\n            self.list.front = next_ptr;\n        }\n        let prev_ptr = frame.meta().prev;\n        if let Some(next) = &mut frame.meta_mut().next {\n            // SAFETY: We own the next node by `&mut self` and the node is\n            // initialized.\n            let next_mut = unsafe { next.as_mut() };\n\n            debug_assert_eq!(next_mut.prev, Some(current));\n            next_mut.prev = prev_ptr;\n            self.current = Some(NonNull::from(next_mut));\n        } else {\n            self.list.back = prev_ptr;\n            self.current = None;\n        }\n\n        frame.meta_mut().next = None;\n        frame.meta_mut().prev = None;\n\n        frame.slot().in_list.store(0, Ordering::Relaxed);\n\n        self.list.size -= 1;\n\n        Some(frame)\n    }",
  "mir": "fn mm::frame::linked_list::CursorMut::<'_, M>::take_current(_1: &mut mm::frame::linked_list::CursorMut<'_, M>) -> core::option::Option<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>> {\n    let mut _0: core::option::Option<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>>;\n    let mut _2: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _3: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _4: isize;\n    let  _5: core::ptr::NonNull<mm::frame::linked_list::Link<M>>;\n    let mut _6: mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let  _7: *mut mm::frame::meta::MetaSlot;\n    let mut _8: *mut mm::frame::linked_list::Link<M>;\n    let  _9: usize;\n    let mut _10: usize;\n    let  _11: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _12: &mm::frame::linked_list::Link<M>;\n    let mut _13: &mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _14: &mut core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _15: &mut mm::frame::linked_list::Link<M>;\n    let mut _16: &mut mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _17: isize;\n    let  _18: &mut core::ptr::NonNull<mm::frame::linked_list::Link<M>>;\n    let mut _19: &mut mm::frame::linked_list::Link<M>;\n    let mut _20: (&core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>, &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n    let mut _21: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _22: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let  _23: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let  _24: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let  _25: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _26: bool;\n    let  _27: core::panicking::AssertKind;\n    let  _28: !;\n    let mut _29: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _30: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _31: &mm::frame::linked_list::Link<M>;\n    let mut _32: &mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _33: &mut core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _34: &mut mm::frame::linked_list::Link<M>;\n    let mut _35: &mut mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _36: isize;\n    let  _37: &mut core::ptr::NonNull<mm::frame::linked_list::Link<M>>;\n    let mut _38: &mut mm::frame::linked_list::Link<M>;\n    let mut _39: (&core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>, &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n    let mut _40: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _41: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let  _42: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let  _43: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let  _44: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _45: bool;\n    let  _46: core::panicking::AssertKind;\n    let  _47: !;\n    let mut _48: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _49: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _50: core::ptr::NonNull<mm::frame::linked_list::Link<M>>;\n    let mut _51: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _52: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _53: &mut mm::frame::linked_list::Link<M>;\n    let mut _54: &mut mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _55: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>;\n    let mut _56: &mut mm::frame::linked_list::Link<M>;\n    let mut _57: &mut mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let  _58: ();\n    let mut _59: &core::sync::atomic::AtomicU64;\n    let  _60: &mm::frame::meta::MetaSlot;\n    let mut _61: &mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _62: core::sync::atomic::Ordering;\n    let mut _63: (usize, bool);\n    let mut _64: mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>;\n    let mut _65: &mut mm::frame::linked_list::LinkedList<M>;\n    let mut _66: &mut mm::frame::linked_list::LinkedList<M>;\n    let mut _67: &mut mm::frame::linked_list::LinkedList<M>;\n    let mut _68: &mut mm::frame::linked_list::LinkedList<M>;\n    let mut _69: &mut mm::frame::linked_list::LinkedList<M>;\n    debug self => _1;\n    debug current => _5;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _5;\n    debug frame => _6;\n    debug meta_ptr => _7;\n    debug paddr => _9;\n    debug next_ptr => _11;\n    debug prev => _18;\n    debug prev_mut => _19;\n    debug left_val => _24;\n    debug right_val => _25;\n    debug kind => _27;\n    debug prev_ptr => _30;\n    debug next => _37;\n    debug next_mut => _38;\n    debug left_val => _43;\n    debug right_val => _44;\n    debug kind => _46;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        _2 = <core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>> as core::ops::Try>::branch(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb3, 1: bb4, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _5 = ((_2 as variant#0).0: core::ptr::NonNull<mm::frame::linked_list::Link<M>>);\n        StorageDead(_2);\n        StorageLive(_6);\n        StorageLive(_8);\n        _8 = core::ptr::NonNull::<mm::frame::linked_list::Link<M>>::as_ptr(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        _0 = <core::option::Option<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<M>>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        goto -> bb33;\n    }\n    bb6: {\n        _7 = move _8 as *mut mm::frame::meta::MetaSlot;\n        StorageDead(_8);\n        StorageLive(_10);\n        _10 = _7 as usize;\n        _9 = mm::frame::meta::mapping::meta_to_frame::<arch::mm::PagingConsts>(move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_10);\n        _6 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::from_raw(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_6;\n        _12 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::meta(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _11 = ((*_12).0: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        StorageDead(_12);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut _6;\n        _15 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::meta_mut(move _16) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        _14 = &mut ((*_15).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        _17 = discriminant((*_14));\n        switchInt(move _17) -> [1: bb11, 0: bb16, otherwise: bb2];\n    }\n    bb11: {\n        _18 = &mut (((*_14) as variant#1).0: core::ptr::NonNull<mm::frame::linked_list::Link<M>>);\n        _19 = core::ptr::NonNull::<mm::frame::linked_list::Link<M>>::as_mut::<'_>(_18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &((*_19).0: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = core::option::Option::Some(_5);\n        _22 = &_23;\n        _20 = (move _21, move _22);\n        StorageDead(_22);\n        StorageDead(_21);\n        _24 = (_20.0: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        _25 = (_20.1: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        StorageLive(_26);\n        _26 = <core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>> as core::cmp::PartialEq>::eq(_24, _25) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _26) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_26);\n        StorageDead(_23);\n        StorageDead(_20);\n        ((*_19).0: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = _11;\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb17;\n    }\n    bb15: {\n        _27 = core::panicking::AssertKind::Eq;\n        StorageLive(_29);\n        _29 = core::option::Option::None;\n        _28 = core::panicking::assert_failed::<core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>, core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>>(_27, _24, _25, move _29) -> unwind unreachable;\n    }\n    bb16: {\n        StorageDead(_15);\n        StorageDead(_14);\n        _65 = ((*_1).0: &mut mm::frame::linked_list::LinkedList<M>);\n        ((*_65).0: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = _11;\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &_6;\n        _31 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::meta(move _32) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_32);\n        _30 = ((*_31).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        StorageDead(_31);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &mut _6;\n        _34 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::meta_mut(move _35) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_35);\n        _33 = &mut ((*_34).0: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        _36 = discriminant((*_33));\n        switchInt(move _36) -> [1: bb20, 0: bb26, otherwise: bb2];\n    }\n    bb20: {\n        _37 = &mut (((*_33) as variant#1).0: core::ptr::NonNull<mm::frame::linked_list::Link<M>>);\n        _38 = core::ptr::NonNull::<mm::frame::linked_list::Link<M>>::as_mut::<'_>(_37) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &((*_38).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = core::option::Option::Some(_5);\n        _41 = &_42;\n        _39 = (move _40, move _41);\n        StorageDead(_41);\n        StorageDead(_40);\n        _43 = (_39.0: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        _44 = (_39.1: &core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>);\n        StorageLive(_45);\n        _45 = <core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>> as core::cmp::PartialEq>::eq(_43, _44) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _45) -> [0: bb24, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_45);\n        StorageDead(_42);\n        StorageDead(_39);\n        ((*_38).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = _30;\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = <core::ptr::NonNull<mm::frame::linked_list::Link<M>> as core::convert::From<&mut mm::frame::linked_list::Link<M>>>::from(_38) -> [return: bb25, unwind unreachable];\n    }\n    bb24: {\n        _46 = core::panicking::AssertKind::Eq;\n        StorageLive(_48);\n        _48 = core::option::Option::None;\n        _47 = core::panicking::assert_failed::<core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>, core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>>(_46, _43, _44, move _48) -> unwind unreachable;\n    }\n    bb25: {\n        _49 = core::option::Option::Some(move _50);\n        StorageDead(_50);\n        ((*_1).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = move _49;\n        StorageDead(_49);\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb27;\n    }\n    bb26: {\n        StorageDead(_34);\n        StorageDead(_33);\n        _66 = ((*_1).0: &mut mm::frame::linked_list::LinkedList<M>);\n        ((*_66).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = _30;\n        StorageLive(_51);\n        _51 = core::option::Option::None;\n        ((*_1).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = move _51;\n        StorageDead(_51);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageLive(_52);\n        _52 = core::option::Option::None;\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &mut _6;\n        _53 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::meta_mut(move _54) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_54);\n        ((*_53).0: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = move _52;\n        StorageDead(_52);\n        StorageDead(_53);\n        StorageLive(_55);\n        _55 = core::option::Option::None;\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &mut _6;\n        _56 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::meta_mut(move _57) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_57);\n        ((*_56).1: core::option::Option<core::ptr::NonNull<mm::frame::linked_list::Link<M>>>) = move _55;\n        StorageDead(_55);\n        StorageDead(_56);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &_6;\n        _60 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<M>>::slot(move _61) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_61);\n        _59 = &((*_60).3: core::sync::atomic::AtomicU64);\n        StorageLive(_62);\n        _62 = core::sync::atomic::Ordering::Relaxed;\n        _58 = core::sync::atomic::AtomicU64::store(move _59, 0_u64, move _62) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_62);\n        StorageDead(_59);\n        StorageDead(_60);\n        _67 = ((*_1).0: &mut mm::frame::linked_list::LinkedList<M>);\n        _63 = CheckedSub(((*_67).2: usize), 1_usize);\n        _68 = ((*_1).0: &mut mm::frame::linked_list::LinkedList<M>);\n        assert(!move (_63.1: bool), \"attempt to compute `{} - {}`, which would overflow\", ((*_68).2: usize), 1_usize) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _69 = ((*_1).0: &mut mm::frame::linked_list::LinkedList<M>);\n        ((*_69).2: usize) = move (_63.0: usize);\n        StorageLive(_64);\n        _64 = move _6;\n        _0 = core::option::Option::Some(move _64);\n        StorageDead(_64);\n        StorageDead(_6);\n        goto -> bb33;\n    }\n    bb33: {\n        return;\n    }\n}\n",
  "doc": " Takes the current pointing frame out of the linked list.\n\n If successful, the frame is returned and the cursor is moved to the\n next frame. If the cursor is pointing to the back of the list then it\n is moved to the \"ghost\" non-element.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}