{
  "name": "mm::frame::segment::Segment::<M>::from_unused",
  "safe": true,
  "callees": {
    "core::num::<impl usize>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "mm::frame::max_paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the maximum physical address that is tracked by frame metadata.\n",
      "adt": {}
    },
    "core::iter::Iterator::step_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator starting at the same point, but stepping by\n the given amount at each iteration.\n\n Note 1: The first element of the iterator will always be returned,\n regardless of the step given.\n\n Note 2: The time at which ignored elements are pulled is not fixed.\n `StepBy` behaves like the sequence `self.next()`, `self.nth(step-1)`,\n `self.nth(step-1)`, …, but is also free to behave like the sequence\n `advance_n_and_return_first(&mut self, step)`,\n `advance_n_and_return_first(&mut self, step)`, …\n Which way is used may change for some iterators for performance reasons.\n The second way will advance the iterator earlier and may consume more items.\n\n `advance_n_and_return_first` is the equivalent of:\n ```\n fn advance_n_and_return_first<I>(iter: &mut I, n: usize) -> Option<I::Item>\n where\n     I: Iterator,\n {\n     let next = iter.next();\n     if n > 1 {\n         iter.nth(n - 2);\n     }\n     next\n }\n ```\n\n # Panics\n\n The method will panic if the given step is `0`.\n\n # Examples\n\n ```\n let a = [0, 1, 2, 3, 4, 5];\n let mut iter = a.into_iter().step_by(2);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "mm::frame::Frame::<M>::from_unused": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a [`Frame`] with a specific usage from a raw, unused page.\n\n The caller should provide the initial metadata of the page.\n\n If the provided frame is not truly unused at the moment, it will return\n an error. If wanting to acquire a frame that is already in use, use\n [`Frame::from_in_use`] instead.\n",
      "adt": {
        "mm::frame::meta::GetFrameError": "Constructor",
        "core::result::Result": "Constructor",
        "mm::frame::Frame": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ops::Range": [
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Plain"
    ],
    "mm::frame::meta::GetFrameError": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "mm::frame::segment::Segment": [
      "Plain",
      "Unknown([Field(0, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) }), Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::iter::StepBy": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4249, kind: RigidTy(Adt(AdtDef(DefId { id: 3414, name: \"mm::frame::Frame\" }), GenericArgs([Type(Ty { id: 1513, kind: Param(ParamTy { index: 0, name: \"M\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4515, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 4393, kind: RigidTy(Adt(AdtDef(DefId { id: 5079, name: \"mm::frame::meta::GetFrameError\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::frame::Frame": [
      "Plain"
    ],
    "core::mem::ManuallyDrop": [
      "Plain"
    ]
  },
  "path": 2010,
  "span": "ostd/src/mm/frame/segment.rs:85:5: 108:6",
  "src": "pub fn from_unused<F>(range: Range<Paddr>, mut metadata_fn: F) -> Result<Self, GetFrameError>\n    where\n        F: FnMut(Paddr) -> M,\n    {\n        if !range.start.is_multiple_of(PAGE_SIZE) || !range.end.is_multiple_of(PAGE_SIZE) {\n            return Err(GetFrameError::NotAligned);\n        }\n        if range.end > super::max_paddr() {\n            return Err(GetFrameError::OutOfBound);\n        }\n        assert!(range.start < range.end);\n        // Construct a segment early to recycle previously forgotten frames if\n        // the subsequent operations fails in the middle.\n        let mut segment = Self {\n            range: range.start..range.start,\n            _marker: core::marker::PhantomData,\n        };\n        for paddr in range.step_by(PAGE_SIZE) {\n            let frame = Frame::<M>::from_unused(paddr, metadata_fn(paddr))?;\n            let _ = ManuallyDrop::new(frame);\n            segment.range.end = paddr + PAGE_SIZE;\n        }\n        Ok(segment)\n    }",
  "mir": "fn mm::frame::segment::Segment::<M>::from_unused(_1: core::ops::Range<usize>, _2: F) -> core::result::Result<mm::frame::segment::Segment<M>, mm::frame::meta::GetFrameError> {\n    let mut _0: core::result::Result<mm::frame::segment::Segment<M>, mm::frame::meta::GetFrameError>;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: mm::frame::meta::GetFrameError;\n    let mut _8: bool;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: mm::frame::meta::GetFrameError;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: !;\n    let mut _16: mm::frame::segment::Segment<M>;\n    let mut _17: core::ops::Range<usize>;\n    let mut _18: usize;\n    let mut _19: usize;\n    let mut _20: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _21: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _22: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _23: core::option::Option<usize>;\n    let mut _24: &mut core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _25: isize;\n    let  _26: usize;\n    let mut _27: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>, mm::frame::Frame<M>>;\n    let mut _28: core::result::Result<mm::frame::Frame<M>, mm::frame::meta::GetFrameError>;\n    let mut _29: M;\n    let mut _30: &mut F;\n    let mut _31: (usize,);\n    let mut _32: isize;\n    let  _33: core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>;\n    let  _34: mm::frame::Frame<M>;\n    let mut _35: core::mem::ManuallyDrop<mm::frame::Frame<M>>;\n    let mut _36: (usize, bool);\n    let mut _37: mm::frame::segment::Segment<M>;\n    debug range => _1;\n    debug metadata_fn => _2;\n    debug segment => _16;\n    debug iter => _22;\n    debug paddr => _26;\n    debug frame => _34;\n    debug residual => _33;\n    debug val => _34;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = (_1.0: usize);\n        _3 = core::num::<impl usize>::is_multiple_of(move _4, mm::PAGE_SIZE) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = (_1.1: usize);\n        _5 = core::num::<impl usize>::is_multiple_of(move _6, mm::PAGE_SIZE) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        goto -> bb7;\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = (_1.1: usize);\n        StorageLive(_10);\n        _10 = mm::frame::max_paddr() -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_7);\n        _7 = mm::frame::meta::GetFrameError::NotAligned;\n        _0 = core::result::Result::Err(move _7);\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb29;\n    }\n    bb8: {\n        _8 = Gt(move _9, move _10);\n        switchInt(move _8) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = mm::frame::meta::GetFrameError::OutOfBound;\n        _0 = core::result::Result::Err(move _11);\n        StorageDead(_11);\n        StorageDead(_8);\n        goto -> bb29;\n    }\n    bb10: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (_1.0: usize);\n        StorageLive(_14);\n        _14 = (_1.1: usize);\n        _12 = Lt(move _13, move _14);\n        switchInt(move _12) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = (_1.0: usize);\n        StorageLive(_19);\n        _19 = (_1.0: usize);\n        _17 = Range(move _18, move _19);\n        StorageDead(_19);\n        StorageDead(_18);\n        _16 = Segment(move _17, ZeroSized: core::marker::PhantomData<M>);\n        StorageDead(_17);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = <core::ops::Range<usize> as core::iter::Iterator>::step_by(_1, mm::PAGE_SIZE) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _15 = core::panicking::panic(\"assertion failed: range.start < range.end\") -> unwind unreachable;\n    }\n    bb13: {\n        _20 = <core::iter::StepBy<core::ops::Range<usize>> as core::iter::IntoIterator>::into_iter(move _21) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_21);\n        StorageLive(_22);\n        _22 = move _20;\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_23);\n        _24 = &mut _22;\n        _23 = <core::iter::StepBy<core::ops::Range<usize>> as core::iter::Iterator>::next(_24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _25 = discriminant(_23);\n        switchInt(move _25) -> [0: bb19, 1: bb18, otherwise: bb17];\n    }\n    bb17: {\n        unreachable;\n    }\n    bb18: {\n        _26 = ((_23 as variant#1).0: usize);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &mut _2;\n        StorageLive(_31);\n        _31 = (_26);\n        _29 = <F as core::ops::FnMut<(usize,)>>::call_mut(move _30, move _31) -> [return: bb20, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageLive(_37);\n        _37 = move _16;\n        _0 = core::result::Result::Ok(move _37);\n        StorageDead(_37);\n        StorageDead(_16);\n        drop(_2) -> [return: bb30, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_31);\n        StorageDead(_30);\n        _28 = mm::frame::Frame::<M>::from_unused(_26, move _29) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_29);\n        _27 = <core::result::Result<mm::frame::Frame<M>, mm::frame::meta::GetFrameError> as core::ops::Try>::branch(move _28) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_28);\n        _32 = discriminant(_27);\n        switchInt(move _32) -> [0: bb23, 1: bb24, otherwise: bb17];\n    }\n    bb23: {\n        _34 = move ((_27 as variant#0).0: mm::frame::Frame<M>);\n        StorageDead(_27);\n        StorageLive(_35);\n        _35 = core::mem::ManuallyDrop::<mm::frame::Frame<M>>::new(_34) -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _33 = move ((_27 as variant#1).0: core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>);\n        _0 = <core::result::Result<mm::frame::segment::Segment<M>, mm::frame::meta::GetFrameError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, mm::frame::meta::GetFrameError>>>::from_residual(_33) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_27);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_20);\n        drop(_16) -> [return: bb28, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        _36 = CheckedAdd(_26, mm::PAGE_SIZE);\n        assert(!move (_36.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _26, mm::PAGE_SIZE) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        ((_16.0: core::ops::Range<usize>).1: usize) = move (_36.0: usize);\n        StorageDead(_23);\n        goto -> bb15;\n    }\n    bb28: {\n        StorageDead(_16);\n        goto -> bb29;\n    }\n    bb29: {\n        drop(_2) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        return;\n    }\n}\n",
  "doc": " Creates a new [`Segment`] from unused frames.\n\n The caller must provide a closure to initialize metadata for all the frames.\n The closure receives the physical address of the frame and returns the\n metadata, which is similar to [`core::array::from_fn`].\n\n It returns an error if:\n  - the physical address is invalid or not aligned;\n  - any of the frames cannot be created with a specific reason.\n\n # Panics\n\n It panics if the range is empty.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}