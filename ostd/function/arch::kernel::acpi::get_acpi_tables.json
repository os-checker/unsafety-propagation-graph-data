{
  "name": "arch::kernel::acpi::get_acpi_tables",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "acpi::rsdp::Rsdp::search_for_on_bios": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This searches for a RSDP on BIOS systems.\n\n ### Safety\n This function probes memory in three locations:\n    - It reads a word from `40:0e` to locate the EBDA.\n    - The first 1KiB of the EBDA (Extended BIOS Data Area).\n    - The BIOS memory area at `0xe0000..=0xfffff`.\n\n This should be fine on all BIOS systems. However, UEFI platforms are free to put the RSDP wherever they\n please, so this won't always find the RSDP. Further, prodding these memory locations may have unintended\n side-effects. On UEFI systems, the RSDP should be found in the Configuration Table, using two GUIDs:\n     - ACPI v1.0 structures use `eb9d2d30-2d88-11d3-9a16-0090273fc14d`.\n     - ACPI v2.0 or later structures use `8868e871-e4f1-11d3-bc22-0080c73c8881`.\n You should search the entire table for the v2.0 GUID before searching for the v1.0 one.\n",
      "adt": {}
    },
    "acpi::AcpiTables::<H>::from_rsdt": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create an `AcpiTables` if you have the physical address of the RSDT/XSDT.\n\n ### Safety\n\n Caller must ensure the provided address is valid RSDT/XSDT address.\n",
      "adt": {}
    },
    "acpi::AcpiTables::<H>::from_rsdp": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create an `AcpiTables` if you have the physical address of the RSDP.\n\n ### Safety\n\n Caller must ensure the provided address is valid to read as an RSDP.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "acpi::PhysicalMapping::<H, T>::physical_start": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "boot::EarlyBootInfo": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2219, kind: RigidTy(Adt(AdtDef(DefId { id: 3050, name: \"acpi::PhysicalMapping\" }), GenericArgs([Type(Ty { id: 428, kind: RigidTy(Adt(AdtDef(DefId { id: 3075, name: \"arch::kernel::acpi::AcpiMemoryHandler\" }), GenericArgs([]))) }), Type(Ty { id: 2223, kind: RigidTy(Adt(AdtDef(DefId { id: 4078, name: \"acpi::rsdp::Rsdp\" }), GenericArgs([]))) })]))) })])"
    ],
    "acpi::AcpiTables": [
      "Plain"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "acpi::PhysicalMapping": [
      "Plain",
      "Ref"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": 1239,
  "span": "ostd/src/arch/x86/kernel/acpi/mod.rs:46:1: 73:2",
  "src": "pub(crate) fn get_acpi_tables() -> Option<AcpiTables<AcpiMemoryHandler>> {\n    let acpi_tables = match boot::EARLY_INFO.get().unwrap().acpi_arg {\n        BootloaderAcpiArg::Rsdp(addr) => unsafe {\n            AcpiTables::from_rsdp(AcpiMemoryHandler {}, addr).unwrap()\n        },\n        BootloaderAcpiArg::Rsdt(addr) => unsafe {\n            AcpiTables::from_rsdt(AcpiMemoryHandler {}, 0, addr).unwrap()\n        },\n        BootloaderAcpiArg::Xsdt(addr) => unsafe {\n            AcpiTables::from_rsdt(AcpiMemoryHandler {}, 1, addr).unwrap()\n        },\n        BootloaderAcpiArg::NotProvided => {\n            // We search by ourselves if the bootloader decides not to provide a rsdp location.\n            let rsdp = unsafe { Rsdp::search_for_on_bios(AcpiMemoryHandler {}) };\n            match rsdp {\n                Ok(map) => unsafe {\n                    AcpiTables::from_rsdp(AcpiMemoryHandler {}, map.physical_start()).unwrap()\n                },\n                Err(_) => {\n                    warn!(\"ACPI info not found!\");\n                    return None;\n                }\n            }\n        }\n    };\n\n    Some(acpi_tables)\n}",
  "mir": "fn arch::kernel::acpi::get_acpi_tables() -> core::option::Option<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>> {\n    let mut _0: core::option::Option<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>;\n    let  _1: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _2: &boot::EarlyBootInfo;\n    let mut _3: core::option::Option<&boot::EarlyBootInfo>;\n    let mut _4: &spin::once::Once<boot::EarlyBootInfo>;\n    let mut _5: isize;\n    let  _6: usize;\n    let mut _7: core::result::Result<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>;\n    let  _8: usize;\n    let mut _9: core::result::Result<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>;\n    let  _10: usize;\n    let mut _11: core::result::Result<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>;\n    let  _12: core::result::Result<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::rsdp::Rsdp>, acpi::AcpiError>;\n    let mut _13: isize;\n    let  _14: acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::rsdp::Rsdp>;\n    let mut _15: core::result::Result<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>;\n    let mut _16: usize;\n    let mut _17: &acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::rsdp::Rsdp>;\n    let  _18: log::Level;\n    let mut _19: bool;\n    let mut _20: &log::Level;\n    let mut _21: &log::LevelFilter;\n    let mut _22: bool;\n    let mut _23: &log::Level;\n    let mut _24: &log::LevelFilter;\n    let  _25: log::LevelFilter;\n    let  _26: ();\n    let mut _27: core::fmt::Arguments<'_>;\n    let  _28: &(&str, &str, &core::panic::Location<'_>);\n    let  _29: (&str, &str, &core::panic::Location<'_>);\n    let mut _30: &str;\n    let  _31: &core::panic::Location<'_>;\n    let mut _32: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    debug acpi_tables => _1;\n    debug addr => _6;\n    debug addr => _8;\n    debug addr => _10;\n    debug rsdp => _12;\n    debug map => _14;\n    debug lvl => _18;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        _3 = spin::once::Once::<boot::EarlyBootInfo>::get(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = core::option::Option::<&boot::EarlyBootInfo>::unwrap(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _5 = discriminant(((*_2).3: boot::BootloaderAcpiArg));\n        switchInt(move _5) -> [0: bb4, 1: bb7, 2: bb6, 3: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_12);\n        _12 = acpi::rsdp::Rsdp::search_for_on_bios::<arch::kernel::acpi::AcpiMemoryHandler>(arch::kernel::acpi::AcpiMemoryHandler {{  }}) -> [return: bb14, unwind unreachable];\n    }\n    bb5: {\n        _10 = ((((*_2).3: boot::BootloaderAcpiArg) as variant#3).0: usize);\n        StorageLive(_11);\n        _11 = acpi::AcpiTables::<arch::kernel::acpi::AcpiMemoryHandler>::from_rsdt(arch::kernel::acpi::AcpiMemoryHandler {{  }}, 1_u8, _10) -> [return: bb12, unwind unreachable];\n    }\n    bb6: {\n        _8 = ((((*_2).3: boot::BootloaderAcpiArg) as variant#2).0: usize);\n        StorageLive(_9);\n        _9 = acpi::AcpiTables::<arch::kernel::acpi::AcpiMemoryHandler>::from_rsdt(arch::kernel::acpi::AcpiMemoryHandler {{  }}, 0_u8, _8) -> [return: bb10, unwind unreachable];\n    }\n    bb7: {\n        _6 = ((((*_2).3: boot::BootloaderAcpiArg) as variant#1).0: usize);\n        StorageLive(_7);\n        _7 = acpi::AcpiTables::<arch::kernel::acpi::AcpiMemoryHandler>::from_rsdp(arch::kernel::acpi::AcpiMemoryHandler {{  }}, _6) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _1 = core::result::Result::<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>::unwrap(move _7) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_7);\n        goto -> bb32;\n    }\n    bb10: {\n        _1 = core::result::Result::<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>::unwrap(move _9) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_9);\n        goto -> bb32;\n    }\n    bb12: {\n        _1 = core::result::Result::<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>::unwrap(move _11) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_11);\n        goto -> bb32;\n    }\n    bb14: {\n        _13 = discriminant(_12);\n        switchInt(move _13) -> [0: bb16, 1: bb15, otherwise: bb3];\n    }\n    bb15: {\n        _18 = log::Level::Warn;\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_18;\n        StorageLive(_21);\n        _21 = arch::kernel::acpi::get_acpi_tables::promoted[0];\n        _19 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _20, move _21) -> [return: bb21, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_14);\n        _14 = move ((_12 as variant#0).0: acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::rsdp::Rsdp>);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_14;\n        _16 = acpi::PhysicalMapping::<arch::kernel::acpi::AcpiMemoryHandler, acpi::rsdp::Rsdp>::physical_start(move _17) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_17);\n        _15 = acpi::AcpiTables::<arch::kernel::acpi::AcpiMemoryHandler>::from_rsdp(arch::kernel::acpi::AcpiMemoryHandler {{  }}, move _16) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_16);\n        _1 = core::result::Result::<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>, acpi::AcpiError>::unwrap(move _15) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_15);\n        drop(_14) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_14);\n        StorageDead(_12);\n        goto -> bb32;\n    }\n    bb21: {\n        switchInt(move _19) -> [0: bb30, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_18;\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = log::max_level() -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _24 = &_25;\n        _22 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _23, move _24) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        switchInt(move _22) -> [0: bb29, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_27);\n        _27 = core::fmt::Arguments::<'_>::from_str(\"ACPI info not found!\") -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = \"ostd::arch::kernel::acpi\";\n        _31 = log::__private_api::loc() -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _29 = (move _30, \"ostd::arch::kernel::acpi\", _31);\n        StorageDead(_30);\n        _28 = &_29;\n        _26 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _27, _18, _28, ()) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_27);\n        StorageDead(_29);\n        goto -> bb31;\n    }\n    bb29: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        goto -> bb31;\n    }\n    bb30: {\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_22);\n        StorageDead(_19);\n        _0 = core::option::Option::None;\n        StorageDead(_12);\n        StorageDead(_2);\n        StorageDead(_1);\n        goto -> bb33;\n    }\n    bb32: {\n        StorageDead(_2);\n        StorageLive(_32);\n        _32 = move _1;\n        _0 = core::option::Option::Some(move _32);\n        StorageDead(_32);\n        StorageDead(_1);\n        goto -> bb33;\n    }\n    bb33: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}