{
  "name": "util::range_alloc::RangeAllocator::alloc",
  "safe": true,
  "callees": {
    "util::range_alloc::RangeAllocator::get_freelist_guard": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "util::range_alloc::RangeAllocator": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor",
        "core::option::Option": "Constructor",
        "alloc::collections::BTreeMap": "Constructor",
        "util::range_alloc::FreeRange": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&mut Option<T>` to `Option<&mut T>`.\n\n # Examples\n\n ```\n let mut x = Some(2);\n match x.as_mut() {\n     Some(v) => *v = 42,\n     None => {},\n }\n assert_eq!(x, Some(42));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets an iterator over the entries of the map, sorted by key.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(3, \"c\");\n map.insert(2, \"b\");\n map.insert(1, \"a\");\n\n for (key, value) in map.iter() {\n     println!(\"{key}: {value}\");\n }\n\n let (first_key, first_value) = map.iter().next().unwrap();\n assert_eq!((*first_key, *first_value), (1, \"a\"));\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the value corresponding to the key.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n if let Some(x) = map.get_mut(&1) {\n     *x = \"b\";\n }\n assert_eq!(map[&1], \"b\");\n ```\n",
      "adt": {}
    },
    "alloc::collections::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "util::range_alloc::RangeAllocator": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7910, kind: RigidTy(Tuple([Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) }, Ty { id: 7911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Not)) }])) }), Field(0, Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7910, kind: RigidTy(Tuple([Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) }, Ty { id: 7911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Not)) }])) }), Field(1, Ty { id: 7911, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7914, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7929, kind: RigidTy(Adt(AdtDef(DefId { id: 6152, name: \"util::range_alloc::FreeRange\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "alloc::collections::BTreeMap": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "alloc::collections::btree_map::Iter": [
      "Plain",
      "MutRef"
    ],
    "util::range_alloc::FreeRange": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2956,
  "span": "ostd/src/util/range_alloc.rs:75:5: 104:6",
  "src": "pub fn alloc(&self, size: usize) -> Result<Range<usize>, RangeAllocError> {\n        let mut lock_guard = self.get_freelist_guard();\n        let freelist = lock_guard.as_mut().unwrap();\n        let mut allocate_range = None;\n        let mut to_remove = None;\n\n        for (key, value) in freelist.iter() {\n            if value.block.end - value.block.start >= size {\n                allocate_range = Some((value.block.end - size)..value.block.end);\n                to_remove = Some(*key);\n                break;\n            }\n        }\n\n        if let Some(key) = to_remove\n            && let Some(freenode) = freelist.get_mut(&key)\n        {\n            if freenode.block.end - size == freenode.block.start {\n                freelist.remove(&key);\n            } else {\n                freenode.block.end -= size;\n            }\n        }\n\n        if let Some(range) = allocate_range {\n            Ok(range)\n        } else {\n            Err(RangeAllocError)\n        }\n    }",
  "mir": "fn util::range_alloc::RangeAllocator::alloc(_1: &util::range_alloc::RangeAllocator, _2: usize) -> core::result::Result<core::ops::Range<usize>, util::range_alloc::RangeAllocError> {\n    let mut _0: core::result::Result<core::ops::Range<usize>, util::range_alloc::RangeAllocError>;\n    let mut _3: sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled>;\n    let  _4: &mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>;\n    let mut _5: core::option::Option<&mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>;\n    let mut _6: &mut core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>;\n    let mut _7: &mut sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled>;\n    let mut _8: core::option::Option<core::ops::Range<usize>>;\n    let mut _9: core::option::Option<usize>;\n    let mut _10: alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _11: alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _12: &alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>;\n    let mut _13: alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _14: core::option::Option<(&usize, &util::range_alloc::FreeRange)>;\n    let mut _15: &mut alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange>;\n    let mut _16: isize;\n    let  _17: &usize;\n    let  _18: &util::range_alloc::FreeRange;\n    let mut _19: bool;\n    let mut _20: usize;\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: (usize, bool);\n    let mut _24: core::option::Option<core::ops::Range<usize>>;\n    let mut _25: core::ops::Range<usize>;\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let mut _29: usize;\n    let mut _30: core::option::Option<usize>;\n    let mut _31: usize;\n    let mut _32: isize;\n    let  _33: usize;\n    let mut _34: core::option::Option<&mut util::range_alloc::FreeRange>;\n    let  _35: &usize;\n    let mut _36: isize;\n    let  _37: &mut util::range_alloc::FreeRange;\n    let mut _38: bool;\n    let mut _39: usize;\n    let mut _40: usize;\n    let mut _41: (usize, bool);\n    let mut _42: usize;\n    let  _43: core::option::Option<util::range_alloc::FreeRange>;\n    let  _44: &usize;\n    let mut _45: (usize, bool);\n    let mut _46: isize;\n    let  _47: core::ops::Range<usize>;\n    debug self => _1;\n    debug size => _2;\n    debug lock_guard => _3;\n    debug freelist => _4;\n    debug allocate_range => _8;\n    debug to_remove => _9;\n    debug iter => _13;\n    debug key => _17;\n    debug value => _18;\n    debug key => _33;\n    debug freenode => _37;\n    debug range => _47;\n    bb0: {\n        StorageLive(_3);\n        _3 = util::range_alloc::RangeAllocator::get_freelist_guard(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &mut _3;\n        _6 = <sync::spin::SpinLockGuard<'_, core::option::Option<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = core::option::Option::<alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>::as_mut(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = core::option::Option::<&mut alloc::collections::BTreeMap<usize, util::range_alloc::FreeRange>>::unwrap(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageLive(_8);\n        _8 = core::option::Option::None;\n        StorageLive(_9);\n        _9 = core::option::Option::None;\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(*_4);\n        _11 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::iter(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        _10 = <alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange> as core::iter::IntoIterator>::into_iter(move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageLive(_13);\n        _13 = move _10;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_14);\n        _15 = &mut _13;\n        _14 = <alloc::collections::btree_map::Iter<'_, usize, util::range_alloc::FreeRange> as core::iter::Iterator>::next(_15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _16 = discriminant(_14);\n        switchInt(move _16) -> [0: bb15, 1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        StorageLive(_17);\n        _17 = (((_14 as variant#1).0: (&usize, &util::range_alloc::FreeRange)).0: &usize);\n        StorageLive(_18);\n        _18 = (((_14 as variant#1).0: (&usize, &util::range_alloc::FreeRange)).1: &util::range_alloc::FreeRange);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = (((*_18).0: core::ops::Range<usize>).1: usize);\n        StorageLive(_22);\n        _22 = (((*_18).0: core::ops::Range<usize>).0: usize);\n        _23 = CheckedSub(_21, _22);\n        assert(!move (_23.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _21, move _22) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _20 = move (_23.0: usize);\n        StorageDead(_22);\n        StorageDead(_21);\n        _19 = Ge(move _20, _2);\n        switchInt(move _19) -> [0: bb14, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = (((*_18).0: core::ops::Range<usize>).1: usize);\n        _28 = CheckedSub(_27, _2);\n        assert(!move (_28.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _27, _2) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _26 = move (_28.0: usize);\n        StorageDead(_27);\n        StorageLive(_29);\n        _29 = (((*_18).0: core::ops::Range<usize>).1: usize);\n        _25 = Range(move _26, move _29);\n        StorageDead(_29);\n        StorageDead(_26);\n        _24 = core::option::Option::Some(move _25);\n        StorageDead(_25);\n        _8 = move _24;\n        StorageDead(_24);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = (*_17);\n        _30 = core::option::Option::Some(move _31);\n        StorageDead(_31);\n        _9 = move _30;\n        StorageDead(_30);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb15;\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_14);\n        goto -> bb7;\n    }\n    bb15: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_10);\n        _32 = discriminant(_9);\n        switchInt(move _32) -> [1: bb16, 0: bb26, otherwise: bb9];\n    }\n    bb16: {\n        StorageLive(_33);\n        _33 = ((_9 as variant#1).0: usize);\n        StorageLive(_34);\n        _35 = &_33;\n        _34 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::get_mut::<usize>(_4, _35) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _36 = discriminant(_34);\n        switchInt(move _36) -> [1: bb18, 0: bb25, otherwise: bb9];\n    }\n    bb18: {\n        StorageLive(_37);\n        _37 = move ((_34 as variant#1).0: &mut util::range_alloc::FreeRange);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = (((*_37).0: core::ops::Range<usize>).1: usize);\n        _41 = CheckedSub(_40, _2);\n        assert(!move (_41.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _40, _2) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _39 = move (_41.0: usize);\n        StorageDead(_40);\n        StorageLive(_42);\n        _42 = (((*_37).0: core::ops::Range<usize>).0: usize);\n        _38 = Eq(move _39, move _42);\n        switchInt(move _38) -> [0: bb22, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_42);\n        StorageDead(_39);\n        StorageLive(_43);\n        _44 = &_33;\n        _43 = alloc::collections::BTreeMap::<usize, util::range_alloc::FreeRange>::remove::<usize>(_4, _44) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_43);\n        goto -> bb24;\n    }\n    bb22: {\n        StorageDead(_42);\n        StorageDead(_39);\n        _45 = CheckedSub((((*_37).0: core::ops::Range<usize>).1: usize), _2);\n        assert(!move (_45.1: bool), \"attempt to compute `{} - {}`, which would overflow\", (((*_37).0: core::ops::Range<usize>).1: usize), _2) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        (((*_37).0: core::ops::Range<usize>).1: usize) = move (_45.0: usize);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb26;\n    }\n    bb25: {\n        StorageDead(_34);\n        StorageDead(_33);\n        goto -> bb26;\n    }\n    bb26: {\n        _46 = discriminant(_8);\n        switchInt(move _46) -> [1: bb27, 0: bb28, otherwise: bb9];\n    }\n    bb27: {\n        _47 = move ((_8 as variant#1).0: core::ops::Range<usize>);\n        _0 = core::result::Result::Ok(_47);\n        goto -> bb29;\n    }\n    bb28: {\n        _0 = core::result::Result::Err(util::range_alloc::RangeAllocError);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_9);\n        StorageDead(_8);\n        drop(_3) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Allocates a range specific by the `size`.\n\n This is currently implemented with a simple FIRST-FIT algorithm.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}