{
  "name": "arch::iommu::registers::IommuRegisters::read_version",
  "safe": true,
  "callees": {
    "volatile::VolatileRef::<'a, T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows this `VolatileRef` as a read-only [`VolatilePtr`].\n\n Use this method to do (partial) volatile reads of the referenced data.\n",
      "adt": {}
    },
    "volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile read of the contained value.\n\n Returns a copy of the read value. Volatile reads are guaranteed not to be optimized\n away by the compiler, but by themselves do not have atomic ordering\n guarantees. To also get atomicity, consider looking at the `Atomic` wrapper types of\n the standard/`core` library.\n\n ## Examples\n\n ```rust\n use volatile::{VolatilePtr, access};\n use core::ptr::NonNull;\n\n let value = 42;\n let pointer = unsafe {\n     VolatilePtr::new_restricted(access::ReadOnly, NonNull::from(&value))\n };\n assert_eq!(pointer.read(), 42);\n ```\n",
      "adt": {}
    },
    "bit_field::BitField::get_bits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Obtains the range of bits specified by `range`; note that index 0 is the least significant\n bit, while index `length() - 1` is the most significant bit.\n\n ```rust\n use bit_field::BitField;\n\n let value: u32 = 0b110101;\n\n assert_eq!(value.get_bits(0..3), 0b101);\n assert_eq!(value.get_bits(2..6), 0b1101);\n assert_eq!(value.get_bits(..), 0b110101);\n assert_eq!(value.get_bits(3..=3), value.get_bit(3) as u32);\n ```\n\n ## Panics\n\n This method will panic if the start or end indexes of the range are out of bounds of the\n bit field.\n",
      "adt": {}
    }
  },
  "adts": {
    "volatile::VolatileRef": [
      "Ref"
    ],
    "arch::iommu::registers::IommuRegisters": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "volatile::VolatilePtr": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "arch::iommu::registers::IommuVersion": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::iommu::registers::IommuRegisters::read_version"
  },
  "span": "ostd/src/arch/x86/iommu/registers/mod.rs:86:5: 92:6",
  "src": "pub fn read_version(&self) -> IommuVersion {\n        let version = self.version.as_ptr().read();\n        IommuVersion {\n            major: version.get_bits(4..8) as u8,\n            minor: version.get_bits(0..4) as u8,\n        }\n    }",
  "mir": "fn arch::iommu::registers::IommuRegisters::read_version(_1: &arch::iommu::registers::IommuRegisters) -> arch::iommu::registers::IommuVersion {\n    let mut _0: arch::iommu::registers::IommuVersion;\n    let  _2: u32;\n    let mut _3: volatile::VolatilePtr<'_, u32, volatile::access::ReadOnly>;\n    let mut _4: &volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>;\n    let mut _5: u8;\n    let mut _6: u32;\n    let mut _7: &u32;\n    let mut _8: core::ops::Range<usize>;\n    let mut _9: u8;\n    let mut _10: u32;\n    let mut _11: &u32;\n    let mut _12: core::ops::Range<usize>;\n    debug self => _1;\n    debug version => _2;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>);\n        _3 = volatile::VolatileRef::<'_, u32, volatile::access::ReadOnly>::as_ptr(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u32, volatile::access::ReadOnly>>::read(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_2;\n        StorageLive(_8);\n        _8 = Range(4_usize, 8_usize);\n        _6 = <u32 as bit_field::BitField>::get_bits::<core::ops::Range<usize>>(move _7, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _5 = move _6 as u8;\n        StorageDead(_6);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_2;\n        StorageLive(_12);\n        _12 = Range(0_usize, 4_usize);\n        _10 = <u32 as bit_field::BitField>::get_bits::<core::ops::Range<usize>>(move _11, move _12) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = move _10 as u8;\n        StorageDead(_10);\n        _0 = IommuVersion(move _5, move _9);\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Reads the version of IOMMU\n",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "dead_code"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* dead_code\n"
    ]
  }
}