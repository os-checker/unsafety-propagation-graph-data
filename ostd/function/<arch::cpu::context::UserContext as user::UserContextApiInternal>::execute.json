{
  "name": "<arch::cpu::context::UserContext as user::UserContextApiInternal>::execute",
  "safe": true,
  "callees": {
    "core::ops::BitOr::bitor": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `|` operation.\n\n # Examples\n\n ```\n assert_eq!(true | false, true);\n assert_eq!(false | false, false);\n assert_eq!(5u8 | 1u8, 5);\n assert_eq!(5u8 | 2u8, 7);\n ```\n",
      "adt": {}
    },
    "x86_64::registers::rflags::_::<impl x86_64::registers::rflags::RFlags>::bits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Get the underlying bits value.\n\n The returned value is exactly the bits set in this flags value.\n",
      "adt": {}
    },
    "task::scheduler::might_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Preempts the current task.\n",
      "adt": {}
    },
    "arch::trap::syscall::<impl arch::trap::RawUserContext>::run": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Goes to user space with the context, and comes back when a trap occurs.\n\n On return, the context will be reset to the status before the trap.\n Trap reason and error code will be placed at `trap_num` and `error_code`.\n\n If the trap was triggered by `syscall` instruction, the `trap_num` will be set to `0x100`.\n\n If `trap_num` is `0x100`, it will go user by `sysret` (`rcx` and `r11` are dropped),\n otherwise it will use `iret`.\n",
      "adt": {
        "arch::trap::RawUserContext": "MutableAsArgument"
      }
    },
    "arch::cpu::context::CpuException::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "arch::cpu::context::CpuException": "Constructor"
      }
    },
    "arch::cpu::context::CpuException::type_": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::cpu::context::CpuException": "MutableAsArgument",
        "arch::cpu::context::CpuExceptionType": "Constructor"
      }
    },
    "arch::cpu::context::tdx::VirtualizationExceptionHandler::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a VE handler.\n\n It is important that such a handler is created immediately after a VE happens,\n before the local IRQs are re-enabled. This is because the handler needs to retrieve more information\n about the last VE from the trusted Intel TDX module. If another VE happens, the information about\n the last one held by Intel TDX module would be overridden and lost!\n\n This constructor method retrieves the VE information from\n Intel TDX module and saved into the newly-created instance.\n So after instantiating a `VirtualizationExceptionHandler`,\n we won't need to worry about triggering a new VE.\n",
      "adt": {
        "arch::cpu::context::tdx::VirtualizationExceptionHandler": "Constructor"
      }
    },
    "arch::irq::ops::enable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::cpu::context::tdx::VirtualizationExceptionHandler::handle": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::cpu::context::UserContext": "MutableAsArgument",
        "arch::cpu::context::tdx::VirtualizationExceptionHandler": "ImmutableAsArgument"
      }
    },
    "arch::cpu::context::CpuExceptionType::is_fault_or_trap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns whether this exception type is a fault or a trap.\n",
      "adt": {}
    },
    "user::UserContextApiInternal::as_trap_frame": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Uses the information inside CpuContext to build a trapframe\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "arch::irq::HwIrqLine::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::irq::HwIrqLine": "Constructor"
      }
    },
    "irq::call_irq_callback_functions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::trap::TrapFrame": "ImmutableAsArgument",
        "arch::irq::HwIrqLine": "ImmutableAsArgument"
      }
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {
    "x86_64::registers::rflags::RFlags": [
      "Plain",
      "Ref"
    ],
    "arch::cpu::context::UserContext": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef",
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "arch::trap::RawUserContext": [
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 515, kind: RigidTy(Adt(AdtDef(DefId { id: 3107, name: \"arch::cpu::context::CpuException\" }), GenericArgs([]))) })])"
    ],
    "arch::cpu::context::CpuException": [
      "Ref",
      "Plain",
      "Unknown([Field(0, Ty { id: 530, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 515, kind: RigidTy(Adt(AdtDef(DefId { id: 3107, name: \"arch::cpu::context::CpuException\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 576, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 591, kind: RigidTy(Adt(AdtDef(DefId { id: 3173, name: \"arch::trap::TrapFrame\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "arch::cpu::context::CpuExceptionType": [
      "Plain"
    ],
    "arch::cpu::context::tdx::VirtualizationExceptionHandler": [
      "Plain",
      "Ref"
    ],
    "arch::trap::TrapFrame": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Unknown([Field(17, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "user::ReturnReason": [
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "arch::irq::HwIrqLine": [
      "Plain",
      "Ref"
    ],
    "cpu::PrivilegeLevel": [
      "Plain"
    ]
  },
  "path": 314,
  "span": "ostd/src/arch/x86/cpu/context/mod.rs:264:5: 320:6",
  "src": "fn execute<F>(&mut self, mut has_kernel_event: F) -> ReturnReason\n    where\n        F: FnMut() -> bool,\n    {\n        // set interrupt flag so that in user mode it can receive external interrupts\n        // set ID flag which means cpu support CPUID instruction\n        self.user_context.general.rflags |= (RFlags::INTERRUPT_FLAG | RFlags::ID).bits() as usize;\n\n        const SYSCALL_TRAPNUM: usize = 0x100;\n\n        // Return when it is syscall or cpu exception type is Fault or Trap.\n        loop {\n            crate::task::scheduler::might_preempt();\n            self.user_context.run();\n\n            let exception =\n                CpuException::new(self.user_context.trap_num, self.user_context.error_code);\n            match exception {\n                #[cfg(feature = \"cvm_guest\")]\n                Some(CpuException::VirtualizationException) => {\n                    let ve_handler = VirtualizationExceptionHandler::new();\n                    // Check out the doc of `VirtualizationExceptionHandler::new` to\n                    // see why IRQs must enabled _after_ instantiating a `VirtualizationExceptionHandler`.\n                    crate::arch::irq::enable_local();\n                    ve_handler.handle(self);\n                }\n                Some(exception) if exception.type_().is_fault_or_trap() => {\n                    crate::arch::irq::enable_local();\n                    self.exception = Some(exception);\n                    return ReturnReason::UserException;\n                }\n                Some(exception) => {\n                    panic!(\n                        \"cannot handle user CPU exception: {:?}, trapframe: {:?}\",\n                        exception,\n                        self.as_trap_frame()\n                    );\n                }\n                None if self.user_context.trap_num == SYSCALL_TRAPNUM => {\n                    crate::arch::irq::enable_local();\n                    return ReturnReason::UserSyscall;\n                }\n                None => {\n                    call_irq_callback_functions(\n                        &self.as_trap_frame(),\n                        &HwIrqLine::new(self.as_trap_frame().trap_num as u8),\n                        PrivilegeLevel::User,\n                    );\n                    crate::arch::irq::enable_local();\n                }\n            }\n\n            if has_kernel_event() {\n                break ReturnReason::KernelEvent;\n            }\n        }\n    }",
  "mir": "fn <arch::cpu::context::UserContext as user::UserContextApiInternal>::execute(_1: &mut arch::cpu::context::UserContext, _2: F) -> user::ReturnReason {\n    let mut _0: user::ReturnReason;\n    let mut _3: usize;\n    let mut _4: u64;\n    let mut _5: &x86_64::registers::rflags::RFlags;\n    let  _6: x86_64::registers::rflags::RFlags;\n    let  _7: ();\n    let  _8: ();\n    let mut _9: &mut arch::trap::RawUserContext;\n    let  _10: core::option::Option<arch::cpu::context::CpuException>;\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: isize;\n    let mut _14: isize;\n    let  _15: arch::cpu::context::tdx::VirtualizationExceptionHandler;\n    let  _16: ();\n    let  _17: ();\n    let mut _18: &arch::cpu::context::tdx::VirtualizationExceptionHandler;\n    let  _19: arch::cpu::context::CpuException;\n    let  _20: &arch::cpu::context::CpuException;\n    let mut _21: bool;\n    let mut _22: arch::cpu::context::CpuExceptionType;\n    let  _23: ();\n    let mut _24: core::option::Option<arch::cpu::context::CpuException>;\n    let  _25: arch::cpu::context::CpuException;\n    let  _26: !;\n    let mut _27: core::fmt::Arguments<'_>;\n    let  _28: (&arch::cpu::context::CpuException, &arch::trap::TrapFrame);\n    let mut _29: &arch::cpu::context::CpuException;\n    let mut _30: &arch::trap::TrapFrame;\n    let  _31: arch::trap::TrapFrame;\n    let mut _32: &arch::cpu::context::UserContext;\n    let  _33: [core::fmt::rt::Argument<'_>; 2];\n    let mut _34: core::fmt::rt::Argument<'_>;\n    let mut _35: core::fmt::rt::Argument<'_>;\n    let mut _36: &[u8; 52];\n    let  _37: &[core::fmt::rt::Argument<'_>; 2];\n    let mut _38: bool;\n    let mut _39: usize;\n    let  _40: ();\n    let  _41: ();\n    let  _42: &arch::trap::TrapFrame;\n    let  _43: arch::trap::TrapFrame;\n    let mut _44: &arch::cpu::context::UserContext;\n    let  _45: &arch::irq::HwIrqLine;\n    let  _46: arch::irq::HwIrqLine;\n    let mut _47: u8;\n    let mut _48: usize;\n    let mut _49: arch::trap::TrapFrame;\n    let mut _50: &arch::cpu::context::UserContext;\n    let mut _51: cpu::PrivilegeLevel;\n    let  _52: ();\n    let mut _53: bool;\n    let mut _54: &mut F;\n    let mut _55: &arch::cpu::context::CpuException;\n    let mut _56: &arch::trap::TrapFrame;\n    debug self => _1;\n    debug has_kernel_event => _2;\n    debug exception => _10;\n    debug ve_handler => _15;\n    debug exception => _19;\n    debug exception => _20;\n    debug exception => _25;\n    debug args => _28;\n    debug args => _33;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = <x86_64::registers::rflags::RFlags as core::ops::BitOr>::bitor(x86_64::registers::rflags::RFlags::INTERRUPT_FLAG, x86_64::registers::rflags::RFlags::ID) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &_6;\n        _4 = x86_64::registers::rflags::_::<impl x86_64::registers::rflags::RFlags>::bits(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = move _4 as usize;\n        StorageDead(_4);\n        ((((*_1).0: arch::trap::RawUserContext).0: arch::cpu::context::GeneralRegs).17: usize) = BitOr(((((*_1).0: arch::trap::RawUserContext).0: arch::cpu::context::GeneralRegs).17: usize), move _3);\n        StorageDead(_3);\n        StorageDead(_6);\n        goto -> bb3;\n    }\n    bb3: {\n        _7 = task::scheduler::might_preempt() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_9);\n        _9 = &mut ((*_1).0: arch::trap::RawUserContext);\n        _8 = arch::trap::syscall::<impl arch::trap::RawUserContext>::run(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = (((*_1).0: arch::trap::RawUserContext).1: usize);\n        StorageLive(_12);\n        _12 = (((*_1).0: arch::trap::RawUserContext).2: usize);\n        _10 = arch::cpu::context::CpuException::new(move _11, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _14 = discriminant(_10);\n        switchInt(move _14) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _13 = discriminant(((_10 as variant#1).0: arch::cpu::context::CpuException));\n        switchInt(move _13) -> [19: bb11, otherwise: bb10];\n    }\n    bb9: {\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = (((*_1).0: arch::trap::RawUserContext).1: usize);\n        _38 = Eq(move _39, <arch::cpu::context::UserContext as user::UserContextApiInternal>::execute::SYSCALL_TRAPNUM);\n        switchInt(move _38) -> [0: bb25, otherwise: bb24];\n    }\n    bb10: {\n        _20 = &((_10 as variant#1).0: arch::cpu::context::CpuException);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = arch::cpu::context::CpuException::type_(_20) -> [return: bb15, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_15);\n        _15 = arch::cpu::context::tdx::VirtualizationExceptionHandler::new() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _16 = arch::irq::ops::enable_local() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_18);\n        _18 = &_15;\n        _17 = arch::cpu::context::tdx::VirtualizationExceptionHandler::handle(move _18, _1) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_18);\n        StorageDead(_15);\n        goto -> bb31;\n    }\n    bb15: {\n        _21 = arch::cpu::context::CpuExceptionType::is_fault_or_trap(move _22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        switchInt(move _21) -> [0: bb18, otherwise: bb17];\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _19 = ((_10 as variant#1).0: arch::cpu::context::CpuException);\n        _23 = arch::irq::ops::enable_local() -> [return: bb19, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_25);\n        _25 = ((_10 as variant#1).0: arch::cpu::context::CpuException);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &_25;\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &(*_1);\n        _31 = <arch::cpu::context::UserContext as user::UserContextApiInternal>::as_trap_frame(move _32) -> [return: bb20, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_24);\n        _24 = core::option::Option::Some(_19);\n        ((*_1).1: core::option::Option<arch::cpu::context::CpuException>) = move _24;\n        StorageDead(_24);\n        _0 = user::ReturnReason::UserException;\n        goto -> bb35;\n    }\n    bb20: {\n        StorageDead(_32);\n        _30 = &_31;\n        _28 = (move _29, move _30);\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_33);\n        StorageLive(_34);\n        _55 = (_28.0: &arch::cpu::context::CpuException);\n        _34 = core::fmt::rt::Argument::<'_>::new_debug::<arch::cpu::context::CpuException>(_55) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_35);\n        _56 = (_28.1: &arch::trap::TrapFrame);\n        _35 = core::fmt::rt::Argument::<'_>::new_debug::<arch::trap::TrapFrame>(_56) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _33 = [move _34, move _35];\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_36);\n        _36 = b\"\\\"cannot handle user CPU exception: \\xc0\\r, trapframe: \\xc0\\x00\";\n        _37 = &_33;\n        _27 = core::fmt::Arguments::<'_>::new::<52, 2>(move _36, _37) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_36);\n        _26 = core::panicking::panic_fmt(move _27) -> unwind unreachable;\n    }\n    bb24: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _40 = arch::irq::ops::enable_local() -> [return: bb26, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &(*_1);\n        _43 = <arch::cpu::context::UserContext as user::UserContextApiInternal>::as_trap_frame(move _44) -> [return: bb27, unwind unreachable];\n    }\n    bb26: {\n        _0 = user::ReturnReason::UserSyscall;\n        goto -> bb35;\n    }\n    bb27: {\n        StorageDead(_44);\n        _42 = &_43;\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = &(*_1);\n        _49 = <arch::cpu::context::UserContext as user::UserContextApiInternal>::as_trap_frame(move _50) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_50);\n        _48 = (_49.17: usize);\n        _47 = move _48 as u8;\n        StorageDead(_48);\n        _46 = arch::irq::HwIrqLine::new(move _47) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_47);\n        _45 = &_46;\n        StorageLive(_51);\n        _51 = cpu::PrivilegeLevel::User;\n        _41 = irq::call_irq_callback_functions(_42, _45, move _51) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_51);\n        StorageDead(_49);\n        StorageDead(_46);\n        StorageDead(_43);\n        _52 = arch::irq::ops::enable_local() -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &mut _2;\n        _53 = <F as core::ops::FnMut<()>>::call_mut(move _54, ()) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        switchInt(move _53) -> [0: bb34, otherwise: bb33];\n    }\n    bb33: {\n        StorageDead(_54);\n        _0 = user::ReturnReason::KernelEvent;\n        StorageDead(_53);\n        StorageDead(_10);\n        drop(_2) -> [return: bb36, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageDead(_10);\n        goto -> bb3;\n    }\n    bb35: {\n        StorageDead(_10);\n        drop(_2) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}