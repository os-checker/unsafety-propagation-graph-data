{
  "name": "arch::io::construct_io_mem_allocator_builder",
  "safe": false,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::filter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which uses a closure to determine if an element\n should be yielded.\n\n Given an element the closure must return `true` or `false`. The returned\n iterator will yield only the elements for which the closure returns\n `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0i32, 1, 2];\n\n let mut iter = a.into_iter().filter(|x| x.is_positive());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `filter()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|x| **x > 1); // needs two *s!\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n It's common to instead use destructuring on the argument to strip away one:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&x| *x > 1); // both & and *\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n or both:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&&x| x > 1); // two &s\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n of these layers.\n\n Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::max_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the element that gives the maximum value with respect to the\n specified comparison function.\n\n If several elements are equally maximum, the last element is\n returned. If the iterator is empty, [`None`] is returned.\n\n # Examples\n\n ```\n let a = [-3_i32, 0, 1, 5, -10];\n assert_eq!(a.into_iter().max_by(|x, y| x.cmp(y)).unwrap(), 5);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "align_ext::AlignExt::align_up": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns to the smallest number that is greater than or equal to\n `self` and is a multiple of the given power of two.\n\n The method panics if `power_of_two` is not a\n power of two or is smaller than 2 or the calculation overflows\n because `self` is too large.\n\n # Examples\n\n ```\n use crate::align_ext::AlignExt;\n assert_eq!(12usize.align_up(2), 12);\n assert_eq!(12usize.align_up(4), 12);\n assert_eq!(12usize.align_up(8), 16);\n assert_eq!(12usize.align_up(16), 16);\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "io::io_mem::allocator::IoMemAllocatorBuilder::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes memory I/O region for devices.\n\n # Safety\n\n 1. This function must be called at most once.\n 2. This function must be called after the kernel page table is activated\n    on the bootstrapping processor.\n 3. The caller must ensure the range doesn't belong to physical memory.\n",
      "adt": {
        "alloc::vec::Vec": "MutableAsArgument",
        "io::io_mem::allocator::IoMemAllocatorBuilder": "Constructor"
      }
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "boot::EarlyBootInfo": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))"
    ],
    "boot::memory_region::MemoryRegionArray": [
      "Ref"
    ],
    "alloc::vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Filter": [
      "Plain",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "io::io_mem::allocator::IoMemAllocatorBuilder": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::io::construct_io_mem_allocator_builder"
  },
  "span": "ostd/src/arch/x86/io.rs:29:1: 80:2",
  "src": "pub(super) unsafe fn construct_io_mem_allocator_builder() -> IoMemAllocatorBuilder {\n    // TODO: Add MMIO regions below 1MB (e.g., VGA framebuffer).\n    let regions = &crate::boot::EARLY_INFO.get().unwrap().memory_regions;\n    let mut ranges = Vec::with_capacity(2);\n\n    let reserved_filter = regions.iter().filter(|r| {\n        r.typ() != MemoryRegionType::Unknown\n            && r.typ() != MemoryRegionType::Reserved\n            && r.typ() != MemoryRegionType::Framebuffer\n    });\n\n    // Find the TOLM (Top of Low Memory) and initialize Low MMIO region (TOLM ~ LOW_MMIO_TOP).\n    // Align start address to LOW_MMIO_ALIGN (according to Intel's datasheets, the lower 20 bits\n    // are zeroed).\n    const LOW_MMIO_TOP: usize = 0x1_0000_0000; // 4 GiB, 32 bits\n    const LOW_MMIO_ALIGN: usize = 0x10_0000; // 1 MiB, 20 bits\n    let (lower_half_base, lower_half_len) = reserved_filter\n        .clone()\n        .filter(|r| r.base() < LOW_MMIO_TOP)\n        .max_by(|a, b| a.base().cmp(&b.base()))\n        .map(|reg| (reg.base(), reg.len()))\n        .unwrap();\n\n    let mmio_start_addr = (lower_half_base + lower_half_len).align_up(LOW_MMIO_ALIGN);\n    assert!(mmio_start_addr < LOW_MMIO_TOP);\n    ranges.push(mmio_start_addr..LOW_MMIO_TOP);\n\n    // Find the TOHM (Top of High Memory) and initialize High MMIO region (TOHM ~ HIGH_MMIO_TOP).\n    // Align start address to HIGH_MMIO_ALIGN (according to Intel's datasheets, the lower 20 bits\n    // are zeroed).\n    //\n    // TODO: Use the CPUID instruction to determine the maximum number of bits in physical\n    // addresses. We use 52 bits here, which is the architectural limit for physical addresses.\n    const HIGH_MMIO_TOP: usize = 0x10_0000_0000_0000; // 4 PiB, 52 bits\n    const HIGH_MMIO_ALIGN: usize = 0x10_0000; // 1 MiB, 20 bits\n    let (upper_half_base, upper_half_len) = reserved_filter\n        .filter(|r| r.base() >= LOW_MMIO_TOP)\n        .max_by(|a, b| a.base().cmp(&b.base()))\n        .map(|reg| (reg.base(), reg.len()))\n        .unwrap_or((LOW_MMIO_TOP, 0));\n\n    let mmio_start_addr = (upper_half_base + upper_half_len).align_up(HIGH_MMIO_ALIGN);\n    assert!(mmio_start_addr < HIGH_MMIO_TOP);\n    ranges.push(mmio_start_addr..HIGH_MMIO_TOP);\n\n    // SAFETY:\n    // 1. This is the only place that creates an `IoMemAllocatorBuilder`. The\n    //    caller ensures that the function is only called once.\n    // 2. The caller ensures that the kernel page table is already activated.\n    // 3. The range is guaranteed not to access physical memory.\n    unsafe { IoMemAllocatorBuilder::new(ranges) }\n}",
  "mir": "fn arch::io::construct_io_mem_allocator_builder() -> io::io_mem::allocator::IoMemAllocatorBuilder {\n    let mut _0: io::io_mem::allocator::IoMemAllocatorBuilder;\n    let  _1: &boot::memory_region::MemoryRegionArray<512>;\n    let  _2: &boot::EarlyBootInfo;\n    let mut _3: core::option::Option<&boot::EarlyBootInfo>;\n    let mut _4: &spin::once::Once<boot::EarlyBootInfo>;\n    let mut _5: alloc::vec::Vec<core::ops::Range<usize>>;\n    let  _6: core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>;\n    let mut _7: core::slice::Iter<'_, boot::memory_region::MemoryRegion>;\n    let  _8: &[boot::memory_region::MemoryRegion];\n    let  _9: usize;\n    let  _10: usize;\n    let mut _11: (usize, usize);\n    let mut _12: core::option::Option<(usize, usize)>;\n    let mut _13: core::option::Option<&boot::memory_region::MemoryRegion>;\n    let mut _14: core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>, {closure@ostd/src/arch/x86/io.rs:47:17: 47:20}>;\n    let mut _15: core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>;\n    let mut _16: &core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>;\n    let  _17: usize;\n    let mut _18: usize;\n    let mut _19: (usize, bool);\n    let mut _20: bool;\n    let mut _21: !;\n    let  _22: ();\n    let mut _23: &mut alloc::vec::Vec<core::ops::Range<usize>>;\n    let mut _24: core::ops::Range<usize>;\n    let  _25: usize;\n    let  _26: usize;\n    let mut _27: (usize, usize);\n    let mut _28: core::option::Option<(usize, usize)>;\n    let mut _29: core::option::Option<&boot::memory_region::MemoryRegion>;\n    let mut _30: core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>, {closure@ostd/src/arch/x86/io.rs:65:17: 65:20}>;\n    let mut _31: (usize, usize);\n    let  _32: usize;\n    let mut _33: usize;\n    let mut _34: (usize, bool);\n    let mut _35: bool;\n    let mut _36: !;\n    let  _37: ();\n    let mut _38: &mut alloc::vec::Vec<core::ops::Range<usize>>;\n    let mut _39: core::ops::Range<usize>;\n    let mut _40: alloc::vec::Vec<core::ops::Range<usize>>;\n    debug regions => _1;\n    debug ranges => _5;\n    debug reserved_filter => _6;\n    debug lower_half_base => _9;\n    debug lower_half_len => _10;\n    debug mmio_start_addr => _17;\n    debug upper_half_base => _25;\n    debug upper_half_len => _26;\n    debug mmio_start_addr => _32;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        _3 = spin::once::Once::<boot::EarlyBootInfo>::get(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = core::option::Option::<&boot::EarlyBootInfo>::unwrap(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _1 = &((*_2).5: boot::memory_region::MemoryRegionArray<512>);\n        StorageLive(_5);\n        _5 = alloc::vec::Vec::<core::ops::Range<usize>>::with_capacity(2_usize) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_7);\n        _8 = <boot::memory_region::MemoryRegionArray<512> as core::ops::Deref>::deref(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = core::slice::<impl [boot::memory_region::MemoryRegion]>::iter(_8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _6 = <core::slice::Iter<'_, boot::memory_region::MemoryRegion> as core::iter::Iterator>::filter::<{closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>(move _7, ZeroSized: {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_6;\n        _15 = <core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}> as core::clone::Clone>::clone(move _16) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_16);\n        _14 = <core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}> as core::iter::Iterator>::filter::<{closure@ostd/src/arch/x86/io.rs:47:17: 47:20}>(move _15, ZeroSized: {closure@ostd/src/arch/x86/io.rs:47:17: 47:20}) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        _13 = <core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>, {closure@ostd/src/arch/x86/io.rs:47:17: 47:20}> as core::iter::Iterator>::max_by::<{closure@ostd/src/arch/x86/io.rs:48:17: 48:23}>(move _14, ZeroSized: {closure@ostd/src/arch/x86/io.rs:48:17: 48:23}) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        _12 = core::option::Option::<&boot::memory_region::MemoryRegion>::map::<(usize, usize), {closure@ostd/src/arch/x86/io.rs:49:14: 49:19}>(move _13, ZeroSized: {closure@ostd/src/arch/x86/io.rs:49:14: 49:19}) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        _11 = core::option::Option::<(usize, usize)>::unwrap(move _12) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_12);\n        _9 = (_11.0: usize);\n        _10 = (_11.1: usize);\n        StorageDead(_11);\n        StorageLive(_18);\n        _19 = CheckedAdd(_9, _10);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, _10) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = move (_19.0: usize);\n        _17 = <usize as align_ext::AlignExt>::align_up(move _18, arch::io::construct_io_mem_allocator_builder::LOW_MMIO_ALIGN) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageLive(_20);\n        _20 = Lt(_17, arch::io::construct_io_mem_allocator_builder::LOW_MMIO_TOP);\n        switchInt(move _20) -> [0: bb15, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = &mut _5;\n        StorageLive(_24);\n        _24 = Range(_17, arch::io::construct_io_mem_allocator_builder::LOW_MMIO_TOP);\n        _22 = alloc::vec::Vec::<core::ops::Range<usize>>::push(move _23, move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb15: {\n        _21 = core::panicking::panic(\"assertion failed: mmio_start_addr < LOW_MMIO_TOP\") -> unwind unreachable;\n    }\n    bb16: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = <core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}> as core::iter::Iterator>::filter::<{closure@ostd/src/arch/x86/io.rs:65:17: 65:20}>(_6, ZeroSized: {closure@ostd/src/arch/x86/io.rs:65:17: 65:20}) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _29 = <core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, boot::memory_region::MemoryRegion>, {closure@ostd/src/arch/x86/io.rs:34:49: 34:52}>, {closure@ostd/src/arch/x86/io.rs:65:17: 65:20}> as core::iter::Iterator>::max_by::<{closure@ostd/src/arch/x86/io.rs:66:17: 66:23}>(move _30, ZeroSized: {closure@ostd/src/arch/x86/io.rs:66:17: 66:23}) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        _28 = core::option::Option::<&boot::memory_region::MemoryRegion>::map::<(usize, usize), {closure@ostd/src/arch/x86/io.rs:67:14: 67:19}>(move _29, ZeroSized: {closure@ostd/src/arch/x86/io.rs:67:14: 67:19}) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_29);\n        StorageLive(_31);\n        _31 = (arch::io::construct_io_mem_allocator_builder::LOW_MMIO_TOP, 0_usize);\n        _27 = core::option::Option::<(usize, usize)>::unwrap_or(move _28, move _31) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_31);\n        StorageDead(_28);\n        _25 = (_27.0: usize);\n        _26 = (_27.1: usize);\n        StorageDead(_27);\n        StorageLive(_33);\n        _34 = CheckedAdd(_25, _26);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _25, _26) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _33 = move (_34.0: usize);\n        _32 = <usize as align_ext::AlignExt>::align_up(move _33, arch::io::construct_io_mem_allocator_builder::HIGH_MMIO_ALIGN) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_33);\n        StorageLive(_35);\n        _35 = Lt(_32, arch::io::construct_io_mem_allocator_builder::HIGH_MMIO_TOP);\n        switchInt(move _35) -> [0: bb24, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageLive(_38);\n        _38 = &mut _5;\n        StorageLive(_39);\n        _39 = Range(_32, arch::io::construct_io_mem_allocator_builder::HIGH_MMIO_TOP);\n        _37 = alloc::vec::Vec::<core::ops::Range<usize>>::push(move _38, move _39) -> [return: bb25, unwind unreachable];\n    }\n    bb24: {\n        _36 = core::panicking::panic(\"assertion failed: mmio_start_addr < HIGH_MMIO_TOP\") -> unwind unreachable;\n    }\n    bb25: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_40);\n        _40 = move _5;\n        _0 = io::io_mem::allocator::IoMemAllocatorBuilder::new(move _40) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_40);\n        StorageDead(_5);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Initializes the allocatable MMIO area based on the x86-64 memory distribution map.\n\n In x86-64, the available physical memory area is divided into two regions below 32 bits (Low memory)\n and above (High memory). The area from the top of low memory to 0xffff_ffff and the area after the\n top of high memory are available MMIO areas.\n\n This memory layout is documented in Intel's datasheets. The MMIO area is defined by specific\n registers that are configured by the BIOS and locked down, preventing the OS from reconfiguring\n them. For the details, one can read the \"Processor Configuration Register Definitions and\n Address Ranges\" section in the \"10th Generation Intel(R) Processor Families\" datasheet\n (<https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/10th-gen-core-families-datasheet-vol-2-datasheet.pdf>).\n However, note that these specifics may differ between CPU generations and those manufactured by\n other vendors.\n\n # Safety\n\n 1. This function must be called only once in the boot context of the\n    bootstrapping processor.\n 2. This function must be called after the kernel page table is activated on\n    the bootstrapping processor.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}