{
  "name": "arch::boot::linux_boot::__linux_boot",
  "safe": false,
  "callees": {
    "arch::init_cvm_guest": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    },
    "boot::call_ostd_main": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Calls the OSTD-user defined entrypoint of the actual kernel.\n\n Any kernel that uses the `ostd` crate should define a function marked with\n `ostd::main` as the entrypoint.\n\n This function should be only called from the bootloader-specific module.\n",
      "adt": {}
    }
  },
  "adts": {
    "linux_boot_params::BootParams": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(28)))"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "boot::EarlyBootInfo": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::boot::linux_boot::__linux_boot"
  },
  "span": "ostd/src/arch/x86/boot/linux_boot/mod.rs:203:1: 222:2",
  "src": "unsafe extern \"sysv64\" fn __linux_boot(params_ptr: *const BootParams) -> ! {\n    let params = unsafe { &*params_ptr };\n    assert_eq!({ params.hdr.header }, LINUX_BOOT_HEADER_MAGIC);\n\n    use crate::boot::{EARLY_INFO, EarlyBootInfo, call_ostd_main};\n\n    #[cfg(feature = \"cvm_guest\")]\n    init_cvm_guest();\n\n    EARLY_INFO.call_once(|| EarlyBootInfo {\n        bootloader_name: parse_bootloader_name(params),\n        kernel_cmdline: parse_kernel_commandline(params).unwrap_or(\"\"),\n        initramfs: parse_initramfs(params),\n        acpi_arg: parse_acpi_arg(params),\n        framebuffer_arg: parse_framebuffer_info(params),\n        memory_regions: parse_memory_regions(params),\n    });\n\n    call_ostd_main();\n}",
  "mir": "fn arch::boot::linux_boot::__linux_boot(_1: *const linux_boot_params::BootParams) -> ! {\n    let mut _0: !;\n    let  _2: &linux_boot_params::BootParams;\n    let mut _3: (&u32, &u32);\n    let mut _4: &u32;\n    let  _5: u32;\n    let mut _6: &u32;\n    let  _7: &u32;\n    let  _8: &u32;\n    let mut _9: bool;\n    let mut _10: u32;\n    let mut _11: u32;\n    let  _12: core::panicking::AssertKind;\n    let  _13: !;\n    let mut _14: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _15: ();\n    let  _16: &boot::EarlyBootInfo;\n    let mut _17: &spin::once::Once<boot::EarlyBootInfo>;\n    let mut _18: {closure@ostd/src/arch/x86/boot/linux_boot/mod.rs:212:26: 212:28};\n    let  _19: !;\n    debug params_ptr => _1;\n    debug params => _2;\n    debug left_val => _7;\n    debug right_val => _8;\n    debug kind => _12;\n    bb0: {\n        _2 = &(*_1);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = (((*_2).28: linux_boot_params::SetupHeader).8: u32);\n        _4 = &_5;\n        StorageLive(_6);\n        _6 = arch::boot::linux_boot::__linux_boot::promoted[0];\n        _3 = (move _4, move _6);\n        StorageDead(_6);\n        StorageDead(_4);\n        _7 = (_3.0: &u32);\n        _8 = (_3.1: &u32);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = (*_7);\n        StorageLive(_11);\n        _11 = (*_8);\n        _9 = Eq(move _10, move _11);\n        switchInt(move _9) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageDead(_3);\n        _15 = arch::init_cvm_guest() -> [return: bb3, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = core::panicking::AssertKind::Eq;\n        StorageLive(_14);\n        _14 = core::option::Option::None;\n        _13 = core::panicking::assert_failed::<u32, u32>(_12, _7, _8, move _14) -> unwind unreachable;\n    }\n    bb3: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        StorageLive(_18);\n        _18 = {closure@ostd/src/arch/x86/boot/linux_boot/mod.rs:212:26: 212:28}(_2);\n        _16 = spin::once::Once::<boot::EarlyBootInfo>::call_once::<{closure@ostd/src/arch/x86/boot/linux_boot/mod.rs:212:26: 212:28}>(move _17, move _18) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        _19 = boot::call_ostd_main() -> unwind unreachable;\n    }\n}\n",
  "doc": " The entry point of the Rust code portion of Asterinas (with Linux boot parameters).\n\n # Safety\n\n - This function must be called only once at a proper timing in the BSP's boot assembly code.\n - The caller must follow C calling conventions and put the right arguments in registers.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}