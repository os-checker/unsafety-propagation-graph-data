{
  "name": "mm::dma::dma_stream::DmaStream::<D>::alloc_uninit",
  "safe": true,
  "callees": {
    "mm::dma::util::cvm_need_private_protection": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::mm::can_sync_dma": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_segment": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a contiguous range of untyped frames without metadata.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "mm::mem_obj::HasPaddrRange::paddr_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the physical address range of the memory object.\n",
      "adt": {}
    },
    "mm::dma::util::alloc_kva": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::kspace::kvirt_area::KVirtArea": "Constructor"
      }
    },
    "mm::dma::util::prepare_dma": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prepares a physical address range for DMA mapping.\n\n If DMA remapping is enabled, the function allocates device addresses, maps\n the given physical address range to them, and returns the start device\n address.\n\n # Safety\n\n The provided physical address range must be untyped DMA memory that\n outlives the following [`unprepare_dma()`] call.\n",
      "adt": {
        "core::ops::Range": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1626, kind: RigidTy(Adt(AdtDef(DefId { id: 3684, name: \"mm::frame::segment::Segment\" }), GenericArgs([Type(Ty { id: 107, kind: RigidTy(Tuple([])) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4015, kind: RigidTy(Tuple([Ty { id: 3653, kind: RigidTy(Adt(AdtDef(DefId { id: 4769, name: \"mm::kspace::kvirt_area::KVirtArea\" }), GenericArgs([]))) }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }])) })])"
    ],
    "mm::frame::segment::Segment": [
      "Plain",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4090, kind: RigidTy(Adt(AdtDef(DefId { id: 4938, name: \"mm::dma::dma_stream::Inner\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Ref"
    ],
    "mm::dma::dma_stream::Inner": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4090, kind: RigidTy(Adt(AdtDef(DefId { id: 4938, name: \"mm::dma::dma_stream::Inner\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "mm::kspace::kvirt_area::KVirtArea": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3653, kind: RigidTy(Adt(AdtDef(DefId { id: 4769, name: \"mm::kspace::kvirt_area::KVirtArea\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "mm::dma::dma_stream::DmaStream": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::dma::dma_stream::DmaStream::<D>::alloc_uninit"
  },
  "span": "ostd/src/mm/dma/dma_stream.rs:125:5: 151:6",
  "src": "pub fn alloc_uninit(nframes: usize, is_cache_coherent: bool) -> Result<Self, Error> {\n        let cvm = cvm_need_private_protection();\n\n        let (inner, paddr_range) = if (can_sync_dma() || is_cache_coherent) && !cvm {\n            let segment: USegment = FrameAllocOptions::new()\n                .zeroed(false)\n                .alloc_segment(nframes)?\n                .into();\n            let paddr_range = segment.paddr_range();\n\n            (Inner::Segment(segment), paddr_range)\n        } else {\n            let (kva, paddr) = alloc_kva(nframes, can_sync_dma() || is_cache_coherent)?;\n\n            (Inner::Kva(kva, paddr), paddr..paddr + nframes * PAGE_SIZE)\n        };\n\n        // SAFETY: The physical address range is untyped DMA memory before `drop`.\n        let map_daddr = unsafe { prepare_dma(&paddr_range) };\n\n        Ok(Self {\n            inner,\n            map_daddr,\n            is_cache_coherent,\n            _phantom: PhantomData,\n        })\n    }",
  "mir": "fn mm::dma::dma_stream::DmaStream::<D>::alloc_uninit(_1: usize, _2: bool) -> core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error> {\n    let mut _0: core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error>;\n    let  _3: bool;\n    let  _4: mm::dma::dma_stream::Inner;\n    let  _5: core::ops::Range<usize>;\n    let mut _6: (mm::dma::dma_stream::Inner, core::ops::Range<usize>);\n    let mut _7: bool;\n    let  _8: mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta>;\n    let mut _9: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::segment::Segment<()>>;\n    let mut _10: core::result::Result<mm::frame::segment::Segment<()>, error::Error>;\n    let mut _11: &mm::frame::allocator::FrameAllocOptions;\n    let  _12: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _13: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _14: mm::frame::allocator::FrameAllocOptions;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _17: mm::frame::segment::Segment<()>;\n    let  _18: core::ops::Range<usize>;\n    let mut _19: &mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta>;\n    let mut _20: mm::dma::dma_stream::Inner;\n    let  _21: mm::kspace::kvirt_area::KVirtArea;\n    let  _22: usize;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, (mm::kspace::kvirt_area::KVirtArea, usize)>;\n    let mut _24: core::result::Result<(mm::kspace::kvirt_area::KVirtArea, usize), error::Error>;\n    let mut _25: bool;\n    let mut _26: bool;\n    let mut _27: isize;\n    let  _28: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _29: (mm::kspace::kvirt_area::KVirtArea, usize);\n    let mut _30: mm::dma::dma_stream::Inner;\n    let mut _31: core::ops::Range<usize>;\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: (usize, bool);\n    let mut _35: (usize, bool);\n    let  _36: core::option::Option<usize>;\n    let  _37: &core::ops::Range<usize>;\n    let mut _38: mm::dma::dma_stream::DmaStream<D>;\n    debug nframes => _1;\n    debug is_cache_coherent => _2;\n    debug cvm => _3;\n    debug inner => _4;\n    debug paddr_range => _5;\n    debug segment => _8;\n    debug residual => _16;\n    debug val => _17;\n    debug paddr_range => _18;\n    debug kva => _21;\n    debug paddr => _22;\n    debug residual => _28;\n    debug val => _29;\n    debug map_daddr => _36;\n    bb0: {\n        _3 = mm::dma::util::cvm_need_private_protection() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = arch::mm::can_sync_dma() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _7) -> [0: bb3, otherwise: bb4];\n    }\n    bb3: {\n        switchInt(_2) -> [0: bb16, otherwise: bb4];\n    }\n    bb4: {\n        switchInt(_3) -> [0: bb5, otherwise: bb16];\n    }\n    bb5: {\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _13 = &mut _14;\n        _12 = mm::frame::allocator::FrameAllocOptions::zeroed(move _13, false) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = &(*_12);\n        StorageDead(_13);\n        _10 = mm::frame::allocator::FrameAllocOptions::alloc_segment(move _11, _1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _9 = <core::result::Result<mm::frame::segment::Segment<()>, error::Error> as core::ops::Try>::branch(move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        _15 = discriminant(_9);\n        switchInt(move _15) -> [0: bb11, 1: bb12, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        _17 = move ((_9 as variant#0).0: mm::frame::segment::Segment<()>);\n        _8 = <mm::frame::segment::Segment<()> as core::convert::Into<mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta>>>::into(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _16 = ((_9 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_9);\n        goto -> bb30;\n    }\n    bb14: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageLive(_19);\n        _19 = &_8;\n        _18 = <mm::frame::segment::Segment<dyn mm::frame::untyped::AnyUFrameMeta> as mm::mem_obj::HasPaddrRange>::paddr_range(move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = mm::dma::dma_stream::Inner::Segment(_8);\n        _6 = (move _20, _18);\n        StorageDead(_20);\n        goto -> bb28;\n    }\n    bb16: {\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = arch::mm::can_sync_dma() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        switchInt(move _26) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        _25 = true;\n        goto -> bb20;\n    }\n    bb19: {\n        _25 = _2;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_26);\n        _24 = mm::dma::util::alloc_kva(_1, move _25) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_25);\n        _23 = <core::result::Result<(mm::kspace::kvirt_area::KVirtArea, usize), error::Error> as core::ops::Try>::branch(move _24) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_24);\n        _27 = discriminant(_23);\n        switchInt(move _27) -> [0: bb23, 1: bb24, otherwise: bb10];\n    }\n    bb23: {\n        _29 = move ((_23 as variant#0).0: (mm::kspace::kvirt_area::KVirtArea, usize));\n        _21 = (_29.0: mm::kspace::kvirt_area::KVirtArea);\n        _22 = (_29.1: usize);\n        StorageDead(_23);\n        StorageLive(_30);\n        _30 = mm::dma::dma_stream::Inner::Kva(_21, _22);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _34 = CheckedMul(_1, mm::PAGE_SIZE);\n        assert(!move (_34.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _1, mm::PAGE_SIZE) -> [success: bb26, unwind unreachable];\n    }\n    bb24: {\n        _28 = ((_23 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::dma::dma_stream::DmaStream<D>, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_28) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_23);\n        goto -> bb30;\n    }\n    bb26: {\n        _33 = move (_34.0: usize);\n        _35 = CheckedAdd(_22, _33);\n        assert(!move (_35.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _22, move _33) -> [success: bb27, unwind unreachable];\n    }\n    bb27: {\n        _32 = move (_35.0: usize);\n        StorageDead(_33);\n        _31 = Range(_22, move _32);\n        StorageDead(_32);\n        _6 = (move _30, move _31);\n        StorageDead(_31);\n        StorageDead(_30);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_7);\n        _4 = move (_6.0: mm::dma::dma_stream::Inner);\n        StorageLive(_5);\n        _5 = move (_6.1: core::ops::Range<usize>);\n        StorageDead(_6);\n        _37 = &_5;\n        _36 = mm::dma::util::prepare_dma(_37) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageLive(_38);\n        _38 = DmaStream(_4, _36, _2, ZeroSized: core::marker::PhantomData<D>);\n        _0 = core::result::Result::Ok(move _38);\n        StorageDead(_38);\n        StorageDead(_5);\n        goto -> bb31;\n    }\n    bb30: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb31;\n    }\n    bb31: {\n        return;\n    }\n}\n",
  "doc": " Allocates a region of physical memory for streaming DMA access\n without initialization.\n\n This method is the same as [`DmaStream::alloc`]\n except that it skips zeroing the memory of newly-allocated DMA region.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}