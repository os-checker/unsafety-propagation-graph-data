{
  "name": "boot::memory_region::MemoryRegion::module",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ops::Range::<Idx>::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `item` is contained in the range.\n\n # Examples\n\n ```\n assert!(!(3..5).contains(&2));\n assert!( (3..5).contains(&3));\n assert!( (3..5).contains(&4));\n assert!(!(3..5).contains(&5));\n\n assert!(!(3..3).contains(&3));\n assert!(!(3..2).contains(&3));\n\n assert!( (0.0..1.0).contains(&0.5));\n assert!(!(0.0..1.0).contains(&f32::NAN));\n assert!(!(0.0..f32::NAN).contains(&0.5));\n assert!(!(f32::NAN..1.0).contains(&0.5));\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ops::Range": [
      "Ref"
    ],
    "boot::memory_region::MemoryRegionType": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegion": [
      "Plain"
    ]
  },
  "path": 1581,
  "span": "ostd/src/boot/memory_region.rs:106:5: 115:6",
  "src": "pub fn module(bytes: &[u8]) -> Self {\n        let vaddr = bytes.as_ptr() as Vaddr;\n        assert!(crate::mm::kspace::LINEAR_MAPPING_VADDR_RANGE.contains(&vaddr));\n\n        Self {\n            base: vaddr - crate::mm::kspace::LINEAR_MAPPING_BASE_VADDR,\n            len: bytes.len(),\n            typ: MemoryRegionType::Reclaimable,\n        }\n    }",
  "mir": "fn boot::memory_region::MemoryRegion::module(_1: &[u8]) -> boot::memory_region::MemoryRegion {\n    let mut _0: boot::memory_region::MemoryRegion;\n    let  _2: usize;\n    let mut _3: *const u8;\n    let mut _4: bool;\n    let mut _5: &core::ops::Range<usize>;\n    let  _6: &usize;\n    let mut _7: !;\n    let mut _8: usize;\n    let mut _9: (usize, bool);\n    let mut _10: usize;\n    let mut _11: boot::memory_region::MemoryRegionType;\n    debug bytes => _1;\n    debug vaddr => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = core::slice::<impl [u8]>::as_ptr(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = move _3 as usize;\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = boot::memory_region::MemoryRegion::module::promoted[0];\n        _6 = &_2;\n        _4 = core::ops::Range::<usize>::contains::<usize>(move _5, _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_8);\n        _9 = CheckedSub(_2, mm::kspace::LINEAR_MAPPING_BASE_VADDR);\n        assert(!move (_9.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _2, mm::kspace::LINEAR_MAPPING_BASE_VADDR) -> [success: bb5, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        _7 = core::panicking::panic(\"assertion failed: crate::mm::kspace::LINEAR_MAPPING_VADDR_RANGE.contains(&vaddr)\") -> unwind unreachable;\n    }\n    bb5: {\n        _8 = move (_9.0: usize);\n        StorageLive(_10);\n        _10 = PtrMetadata(_1);\n        StorageLive(_11);\n        _11 = boot::memory_region::MemoryRegionType::Reclaimable;\n        _0 = MemoryRegion(move _8, move _10, move _11);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": " Constructs a module memory region from a byte slice that lives in the linear mapping.\n\n # Panics\n\n This method will panic if the byte slice does not live in the linear mapping.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}