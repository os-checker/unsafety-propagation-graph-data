{
  "name": "task::kernel_stack::KernelStack::new_with_guard_page",
  "safe": true,
  "callees": {
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_segment_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a contiguous range of frames with additional metadata.\n\n The returned [`Segment`] contains at least one frame. The method returns\n an error if the number of frames is zero.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "mm::page_prop::PrivilegedPageFlags::empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an empty set of flags.\n",
      "adt": {
        "mm::page_prop::PrivilegedPageFlags": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::kspace::kvirt_area::KVirtArea::map_frames": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a kernel virtual area and map tracked pages into it.\n\n The created virtual area will have a size of `area_size`, and the pages\n will be mapped starting from `map_offset` in the area.\n\n # Panics\n\n This function panics if\n  - the area size is not a multiple of [`PAGE_SIZE`];\n  - the map offset is not aligned to [`PAGE_SIZE`];\n  - the map offset plus the size of the pages exceeds the area size.\n",
      "adt": {
        "mm::kspace::kvirt_area::KVirtArea": "Constructor"
      }
    },
    "mm::kspace::kvirt_area::KVirtArea::range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::kspace::kvirt_area::KVirtArea": "ImmutableAsArgument",
        "core::ops::Range": "Constructor"
      }
    },
    "util::id_set::IdSet::<I>::new_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `IdSet` with no IDs in the system.\n",
      "adt": {
        "util::id_set::IdSet": "Constructor"
      }
    },
    "util::id_set::AtomicIdSet::<I>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `AtomicIdSet` from an `IdSet`.\n",
      "adt": {
        "util::id_set::AtomicIdSet": "Constructor"
      }
    }
  },
  "adts": {
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7288, kind: RigidTy(Adt(AdtDef(DefId { id: 3684, name: \"mm::frame::segment::Segment\" }), GenericArgs([Type(Ty { id: 7296, kind: RigidTy(Adt(AdtDef(DefId { id: 5957, name: \"task::kernel_stack::KernelStackMeta\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::frame::segment::Segment": [
      "Plain"
    ],
    "mm::page_prop::CachePolicy": [
      "Plain"
    ],
    "mm::page_prop::PrivilegedPageFlags": [
      "Plain"
    ],
    "mm::page_prop::PageProperty": [
      "Plain"
    ],
    "mm::kspace::kvirt_area::KVirtArea": [
      "Plain",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "util::id_set::IdSet": [
      "Plain"
    ],
    "util::id_set::AtomicIdSet": [
      "Plain"
    ],
    "task::kernel_stack::KernelStack": [
      "Plain"
    ]
  },
  "path": 2764,
  "span": "ostd/src/task/kernel_stack.rs:63:5: 85:6",
  "src": "pub(super) fn new_with_guard_page() -> Result<Self> {\n        let pages = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_segment_with(KERNEL_STACK_SIZE / PAGE_SIZE, |_| KernelStackMeta)?;\n        let prop = PageProperty {\n            flags: PageFlags::RW,\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        };\n        let new_kvirt_area = KVirtArea::map_frames(\n            KERNEL_STACK_SIZE + 4 * PAGE_SIZE,\n            2 * PAGE_SIZE,\n            pages.into_iter(),\n            prop,\n        );\n        let mapped_start = new_kvirt_area.range().start + 2 * PAGE_SIZE;\n        let mapped_end = mapped_start + KERNEL_STACK_SIZE;\n        Ok(Self {\n            kvirt_area: new_kvirt_area,\n            tlb_coherent: AtomicCpuSet::new(CpuSet::new_empty()),\n            end_vaddr: mapped_end,\n        })\n    }",
  "mir": "fn task::kernel_stack::KernelStack::new_with_guard_page() -> core::result::Result<task::kernel_stack::KernelStack, error::Error> {\n    let mut _0: core::result::Result<task::kernel_stack::KernelStack, error::Error>;\n    let mut _1: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>>;\n    let mut _2: core::result::Result<mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>, error::Error>;\n    let mut _3: &mm::frame::allocator::FrameAllocOptions;\n    let  _4: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _5: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _6: mm::frame::allocator::FrameAllocOptions;\n    let mut _7: usize;\n    let mut _8: bool;\n    let mut _9: isize;\n    let  _10: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _11: mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>;\n    let  _12: mm::page_prop::PageProperty;\n    let mut _13: mm::page_prop::CachePolicy;\n    let mut _14: mm::page_prop::PrivilegedPageFlags;\n    let  _15: mm::kspace::kvirt_area::KVirtArea;\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: (usize, bool);\n    let mut _19: (usize, bool);\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>;\n    let  _23: usize;\n    let mut _24: usize;\n    let mut _25: core::ops::Range<usize>;\n    let mut _26: &mm::kspace::kvirt_area::KVirtArea;\n    let mut _27: usize;\n    let mut _28: (usize, bool);\n    let mut _29: (usize, bool);\n    let  _30: usize;\n    let mut _31: (usize, bool);\n    let mut _32: task::kernel_stack::KernelStack;\n    let mut _33: util::id_set::AtomicIdSet<cpu::id::CpuId>;\n    let mut _34: util::id_set::IdSet<cpu::id::CpuId>;\n    debug pages => _11;\n    debug residual => _10;\n    debug val => _11;\n    debug prop => _12;\n    debug new_kvirt_area => _15;\n    debug mapped_start => _23;\n    debug mapped_end => _30;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &mut _6;\n        _4 = mm::frame::allocator::FrameAllocOptions::zeroed(move _5, false) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = &(*_4);\n        StorageDead(_5);\n        StorageLive(_7);\n        _8 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _8, \"attempt to divide `{}` by zero\", task::kernel_stack::KERNEL_STACK_SIZE) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = Div(task::kernel_stack::KERNEL_STACK_SIZE, mm::PAGE_SIZE);\n        _2 = mm::frame::allocator::FrameAllocOptions::alloc_segment_with::<task::kernel_stack::KernelStackMeta, {closure@ostd/src/task/kernel_stack.rs:66:64: 66:67}>(move _3, move _7, ZeroSized: {closure@ostd/src/task/kernel_stack.rs:66:64: 66:67}) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageDead(_3);\n        _1 = <core::result::Result<mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>, error::Error> as core::ops::Try>::branch(move _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        _9 = discriminant(_1);\n        switchInt(move _9) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _11 = move ((_1 as variant#0).0: mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>);\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageDead(_1);\n        StorageLive(_13);\n        _13 = mm::page_prop::CachePolicy::Writeback;\n        StorageLive(_14);\n        _14 = mm::page_prop::PrivilegedPageFlags::empty() -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _10 = ((_1 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<task::kernel_stack::KernelStack, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        StorageDead(_4);\n        StorageDead(_1);\n        goto -> bb22;\n    }\n    bb10: {\n        _12 = PageProperty(mm::page_prop::PageFlags::RW, move _13, move _14);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_16);\n        StorageLive(_17);\n        _18 = CheckedMul(4_usize, mm::PAGE_SIZE);\n        assert(!move (_18.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 4_usize, mm::PAGE_SIZE) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _17 = move (_18.0: usize);\n        _19 = CheckedAdd(task::kernel_stack::KERNEL_STACK_SIZE, _17);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", task::kernel_stack::KERNEL_STACK_SIZE, move _17) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _16 = move (_19.0: usize);\n        StorageDead(_17);\n        StorageLive(_20);\n        _21 = CheckedMul(2_usize, mm::PAGE_SIZE);\n        assert(!move (_21.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, mm::PAGE_SIZE) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _20 = move (_21.0: usize);\n        StorageLive(_22);\n        _22 = <mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta> as core::iter::IntoIterator>::into_iter(_11) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _15 = mm::kspace::kvirt_area::KVirtArea::map_frames::<task::kernel_stack::KernelStackMeta, mm::frame::segment::Segment<task::kernel_stack::KernelStackMeta>>(move _16, move _20, move _22, _12) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_22);\n        StorageDead(_20);\n        StorageDead(_16);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_15;\n        _25 = mm::kspace::kvirt_area::KVirtArea::range(move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _24 = (_25.0: usize);\n        StorageLive(_27);\n        _28 = CheckedMul(2_usize, mm::PAGE_SIZE);\n        assert(!move (_28.1: bool), \"attempt to compute `{} * {}`, which would overflow\", 2_usize, mm::PAGE_SIZE) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _27 = move (_28.0: usize);\n        _29 = CheckedAdd(_24, _27);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _24, move _27) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _23 = move (_29.0: usize);\n        StorageDead(_27);\n        StorageDead(_24);\n        StorageDead(_25);\n        _31 = CheckedAdd(_23, task::kernel_stack::KERNEL_STACK_SIZE);\n        assert(!move (_31.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _23, task::kernel_stack::KERNEL_STACK_SIZE) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        _30 = move (_31.0: usize);\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = util::id_set::IdSet::<cpu::id::CpuId>::new_empty() -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _33 = util::id_set::AtomicIdSet::<cpu::id::CpuId>::new(move _34) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_34);\n        _32 = KernelStack(_15, move _33, _30);\n        StorageDead(_33);\n        _0 = core::result::Result::Ok(move _32);\n        StorageDead(_32);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": " Generates a kernel stack with guard pages.\n\n 4 additional pages are allocated and regarded as guard pages, which\n should not be accessed.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}