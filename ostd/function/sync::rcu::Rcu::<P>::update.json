{
  "name": "sync::rcu::Rcu::<P>::update",
  "safe": true,
  "callees": {
    "sync::rcu::RcuInner::<P>::update": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::rcu::RcuInner": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sync::rcu::RcuInner": [
      "Ref"
    ],
    "sync::rcu::Rcu": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2611,
  "span": "ostd/src/sync/rcu/mod.rs:269:5: 271:6",
  "src": "pub fn update(&self, new_ptr: P) {\n        self.0.update(Some(new_ptr));\n    }",
  "mir": "fn sync::rcu::Rcu::<P>::update(_1: &sync::rcu::Rcu<P>, _2: P) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: &sync::rcu::RcuInner<P>;\n    let mut _5: core::option::Option<P>;\n    debug self => _1;\n    debug new_ptr => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &((*_1).0: sync::rcu::RcuInner<P>);\n        StorageLive(_5);\n        _5 = core::option::Option::Some(_2);\n        _3 = sync::rcu::RcuInner::<P>::update(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Replaces the current pointer with a null pointer.\n\n This function updates the pointer to the new pointer regardless of the\n original pointer. The original pointer will be dropped after the grace\n period.\n\n Oftentimes this function is not recommended unless you have serialized\n writes with locks. Otherwise, you can use [`Self::read`] and then\n [`RcuReadGuard::compare_exchange`] to update the pointer.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}