{
  "name": "boot::smp::boot_all_aps",
  "safe": false,
  "callees": {
    "cpu::id::CpuId::bsp": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the CPU ID of the bootstrap processor (BSP).\n\n The number for the BSP is always zero.\n",
      "adt": {
        "cpu::id::CpuId": "Constructor"
      }
    },
    "util::id_set::Id::as_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an [`usize`] from the [`Id`]'s corresponding [`u32`].\n",
      "adt": {}
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "boot::smp::report_online_and_hw_cpu_id": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "cpu::id::num_cpus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of CPUs.\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "spin::once::Once::<T, R>::is_completed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the value has been initialized.\n\n This is done using [`Acquire`](core::sync::atomic::Ordering::Acquire) ordering, and\n therefore it is safe to access the value directly via\n [`get_unchecked`](Self::get_unchecked) if this returns true.\n",
      "adt": {}
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_segment_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a contiguous range of frames with additional metadata.\n\n The returned [`Segment`] contains at least one frame. The method returns\n an error if the number of frames is zero.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "mm::frame::segment::Segment": "Constructor"
      }
    },
    "mm::mem_obj::HasPaddrRange::end_paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the end physical address of the memory object.\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "cpu::local::get_ap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the pointer to the static CPU-local storage for the given AP.\n\n # Panics\n\n This method will panic if the `cpu_id` does not represent an AP or the AP's CPU-local storage\n has not been allocated.\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "mm::page_table::boot_pt::with_borrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The accessor to the boot page table singleton [`BootPageTable`].\n\n The user should provide a closure to access the boot page table. The\n function will acquire the lock and call the closure with a mutable\n reference to the boot page table as the argument.\n\n The boot page table will be dropped when all CPUs have dismissed it.\n This function will return an [`Err`] if the boot page table is dropped.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "arch::boot::smp::bringup_all_aps": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Brings up all application processors.\n\n # Safety\n\n The caller must ensure that\n 1. we're in the boot context of the BSP,\n 2. all APs have not yet been booted, and\n 3. the arguments are valid to boot APs.\n",
      "adt": {}
    },
    "boot::smp::wait_for_all_aps_started": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "cpu::id::CpuId": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "alloc::vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "mm::frame::segment::Segment": [
      "Plain",
      "Ref"
    ],
    "boot::smp::PerApRawInfo": [
      "Plain"
    ],
    "boot::smp::PerApInfo": [
      "Plain"
    ],
    "boot::smp::ApBootInfo": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "alloc::boxed::Box": [
      "Plain",
      "Unknown([Field(0, Ty { id: 3081, kind: RigidTy(Adt(AdtDef(DefId { id: 3281, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 3108, kind: RigidTy(Slice(Ty { id: 453, kind: RigidTy(Adt(AdtDef(DefId { id: 4573, name: \"boot::smp::PerApRawInfo\" }), GenericArgs([]))) })) })]))) }), Field(0, Ty { id: 3082, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 3108, kind: RigidTy(Slice(Ty { id: 453, kind: RigidTy(Adt(AdtDef(DefId { id: 4573, name: \"boot::smp::PerApRawInfo\" }), GenericArgs([]))) })) })]))) })])"
    ]
  },
  "path": 1601,
  "span": "ostd/src/boot/smp.rs:72:1: 116:2",
  "src": "pub(crate) unsafe fn boot_all_aps() {\n    // Mark the BSP as started.\n    report_online_and_hw_cpu_id(crate::cpu::CpuId::bsp().as_usize().try_into().unwrap());\n\n    let num_cpus = crate::cpu::num_cpus();\n\n    if num_cpus == 1 {\n        return;\n    }\n    log::info!(\"Booting {} processors\", num_cpus - 1);\n\n    let mut per_ap_raw_info = Vec::with_capacity(num_cpus);\n    let mut per_ap_info = Vec::with_capacity(num_cpus);\n\n    for ap in 1..num_cpus {\n        let boot_stack_pages = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_segment_with(AP_BOOT_STACK_SIZE / PAGE_SIZE, |_| KernelMeta)\n            .unwrap();\n\n        per_ap_raw_info.push(PerApRawInfo {\n            stack_top: paddr_to_vaddr(boot_stack_pages.end_paddr()) as *mut u8,\n            cpu_local: paddr_to_vaddr(crate::cpu::local::get_ap(ap.try_into().unwrap())) as *mut u8,\n        });\n        per_ap_info.push(PerApInfo { boot_stack_pages });\n    }\n\n    assert!(!AP_BOOT_INFO.is_completed());\n    AP_BOOT_INFO.call_once(move || ApBootInfo {\n        per_ap_raw_info: per_ap_raw_info.into_boxed_slice(),\n        per_ap_info: per_ap_info.into_boxed_slice(),\n    });\n\n    log::info!(\"Booting all application processors...\");\n\n    let info_ptr = AP_BOOT_INFO.get().unwrap().per_ap_raw_info.as_ptr();\n    let pt_ptr = crate::mm::page_table::boot_pt::with_borrow(|pt| pt.root_address()).unwrap();\n    // SAFETY: It's the right time to boot APs (guaranteed by the caller) and\n    // the arguments are valid to boot APs (generated above).\n    unsafe { crate::arch::boot::smp::bringup_all_aps(info_ptr, pt_ptr, num_cpus as u32) };\n\n    wait_for_all_aps_started(num_cpus);\n\n    log::info!(\"All application processors started. The BSP continues to run.\");\n}",
  "mir": "fn boot::smp::boot_all_aps() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let mut _2: u32;\n    let mut _3: core::result::Result<u32, core::num::TryFromIntError>;\n    let mut _4: usize;\n    let mut _5: cpu::id::CpuId;\n    let  _6: usize;\n    let  _7: log::Level;\n    let mut _8: bool;\n    let mut _9: &log::Level;\n    let mut _10: &log::LevelFilter;\n    let mut _11: bool;\n    let mut _12: &log::Level;\n    let mut _13: &log::LevelFilter;\n    let  _14: log::LevelFilter;\n    let  _15: ();\n    let mut _16: core::fmt::Arguments<'_>;\n    let  _17: (&usize,);\n    let mut _18: &usize;\n    let  _19: usize;\n    let mut _20: (usize, bool);\n    let  _21: [core::fmt::rt::Argument<'_>; 1];\n    let mut _22: core::fmt::rt::Argument<'_>;\n    let mut _23: &[u8; 23];\n    let  _24: &[core::fmt::rt::Argument<'_>; 1];\n    let  _25: &(&str, &str, &core::panic::Location<'_>);\n    let  _26: (&str, &str, &core::panic::Location<'_>);\n    let mut _27: &str;\n    let  _28: &core::panic::Location<'_>;\n    let mut _29: alloc::vec::Vec<boot::smp::PerApRawInfo>;\n    let mut _30: alloc::vec::Vec<boot::smp::PerApInfo>;\n    let mut _31: core::ops::Range<usize>;\n    let mut _32: core::ops::Range<usize>;\n    let mut _33: core::ops::Range<usize>;\n    let mut _34: core::option::Option<usize>;\n    let mut _35: &mut core::ops::Range<usize>;\n    let mut _36: isize;\n    let  _37: usize;\n    let  _38: mm::frame::segment::Segment<mm::frame::meta::KernelMeta>;\n    let mut _39: core::result::Result<mm::frame::segment::Segment<mm::frame::meta::KernelMeta>, error::Error>;\n    let mut _40: &mm::frame::allocator::FrameAllocOptions;\n    let  _41: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _42: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _43: mm::frame::allocator::FrameAllocOptions;\n    let mut _44: usize;\n    let mut _45: bool;\n    let  _46: ();\n    let mut _47: &mut alloc::vec::Vec<boot::smp::PerApRawInfo>;\n    let mut _48: boot::smp::PerApRawInfo;\n    let mut _49: *mut u8;\n    let mut _50: usize;\n    let mut _51: usize;\n    let mut _52: &mm::frame::segment::Segment<mm::frame::meta::KernelMeta>;\n    let mut _53: *mut u8;\n    let mut _54: usize;\n    let mut _55: usize;\n    let mut _56: cpu::id::CpuId;\n    let mut _57: core::result::Result<cpu::id::CpuId, cpu::id::CpuIdFromIntError>;\n    let  _58: ();\n    let mut _59: &mut alloc::vec::Vec<boot::smp::PerApInfo>;\n    let mut _60: boot::smp::PerApInfo;\n    let mut _61: bool;\n    let mut _62: &spin::once::Once<boot::smp::ApBootInfo>;\n    let mut _63: !;\n    let  _64: &boot::smp::ApBootInfo;\n    let mut _65: &spin::once::Once<boot::smp::ApBootInfo>;\n    let mut _66: {closure@ostd/src/boot/smp.rs:100:28: 100:35};\n    let  _67: log::Level;\n    let mut _68: bool;\n    let mut _69: &log::Level;\n    let mut _70: &log::LevelFilter;\n    let mut _71: bool;\n    let mut _72: &log::Level;\n    let mut _73: &log::LevelFilter;\n    let  _74: log::LevelFilter;\n    let  _75: ();\n    let mut _76: core::fmt::Arguments<'_>;\n    let  _77: &(&str, &str, &core::panic::Location<'_>);\n    let  _78: (&str, &str, &core::panic::Location<'_>);\n    let mut _79: &str;\n    let  _80: &core::panic::Location<'_>;\n    let  _81: *const boot::smp::PerApRawInfo;\n    let mut _82: &[boot::smp::PerApRawInfo];\n    let  _83: &boot::smp::ApBootInfo;\n    let mut _84: core::option::Option<&boot::smp::ApBootInfo>;\n    let mut _85: &spin::once::Once<boot::smp::ApBootInfo>;\n    let  _86: usize;\n    let mut _87: core::result::Result<usize, ()>;\n    let  _88: ();\n    let mut _89: u32;\n    let  _90: ();\n    let  _91: log::Level;\n    let mut _92: bool;\n    let mut _93: &log::Level;\n    let mut _94: &log::LevelFilter;\n    let mut _95: bool;\n    let mut _96: &log::Level;\n    let mut _97: &log::LevelFilter;\n    let  _98: log::LevelFilter;\n    let  _99: ();\n    let mut _100: core::fmt::Arguments<'_>;\n    let  _101: &(&str, &str, &core::panic::Location<'_>);\n    let  _102: (&str, &str, &core::panic::Location<'_>);\n    let mut _103: &str;\n    let  _104: &core::panic::Location<'_>;\n    let mut _105: &usize;\n    let mut _106: alloc::boxed::Box<[boot::smp::PerApRawInfo]>;\n    let mut _107: *const [boot::smp::PerApRawInfo];\n    debug num_cpus => _6;\n    debug lvl => _7;\n    debug args => _17;\n    debug args => _21;\n    debug per_ap_raw_info => _29;\n    debug per_ap_info => _30;\n    debug iter => _33;\n    debug ap => _37;\n    debug boot_stack_pages => _38;\n    debug lvl => _67;\n    debug info_ptr => _81;\n    debug pt_ptr => _86;\n    debug lvl => _91;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = cpu::id::CpuId::bsp() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <cpu::id::CpuId as util::id_set::Id>::as_usize(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = <usize as core::convert::TryInto<u32>>::try_into(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _2 = core::result::Result::<u32, core::num::TryFromIntError>::unwrap(move _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        _1 = boot::smp::report_online_and_hw_cpu_id(move _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        _6 = cpu::id::num_cpus() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(_6) -> [1: bb7, otherwise: bb8];\n    }\n    bb7: {\n        goto -> bb76;\n    }\n    bb8: {\n        _7 = log::Level::Info;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_7;\n        StorageLive(_10);\n        _10 = boot::smp::boot_all_aps::promoted[2];\n        _8 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _9, move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _8) -> [0: bb20, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_7;\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = log::max_level() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _13 = &_14;\n        _11 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _12, move _13) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _11) -> [0: bb19, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = CheckedSub(_6, 1_usize);\n        assert(!move (_20.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, 1_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _19 = move (_20.0: usize);\n        _18 = &_19;\n        _17 = (move _18);\n        StorageDead(_18);\n        StorageLive(_21);\n        StorageLive(_22);\n        _105 = (_17.0: &usize);\n        _22 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_105) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _21 = [move _22];\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = b\"\\x08Booting \\xc0\\x0b processors\\x00\";\n        _24 = &_21;\n        _16 = core::fmt::Arguments::<'_>::new::<23, 1>(move _23, _24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = \"ostd::boot::smp\";\n        _28 = log::__private_api::loc() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _26 = (move _27, \"ostd::boot::smp\", _28);\n        StorageDead(_27);\n        _25 = &_26;\n        _15 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _16, _7, _25, ()) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_16);\n        StorageDead(_26);\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageDead(_17);\n        goto -> bb21;\n    }\n    bb19: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        goto -> bb21;\n    }\n    bb20: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageLive(_29);\n        _29 = alloc::vec::Vec::<boot::smp::PerApRawInfo>::with_capacity(_6) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_30);\n        _30 = alloc::vec::Vec::<boot::smp::PerApInfo>::with_capacity(_6) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = Range(1_usize, _6);\n        _31 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(move _32) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_32);\n        StorageLive(_33);\n        _33 = move _31;\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_34);\n        _35 = &mut _33;\n        _34 = <core::ops::Range<usize> as core::iter::Iterator>::next(_35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _36 = discriminant(_34);\n        switchInt(move _36) -> [0: bb29, 1: bb28, otherwise: bb27];\n    }\n    bb27: {\n        unreachable;\n    }\n    bb28: {\n        _37 = ((_34 as variant#1).0: usize);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb30, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_31);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = {alloc663: &spin::once::Once<boot::smp::ApBootInfo>};\n        _61 = spin::once::Once::<boot::smp::ApBootInfo>::is_completed(move _62) -> [return: bb43, unwind unreachable];\n    }\n    bb30: {\n        _42 = &mut _43;\n        _41 = mm::frame::allocator::FrameAllocOptions::zeroed(move _42, false) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _40 = &(*_41);\n        StorageDead(_42);\n        StorageLive(_44);\n        _45 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _45, \"attempt to divide `{}` by zero\", boot::smp::AP_BOOT_STACK_SIZE) -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        _44 = Div(boot::smp::AP_BOOT_STACK_SIZE, mm::PAGE_SIZE);\n        _39 = mm::frame::allocator::FrameAllocOptions::alloc_segment_with::<mm::frame::meta::KernelMeta, {closure@ostd/src/boot/smp.rs:89:65: 89:68}>(move _40, move _44, ZeroSized: {closure@ostd/src/boot/smp.rs:89:65: 89:68}) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_44);\n        StorageDead(_40);\n        _38 = core::result::Result::<mm::frame::segment::Segment<mm::frame::meta::KernelMeta>, error::Error>::unwrap(move _39) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_39);\n        StorageDead(_43);\n        StorageDead(_41);\n        StorageLive(_47);\n        _47 = &mut _29;\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &_38;\n        _51 = <mm::frame::segment::Segment<mm::frame::meta::KernelMeta> as mm::mem_obj::HasPaddrRange>::end_paddr(move _52) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_52);\n        _50 = mm::kspace::paddr_to_vaddr(move _51) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_51);\n        _49 = move _50 as *mut u8;\n        StorageDead(_50);\n        StorageLive(_53);\n        StorageLive(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = <usize as core::convert::TryInto<cpu::id::CpuId>>::try_into(_37) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _56 = core::result::Result::<cpu::id::CpuId, cpu::id::CpuIdFromIntError>::unwrap(move _57) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_57);\n        _55 = cpu::local::get_ap(move _56) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_56);\n        _54 = mm::kspace::paddr_to_vaddr(move _55) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_55);\n        _53 = move _54 as *mut u8;\n        StorageDead(_54);\n        _48 = PerApRawInfo(move _49, move _53);\n        StorageDead(_53);\n        StorageDead(_49);\n        _46 = alloc::vec::Vec::<boot::smp::PerApRawInfo>::push(move _47, move _48) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageLive(_59);\n        _59 = &mut _30;\n        StorageLive(_60);\n        _60 = PerApInfo(_38);\n        _58 = alloc::vec::Vec::<boot::smp::PerApInfo>::push(move _59, move _60) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_34);\n        goto -> bb25;\n    }\n    bb43: {\n        switchInt(move _61) -> [0: bb45, otherwise: bb44];\n    }\n    bb44: {\n        StorageDead(_62);\n        _63 = core::panicking::panic(\"assertion failed: !AP_BOOT_INFO.is_completed()\") -> unwind unreachable;\n    }\n    bb45: {\n        StorageDead(_62);\n        StorageDead(_61);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = {alloc663: &spin::once::Once<boot::smp::ApBootInfo>};\n        StorageLive(_66);\n        _66 = {closure@ostd/src/boot/smp.rs:100:28: 100:35}(move _29, move _30);\n        _64 = spin::once::Once::<boot::smp::ApBootInfo>::call_once::<{closure@ostd/src/boot/smp.rs:100:28: 100:35}>(move _65, move _66) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_66);\n        StorageDead(_65);\n        StorageDead(_64);\n        _67 = log::Level::Info;\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = &_67;\n        StorageLive(_70);\n        _70 = boot::smp::boot_all_aps::promoted[1];\n        _68 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _69, move _70) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        switchInt(move _68) -> [0: bb56, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = &_67;\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = log::max_level() -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _73 = &_74;\n        _71 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _72, move _73) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        switchInt(move _71) -> [0: bb55, otherwise: bb51];\n    }\n    bb51: {\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageDead(_72);\n        StorageLive(_76);\n        _76 = core::fmt::Arguments::<'_>::from_str(\"Booting all application processors...\") -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageLive(_78);\n        StorageLive(_79);\n        _79 = \"ostd::boot::smp\";\n        _80 = log::__private_api::loc() -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        _78 = (move _79, \"ostd::boot::smp\", _80);\n        StorageDead(_79);\n        _77 = &_78;\n        _75 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _76, _67, _77, ()) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_76);\n        StorageDead(_78);\n        goto -> bb57;\n    }\n    bb55: {\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageDead(_72);\n        goto -> bb57;\n    }\n    bb56: {\n        StorageDead(_70);\n        StorageDead(_69);\n        goto -> bb57;\n    }\n    bb57: {\n        StorageDead(_71);\n        StorageDead(_68);\n        StorageLive(_82);\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = {alloc663: &spin::once::Once<boot::smp::ApBootInfo>};\n        _84 = spin::once::Once::<boot::smp::ApBootInfo>::get(move _85) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_85);\n        _83 = core::option::Option::<&boot::smp::ApBootInfo>::unwrap(move _84) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_84);\n        _106 = ((*_83).0: alloc::boxed::Box<[boot::smp::PerApRawInfo]>);\n        _107 = ((_106.0: core::ptr::Unique<[boot::smp::PerApRawInfo]>).0: core::ptr::NonNull<[boot::smp::PerApRawInfo]>) as *const [boot::smp::PerApRawInfo];\n        _82 = &(*_107);\n        _81 = core::slice::<impl [boot::smp::PerApRawInfo]>::as_ptr(move _82) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_82);\n        StorageDead(_83);\n        StorageLive(_87);\n        _87 = mm::page_table::boot_pt::with_borrow::<{closure@ostd/src/boot/smp.rs:108:62: 108:66}, usize>(ZeroSized: {closure@ostd/src/boot/smp.rs:108:62: 108:66}) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        _86 = core::result::Result::<usize, ()>::unwrap(move _87) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_87);\n        StorageLive(_89);\n        _89 = _6 as u32;\n        _88 = arch::boot::smp::bringup_all_aps(_81, _86, move _89) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_89);\n        _90 = boot::smp::wait_for_all_aps_started(_6) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        _91 = log::Level::Info;\n        StorageLive(_92);\n        StorageLive(_93);\n        _93 = &_91;\n        StorageLive(_94);\n        _94 = boot::smp::boot_all_aps::promoted[0];\n        _92 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _93, move _94) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        switchInt(move _92) -> [0: bb74, otherwise: bb66];\n    }\n    bb66: {\n        StorageDead(_94);\n        StorageDead(_93);\n        StorageLive(_95);\n        StorageLive(_96);\n        _96 = &_91;\n        StorageLive(_97);\n        StorageLive(_98);\n        _98 = log::max_level() -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        _97 = &_98;\n        _95 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _96, move _97) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        switchInt(move _95) -> [0: bb73, otherwise: bb69];\n    }\n    bb69: {\n        StorageDead(_98);\n        StorageDead(_97);\n        StorageDead(_96);\n        StorageLive(_100);\n        _100 = core::fmt::Arguments::<'_>::from_str(\"All application processors started. The BSP continues to run.\") -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = \"ostd::boot::smp\";\n        _104 = log::__private_api::loc() -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        _102 = (move _103, \"ostd::boot::smp\", _104);\n        StorageDead(_103);\n        _101 = &_102;\n        _99 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _100, _91, _101, ()) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        StorageDead(_100);\n        StorageDead(_102);\n        goto -> bb75;\n    }\n    bb73: {\n        StorageDead(_98);\n        StorageDead(_97);\n        StorageDead(_96);\n        goto -> bb75;\n    }\n    bb74: {\n        StorageDead(_94);\n        StorageDead(_93);\n        goto -> bb75;\n    }\n    bb75: {\n        StorageDead(_95);\n        StorageDead(_92);\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb76;\n    }\n    bb76: {\n        return;\n    }\n}\n",
  "doc": " Boots all application processors.\n\n This function should be called late in the system startup. The system must at\n least ensure that the scheduler, ACPI table, memory allocation, and IPI module\n have been initialized.\n\n # Safety\n\n This function can only be called in the boot context of the BSP where APs have\n not yet been booted.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}