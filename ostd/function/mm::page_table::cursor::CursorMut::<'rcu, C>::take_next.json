{
  "name": "mm::page_table::cursor::CursorMut::<'rcu, C>::take_next",
  "safe": false,
  "callees": {
    "mm::page_table::cursor::Cursor::<'rcu, C>::find_next_impl": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves the cursor forward to the next fragment in the range.\n\n See [`Self::find_next`] for more details. Other than the semantics\n provided by [`Self::find_next`], this method also supports finding non-\n leaf entries and splitting huge pages if necessary.\n\n `find_unmap_subtree` specifies whether the cursor should stop at the\n highest possible level for unmapping. If `false`, the cursor will only\n stop at leaf entries.\n\n `split_huge` specifies whether the cursor should split huge pages when\n it finds a huge page that is mapped over the required range (`len`).\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "mm::page_table::cursor::CursorMut::<'rcu, C>::replace_cur_entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::page_table::cursor::CursorMut": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "mm::page_table::cursor::Cursor::<'rcu, C>::move_forward": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Traverses forward to the end of [`Self::cur_va_range`].\n\n If reached the end of the current page table node, it (recursively)\n moves itself up to the next page of the parent page.\n",
      "adt": {
        "mm::page_table::cursor::Cursor": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::page_table::cursor::Cursor": [
      "MutRef"
    ],
    "mm::page_table::cursor::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "mm::page_table::node::child::Child": [
      "Plain"
    ]
  },
  "path": 2368,
  "span": "ostd/src/mm/page_table/cursor/mod.rs:534:5: 542:6",
  "src": "pub unsafe fn take_next(&mut self, len: usize) -> Option<PageTableFrag<C>> {\n        self.0.find_next_impl(len, true, true)?;\n\n        let frag = self.replace_cur_entry(Child::None);\n\n        self.0.move_forward();\n\n        frag\n    }",
  "mir": "fn mm::page_table::cursor::CursorMut::<'rcu, C>::take_next(_1: &mut mm::page_table::cursor::CursorMut<'_, C>, _2: usize) -> core::option::Option<mm::page_table::cursor::PageTableFrag<C>> {\n    let mut _0: core::option::Option<mm::page_table::cursor::PageTableFrag<C>>;\n    let mut _3: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;\n    let mut _4: core::option::Option<usize>;\n    let mut _5: &mut mm::page_table::cursor::Cursor<'_, C>;\n    let mut _6: isize;\n    let  _7: usize;\n    let  _8: core::option::Option<mm::page_table::cursor::PageTableFrag<C>>;\n    let mut _9: mm::page_table::node::child::Child<C>;\n    let  _10: ();\n    let mut _11: &mut mm::page_table::cursor::Cursor<'_, C>;\n    debug self => _1;\n    debug len => _2;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _7;\n    debug frag => _8;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _4 = mm::page_table::cursor::Cursor::<'_, C>::find_next_impl(move _5, _2, true, true) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = <core::option::Option<usize> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = ((_3 as variant#0).0: usize);\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = mm::page_table::node::child::Child::None;\n        _8 = mm::page_table::cursor::CursorMut::<'_, C>::replace_cur_entry(_1, move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::option::Option<mm::page_table::cursor::PageTableFrag<C>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        goto -> bb9;\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = &mut ((*_1).0: mm::page_table::cursor::Cursor<'_, C>);\n        _10 = mm::page_table::cursor::Cursor::<'_, C>::move_forward(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _0 = move _8;\n        StorageDead(_8);\n        goto -> bb9;\n    }\n    bb9: {\n        return;\n    }\n}\n",
  "doc": " Finds and removes the first page table fragment in the following range.\n\n The range to be found in is the current virtual address with the\n provided length.\n\n The function stops and yields the fragment if it has actually removed a\n fragment, no matter if the following pages are also required to be\n unmapped. The returned virtual address is the virtual page that existed\n before the removal but having just been unmapped.\n\n It also makes the cursor moves forward to the next page after the\n removed one, when an actual page is removed. If no mapped pages exist\n in the following range, the cursor will stop at the end of the range\n and return [`None`].\n\n The caller should handle TLB coherence if necessary, using the returned\n virtual address range.\n\n # Safety\n\n The caller should ensure that the range being unmapped does not affect\n kernel's memory safety.\n\n # Panics\n\n Panics if:\n  - the length is longer than the remaining range of the cursor;\n  - the length is not page-aligned.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}