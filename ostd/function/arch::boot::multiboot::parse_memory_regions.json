{
  "name": "arch::boot::multiboot::parse_memory_regions",
  "safe": true,
  "callees": {
    "boot::memory_region::MemoryRegionArray::<LEN>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs an empty set.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "Constructor"
      }
    },
    "arch::boot::multiboot::MultibootLegacyInfo::get_memory_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MultibootLegacyInfo": "ImmutableAsArgument",
        "arch::boot::multiboot::MemoryEntryIter": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "arch::boot::multiboot::MemoryEntry::base_addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MemoryEntry": "ImmutableAsArgument"
      }
    },
    "arch::boot::multiboot::parse_framebuffer_info": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MultibootLegacyInfo": "ImmutableAsArgument",
        "core::option::Option": "Constructor",
        "boot::BootloaderFramebufferArg": "Constructor"
      }
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "arch::boot::multiboot::MemoryEntry::length": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MemoryEntry": "ImmutableAsArgument"
      }
    },
    "arch::boot::multiboot::MemoryEntry::memory_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MemoryEntry": "ImmutableAsArgument",
        "boot::memory_region::MemoryRegionType": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a valid memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegionArray::<LEN>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends a region to the set.\n\n If the set is full, an error is returned.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::framebuffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a framebuffer memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor",
        "boot::BootloaderFramebufferArg": "ImmutableAsArgument"
      }
    },
    "boot::memory_region::MemoryRegion::kernel": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a memory region where kernel sections are loaded.\n\n Most boot protocols do not mark the place where the kernel loads as unusable. In this case,\n we need to explicitly construct and append this memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::multiboot::parse_initramfs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MultibootLegacyInfo": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::module": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a module memory region from a byte slice that lives in the linear mapping.\n\n # Panics\n\n This method will panic if the byte slice does not live in the linear mapping.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::smp::reclaimable_memory_region": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::multiboot::parse_kernel_commandline": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MultibootLegacyInfo": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "arch::boot::multiboot::parse_bootloader_name": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::boot::multiboot::MultibootLegacyInfo": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegionArray::<LEN>::into_non_overlapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the regions and returns a full set of non-overlapping regions.\n\n If an address is in multiple regions, the region with the lowest\n usability will be its type.\n\n All the addresses between 0 and the end of the last region will be in\n the resulting set. If an address is not in any region, it will be marked\n as [`MemoryRegionType::Unknown`].\n\n If any of the region boundaries are not page-aligned, they will be aligned\n according to the type of the region.\n\n # Panics\n\n This method will panic if the number of output regions is greater than `LEN`.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "Constructor"
      }
    }
  },
  "adts": {
    "boot::memory_region::MemoryRegionArray": [
      "Plain",
      "MutRef"
    ],
    "arch::boot::multiboot::MultibootLegacyInfo": [
      "Ref"
    ],
    "arch::boot::multiboot::MemoryEntryIter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 199, kind: RigidTy(Adt(AdtDef(DefId { id: 2906, name: \"arch::boot::multiboot::MemoryEntry\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 73, kind: RigidTy(Adt(AdtDef(DefId { id: 2784, name: \"boot::BootloaderFramebufferArg\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 23, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 33, kind: RigidTy(Slice(Ty { id: 1, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 4, kind: RigidTy(Str) }, Not)) })])"
    ],
    "arch::boot::multiboot::MemoryEntry": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegionType": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegion": [
      "Plain"
    ],
    "boot::BootloaderFramebufferArg": [
      "Plain",
      "Ref"
    ]
  },
  "path": 137,
  "span": "ostd/src/arch/x86/boot/multiboot/mod.rs:78:1: 122:2",
  "src": "fn parse_memory_regions(mb1_info: &MultibootLegacyInfo) -> MemoryRegionArray {\n    let mut regions = MemoryRegionArray::new();\n\n    // Add the regions in the multiboot protocol.\n    for entry in mb1_info.get_memory_map() {\n        let region = MemoryRegion::new(\n            entry.base_addr().try_into().unwrap(),\n            entry.length().try_into().unwrap(),\n            entry.memory_type(),\n        );\n        regions.push(region).unwrap();\n    }\n\n    // Add the framebuffer region.\n    if let Some(fb) = parse_framebuffer_info(mb1_info) {\n        regions.push(MemoryRegion::framebuffer(&fb)).unwrap();\n    }\n\n    // Add the kernel region.\n    regions.push(MemoryRegion::kernel()).unwrap();\n\n    // Add the initramfs region.\n    if let Some(initramfs) = parse_initramfs(mb1_info) {\n        regions.push(MemoryRegion::module(initramfs)).unwrap();\n    }\n\n    // Add the AP boot code region that will be copied into by the BSP.\n    regions\n        .push(super::smp::reclaimable_memory_region())\n        .unwrap();\n\n    // Add the kernel cmdline and boot loader name region since Grub does not specify it.\n    if let Some(kcmdline) = parse_kernel_commandline(mb1_info) {\n        regions\n            .push(MemoryRegion::module(kcmdline.as_bytes()))\n            .unwrap();\n    }\n    if let Some(bootloader_name) = parse_bootloader_name(mb1_info) {\n        regions\n            .push(MemoryRegion::module(bootloader_name.as_bytes()))\n            .unwrap();\n    }\n\n    regions.into_non_overlapping()\n}",
  "mir": "fn arch::boot::multiboot::parse_memory_regions(_1: &arch::boot::multiboot::MultibootLegacyInfo) -> boot::memory_region::MemoryRegionArray<512> {\n    let mut _0: boot::memory_region::MemoryRegionArray<512>;\n    let mut _2: boot::memory_region::MemoryRegionArray<512>;\n    let mut _3: arch::boot::multiboot::MemoryEntryIter;\n    let mut _4: arch::boot::multiboot::MemoryEntryIter;\n    let mut _5: arch::boot::multiboot::MemoryEntryIter;\n    let mut _6: core::option::Option<arch::boot::multiboot::MemoryEntry>;\n    let mut _7: &mut arch::boot::multiboot::MemoryEntryIter;\n    let mut _8: isize;\n    let  _9: arch::boot::multiboot::MemoryEntry;\n    let  _10: boot::memory_region::MemoryRegion;\n    let mut _11: usize;\n    let mut _12: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _13: u64;\n    let mut _14: &arch::boot::multiboot::MemoryEntry;\n    let mut _15: usize;\n    let mut _16: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _17: u64;\n    let mut _18: &arch::boot::multiboot::MemoryEntry;\n    let mut _19: boot::memory_region::MemoryRegionType;\n    let mut _20: &arch::boot::multiboot::MemoryEntry;\n    let  _21: ();\n    let mut _22: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _23: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _24: core::option::Option<boot::BootloaderFramebufferArg>;\n    let mut _25: isize;\n    let  _26: boot::BootloaderFramebufferArg;\n    let  _27: ();\n    let mut _28: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _29: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _30: boot::memory_region::MemoryRegion;\n    let  _31: &boot::BootloaderFramebufferArg;\n    let  _32: ();\n    let mut _33: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _34: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _35: boot::memory_region::MemoryRegion;\n    let mut _36: core::option::Option<&[u8]>;\n    let mut _37: isize;\n    let  _38: &[u8];\n    let  _39: ();\n    let mut _40: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _41: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _42: boot::memory_region::MemoryRegion;\n    let  _43: ();\n    let mut _44: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _45: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _46: boot::memory_region::MemoryRegion;\n    let mut _47: core::option::Option<&str>;\n    let mut _48: isize;\n    let  _49: &str;\n    let  _50: ();\n    let mut _51: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _52: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _53: boot::memory_region::MemoryRegion;\n    let  _54: &[u8];\n    let mut _55: core::option::Option<&str>;\n    let mut _56: isize;\n    let  _57: &str;\n    let  _58: ();\n    let mut _59: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _60: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _61: boot::memory_region::MemoryRegion;\n    let  _62: &[u8];\n    let mut _63: boot::memory_region::MemoryRegionArray<512>;\n    debug mb1_info => _1;\n    debug regions => _2;\n    debug iter => _5;\n    debug entry => _9;\n    debug region => _10;\n    debug fb => _26;\n    debug initramfs => _38;\n    debug kcmdline => _49;\n    debug bootloader_name => _57;\n    bb0: {\n        StorageLive(_2);\n        _2 = boot::memory_region::MemoryRegionArray::<512>::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = arch::boot::multiboot::MultibootLegacyInfo::get_memory_map(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = <arch::boot::multiboot::MemoryEntryIter as core::iter::IntoIterator>::into_iter(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = _3;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_6);\n        _7 = &mut _5;\n        _6 = <arch::boot::multiboot::MemoryEntryIter as core::iter::Iterator>::next(_7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = discriminant(_6);\n        switchInt(move _8) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageLive(_9);\n        _9 = move ((_6 as variant#1).0: arch::boot::multiboot::MemoryEntry);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_9;\n        _13 = arch::boot::multiboot::MemoryEntry::base_addr(move _14) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageLive(_24);\n        _24 = arch::boot::multiboot::parse_framebuffer_info(_1) -> [return: bb19, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        _12 = <u64 as core::convert::TryInto<usize>>::try_into(move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        _11 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap(move _12) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_9;\n        _17 = arch::boot::multiboot::MemoryEntry::length(move _18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_18);\n        _16 = <u64 as core::convert::TryInto<usize>>::try_into(move _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        _15 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap(move _16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_9;\n        _19 = arch::boot::multiboot::MemoryEntry::memory_type(move _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        _10 = boot::memory_region::MemoryRegion::new(move _11, move _15, move _19) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_19);\n        StorageDead(_15);\n        StorageDead(_11);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &mut _2;\n        _22 = boot::memory_region::MemoryRegionArray::<512>::push(move _23, _10) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_23);\n        _21 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _22) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_22);\n        StorageDead(_9);\n        StorageDead(_6);\n        goto -> bb4;\n    }\n    bb19: {\n        _25 = discriminant(_24);\n        switchInt(move _25) -> [1: bb20, 0: bb24, otherwise: bb6];\n    }\n    bb20: {\n        StorageLive(_26);\n        _26 = ((_24 as variant#1).0: boot::BootloaderFramebufferArg);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &mut _2;\n        StorageLive(_30);\n        _31 = &_26;\n        _30 = boot::memory_region::MemoryRegion::framebuffer(_31) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _28 = boot::memory_region::MemoryRegionArray::<512>::push(move _29, move _30) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageDead(_29);\n        _27 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _28) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_28);\n        StorageDead(_26);\n        StorageDead(_24);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_24);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _2;\n        StorageLive(_35);\n        _35 = boot::memory_region::MemoryRegion::kernel() -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _33 = boot::memory_region::MemoryRegionArray::<512>::push(move _34, move _35) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_35);\n        StorageDead(_34);\n        _32 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _33) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_33);\n        StorageLive(_36);\n        _36 = arch::boot::multiboot::parse_initramfs(_1) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _37 = discriminant(_36);\n        switchInt(move _37) -> [1: bb30, 0: bb34, otherwise: bb6];\n    }\n    bb30: {\n        _38 = ((_36 as variant#1).0: &[u8]);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = &mut _2;\n        StorageLive(_42);\n        _42 = boot::memory_region::MemoryRegion::module(_38) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _40 = boot::memory_region::MemoryRegionArray::<512>::push(move _41, move _42) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_42);\n        StorageDead(_41);\n        _39 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _40) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_40);\n        StorageDead(_36);\n        goto -> bb35;\n    }\n    bb34: {\n        StorageDead(_36);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &mut _2;\n        StorageLive(_46);\n        _46 = arch::boot::smp::reclaimable_memory_region() -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _44 = boot::memory_region::MemoryRegionArray::<512>::push(move _45, move _46) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_46);\n        StorageDead(_45);\n        _43 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _44) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_44);\n        StorageLive(_47);\n        _47 = arch::boot::multiboot::parse_kernel_commandline(_1) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _48 = discriminant(_47);\n        switchInt(move _48) -> [1: bb40, 0: bb45, otherwise: bb6];\n    }\n    bb40: {\n        _49 = ((_47 as variant#1).0: &str);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &mut _2;\n        StorageLive(_53);\n        _54 = core::str::<impl str>::as_bytes(_49) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _53 = boot::memory_region::MemoryRegion::module(_54) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        _51 = boot::memory_region::MemoryRegionArray::<512>::push(move _52, move _53) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_53);\n        StorageDead(_52);\n        _50 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _51) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_51);\n        StorageDead(_47);\n        goto -> bb46;\n    }\n    bb45: {\n        StorageDead(_47);\n        goto -> bb46;\n    }\n    bb46: {\n        StorageLive(_55);\n        _55 = arch::boot::multiboot::parse_bootloader_name(_1) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _56 = discriminant(_55);\n        switchInt(move _56) -> [1: bb48, 0: bb53, otherwise: bb6];\n    }\n    bb48: {\n        _57 = ((_55 as variant#1).0: &str);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &mut _2;\n        StorageLive(_61);\n        _62 = core::str::<impl str>::as_bytes(_57) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        _61 = boot::memory_region::MemoryRegion::module(_62) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        _59 = boot::memory_region::MemoryRegionArray::<512>::push(move _60, move _61) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_61);\n        StorageDead(_60);\n        _58 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _59) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_59);\n        StorageDead(_55);\n        goto -> bb54;\n    }\n    bb53: {\n        StorageDead(_55);\n        goto -> bb54;\n    }\n    bb54: {\n        StorageLive(_63);\n        _63 = move _2;\n        _0 = boot::memory_region::MemoryRegionArray::<512>::into_non_overlapping(move _63) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_63);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}