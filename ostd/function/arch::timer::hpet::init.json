{
  "name": "arch::timer::hpet::init",
  "safe": true,
  "callees": {
    "arch::kernel::acpi::get_acpi_tables": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "acpi::AcpiTables": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "acpi::HpetInfo::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull` if `ptr` is non-null.\n\n # Panics during const evaluation\n\n This method will panic during const evaluation if the pointer cannot be\n determined to be null or not. See [`is_null`] for more information.\n\n [`is_null`]: ../primitive.pointer.html#method.is_null-1\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::<u32>::new(&mut x as *mut _).expect(\"ptr is null!\");\n\n if let Some(ptr) = NonNull::<u32>::new(std::ptr::null_mut()) {\n     unreachable!();\n }\n ```\n",
      "adt": {}
    },
    "arch::timer::hpet::Hpet::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller must ensure that the address is valid and points to the HPET MMIO region.\n",
      "adt": {
        "arch::timer::hpet::Hpet": "Constructor"
      }
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "acpi::AcpiTables": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 2676, kind: RigidTy(Adt(AdtDef(DefId { id: 4379, name: \"acpi::HpetInfo\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2678, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 430, kind: RigidTy(Adt(AdtDef(DefId { id: 4385, name: \"acpi::AcpiError\" }), GenericArgs([]))) })]))) })])"
    ],
    "acpi::HpetInfo": [
      "Plain",
      "Unknown([Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "arch::timer::hpet::Hpet": [
      "Plain",
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": 1512,
  "span": "ostd/src/arch/x86/timer/hpet.rs:138:1: 150:2",
  "src": "pub fn init() -> Result<(), AcpiError> {\n    let tables = get_acpi_tables().unwrap();\n\n    let hpet_info = HpetInfo::new(&tables)?;\n    assert_ne!(hpet_info.base_address, 0, \"HPET address should not be zero\");\n\n    let base = NonNull::new(paddr_to_vaddr(hpet_info.base_address) as *mut u8).unwrap();\n    // SAFETY: The base address is from the ACPI table and points to the HPET MMIO region.\n    let hpet = unsafe { Hpet::new(base) };\n    HPET_INSTANCE.call_once(|| hpet);\n\n    Ok(())\n}",
  "mir": "fn arch::timer::hpet::init() -> core::result::Result<(), acpi::AcpiError> {\n    let mut _0: core::result::Result<(), acpi::AcpiError>;\n    let  _1: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _2: core::option::Option<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>;\n    let  _3: acpi::HpetInfo;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, acpi::AcpiError>, acpi::HpetInfo>;\n    let mut _5: core::result::Result<acpi::HpetInfo, acpi::AcpiError>;\n    let  _6: &acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _7: isize;\n    let  _8: core::result::Result<core::convert::Infallible, acpi::AcpiError>;\n    let  _9: acpi::HpetInfo;\n    let mut _10: (&usize, &usize);\n    let mut _11: &usize;\n    let mut _12: &usize;\n    let  _13: &usize;\n    let  _14: &usize;\n    let mut _15: bool;\n    let mut _16: usize;\n    let mut _17: usize;\n    let  _18: core::panicking::AssertKind;\n    let  _19: !;\n    let mut _20: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _21: core::fmt::Arguments<'_>;\n    let  _22: core::ptr::NonNull<u8>;\n    let mut _23: core::option::Option<core::ptr::NonNull<u8>>;\n    let mut _24: *mut u8;\n    let mut _25: usize;\n    let mut _26: usize;\n    let  _27: arch::timer::hpet::Hpet;\n    let  _28: &arch::timer::hpet::Hpet;\n    let mut _29: &spin::once::Once<arch::timer::hpet::Hpet>;\n    let mut _30: {closure@ostd/src/arch/x86/timer/hpet.rs:147:29: 147:31};\n    debug tables => _1;\n    debug hpet_info => _3;\n    debug residual => _8;\n    debug val => _9;\n    debug left_val => _13;\n    debug right_val => _14;\n    debug kind => _18;\n    debug base => _22;\n    debug hpet => _27;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        _2 = arch::kernel::acpi::get_acpi_tables() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = core::option::Option::<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>::unwrap(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _6 = &_1;\n        _5 = acpi::HpetInfo::new::<arch::kernel::acpi::AcpiMemoryHandler>(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = <core::result::Result<acpi::HpetInfo, acpi::AcpiError> as core::ops::Try>::branch(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        _7 = discriminant(_4);\n        switchInt(move _7) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_9);\n        _9 = move ((_4 as variant#0).0: acpi::HpetInfo);\n        _3 = move _9;\n        StorageDead(_9);\n        StorageDead(_4);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(_3.1: usize);\n        StorageLive(_12);\n        _12 = arch::timer::hpet::init::promoted[0];\n        _10 = (move _11, move _12);\n        StorageDead(_12);\n        StorageDead(_11);\n        _13 = (_10.0: &usize);\n        _14 = (_10.1: &usize);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = (*_13);\n        StorageLive(_17);\n        _17 = (*_14);\n        _15 = Eq(move _16, move _17);\n        switchInt(move _15) -> [0: bb10, otherwise: bb9];\n    }\n    bb7: {\n        _8 = move ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, acpi::AcpiError>);\n        _0 = <core::result::Result<(), acpi::AcpiError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, acpi::AcpiError>>>::from_residual(_8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_4);\n        StorageDead(_3);\n        drop(_1) -> [return: bb18, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _18 = core::panicking::AssertKind::Ne;\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = core::fmt::Arguments::<'_>::from_str(\"HPET address should not be zero\") -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_10);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = (_3.1: usize);\n        _25 = mm::kspace::paddr_to_vaddr(move _26) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        _20 = core::option::Option::Some(move _21);\n        StorageDead(_21);\n        _19 = core::panicking::assert_failed::<usize, usize>(_18, _13, _14, move _20) -> unwind unreachable;\n    }\n    bb12: {\n        StorageDead(_26);\n        _24 = move _25 as *mut u8;\n        StorageDead(_25);\n        _23 = core::ptr::NonNull::<u8>::new(move _24) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_24);\n        _22 = core::option::Option::<core::ptr::NonNull<u8>>::unwrap(move _23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageLive(_27);\n        _27 = arch::timer::hpet::Hpet::new(_22) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = {alloc564: &spin::once::Once<arch::timer::hpet::Hpet>};\n        StorageLive(_30);\n        _30 = {closure@ostd/src/arch/x86/timer/hpet.rs:147:29: 147:31}(move _27);\n        _28 = spin::once::Once::<arch::timer::hpet::Hpet>::call_once::<{closure@ostd/src/arch/x86/timer/hpet.rs:147:29: 147:31}>(move _29, move _30) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        _0 = core::result::Result::Ok(());\n        StorageDead(_27);\n        StorageDead(_3);\n        drop(_1) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_1);\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_1);\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": " HPET init, need to init IOAPIC before init this function\n",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "dead_code"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* dead_code\n"
    ]
  }
}