{
  "name": "arch::trap::init_on_cpu",
  "safe": false,
  "callees": {
    "arch::trap::gdt::init_on_cpu": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes and loads the GDT and TSS.\n\n The caller should only call this method once in the boot context for each available processor.\n This is not a safety requirement, however, because calling this method again will do nothing\n more than load the GDT and TSS with the same contents.\n\n # Safety\n\n The caller must ensure that no preemption can occur during the method, otherwise we may\n accidentally load a wrong GDT and TSS that actually belongs to another CPU.\n",
      "adt": {}
    },
    "arch::trap::idt::init_on_cpu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes and loads the IDT.\n\n The caller should only call this method once in the boot context for each available processor.\n This is not a safety requirement, however, because calling this method again will do nothing\n more than load the same IDT.\n",
      "adt": {}
    },
    "arch::trap::syscall::init_on_cpu": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller needs to ensure that `gdt::init_on_cpu` has been called before,\n so the segment selectors used in the `syscall` and `sysret` instructions\n have been properly initialized.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 1541,
  "span": "ostd/src/arch/x86/trap/mod.rs:114:1: 122:2",
  "src": "pub(crate) unsafe fn init_on_cpu() {\n    // SAFETY: Since there's no traps, no preemption can occur.\n    unsafe { gdt::init_on_cpu() };\n\n    idt::init_on_cpu();\n\n    // SAFETY: `gdt::init_on_cpu` has been called before.\n    unsafe { syscall::init_on_cpu() };\n}",
  "mir": "fn arch::trap::init_on_cpu() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let  _2: ();\n    let  _3: ();\n    bb0: {\n        _1 = arch::trap::gdt::init_on_cpu() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = arch::trap::idt::init_on_cpu() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = arch::trap::syscall::init_on_cpu() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        return;\n    }\n}\n",
  "doc": " Initializes interrupt handling on x86_64.\n\n This function will:\n - Switch to a new, CPU-local [GDT].\n - Switch to a new, CPU-local [TSS].\n - Switch to a new, global [IDT].\n - Enable the [`syscall`] instruction.\n\n [GDT]: https://wiki.osdev.org/GDT\n [IDT]: https://wiki.osdev.org/IDT\n [TSS]: https://wiki.osdev.org/Task_State_Segment\n [`syscall`]: https://www.felixcloutier.com/x86/syscall\n\n # Safety\n\n On the current CPU, this function must be called\n - only once and\n - before any trap can occur.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}