{
  "name": "arch::kernel::tsc::init_tsc_freq",
  "safe": true,
  "callees": {
    "arch::cpu::cpuid::query_tsc_freq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Queries the frequency in Hz of the Time Stamp Counter (TSC).\n\n This is based on the information given by the CPUID instruction in the Time Stamp Counter and\n Nominal Core Crystal Clock Information Leaf.\n\n Note that the CPUID leaf is currently only supported by new Intel CPUs. This method will return\n `None` if it is not supported.\n",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "arch::kernel::tsc::determine_tsc_freq_via_pit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines the TSC frequency with the help of the Programmable Interval Timer (PIT).\n\n When the TSC frequency is not enumerated in the results of the CPUID instruction, it can\n leverage the PIT to calculate the TSC frequency.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU64::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": 1307,
  "span": "ostd/src/arch/x86/kernel/tsc.rs:19:1: 25:2",
  "src": "pub fn init_tsc_freq() {\n    use crate::arch::cpu::cpuid::query_tsc_freq as determine_tsc_freq_via_cpuid;\n\n    let tsc_freq = determine_tsc_freq_via_cpuid().unwrap_or_else(determine_tsc_freq_via_pit);\n    TSC_FREQ.store(tsc_freq, Ordering::Relaxed);\n    info!(\"TSC frequency: {:?} Hz\", tsc_freq);\n}",
  "mir": "fn arch::kernel::tsc::init_tsc_freq() -> () {\n    let mut _0: ();\n    let  _1: u64;\n    let mut _2: core::option::Option<u64>;\n    let  _3: ();\n    let mut _4: &core::sync::atomic::AtomicU64;\n    let mut _5: core::sync::atomic::Ordering;\n    let  _6: log::Level;\n    let mut _7: bool;\n    let mut _8: &log::Level;\n    let mut _9: &log::LevelFilter;\n    let mut _10: bool;\n    let mut _11: &log::Level;\n    let mut _12: &log::LevelFilter;\n    let  _13: log::LevelFilter;\n    let  _14: ();\n    let mut _15: core::fmt::Arguments<'_>;\n    let  _16: (&u64,);\n    let mut _17: &u64;\n    let  _18: [core::fmt::rt::Argument<'_>; 1];\n    let mut _19: core::fmt::rt::Argument<'_>;\n    let mut _20: &[u8; 22];\n    let  _21: &[core::fmt::rt::Argument<'_>; 1];\n    let  _22: &(&str, &str, &core::panic::Location<'_>);\n    let  _23: (&str, &str, &core::panic::Location<'_>);\n    let mut _24: &str;\n    let  _25: &core::panic::Location<'_>;\n    let mut _26: &u64;\n    debug tsc_freq => _1;\n    debug lvl => _6;\n    debug args => _16;\n    debug args => _18;\n    bb0: {\n        StorageLive(_2);\n        _2 = arch::cpu::cpuid::query_tsc_freq() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = core::option::Option::<u64>::unwrap_or_else::<fn() -> u64 {arch::kernel::tsc::determine_tsc_freq_via_pit}>(move _2, arch::kernel::tsc::determine_tsc_freq_via_pit) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_4);\n        _4 = {alloc367: &core::sync::atomic::AtomicU64};\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Relaxed;\n        _3 = core::sync::atomic::AtomicU64::store(move _4, _1, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _6 = log::Level::Info;\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_6;\n        StorageLive(_9);\n        _9 = arch::kernel::tsc::init_tsc_freq::promoted[0];\n        _7 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _8, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _7) -> [0: bb14, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_6;\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = log::max_level() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _12 = &_13;\n        _10 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _11, move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _10) -> [0: bb13, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_1;\n        _16 = (move _17);\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _26 = (_16.0: &u64);\n        _19 = core::fmt::rt::Argument::<'_>::new_debug::<u64>(_26) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _18 = [move _19];\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = b\"\\x0fTSC frequency: \\xc0\\x03 Hz\\x00\";\n        _21 = &_18;\n        _15 = core::fmt::Arguments::<'_>::new::<22, 1>(move _20, _21) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = \"ostd::arch::kernel::tsc\";\n        _25 = log::__private_api::loc() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _23 = (move _24, \"ostd::arch::kernel::tsc\", _25);\n        StorageDead(_24);\n        _22 = &_23;\n        _14 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _15, _6, _22, ()) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageDead(_23);\n        StorageDead(_18);\n        StorageDead(_16);\n        goto -> bb15;\n    }\n    bb13: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb15;\n    }\n    bb14: {\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_10);\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}