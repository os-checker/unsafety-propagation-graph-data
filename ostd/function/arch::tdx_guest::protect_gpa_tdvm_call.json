{
  "name": "arch::tdx_guest::protect_gpa_tdvm_call",
  "safe": false,
  "callees": {
    "core::num::<impl usize>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "tdx_guest::tdvmcall::map_gpa": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " MapGPA TDG.VP.VMCALL is used to help request the host VMM to map a GPA range as private\n or shared-memory mappings. This API may also be used to convert page mappings from\n private to shared. The GPA range passed in this operation can indicate if the mapping is\n requested for a shared or private memory via the GPA.Shared bit in the start address.\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::step_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator starting at the same point, but stepping by\n the given amount at each iteration.\n\n Note 1: The first element of the iterator will always be returned,\n regardless of the step given.\n\n Note 2: The time at which ignored elements are pulled is not fixed.\n `StepBy` behaves like the sequence `self.next()`, `self.nth(step-1)`,\n `self.nth(step-1)`, …, but is also free to behave like the sequence\n `advance_n_and_return_first(&mut self, step)`,\n `advance_n_and_return_first(&mut self, step)`, …\n Which way is used may change for some iterators for performance reasons.\n The second way will advance the iterator earlier and may consume more items.\n\n `advance_n_and_return_first` is the equivalent of:\n ```\n fn advance_n_and_return_first<I>(iter: &mut I, n: usize) -> Option<I::Item>\n where\n     I: Iterator,\n {\n     let next = iter.next();\n     if n > 1 {\n         iter.nth(n - 2);\n     }\n     next\n }\n ```\n\n # Panics\n\n The method will panic if the given step is `0`.\n\n # Examples\n\n ```\n let a = [0, 1, 2, 3, 4, 5];\n let mut iter = a.into_iter().step_by(2);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "tdx_guest::tdcall::accept_page": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Accept a pending private page and initialize it to all-0 using the TD ephemeral private key.\n # Safety\n The 'gpa' parameter must be a valid address.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2857, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 2850, kind: RigidTy(Adt(AdtDef(DefId { id: 4469, name: \"arch::tdx_guest::PageConvertError\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::iter::StepBy": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": 1461,
  "span": "ostd/src/arch/x86/tdx_guest.rs:51:1: 63:2",
  "src": "pub unsafe fn protect_gpa_tdvm_call(gpa: Paddr, size: usize) -> Result<(), PageConvertError> {\n    debug_assert!(gpa.is_multiple_of(PAGE_SIZE));\n\n    map_gpa(gpa as u64, size as u64).map_err(|_| PageConvertError::TdVmcall)?;\n    for page_gpa in (gpa..gpa + size).step_by(PAGE_SIZE) {\n        // SAFETY: The caller ensures the safety of this operation.\n        unsafe {\n            accept_page(0, page_gpa as u64).map_err(|_| PageConvertError::TdCall)?;\n        }\n    }\n\n    Ok(())\n}",
  "mir": "fn arch::tdx_guest::protect_gpa_tdvm_call(_1: usize, _2: usize) -> core::result::Result<(), arch::tdx_guest::PageConvertError> {\n    let mut _0: core::result::Result<(), arch::tdx_guest::PageConvertError>;\n    let mut _3: bool;\n    let mut _4: !;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>>;\n    let mut _6: core::result::Result<(), arch::tdx_guest::PageConvertError>;\n    let mut _7: core::result::Result<(), (u64, tdx_guest::tdvmcall::TdVmcallError)>;\n    let mut _8: u64;\n    let mut _9: u64;\n    let mut _10: isize;\n    let  _11: core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>;\n    let mut _12: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _13: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _14: core::ops::Range<usize>;\n    let mut _15: usize;\n    let mut _16: (usize, bool);\n    let mut _17: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _18: core::option::Option<usize>;\n    let mut _19: &mut core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _20: isize;\n    let  _21: usize;\n    let mut _22: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>>;\n    let mut _23: core::result::Result<(), arch::tdx_guest::PageConvertError>;\n    let mut _24: core::result::Result<(), tdx_guest::tdcall::TdCallError>;\n    let mut _25: u64;\n    let mut _26: isize;\n    let  _27: core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>;\n    debug gpa => _1;\n    debug size => _2;\n    debug residual => _11;\n    debug val => ();\n    debug iter => _17;\n    debug page_gpa => _21;\n    debug residual => _27;\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        _3 = core::num::<impl usize>::is_multiple_of(_1, mm::PAGE_SIZE) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = _1 as u64;\n        StorageLive(_9);\n        _9 = _2 as u64;\n        _7 = tdx_guest::tdvmcall::map_gpa(move _8, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        _4 = core::panicking::panic(\"assertion failed: gpa.is_multiple_of(PAGE_SIZE)\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_8);\n        _6 = core::result::Result::<(), (u64, tdx_guest::tdvmcall::TdVmcallError)>::map_err::<arch::tdx_guest::PageConvertError, {closure@ostd/src/arch/x86/tdx_guest.rs:54:46: 54:49}>(move _7, ZeroSized: {closure@ostd/src/arch/x86/tdx_guest.rs:54:46: 54:49}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _5 = <core::result::Result<(), arch::tdx_guest::PageConvertError> as core::ops::Try>::branch(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        _10 = discriminant(_5);\n        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        StorageDead(_5);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _16 = CheckedAdd(_1, _2);\n        assert(!move (_16.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _1, _2) -> [success: bb11, unwind unreachable];\n    }\n    bb9: {\n        _11 = move ((_5 as variant#1).0: core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>);\n        _0 = <core::result::Result<(), arch::tdx_guest::PageConvertError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>>>::from_residual(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_5);\n        goto -> bb24;\n    }\n    bb11: {\n        _15 = move (_16.0: usize);\n        _14 = Range(_1, move _15);\n        StorageDead(_15);\n        _13 = <core::ops::Range<usize> as core::iter::Iterator>::step_by(move _14, mm::PAGE_SIZE) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        _12 = <core::iter::StepBy<core::ops::Range<usize>> as core::iter::IntoIterator>::into_iter(move _13) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_13);\n        StorageLive(_17);\n        _17 = move _12;\n        goto -> bb14;\n    }\n    bb14: {\n        StorageLive(_18);\n        _19 = &mut _17;\n        _18 = <core::iter::StepBy<core::ops::Range<usize>> as core::iter::Iterator>::next(_19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20 = discriminant(_18);\n        switchInt(move _20) -> [0: bb17, 1: bb16, otherwise: bb7];\n    }\n    bb16: {\n        _21 = ((_18 as variant#1).0: usize);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = _21 as u64;\n        _24 = tdx_guest::tdcall::accept_page(0_u64, move _25) -> [return: bb18, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_12);\n        _0 = core::result::Result::Ok(());\n        goto -> bb24;\n    }\n    bb18: {\n        StorageDead(_25);\n        _23 = core::result::Result::<(), tdx_guest::tdcall::TdCallError>::map_err::<arch::tdx_guest::PageConvertError, {closure@ostd/src/arch/x86/tdx_guest.rs:58:53: 58:56}>(move _24, ZeroSized: {closure@ostd/src/arch/x86/tdx_guest.rs:58:53: 58:56}) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_24);\n        _22 = <core::result::Result<(), arch::tdx_guest::PageConvertError> as core::ops::Try>::branch(move _23) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_23);\n        _26 = discriminant(_22);\n        switchInt(move _26) -> [0: bb21, 1: bb22, otherwise: bb7];\n    }\n    bb21: {\n        StorageDead(_22);\n        StorageDead(_18);\n        goto -> bb14;\n    }\n    bb22: {\n        _27 = move ((_22 as variant#1).0: core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>);\n        _0 = <core::result::Result<(), arch::tdx_guest::PageConvertError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, arch::tdx_guest::PageConvertError>>>::from_residual(_27) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_12);\n        goto -> bb24;\n    }\n    bb24: {\n        return;\n    }\n}\n",
  "doc": " Converts physical pages to Intel TDX private pages.\n\n It invokes the [`map_gpa`] TDVMCALL and the [`accept_page`] TDCALL to\n convert those pages into Intel TDX private pages. Due to the conversion,\n any existing data on the pages will be zeroed.\n\n # Safety\n\n The caller must ensure that:\n  - The provided physical address is page aligned.\n  - The provided physical address range is in bounds, i.e., it should fall\n    within the maximum Guest Physical Address (GPA) limit.\n  - All of the physical pages are untyped memory. Therefore, converting and\n    erasing the data will not cause memory safety issues.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}