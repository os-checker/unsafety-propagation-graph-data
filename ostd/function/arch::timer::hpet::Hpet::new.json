{
  "name": "arch::timer::hpet::Hpet::new",
  "safe": false,
  "callees": {
    "core::ptr::NonNull::<T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an offset to a pointer (convenience for `.offset(count as isize)`).\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n If any of the following conditions are violated, the result is Undefined Behavior:\n\n * The computed offset, `count * size_of::<T>()` bytes, must not overflow `isize`.\n\n * If the computed offset is non-zero, then `self` must be derived from a pointer to some\n   [allocation], and the entire memory range between `self` and the result must be in\n   bounds of that allocation. In particular, this range must not \"wrap around\" the edge\n   of the address space.\n\n Allocations can never be larger than `isize::MAX` bytes, so if the computed offset\n stays in bounds of the allocation, it is guaranteed to satisfy the first requirement.\n This implies, for instance, that `vec.as_ptr().add(vec.len())` (for `vec: Vec<T>`) is always\n safe.\n\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let s: &str = \"123\";\n let ptr: NonNull<u8> = NonNull::new(s.as_ptr().cast_mut()).unwrap();\n\n unsafe {\n     println!(\"{}\", ptr.add(1).read() as char);\n     println!(\"{}\", ptr.add(2).read() as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::new(&mut x as *mut _).expect(\"null pointer\");\n\n let casted_ptr = ptr.cast::<i8>();\n let raw_ptr: *mut i8 = casted_ptr.as_ptr();\n ```\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T>::new_read_only": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Turns the given pointer into a read-only `VolatileRef`.\n\n ## Safety\n\n - The pointer must be properly aligned.\n - It must be “dereferenceable” in the sense defined in the [`core::ptr`] documentation.\n - The pointer must point to an initialized instance of T.\n - You must enforce Rust’s aliasing rules, since the returned lifetime 'a is arbitrarily\n   chosen and does not necessarily reflect the actual lifetime of the data. In particular,\n   while this `VolatileRef` exists, the memory the pointer points to _must not get mutated_.\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Turns the given pointer into a `VolatileRef`.\n\n ## Safety\n\n - The pointer must be properly aligned.\n - It must be “dereferenceable” in the sense defined in the [`core::ptr`] documentation.\n - The pointer must point to an initialized instance of T.\n - You must enforce Rust’s aliasing rules, since the returned lifetime 'a is arbitrarily\n   chosen and does not necessarily reflect the actual lifetime of the data. In particular,\n   while this `VolatileRef` exists, the memory the pointer points to must not get accessed\n   (_read or written_) through any other pointer.\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows this `VolatileRef` as a read-only [`VolatilePtr`].\n\n Use this method to do (partial) volatile reads of the referenced data.\n",
      "adt": {}
    },
    "volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile read of the contained value.\n\n Returns a copy of the read value. Volatile reads are guaranteed not to be optimized\n away by the compiler, but by themselves do not have atomic ordering\n guarantees. To also get atomicity, consider looking at the `Atomic` wrapper types of\n the standard/`core` library.\n\n ## Examples\n\n ```rust\n use volatile::{VolatilePtr, access};\n use core::ptr::NonNull;\n\n let value = 42;\n let pointer = unsafe {\n     VolatilePtr::new_restricted(access::ReadOnly, NonNull::from(&value))\n };\n assert_eq!(pointer.read(), 42);\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "irq::top_half::IrqLine::alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates an available IRQ line.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "irq::top_half::IrqLine": "Constructor"
      }
    },
    "alloc::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "arch::irq::chip::IrqChip::map_isa_pin_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an IRQ pin specified by an ISA interrupt number to an IRQ line.\n\n Industry Standard Architecture (ISA) is the 16-bit internal bus of IBM PC/AT. For\n compatibility reasons, legacy devices such as keyboards connected via the i8042 PS/2\n controller still use it.\n\n This method is x86-specific.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "arch::irq::chip::IrqChip": "ImmutableAsArgument",
        "arch::irq::chip::MappedIrqLine": "Constructor"
      }
    }
  },
  "adts": {
    "core::ptr::NonNull": [
      "Plain"
    ],
    "volatile::VolatileRef": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1703, kind: RigidTy(Adt(AdtDef(DefId { id: 3571, name: \"volatile::VolatileRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: RigidTy(Uint(U32)) }), Type(Ty { id: 1282, kind: RigidTy(Adt(AdtDef(DefId { id: 3609, name: \"volatile::access::ReadOnly\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 1274, kind: RigidTy(Adt(AdtDef(DefId { id: 3571, name: \"volatile::VolatileRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: RigidTy(Uint(U32)) }), Type(Ty { id: 1281, kind: RigidTy(Adt(AdtDef(DefId { id: 3610, name: \"volatile::access::ReadWrite\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 1274, kind: RigidTy(Adt(AdtDef(DefId { id: 3571, name: \"volatile::VolatileRef\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: RigidTy(Uint(U32)) }), Type(Ty { id: 1281, kind: RigidTy(Adt(AdtDef(DefId { id: 3610, name: \"volatile::access::ReadWrite\" }), GenericArgs([]))) })]))) })])",
      "Ref"
    ],
    "volatile::VolatilePtr": [
      "Plain"
    ],
    "alloc::vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "irq::top_half::IrqLine": [
      "Plain"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "arch::irq::chip::IrqChip": [
      "Ref"
    ],
    "arch::irq::chip::MappedIrqLine": [
      "Plain"
    ],
    "arch::timer::hpet::Hpet": [
      "Plain"
    ]
  },
  "path": 1517,
  "span": "ostd/src/arch/x86/timer/hpet.rs:54:5: 108:6",
  "src": "unsafe fn new(base_address: NonNull<u8>) -> Hpet {\n        // SAFETY: The safety is upheld by the caller.\n        let (\n            information_register,\n            general_configuration_register,\n            general_interrupt_status_register,\n        ) = unsafe {\n            (\n                VolatileRef::new_read_only(base_address.add(OFFSET_ID_REGISTER).cast::<u32>()),\n                VolatileRef::new(\n                    base_address\n                        .add(OFFSET_CONFIGURATION_REGISTER)\n                        .cast::<u32>(),\n                ),\n                VolatileRef::new(\n                    base_address\n                        .add(OFFSET_INTERRUPT_STATUS_REGISTER)\n                        .cast::<u32>(),\n                ),\n            )\n        };\n\n        let num_comparator = ((information_register.as_ptr().read() & 0x1F00) >> 8) as u8 + 1;\n        let num_comparator = num_comparator as usize;\n\n        // FIXME: We now trust the hardware. We should instead find a way to check that\n        // `num_comparator` are reasonable values before proceeding.\n\n        let mut comparators = Vec::with_capacity(num_comparator);\n        for i in 0..num_comparator {\n            // SAFETY: The safety is upheld by the caller and the correctness of the information\n            // value.\n            let comp = unsafe {\n                VolatileRef::new(\n                    base_address\n                        .add(0x100)\n                        .add(i * 0x20)\n                        .cast::<HpetTimerRegister>(),\n                )\n            };\n            comparators.push(comp);\n        }\n\n        let irq = IrqLine::alloc().unwrap();\n        // FIXME: The index of HPET interrupt needs to be tested.\n        let irq = IRQ_CHIP.get().unwrap().map_isa_pin_to(irq, 0).unwrap();\n\n        Hpet {\n            information_register,\n            _general_configuration_register: general_configuration_register,\n            _general_interrupt_status_register: general_interrupt_status_register,\n            _timer_registers: comparators,\n            _irq: irq,\n        }\n    }",
  "mir": "fn arch::timer::hpet::Hpet::new(_1: core::ptr::NonNull<u8>) -> arch::timer::hpet::Hpet {\n    let mut _0: arch::timer::hpet::Hpet;\n    let  _2: volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>;\n    let  _3: volatile::VolatileRef<'_, u32>;\n    let  _4: volatile::VolatileRef<'_, u32>;\n    let mut _5: (volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>, volatile::VolatileRef<'_, u32>, volatile::VolatileRef<'_, u32>);\n    let mut _6: volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>;\n    let mut _7: core::ptr::NonNull<u32>;\n    let mut _8: core::ptr::NonNull<u8>;\n    let mut _9: volatile::VolatileRef<'_, u32>;\n    let mut _10: core::ptr::NonNull<u32>;\n    let mut _11: core::ptr::NonNull<u8>;\n    let mut _12: volatile::VolatileRef<'_, u32>;\n    let mut _13: core::ptr::NonNull<u32>;\n    let mut _14: core::ptr::NonNull<u8>;\n    let  _15: u8;\n    let mut _16: u8;\n    let mut _17: u32;\n    let mut _18: u32;\n    let mut _19: u32;\n    let mut _20: volatile::VolatilePtr<'_, u32, volatile::access::ReadOnly>;\n    let mut _21: &volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>;\n    let mut _22: u32;\n    let mut _23: bool;\n    let mut _24: (u8, bool);\n    let  _25: usize;\n    let mut _26: alloc::vec::Vec<volatile::VolatileRef<'_, arch::timer::hpet::HpetTimerRegister>>;\n    let mut _27: core::ops::Range<usize>;\n    let mut _28: core::ops::Range<usize>;\n    let mut _29: core::ops::Range<usize>;\n    let mut _30: core::option::Option<usize>;\n    let mut _31: &mut core::ops::Range<usize>;\n    let mut _32: isize;\n    let  _33: usize;\n    let  _34: volatile::VolatileRef<'_, arch::timer::hpet::HpetTimerRegister>;\n    let mut _35: core::ptr::NonNull<arch::timer::hpet::HpetTimerRegister>;\n    let mut _36: core::ptr::NonNull<u8>;\n    let mut _37: core::ptr::NonNull<u8>;\n    let mut _38: usize;\n    let mut _39: (usize, bool);\n    let  _40: ();\n    let mut _41: &mut alloc::vec::Vec<volatile::VolatileRef<'_, arch::timer::hpet::HpetTimerRegister>>;\n    let  _42: irq::top_half::IrqLine;\n    let mut _43: core::result::Result<irq::top_half::IrqLine, error::Error>;\n    let  _44: arch::irq::chip::MappedIrqLine;\n    let mut _45: core::result::Result<arch::irq::chip::MappedIrqLine, error::Error>;\n    let  _46: &arch::irq::chip::IrqChip;\n    let mut _47: core::option::Option<&arch::irq::chip::IrqChip>;\n    let mut _48: &spin::once::Once<arch::irq::chip::IrqChip>;\n    let mut _49: alloc::vec::Vec<volatile::VolatileRef<'_, arch::timer::hpet::HpetTimerRegister>>;\n    debug base_address => _1;\n    debug information_register => _2;\n    debug general_configuration_register => _3;\n    debug general_interrupt_status_register => _4;\n    debug num_comparator => _15;\n    debug num_comparator => _25;\n    debug comparators => _26;\n    debug iter => _29;\n    debug i => _33;\n    debug comp => _34;\n    debug irq => _42;\n    debug irq => _44;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = core::ptr::NonNull::<u8>::add(_1, arch::timer::hpet::OFFSET_ID_REGISTER) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = core::ptr::NonNull::<u8>::cast::<u32>(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _6 = volatile::VolatileRef::<'_, u32>::new_read_only(move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = core::ptr::NonNull::<u8>::add(_1, arch::timer::hpet::OFFSET_CONFIGURATION_REGISTER) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = core::ptr::NonNull::<u8>::cast::<u32>(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        _9 = volatile::VolatileRef::<'_, u32>::new(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = core::ptr::NonNull::<u8>::add(_1, arch::timer::hpet::OFFSET_INTERRUPT_STATUS_REGISTER) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _13 = core::ptr::NonNull::<u8>::cast::<u32>(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_14);\n        _12 = volatile::VolatileRef::<'_, u32>::new(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _5 = (move _6, move _9, move _12);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageDead(_6);\n        _2 = (_5.0: volatile::VolatileRef<'_, u32, volatile::access::ReadOnly>);\n        _3 = move (_5.1: volatile::VolatileRef<'_, u32>);\n        _4 = move (_5.2: volatile::VolatileRef<'_, u32>);\n        StorageDead(_5);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_2;\n        _20 = volatile::VolatileRef::<'_, u32, volatile::access::ReadOnly>::as_ptr(move _21) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_21);\n        _19 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u32, volatile::access::ReadOnly>>::read(move _20) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_20);\n        _18 = BitAnd(move _19, 7936_u32);\n        StorageDead(_19);\n        _22 = 8_i32 as u32;\n        _23 = Lt(move _22, 32_u32);\n        assert(move _23, \"attempt to shift right by `{}`, which would overflow\", 8_i32) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _17 = Shr(move _18, 8_i32);\n        StorageDead(_18);\n        _16 = move _17 as u8;\n        StorageDead(_17);\n        _24 = CheckedAdd(_16, 1_u8);\n        assert(!move (_24.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _16, 1_u8) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _15 = move (_24.0: u8);\n        StorageDead(_16);\n        _25 = _15 as usize;\n        StorageLive(_26);\n        _26 = alloc::vec::Vec::<volatile::VolatileRef<'_, arch::timer::hpet::HpetTimerRegister>>::with_capacity(_25) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = Range(0_usize, _25);\n        _27 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(move _28) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_28);\n        StorageLive(_29);\n        _29 = move _27;\n        goto -> bb16;\n    }\n    bb16: {\n        StorageLive(_30);\n        _31 = &mut _29;\n        _30 = <core::ops::Range<usize> as core::iter::Iterator>::next(_31) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _32 = discriminant(_30);\n        switchInt(move _32) -> [0: bb20, 1: bb19, otherwise: bb18];\n    }\n    bb18: {\n        unreachable;\n    }\n    bb19: {\n        _33 = ((_30 as variant#1).0: usize);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = core::ptr::NonNull::<u8>::add(_1, 256_usize) -> [return: bb21, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageLive(_43);\n        _43 = irq::top_half::IrqLine::alloc() -> [return: bb27, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_38);\n        _39 = CheckedMul(_33, 32_usize);\n        assert(!move (_39.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _33, 32_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _38 = move (_39.0: usize);\n        _36 = core::ptr::NonNull::<u8>::add(move _37, move _38) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_38);\n        StorageDead(_37);\n        _35 = core::ptr::NonNull::<u8>::cast::<arch::timer::hpet::HpetTimerRegister>(move _36) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_36);\n        _34 = volatile::VolatileRef::<'_, arch::timer::hpet::HpetTimerRegister>::new(move _35) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_35);\n        StorageLive(_41);\n        _41 = &mut _26;\n        _40 = alloc::vec::Vec::<volatile::VolatileRef<'_, arch::timer::hpet::HpetTimerRegister>>::push(move _41, _34) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_41);\n        StorageDead(_30);\n        goto -> bb16;\n    }\n    bb27: {\n        _42 = core::result::Result::<irq::top_half::IrqLine, error::Error>::unwrap(move _43) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_43);\n        StorageLive(_45);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = {alloc261: &spin::once::Once<arch::irq::chip::IrqChip>};\n        _47 = spin::once::Once::<arch::irq::chip::IrqChip>::get(move _48) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_48);\n        _46 = core::option::Option::<&arch::irq::chip::IrqChip>::unwrap(move _47) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_47);\n        _45 = arch::irq::chip::IrqChip::map_isa_pin_to(_46, _42, 0_u8) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _44 = core::result::Result::<arch::irq::chip::MappedIrqLine, error::Error>::unwrap(move _45) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_45);\n        StorageLive(_49);\n        _49 = move _26;\n        _0 = Hpet(_2, _3, _4, move _49, _44);\n        StorageDead(_49);\n        StorageDead(_26);\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n The caller must ensure that the address is valid and points to the HPET MMIO region.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}