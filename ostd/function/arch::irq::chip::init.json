{
  "name": "arch::irq::chip::init",
  "safe": true,
  "callees": {
    "arch::kernel::acpi::get_acpi_tables": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "acpi::AcpiTables": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "acpi::AcpiTables::<H>::find_table": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches through the ACPI table headers and attempts to locate the table with a matching `T::SIGNATURE`.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "acpi::PhysicalMapping::<H, T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "arch::irq::chip::pic::init_and_disable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes and disables the 8259 Programmable Interrupt Controller (PIC).\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    },
    "acpi::madt::Madt::entries": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {}
    },
    "arch::irq::chip::ioapic::IoApic::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller must ensure that the base address is a valid I/O APIC base address.\n",
      "adt": {
        "io::io_mem::allocator::IoMemAllocatorBuilder": "ImmutableAsArgument",
        "arch::irq::chip::ioapic::IoApic": "Constructor"
      }
    },
    "alloc::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc::slice::<impl [T]>::sort_by_key": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order with a key extraction function, preserving initial order\n of equal elements.\n\n This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* \\* log(*n*))\n worst-case, where the key function is *O*(*m*).\n\n If the implementation of [`Ord`] for `K` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n # Current implementation\n\n The current implementation is based on [driftsort] by Orson Peters and Lukas Bergdoll, which\n combines the fast average case of quicksort with the fast worst case and partial run\n detection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\n with k distinct elements, the expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n The auxiliary memory allocation behavior depends on the input length. Short slices are\n handled without allocation, medium sized slices allocate `self.len()` and beyond that it\n clamps at `self.len() / 2`.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `K` does not implement a [total order], or if\n the [`Ord`] implementation or the key-function `f` panics.\n\n All safe functions on slices preserve the invariant that even if the function panics, all\n original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. This ensures that recovery code (for instance inside\n of a `Drop` or following a `catch_unwind`) will still have access to all the original\n elements. For instance, if the slice belongs to a `Vec`, the `Vec::drop` method will be able\n to dispose of all contained elements.\n\n # Examples\n\n ```\n let mut v = [4i32, -5, 1, -3, 2];\n\n v.sort_by_key(|k| k.abs());\n assert_eq!(v, [1, 2, -3, 4, -5]);\n ```\n\n [driftsort]: https://github.com/Voultapher/driftsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "arch::irq::chip::ioapic::IoApic::interrupt_base": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base number of the global system interrupts controlled by the I/O APIC.\n",
      "adt": {
        "arch::irq::chip::ioapic::IoApic": "ImmutableAsArgument"
      }
    },
    "alloc::vec::Vec::<T, A>::into_boxed_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the vector into [`Box<[T]>`][owned slice].\n\n Before doing the conversion, this method discards excess capacity like [`shrink_to_fit`].\n\n [owned slice]: Box\n [`shrink_to_fit`]: Vec::shrink_to_fit\n\n # Examples\n\n ```\n let v = vec![1, 2, 3];\n\n let slice = v.into_boxed_slice();\n ```\n\n Any excess capacity is removed:\n\n ```\n let mut vec = Vec::with_capacity(10);\n vec.extend([1, 2, 3]);\n\n assert!(vec.capacity() >= 10);\n let slice = vec.into_boxed_slice();\n assert_eq!(slice.into_vec().capacity(), 3);\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "sync::spin::SpinLock::<T, G>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "Constructor"
      }
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1992, kind: RigidTy(Adt(AdtDef(DefId { id: 3917, name: \"acpi::madt::MadtEntry\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1964, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1963, kind: RigidTy(Adt(AdtDef(DefId { id: 3905, name: \"arch::irq::chip::IsaOverride\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "acpi::AcpiTables": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "acpi::PhysicalMapping": [
      "Plain",
      "Ref"
    ],
    "core::pin::Pin": [
      "Plain",
      "Ref"
    ],
    "acpi::madt::Madt": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "alloc::vec::Vec": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "acpi::madt::MadtEntryIter": [
      "Plain",
      "MutRef"
    ],
    "acpi::madt::MadtEntry": [
      "Plain",
      "Unknown([Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 1994, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2027, kind: RigidTy(Adt(AdtDef(DefId { id: 3943, name: \"acpi::madt::InterruptSourceOverrideEntry\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1995, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2028, kind: RigidTy(Adt(AdtDef(DefId { id: 3949, name: \"acpi::madt::IoApicEntry\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "acpi::madt::InterruptSourceOverrideEntry": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "acpi::madt::IoApicEntry": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))"
    ],
    "io::io_mem::allocator::IoMemAllocatorBuilder": [
      "Ref"
    ],
    "arch::irq::chip::ioapic::IoApic": [
      "Plain",
      "Ref"
    ],
    "arch::irq::chip::IsaOverride": [
      "Plain",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "alloc::boxed::Box": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "sync::spin::SpinLock": [
      "Plain"
    ],
    "arch::irq::chip::IrqChip": [
      "Plain",
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::irq::chip::init"
  },
  "span": "ostd/src/arch/x86/irq/chip/mod.rs:164:1: 243:2",
  "src": "pub(in crate::arch) fn init(io_mem_builder: &IoMemAllocatorBuilder) {\n    use acpi::madt::{Madt, MadtEntry};\n\n    // If there are no ACPI tables, or the ACPI tables do not provide us with information about\n    // the I/O APIC, we may need to find another way to determine the I/O APIC address\n    // correctly and reliably (e.g., by parsing the MultiProcessor Specification, which has\n    // been deprecated for a long time and may not even exist in modern hardware).\n    let acpi_tables = get_acpi_tables().unwrap();\n    let madt_table = acpi_tables.find_table::<Madt>().unwrap();\n\n    // \"A one indicates that the system also has a PC-AT-compatible dual-8259 setup. The 8259\n    // vectors must be disabled (that is, masked) when enabling the ACPI APIC operation\"\n    const PCAT_COMPAT: u32 = 1;\n    if madt_table.get().flags & PCAT_COMPAT != 0 {\n        pic::init_and_disable();\n    }\n\n    let mut io_apics = Vec::with_capacity(2);\n    let mut isa_overrides = Vec::new();\n\n    const BUS_ISA: u8 = 0; // \"0 Constant, meaning ISA\".\n\n    for madt_entry in madt_table.get().entries() {\n        match madt_entry {\n            MadtEntry::IoApic(madt_io_apic) => {\n                // SAFETY: We trust the ACPI tables (as well as the MADTs in them), from which the\n                // base address is obtained, so it is a valid I/O APIC base address.\n                let io_apic = unsafe {\n                    IoApic::new(\n                        madt_io_apic.io_apic_address as usize,\n                        madt_io_apic.global_system_interrupt_base,\n                        io_mem_builder,\n                    )\n                };\n                io_apics.push(io_apic);\n            }\n            MadtEntry::InterruptSourceOverride(madt_isa_override)\n                if madt_isa_override.bus == BUS_ISA =>\n            {\n                let isa_override = IsaOverride {\n                    source: madt_isa_override.irq,\n                    target: madt_isa_override.global_system_interrupt,\n                };\n                isa_overrides.push(isa_override);\n            }\n            _ => {}\n        }\n    }\n\n    if isa_overrides.is_empty() {\n        // TODO: QEMU MicroVM does not provide any interrupt source overrides. Therefore, the timer\n        // interrupt used by the PIT will not work. Is this a bug in QEMU MicroVM? Why won't this\n        // affect operating systems such as Linux?\n        isa_overrides.push(IsaOverride {\n            source: 0, // Timer ISA IRQ\n            target: 2, // Timer GSI\n        });\n    }\n\n    for isa_override in isa_overrides.iter() {\n        info!(\n            \"[IOAPIC]: Override ISA interrupt {} for GSI {}\",\n            isa_override.source, isa_override.target\n        );\n    }\n\n    io_apics.sort_by_key(|io_apic| io_apic.interrupt_base());\n    assert!(!io_apics.is_empty(), \"No I/O APICs found\");\n    assert_eq!(\n        io_apics[0].interrupt_base(),\n        0,\n        \"No I/O APIC with zero interrupt base found\"\n    );\n\n    let irq_chip = IrqChip {\n        io_apics: SpinLock::new(io_apics.into_boxed_slice()),\n        overrides: isa_overrides.into_boxed_slice(),\n    };\n    IRQ_CHIP.call_once(|| irq_chip);\n}",
  "mir": "fn arch::irq::chip::init(_1: &io::io_mem::allocator::IoMemAllocatorBuilder) -> () {\n    let mut _0: ();\n    let  _2: acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _3: core::option::Option<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>;\n    let  _4: acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let mut _5: core::result::Result<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>, acpi::AcpiError>;\n    let mut _6: &acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>;\n    let mut _7: u32;\n    let mut _8: u32;\n    let mut _9: &acpi::madt::Madt;\n    let mut _10: &core::pin::Pin<&acpi::madt::Madt>;\n    let  _11: core::pin::Pin<&acpi::madt::Madt>;\n    let mut _12: &acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let  _13: ();\n    let mut _14: alloc::vec::Vec<arch::irq::chip::ioapic::IoApic>;\n    let mut _15: alloc::vec::Vec<arch::irq::chip::IsaOverride>;\n    let mut _16: acpi::madt::MadtEntryIter<'_>;\n    let mut _17: acpi::madt::MadtEntryIter<'_>;\n    let mut _18: core::pin::Pin<&acpi::madt::Madt>;\n    let mut _19: &acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>;\n    let mut _20: acpi::madt::MadtEntryIter<'_>;\n    let mut _21: core::option::Option<acpi::madt::MadtEntry<'_>>;\n    let mut _22: &mut acpi::madt::MadtEntryIter<'_>;\n    let mut _23: isize;\n    let  _24: acpi::madt::MadtEntry<'_>;\n    let mut _25: isize;\n    let  _26: &acpi::madt::IoApicEntry;\n    let  _27: arch::irq::chip::ioapic::IoApic;\n    let mut _28: usize;\n    let mut _29: u32;\n    let mut _30: u32;\n    let  _31: ();\n    let mut _32: &mut alloc::vec::Vec<arch::irq::chip::ioapic::IoApic>;\n    let  _33: &acpi::madt::InterruptSourceOverrideEntry;\n    let  _34: &&acpi::madt::InterruptSourceOverrideEntry;\n    let mut _35: bool;\n    let mut _36: u8;\n    let  _37: arch::irq::chip::IsaOverride;\n    let mut _38: u8;\n    let mut _39: u32;\n    let  _40: ();\n    let mut _41: &mut alloc::vec::Vec<arch::irq::chip::IsaOverride>;\n    let mut _42: bool;\n    let mut _43: &alloc::vec::Vec<arch::irq::chip::IsaOverride>;\n    let  _44: ();\n    let mut _45: &mut alloc::vec::Vec<arch::irq::chip::IsaOverride>;\n    let mut _46: arch::irq::chip::IsaOverride;\n    let mut _47: core::slice::Iter<'_, arch::irq::chip::IsaOverride>;\n    let mut _48: core::slice::Iter<'_, arch::irq::chip::IsaOverride>;\n    let  _49: &[arch::irq::chip::IsaOverride];\n    let mut _50: &alloc::vec::Vec<arch::irq::chip::IsaOverride>;\n    let mut _51: core::slice::Iter<'_, arch::irq::chip::IsaOverride>;\n    let mut _52: core::option::Option<&arch::irq::chip::IsaOverride>;\n    let mut _53: &mut core::slice::Iter<'_, arch::irq::chip::IsaOverride>;\n    let mut _54: isize;\n    let  _55: &arch::irq::chip::IsaOverride;\n    let  _56: log::Level;\n    let mut _57: bool;\n    let mut _58: &log::Level;\n    let mut _59: &log::LevelFilter;\n    let mut _60: bool;\n    let mut _61: &log::Level;\n    let mut _62: &log::LevelFilter;\n    let  _63: log::LevelFilter;\n    let  _64: ();\n    let mut _65: core::fmt::Arguments<'_>;\n    let  _66: (&u8, &u32);\n    let mut _67: &u8;\n    let mut _68: &u32;\n    let  _69: [core::fmt::rt::Argument<'_>; 2];\n    let mut _70: core::fmt::rt::Argument<'_>;\n    let mut _71: core::fmt::rt::Argument<'_>;\n    let mut _72: &[u8; 47];\n    let  _73: &[core::fmt::rt::Argument<'_>; 2];\n    let  _74: &(&str, &str, &core::panic::Location<'_>);\n    let  _75: (&str, &str, &core::panic::Location<'_>);\n    let mut _76: &str;\n    let  _77: &core::panic::Location<'_>;\n    let  _78: ();\n    let mut _79: &mut [arch::irq::chip::ioapic::IoApic];\n    let mut _80: &mut alloc::vec::Vec<arch::irq::chip::ioapic::IoApic>;\n    let mut _81: bool;\n    let mut _82: &alloc::vec::Vec<arch::irq::chip::ioapic::IoApic>;\n    let  _83: !;\n    let mut _84: core::fmt::Arguments<'_>;\n    let mut _85: (&u32, &u32);\n    let mut _86: &u32;\n    let  _87: u32;\n    let  _88: &arch::irq::chip::ioapic::IoApic;\n    let mut _89: &alloc::vec::Vec<arch::irq::chip::ioapic::IoApic>;\n    let mut _90: &u32;\n    let  _91: &u32;\n    let  _92: &u32;\n    let mut _93: bool;\n    let mut _94: u32;\n    let mut _95: u32;\n    let  _96: core::panicking::AssertKind;\n    let  _97: !;\n    let mut _98: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _99: core::fmt::Arguments<'_>;\n    let  _100: arch::irq::chip::IrqChip;\n    let mut _101: sync::spin::SpinLock<alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>>;\n    let mut _102: alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>;\n    let mut _103: alloc::vec::Vec<arch::irq::chip::ioapic::IoApic>;\n    let mut _104: alloc::boxed::Box<[arch::irq::chip::IsaOverride]>;\n    let mut _105: alloc::vec::Vec<arch::irq::chip::IsaOverride>;\n    let  _106: &arch::irq::chip::IrqChip;\n    let mut _107: &spin::once::Once<arch::irq::chip::IrqChip>;\n    let mut _108: {closure@ostd/src/arch/x86/irq/chip/mod.rs:242:24: 242:26};\n    let mut _109: &acpi::madt::InterruptSourceOverrideEntry;\n    let mut _110: &u8;\n    let mut _111: &u32;\n    debug io_mem_builder => _1;\n    debug acpi_tables => _2;\n    debug madt_table => _4;\n    debug io_apics => _14;\n    debug isa_overrides => _15;\n    debug iter => _20;\n    debug madt_entry => _24;\n    debug madt_io_apic => _26;\n    debug io_apic => _27;\n    debug madt_isa_override => _33;\n    debug madt_isa_override => _34;\n    debug isa_override => _37;\n    debug iter => _51;\n    debug isa_override => _55;\n    debug lvl => _56;\n    debug args => _66;\n    debug args => _69;\n    debug left_val => _91;\n    debug right_val => _92;\n    debug kind => _96;\n    debug irq_chip => _100;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = arch::kernel::acpi::get_acpi_tables() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::option::Option::<acpi::AcpiTables<arch::kernel::acpi::AcpiMemoryHandler>>::unwrap(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = acpi::AcpiTables::<arch::kernel::acpi::AcpiMemoryHandler>::find_table::<acpi::madt::Madt>(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _4 = core::result::Result::<acpi::PhysicalMapping<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>, acpi::AcpiError>::unwrap(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_4;\n        _11 = acpi::PhysicalMapping::<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>::get(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = &_11;\n        _9 = <core::pin::Pin<&acpi::madt::Madt> as core::ops::Deref>::deref(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_10);\n        _8 = ((*_9).2: u32);\n        _7 = BitAnd(move _8, arch::irq::chip::init::PCAT_COMPAT);\n        StorageDead(_8);\n        switchInt(move _7) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_7);\n        _13 = arch::irq::chip::pic::init_and_disable() -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_7);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_14);\n        _14 = alloc::vec::Vec::<arch::irq::chip::ioapic::IoApic>::with_capacity(2_usize) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_15);\n        _15 = alloc::vec::Vec::<arch::irq::chip::IsaOverride>::new() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_4;\n        _18 = acpi::PhysicalMapping::<arch::kernel::acpi::AcpiMemoryHandler, acpi::madt::Madt>::get(move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_19);\n        _17 = acpi::madt::Madt::entries(move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        _16 = <acpi::madt::MadtEntryIter<'_> as core::iter::IntoIterator>::into_iter(move _17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        StorageLive(_20);\n        _20 = move _16;\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_21);\n        _22 = &mut _20;\n        _21 = <acpi::madt::MadtEntryIter<'_> as core::iter::Iterator>::next(_22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _23 = discriminant(_21);\n        switchInt(move _23) -> [0: bb19, 1: bb18, otherwise: bb17];\n    }\n    bb17: {\n        unreachable;\n    }\n    bb18: {\n        StorageLive(_24);\n        _24 = move ((_21 as variant#1).0: acpi::madt::MadtEntry<'_>);\n        _25 = discriminant(_24);\n        switchInt(move _25) -> [1: bb21, 2: bb20, otherwise: bb27];\n    }\n    bb19: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_16);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &_15;\n        _42 = alloc::vec::Vec::<arch::irq::chip::IsaOverride>::is_empty(move _43) -> [return: bb28, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_34);\n        _34 = &((_24 as variant#2).0: &acpi::madt::InterruptSourceOverrideEntry);\n        StorageLive(_35);\n        StorageLive(_36);\n        _109 = (*_34);\n        _36 = ((*_109).1: u8);\n        _35 = Eq(move _36, arch::irq::chip::init::BUS_ISA);\n        switchInt(move _35) -> [0: bb25, otherwise: bb24];\n    }\n    bb21: {\n        StorageLive(_26);\n        _26 = ((_24 as variant#1).0: &acpi::madt::IoApicEntry);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = ((*_26).3: u32);\n        _28 = move _29 as usize;\n        StorageDead(_29);\n        StorageLive(_30);\n        _30 = ((*_26).4: u32);\n        _27 = arch::irq::chip::ioapic::IoApic::new(move _28, move _30, _1) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageLive(_32);\n        _32 = &mut _14;\n        _31 = alloc::vec::Vec::<arch::irq::chip::ioapic::IoApic>::push(move _32, _27) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_32);\n        StorageDead(_26);\n        goto -> bb27;\n    }\n    bb24: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_33);\n        _33 = ((_24 as variant#2).0: &acpi::madt::InterruptSourceOverrideEntry);\n        StorageLive(_38);\n        _38 = ((*_33).2: u8);\n        StorageLive(_39);\n        _39 = ((*_33).3: u32);\n        _37 = IsaOverride(move _38, move _39);\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_41);\n        _41 = &mut _15;\n        _40 = alloc::vec::Vec::<arch::irq::chip::IsaOverride>::push(move _41, _37) -> [return: bb26, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        goto -> bb27;\n    }\n    bb26: {\n        StorageDead(_41);\n        StorageDead(_33);\n        StorageDead(_34);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_24);\n        StorageDead(_21);\n        goto -> bb15;\n    }\n    bb28: {\n        switchInt(move _42) -> [0: bb31, otherwise: bb29];\n    }\n    bb29: {\n        StorageDead(_43);\n        StorageLive(_45);\n        _45 = &mut _15;\n        StorageLive(_46);\n        _46 = IsaOverride(0_u8, 2_u32);\n        _44 = alloc::vec::Vec::<arch::irq::chip::IsaOverride>::push(move _45, move _46) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_46);\n        StorageDead(_45);\n        goto -> bb32;\n    }\n    bb31: {\n        StorageDead(_43);\n        goto -> bb32;\n    }\n    bb32: {\n        StorageDead(_42);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_50);\n        _50 = &_15;\n        _49 = <alloc::vec::Vec<arch::irq::chip::IsaOverride> as core::ops::Deref>::deref(move _50) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_50);\n        _48 = core::slice::<impl [arch::irq::chip::IsaOverride]>::iter(_49) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _47 = <core::slice::Iter<'_, arch::irq::chip::IsaOverride> as core::iter::IntoIterator>::into_iter(move _48) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_48);\n        StorageLive(_51);\n        _51 = move _47;\n        goto -> bb36;\n    }\n    bb36: {\n        StorageLive(_52);\n        _53 = &mut _51;\n        _52 = <core::slice::Iter<'_, arch::irq::chip::IsaOverride> as core::iter::Iterator>::next(_53) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _54 = discriminant(_52);\n        switchInt(move _54) -> [0: bb39, 1: bb38, otherwise: bb17];\n    }\n    bb38: {\n        StorageLive(_55);\n        _55 = ((_52 as variant#1).0: &arch::irq::chip::IsaOverride);\n        _56 = log::Level::Info;\n        StorageLive(_57);\n        StorageLive(_58);\n        _58 = &_56;\n        StorageLive(_59);\n        _59 = arch::irq::chip::init::promoted[0];\n        _57 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _58, move _59) -> [return: bb40, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_52);\n        StorageDead(_51);\n        StorageDead(_47);\n        StorageLive(_80);\n        _80 = &mut _14;\n        _79 = <alloc::vec::Vec<arch::irq::chip::ioapic::IoApic> as core::ops::DerefMut>::deref_mut(move _80) -> [return: bb53, unwind unreachable];\n    }\n    bb40: {\n        switchInt(move _57) -> [0: bb51, otherwise: bb41];\n    }\n    bb41: {\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &_56;\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = log::max_level() -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        _62 = &_63;\n        _60 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _61, move _62) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        switchInt(move _60) -> [0: bb50, otherwise: bb44];\n    }\n    bb44: {\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageDead(_61);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        _67 = &((*_55).0: u8);\n        StorageLive(_68);\n        _68 = &((*_55).1: u32);\n        _66 = (move _67, move _68);\n        StorageDead(_68);\n        StorageDead(_67);\n        StorageLive(_69);\n        StorageLive(_70);\n        _110 = (_66.0: &u8);\n        _70 = core::fmt::rt::Argument::<'_>::new_display::<u8>(_110) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageLive(_71);\n        _111 = (_66.1: &u32);\n        _71 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_111) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _69 = [move _70, move _71];\n        StorageDead(_71);\n        StorageDead(_70);\n        StorageLive(_72);\n        _72 = b\"![IOAPIC]: Override ISA interrupt \\xc0\\t for GSI \\xc0\\x00\";\n        _73 = &_69;\n        _65 = core::fmt::Arguments::<'_>::new::<47, 2>(move _72, _73) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_72);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = \"ostd::arch::irq::chip\";\n        _77 = log::__private_api::loc() -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        _75 = (move _76, \"ostd::arch::irq::chip\", _77);\n        StorageDead(_76);\n        _74 = &_75;\n        _64 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _65, _56, _74, ()) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_65);\n        StorageDead(_75);\n        StorageDead(_69);\n        StorageDead(_66);\n        goto -> bb52;\n    }\n    bb50: {\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageDead(_61);\n        goto -> bb52;\n    }\n    bb51: {\n        StorageDead(_59);\n        StorageDead(_58);\n        goto -> bb52;\n    }\n    bb52: {\n        StorageDead(_60);\n        StorageDead(_57);\n        StorageDead(_55);\n        StorageDead(_52);\n        goto -> bb36;\n    }\n    bb53: {\n        StorageDead(_80);\n        _78 = alloc::slice::<impl [arch::irq::chip::ioapic::IoApic]>::sort_by_key::<u32, {closure@ostd/src/arch/x86/irq/chip/mod.rs:230:26: 230:35}>(_79, ZeroSized: {closure@ostd/src/arch/x86/irq/chip/mod.rs:230:26: 230:35}) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageLive(_81);\n        StorageLive(_82);\n        _82 = &_14;\n        _81 = alloc::vec::Vec::<arch::irq::chip::ioapic::IoApic>::is_empty(move _82) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        switchInt(move _81) -> [0: bb57, otherwise: bb56];\n    }\n    bb56: {\n        StorageDead(_82);\n        StorageLive(_84);\n        _84 = core::fmt::Arguments::<'_>::from_str(\"No I/O APICs found\") -> [return: bb58, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_82);\n        StorageDead(_81);\n        StorageLive(_85);\n        StorageLive(_86);\n        StorageLive(_87);\n        StorageLive(_89);\n        _89 = &_14;\n        _88 = <alloc::vec::Vec<arch::irq::chip::ioapic::IoApic> as core::ops::Index<usize>>::index(move _89, 0_usize) -> [return: bb59, unwind unreachable];\n    }\n    bb58: {\n        _83 = core::panicking::panic_fmt(move _84) -> unwind unreachable;\n    }\n    bb59: {\n        StorageDead(_89);\n        _87 = arch::irq::chip::ioapic::IoApic::interrupt_base(_88) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        _86 = &_87;\n        StorageLive(_90);\n        _90 = arch::irq::chip::init::promoted[1];\n        _85 = (move _86, move _90);\n        StorageDead(_90);\n        StorageDead(_86);\n        _91 = (_85.0: &u32);\n        _92 = (_85.1: &u32);\n        StorageLive(_93);\n        StorageLive(_94);\n        _94 = (*_91);\n        StorageLive(_95);\n        _95 = (*_92);\n        _93 = Eq(move _94, move _95);\n        switchInt(move _93) -> [0: bb62, otherwise: bb61];\n    }\n    bb61: {\n        StorageDead(_95);\n        StorageDead(_94);\n        StorageDead(_93);\n        StorageDead(_87);\n        StorageDead(_85);\n        StorageLive(_100);\n        StorageLive(_101);\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = move _14;\n        _102 = alloc::vec::Vec::<arch::irq::chip::ioapic::IoApic>::into_boxed_slice(move _103) -> [return: bb64, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_95);\n        StorageDead(_94);\n        _96 = core::panicking::AssertKind::Eq;\n        StorageLive(_98);\n        StorageLive(_99);\n        _99 = core::fmt::Arguments::<'_>::from_str(\"No I/O APIC with zero interrupt base found\") -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        _98 = core::option::Option::Some(move _99);\n        StorageDead(_99);\n        _97 = core::panicking::assert_failed::<u32, u32>(_96, _91, _92, move _98) -> unwind unreachable;\n    }\n    bb64: {\n        StorageDead(_103);\n        _101 = sync::spin::SpinLock::<alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>>::new(move _102) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        StorageDead(_102);\n        StorageLive(_104);\n        StorageLive(_105);\n        _105 = move _15;\n        _104 = alloc::vec::Vec::<arch::irq::chip::IsaOverride>::into_boxed_slice(move _105) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_105);\n        _100 = IrqChip(move _101, move _104);\n        StorageDead(_104);\n        StorageDead(_101);\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = {alloc261: &spin::once::Once<arch::irq::chip::IrqChip>};\n        StorageLive(_108);\n        _108 = {closure@ostd/src/arch/x86/irq/chip/mod.rs:242:24: 242:26}(move _100);\n        _106 = spin::once::Once::<arch::irq::chip::IrqChip>::call_once::<{closure@ostd/src/arch/x86/irq/chip/mod.rs:242:24: 242:26}>(move _107, move _108) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_108);\n        StorageDead(_107);\n        StorageDead(_106);\n        StorageDead(_100);\n        StorageDead(_15);\n        StorageDead(_14);\n        drop(_4) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_4);\n        drop(_2) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}