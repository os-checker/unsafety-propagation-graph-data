{
  "name": "mm::dma::util::alloc_unprotect_physical_range",
  "safe": false,
  "callees": {
    "core::num::<impl usize>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "util::range_counter::RangeCounter::add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds one new count for all counters in the range.\n\n Returns ranges that the counter has updated from zero to one.\n\n # Panics\n\n Panics if the range has a negative size.\n",
      "adt": {
        "core::ops::Range": "Constructor",
        "util::range_counter::RangeCounter": "MutableAsArgument",
        "alloc::vec::IntoIter": "Constructor"
      }
    },
    "tdx_guest::tdx_is_enabled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "arch::tdx_guest::unprotect_gpa_tdvm_call": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts physical pages to Intel TDX shared pages.\n\n It invokes the [`map_gpa`] TDVMCALL to convert those pages into Intel TDX\n shared pages. Due to the conversion, any existing data on the pages will\n be lost.\n\n # Safety\n\n The caller must ensure that:\n  - The provided physical address is page aligned.\n  - The provided physical address range is in bounds, i.e., it should fall\n    within the maximum Guest Physical Address (GPA) limit.\n  - All of the physical pages are untyped memory. Therefore, converting and\n    erasing the data will not cause memory safety issues.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "alloc::alloc::exchange_malloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc::slice::<impl [T]>::into_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts `self` into a vector without clones or allocation.\n\n The resulting vector can be converted back into a box via\n `Vec<T>`'s `into_boxed_slice` method.\n\n # Examples\n\n ```\n let s: Box<[i32]> = Box::new([10, 40, 30]);\n let x = s.into_vec();\n // `s` cannot be used anymore because it has been converted into `x`.\n\n assert_eq!(x, vec![10, 40, 30]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::ops::Range": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "util::range_counter::RangeCounter": [
      "MutRef"
    ],
    "alloc::vec::IntoIter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "alloc::vec::Vec": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "core::ptr::Unique": [
      "Plain"
    ],
    "alloc::boxed::Box": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4210, kind: RigidTy(Adt(AdtDef(DefId { id: 3281, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 4206, kind: RigidTy(Array(Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) }, TyConst { kind: Value(Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(1), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(13, ThreadLocalIndex) })) })]))) }), Field(0, Ty { id: 4211, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 4206, kind: RigidTy(Array(Ty { id: 104, kind: RigidTy(Adt(AdtDef(DefId { id: 2829, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 11, kind: RigidTy(Uint(Usize)) })]))) }, TyConst { kind: Value(Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(1), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(13, ThreadLocalIndex) })) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::dma::util::alloc_unprotect_physical_range"
  },
  "span": "ostd/src/mm/dma/util.rs:163:1: 193:2",
  "src": "unsafe fn alloc_unprotect_physical_range(pa_range: &Range<Paddr>) {\n    use alloc::{vec, vec::Vec};\n\n    debug_assert!(pa_range.start.is_multiple_of(PAGE_SIZE));\n    debug_assert!(pa_range.end.is_multiple_of(PAGE_SIZE));\n    let pfn_range = pa_range.start / PAGE_SIZE..pa_range.end / PAGE_SIZE;\n\n    let mut refcnts = PADDR_REF_CNTS.lock();\n    let ranges = refcnts.add(&pfn_range);\n    #[cfg(target_arch = \"x86_64\")]\n    crate::arch::if_tdx_enabled!({\n        for partial in ranges {\n            debug_assert_eq!(partial, pfn_range.clone());\n            // SAFETY:\n            //  - The provided physical address is page aligned.\n            //  - The provided physical address range is in bounds.\n            //  - All of the physical pages are untyped memory.\n            unsafe {\n                crate::arch::tdx_guest::unprotect_gpa_tdvm_call(\n                    partial.start * PAGE_SIZE,\n                    partial.len() * PAGE_SIZE,\n                )\n                .expect(\"failed to unprotect the DMA segment in TDX guest\");\n            }\n        }\n    } else {\n        debug_assert_eq!(ranges.collect::<Vec<_>>(), vec![pfn_range.clone()]);\n    });\n    #[cfg(not(target_arch = \"x86_64\"))]\n    debug_assert_eq!(ranges.collect::<Vec<_>>(), vec![pfn_range.clone()]);\n}",
  "mir": "fn mm::dma::util::alloc_unprotect_physical_range(_1: &core::ops::Range<usize>) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: !;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: !;\n    let  _8: core::ops::Range<usize>;\n    let mut _9: usize;\n    let mut _10: usize;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: bool;\n    let mut _15: sync::spin::SpinLockGuard<'_, util::range_counter::RangeCounter, sync::guard::PreemptDisabled>;\n    let mut _16: &sync::spin::SpinLock<util::range_counter::RangeCounter>;\n    let  _17: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _18: &mut util::range_counter::RangeCounter;\n    let mut _19: &mut sync::spin::SpinLockGuard<'_, util::range_counter::RangeCounter, sync::guard::PreemptDisabled>;\n    let  _20: &core::ops::Range<usize>;\n    let mut _21: bool;\n    let mut _22: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _23: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _24: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _25: core::option::Option<core::ops::Range<usize>>;\n    let mut _26: &mut alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _27: isize;\n    let  _28: core::ops::Range<usize>;\n    let mut _29: (&core::ops::Range<usize>, &core::ops::Range<usize>);\n    let mut _30: &core::ops::Range<usize>;\n    let mut _31: &core::ops::Range<usize>;\n    let  _32: core::ops::Range<usize>;\n    let mut _33: &core::ops::Range<usize>;\n    let  _34: &core::ops::Range<usize>;\n    let  _35: &core::ops::Range<usize>;\n    let mut _36: bool;\n    let  _37: core::panicking::AssertKind;\n    let  _38: !;\n    let mut _39: core::option::Option<core::fmt::Arguments<'_>>;\n    let  _40: ();\n    let mut _41: core::result::Result<(), arch::tdx_guest::PageConvertError>;\n    let mut _42: usize;\n    let mut _43: usize;\n    let mut _44: (usize, bool);\n    let mut _45: usize;\n    let mut _46: usize;\n    let mut _47: &core::ops::Range<usize>;\n    let mut _48: (usize, bool);\n    let mut _49: &str;\n    let mut _50: (&alloc::vec::Vec<core::ops::Range<usize>>, &alloc::vec::Vec<core::ops::Range<usize>>);\n    let mut _51: &alloc::vec::Vec<core::ops::Range<usize>>;\n    let  _52: alloc::vec::Vec<core::ops::Range<usize>>;\n    let mut _53: alloc::vec::IntoIter<core::ops::Range<usize>>;\n    let mut _54: &alloc::vec::Vec<core::ops::Range<usize>>;\n    let  _55: alloc::vec::Vec<core::ops::Range<usize>>;\n    let mut _56: alloc::boxed::Box<[core::ops::Range<usize>]>;\n    let mut _57: *mut u8;\n    let mut _58: alloc::boxed::Box<[core::ops::Range<usize>; 1]>;\n    let mut _59: core::ops::Range<usize>;\n    let mut _60: &core::ops::Range<usize>;\n    let  _61: &alloc::vec::Vec<core::ops::Range<usize>>;\n    let  _62: &alloc::vec::Vec<core::ops::Range<usize>>;\n    let mut _63: bool;\n    let  _64: core::panicking::AssertKind;\n    let  _65: !;\n    let mut _66: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _67: bool;\n    let mut _68: *const [core::ops::Range<usize>; 1];\n    let mut _69: core::ptr::NonNull<[core::ops::Range<usize>; 1]>;\n    let mut _70: core::ptr::Unique<[core::ops::Range<usize>; 1]>;\n    let mut _71: *const [core::ops::Range<usize>; 1];\n    debug pa_range => _1;\n    debug pfn_range => _8;\n    debug refcnts => _15;\n    debug ranges => _17;\n    debug iter => _24;\n    debug partial => _28;\n    debug left_val => _34;\n    debug right_val => _35;\n    debug kind => _37;\n    debug left_val => _61;\n    debug right_val => _62;\n    debug kind => _64;\n    bb0: {\n        _67 = false;\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = ((*_1).0: usize);\n        _2 = core::num::<impl usize>::is_multiple_of(move _3, mm::PAGE_SIZE) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = ((*_1).1: usize);\n        _5 = core::num::<impl usize>::is_multiple_of(move _6, mm::PAGE_SIZE) -> [return: bb4, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        _4 = core::panicking::panic(\"assertion failed: pa_range.start.is_multiple_of(PAGE_SIZE)\") -> unwind unreachable;\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).0: usize);\n        _11 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _11, \"attempt to divide `{}` by zero\", _10) -> [success: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        _7 = core::panicking::panic(\"assertion failed: pa_range.end.is_multiple_of(PAGE_SIZE)\") -> unwind unreachable;\n    }\n    bb7: {\n        _9 = Div(move _10, mm::PAGE_SIZE);\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = ((*_1).1: usize);\n        _14 = Eq(mm::PAGE_SIZE, 0_usize);\n        assert(!move _14, \"attempt to divide `{}` by zero\", _13) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _12 = Div(move _13, mm::PAGE_SIZE);\n        StorageDead(_13);\n        _8 = Range(move _9, move _12);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = {alloc1141: &sync::spin::SpinLock<util::range_counter::RangeCounter>};\n        _15 = sync::spin::SpinLock::<util::range_counter::RangeCounter>::lock(move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_19);\n        _19 = &mut _15;\n        _18 = <sync::spin::SpinLockGuard<'_, util::range_counter::RangeCounter, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        _20 = &_8;\n        _17 = util::range_counter::RangeCounter::add(_18, _20) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _67 = true;\n        StorageLive(_21);\n        _21 = tdx_guest::tdx_is_enabled() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _21) -> [0: bb30, otherwise: bb13];\n    }\n    bb13: {\n        StorageLive(_22);\n        StorageLive(_23);\n        _67 = false;\n        _23 = move _17;\n        _22 = <alloc::vec::IntoIter<core::ops::Range<usize>> as core::iter::IntoIterator>::into_iter(move _23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageLive(_24);\n        _24 = move _22;\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_25);\n        _26 = &mut _24;\n        _25 = <alloc::vec::IntoIter<core::ops::Range<usize>> as core::iter::Iterator>::next(_26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _27 = discriminant(_25);\n        switchInt(move _27) -> [0: bb19, 1: bb18, otherwise: bb17];\n    }\n    bb17: {\n        unreachable;\n    }\n    bb18: {\n        StorageLive(_28);\n        _28 = move ((_25 as variant#1).0: core::ops::Range<usize>);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_28;\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_8;\n        _32 = <core::ops::Range<usize> as core::clone::Clone>::clone(move _33) -> [return: bb20, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_25);\n        drop(_24) -> [return: bb29, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_33);\n        _31 = &_32;\n        _29 = (move _30, move _31);\n        StorageDead(_31);\n        StorageDead(_30);\n        _34 = (_29.0: &core::ops::Range<usize>);\n        _35 = (_29.1: &core::ops::Range<usize>);\n        StorageLive(_36);\n        _36 = <core::ops::Range<usize> as core::cmp::PartialEq>::eq(_34, _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        switchInt(move _36) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_36);\n        StorageDead(_32);\n        StorageDead(_29);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = (_28.0: usize);\n        _44 = CheckedMul(_43, mm::PAGE_SIZE);\n        assert(!move (_44.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _43, mm::PAGE_SIZE) -> [success: bb24, unwind unreachable];\n    }\n    bb23: {\n        _37 = core::panicking::AssertKind::Eq;\n        StorageLive(_39);\n        _39 = core::option::Option::None;\n        _38 = core::panicking::assert_failed::<core::ops::Range<usize>, core::ops::Range<usize>>(_37, _34, _35, move _39) -> unwind unreachable;\n    }\n    bb24: {\n        _42 = move (_44.0: usize);\n        StorageDead(_43);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = &_28;\n        _46 = <core::ops::Range<usize> as core::iter::ExactSizeIterator>::len(move _47) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_47);\n        _48 = CheckedMul(_46, mm::PAGE_SIZE);\n        assert(!move (_48.1: bool), \"attempt to compute `{} * {}`, which would overflow\", move _46, mm::PAGE_SIZE) -> [success: bb26, unwind unreachable];\n    }\n    bb26: {\n        _45 = move (_48.0: usize);\n        StorageDead(_46);\n        _41 = arch::tdx_guest::unprotect_gpa_tdvm_call(move _42, move _45) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_45);\n        StorageDead(_42);\n        StorageLive(_49);\n        _49 = \"failed to unprotect the DMA segment in TDX guest\";\n        _40 = core::result::Result::<(), arch::tdx_guest::PageConvertError>::expect(move _41, move _49) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_49);\n        StorageDead(_41);\n        StorageDead(_28);\n        StorageDead(_25);\n        goto -> bb15;\n    }\n    bb29: {\n        StorageDead(_24);\n        StorageDead(_22);\n        goto -> bb40;\n    }\n    bb30: {\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _67 = false;\n        _53 = move _17;\n        _52 = <alloc::vec::IntoIter<core::ops::Range<usize>> as core::iter::Iterator>::collect::<alloc::vec::Vec<core::ops::Range<usize>>>(move _53) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_53);\n        _51 = &_52;\n        StorageLive(_54);\n        StorageLive(_55);\n        StorageLive(_56);\n        _57 = alloc::alloc::exchange_malloc(<[core::ops::Range<usize>; 1] as core::mem::SizedTypeProperties>::SIZE, <[core::ops::Range<usize>; 1] as core::mem::SizedTypeProperties>::ALIGN) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _68 = move _57 as *const [core::ops::Range<usize>; 1];\n        _69 = NonNull(move _68);\n        _70 = Unique(move _69, core::marker::PhantomData::<[core::ops::Range<usize>; 1]>);\n        _58 = Box(move _70, alloc::alloc::Global);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &_8;\n        _59 = <core::ops::Range<usize> as core::clone::Clone>::clone(move _60) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_60);\n        _71 = ((_58.0: core::ptr::Unique<[core::ops::Range<usize>; 1]>).0: core::ptr::NonNull<[core::ops::Range<usize>; 1]>) as *const [core::ops::Range<usize>; 1];\n        (*_71) = [move _59];\n        StorageDead(_59);\n        _56 = _58 as alloc::boxed::Box<[core::ops::Range<usize>]>;\n        _55 = alloc::slice::<impl [core::ops::Range<usize>]>::into_vec::<alloc::alloc::Global>(move _56) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_56);\n        _54 = &_55;\n        _50 = (move _51, move _54);\n        StorageDead(_54);\n        StorageDead(_51);\n        _61 = (_50.0: &alloc::vec::Vec<core::ops::Range<usize>>);\n        _62 = (_50.1: &alloc::vec::Vec<core::ops::Range<usize>>);\n        StorageLive(_63);\n        _63 = <alloc::vec::Vec<core::ops::Range<usize>> as core::cmp::PartialEq>::eq(_61, _62) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        switchInt(move _63) -> [0: bb37, otherwise: bb36];\n    }\n    bb36: {\n        StorageDead(_63);\n        drop(_55) -> [return: bb38, unwind unreachable];\n    }\n    bb37: {\n        _64 = core::panicking::AssertKind::Eq;\n        StorageLive(_66);\n        _66 = core::option::Option::None;\n        _65 = core::panicking::assert_failed::<alloc::vec::Vec<core::ops::Range<usize>>, alloc::vec::Vec<core::ops::Range<usize>>>(_64, _61, _62, move _66) -> unwind unreachable;\n    }\n    bb38: {\n        StorageDead(_55);\n        drop(_52) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_52);\n        StorageDead(_50);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageDead(_21);\n        switchInt(_67) -> [0: bb41, otherwise: bb43];\n    }\n    bb41: {\n        _67 = false;\n        StorageDead(_17);\n        drop(_15) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_15);\n        StorageDead(_8);\n        return;\n    }\n    bb43: {\n        drop(_17) -> [return: bb41, unwind unreachable];\n    }\n}\n",
  "doc": " Marks a physical address range as used (also unprotected if in TDX guest).\n\n # Safety\n\n The provided physical address range must be untyped DMA memory that\n outlives the following [`dealloc_protect_physical_range()`] call.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}