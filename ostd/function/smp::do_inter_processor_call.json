{
  "name": "smp::do_inter_processor_call",
  "safe": false,
  "callees": {
    "cpu::id::current::<impl cpu::id::CpuId>::current_racy": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the ID of the current CPU.\n\n This function is safe to call, but is vulnerable to races. The returned CPU\n ID may be outdated if the task migrates to another CPU.\n\n To ensure that the CPU ID is up-to-date, do it under any guards that\n implement the [`PinCurrentCpu`] trait.\n",
      "adt": {
        "cpu::id::CpuId": "Constructor"
      }
    },
    "cpu::local::CpuLocal::<T, S>::get_on_cpu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets access to the CPU-local value on a specific CPU.\n\n This allows the caller to access CPU-local data from a remote CPU,\n so the data type must be `Sync`.\n",
      "adt": {
        "cpu::local::CpuLocal": "ImmutableAsArgument"
      }
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "alloc::collections::VecDeque::<T, A>::pop_front": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the first element and returns it, or `None` if the deque is\n empty.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut d = VecDeque::new();\n d.push_back(1);\n d.push_back(2);\n\n assert_eq!(d.pop_front(), Some(1));\n assert_eq!(d.pop_front(), Some(2));\n assert_eq!(d.pop_front(), None);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "cpu::id::CpuId": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "cpu::local::CpuLocal": [
      "Ref"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "alloc::collections::VecDeque": [
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3120, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 107, kind: RigidTy(Tuple([])) }], c_variadic: false, safety: Safe, abi: Rust }, bound_vars: [] })) })])"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "arch::trap::TrapFrame": [
      "Ref"
    ]
  },
  "path": 2533,
  "span": "ostd/src/smp.rs:92:1: 105:2",
  "src": "pub(crate) unsafe fn do_inter_processor_call(_trapframe: &TrapFrame) {\n    // No races because we are in IRQs.\n    let this_cpu_id = crate::cpu::CpuId::current_racy();\n\n    let mut queue = CALL_QUEUES.get_on_cpu(this_cpu_id).lock();\n    while let Some(f) = queue.pop_front() {\n        log::trace!(\n            \"Performing inter-processor call to {:#?} on CPU {:#?}\",\n            f,\n            this_cpu_id,\n        );\n        f();\n    }\n}",
  "mir": "fn smp::do_inter_processor_call(_1: &arch::trap::TrapFrame) -> () {\n    let mut _0: ();\n    let  _2: cpu::id::CpuId;\n    let mut _3: sync::spin::SpinLockGuard<'_, alloc::collections::VecDeque<fn()>, sync::guard::PreemptDisabled>;\n    let  _4: &sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>;\n    let mut _5: &cpu::local::CpuLocal<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>>>;\n    let mut _6: core::option::Option<fn()>;\n    let mut _7: &mut alloc::collections::VecDeque<fn()>;\n    let mut _8: &mut sync::spin::SpinLockGuard<'_, alloc::collections::VecDeque<fn()>, sync::guard::PreemptDisabled>;\n    let mut _9: isize;\n    let  _10: fn();\n    let  _11: log::Level;\n    let mut _12: bool;\n    let mut _13: &log::Level;\n    let mut _14: &log::LevelFilter;\n    let mut _15: bool;\n    let mut _16: &log::Level;\n    let mut _17: &log::LevelFilter;\n    let  _18: log::LevelFilter;\n    let  _19: ();\n    let mut _20: core::fmt::Arguments<'_>;\n    let  _21: (&fn(), &cpu::id::CpuId);\n    let mut _22: &fn();\n    let mut _23: &cpu::id::CpuId;\n    let  _24: [core::fmt::rt::Argument<'_>; 2];\n    let mut _25: core::fmt::rt::Argument<'_>;\n    let mut _26: core::fmt::rt::Argument<'_>;\n    let mut _27: &[u8; 56];\n    let  _28: &[core::fmt::rt::Argument<'_>; 2];\n    let  _29: &(&str, &str, &core::panic::Location<'_>);\n    let  _30: (&str, &str, &core::panic::Location<'_>);\n    let mut _31: &str;\n    let  _32: &core::panic::Location<'_>;\n    let  _33: ();\n    let mut _34: &fn();\n    let mut _35: &cpu::id::CpuId;\n    debug _trapframe => _1;\n    debug this_cpu_id => _2;\n    debug queue => _3;\n    debug f => _10;\n    debug lvl => _11;\n    debug args => _21;\n    debug args => _24;\n    bb0: {\n        _2 = cpu::id::current::<impl cpu::id::CpuId>::current_racy() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_5);\n        _5 = {alloc1434: &cpu::local::CpuLocal<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>>>};\n        _4 = cpu::local::CpuLocal::<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<alloc::collections::VecDeque<fn()>>>>::get_on_cpu(move _5, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = sync::spin::SpinLock::<alloc::collections::VecDeque<fn()>>::lock(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_6);\n        StorageLive(_8);\n        _8 = &mut _3;\n        _7 = <sync::spin::SpinLockGuard<'_, alloc::collections::VecDeque<fn()>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _6 = alloc::collections::VecDeque::<fn()>::pop_front(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = discriminant(_6);\n        switchInt(move _9) -> [1: bb7, 0: bb22, otherwise: bb24];\n    }\n    bb7: {\n        _10 = ((_6 as variant#1).0: fn());\n        _11 = log::Level::Trace;\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_11;\n        StorageLive(_14);\n        _14 = smp::do_inter_processor_call::promoted[0];\n        _12 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _13, move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _12) -> [0: bb19, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_11;\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = log::max_level() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _17 = &_18;\n        _15 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _16, move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _15) -> [0: bb18, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_10;\n        StorageLive(_23);\n        _23 = &_2;\n        _21 = (move _22, move _23);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _34 = (_21.0: &fn());\n        _25 = core::fmt::rt::Argument::<'_>::new_debug::<fn()>(_34) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_26);\n        _35 = (_21.1: &cpu::id::CpuId);\n        _26 = core::fmt::rt::Argument::<'_>::new_debug::<cpu::id::CpuId>(_35) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _24 = [move _25, move _26];\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageLive(_27);\n        _27 = b\"#Performing inter-processor call to \\xc1 \\x00\\x80`\\x08 on CPU \\xc1 \\x00\\x80`\\x00\";\n        _28 = &_24;\n        _20 = core::fmt::Arguments::<'_>::new::<56, 2>(move _27, _28) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_27);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = \"ostd::smp\";\n        _32 = log::__private_api::loc() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _30 = (move _31, \"ostd::smp\", _32);\n        StorageDead(_31);\n        _29 = &_30;\n        _19 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _20, _11, _29, ()) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_20);\n        StorageDead(_30);\n        StorageDead(_24);\n        StorageDead(_21);\n        goto -> bb20;\n    }\n    bb18: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_15);\n        StorageDead(_12);\n        _33 = _10() -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_6);\n        goto -> bb4;\n    }\n    bb22: {\n        StorageDead(_6);\n        drop(_3) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_3);\n        return;\n    }\n    bb24: {\n        unreachable;\n    }\n}\n",
  "doc": " Handles inter-processor calls.\n\n # Safety\n\n This function must be called from an IRQ handler that can be triggered by\n inter-processor interrupts.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}