{
  "name": "mm::page_table::PageTable::<C>::root_paddr",
  "safe": true,
  "callees": {
    "mm::mem_obj::HasPaddr::paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the start physical address of the memory object.\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::Frame": [
      "Ref"
    ],
    "mm::page_table::PageTable": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ]
  },
  "path": 2427,
  "span": "ostd/src/mm/page_table/mod.rs:379:5: 381:6",
  "src": "pub fn root_paddr(&self) -> Paddr {\n        self.root.paddr()\n    }",
  "mir": "fn mm::page_table::PageTable::<C>::root_paddr(_1: &mm::page_table::PageTable<C>) -> usize {\n    let mut _0: usize;\n    let mut _2: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = &((*_1).0: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>);\n        _0 = <mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>> as mm::mem_obj::HasPaddr>::paddr(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " The physical address of the root page table.\n\n Obtaining the physical address of the root page table is safe, however, using it or\n providing it to the hardware will be unsafe since the page table node may be dropped,\n resulting in UAF.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}