{
  "name": "arch::iommu::dma_remapping::init",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::registers::IommuRegisters::read_capability": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the capability of IOMMU\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "ImmutableAsArgument",
        "arch::iommu::registers::capability::Capability": "Constructor"
      }
    },
    "arch::iommu::registers::capability::Capability::supported_adjusted_guest_address_widths": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Supported Adjusted Guest Address Widths.\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument",
        "arch::iommu::registers::capability::CapabilitySagaw": "Constructor"
      }
    },
    "arch::iommu::registers::capability::CapabilitySagaw::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if all of the flags in `other` are contained within `self`.\n",
      "adt": {
        "arch::iommu::registers::capability::CapabilitySagaw": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::iommu::dma_remapping::context_table::RootTable::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::dma_remapping::context_table::RootTable": "Constructor"
      }
    },
    "mm::page_table::PageTable::<C>::empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new empty page table.\n\n Useful for the IOMMU page tables only.\n",
      "adt": {
        "mm::page_table::PageTable": "Constructor"
      }
    },
    "arch::iommu::dma_remapping::PciDeviceLocation::all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that enumerates all possible PCI device locations.\n",
      "adt": {
        "core::iter::Map": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::page_table::PageTable::<C>::shallow_copy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new reference to the same page table.\n The caller must ensure that the kernel page table is not copied.\n This is only useful for IOMMU page tables. Think twice before using it in other cases.\n",
      "adt": {
        "mm::page_table::PageTable": "Constructor"
      }
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    },
    "arch::iommu::dma_remapping::context_table::RootTable::specify_device_page_table": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Specifies the device page table instead of creating a page table if not exists.\n\n This will be useful if we want all the devices to use the same page table.\n The original page table will be overwritten.\n",
      "adt": {
        "arch::iommu::dma_remapping::context_table::RootTable": "MutableAsArgument",
        "mm::page_table::PageTable": "ImmutableAsArgument"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::registers::IommuRegisters::enable_dma_remapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables DMA remapping with static RootTable\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "arch::iommu::registers::IommuRegisters": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 995, kind: RigidTy(Adt(AdtDef(DefId { id: 3432, name: \"arch::iommu::dma_remapping::PciDeviceLocation\" }), GenericArgs([]))) })])"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "arch::iommu::registers::IommuRegisters": [
      "Ref",
      "MutRef"
    ],
    "arch::iommu::registers::capability::Capability": [
      "Plain",
      "Ref"
    ],
    "arch::iommu::registers::capability::CapabilitySagaw": [
      "Plain",
      "Ref"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "arch::iommu::dma_remapping::context_table::RootTable": [
      "Plain",
      "MutRef"
    ],
    "mm::page_table::PageTable": [
      "Plain",
      "Ref"
    ],
    "core::iter::Map": [
      "Plain",
      "MutRef"
    ],
    "arch::iommu::dma_remapping::PciDeviceLocation": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::iommu::dma_remapping::init"
  },
  "span": "ostd/src/arch/x86/iommu/dma_remapping/mod.rs:123:1: 154:2",
  "src": "pub fn init() {\n    if !IOMMU_REGS\n        .get()\n        .unwrap()\n        .lock()\n        .read_capability()\n        .supported_adjusted_guest_address_widths()\n        .contains(CapabilitySagaw::AGAW_39BIT_3LP)\n    {\n        warn!(\"[IOMMU] 3-level page tables not supported, disabling DMA remapping\");\n        return;\n    }\n\n    // Create a Root Table instance.\n    let mut root_table = RootTable::new();\n    // For all PCI devices, use the same page table.\n    //\n    // TODO: The BIOS reserves some memory regions as DMA targets and lists them in the Reserved\n    // Memory Region Reporting (RMRR) structures. These regions must be mapped for the hardware or\n    // firmware to function properly. For more details, see Intel(R) Virtualization Technology for\n    // Directed I/O (Revision 5.0), 3.16 Handling Requests to Reserved System Memory.\n    let page_table = PageTable::<IommuPtConfig>::empty();\n    for table in PciDeviceLocation::all() {\n        root_table.specify_device_page_table(table, unsafe { page_table.shallow_copy() })\n    }\n    PAGE_TABLE.call_once(|| SpinLock::new(root_table));\n\n    // Enable DMA remapping.\n    let mut iommu_regs = IOMMU_REGS.get().unwrap().lock();\n    iommu_regs.enable_dma_remapping(PAGE_TABLE.get().unwrap());\n    info!(\"[IOMMU] DMA remapping enabled\");\n}",
  "mir": "fn arch::iommu::dma_remapping::init() -> () {\n    let mut _0: ();\n    let mut _1: bool;\n    let mut _2: &arch::iommu::registers::capability::CapabilitySagaw;\n    let  _3: arch::iommu::registers::capability::CapabilitySagaw;\n    let mut _4: &arch::iommu::registers::capability::Capability;\n    let  _5: arch::iommu::registers::capability::Capability;\n    let  _6: &arch::iommu::registers::IommuRegisters;\n    let mut _7: &sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _8: sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _9: &sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let mut _10: core::option::Option<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let mut _11: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let  _12: log::Level;\n    let mut _13: bool;\n    let mut _14: &log::Level;\n    let mut _15: &log::LevelFilter;\n    let mut _16: bool;\n    let mut _17: &log::Level;\n    let mut _18: &log::LevelFilter;\n    let  _19: log::LevelFilter;\n    let  _20: ();\n    let mut _21: core::fmt::Arguments<'_>;\n    let  _22: &(&str, &str, &core::panic::Location<'_>);\n    let  _23: (&str, &str, &core::panic::Location<'_>);\n    let mut _24: &str;\n    let  _25: &core::panic::Location<'_>;\n    let mut _26: arch::iommu::dma_remapping::context_table::RootTable;\n    let  _27: mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _28: core::iter::Map<core::iter::FlatMap<core::iter::FlatMap<core::ops::RangeInclusive<u8>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:54: 54:64}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:23: 54:33}>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:62: 55:73}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:23: 55:40}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:56:18: 56:36}>;\n    let mut _29: core::iter::Map<core::iter::FlatMap<core::iter::FlatMap<core::ops::RangeInclusive<u8>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:54: 54:64}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:23: 54:33}>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:62: 55:73}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:23: 55:40}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:56:18: 56:36}>;\n    let mut _30: core::iter::Map<core::iter::FlatMap<core::iter::FlatMap<core::ops::RangeInclusive<u8>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:54: 54:64}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:23: 54:33}>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:62: 55:73}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:23: 55:40}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:56:18: 56:36}>;\n    let  _31: ();\n    let mut _32: core::option::Option<arch::iommu::dma_remapping::PciDeviceLocation>;\n    let mut _33: &mut core::iter::Map<core::iter::FlatMap<core::iter::FlatMap<core::ops::RangeInclusive<u8>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:54: 54:64}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:23: 54:33}>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:62: 55:73}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:23: 55:40}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:56:18: 56:36}>;\n    let mut _34: isize;\n    let  _35: arch::iommu::dma_remapping::PciDeviceLocation;\n    let mut _36: &mut arch::iommu::dma_remapping::context_table::RootTable;\n    let mut _37: mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _38: &mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let  _39: &sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>;\n    let mut _40: &spin::once::Once<sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>;\n    let mut _41: {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:148:26: 148:28};\n    let mut _42: sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _43: &sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let mut _44: core::option::Option<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let mut _45: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let  _46: ();\n    let mut _47: &mut arch::iommu::registers::IommuRegisters;\n    let mut _48: &mut sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _49: &sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>;\n    let mut _50: core::option::Option<&sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>;\n    let mut _51: &spin::once::Once<sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>;\n    let  _52: log::Level;\n    let mut _53: bool;\n    let mut _54: &log::Level;\n    let mut _55: &log::LevelFilter;\n    let mut _56: bool;\n    let mut _57: &log::Level;\n    let mut _58: &log::LevelFilter;\n    let  _59: log::LevelFilter;\n    let  _60: ();\n    let mut _61: core::fmt::Arguments<'_>;\n    let  _62: &(&str, &str, &core::panic::Location<'_>);\n    let  _63: (&str, &str, &core::panic::Location<'_>);\n    let mut _64: &str;\n    let  _65: &core::panic::Location<'_>;\n    debug lvl => _12;\n    debug root_table => _26;\n    debug page_table => _27;\n    debug iter => _30;\n    debug table => _35;\n    debug iommu_regs => _42;\n    debug lvl => _52;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = {alloc227: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>};\n        _10 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::get(move _11) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_11);\n        _9 = core::option::Option::<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::unwrap(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        _8 = sync::spin::SpinLock::<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>::lock(_9) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = &_8;\n        _6 = <sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled> as core::ops::Deref>::deref(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = arch::iommu::registers::IommuRegisters::read_capability(_6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _4 = &_5;\n        _3 = arch::iommu::registers::capability::Capability::supported_adjusted_guest_address_widths(move _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _2 = &_3;\n        StorageDead(_4);\n        _1 = arch::iommu::registers::capability::CapabilitySagaw::contains(move _2, arch::iommu::registers::capability::CapabilitySagaw::AGAW_39BIT_3LP) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _1) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_2);\n        drop(_8) -> [return: bb22, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_2);\n        drop(_8) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageDead(_3);\n        _12 = log::Level::Warn;\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_12;\n        StorageLive(_15);\n        _15 = arch::iommu::dma_remapping::init::promoted[1];\n        _13 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _14, move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _13) -> [0: bb20, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_12;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = log::max_level() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = &_19;\n        _16 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _17, move _18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _16) -> [0: bb19, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_21);\n        _21 = core::fmt::Arguments::<'_>::from_str(\"[IOMMU] 3-level page tables not supported, disabling DMA remapping\") -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = \"ostd::arch::iommu::dma_remapping\";\n        _25 = log::__private_api::loc() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _23 = (move _24, \"ostd::arch::iommu::dma_remapping\", _25);\n        StorageDead(_24);\n        _22 = &_23;\n        _20 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _21, _12, _22, ()) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_21);\n        StorageDead(_23);\n        goto -> bb21;\n    }\n    bb19: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb21;\n    }\n    bb20: {\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageDead(_1);\n        goto -> bb55;\n    }\n    bb22: {\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageDead(_1);\n        StorageLive(_26);\n        _26 = arch::iommu::dma_remapping::context_table::RootTable::new() -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_27);\n        _27 = mm::page_table::PageTable::<arch::iommu::dma_remapping::second_stage::IommuPtConfig>::empty() -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = arch::iommu::dma_remapping::PciDeviceLocation::all() -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _28 = <core::iter::Map<core::iter::FlatMap<core::iter::FlatMap<core::ops::RangeInclusive<u8>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:54: 54:64}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:23: 54:33}>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:62: 55:73}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:23: 55:40}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:56:18: 56:36}> as core::iter::IntoIterator>::into_iter(move _29) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_29);\n        StorageLive(_30);\n        _30 = move _28;\n        goto -> bb27;\n    }\n    bb27: {\n        StorageLive(_32);\n        _33 = &mut _30;\n        _32 = <core::iter::Map<core::iter::FlatMap<core::iter::FlatMap<core::ops::RangeInclusive<u8>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:54: 54:64}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:54:23: 54:33}>, core::iter::Map<core::ops::RangeInclusive<u8>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:62: 55:73}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:55:23: 55:40}>, {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:56:18: 56:36}> as core::iter::Iterator>::next(_33) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _34 = discriminant(_32);\n        switchInt(move _34) -> [0: bb31, 1: bb30, otherwise: bb29];\n    }\n    bb29: {\n        unreachable;\n    }\n    bb30: {\n        _35 = ((_32 as variant#1).0: arch::iommu::dma_remapping::PciDeviceLocation);\n        StorageLive(_36);\n        _36 = &mut _26;\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &_27;\n        _37 = mm::page_table::PageTable::<arch::iommu::dma_remapping::second_stage::IommuPtConfig>::shallow_copy(move _38) -> [return: bb32, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_32);\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = {alloc141: &spin::once::Once<sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>};\n        StorageLive(_41);\n        _41 = {closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:148:26: 148:28}(move _26);\n        _39 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>::call_once::<{closure@ostd/src/arch/x86/iommu/dma_remapping/mod.rs:148:26: 148:28}>(move _40, move _41) -> [return: bb34, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_38);\n        _31 = arch::iommu::dma_remapping::context_table::RootTable::specify_device_page_table(move _36, _35, move _37) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_32);\n        goto -> bb27;\n    }\n    bb34: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_42);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = {alloc227: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>};\n        _44 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::get(move _45) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_45);\n        _43 = core::option::Option::<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::unwrap(move _44) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_44);\n        _42 = sync::spin::SpinLock::<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>::lock(_43) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageLive(_48);\n        _48 = &mut _42;\n        _47 = <sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled> as core::ops::DerefMut>::deref_mut(move _48) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_48);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = {alloc141: &spin::once::Once<sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>};\n        _50 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>::get(move _51) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_51);\n        _49 = core::option::Option::<&sync::spin::SpinLock<arch::iommu::dma_remapping::context_table::RootTable, sync::guard::LocalIrqDisabled>>::unwrap(move _50) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_50);\n        _46 = arch::iommu::registers::IommuRegisters::enable_dma_remapping(_47, _49) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _52 = log::Level::Info;\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &_52;\n        StorageLive(_55);\n        _55 = arch::iommu::dma_remapping::init::promoted[0];\n        _53 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _54, move _55) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        switchInt(move _53) -> [0: bb51, otherwise: bb43];\n    }\n    bb43: {\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_52;\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = log::max_level() -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _58 = &_59;\n        _56 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _57, move _58) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        switchInt(move _56) -> [0: bb50, otherwise: bb46];\n    }\n    bb46: {\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageLive(_61);\n        _61 = core::fmt::Arguments::<'_>::from_str(\"[IOMMU] DMA remapping enabled\") -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = \"ostd::arch::iommu::dma_remapping\";\n        _65 = log::__private_api::loc() -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        _63 = (move _64, \"ostd::arch::iommu::dma_remapping\", _65);\n        StorageDead(_64);\n        _62 = &_63;\n        _60 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _61, _52, _62, ()) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_61);\n        StorageDead(_63);\n        goto -> bb52;\n    }\n    bb50: {\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_57);\n        goto -> bb52;\n    }\n    bb51: {\n        StorageDead(_55);\n        StorageDead(_54);\n        goto -> bb52;\n    }\n    bb52: {\n        StorageDead(_56);\n        StorageDead(_53);\n        drop(_42) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_42);\n        drop(_27) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_27);\n        StorageDead(_26);\n        goto -> bb55;\n    }\n    bb55: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}