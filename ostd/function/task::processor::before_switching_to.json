{
  "name": "task::processor::before_switching_to",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "task::kernel_stack::KernelStack::flush_tlb": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Flushes the TLB for the current CPU if necessary.\n",
      "adt": {
        "task::kernel_stack::KernelStack": "ImmutableAsArgument",
        "irq::guard::DisabledLocalIrqGuard": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicBool::compare_exchange": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the [`bool`] if the current value is the same as the `current` value.\n\n The return value is a result indicating whether the new value was written and containing\n the previous value. On success this value is guaranteed to be equal to `current`.\n\n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. `success` describes the required ordering for the\n read-modify-write operation that takes place if the comparison with `current` succeeds.\n `failure` describes the required ordering for the load operation that takes place when\n the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note:** This method is only available on platforms that support atomic\n operations on `u8`.\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n assert_eq!(some_bool.compare_exchange(true,\n                                       false,\n                                       Ordering::Acquire,\n                                       Ordering::Relaxed),\n            Ok(true));\n assert_eq!(some_bool.load(Ordering::Relaxed), false);\n\n assert_eq!(some_bool.compare_exchange(true, true,\n                                       Ordering::SeqCst,\n                                       Ordering::Acquire),\n            Err(false));\n assert_eq!(some_bool.load(Ordering::Relaxed), false);\n ```\n\n # Considerations\n\n `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n of CAS operations. In particular, a load of the value followed by a successful\n `compare_exchange` with the previous load *does not ensure* that other threads have not\n changed the value in the interim. This is usually important when the *equality* check in\n the `compare_exchange` is being used to check the *identity* of a value, but equality\n does not necessarily imply identity. In this case, `compare_exchange` can lead to the\n [ABA problem].\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::is_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Err`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_err(), false);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_err(), true);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::hint::spin_loop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Emits a machine instruction to signal the processor that it is running in\n a busy-wait spin-loop (\"spin lock\").\n\n Upon receiving the spin-loop signal the processor can optimize its behavior by,\n for example, saving power or switching hyper-threads.\n\n This function is different from [`thread::yield_now`] which directly\n yields to the system's scheduler, whereas `spin_loop` does not interact\n with the operating system.\n\n A common use case for `spin_loop` is implementing bounded optimistic\n spinning in a CAS loop in synchronization primitives. To avoid problems\n like priority inversion, it is strongly recommended that the spin loop is\n terminated after a finite amount of iterations and an appropriate blocking\n syscall is made.\n\n **Note**: On platforms that do not support receiving spin-loop hints this\n function does not do anything at all.\n\n # Examples\n\n ```ignore-wasm\n use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::Arc;\n use std::{hint, thread};\n\n // A shared atomic value that threads will use to coordinate\n let live = Arc::new(AtomicBool::new(false));\n\n // In a background thread we'll eventually set the value\n let bg_work = {\n     let live = live.clone();\n     thread::spawn(move || {\n         // Do some work, then make the value live\n         do_some_work();\n         live.store(true, Ordering::Release);\n     })\n };\n\n // Back on our current thread, we wait for the value to be set\n while !live.load(Ordering::Acquire) {\n     // The spin loop is a hint to the CPU that we're waiting, but probably\n     // not for very long\n     hint::spin_loop();\n }\n\n // The value is now set\n # fn do_some_work() {}\n do_some_work();\n bg_work.join()?;\n # Ok::<(), Box<dyn core::any::Any + Send + 'static>>(())\n ```\n\n [`thread::yield_now`]: ../../std/thread/fn.yield_now.html\n",
      "adt": {}
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3121, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3120, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 107, kind: RigidTy(Tuple([])) }], c_variadic: false, safety: Safe, abi: Rust }, bound_vars: [] })) }, Not)) })])"
    ],
    "task::kernel_stack::KernelStack": [
      "Ref"
    ],
    "task::Task": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))",
      "Ref"
    ],
    "irq::guard::DisabledLocalIrqGuard": [
      "Ref"
    ],
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Ref"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": 2787,
  "span": "ostd/src/task/processor.rs:95:1: 112:2",
  "src": "fn before_switching_to(next_task: &Task, irq_guard: &DisabledLocalIrqGuard) {\n    if let Some(handler) = PRE_SCHEDULE_HANDLER.get() {\n        handler();\n    }\n\n    // Ensure that the mapping to the kernel stack is valid.\n    next_task.kstack.flush_tlb(irq_guard);\n\n    // Ensure that we are not switching to a task that is already running.\n    while next_task\n        .switched_to_cpu\n        .compare_exchange(false, true, Ordering::AcqRel, Ordering::Relaxed)\n        .is_err()\n    {\n        log::warn!(\"Switching to a task already running in the foreground\");\n        core::hint::spin_loop();\n    }\n}",
  "mir": "fn task::processor::before_switching_to(_1: &task::Task, _2: &irq::guard::DisabledLocalIrqGuard) -> () {\n    let mut _0: ();\n    let mut _3: core::option::Option<&fn()>;\n    let mut _4: &spin::once::Once<fn()>;\n    let mut _5: isize;\n    let  _6: &fn();\n    let  _7: ();\n    let mut _8: fn();\n    let  _9: ();\n    let mut _10: &task::kernel_stack::KernelStack;\n    let mut _11: bool;\n    let mut _12: &core::result::Result<bool, bool>;\n    let  _13: core::result::Result<bool, bool>;\n    let mut _14: &core::sync::atomic::AtomicBool;\n    let mut _15: core::sync::atomic::Ordering;\n    let mut _16: core::sync::atomic::Ordering;\n    let  _17: log::Level;\n    let mut _18: bool;\n    let mut _19: &log::Level;\n    let mut _20: &log::LevelFilter;\n    let mut _21: bool;\n    let mut _22: &log::Level;\n    let mut _23: &log::LevelFilter;\n    let  _24: log::LevelFilter;\n    let  _25: ();\n    let mut _26: core::fmt::Arguments<'_>;\n    let  _27: &(&str, &str, &core::panic::Location<'_>);\n    let  _28: (&str, &str, &core::panic::Location<'_>);\n    let mut _29: &str;\n    let  _30: &core::panic::Location<'_>;\n    let  _31: ();\n    debug next_task => _1;\n    debug irq_guard => _2;\n    debug handler => _6;\n    debug lvl => _17;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc1543: &spin::once::Once<fn()>};\n        _3 = spin::once::Once::<fn()>::get(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [1: bb2, 0: bb4, otherwise: bb24];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = ((_3 as variant#1).0: &fn());\n        StorageLive(_8);\n        _8 = (*_6);\n        _7 = move _8() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_3);\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_3);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_10);\n        _10 = &((*_1).4: task::kernel_stack::KernelStack);\n        _9 = task::kernel_stack::KernelStack::flush_tlb(move _10, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &((*_1).5: core::sync::atomic::AtomicBool);\n        StorageLive(_15);\n        _15 = core::sync::atomic::Ordering::AcqRel;\n        StorageLive(_16);\n        _16 = core::sync::atomic::Ordering::Relaxed;\n        _13 = core::sync::atomic::AtomicBool::compare_exchange(move _14, false, true, move _15, move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _12 = &_13;\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        _11 = core::result::Result::<bool, bool>::is_err(move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _11) -> [0: bb23, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _17 = log::Level::Warn;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_17;\n        StorageLive(_20);\n        _20 = task::processor::before_switching_to::promoted[0];\n        _18 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _19, move _20) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _18) -> [0: bb20, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_17;\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = log::max_level() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _23 = &_24;\n        _21 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _22, move _23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _21) -> [0: bb19, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_26);\n        _26 = core::fmt::Arguments::<'_>::from_str(\"Switching to a task already running in the foreground\") -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = \"ostd::task::processor\";\n        _30 = log::__private_api::loc() -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _28 = (move _29, \"ostd::task::processor\", _30);\n        StorageDead(_29);\n        _27 = &_28;\n        _25 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _26, _17, _27, ()) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_26);\n        StorageDead(_28);\n        goto -> bb21;\n    }\n    bb19: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb21;\n    }\n    bb20: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageDead(_21);\n        StorageDead(_18);\n        _31 = core::hint::spin_loop() -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_11);\n        goto -> bb7;\n    }\n    bb23: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        return;\n    }\n    bb24: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}