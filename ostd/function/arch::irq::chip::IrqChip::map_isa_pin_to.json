{
  "name": "arch::irq::chip::IrqChip::map_isa_pin_to",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "arch::irq::chip::IrqChip::map_gsi_pin_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an IRQ pin specified by a GSI number to an IRQ line.\n\n ACPI represents all interrupts as \"flat\" values known as global system interrupts (GSIs).\n So GSI numbers are well defined on all systems where the ACPI support is present.\n",
      "adt": {
        "arch::irq::chip::IrqChip": "ImmutableAsArgument",
        "irq::top_half::IrqLine": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "alloc::boxed::Box": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1948, kind: RigidTy(Adt(AdtDef(DefId { id: 3281, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 1962, kind: RigidTy(Slice(Ty { id: 1963, kind: RigidTy(Adt(AdtDef(DefId { id: 3905, name: \"arch::irq::chip::IsaOverride\" }), GenericArgs([]))) })) })]))) }), Field(0, Ty { id: 1949, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 1962, kind: RigidTy(Slice(Ty { id: 1963, kind: RigidTy(Adt(AdtDef(DefId { id: 3905, name: \"arch::irq::chip::IsaOverride\" }), GenericArgs([]))) })) })]))) })])"
    ],
    "arch::irq::chip::IrqChip": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "irq::top_half::IrqLine": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::irq::chip::IrqChip::map_isa_pin_to"
  },
  "span": "ostd/src/arch/x86/irq/chip/mod.rs:93:5: 106:6",
  "src": "pub fn map_isa_pin_to(\n        &'static self,\n        irq_line: IrqLine,\n        isa_index: u8,\n    ) -> Result<MappedIrqLine> {\n        let gsi_index = self\n            .overrides\n            .iter()\n            .find(|isa_override| isa_override.source == isa_index)\n            .map(|isa_override| isa_override.target)\n            .unwrap_or(isa_index as u32);\n\n        self.map_gsi_pin_to(irq_line, gsi_index)\n    }",
  "mir": "fn arch::irq::chip::IrqChip::map_isa_pin_to(_1: &arch::irq::chip::IrqChip, _2: irq::top_half::IrqLine, _3: u8) -> core::result::Result<arch::irq::chip::MappedIrqLine, error::Error> {\n    let mut _0: core::result::Result<arch::irq::chip::MappedIrqLine, error::Error>;\n    let  _4: u32;\n    let mut _5: core::option::Option<u32>;\n    let mut _6: core::option::Option<&arch::irq::chip::IsaOverride>;\n    let mut _7: &mut core::slice::Iter<'_, arch::irq::chip::IsaOverride>;\n    let mut _8: core::slice::Iter<'_, arch::irq::chip::IsaOverride>;\n    let mut _9: &[arch::irq::chip::IsaOverride];\n    let mut _10: {closure@ostd/src/arch/x86/irq/chip/mod.rs:101:19: 101:33};\n    let mut _11: &u8;\n    let mut _12: u32;\n    let mut _13: alloc::boxed::Box<[arch::irq::chip::IsaOverride]>;\n    let mut _14: *const [arch::irq::chip::IsaOverride];\n    debug self => _1;\n    debug irq_line => _2;\n    debug isa_index => _3;\n    debug gsi_index => _4;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _13 = ((*_1).1: alloc::boxed::Box<[arch::irq::chip::IsaOverride]>);\n        _14 = ((_13.0: core::ptr::Unique<[arch::irq::chip::IsaOverride]>).0: core::ptr::NonNull<[arch::irq::chip::IsaOverride]>) as *const [arch::irq::chip::IsaOverride];\n        _9 = &(*_14);\n        _8 = core::slice::<impl [arch::irq::chip::IsaOverride]>::iter(move _9) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = &mut _8;\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_3;\n        _10 = {closure@ostd/src/arch/x86/irq/chip/mod.rs:101:19: 101:33}(move _11);\n        StorageDead(_11);\n        _6 = <core::slice::Iter<'_, arch::irq::chip::IsaOverride> as core::iter::Iterator>::find::<{closure@ostd/src/arch/x86/irq/chip/mod.rs:101:19: 101:33}>(move _7, move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        StorageDead(_7);\n        _5 = core::option::Option::<&arch::irq::chip::IsaOverride>::map::<u32, {closure@ostd/src/arch/x86/irq/chip/mod.rs:102:18: 102:32}>(move _6, ZeroSized: {closure@ostd/src/arch/x86/irq/chip/mod.rs:102:18: 102:32}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_12);\n        _12 = _3 as u32;\n        _4 = core::option::Option::<u32>::unwrap_or(move _5, move _12) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_12);\n        StorageDead(_5);\n        StorageDead(_8);\n        _0 = arch::irq::chip::IrqChip::map_gsi_pin_to(_1, _2, _4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": " Maps an IRQ pin specified by an ISA interrupt number to an IRQ line.\n\n Industry Standard Architecture (ISA) is the 16-bit internal bus of IBM PC/AT. For\n compatibility reasons, legacy devices such as keyboards connected via the i8042 PS/2\n controller still use it.\n\n This method is x86-specific.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}