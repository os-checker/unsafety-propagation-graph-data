{
  "name": "arch::boot::linux_boot::parse_memory_regions",
  "safe": true,
  "callees": {
    "boot::memory_region::MemoryRegionArray::<LEN>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs an empty set.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "Constructor"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "arch::boot::linux_boot::parse_framebuffer_info": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "linux_boot_params::BootParams": "ImmutableAsArgument",
        "core::option::Option": "Constructor",
        "boot::BootloaderFramebufferArg": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "boot::memory_region::MemoryRegion::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a valid memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegionArray::<LEN>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends a region to the set.\n\n If the set is full, an error is returned.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::framebuffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a framebuffer memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor",
        "boot::BootloaderFramebufferArg": "ImmutableAsArgument"
      }
    },
    "boot::memory_region::MemoryRegion::kernel": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a memory region where kernel sections are loaded.\n\n Most boot protocols do not mark the place where the kernel loads as unusable. In this case,\n we need to explicitly construct and append this memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::linux_boot::parse_initramfs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "linux_boot_params::BootParams": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::module": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a module memory region from a byte slice that lives in the linear mapping.\n\n # Panics\n\n This method will panic if the byte slice does not live in the linear mapping.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::smp::reclaimable_memory_region": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::linux_boot::parse_kernel_commandline": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "linux_boot_params::BootParams": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "tdx_guest::tdx_is_enabled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "boot::memory_region::MemoryRegionArray::<LEN>::into_non_overlapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the regions and returns a full set of non-overlapping regions.\n\n If an address is in multiple regions, the region with the lowest\n usability will be its type.\n\n All the addresses between 0 and the end of the last region will be in\n the resulting set. If an address is not in any region, it will be marked\n as [`MemoryRegionType::Unknown`].\n\n If any of the region boundaries are not page-aligned, they will be aligned\n according to the type of the region.\n\n # Panics\n\n This method will panic if the number of output regions is greater than `LEN`.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "Constructor"
      }
    }
  },
  "adts": {
    "boot::memory_region::MemoryRegionArray": [
      "Plain",
      "MutRef"
    ],
    "linux_boot_params::BootParams": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(20)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(31)))",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 87, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 112, kind: RigidTy(Adt(AdtDef(DefId { id: 2847, name: \"linux_boot_params::BootE820Entry\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 73, kind: RigidTy(Adt(AdtDef(DefId { id: 2784, name: \"boot::BootloaderFramebufferArg\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 23, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 33, kind: RigidTy(Slice(Ty { id: 1, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 4, kind: RigidTy(Str) }, Not)) })])"
    ],
    "linux_boot_params::BootE820Entry": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "linux_boot_params::E820Type": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegionType": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegion": [
      "Plain"
    ],
    "boot::BootloaderFramebufferArg": [
      "Plain",
      "Ref"
    ]
  },
  "path": 128,
  "span": "ostd/src/arch/x86/boot/linux_boot/mod.rs:131:1: 193:2",
  "src": "fn parse_memory_regions(boot_params: &BootParams) -> MemoryRegionArray {\n    let mut regions = MemoryRegionArray::new();\n\n    // Add regions from E820.\n    let num_entries = boot_params.e820_entries as usize;\n    for e820_entry in &boot_params.e820_table[0..num_entries] {\n        regions\n            .push(MemoryRegion::new(\n                e820_entry.addr.try_into().unwrap(),\n                e820_entry.size.try_into().unwrap(),\n                e820_entry.typ.into(),\n            ))\n            .unwrap();\n    }\n\n    // Add the framebuffer region.\n    if let Some(fb) = parse_framebuffer_info(boot_params) {\n        regions.push(MemoryRegion::framebuffer(&fb)).unwrap();\n    }\n\n    // Add the kernel region.\n    regions.push(MemoryRegion::kernel()).unwrap();\n\n    // Add the initramfs region.\n    if let Some(initramfs) = parse_initramfs(boot_params) {\n        regions.push(MemoryRegion::module(initramfs)).unwrap();\n    }\n\n    // Add the AP boot code region that will be copied into by the BSP.\n    regions\n        .push(super::smp::reclaimable_memory_region())\n        .unwrap();\n\n    // Add the region of the kernel cmdline since some bootloaders do not provide it.\n    if let Some(kcmdline) = parse_kernel_commandline(boot_params) {\n        regions\n            .push(MemoryRegion::module(kcmdline.as_bytes()))\n            .unwrap();\n    }\n\n    // FIXME: Early versions of TDVF did not correctly report the location of AP's page tables as\n    // EfiACPIMemoryNVS. We need to manually reserve this memory region to prevent them from being\n    // corrupted. TDVF has now been upstreamed to OVMF, and this issue has been fixed in OVMF\n    // stable-202411 or later. See the commit for details:\n    // <https://github.com/tianocore/edk2/commit/383f729ac096b8deb279933fce86e83a5f7f5ec7>.\n    if_tdx_enabled!({\n        // The definition of these constants can be found in:\n        // <https://github.com/tianocore/edk2/blob/a7ab45ace25c4b987994158687d04de07ed20a96/OvmfPkg/IntelTdx/IntelTdxX64.fdf#L64-L71>\n        // <https://github.com/tianocore/edk2/blob/a7ab45ace25c4b987994158687d04de07ed20a96/OvmfPkg/Include/Fdf/OvmfPkgDefines.fdf.inc#L106>\n        regions\n            .push(MemoryRegion::new(\n                // PcdOvmfSecPageTablesBase = $(MEMFD_BASE_ADDRESS) + 0x000000 = 0x800000\n                0x800000,\n                // PcdOvmfSecPageTablesSize = 0x006000\n                0x006000,\n                // EfiACPIMemoryNVS\n                MemoryRegionType::NonVolatileSleep,\n            ))\n            .unwrap();\n    });\n\n    regions.into_non_overlapping()\n}",
  "mir": "fn arch::boot::linux_boot::parse_memory_regions(_1: &linux_boot_params::BootParams) -> boot::memory_region::MemoryRegionArray<512> {\n    let mut _0: boot::memory_region::MemoryRegionArray<512>;\n    let mut _2: boot::memory_region::MemoryRegionArray<512>;\n    let  _3: usize;\n    let mut _4: u8;\n    let mut _5: core::slice::Iter<'_, linux_boot_params::BootE820Entry>;\n    let  _6: &[linux_boot_params::BootE820Entry];\n    let mut _7: &[linux_boot_params::BootE820Entry; 128];\n    let mut _8: core::ops::Range<usize>;\n    let mut _9: core::slice::Iter<'_, linux_boot_params::BootE820Entry>;\n    let mut _10: core::option::Option<&linux_boot_params::BootE820Entry>;\n    let mut _11: &mut core::slice::Iter<'_, linux_boot_params::BootE820Entry>;\n    let mut _12: isize;\n    let  _13: &linux_boot_params::BootE820Entry;\n    let  _14: ();\n    let mut _15: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _16: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _17: boot::memory_region::MemoryRegion;\n    let mut _18: usize;\n    let mut _19: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _20: u64;\n    let mut _21: usize;\n    let mut _22: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _23: u64;\n    let mut _24: boot::memory_region::MemoryRegionType;\n    let mut _25: linux_boot_params::E820Type;\n    let mut _26: core::option::Option<boot::BootloaderFramebufferArg>;\n    let mut _27: isize;\n    let  _28: boot::BootloaderFramebufferArg;\n    let  _29: ();\n    let mut _30: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _31: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _32: boot::memory_region::MemoryRegion;\n    let  _33: &boot::BootloaderFramebufferArg;\n    let  _34: ();\n    let mut _35: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _36: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _37: boot::memory_region::MemoryRegion;\n    let mut _38: core::option::Option<&[u8]>;\n    let mut _39: isize;\n    let  _40: &[u8];\n    let  _41: ();\n    let mut _42: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _43: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _44: boot::memory_region::MemoryRegion;\n    let  _45: ();\n    let mut _46: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _47: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _48: boot::memory_region::MemoryRegion;\n    let mut _49: core::option::Option<&str>;\n    let mut _50: isize;\n    let  _51: &str;\n    let  _52: ();\n    let mut _53: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _54: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _55: boot::memory_region::MemoryRegion;\n    let  _56: &[u8];\n    let mut _57: bool;\n    let  _58: ();\n    let mut _59: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _60: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _61: boot::memory_region::MemoryRegion;\n    let mut _62: boot::memory_region::MemoryRegionType;\n    let mut _63: boot::memory_region::MemoryRegionArray<512>;\n    debug boot_params => _1;\n    debug regions => _2;\n    debug num_entries => _3;\n    debug iter => _9;\n    debug e820_entry => _13;\n    debug fb => _28;\n    debug initramfs => _40;\n    debug kcmdline => _51;\n    bb0: {\n        StorageLive(_2);\n        _2 = boot::memory_region::MemoryRegionArray::<512>::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = ((*_1).20: u8);\n        _3 = move _4 as usize;\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &((*_1).31: [linux_boot_params::BootE820Entry; 128]);\n        StorageLive(_8);\n        _8 = Range(0_usize, _3);\n        _6 = <[linux_boot_params::BootE820Entry; 128] as core::ops::Index<core::ops::Range<usize>>>::index(move _7, move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _5 = <&[linux_boot_params::BootE820Entry] as core::iter::IntoIterator>::into_iter(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = move _5;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_10);\n        _11 = &mut _9;\n        _10 = <core::slice::Iter<'_, linux_boot_params::BootE820Entry> as core::iter::Iterator>::next(_11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageLive(_13);\n        _13 = ((_10 as variant#1).0: &linux_boot_params::BootE820Entry);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut _2;\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = ((*_13).0: u64);\n        _19 = <u64 as core::convert::TryInto<usize>>::try_into(move _20) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_5);\n        StorageLive(_26);\n        _26 = arch::boot::linux_boot::parse_framebuffer_info(_1) -> [return: bb17, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_20);\n        _18 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap(move _19) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = ((*_13).1: u64);\n        _22 = <u64 as core::convert::TryInto<usize>>::try_into(move _23) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_23);\n        _21 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap(move _22) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = ((*_13).2: linux_boot_params::E820Type);\n        _24 = <linux_boot_params::E820Type as core::convert::Into<boot::memory_region::MemoryRegionType>>::into(move _25) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_25);\n        _17 = boot::memory_region::MemoryRegion::new(move _18, move _21, move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageDead(_18);\n        _15 = boot::memory_region::MemoryRegionArray::<512>::push(move _16, move _17) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_17);\n        StorageDead(_16);\n        _14 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _15) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb4;\n    }\n    bb17: {\n        _27 = discriminant(_26);\n        switchInt(move _27) -> [1: bb18, 0: bb22, otherwise: bb6];\n    }\n    bb18: {\n        StorageLive(_28);\n        _28 = ((_26 as variant#1).0: boot::BootloaderFramebufferArg);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &mut _2;\n        StorageLive(_32);\n        _33 = &_28;\n        _32 = boot::memory_region::MemoryRegion::framebuffer(_33) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _30 = boot::memory_region::MemoryRegionArray::<512>::push(move _31, move _32) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _29 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _30) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_30);\n        StorageDead(_28);\n        StorageDead(_26);\n        goto -> bb23;\n    }\n    bb22: {\n        StorageDead(_26);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &mut _2;\n        StorageLive(_37);\n        _37 = boot::memory_region::MemoryRegion::kernel() -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _35 = boot::memory_region::MemoryRegionArray::<512>::push(move _36, move _37) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_37);\n        StorageDead(_36);\n        _34 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        StorageLive(_38);\n        _38 = arch::boot::linux_boot::parse_initramfs(_1) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _39 = discriminant(_38);\n        switchInt(move _39) -> [1: bb28, 0: bb32, otherwise: bb6];\n    }\n    bb28: {\n        _40 = ((_38 as variant#1).0: &[u8]);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &mut _2;\n        StorageLive(_44);\n        _44 = boot::memory_region::MemoryRegion::module(_40) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _42 = boot::memory_region::MemoryRegionArray::<512>::push(move _43, move _44) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_44);\n        StorageDead(_43);\n        _41 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _42) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_42);\n        StorageDead(_38);\n        goto -> bb33;\n    }\n    bb32: {\n        StorageDead(_38);\n        goto -> bb33;\n    }\n    bb33: {\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = &mut _2;\n        StorageLive(_48);\n        _48 = arch::boot::smp::reclaimable_memory_region() -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _46 = boot::memory_region::MemoryRegionArray::<512>::push(move _47, move _48) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_48);\n        StorageDead(_47);\n        _45 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _46) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_46);\n        StorageLive(_49);\n        _49 = arch::boot::linux_boot::parse_kernel_commandline(_1) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _50 = discriminant(_49);\n        switchInt(move _50) -> [1: bb38, 0: bb43, otherwise: bb6];\n    }\n    bb38: {\n        _51 = ((_49 as variant#1).0: &str);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = &mut _2;\n        StorageLive(_55);\n        _56 = core::str::<impl str>::as_bytes(_51) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _55 = boot::memory_region::MemoryRegion::module(_56) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _53 = boot::memory_region::MemoryRegionArray::<512>::push(move _54, move _55) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_55);\n        StorageDead(_54);\n        _52 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _53) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_53);\n        StorageDead(_49);\n        goto -> bb44;\n    }\n    bb43: {\n        StorageDead(_49);\n        goto -> bb44;\n    }\n    bb44: {\n        StorageLive(_57);\n        _57 = tdx_guest::tdx_is_enabled() -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        switchInt(move _57) -> [0: bb50, otherwise: bb46];\n    }\n    bb46: {\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &mut _2;\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = boot::memory_region::MemoryRegionType::NonVolatileSleep;\n        _61 = boot::memory_region::MemoryRegion::new(8388608_usize, 24576_usize, move _62) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_62);\n        _59 = boot::memory_region::MemoryRegionArray::<512>::push(move _60, move _61) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_61);\n        StorageDead(_60);\n        _58 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _59) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_59);\n        goto -> bb50;\n    }\n    bb50: {\n        StorageDead(_57);\n        StorageLive(_63);\n        _63 = move _2;\n        _0 = boot::memory_region::MemoryRegionArray::<512>::into_non_overlapping(move _63) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_63);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}