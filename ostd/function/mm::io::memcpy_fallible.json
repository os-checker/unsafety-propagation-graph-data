{
  "name": "mm::io::memcpy_fallible",
  "safe": false,
  "callees": {
    "arch::mm::util::__memcpy_fallible": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `size` bytes from `src` to `dst`. This function works with exception handling\n and can recover from page fault.\n Returns number of bytes that failed to copy.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 2116,
  "span": "ostd/src/mm/io.rs:290:1: 294:2",
  "src": "unsafe fn memcpy_fallible(dst: *mut u8, src: *const u8, len: usize) -> usize {\n    // SAFETY: The safety is upheld by the caller.\n    let failed_bytes = unsafe { __memcpy_fallible(dst, src, len) };\n    len - failed_bytes\n}",
  "mir": "fn mm::io::memcpy_fallible(_1: *mut u8, _2: *const u8, _3: usize) -> usize {\n    let mut _0: usize;\n    let  _4: usize;\n    let mut _5: (usize, bool);\n    debug dst => _1;\n    debug src => _2;\n    debug len => _3;\n    debug failed_bytes => _4;\n    bb0: {\n        _4 = arch::mm::util::__memcpy_fallible(_1, _2, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = CheckedSub(_3, _4);\n        assert(!move (_5.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _4) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = move (_5.0: usize);\n        return;\n    }\n}\n",
  "doc": " Copies `len` bytes from `src` to `dst`.\n This function will early stop copying if encountering an unresolvable page fault.\n\n Returns the number of successfully copied bytes.\n\n In the following cases, this method may cause unexpected bytes to be copied, but will not cause\n safety problems as long as the safety requirements are met:\n - The source and destination overlap.\n - The current context is not associated with valid user space (e.g., in the kernel thread).\n\n # Safety\n\n - `src` must either be [valid] for reads of `len` bytes or be in user space for `len` bytes.\n - `dst` must either be [valid] for writes of `len` bytes or be in user space for `len` bytes.\n\n [valid]: crate::mm::io#safety\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}