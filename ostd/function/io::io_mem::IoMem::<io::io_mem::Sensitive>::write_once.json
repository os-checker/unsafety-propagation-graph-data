{
  "name": "io::io_mem::IoMem::<io::io_mem::Sensitive>::write_once",
  "safe": false,
  "callees": {
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "mm::kspace::kvirt_area::KVirtArea::start": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::kspace::kvirt_area::KVirtArea": "ImmutableAsArgument"
      }
    },
    "core::ptr::write_volatile": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile write of a memory location with the given value without reading or dropping\n the old value.\n\n Volatile operations are intended to act on I/O memory. As such, they are considered externally\n observable events (just like syscalls), and are guaranteed to not be elided or reordered by the\n compiler across other externally observable events. With this in mind, there are two cases of\n usage that need to be distinguished:\n\n - When a volatile operation is used for memory inside an [allocation], it behaves exactly like\n   [`write`][write()], except for the additional guarantee that it won't be elided or reordered\n   (see above). This implies that the operation will actually access memory and not e.g. be\n   lowered to a register access. Other than that, all the usual rules for memory accesses apply\n   (including provenance). In particular, just like in C, whether an operation is volatile has no\n   bearing whatsoever on questions involving concurrent access from multiple threads. Volatile\n   accesses behave exactly like non-atomic accesses in that regard.\n\n - Volatile operations, however, may also be used to access memory that is _outside_ of any Rust\n   allocation. In this use-case, the pointer does *not* have to be [valid] for writes. This is\n   typically used for CPU and peripheral registers that must be accessed via an I/O memory\n   mapping, most commonly at fixed addresses reserved by the hardware. These often have special\n   semantics associated to their manipulation, and cannot be used as general purpose memory.\n   Here, any address value is possible, including 0 and [`usize::MAX`], so long as the semantics\n   of such a write are well-defined by the target hardware. The provenance of the pointer is\n   irrelevant, and it can be created with [`without_provenance`]. The access must not trap. It\n   can cause side-effects, but those must not affect Rust-allocated memory in any way. This\n   access is still not considered [atomic], and as such it cannot be used for inter-thread\n   synchronization.\n\n Note that volatile memory operations on zero-sized types (e.g., if a zero-sized type is passed\n to `write_volatile`) are noops and may be ignored.\n\n `write_volatile` does not drop the contents of `dst`. This is safe, but it could leak\n allocations or resources, so care should be taken not to overwrite an object that should be\n dropped when operating on Rust memory. Additionally, it does not drop `src`. Semantically, `src`\n is moved into the location pointed to by `dst`.\n\n [allocation]: crate::ptr#allocated-object\n [atomic]: crate::sync::atomic#memory-model-for-atomic-accesses\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `dst` must be either [valid] for writes, or it must point to memory outside of all Rust\n   allocations and writing to that memory must:\n   - not trap, and\n   - not cause any memory inside a Rust allocation to be modified.\n\n * `dst` must be properly aligned.\n\n Note that even if `T` has size `0`, the pointer must be properly aligned.\n\n [valid]: self#safety\n\n # Examples\n\n Basic usage:\n\n ```\n let mut x = 0;\n let y = &mut x as *mut i32;\n let z = 12;\n\n unsafe {\n     std::ptr::write_volatile(y, z);\n     assert_eq!(std::ptr::read_volatile(y), 12);\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "io::io_mem::IoMem": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "alloc::sync::Arc": [
      "Ref"
    ],
    "mm::kspace::kvirt_area::KVirtArea": [
      "Ref"
    ]
  },
  "path": 1764,
  "span": "ostd/src/io/io_mem/mod.rs:184:5: 189:6",
  "src": "pub(crate) unsafe fn write_once<T: PodOnce>(&self, offset: usize, value: &T) {\n        debug_assert!(offset + size_of::<T>() < self.limit);\n        let ptr = (self.kvirt_area.deref().start() + self.offset + offset) as *mut T;\n        // SAFETY: The safety of the write operation's semantics is upheld by the caller.\n        unsafe { core::ptr::write_volatile(ptr, *value) };\n    }",
  "mir": "fn io::io_mem::IoMem::<io::io_mem::Sensitive>::write_once(_1: &io::io_mem::IoMem<io::io_mem::Sensitive>, _2: usize, _3: &T) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: usize;\n    let mut _7: (usize, bool);\n    let mut _8: usize;\n    let mut _9: !;\n    let  _10: *mut T;\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: usize;\n    let  _14: &mm::kspace::kvirt_area::KVirtArea;\n    let mut _15: &alloc::sync::Arc<mm::kspace::kvirt_area::KVirtArea>;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: (usize, bool);\n    let  _19: ();\n    let mut _20: T;\n    debug self => _1;\n    debug offset => _2;\n    debug value => _3;\n    debug ptr => _10;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = core::mem::size_of::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = CheckedAdd(_2, _6);\n        assert(!move (_7.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _2, move _6) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = move (_7.0: usize);\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = ((*_1).2: usize);\n        _4 = Lt(move _5, move _8);\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_15);\n        _15 = &((*_1).0: alloc::sync::Arc<mm::kspace::kvirt_area::KVirtArea>);\n        _14 = <alloc::sync::Arc<mm::kspace::kvirt_area::KVirtArea> as core::ops::Deref>::deref(move _15) -> [return: bb5, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_5);\n        _9 = core::panicking::panic(\"assertion failed: offset + size_of::<T>() < self.limit\") -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_15);\n        _13 = mm::kspace::kvirt_area::KVirtArea::start(_14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_16);\n        _16 = ((*_1).1: usize);\n        _17 = CheckedAdd(_13, _16);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _13, move _16) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _12 = move (_17.0: usize);\n        StorageDead(_16);\n        StorageDead(_13);\n        _18 = CheckedAdd(_12, _2);\n        assert(!move (_18.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _12, _2) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _11 = move (_18.0: usize);\n        StorageDead(_12);\n        _10 = move _11 as *mut T;\n        StorageDead(_11);\n        StorageLive(_20);\n        _20 = (*_3);\n        _19 = core::ptr::write_volatile::<T>(_10, move _20) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_20);\n        return;\n    }\n}\n",
  "doc": " Writes a value of the `PodOnce` type at the specified offset using one\n non-tearing memory store.\n\n Except that the offset is specified explicitly, the semantics of this\n method is the same as [`VmWriter::write_once`].\n\n # Safety\n\n The caller must ensure that the offset and the write operation is valid,\n e.g., follows the specification when used for implementing drivers, does\n not cause any out-of-bounds access, and does not cause unsound side\n effects (e.g., corrupting the kernel memory).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}