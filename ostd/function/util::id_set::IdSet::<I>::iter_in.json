{
  "name": "util::id_set::IdSet::<I>::iter_in",
  "safe": true,
  "callees": {
    "util::id_set::IdSetSlicer::to_range_bounds": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the index type to inclusive start and exclusive end bounds.\n\n Returns `(start, end)` where:\n - `start`: inclusive lower bound\n - `end`: exclusive upper bound\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "bitvec::view::BitView::view_bits": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Views a memory region as an immutable bit-slice.\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "bitvec::slice::BitSlice::<T, O>::iter_ones": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enumerates the index of each bit in a bit-slice set to `1`.\n\n This is a shorthand for a `.enumerate().filter_map()` iterator that\n selects the index of each `true` bit; however, its implementation is\n eligible for optimizations that the individual-bit iterator is not.\n\n Specializations for the `Lsb0` and `Msb0` orderings allow processors\n with instructions that seek particular bits within an element to operate\n on whole elements, rather than on each bit individually.\n\n ## Examples\n\n This example uses `.iter_ones()`, a `.filter_map()` that finds the index\n of each set bit, and the known indices, in order to show that they have\n equivalent behavior.\n\n ```rust\n use bitvec::prelude::*;\n\n let bits = bits![0, 1, 0, 0, 1, 0, 0, 0, 1];\n\n let iter_ones = bits.iter_ones();\n let known_indices = [1, 4, 8].iter().copied();\n let filter = bits.iter()\n   .by_vals()\n   .enumerate()\n   .filter_map(|(idx, bit)| if bit { Some(idx) } else { None });\n let all = iter_ones.zip(known_indices).zip(filter);\n\n for ((iter_one, known), filtered) in all {\n   assert_eq!(iter_one, known);\n   assert_eq!(known, filtered);\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "smallvec::SmallVec": [
      "Ref"
    ],
    "util::id_set::IdSet": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "bitvec::slice::BitSlice": [
      "Ref"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "bitvec::slice::IterOnes": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::util::id_set::IdSet::<I>::iter_in"
  },
  "span": "ostd/src/util/id_set.rs:263:5: 275:6",
  "src": "pub fn iter_in<S: IdSetSlicer<I>>(&self, slicer: S) -> impl Iterator<Item = I> + '_ {\n        let (start, end) = slicer.to_range_bounds();\n\n        self.bits.view_bits::<Lsb0>()[start..end]\n            .iter_ones()\n            .map(move |offset| {\n                // SAFETY: `offset` is relative to the slice `[start..end]`,\n                // therefore `start + offset` is the absolute index of the bit.\n                // Since `offset` only iterates over relative positions of bit 1s, the\n                // resulting absolute index must refer to an active bit in `self.bits`.\n                unsafe { I::new_unchecked((start + offset) as u32) }\n            })\n    }",
  "mir": "fn util::id_set::IdSet::<I>::iter_in(_1: &util::id_set::IdSet<I>, _2: S) -> core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}> {\n    let mut _0: core::iter::Map<bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>;\n    let  _3: usize;\n    let  _4: usize;\n    let mut _5: (usize, usize);\n    let mut _6: bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0>;\n    let  _7: &bitvec::slice::BitSlice<u64>;\n    let  _8: &bitvec::slice::BitSlice<u64>;\n    let  _9: &[u64];\n    let mut _10: &smallvec::SmallVec<[u64; 2]>;\n    let mut _11: core::ops::Range<usize>;\n    let mut _12: {closure@ostd/src/util/id_set.rs:268:18: 268:31};\n    debug self => _1;\n    debug slicer => _2;\n    debug start => _3;\n    debug end => _4;\n    bb0: {\n        StorageLive(_5);\n        _5 = <S as util::id_set::IdSetSlicer<I>>::to_range_bounds(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = (_5.0: usize);\n        _4 = (_5.1: usize);\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_10);\n        _10 = &((*_1).0: smallvec::SmallVec<[u64; 2]>);\n        _9 = <smallvec::SmallVec<[u64; 2]> as core::ops::Deref>::deref(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        _8 = <[u64] as bitvec::view::BitView>::view_bits::<bitvec::order::Lsb0>(_9) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_11);\n        _11 = Range(_3, _4);\n        _7 = <bitvec::slice::BitSlice<u64> as core::ops::Index<core::ops::Range<usize>>>::index(_8, move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        _6 = bitvec::slice::BitSlice::<u64>::iter_ones(_7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_12);\n        _12 = {closure@ostd/src/util/id_set.rs:268:18: 268:31}(_3);\n        _0 = <bitvec::slice::IterOnes<'_, u64, bitvec::order::Lsb0> as core::iter::Iterator>::map::<I, {closure@ostd/src/util/id_set.rs:268:18: 268:31}>(move _6, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": " Iterates over the IDs in the set within the specified range.\n\n The iteration is guaranteed to be in ascending order.\n Only IDs that are both in the set and within the specified range will be returned.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}