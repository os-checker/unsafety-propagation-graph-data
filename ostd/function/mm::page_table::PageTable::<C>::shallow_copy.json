{
  "name": "mm::page_table::PageTable::<C>::shallow_copy",
  "safe": false,
  "callees": {
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::Frame": [
      "Ref",
      "Plain"
    ],
    "mm::page_table::PageTable": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Plain",
      "Ref"
    ]
  },
  "path": 2428,
  "span": "ostd/src/mm/page_table/mod.rs:422:5: 426:6",
  "src": "pub unsafe fn shallow_copy(&self) -> Self {\n        PageTable {\n            root: self.root.clone(),\n        }\n    }",
  "mir": "fn mm::page_table::PageTable::<C>::shallow_copy(_1: &mm::page_table::PageTable<C>) -> mm::page_table::PageTable<C> {\n    let mut _0: mm::page_table::PageTable<C>;\n    let mut _2: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    let mut _3: &mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).0: mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>>);\n        _2 = <mm::frame::Frame<mm::page_table::node::PageTablePageMeta<C>> as core::clone::Clone>::clone(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = PageTable(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Create a new reference to the same page table.\n The caller must ensure that the kernel page table is not copied.\n This is only useful for IOMMU page tables. Think twice before using it in other cases.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}