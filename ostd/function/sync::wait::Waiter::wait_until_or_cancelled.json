{
  "name": "sync::wait::Waiter::wait_until_or_cancelled",
  "safe": true,
  "callees": {
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sync::wait::Waker::close": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::wait::Waker": "ImmutableAsArgument"
      }
    },
    "core::option::Option::<T>::ok_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err)`].\n\n Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n result of a function call, it is recommended to use [`ok_or_else`], which is\n lazily evaluated.\n\n [`Ok(v)`]: Ok\n [`Err(err)`]: Err\n [`Some(v)`]: Some\n [`ok_or_else`]: Option::ok_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.ok_or(0), Ok(\"foo\"));\n\n let x: Option<&str> = None;\n assert_eq!(x.ok_or(0), Err(0));\n ```\n",
      "adt": {}
    },
    "core::ops::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "sync::wait::Waiter::wait": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Waits until the waiter is woken up by calling [`Waker::wake_up`] on the associated\n [`Waker`].\n\n This method returns immediately if the waiter has been woken since the end of the last call\n to this method (or since the waiter was created, if this method has not been called\n before). Otherwise, it puts the current thread to sleep until the waiter is woken up.\n",
      "adt": {
        "sync::wait::Waiter": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 54, kind: Param(ParamTy { index: 1, name: \"R\" }) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7207, kind: Param(ParamTy { index: 3, name: \"E\" }) })])"
    ],
    "alloc::sync::Arc": [
      "Ref"
    ],
    "sync::wait::Waiter": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::wait::Waker": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::sync::wait::Waiter::wait_until_or_cancelled"
  },
  "span": "ostd/src/sync/wait.rs:209:5: 231:6",
  "src": "pub fn wait_until_or_cancelled<F, R, FCancel, E>(\n        &self,\n        mut cond: F,\n        cancel_cond: FCancel,\n    ) -> core::result::Result<R, E>\n    where\n        F: FnMut() -> Option<R>,\n        FCancel: Fn() -> core::result::Result<(), E>,\n    {\n        loop {\n            if let Some(res) = cond() {\n                return Ok(res);\n            };\n\n            if let Err(e) = cancel_cond() {\n                // Close the waker and check again to avoid missing a wake event.\n                self.waker.close();\n                return cond().ok_or(e);\n            }\n\n            self.wait();\n        }\n    }",
  "mir": "fn sync::wait::Waiter::wait_until_or_cancelled(_1: &sync::wait::Waiter, _2: F, _3: FCancel) -> core::result::Result<R, E> {\n    let mut _0: core::result::Result<R, E>;\n    let mut _4: core::option::Option<R>;\n    let mut _5: &mut F;\n    let mut _6: isize;\n    let  _7: R;\n    let mut _8: core::result::Result<(), E>;\n    let mut _9: &FCancel;\n    let mut _10: isize;\n    let  _11: E;\n    let  _12: ();\n    let  _13: &sync::wait::Waker;\n    let mut _14: &alloc::sync::Arc<sync::wait::Waker>;\n    let mut _15: core::option::Option<R>;\n    let mut _16: &mut F;\n    let  _17: ();\n    debug self => _1;\n    debug cond => _2;\n    debug cancel_cond => _3;\n    debug res => _7;\n    debug e => _11;\n    bb0: {\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _2;\n        _4 = <F as core::ops::FnMut<()>>::call_mut(move _5, ()) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [1: bb3, 0: bb14, otherwise: bb16];\n    }\n    bb3: {\n        _7 = move ((_4 as variant#1).0: R);\n        _0 = core::result::Result::Ok(_7);\n        StorageDead(_4);\n        goto -> bb11;\n    }\n    bb4: {\n        StorageDead(_9);\n        _10 = discriminant(_8);\n        switchInt(move _10) -> [1: bb5, 0: bb15, otherwise: bb16];\n    }\n    bb5: {\n        _11 = move ((_8 as variant#1).0: E);\n        StorageLive(_14);\n        _14 = &((*_1).0: alloc::sync::Arc<sync::wait::Waker>);\n        _13 = <alloc::sync::Arc<sync::wait::Waker> as core::ops::Deref>::deref(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _12 = sync::wait::Waker::close(_13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut _2;\n        _15 = <F as core::ops::FnMut<()>>::call_mut(move _16, ()) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _0 = core::option::Option::<R>::ok_or::<E>(move _15, _11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb10: {\n        goto -> bb1;\n    }\n    bb11: {\n        drop(_3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        drop(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        return;\n    }\n    bb14: {\n        StorageDead(_4);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_3;\n        _8 = <FCancel as core::ops::Fn<()>>::call(move _9, ()) -> [return: bb4, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_8);\n        _17 = sync::wait::Waiter::wait(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb16: {\n        unreachable;\n    }\n}\n",
  "doc": " Waits until some condition is met or the cancel condition becomes true.\n\n This method will return `Ok(_)` if the condition returns `Some(_)`, and will stop waiting\n if the cancel condition returns `Err(_)`. In this situation, this method will return the `Err(_)`\n generated by the cancel condition.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}