{
  "name": "arch::boot::smp::send_boot_ipis",
  "safe": false,
  "callees": {
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "arch::kernel::apic::get_or_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the local APIC instance of the current CPU.\n\n The reference to the APIC instance will not outlive the given\n [`PinCurrentCpu`] guard and the APIC instance does not implement\n [`Sync`], so it is safe to assume that the APIC instance belongs\n to the current CPU. Note that interrupts are not disabled, so the\n APIC instance may be accessed concurrently by interrupt handlers.\n\n At the first time the function is called, the local APIC instance\n is initialized and enabled if it was not enabled beforehand.\n\n # Examples\n\n ```rust\n use ostd::{\n     arch::x86::kernel::apic,\n     task::disable_preempt,\n };\n\n let preempt_guard = disable_preempt();\n let apic = apic::get_or_init(&preempt_guard as _);\n\n let ticks = apic.timer_current_count();\n apic.set_timer_init_count(0);\n ```\n",
      "adt": {}
    },
    "arch::boot::smp::send_init_to_all_aps": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller should ensure it's valid to send INIT IPIs to all CPUs excluding self.\n",
      "adt": {}
    },
    "arch::boot::smp::spin_wait_cycles": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Spin wait approximately `c` cycles.\n\n Since the timer requires CPU local storage to be initialized, we\n can only wait by spinning.\n",
      "adt": {}
    },
    "arch::boot::smp::send_init_deassert": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller should ensure it's valid to deassert INIT IPIs for all CPUs excluding self.\n",
      "adt": {}
    },
    "arch::boot::smp::send_startup_to_all_aps": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n The caller should ensure it's valid to send STARTUP IPIs to all CPUs excluding self.\n",
      "adt": {}
    }
  },
  "adts": {
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ]
  },
  "path": 176,
  "span": "ostd/src/arch/x86/boot/smp.rs:261:1: 280:2",
  "src": "unsafe fn send_boot_ipis() {\n    let preempt_guard = disable_preempt();\n    let apic = apic::get_or_init(&preempt_guard as _);\n\n    // SAFETY: We're sending IPIs to boot all application processors.\n    // The safety is upheld by the caller.\n    unsafe {\n        send_init_to_all_aps(apic);\n        spin_wait_cycles(100_000_000);\n\n        send_init_deassert(apic);\n        spin_wait_cycles(20_000_000);\n\n        send_startup_to_all_aps(apic);\n        spin_wait_cycles(20_000_000);\n\n        send_startup_to_all_aps(apic);\n        spin_wait_cycles(20_000_000);\n    }\n}",
  "mir": "fn arch::boot::smp::send_boot_ipis() -> () {\n    let mut _0: ();\n    let  _1: task::preempt::guard::DisabledPreemptGuard;\n    let  _2: &dyn arch::kernel::apic::Apic;\n    let mut _3: &dyn cpu::id::current::PinCurrentCpu;\n    let  _4: &task::preempt::guard::DisabledPreemptGuard;\n    let  _5: ();\n    let  _6: ();\n    let  _7: ();\n    let  _8: ();\n    let  _9: ();\n    let  _10: ();\n    let  _11: ();\n    let  _12: ();\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug apic => _2;\n    bb0: {\n        _1 = task::preempt::guard::disable_preempt() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = &_1;\n        _3 = _4 as &dyn cpu::id::current::PinCurrentCpu;\n        _2 = arch::kernel::apic::get_or_init(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = arch::boot::smp::send_init_to_all_aps(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = arch::boot::smp::spin_wait_cycles(100000000_u64) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = arch::boot::smp::send_init_deassert(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = arch::boot::smp::spin_wait_cycles(20000000_u64) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = arch::boot::smp::send_startup_to_all_aps(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = arch::boot::smp::spin_wait_cycles(20000000_u64) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _11 = arch::boot::smp::send_startup_to_all_aps(_2) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _12 = arch::boot::smp::spin_wait_cycles(20000000_u64) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        drop(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": " Sends IPIs to notify all application processors to boot.\n\n Follow the INIT-SIPI-SIPI IPI sequence.\n Here, we don't check whether there is an AP that failed to start,\n but send the second SIPI directly (checking whether each core is\n started successfully one by one will bring extra overhead). For\n APs that have been started, this signal will not bring any cost.\n\n # Safety\n\n The caller must ensure that all application processors can be\n safely booted by ensuring that:\n 1. We're in the boot context of the BSP and all APs have not yet\n    been booted.\n 2. We've properly prepared all the resources for the application\n    processors to boot successfully (e.g., each AP's page table\n    and stack).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}