{
  "name": "mm::kspace::init_kernel_page_table",
  "safe": true,
  "callees": {
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::new_kernel_page_table": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new kernel page table.\n",
      "adt": {
        "mm::page_table::PageTable": "Constructor"
      }
    },
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "mm::frame::max_paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the maximum physical address that is tracked by frame metadata.\n",
      "adt": {}
    },
    "mm::page_table::PageTable::<C>::cursor_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new cursor exclusively accessing the virtual address range for mapping.\n\n If another cursor is already accessing the range, the new cursor may wait until the\n previous cursor is dropped.\n",
      "adt": {
        "mm::page_table::PageTable": "ImmutableAsArgument",
        "core::ops::Range": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::page_table::cursor::CursorMut": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "mm::page_table::largest_pages": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the address range into largest page table items.\n\n Each of the returned items is a tuple of the physical address and the\n paging level. It is helpful when you want to map a physical address range\n into the provided virtual address.\n\n For example, on x86-64, `C: PageTableConfig` may specify level 1 page as\n 4KiB, level 2 page as 2MiB, and level 3 page as 1GiB. Suppose that the\n supplied physical address range is from `0x3fdff000` to `0x80002000`,\n and the virtual address is also `0x3fdff000`, the following 5 items will\n be returned:\n\n ```text\n 0x3fdff000                                                 0x80002000\n start                                                             end\n   |----|----------------|--------------------------------|----|----|\n    4KiB      2MiB                       1GiB              4KiB 4KiB\n ```\n\n # Panics\n\n Panics if:\n  - any of `va`, `pa`, or `len` is not aligned to the base page size;\n  - the range `va..(va + len)` is not valid for the page table.\n",
      "adt": {
        "core::iter::FromFn": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "mm::page_table::cursor::CursorMut::<'rcu, C>::map": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps the item starting from the current address to a physical address range.\n\n If the current address has already mapped pages, it will do a re-map,\n taking out the old physical address and replacing it with the new one.\n This function will return [`Err`] with a [`PageTableFrag`], the not\n mapped item. The caller should drop it after TLB coherence.\n\n If there is no mapped pages in the specified virtual address range,\n the function will return [`None`].\n\n # Panics\n\n This function will panic if\n  - the virtual address range to be mapped is out of the locked range;\n  - the current virtual address is not aligned to the page size of the\n    item to be mapped;\n\n # Safety\n\n The caller should ensure that\n  - the range being mapped does not affect kernel's memory safety;\n  - the physical address to be mapped is valid and safe to use;\n",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::page_table::cursor::CursorMut": "MutableAsArgument"
      }
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "mm::frame::meta::mapping::frame_to_meta": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a physical address of a base frame to the virtual address of the metadata slot.\n",
      "adt": {}
    },
    "mm::mem_obj::HasSize::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the memory object in bytes.\n",
      "adt": {}
    },
    "mm::frame::segment::Segment::<M>::into_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forgets the [`Segment`] and gets a raw range of physical addresses.\n",
      "adt": {
        "core::ops::Range": "Constructor"
      }
    },
    "core::iter::ExactSizeIterator::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the exact remaining length of the iterator.\n\n The implementation ensures that the iterator will return exactly `len()`\n more times a [`Some(T)`] value, before returning [`None`].\n This method has a default implementation, so you usually should not\n implement it directly. However, if you can provide a more efficient\n implementation, you can do so. See the [trait-level] docs for an\n example.\n\n This function has the same safety guarantees as the\n [`Iterator::size_hint`] function.\n\n [trait-level]: ExactSizeIterator\n [`Some(T)`]: Some\n\n # Examples\n\n Basic usage:\n\n ```\n // a finite range knows exactly how many times it will iterate\n let mut range = 0..5;\n\n assert_eq!(5, range.len());\n let _ = range.next();\n assert_eq!(4, range.len());\n ```\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {}
    },
    "mm::kspace::kernel_loaded_offset": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The kernel code is linear mapped to this address.\n\n FIXME: This offset should be randomly chosen by the loader or the\n boot compatibility layer. But we disabled it because OSTD\n doesn't support relocatable kernel yet.\n",
      "adt": {}
    },
    "boot::memory_region::MemoryRegion::base": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the physical address of the base of the region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "ImmutableAsArgument"
      }
    },
    "boot::memory_region::MemoryRegion::end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the physical address of the end of the region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "ImmutableAsArgument"
      }
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "mm::page_table::PageTable": [
      "Plain",
      "Ref"
    ],
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "mm::page_prop::CachePolicy": [
      "Plain"
    ],
    "mm::page_prop::PageProperty": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "mm::page_table::cursor::CursorMut": [
      "Plain",
      "MutRef"
    ],
    "core::iter::FromFn": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5358, kind: RigidTy(Tuple([Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Ty { id: 1, kind: RigidTy(Uint(U8)) }])) }), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5358, kind: RigidTy(Tuple([Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Ty { id: 1, kind: RigidTy(Uint(U8)) }])) }), Field(1, Ty { id: 1, kind: RigidTy(Uint(U8)) })])"
    ],
    "mm::kspace::MappedItem": [
      "Plain"
    ],
    "mm::frame::segment::Segment": [
      "Ref",
      "Plain"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "boot::EarlyBootInfo": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(5)))"
    ],
    "boot::memory_region::MemoryRegionArray": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "boot::memory_region::MemoryRegion": [
      "Ref"
    ]
  },
  "path": 2186,
  "span": "ostd/src/mm/kspace/mod.rs:197:1: 272:2",
  "src": "pub fn init_kernel_page_table(meta_pages: Segment<MetaPageMeta>) {\n    info!(\"Initializing the kernel page table\");\n\n    // Start to initialize the kernel page table.\n    let kpt = PageTable::<KernelPtConfig>::new_kernel_page_table();\n    let preempt_guard = disable_preempt();\n\n    // In LoongArch64, we don't need to do linear mappings for the kernel because of DMW0.\n    #[cfg(not(target_arch = \"loongarch64\"))]\n    // Do linear mappings for the kernel.\n    {\n        let max_paddr = crate::mm::frame::max_paddr();\n        let from = LINEAR_MAPPING_BASE_VADDR..LINEAR_MAPPING_BASE_VADDR + max_paddr;\n        let prop = PageProperty {\n            flags: PageFlags::RW,\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::GLOBAL,\n        };\n        let mut cursor = kpt.cursor_mut(&preempt_guard, &from).unwrap();\n        for (pa, level) in largest_pages::<KernelPtConfig>(from.start, 0, max_paddr) {\n            // SAFETY: we are doing the linear mapping for the kernel.\n            unsafe { cursor.map(MappedItem::Untracked(pa, level, prop)) }\n                .expect(\"Kernel linear address space is mapped twice\");\n        }\n    }\n\n    // Map the metadata pages.\n    {\n        let start_va = mapping::frame_to_meta::<PagingConsts>(0);\n        let from = start_va..start_va + meta_pages.size();\n        let prop = PageProperty {\n            flags: PageFlags::RW,\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::GLOBAL,\n        };\n        let mut cursor = kpt.cursor_mut(&preempt_guard, &from).unwrap();\n        // We use untracked mapping so that we can benefit from huge pages.\n        // We won't unmap them anyway, so there's no leaking problem yet.\n        // TODO: support tracked huge page mapping.\n        let pa_range = meta_pages.into_raw();\n        for (pa, level) in\n            largest_pages::<KernelPtConfig>(from.start, pa_range.start, pa_range.len())\n        {\n            // SAFETY: We are doing the metadata mappings for the kernel.\n            unsafe { cursor.map(MappedItem::Untracked(pa, level, prop)) }\n                .expect(\"Frame metadata address space is mapped twice\");\n        }\n    }\n\n    // In LoongArch64, we don't need to do linear mappings for the kernel code because of DMW0.\n    #[cfg(not(target_arch = \"loongarch64\"))]\n    // Map for the kernel code itself.\n    // TODO: set separated permissions for each segments in the kernel.\n    {\n        let regions = &crate::boot::EARLY_INFO.get().unwrap().memory_regions;\n        let region = regions\n            .iter()\n            .find(|r| r.typ() == MemoryRegionType::Kernel)\n            .unwrap();\n        let offset = kernel_loaded_offset();\n        let from = region.base() + offset..region.end() + offset;\n        let prop = PageProperty {\n            flags: PageFlags::RWX,\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::GLOBAL,\n        };\n        let mut cursor = kpt.cursor_mut(&preempt_guard, &from).unwrap();\n        for (pa, level) in largest_pages::<KernelPtConfig>(from.start, region.base(), from.len()) {\n            // SAFETY: we are doing the kernel code mapping.\n            unsafe { cursor.map(MappedItem::Untracked(pa, level, prop)) }\n                .expect(\"Kernel code mapped twice\");\n        }\n    }\n\n    KERNEL_PAGE_TABLE.call_once(|| kpt);\n}",
  "mir": "fn mm::kspace::init_kernel_page_table(_1: mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta>) -> () {\n    let mut _0: ();\n    let  _2: log::Level;\n    let mut _3: bool;\n    let mut _4: &log::Level;\n    let mut _5: &log::LevelFilter;\n    let mut _6: bool;\n    let mut _7: &log::Level;\n    let mut _8: &log::LevelFilter;\n    let  _9: log::LevelFilter;\n    let  _10: ();\n    let mut _11: core::fmt::Arguments<'_>;\n    let  _12: &(&str, &str, &core::panic::Location<'_>);\n    let  _13: (&str, &str, &core::panic::Location<'_>);\n    let mut _14: &str;\n    let  _15: &core::panic::Location<'_>;\n    let  _16: mm::page_table::PageTable<mm::kspace::KernelPtConfig>;\n    let  _17: task::preempt::guard::DisabledPreemptGuard;\n    let  _18: usize;\n    let  _19: core::ops::Range<usize>;\n    let mut _20: usize;\n    let mut _21: (usize, bool);\n    let  _22: mm::page_prop::PageProperty;\n    let mut _23: mm::page_prop::CachePolicy;\n    let mut _24: mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _25: core::result::Result<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>;\n    let mut _26: &mm::page_table::PageTable<mm::kspace::KernelPtConfig>;\n    let  _27: &task::preempt::guard::DisabledPreemptGuard;\n    let  _28: &core::ops::Range<usize>;\n    let mut _29: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _30: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _31: usize;\n    let mut _32: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _33: core::option::Option<(usize, u8)>;\n    let mut _34: &mut core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _35: isize;\n    let  _36: usize;\n    let  _37: u8;\n    let  _38: ();\n    let mut _39: core::result::Result<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>;\n    let mut _40: &mut mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _41: mm::kspace::MappedItem;\n    let mut _42: &str;\n    let  _43: usize;\n    let  _44: core::ops::Range<usize>;\n    let mut _45: usize;\n    let mut _46: usize;\n    let mut _47: &mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta>;\n    let mut _48: (usize, bool);\n    let  _49: mm::page_prop::PageProperty;\n    let mut _50: mm::page_prop::CachePolicy;\n    let mut _51: mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _52: core::result::Result<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>;\n    let mut _53: &mm::page_table::PageTable<mm::kspace::KernelPtConfig>;\n    let  _54: &task::preempt::guard::DisabledPreemptGuard;\n    let  _55: &core::ops::Range<usize>;\n    let  _56: core::ops::Range<usize>;\n    let mut _57: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _58: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _59: usize;\n    let mut _60: usize;\n    let mut _61: usize;\n    let mut _62: &core::ops::Range<usize>;\n    let mut _63: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _64: core::option::Option<(usize, u8)>;\n    let mut _65: &mut core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _66: isize;\n    let  _67: usize;\n    let  _68: u8;\n    let  _69: ();\n    let mut _70: core::result::Result<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>;\n    let mut _71: &mut mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _72: mm::kspace::MappedItem;\n    let mut _73: &str;\n    let  _74: &boot::memory_region::MemoryRegionArray<512>;\n    let  _75: &boot::EarlyBootInfo;\n    let mut _76: core::option::Option<&boot::EarlyBootInfo>;\n    let mut _77: &spin::once::Once<boot::EarlyBootInfo>;\n    let  _78: &boot::memory_region::MemoryRegion;\n    let mut _79: core::option::Option<&boot::memory_region::MemoryRegion>;\n    let mut _80: &mut core::slice::Iter<'_, boot::memory_region::MemoryRegion>;\n    let mut _81: core::slice::Iter<'_, boot::memory_region::MemoryRegion>;\n    let  _82: &[boot::memory_region::MemoryRegion];\n    let  _83: usize;\n    let  _84: core::ops::Range<usize>;\n    let mut _85: usize;\n    let mut _86: usize;\n    let mut _87: (usize, bool);\n    let mut _88: usize;\n    let mut _89: usize;\n    let mut _90: (usize, bool);\n    let  _91: mm::page_prop::PageProperty;\n    let mut _92: mm::page_prop::CachePolicy;\n    let mut _93: mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _94: core::result::Result<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>;\n    let mut _95: &mm::page_table::PageTable<mm::kspace::KernelPtConfig>;\n    let  _96: &task::preempt::guard::DisabledPreemptGuard;\n    let  _97: &core::ops::Range<usize>;\n    let mut _98: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _99: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _100: usize;\n    let mut _101: usize;\n    let mut _102: usize;\n    let mut _103: &core::ops::Range<usize>;\n    let mut _104: core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _105: core::option::Option<(usize, u8)>;\n    let mut _106: &mut core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}>;\n    let mut _107: isize;\n    let  _108: usize;\n    let  _109: u8;\n    let  _110: ();\n    let mut _111: core::result::Result<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>;\n    let mut _112: &mut mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>;\n    let mut _113: mm::kspace::MappedItem;\n    let mut _114: &str;\n    let  _115: &mm::page_table::PageTable<mm::kspace::KernelPtConfig>;\n    let mut _116: &spin::once::Once<mm::page_table::PageTable<mm::kspace::KernelPtConfig>>;\n    let mut _117: {closure@ostd/src/mm/kspace/mod.rs:271:33: 271:35};\n    debug meta_pages => _1;\n    debug lvl => _2;\n    debug kpt => _16;\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug max_paddr => _18;\n    debug from => _19;\n    debug prop => _22;\n    debug cursor => _24;\n    debug iter => _32;\n    debug pa => _36;\n    debug level => _37;\n    debug start_va => _43;\n    debug from => _44;\n    debug prop => _49;\n    debug cursor => _51;\n    debug pa_range => _56;\n    debug iter => _63;\n    debug pa => _67;\n    debug level => _68;\n    debug regions => _74;\n    debug region => _78;\n    debug offset => _83;\n    debug from => _84;\n    debug prop => _91;\n    debug cursor => _93;\n    debug iter => _104;\n    debug pa => _108;\n    debug level => _109;\n    bb0: {\n        _2 = log::Level::Info;\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_2;\n        StorageLive(_5);\n        _5 = mm::kspace::init_kernel_page_table::promoted[0];\n        _3 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb10, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_2;\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = log::max_level() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &_9;\n        _6 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _7, move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _6) -> [0: bb9, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_11);\n        _11 = core::fmt::Arguments::<'_>::from_str(\"Initializing the kernel page table\") -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = \"ostd::mm::kspace\";\n        _15 = log::__private_api::loc() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _13 = (move _14, \"ostd::mm::kspace\", _15);\n        StorageDead(_14);\n        _12 = &_13;\n        _10 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _11, _2, _12, ()) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageDead(_13);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageLive(_16);\n        _16 = mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::new_kernel_page_table() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _17 = task::preempt::guard::disable_preempt() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _18 = mm::frame::max_paddr() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_19);\n        StorageLive(_20);\n        _21 = CheckedAdd(mm::kspace::LINEAR_MAPPING_BASE_VADDR, _18);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", mm::kspace::LINEAR_MAPPING_BASE_VADDR, _18) -> [success: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20 = move (_21.0: usize);\n        _19 = Range(mm::kspace::LINEAR_MAPPING_BASE_VADDR, move _20);\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = mm::page_prop::CachePolicy::Writeback;\n        _22 = PageProperty(mm::page_prop::PageFlags::RW, move _23, mm::page_prop::PrivilegedPageFlags::GLOBAL);\n        StorageDead(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_16;\n        _27 = &_17;\n        _28 = &_19;\n        _25 = mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::cursor_mut::<task::preempt::guard::DisabledPreemptGuard>(move _26, _27, _28) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _24 = core::result::Result::<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>::unwrap(move _25) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_25);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = (_19.0: usize);\n        _30 = mm::page_table::largest_pages::<mm::kspace::KernelPtConfig>(move _31, 0_usize, _18) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        _29 = <core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}> as core::iter::IntoIterator>::into_iter(move _30) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_30);\n        StorageLive(_32);\n        _32 = move _29;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_33);\n        _34 = &mut _32;\n        _33 = <core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}> as core::iter::Iterator>::next(_34) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _35 = discriminant(_33);\n        switchInt(move _35) -> [0: bb24, 1: bb23, otherwise: bb22];\n    }\n    bb22: {\n        unreachable;\n    }\n    bb23: {\n        _36 = (((_33 as variant#1).0: (usize, u8)).0: usize);\n        _37 = (((_33 as variant#1).0: (usize, u8)).1: u8);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &mut _24;\n        StorageLive(_41);\n        _41 = mm::kspace::MappedItem::Untracked(_36, _37, _22);\n        _39 = mm::page_table::cursor::CursorMut::<'_, mm::kspace::KernelPtConfig>::map(move _40, move _41) -> [return: bb25, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_29);\n        drop(_24) -> [return: bb27, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageLive(_42);\n        _42 = \"Kernel linear address space is mapped twice\";\n        _38 = core::result::Result::<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>::expect(move _39, move _42) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_42);\n        StorageDead(_39);\n        StorageDead(_33);\n        goto -> bb20;\n    }\n    bb27: {\n        StorageDead(_24);\n        StorageDead(_19);\n        _43 = mm::frame::meta::mapping::frame_to_meta::<arch::mm::PagingConsts>(0_usize) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = &_1;\n        _46 = <mm::frame::segment::Segment<mm::frame::meta::MetaPageMeta> as mm::mem_obj::HasSize>::size(move _47) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_47);\n        _48 = CheckedAdd(_43, _46);\n        assert(!move (_48.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _43, move _46) -> [success: bb30, unwind unreachable];\n    }\n    bb30: {\n        _45 = move (_48.0: usize);\n        StorageDead(_46);\n        _44 = Range(_43, move _45);\n        StorageDead(_45);\n        StorageLive(_50);\n        _50 = mm::page_prop::CachePolicy::Writeback;\n        _49 = PageProperty(mm::page_prop::PageFlags::RW, move _50, mm::page_prop::PrivilegedPageFlags::GLOBAL);\n        StorageDead(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = &_16;\n        _54 = &_17;\n        _55 = &_44;\n        _52 = mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::cursor_mut::<task::preempt::guard::DisabledPreemptGuard>(move _53, _54, _55) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_53);\n        _51 = core::result::Result::<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>::unwrap(move _52) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_52);\n        StorageLive(_56);\n        _56 = mm::frame::segment::Segment::<mm::frame::meta::MetaPageMeta>::into_raw(_1) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = (_44.0: usize);\n        StorageLive(_60);\n        _60 = (_56.0: usize);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = &_56;\n        _61 = <core::ops::Range<usize> as core::iter::ExactSizeIterator>::len(move _62) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_62);\n        _58 = mm::page_table::largest_pages::<mm::kspace::KernelPtConfig>(move _59, move _60, move _61) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_61);\n        StorageDead(_60);\n        StorageDead(_59);\n        _57 = <core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}> as core::iter::IntoIterator>::into_iter(move _58) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_58);\n        StorageLive(_63);\n        _63 = move _57;\n        goto -> bb37;\n    }\n    bb37: {\n        StorageLive(_64);\n        _65 = &mut _63;\n        _64 = <core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}> as core::iter::Iterator>::next(_65) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        _66 = discriminant(_64);\n        switchInt(move _66) -> [0: bb40, 1: bb39, otherwise: bb22];\n    }\n    bb39: {\n        _67 = (((_64 as variant#1).0: (usize, u8)).0: usize);\n        _68 = (((_64 as variant#1).0: (usize, u8)).1: u8);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = &mut _51;\n        StorageLive(_72);\n        _72 = mm::kspace::MappedItem::Untracked(_67, _68, _49);\n        _70 = mm::page_table::cursor::CursorMut::<'_, mm::kspace::KernelPtConfig>::map(move _71, move _72) -> [return: bb41, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_64);\n        StorageDead(_63);\n        StorageDead(_57);\n        StorageDead(_56);\n        drop(_51) -> [return: bb43, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_72);\n        StorageDead(_71);\n        StorageLive(_73);\n        _73 = \"Frame metadata address space is mapped twice\";\n        _69 = core::result::Result::<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>::expect(move _70, move _73) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_73);\n        StorageDead(_70);\n        StorageDead(_64);\n        goto -> bb37;\n    }\n    bb43: {\n        StorageDead(_51);\n        StorageDead(_44);\n        StorageLive(_75);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = {alloc733: &spin::once::Once<boot::EarlyBootInfo>};\n        _76 = spin::once::Once::<boot::EarlyBootInfo>::get(move _77) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_77);\n        _75 = core::option::Option::<&boot::EarlyBootInfo>::unwrap(move _76) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_76);\n        _74 = &((*_75).5: boot::memory_region::MemoryRegionArray<512>);\n        StorageLive(_79);\n        StorageLive(_80);\n        StorageLive(_81);\n        _82 = <boot::memory_region::MemoryRegionArray<512> as core::ops::Deref>::deref(_74) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _81 = core::slice::<impl [boot::memory_region::MemoryRegion]>::iter(_82) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _80 = &mut _81;\n        _79 = <core::slice::Iter<'_, boot::memory_region::MemoryRegion> as core::iter::Iterator>::find::<{closure@ostd/src/mm/kspace/mod.rs:254:19: 254:22}>(move _80, ZeroSized: {closure@ostd/src/mm/kspace/mod.rs:254:19: 254:22}) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_80);\n        _78 = core::option::Option::<&boot::memory_region::MemoryRegion>::unwrap(move _79) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_79);\n        StorageDead(_81);\n        _83 = mm::kspace::kernel_loaded_offset() -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageLive(_84);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = boot::memory_region::MemoryRegion::base(_78) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        _87 = CheckedAdd(_86, _83);\n        assert(!move (_87.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _86, _83) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        _85 = move (_87.0: usize);\n        StorageDead(_86);\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = boot::memory_region::MemoryRegion::end(_78) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        _90 = CheckedAdd(_89, _83);\n        assert(!move (_90.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _89, _83) -> [success: bb54, unwind unreachable];\n    }\n    bb54: {\n        _88 = move (_90.0: usize);\n        StorageDead(_89);\n        _84 = Range(move _85, move _88);\n        StorageDead(_88);\n        StorageDead(_85);\n        StorageLive(_92);\n        _92 = mm::page_prop::CachePolicy::Writeback;\n        _91 = PageProperty(mm::page_prop::PageFlags::RWX, move _92, mm::page_prop::PrivilegedPageFlags::GLOBAL);\n        StorageDead(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = &_16;\n        _96 = &_17;\n        _97 = &_84;\n        _94 = mm::page_table::PageTable::<mm::kspace::KernelPtConfig>::cursor_mut::<task::preempt::guard::DisabledPreemptGuard>(move _95, _96, _97) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_95);\n        _93 = core::result::Result::<mm::page_table::cursor::CursorMut<'_, mm::kspace::KernelPtConfig>, mm::page_table::PageTableError>::unwrap(move _94) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_94);\n        StorageLive(_98);\n        StorageLive(_99);\n        StorageLive(_100);\n        _100 = (_84.0: usize);\n        StorageLive(_101);\n        _101 = boot::memory_region::MemoryRegion::base(_78) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageLive(_102);\n        StorageLive(_103);\n        _103 = &_84;\n        _102 = <core::ops::Range<usize> as core::iter::ExactSizeIterator>::len(move _103) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_103);\n        _99 = mm::page_table::largest_pages::<mm::kspace::KernelPtConfig>(move _100, move _101, move _102) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_102);\n        StorageDead(_101);\n        StorageDead(_100);\n        _98 = <core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}> as core::iter::IntoIterator>::into_iter(move _99) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_99);\n        StorageLive(_104);\n        _104 = move _98;\n        goto -> bb61;\n    }\n    bb61: {\n        StorageLive(_105);\n        _106 = &mut _104;\n        _105 = <core::iter::FromFn<{closure@ostd/src/mm/page_table/mod.rs:178:25: 178:32}> as core::iter::Iterator>::next(_106) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        _107 = discriminant(_105);\n        switchInt(move _107) -> [0: bb64, 1: bb63, otherwise: bb22];\n    }\n    bb63: {\n        _108 = (((_105 as variant#1).0: (usize, u8)).0: usize);\n        _109 = (((_105 as variant#1).0: (usize, u8)).1: u8);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = &mut _93;\n        StorageLive(_113);\n        _113 = mm::kspace::MappedItem::Untracked(_108, _109, _91);\n        _111 = mm::page_table::cursor::CursorMut::<'_, mm::kspace::KernelPtConfig>::map(move _112, move _113) -> [return: bb65, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_105);\n        StorageDead(_104);\n        StorageDead(_98);\n        drop(_93) -> [return: bb67, unwind unreachable];\n    }\n    bb65: {\n        StorageDead(_113);\n        StorageDead(_112);\n        StorageLive(_114);\n        _114 = \"Kernel code mapped twice\";\n        _110 = core::result::Result::<(), mm::page_table::cursor::PageTableFrag<mm::kspace::KernelPtConfig>>::expect(move _111, move _114) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_114);\n        StorageDead(_111);\n        StorageDead(_105);\n        goto -> bb61;\n    }\n    bb67: {\n        StorageDead(_93);\n        StorageDead(_84);\n        StorageDead(_75);\n        StorageLive(_115);\n        StorageLive(_116);\n        _116 = {alloc1275: &spin::once::Once<mm::page_table::PageTable<mm::kspace::KernelPtConfig>>};\n        StorageLive(_117);\n        _117 = {closure@ostd/src/mm/kspace/mod.rs:271:33: 271:35}(move _16);\n        _115 = spin::once::Once::<mm::page_table::PageTable<mm::kspace::KernelPtConfig>>::call_once::<{closure@ostd/src/mm/kspace/mod.rs:271:33: 271:35}>(move _116, move _117) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_117);\n        StorageDead(_116);\n        StorageDead(_115);\n        drop(_17) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        StorageDead(_16);\n        return;\n    }\n}\n",
  "doc": " Initializes the kernel page table.\n\n This function should be called after:\n  - the page allocator and the heap allocator are initialized;\n  - the memory regions are initialized.\n\n This function should be called before:\n  - any initializer that modifies the kernel page table.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}