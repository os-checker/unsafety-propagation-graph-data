{
  "name": "mm::vm_space::CursorMut::<'a>::handle_remapped_frag",
  "safe": true,
  "callees": {
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "mm::tlb::TlbFlushOp::for_single": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new TLB flush operation that flushes the TLB entry associated\n with the provided virtual address.\n",
      "adt": {
        "mm::tlb::TlbFlushOp": "Constructor"
      }
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "mm::tlb::TlbFlusher::<'a, G>::issue_tlb_flush_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Issues a TLB flush request that must happen before dropping the page.\n\n If we need to remove a mapped page from the page table, we can only\n recycle the page after all the relevant TLB entries in all CPUs are\n flushed. Otherwise if the page is recycled for other purposes, the user\n space program can still access the page through the TLB entries. This\n method is designed to be used in such cases.\n",
      "adt": {
        "mm::tlb::TlbFlusher": "MutableAsArgument"
      }
    },
    "mm::tlb::TlbFlusher::<'a, G>::issue_tlb_flush": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Issues a pending TLB flush request.\n\n This function does not guarantee to flush the TLB entries on either\n this CPU or remote CPUs. The flush requests are only performed when\n [`Self::dispatch_tlb_flush`] is called.\n",
      "adt": {
        "mm::tlb::TlbFlusher": "MutableAsArgument"
      }
    },
    "mm::tlb::TlbFlusher::<'a, G>::dispatch_tlb_flush": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dispatches all the pending TLB flush requests.\n\n All previous pending requests issued by [`Self::issue_tlb_flush`] or\n [`Self::issue_tlb_flush_with`] starts to be processed after this\n function. But it may not be synchronous. Upon the return of this\n function, the TLB entries may not be coherent.\n",
      "adt": {
        "mm::tlb::TlbFlusher": "MutableAsArgument"
      }
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::page_table::cursor::PageTableFrag": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(1, Ty { id: 6277, kind: RigidTy(Adt(AdtDef(DefId { id: 5587, name: \"mm::vm_space::VmItem\" }), GenericArgs([]))) })])"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "mm::vm_space::VmItem": [
      "Plain",
      "Unknown([Field(1, Ty { id: 6338, kind: RigidTy(Adt(AdtDef(DefId { id: 5605, name: \"mm::vm_space::MappedItem\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 6338, kind: RigidTy(Adt(AdtDef(DefId { id: 5605, name: \"mm::vm_space::MappedItem\" }), GenericArgs([]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4909, kind: RigidTy(Adt(AdtDef(DefId { id: 3414, name: \"mm::frame::Frame\" }), GenericArgs([Type(Ty { id: 4095, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 4951, name: \"mm::frame::untyped::AnyUFrameMeta\" }), generic_args: GenericArgs([]) }), bound_vars: [] }], Region { kind: ReErased })) })]))) })])"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "mm::tlb::TlbFlusher": [
      "MutRef"
    ],
    "mm::vm_space::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "mm::tlb::TlbFlushOp": [
      "Plain"
    ],
    "mm::frame::Frame": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::vm_space::CursorMut::<'a>::handle_remapped_frag"
  },
  "span": "ostd/src/mm/vm_space.rs:459:5: 486:6",
  "src": "fn handle_remapped_frag(&mut self, frag: PageTableFrag<UserPtConfig>, start_va: Vaddr) {\n        match frag {\n            PageTableFrag::Mapped { va, item } => {\n                debug_assert_eq!(va, start_va);\n                match item.mapped_item {\n                    MappedItem::TrackedFrame(old_frame) => {\n                        self.flusher.issue_tlb_flush_with(\n                            TlbFlushOp::for_single(start_va),\n                            old_frame.into(),\n                        );\n                    }\n                    MappedItem::UntrackedIoMem { .. } => {\n                        // Flush the TLB entry for the current address, but in\n                        // the current design, we cannot drop the corresponding\n                        // `IoMem`. This is because we manage the range of I/O\n                        // as a whole, but the frames handled here might be one\n                        // segment of it.\n                        self.flusher\n                            .issue_tlb_flush(TlbFlushOp::for_single(start_va));\n                    }\n                }\n                self.flusher.dispatch_tlb_flush();\n            }\n            PageTableFrag::StrayPageTable { .. } => {\n                panic!(\"`UFrame` is base page sized but re-mapping out a child PT\");\n            }\n        }\n    }",
  "mir": "fn mm::vm_space::CursorMut::<'a>::handle_remapped_frag(_1: &mut mm::vm_space::CursorMut<'_>, _2: mm::page_table::cursor::PageTableFrag<mm::vm_space::UserPtConfig>, _3: usize) -> () {\n    let mut _0: ();\n    let mut _4: isize;\n    let  _5: usize;\n    let  _6: mm::vm_space::VmItem;\n    let mut _7: (&usize, &usize);\n    let mut _8: &usize;\n    let mut _9: &usize;\n    let  _10: &usize;\n    let  _11: &usize;\n    let mut _12: bool;\n    let mut _13: usize;\n    let mut _14: usize;\n    let  _15: core::panicking::AssertKind;\n    let  _16: !;\n    let mut _17: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _18: isize;\n    let  _19: mm::frame::Frame<dyn mm::frame::untyped::AnyUFrameMeta>;\n    let  _20: ();\n    let mut _21: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    let mut _22: mm::tlb::TlbFlushOp;\n    let mut _23: mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>;\n    let  _24: ();\n    let mut _25: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    let mut _26: mm::tlb::TlbFlushOp;\n    let  _27: ();\n    let mut _28: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    let  _29: !;\n    let mut _30: core::fmt::Arguments<'_>;\n    let mut _31: isize;\n    debug self => _1;\n    debug frag => _2;\n    debug start_va => _3;\n    debug va => _5;\n    debug item => _6;\n    debug left_val => _10;\n    debug right_val => _11;\n    debug kind => _15;\n    debug old_frame => _19;\n    bb0: {\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb3, 1: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        StorageLive(_30);\n        _30 = core::fmt::Arguments::<'_>::from_str(\"`UFrame` is base page sized but re-mapping out a child PT\") -> [return: bb15, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_5);\n        _5 = ((_2 as variant#0).0: usize);\n        StorageLive(_6);\n        _6 = move ((_2 as variant#0).1: mm::vm_space::VmItem);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_5;\n        StorageLive(_9);\n        _9 = &_3;\n        _7 = (move _8, move _9);\n        StorageDead(_9);\n        StorageDead(_8);\n        _10 = (_7.0: &usize);\n        _11 = (_7.1: &usize);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = (*_10);\n        StorageLive(_14);\n        _14 = (*_11);\n        _12 = Eq(move _13, move _14);\n        switchInt(move _12) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_7);\n        _18 = discriminant((_6.1: mm::vm_space::MappedItem));\n        switchInt(move _18) -> [0: bb7, 1: bb6, otherwise: bb1];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _15 = core::panicking::AssertKind::Eq;\n        StorageLive(_17);\n        _17 = core::option::Option::None;\n        _16 = core::panicking::assert_failed::<usize, usize>(_15, _10, _11, move _17) -> unwind unreachable;\n    }\n    bb6: {\n        StorageLive(_25);\n        _25 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        StorageLive(_26);\n        _26 = mm::tlb::TlbFlushOp::for_single(_3) -> [return: bb11, unwind unreachable];\n    }\n    bb7: {\n        _19 = move (((_6.1: mm::vm_space::MappedItem) as variant#0).0: mm::frame::Frame<dyn mm::frame::untyped::AnyUFrameMeta>);\n        StorageLive(_21);\n        _21 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        StorageLive(_22);\n        _22 = mm::tlb::TlbFlushOp::for_single(_3) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_23);\n        _23 = <mm::frame::Frame<dyn mm::frame::untyped::AnyUFrameMeta> as core::convert::Into<mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>>>::into(_19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _20 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::issue_tlb_flush_with(move _21, move _22, move _23) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        goto -> bb13;\n    }\n    bb11: {\n        _24 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::issue_tlb_flush(move _25, move _26) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_26);\n        StorageDead(_25);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageLive(_28);\n        _28 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        _27 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::dispatch_tlb_flush(move _28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_28);\n        StorageDead(_6);\n        StorageDead(_5);\n        _31 = discriminant(_2);\n        switchInt(move _31) -> [0: bb16, 1: bb17, otherwise: bb1];\n    }\n    bb15: {\n        _29 = core::panicking::panic_fmt(move _30) -> unwind unreachable;\n    }\n    bb16: {\n        return;\n    }\n    bb17: {\n        drop(_2) -> [return: bb16, unwind unreachable];\n    }\n}\n",
  "doc": " Handles a page table fragment that was remapped.\n\n This method handles the TLB flushing and other cleanup when a mapping\n operation results in a fragment being replaced.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}