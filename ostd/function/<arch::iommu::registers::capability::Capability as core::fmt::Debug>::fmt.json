{
  "name": "<arch::iommu::registers::capability::Capability as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "arch::iommu::registers::capability::Capability::flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Capability flags\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument",
        "arch::iommu::registers::capability::CapabilityFlags": "Constructor"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "arch::iommu::registers::capability::Capability::maximum_guest_address_width": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maximum Guest Address Width. The maximum guest physical address width supported\n by second-stage translation in remapping hardware.\n MGAW is computed as (N+1), where N is the valued reported in this field.\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument"
      }
    },
    "arch::iommu::registers::capability::Capability::second_stage_large_page_support": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Second Stage Large Page Support.\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument",
        "arch::iommu::registers::capability::CapabilitySslps": "Constructor"
      }
    },
    "arch::iommu::registers::capability::Capability::fault_recording_register_offset": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fault-recording Register offset, specifies the offset of the first fault recording\n register relative to the register base address of this remapping hardware unit.\n\n If the register base address is X, and the value reported in this field\n is Y, the address for the first fault recording register is calculated as X+(16*Y).\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument"
      }
    },
    "arch::iommu::registers::capability::Capability::supported_adjusted_guest_address_widths": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Supported Adjusted Guest Address Widths.\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument",
        "arch::iommu::registers::capability::CapabilitySagaw": "Constructor"
      }
    },
    "arch::iommu::registers::capability::Capability::domain_support_number": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Number of domain support.\n\n ```text\n 0 => 4-bit domain-ids with support for up to 16 domains.\n 1 => 6-bit domain-ids with support for up to 64 domains.\n 2 => 8-bit domain-ids with support for up to 256 domains.\n 3 => 10-bit domain-ids with support for up to 1024 domains.\n 4 => 12-bit domain-ids with support for up to 4K domains.\n 5 => 14-bit domain-ids with support for up to 16K domains.\n 6 => 16-bit domain-ids with support for up to 64K domains.\n 7 => Reserved.\n ```\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument"
      }
    },
    "arch::iommu::registers::capability::Capability::maximum_address_mask_value": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maximum Address Mask Value, indicates the maximum supported value for them Address\n Mask (AM) field in the Invalidation Address register (IVA_REG), and IOTLB Invalidation\n Descriptor (iotlb_inv_dsc) used for invalidations of second-stage translation.\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument"
      }
    },
    "arch::iommu::registers::capability::Capability::fault_recording_number": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Number of Fault-recording. The maximum number of fault recording registers per\n remapping hardware unit is 256.\n\n Number of fault recording registers is computed as N+1, where N is the value\n reported in this field.\n",
      "adt": {
        "arch::iommu::registers::capability::Capability": "ImmutableAsArgument"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finishes output and returns any error encountered.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     baz: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .field(\"baz\", &self.baz)\n            .finish() // You need to call it to \"finish\" the\n                      // struct formatting.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, baz: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, baz: \"Hello World\" }\"#,\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "arch::iommu::registers::capability::Capability": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "arch::iommu::registers::capability::CapabilityFlags": [
      "Plain",
      "Ref"
    ],
    "arch::iommu::registers::capability::CapabilitySslps": [
      "Plain",
      "Ref"
    ],
    "arch::iommu::registers::capability::CapabilitySagaw": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::<arch::iommu::registers::capability::Capability as core::fmt::Debug>::fmt"
  },
  "span": "ostd/src/arch/x86/iommu/registers/capability.rs:86:5: 113:6",
  "src": "fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        f.debug_struct(\"Capability\")\n            .field(\"flags\", &self.flags())\n            .field(\n                \"maximum_guest_address_width\",\n                &self.maximum_guest_address_width(),\n            )\n            .field(\n                \"second_stage_large_page_support\",\n                &self.second_stage_large_page_support(),\n            )\n            .field(\n                \"fault_recording_register_offset\",\n                &self.fault_recording_register_offset(),\n            )\n            .field(\n                \"supported_adjusted_guest_address_widths\",\n                &self.supported_adjusted_guest_address_widths(),\n            )\n            .field(\"domain_support_number\", &self.domain_support_number())\n            .field(\n                \"maximum_address_mask_value\",\n                &self.maximum_address_mask_value(),\n            )\n            .field(\"fault_recording_number\", &self.fault_recording_number())\n            .field(\"raw\", &self.0)\n            .finish()\n    }",
  "mir": "fn <arch::iommu::registers::capability::Capability as core::fmt::Debug>::fmt(_1: &arch::iommu::registers::capability::Capability, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _7: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _8: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _9: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _10: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _11: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _12: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _13: core::fmt::DebugStruct<'_, '_>;\n    let mut _14: &str;\n    let mut _15: &str;\n    let mut _16: &dyn core::fmt::Debug;\n    let  _17: &arch::iommu::registers::capability::CapabilityFlags;\n    let  _18: arch::iommu::registers::capability::CapabilityFlags;\n    let mut _19: &str;\n    let mut _20: &dyn core::fmt::Debug;\n    let  _21: &u64;\n    let  _22: u64;\n    let mut _23: &str;\n    let mut _24: &dyn core::fmt::Debug;\n    let  _25: &arch::iommu::registers::capability::CapabilitySslps;\n    let  _26: arch::iommu::registers::capability::CapabilitySslps;\n    let mut _27: &str;\n    let mut _28: &dyn core::fmt::Debug;\n    let  _29: &u64;\n    let  _30: u64;\n    let mut _31: &str;\n    let mut _32: &dyn core::fmt::Debug;\n    let  _33: &arch::iommu::registers::capability::CapabilitySagaw;\n    let  _34: arch::iommu::registers::capability::CapabilitySagaw;\n    let mut _35: &str;\n    let mut _36: &dyn core::fmt::Debug;\n    let  _37: &u64;\n    let  _38: u64;\n    let mut _39: &str;\n    let mut _40: &dyn core::fmt::Debug;\n    let  _41: &u64;\n    let  _42: u64;\n    let mut _43: &str;\n    let mut _44: &dyn core::fmt::Debug;\n    let  _45: &u64;\n    let  _46: u64;\n    let mut _47: &str;\n    let mut _48: &dyn core::fmt::Debug;\n    let  _49: &u64;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = \"Capability\";\n        _13 = core::fmt::Formatter::<'_>::debug_struct(_2, move _14) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _12 = &mut _13;\n        StorageDead(_14);\n        StorageLive(_15);\n        _15 = \"flags\";\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = arch::iommu::registers::capability::Capability::flags(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _17 = &_18;\n        _16 = _17 as &dyn core::fmt::Debug;\n        _11 = core::fmt::DebugStruct::<'_, '_>::field(move _12, move _15, move _16) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_12);\n        StorageLive(_19);\n        _19 = \"maximum_guest_address_width\";\n        StorageLive(_20);\n        StorageLive(_22);\n        _22 = arch::iommu::registers::capability::Capability::maximum_guest_address_width(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _21 = &_22;\n        _20 = _21 as &dyn core::fmt::Debug;\n        _10 = core::fmt::DebugStruct::<'_, '_>::field(_11, move _19, move _20) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_23);\n        _23 = \"second_stage_large_page_support\";\n        StorageLive(_24);\n        StorageLive(_26);\n        _26 = arch::iommu::registers::capability::Capability::second_stage_large_page_support(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _25 = &_26;\n        _24 = _25 as &dyn core::fmt::Debug;\n        _9 = core::fmt::DebugStruct::<'_, '_>::field(_10, move _23, move _24) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_27);\n        _27 = \"fault_recording_register_offset\";\n        StorageLive(_28);\n        StorageLive(_30);\n        _30 = arch::iommu::registers::capability::Capability::fault_recording_register_offset(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _29 = &_30;\n        _28 = _29 as &dyn core::fmt::Debug;\n        _8 = core::fmt::DebugStruct::<'_, '_>::field(_9, move _27, move _28) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageLive(_31);\n        _31 = \"supported_adjusted_guest_address_widths\";\n        StorageLive(_32);\n        StorageLive(_34);\n        _34 = arch::iommu::registers::capability::Capability::supported_adjusted_guest_address_widths(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _33 = &_34;\n        _32 = _33 as &dyn core::fmt::Debug;\n        _7 = core::fmt::DebugStruct::<'_, '_>::field(_8, move _31, move _32) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_35);\n        _35 = \"domain_support_number\";\n        StorageLive(_36);\n        StorageLive(_38);\n        _38 = arch::iommu::registers::capability::Capability::domain_support_number(_1) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _37 = &_38;\n        _36 = _37 as &dyn core::fmt::Debug;\n        _6 = core::fmt::DebugStruct::<'_, '_>::field(_7, move _35, move _36) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageLive(_39);\n        _39 = \"maximum_address_mask_value\";\n        StorageLive(_40);\n        StorageLive(_42);\n        _42 = arch::iommu::registers::capability::Capability::maximum_address_mask_value(_1) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _41 = &_42;\n        _40 = _41 as &dyn core::fmt::Debug;\n        _5 = core::fmt::DebugStruct::<'_, '_>::field(_6, move _39, move _40) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_43);\n        _43 = \"fault_recording_number\";\n        StorageLive(_44);\n        StorageLive(_46);\n        _46 = arch::iommu::registers::capability::Capability::fault_recording_number(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _45 = &_46;\n        _44 = _45 as &dyn core::fmt::Debug;\n        _4 = core::fmt::DebugStruct::<'_, '_>::field(_5, move _43, move _44) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageLive(_47);\n        _47 = \"raw\";\n        StorageLive(_48);\n        _49 = &((*_1).0: u64);\n        _48 = _49 as &dyn core::fmt::Debug;\n        _3 = core::fmt::DebugStruct::<'_, '_>::field(_4, move _47, move _48) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_48);\n        StorageDead(_47);\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish(_3) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_46);\n        StorageDead(_42);\n        StorageDead(_38);\n        StorageDead(_34);\n        StorageDead(_30);\n        StorageDead(_26);\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}