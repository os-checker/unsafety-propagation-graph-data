{
  "name": "arch::timer::apic::init_periodic_mode_config::pit_callback",
  "safe": true,
  "callees": {
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "arch::kernel::apic::get_or_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the local APIC instance of the current CPU.\n\n The reference to the APIC instance will not outlive the given\n [`PinCurrentCpu`] guard and the APIC instance does not implement\n [`Sync`], so it is safe to assume that the APIC instance belongs\n to the current CPU. Note that interrupts are not disabled, so the\n APIC instance may be accessed concurrently by interrupt handlers.\n\n At the first time the function is called, the local APIC instance\n is initialized and enabled if it was not enabled beforehand.\n\n # Examples\n\n ```rust\n use ostd::{\n     arch::x86::kernel::apic,\n     task::disable_preempt,\n };\n\n let preempt_guard = disable_preempt();\n let apic = apic::get_or_init(&preempt_guard as _);\n\n let ticks = apic.timer_current_count();\n apic.set_timer_init_count(0);\n ```\n",
      "adt": {}
    },
    "arch::kernel::apic::ApicTimer::timer_current_count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the current count of the timer.\n The interval can be expressed by the expression: `init_count` - `current_count`.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU64::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::is_completed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the value has been initialized.\n\n This is done using [`Acquire`](core::sync::atomic::Ordering::Acquire) ordering, and\n therefore it is safe to access the value directly via\n [`get_unchecked`](Self::get_unchecked) if this returns true.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU64::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU64::fetch_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds to the current value, returning the previous value.\n\n This operation wraps around on overflow.\n\n `fetch_add` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Examples\n\n ```\n\n assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);\n assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\n",
      "adt": {}
    },
    "arch::kernel::apic::ApicTimer::set_timer_init_count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the initial timer count, the APIC timer will count down from this value.\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_lower_hex": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "arch::timer::apic::Config": [
      "Ref"
    ],
    "arch::trap::TrapFrame": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::timer::apic::init_periodic_mode_config::pit_callback"
  },
  "span": "ostd/src/arch/x86/timer/apic.rs:137:5: 170:6",
  "src": "fn pit_callback(_trap_frame: &TrapFrame) {\n        static IN_TIME: AtomicU64 = AtomicU64::new(0);\n        static APIC_FIRST_COUNT: AtomicU64 = AtomicU64::new(0);\n        // Set a certain times of callbacks to calculate the frequency\n        // The number of callbacks needed to calculate the APIC timer frequency.\n        // This is set to 1/10th of the TIMER_FREQ to ensure enough samples for accurate calculation.\n        const CALLBACK_TIMES: u64 = TIMER_FREQ / 10;\n\n        let preempt_guard = disable_preempt();\n        let apic = apic::get_or_init(&preempt_guard as _);\n\n        let apic_current_count = 0xFFFF_FFFF - apic.timer_current_count();\n\n        if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || CONFIG.is_completed() {\n            if IN_TIME.load(Ordering::Relaxed) == 0 {\n                APIC_FIRST_COUNT.store(apic_current_count, Ordering::Relaxed);\n            }\n            IN_TIME.fetch_add(1, Ordering::Relaxed);\n            return;\n        }\n\n        // Stop APIC Timer\n        apic.set_timer_init_count(0);\n\n        let apic_first_count = APIC_FIRST_COUNT.load(Ordering::Relaxed);\n        let apic_init_count = (apic_current_count - apic_first_count) / CALLBACK_TIMES;\n        info!(\n            \"APIC timer: first {:#x}, current {:#x}, init {:#x}\",\n            apic_first_count, apic_current_count, apic_init_count,\n        );\n        CONFIG.call_once(|| Config::PeriodicMode {\n            init_count: apic_init_count,\n        });\n    }",
  "mir": "fn arch::timer::apic::init_periodic_mode_config::pit_callback(_1: &arch::trap::TrapFrame) -> () {\n    let mut _0: ();\n    let  _2: task::preempt::guard::DisabledPreemptGuard;\n    let  _3: &dyn arch::kernel::apic::Apic;\n    let mut _4: &dyn cpu::id::current::PinCurrentCpu;\n    let  _5: &task::preempt::guard::DisabledPreemptGuard;\n    let  _6: u64;\n    let mut _7: u64;\n    let mut _8: (u64, bool);\n    let mut _9: bool;\n    let mut _10: u64;\n    let mut _11: &core::sync::atomic::AtomicU64;\n    let mut _12: core::sync::atomic::Ordering;\n    let mut _13: bool;\n    let mut _14: &spin::once::Once<arch::timer::apic::Config>;\n    let mut _15: u64;\n    let mut _16: &core::sync::atomic::AtomicU64;\n    let mut _17: core::sync::atomic::Ordering;\n    let  _18: ();\n    let mut _19: &core::sync::atomic::AtomicU64;\n    let mut _20: core::sync::atomic::Ordering;\n    let  _21: u64;\n    let mut _22: &core::sync::atomic::AtomicU64;\n    let mut _23: core::sync::atomic::Ordering;\n    let  _24: ();\n    let  _25: u64;\n    let mut _26: &core::sync::atomic::AtomicU64;\n    let mut _27: core::sync::atomic::Ordering;\n    let  _28: u64;\n    let mut _29: u64;\n    let mut _30: (u64, bool);\n    let mut _31: bool;\n    let  _32: log::Level;\n    let mut _33: bool;\n    let mut _34: &log::Level;\n    let mut _35: &log::LevelFilter;\n    let mut _36: bool;\n    let mut _37: &log::Level;\n    let mut _38: &log::LevelFilter;\n    let  _39: log::LevelFilter;\n    let  _40: ();\n    let mut _41: core::fmt::Arguments<'_>;\n    let  _42: (&u64, &u64, &u64);\n    let mut _43: &u64;\n    let mut _44: &u64;\n    let mut _45: &u64;\n    let  _46: [core::fmt::rt::Argument<'_>; 3];\n    let mut _47: core::fmt::rt::Argument<'_>;\n    let mut _48: core::fmt::rt::Argument<'_>;\n    let mut _49: core::fmt::rt::Argument<'_>;\n    let mut _50: &[u8; 54];\n    let  _51: &[core::fmt::rt::Argument<'_>; 3];\n    let  _52: &(&str, &str, &core::panic::Location<'_>);\n    let  _53: (&str, &str, &core::panic::Location<'_>);\n    let mut _54: &str;\n    let  _55: &core::panic::Location<'_>;\n    let  _56: &arch::timer::apic::Config;\n    let mut _57: &spin::once::Once<arch::timer::apic::Config>;\n    let mut _58: {closure@ostd/src/arch/x86/timer/apic.rs:167:26: 167:28};\n    let mut _59: &u64;\n    let mut _60: &u64;\n    let mut _61: &u64;\n    let mut _62: &u64;\n    debug _trap_frame => _1;\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug apic => _3;\n    debug apic_current_count => _6;\n    debug apic_first_count => _25;\n    debug apic_init_count => _28;\n    debug lvl => _32;\n    debug args => _42;\n    debug args => _46;\n    bb0: {\n        _2 = task::preempt::guard::disable_preempt() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &_2;\n        _4 = _5 as &dyn cpu::id::current::PinCurrentCpu;\n        _3 = arch::kernel::apic::get_or_init(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = <dyn arch::kernel::apic::Apic as arch::kernel::apic::ApicTimer>::timer_current_count(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = CheckedSub(4294967295_u64, _7);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", 4294967295_u64, move _7) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = move (_8.0: u64);\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = {alloc555: &core::sync::atomic::AtomicU64};\n        StorageLive(_12);\n        _12 = core::sync::atomic::Ordering::Relaxed;\n        _10 = core::sync::atomic::AtomicU64::load(move _11, move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = Lt(move _10, arch::timer::apic::init_periodic_mode_config::pit_callback::CALLBACK_TIMES);\n        switchInt(move _9) -> [0: bb7, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_10);\n        goto -> bb10;\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = {alloc538: &spin::once::Once<arch::timer::apic::Config>};\n        _13 = spin::once::Once::<arch::timer::apic::Config>::is_completed(move _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _13) -> [0: bb17, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = {alloc555: &core::sync::atomic::AtomicU64};\n        StorageLive(_17);\n        _17 = core::sync::atomic::Ordering::Relaxed;\n        _15 = core::sync::atomic::AtomicU64::load(move _16, move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_16);\n        switchInt(move _15) -> [0: bb12, otherwise: bb14];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageLive(_19);\n        _19 = {alloc559: &core::sync::atomic::AtomicU64};\n        StorageLive(_20);\n        _20 = core::sync::atomic::Ordering::Relaxed;\n        _18 = core::sync::atomic::AtomicU64::store(move _19, _6, move _20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb15;\n    }\n    bb14: {\n        StorageDead(_15);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = {alloc555: &core::sync::atomic::AtomicU64};\n        StorageLive(_23);\n        _23 = core::sync::atomic::Ordering::Relaxed;\n        _21 = core::sync::atomic::AtomicU64::fetch_add(move _22, 1_u64, move _23) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_13);\n        StorageDead(_9);\n        drop(_2) -> [return: bb37, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_9);\n        _24 = <dyn arch::kernel::apic::Apic as arch::kernel::apic::ApicTimer>::set_timer_init_count(_3, 0_u64) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageLive(_26);\n        _26 = {alloc559: &core::sync::atomic::AtomicU64};\n        StorageLive(_27);\n        _27 = core::sync::atomic::Ordering::Relaxed;\n        _25 = core::sync::atomic::AtomicU64::load(move _26, move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_28);\n        StorageLive(_29);\n        _30 = CheckedSub(_6, _25);\n        assert(!move (_30.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _6, _25) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _29 = move (_30.0: u64);\n        _31 = Eq(arch::timer::apic::init_periodic_mode_config::pit_callback::CALLBACK_TIMES, 0_u64);\n        assert(!move _31, \"attempt to divide `{}` by zero\", _29) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _28 = Div(move _29, arch::timer::apic::init_periodic_mode_config::pit_callback::CALLBACK_TIMES);\n        StorageDead(_29);\n        _32 = log::Level::Info;\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &_32;\n        StorageLive(_35);\n        _35 = arch::timer::apic::init_periodic_mode_config::pit_callback::promoted[0];\n        _33 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _34, move _35) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        switchInt(move _33) -> [0: bb34, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &_32;\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = log::max_level() -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _38 = &_39;\n        _36 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _37, move _38) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _36) -> [0: bb33, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &_25;\n        StorageLive(_44);\n        _44 = &_6;\n        StorageLive(_45);\n        _45 = &_28;\n        _42 = (move _43, move _44, move _45);\n        StorageDead(_45);\n        StorageDead(_44);\n        StorageDead(_43);\n        StorageLive(_46);\n        StorageLive(_47);\n        _60 = (_42.0: &u64);\n        _47 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_60) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageLive(_48);\n        _61 = (_42.1: &u64);\n        _48 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_61) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageLive(_49);\n        _62 = (_42.2: &u64);\n        _49 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u64>(_62) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _46 = [move _47, move _48, move _49];\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageLive(_50);\n        _50 = b\"\\x12APIC timer: first \\xc1 \\x00\\x80`\\n, current \\xc1 \\x00\\x80`\\x07, init \\xc1 \\x00\\x80`\\x00\";\n        _51 = &_46;\n        _41 = core::fmt::Arguments::<'_>::new::<54, 3>(move _50, _51) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_50);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = \"ostd::arch::timer::apic\";\n        _55 = log::__private_api::loc() -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _53 = (move _54, \"ostd::arch::timer::apic\", _55);\n        StorageDead(_54);\n        _52 = &_53;\n        _40 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _41, _32, _52, ()) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_41);\n        StorageDead(_53);\n        StorageDead(_46);\n        StorageDead(_42);\n        goto -> bb35;\n    }\n    bb33: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb35;\n    }\n    bb34: {\n        StorageDead(_35);\n        StorageDead(_34);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_36);\n        StorageDead(_33);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = {alloc538: &spin::once::Once<arch::timer::apic::Config>};\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = &_28;\n        _58 = {closure@ostd/src/arch/x86/timer/apic.rs:167:26: 167:28}(move _59);\n        StorageDead(_59);\n        _56 = spin::once::Once::<arch::timer::apic::Config>::call_once::<{closure@ostd/src/arch/x86/timer/apic.rs:167:26: 167:28}>(move _57, move _58) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageDead(_56);\n        StorageDead(_28);\n        drop(_2) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}