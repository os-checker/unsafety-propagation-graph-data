{
  "name": "panic::__ostd_panic_handler",
  "safe": true,
  "callees": {
    "irq::guard::disable_local": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables all IRQs on the current CPU (i.e., locally).\n\n This function returns a guard object, which will automatically enable local IRQs again when\n it is dropped. This function works correctly even when it is called in a _nested_ way.\n The local IRQs shall only be re-enabled when the most outer guard is dropped.\n\n This function can play nicely with [`SpinLock`] as the type uses this function internally.\n One can invoke this function even after acquiring a spin lock. And the reversed order is also ok.\n\n [`SpinLock`]: crate::sync::SpinLock\n\n # Example\n\n ```rust\n use ostd::irq;\n\n {\n     let _ = irq::disable_local();\n     todo!(\"do something when irqs are disabled\");\n }\n ```\n",
      "adt": {
        "irq::guard::DisabledLocalIrqGuard": "Constructor"
      }
    },
    "cpu::local::cell::CpuLocalCell::<T>::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the value of the per-CPU object in a single instruction.\n\n Note that this memory operation will not be elided or reordered by the\n compiler since it is a black-box.\n",
      "adt": {
        "cpu::local::cell::CpuLocalCell": "MutableAsArgument"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "console::early_print": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prints formatted arguments to the console.\n",
      "adt": {}
    },
    "panic::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the system.\n\n This function will first attempt to power off the system. If that fails, it will halt all CPUs.\n",
      "adt": {}
    },
    "cpu::local::cell::CpuLocalCell::<T>::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a value to the per-CPU object in a single instruction.\n\n Note that this memory operation will not be elided or reordered by the\n compiler since it is a black-box.\n",
      "adt": {
        "cpu::local::cell::CpuLocalCell": "MutableAsArgument"
      }
    },
    "panic::print_stack_trace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prints the stack trace of the current thread to the console.\n\n The printing procedure is protected by a spin lock to prevent interleaving.\n",
      "adt": {}
    }
  },
  "adts": {
    "irq::guard::DisabledLocalIrqGuard": [
      "Plain"
    ],
    "cpu::local::cell::CpuLocalCell": [
      "Ref"
    ],
    "core::panic::PanicInfo": [
      "Ref"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 2520,
  "span": "ostd/src/panic.rs:17:1: 35:2",
  "src": "pub fn __ostd_panic_handler(info: &core::panic::PanicInfo) -> ! {\n    let _irq_guard = crate::irq::disable_local();\n\n    crate::cpu_local_cell! {\n        static IN_PANIC: bool = false;\n    }\n\n    if IN_PANIC.load() {\n        early_println!(\"The panic handler panicked {:#?}\", info);\n        abort();\n    }\n\n    IN_PANIC.store(true);\n\n    early_println!(\"Non-resettable panic! {:#?}\", info);\n\n    print_stack_trace();\n    abort();\n}",
  "mir": "fn panic::__ostd_panic_handler(_1: &core::panic::PanicInfo<'_>) -> ! {\n    let mut _0: !;\n    let  _2: irq::guard::DisabledLocalIrqGuard;\n    let mut _3: bool;\n    let mut _4: &cpu::local::cell::CpuLocalCell<bool>;\n    let  _5: ();\n    let mut _6: core::fmt::Arguments<'_>;\n    let  _7: (&&core::panic::PanicInfo<'_>,);\n    let mut _8: &&core::panic::PanicInfo<'_>;\n    let  _9: [core::fmt::rt::Argument<'_>; 1];\n    let mut _10: core::fmt::rt::Argument<'_>;\n    let mut _11: &[u8; 36];\n    let  _12: &[core::fmt::rt::Argument<'_>; 1];\n    let  _13: !;\n    let  _14: ();\n    let mut _15: &cpu::local::cell::CpuLocalCell<bool>;\n    let  _16: ();\n    let mut _17: core::fmt::Arguments<'_>;\n    let  _18: (&&core::panic::PanicInfo<'_>,);\n    let mut _19: &&core::panic::PanicInfo<'_>;\n    let  _20: [core::fmt::rt::Argument<'_>; 1];\n    let mut _21: core::fmt::rt::Argument<'_>;\n    let mut _22: &[u8; 31];\n    let  _23: &[core::fmt::rt::Argument<'_>; 1];\n    let  _24: ();\n    let  _25: !;\n    let mut _26: &&core::panic::PanicInfo<'_>;\n    let mut _27: &&core::panic::PanicInfo<'_>;\n    debug info => _1;\n    debug _irq_guard => _2;\n    debug args => _7;\n    debug args => _9;\n    debug args => _18;\n    debug args => _20;\n    bb0: {\n        StorageLive(_2);\n        _2 = irq::guard::disable_local() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc1385: &cpu::local::cell::CpuLocalCell<bool>};\n        _3 = cpu::local::cell::CpuLocalCell::<bool>::load(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [0: bb7, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_1;\n        _7 = (move _8);\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _26 = (_7.0: &&core::panic::PanicInfo<'_>);\n        _10 = core::fmt::rt::Argument::<'_>::new_debug::<&core::panic::PanicInfo<'_>>(_26) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = [move _10];\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = b\"\\x1bThe panic handler panicked \\xc1 \\x00\\x80`\\x01\\n\\x00\";\n        _12 = &_9;\n        _6 = core::fmt::Arguments::<'_>::new::<36, 1>(move _11, _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        _5 = console::early_print(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_9);\n        StorageDead(_7);\n        _13 = panic::abort() -> unwind unreachable;\n    }\n    bb7: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_15);\n        _15 = {alloc1385: &cpu::local::cell::CpuLocalCell<bool>};\n        _14 = cpu::local::cell::CpuLocalCell::<bool>::store(move _15, true) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_1;\n        _18 = (move _19);\n        StorageDead(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _27 = (_18.0: &&core::panic::PanicInfo<'_>);\n        _21 = core::fmt::rt::Argument::<'_>::new_debug::<&core::panic::PanicInfo<'_>>(_27) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _20 = [move _21];\n        StorageDead(_21);\n        StorageLive(_22);\n        _22 = b\"\\x16Non-resettable panic! \\xc1 \\x00\\x80`\\x01\\n\\x00\";\n        _23 = &_20;\n        _17 = core::fmt::Arguments::<'_>::new::<31, 1>(move _22, _23) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_22);\n        _16 = console::early_print(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_20);\n        StorageDead(_18);\n        _24 = panic::print_stack_trace() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _25 = panic::abort() -> unwind unreachable;\n    }\n}\n",
  "doc": " The default panic handler for OSTD based kernels.\n\n The user can override it by defining their own panic handler with the macro\n `#[ostd::panic_handler]`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}