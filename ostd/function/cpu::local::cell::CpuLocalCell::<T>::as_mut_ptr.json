{
  "name": "cpu::local::cell::CpuLocalCell::<T>::as_mut_ptr",
  "safe": true,
  "callees": {
    "cpu::local::is_used::debug_set_true": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "cpu::local::__cpu_local_start": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "cpu::local::__cpu_local_end": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "arch::cpu::local::get_base": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the base address for the CPU local storage by reading the GS base model-specific register.\n",
      "adt": {}
    },
    "core::mem::align_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the [ABI]-required minimum alignment of a type in bytes.\n\n Every reference to a value of the type `T` must be a multiple of this number.\n\n This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n\n [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n\n # Examples\n\n ```\n assert_eq!(4, align_of::<i32>());\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "cpu::local::cell::CpuLocalCell": [
      "Deref",
      "Ref"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 1662,
  "span": "ostd/src/cpu/local/cell.rs:113:5: 132:6",
  "src": "pub fn as_mut_ptr(&'static self) -> *mut T {\n        super::is_used::debug_set_true();\n\n        let offset = {\n            let bsp_va = self as *const _ as usize;\n            let bsp_base = __cpu_local_start as *const () as usize;\n            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n            debug_assert!(bsp_va + size_of::<T>() <= __cpu_local_end as *const () as usize);\n\n            bsp_va - bsp_base as usize\n        };\n\n        let local_base = arch::cpu::local::get_base() as usize;\n        let local_va = local_base + offset;\n\n        // A sanity check about the alignment.\n        debug_assert_eq!(local_va % align_of::<T>(), 0);\n\n        local_va as *mut T\n    }",
  "mir": "fn cpu::local::cell::CpuLocalCell::<T>::as_mut_ptr(_1: &cpu::local::cell::CpuLocalCell<T>) -> *mut T {\n    let mut _0: *mut T;\n    let  _2: ();\n    let  _3: usize;\n    let  _4: usize;\n    let mut _5: *const cpu::local::cell::CpuLocalCell<T>;\n    let  _6: usize;\n    let mut _7: *const ();\n    let mut _8: unsafe extern \"C\" fn();\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let mut _13: usize;\n    let mut _14: *const ();\n    let mut _15: unsafe extern \"C\" fn();\n    let mut _16: !;\n    let mut _17: (usize, bool);\n    let  _18: usize;\n    let mut _19: u64;\n    let  _20: usize;\n    let mut _21: (usize, bool);\n    let mut _22: (&usize, &usize);\n    let mut _23: &usize;\n    let  _24: usize;\n    let mut _25: usize;\n    let mut _26: bool;\n    let mut _27: &usize;\n    let  _28: &usize;\n    let  _29: &usize;\n    let mut _30: bool;\n    let mut _31: usize;\n    let mut _32: usize;\n    let  _33: core::panicking::AssertKind;\n    let  _34: !;\n    let mut _35: core::option::Option<core::fmt::Arguments<'_>>;\n    debug self => _1;\n    debug offset => _3;\n    debug bsp_va => _4;\n    debug bsp_base => _6;\n    debug local_base => _18;\n    debug local_va => _20;\n    debug left_val => _28;\n    debug right_val => _29;\n    debug kind => _33;\n    bb0: {\n        _2 = cpu::local::is_used::debug_set_true() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &raw const (*_1);\n        _4 = _5 as usize;\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = cpu::local::__cpu_local_start as unsafe extern \"C\" fn();\n        _7 = move _8 as *const ();\n        StorageDead(_8);\n        _6 = move _7 as usize;\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = core::mem::size_of::<T>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _12 = CheckedAdd(_4, _11);\n        assert(!move (_12.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, move _11) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _10 = move (_12.0: usize);\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = cpu::local::__cpu_local_end as unsafe extern \"C\" fn();\n        _14 = move _15 as *const ();\n        StorageDead(_15);\n        _13 = move _14 as usize;\n        StorageDead(_14);\n        _9 = Le(move _10, move _13);\n        switchInt(move _9) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_13);\n        StorageDead(_10);\n        StorageDead(_9);\n        _17 = CheckedSub(_4, _6);\n        assert(!move (_17.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _6) -> [success: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        StorageDead(_10);\n        _16 = core::panicking::panic(\"assertion failed: bsp_va + size_of::<T>() <= __cpu_local_end as *const () as usize\") -> unwind unreachable;\n    }\n    bb6: {\n        _3 = move (_17.0: usize);\n        StorageLive(_19);\n        _19 = arch::cpu::local::get_base() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _18 = move _19 as usize;\n        StorageDead(_19);\n        _21 = CheckedAdd(_18, _3);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _18, _3) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _20 = move (_21.0: usize);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = core::mem::align_of::<T>() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _26 = Eq(_25, 0_usize);\n        assert(!move _26, \"attempt to calculate the remainder of `{}` with a divisor of zero\", _20) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _24 = Rem(_20, move _25);\n        StorageDead(_25);\n        _23 = &_24;\n        StorageLive(_27);\n        _27 = cpu::local::cell::CpuLocalCell::<T>::as_mut_ptr::promoted[0];\n        _22 = (move _23, move _27);\n        StorageDead(_27);\n        StorageDead(_23);\n        _28 = (_22.0: &usize);\n        _29 = (_22.1: &usize);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = (*_28);\n        StorageLive(_32);\n        _32 = (*_29);\n        _30 = Eq(move _31, move _32);\n        switchInt(move _30) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        StorageDead(_24);\n        StorageDead(_22);\n        _0 = _20 as *mut T;\n        return;\n    }\n    bb12: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _33 = core::panicking::AssertKind::Eq;\n        StorageLive(_35);\n        _35 = core::option::Option::None;\n        _34 = core::panicking::assert_failed::<usize, usize>(_33, _28, _29, move _35) -> unwind unreachable;\n    }\n}\n",
  "doc": " Gets access to the underlying value through a raw pointer.\n\n This function calculates the virtual address of the CPU-local object\n based on the CPU-local base address and the offset in the BSP.\n\n This method is safe, but using the returned pointer will be unsafe.\n Specifically,\n - Preemption should be disabled from the time this method is called\n   to the time the pointer is used. Otherwise, the pointer may point\n   to the variable on another CPU, making it difficult or impossible\n   to determine if the data can be borrowed.\n - If the variable can be used in interrupt handlers, borrowing the\n   data should be done with interrupts disabled. Otherwise, more care\n   must be taken to ensure that the borrowing rules are correctly\n   enforced, since the interrupts may come asynchronously.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}