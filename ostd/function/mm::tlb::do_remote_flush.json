{
  "name": "mm::tlb::do_remote_flush",
  "safe": true,
  "callees": {
    "cpu::id::current::<impl cpu::id::CpuId>::current_racy": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the ID of the current CPU.\n\n This function is safe to call, but is vulnerable to races. The returned CPU\n ID may be outdated if the task migrates to another CPU.\n\n To ensure that the CPU ID is up-to-date, do it under any guards that\n implement the [`PinCurrentCpu`] trait.\n",
      "adt": {
        "cpu::id::CpuId": "Constructor"
      }
    },
    "mm::tlb::OpsStack::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::tlb::OpsStack": "Constructor"
      }
    },
    "cpu::local::CpuLocal::<T, S>::get_on_cpu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets access to the CPU-local value on a specific CPU.\n\n This allows the caller to access CPU-local data from a remote CPU,\n so the data type must be `Sync`.\n",
      "adt": {
        "cpu::local::CpuLocal": "ImmutableAsArgument"
      }
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::mem::swap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Swaps the values at two mutable locations, without deinitializing either one.\n\n * If you want to swap with a default or dummy value, see [`take`].\n * If you want to swap with a passed value, returning the old value, see [`replace`].\n\n # Examples\n\n ```\n use std::mem;\n\n let mut x = 5;\n let mut y = 42;\n\n mem::swap(&mut x, &mut y);\n\n assert_eq!(42, x);\n assert_eq!(5, y);\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the bool.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n some_bool.store(false, Ordering::Relaxed);\n assert_eq!(some_bool.load(Ordering::Relaxed), false);\n ```\n",
      "adt": {}
    },
    "mm::tlb::OpsStack::flush_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::tlb::OpsStack": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "cpu::id::CpuId": [
      "Plain"
    ],
    "mm::tlb::OpsStack": [
      "Plain",
      "MutRef"
    ],
    "cpu::local::CpuLocal": [
      "Ref"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::tlb::do_remote_flush"
  },
  "span": "ostd/src/mm/tlb.rs:271:1: 289:2",
  "src": "fn do_remote_flush() {\n    // No races because we are in IRQs or have disabled preemption.\n    let current_cpu = crate::cpu::CpuId::current_racy();\n\n    let mut new_op_queue = OpsStack::new();\n    {\n        let mut op_queue = FLUSH_OPS.get_on_cpu(current_cpu).lock();\n\n        core::mem::swap(&mut *op_queue, &mut new_op_queue);\n\n        // ACK before dropping the lock so that we won't miss flush requests.\n        ACK_REMOTE_FLUSH\n            .get_on_cpu(current_cpu)\n            .store(true, Ordering::Relaxed);\n    }\n    // Unlock the locks quickly to avoid contention. ACK before flushing is\n    // fine since we cannot switch back to userspace now.\n    new_op_queue.flush_all();\n}",
  "mir": "fn mm::tlb::do_remote_flush() -> () {\n    let mut _0: ();\n    let  _1: cpu::id::CpuId;\n    let mut _2: mm::tlb::OpsStack;\n    let mut _3: sync::spin::SpinLockGuard<'_, mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>;\n    let  _4: &sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>;\n    let mut _5: &cpu::local::CpuLocal<sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>>>;\n    let  _6: ();\n    let mut _7: &mut mm::tlb::OpsStack;\n    let mut _8: &mut sync::spin::SpinLockGuard<'_, mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>;\n    let mut _9: &mut mm::tlb::OpsStack;\n    let  _10: ();\n    let  _11: &core::sync::atomic::AtomicBool;\n    let mut _12: &cpu::local::CpuLocal<core::sync::atomic::AtomicBool, cpu::local::static_cpu_local::StaticStorage<core::sync::atomic::AtomicBool>>;\n    let mut _13: core::sync::atomic::Ordering;\n    let  _14: ();\n    let mut _15: &mut mm::tlb::OpsStack;\n    debug current_cpu => _1;\n    debug new_op_queue => _2;\n    debug op_queue => _3;\n    bb0: {\n        _1 = cpu::id::current::<impl cpu::id::CpuId>::current_racy() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        _2 = mm::tlb::OpsStack::new() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_3);\n        StorageLive(_5);\n        _5 = {alloc1320: &cpu::local::CpuLocal<sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>>>};\n        _4 = cpu::local::CpuLocal::<sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>, cpu::local::static_cpu_local::StaticStorage<sync::spin::SpinLock<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>>>::get_on_cpu(move _5, _1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        _3 = sync::spin::SpinLock::<mm::tlb::OpsStack, sync::guard::LocalIrqDisabled>::lock(_4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = &mut _3;\n        _7 = <sync::spin::SpinLockGuard<'_, mm::tlb::OpsStack, sync::guard::LocalIrqDisabled> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _9 = &mut _2;\n        _6 = core::mem::swap::<mm::tlb::OpsStack>(_7, _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_12);\n        _12 = {alloc1371: &cpu::local::CpuLocal<core::sync::atomic::AtomicBool, cpu::local::static_cpu_local::StaticStorage<core::sync::atomic::AtomicBool>>};\n        _11 = cpu::local::CpuLocal::<core::sync::atomic::AtomicBool, cpu::local::static_cpu_local::StaticStorage<core::sync::atomic::AtomicBool>>::get_on_cpu(move _12, _1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageLive(_13);\n        _13 = core::sync::atomic::Ordering::Relaxed;\n        _10 = core::sync::atomic::AtomicBool::store(_11, true, move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        drop(_3) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_3);\n        StorageLive(_15);\n        _15 = &mut _2;\n        _14 = mm::tlb::OpsStack::flush_all(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        drop(_2) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}