{
  "name": "arch::iommu::interrupt_remapping::init",
  "safe": true,
  "callees": {
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::registers::IommuRegisters::read_extended_capability": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the extended Capability of IOMMU\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "ImmutableAsArgument",
        "arch::iommu::registers::extended_cap::ExtendedCapability": "Constructor"
      }
    },
    "arch::iommu::registers::extended_cap::ExtendedCapability::flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extended capability flags\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapability": "ImmutableAsArgument",
        "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": "Constructor"
      }
    },
    "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if all of the flags in `other` are contained within `self`.\n",
      "adt": {
        "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": "ImmutableAsArgument"
      }
    },
    "spin::once::Once::<T, R>::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it may not be the closure specified). The\n returned pointer will point to the result from the closure that was\n run.\n\n # Panics\n\n This function will panic if the [`Once`] previously panicked while attempting\n to initialize. This is similar to the poisoning behaviour of `std::sync`'s\n primitives.\n\n # Examples\n\n ```\n use spin;\n\n static INIT: spin::Once<usize> = spin::Once::new();\n\n fn get_cached_val() -> usize {\n     *INIT.call_once(expensive_computation)\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n",
      "adt": {}
    },
    "arch::iommu::interrupt_remapping::table::IntRemappingTable::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an Interrupt Remapping Table with one page.\n",
      "adt": {
        "arch::iommu::interrupt_remapping::table::IntRemappingTable": "Constructor"
      }
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::registers::IommuRegisters::enable_interrupt_remapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables Interrupt Remapping with IntRemappingTable\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "MutableAsArgument",
        "arch::iommu::interrupt_remapping::table::IntRemappingTable": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "arch::iommu::registers::IommuRegisters": [
      "Ref",
      "MutRef"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapability": [
      "Plain",
      "Ref"
    ],
    "arch::iommu::registers::extended_cap::ExtendedCapabilityFlags": [
      "Plain",
      "Ref"
    ],
    "arch::iommu::interrupt_remapping::table::IntRemappingTable": [
      "Ref"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": 729,
  "span": "ostd/src/arch/x86/iommu/interrupt_remapping/mod.rs:52:1: 67:2",
  "src": "pub(super) fn init() {\n    let mut iommu_regs = IOMMU_REGS.get().unwrap().lock();\n\n    // Check if interrupt remapping is supported\n    let extend_cap = iommu_regs.read_extended_capability();\n    if !extend_cap.flags().contains(ExtendedCapabilityFlags::IR) {\n        warn!(\"[IOMMU] Interrupt remapping not supported\");\n        return;\n    }\n\n    // Create interrupt remapping table\n    REMAPPING_TABLE.call_once(IntRemappingTable::new);\n    iommu_regs.enable_interrupt_remapping(REMAPPING_TABLE.get().unwrap());\n\n    info!(\"[IOMMU] Interrupt remapping enabled\");\n}",
  "mir": "fn arch::iommu::interrupt_remapping::init() -> () {\n    let mut _0: ();\n    let mut _1: sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _2: &sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let mut _3: core::option::Option<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let mut _4: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>;\n    let  _5: arch::iommu::registers::extended_cap::ExtendedCapability;\n    let  _6: &arch::iommu::registers::IommuRegisters;\n    let mut _7: &sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let mut _8: bool;\n    let mut _9: &arch::iommu::registers::extended_cap::ExtendedCapabilityFlags;\n    let  _10: arch::iommu::registers::extended_cap::ExtendedCapabilityFlags;\n    let mut _11: &arch::iommu::registers::extended_cap::ExtendedCapability;\n    let  _12: log::Level;\n    let mut _13: bool;\n    let mut _14: &log::Level;\n    let mut _15: &log::LevelFilter;\n    let mut _16: bool;\n    let mut _17: &log::Level;\n    let mut _18: &log::LevelFilter;\n    let  _19: log::LevelFilter;\n    let  _20: ();\n    let mut _21: core::fmt::Arguments<'_>;\n    let  _22: &(&str, &str, &core::panic::Location<'_>);\n    let  _23: (&str, &str, &core::panic::Location<'_>);\n    let mut _24: &str;\n    let  _25: &core::panic::Location<'_>;\n    let  _26: &arch::iommu::interrupt_remapping::table::IntRemappingTable;\n    let mut _27: &spin::once::Once<arch::iommu::interrupt_remapping::table::IntRemappingTable>;\n    let  _28: ();\n    let mut _29: &mut arch::iommu::registers::IommuRegisters;\n    let mut _30: &mut sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>;\n    let  _31: &arch::iommu::interrupt_remapping::table::IntRemappingTable;\n    let mut _32: core::option::Option<&arch::iommu::interrupt_remapping::table::IntRemappingTable>;\n    let mut _33: &spin::once::Once<arch::iommu::interrupt_remapping::table::IntRemappingTable>;\n    let  _34: log::Level;\n    let mut _35: bool;\n    let mut _36: &log::Level;\n    let mut _37: &log::LevelFilter;\n    let mut _38: bool;\n    let mut _39: &log::Level;\n    let mut _40: &log::LevelFilter;\n    let  _41: log::LevelFilter;\n    let  _42: ();\n    let mut _43: core::fmt::Arguments<'_>;\n    let  _44: &(&str, &str, &core::panic::Location<'_>);\n    let  _45: (&str, &str, &core::panic::Location<'_>);\n    let mut _46: &str;\n    let  _47: &core::panic::Location<'_>;\n    debug iommu_regs => _1;\n    debug extend_cap => _5;\n    debug lvl => _12;\n    debug lvl => _34;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc227: &spin::once::Once<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>};\n        _3 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::get(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = core::option::Option::<&sync::spin::SpinLock<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>>::unwrap(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _1 = sync::spin::SpinLock::<arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled>::lock(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &_1;\n        _6 = <sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled> as core::ops::Deref>::deref(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = arch::iommu::registers::IommuRegisters::read_extended_capability(_6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_5;\n        _10 = arch::iommu::registers::extended_cap::ExtendedCapability::flags(move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = &_10;\n        StorageDead(_11);\n        _8 = arch::iommu::registers::extended_cap::ExtendedCapabilityFlags::contains(move _9, arch::iommu::registers::extended_cap::ExtendedCapabilityFlags::IR) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _8) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = {alloc186: &spin::once::Once<arch::iommu::interrupt_remapping::table::IntRemappingTable>};\n        _26 = spin::once::Once::<arch::iommu::interrupt_remapping::table::IntRemappingTable>::call_once::<fn() -> arch::iommu::interrupt_remapping::table::IntRemappingTable {arch::iommu::interrupt_remapping::table::IntRemappingTable::new}>(move _27, arch::iommu::interrupt_remapping::table::IntRemappingTable::new) -> [return: bb21, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageDead(_10);\n        _12 = log::Level::Warn;\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_12;\n        StorageLive(_15);\n        _15 = arch::iommu::interrupt_remapping::init::promoted[1];\n        _13 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _14, move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _13) -> [0: bb19, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_12;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = log::max_level() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = &_19;\n        _16 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _17, move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _16) -> [0: bb18, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_21);\n        _21 = core::fmt::Arguments::<'_>::from_str(\"[IOMMU] Interrupt remapping not supported\") -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = \"ostd::arch::iommu::interrupt_remapping\";\n        _25 = log::__private_api::loc() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _23 = (move _24, \"ostd::arch::iommu::interrupt_remapping\", _25);\n        StorageDead(_24);\n        _22 = &_23;\n        _20 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _21, _12, _22, ()) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_21);\n        StorageDead(_23);\n        goto -> bb20;\n    }\n    bb18: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageDead(_8);\n        StorageDead(_5);\n        drop(_1) -> [return: bb38, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_30);\n        _30 = &mut _1;\n        _29 = <sync::spin::SpinLockGuard<'_, arch::iommu::registers::IommuRegisters, sync::guard::LocalIrqDisabled> as core::ops::DerefMut>::deref_mut(move _30) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_30);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = {alloc186: &spin::once::Once<arch::iommu::interrupt_remapping::table::IntRemappingTable>};\n        _32 = spin::once::Once::<arch::iommu::interrupt_remapping::table::IntRemappingTable>::get(move _33) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_33);\n        _31 = core::option::Option::<&arch::iommu::interrupt_remapping::table::IntRemappingTable>::unwrap(move _32) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_32);\n        _28 = arch::iommu::registers::IommuRegisters::enable_interrupt_remapping(_29, _31) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        _34 = log::Level::Info;\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &_34;\n        StorageLive(_37);\n        _37 = arch::iommu::interrupt_remapping::init::promoted[0];\n        _35 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _36, move _37) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _35) -> [0: bb35, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &_34;\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = log::max_level() -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _40 = &_41;\n        _38 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _39, move _40) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        switchInt(move _38) -> [0: bb34, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_43);\n        _43 = core::fmt::Arguments::<'_>::from_str(\"[IOMMU] Interrupt remapping enabled\") -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = \"ostd::arch::iommu::interrupt_remapping\";\n        _47 = log::__private_api::loc() -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _45 = (move _46, \"ostd::arch::iommu::interrupt_remapping\", _47);\n        StorageDead(_46);\n        _44 = &_45;\n        _42 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _43, _34, _44, ()) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_43);\n        StorageDead(_45);\n        goto -> bb36;\n    }\n    bb34: {\n        StorageDead(_41);\n        StorageDead(_40);\n        StorageDead(_39);\n        goto -> bb36;\n    }\n    bb35: {\n        StorageDead(_37);\n        StorageDead(_36);\n        goto -> bb36;\n    }\n    bb36: {\n        StorageDead(_38);\n        StorageDead(_35);\n        StorageDead(_5);\n        drop(_1) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_1);\n        goto -> bb39;\n    }\n    bb38: {\n        StorageDead(_1);\n        goto -> bb39;\n    }\n    bb39: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}