{
  "name": "arch::iommu::registers::IommuRegisters::invalidate_interrupt_cache",
  "safe": true,
  "callees": {
    "arch::iommu::registers::IommuRegisters::read_global_status": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the global Status of IOMMU\n",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "ImmutableAsArgument",
        "arch::iommu::registers::status::GlobalStatus": "Constructor"
      }
    },
    "arch::iommu::registers::status::GlobalStatus::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if all of the flags in `other` are contained within `self`.\n",
      "adt": {
        "arch::iommu::registers::status::GlobalStatus": "ImmutableAsArgument"
      }
    },
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "arch::iommu::registers::IommuRegisters::global_invalidation": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::registers::IommuRegisters": "MutableAsArgument"
      }
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::invalidate::descriptor::InterruptEntryCache::global_invalidation": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::invalidate::descriptor::InterruptEntryCache": "Constructor"
      }
    },
    "arch::iommu::invalidate::queue::Queue::append_descriptor": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::invalidate::queue::Queue": "MutableAsArgument"
      }
    },
    "arch::iommu::invalidate::descriptor::InvalidationWait::with_interrupt_flag": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::invalidate::descriptor::InvalidationWait": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "arch::iommu::invalidate::queue::Queue::tail": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::invalidate::queue::Queue": "ImmutableAsArgument"
      }
    },
    "volatile::VolatileRef::<'a, T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows this `VolatileRef` as a mutable [`VolatilePtr`].\n\n Use this method to do (partial) volatile reads or writes of the referenced data.\n",
      "adt": {}
    },
    "volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile write, setting the contained value to the given `value`.\n\n Volatile writes are guaranteed to not be optimized away by the compiler, but by\n themselves do not have atomic ordering guarantees. To also get atomicity, consider\n looking at the `Atomic` wrapper types of the standard/`core` library.\n\n ## Example\n\n ```rust\n use volatile::VolatilePtr;\n\n let mut value = 42;\n let volatile = unsafe { VolatilePtr::new((&mut value).into()) };\n volatile.write(50);\n\n assert_eq!(volatile.read(), 50);\n ```\n",
      "adt": {}
    },
    "volatile::VolatileRef::<'a, T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Borrows this `VolatileRef` as a read-only [`VolatilePtr`].\n\n Use this method to do (partial) volatile reads of the referenced data.\n",
      "adt": {}
    },
    "volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'a, T, A>>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs a volatile read of the contained value.\n\n Returns a copy of the read value. Volatile reads are guaranteed not to be optimized\n away by the compiler, but by themselves do not have atomic ordering\n guarantees. To also get atomicity, consider looking at the `Atomic` wrapper types of\n the standard/`core` library.\n\n ## Examples\n\n ```rust\n use volatile::{VolatilePtr, access};\n use core::ptr::NonNull;\n\n let value = 42;\n let pointer = unsafe {\n     VolatilePtr::new_restricted(access::ReadOnly, NonNull::from(&value))\n };\n assert_eq!(pointer.read(), 42);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "arch::iommu::registers::IommuRegisters": [
      "Ref",
      "Deref",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(8)))"
    ],
    "arch::iommu::registers::status::GlobalStatus": [
      "Plain",
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "arch::iommu::invalidate::queue::Queue": [
      "MutRef",
      "Ref"
    ],
    "arch::iommu::invalidate::descriptor::InterruptEntryCache": [
      "Plain",
      "Unknown([Field(0, Ty { id: 955, kind: RigidTy(Uint(U128)) })])"
    ],
    "arch::iommu::invalidate::descriptor::InvalidationWait": [
      "Plain",
      "Unknown([Field(0, Ty { id: 955, kind: RigidTy(Uint(U128)) })])"
    ],
    "volatile::VolatileRef": [
      "MutRef",
      "Ref"
    ],
    "volatile::VolatilePtr": [
      "Plain"
    ]
  },
  "path": 1099,
  "span": "ostd/src/arch/x86/iommu/registers/mod.rs:199:5: 228:6",
  "src": "pub(super) fn invalidate_interrupt_cache(&mut self) {\n        if !self.read_global_status().contains(GlobalStatus::QIES) {\n            self.global_invalidation();\n            return;\n        }\n\n        let mut queue = QUEUE.get().unwrap().lock();\n\n        // Currently, we don't support asynchronous processing in the queue. Therefore, when we\n        // lock the queue, we know that it is empty and that the Invalidation Completion Status\n        // Register has been cleared.\n\n        // Construct an Interrupt Entry Cache Invalidate Descriptor.\n        queue.append_descriptor(InterruptEntryCache::global_invalidation().0);\n        // Construct an Invalidation Wait Descriptor. We need to set the interrupt flag so that the\n        // Invalidation Completion Status Register can report the completion status.\n        queue.append_descriptor(InvalidationWait::with_interrupt_flag().0);\n\n        // Update the queue tail.\n        let tail = queue.tail();\n        self.invalidate\n            .queue_tail\n            .as_mut_ptr()\n            .write((tail << 4) as u64);\n\n        // Wait for completion.\n        while self.invalidate.completion_status.as_ptr().read() == 0 {}\n        // Clear the Invalidation Completion Status Register.\n        self.invalidate.completion_status.as_mut_ptr().write(1);\n    }",
  "mir": "fn arch::iommu::registers::IommuRegisters::invalidate_interrupt_cache(_1: &mut arch::iommu::registers::IommuRegisters) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: &arch::iommu::registers::status::GlobalStatus;\n    let  _4: arch::iommu::registers::status::GlobalStatus;\n    let mut _5: &arch::iommu::registers::IommuRegisters;\n    let  _6: ();\n    let mut _7: sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled>;\n    let  _8: &sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>;\n    let mut _9: core::option::Option<&sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>;\n    let mut _10: &spin::once::Once<sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>;\n    let  _11: ();\n    let mut _12: &mut arch::iommu::invalidate::queue::Queue;\n    let mut _13: &mut sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled>;\n    let mut _14: u128;\n    let mut _15: arch::iommu::invalidate::descriptor::InterruptEntryCache;\n    let  _16: ();\n    let mut _17: &mut arch::iommu::invalidate::queue::Queue;\n    let mut _18: &mut sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled>;\n    let mut _19: u128;\n    let mut _20: arch::iommu::invalidate::descriptor::InvalidationWait;\n    let  _21: usize;\n    let  _22: &arch::iommu::invalidate::queue::Queue;\n    let mut _23: &sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled>;\n    let  _24: ();\n    let mut _25: volatile::VolatilePtr<'_, u64>;\n    let mut _26: &mut volatile::VolatileRef<'_, u64>;\n    let mut _27: u64;\n    let mut _28: usize;\n    let mut _29: u32;\n    let mut _30: bool;\n    let mut _31: u32;\n    let mut _32: volatile::VolatilePtr<'_, u32, volatile::access::ReadOnly>;\n    let mut _33: &volatile::VolatileRef<'_, u32>;\n    let  _34: ();\n    let mut _35: volatile::VolatilePtr<'_, u32>;\n    let mut _36: &mut volatile::VolatileRef<'_, u32>;\n    debug self => _1;\n    debug queue => _7;\n    debug tail => _21;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = arch::iommu::registers::IommuRegisters::read_global_status(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &_4;\n        StorageDead(_5);\n        _2 = arch::iommu::registers::status::GlobalStatus::contains(move _3, arch::iommu::registers::status::GlobalStatus::QIES) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageDead(_4);\n        StorageDead(_2);\n        StorageLive(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = {alloc203: &spin::once::Once<sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>};\n        _9 = spin::once::Once::<sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>::get(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        StorageDead(_4);\n        _6 = arch::iommu::registers::IommuRegisters::global_invalidation(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        goto -> bb28;\n    }\n    bb6: {\n        StorageDead(_10);\n        _8 = core::option::Option::<&sync::spin::SpinLock<arch::iommu::invalidate::queue::Queue>>::unwrap(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        _7 = sync::spin::SpinLock::<arch::iommu::invalidate::queue::Queue>::lock(_8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_13);\n        _13 = &mut _7;\n        _12 = <sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = arch::iommu::invalidate::descriptor::InterruptEntryCache::global_invalidation() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _14 = (_15.0: u128);\n        _11 = arch::iommu::invalidate::queue::Queue::append_descriptor(_12, move _14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageDead(_15);\n        StorageLive(_18);\n        _18 = &mut _7;\n        _17 = <sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = arch::iommu::invalidate::descriptor::InvalidationWait::with_interrupt_flag() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _19 = (_20.0: u128);\n        _16 = arch::iommu::invalidate::queue::Queue::append_descriptor(_17, move _19) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_19);\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = &_7;\n        _22 = <sync::spin::SpinLockGuard<'_, arch::iommu::invalidate::queue::Queue, sync::guard::PreemptDisabled> as core::ops::Deref>::deref(move _23) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_23);\n        _21 = arch::iommu::invalidate::queue::Queue::tail(_22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &mut (((*_1).8: arch::iommu::registers::invalidation::InvalidationRegisters).1: volatile::VolatileRef<'_, u64>);\n        _25 = volatile::VolatileRef::<'_, u64>::as_mut_ptr(move _26) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _29 = 4_i32 as u32;\n        _30 = Lt(move _29, 64_u32);\n        assert(move _30, \"attempt to shift left by `{}`, which would overflow\", 4_i32) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _28 = Shl(_21, 4_i32);\n        _27 = move _28 as u64;\n        StorageDead(_28);\n        _24 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u64>>::write(move _25, move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        StorageDead(_25);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &(((*_1).8: arch::iommu::registers::invalidation::InvalidationRegisters).3: volatile::VolatileRef<'_, u32>);\n        _32 = volatile::VolatileRef::<'_, u32>::as_ptr(move _33) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        _31 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u32, volatile::access::ReadOnly>>::read(move _32) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_32);\n        switchInt(move _31) -> [0: bb23, otherwise: bb24];\n    }\n    bb23: {\n        StorageDead(_31);\n        goto -> bb20;\n    }\n    bb24: {\n        StorageDead(_31);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = &mut (((*_1).8: arch::iommu::registers::invalidation::InvalidationRegisters).3: volatile::VolatileRef<'_, u32>);\n        _35 = volatile::VolatileRef::<'_, u32>::as_mut_ptr(move _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        _34 = volatile::volatile_ptr::operations::<impl volatile::VolatilePtr<'_, u32>>::write(move _35, 1_u32) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        drop(_7) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_7);\n        goto -> bb28;\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}