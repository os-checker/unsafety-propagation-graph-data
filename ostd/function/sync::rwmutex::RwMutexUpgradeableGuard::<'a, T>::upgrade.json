{
  "name": "sync::rwmutex::RwMutexUpgradeableGuard::<'a, T>::upgrade",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicUsize::fetch_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Bitwise \"or\" with the current value.\n\n Performs a bitwise \"or\" operation on the current value and the argument `val`, and\n sets the new value to the result.\n\n Returns the previous value.\n\n `fetch_or` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Examples\n\n ```\n\n assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);\n assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\n",
      "adt": {}
    },
    "sync::rwmutex::RwMutexUpgradeableGuard::<'a, T>::try_upgrade": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to upgrade this upread guard to a write guard atomically.\n\n This function will return immediately.\n",
      "adt": {
        "sync::rwmutex::RwMutexUpgradeableGuard": "Constructor",
        "core::result::Result": "Constructor",
        "sync::rwmutex::RwMutexWriteGuard": "Constructor"
      }
    }
  },
  "adts": {
    "sync::rwmutex::RwMutex": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "sync::rwmutex::RwMutexUpgradeableGuard": [
      "Unknown([Field(0, Ty { id: 7097, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 7099, kind: RigidTy(Adt(AdtDef(DefId { id: 5869, name: \"sync::rwmutex::RwMutex\" }), GenericArgs([Type(Ty { id: 38, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) }, Not)) })])",
      "Plain"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7113, kind: RigidTy(Adt(AdtDef(DefId { id: 5882, name: \"sync::rwmutex::RwMutexUpgradeableGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 38, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7108, kind: RigidTy(Adt(AdtDef(DefId { id: 5878, name: \"sync::rwmutex::RwMutexWriteGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 38, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])"
    ],
    "sync::rwmutex::RwMutexWriteGuard": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::sync::rwmutex::RwMutexUpgradeableGuard::<'a, T>::upgrade"
  },
  "span": "ostd/src/sync/rwmutex.rs:325:5: 333:6",
  "src": "pub fn upgrade(mut self) -> RwMutexWriteGuard<'a, T> {\n        self.inner.lock.fetch_or(BEING_UPGRADED, Acquire);\n        loop {\n            self = match self.try_upgrade() {\n                Ok(guard) => return guard,\n                Err(e) => e,\n            };\n        }\n    }",
  "mir": "fn sync::rwmutex::RwMutexUpgradeableGuard::<'a, T>::upgrade(_1: sync::rwmutex::RwMutexUpgradeableGuard<'_, T>) -> sync::rwmutex::RwMutexWriteGuard<'_, T> {\n    let mut _0: sync::rwmutex::RwMutexWriteGuard<'_, T>;\n    let  _2: usize;\n    let mut _3: &core::sync::atomic::AtomicUsize;\n    let mut _4: core::sync::atomic::Ordering;\n    let mut _5: core::result::Result<sync::rwmutex::RwMutexWriteGuard<'_, T>, sync::rwmutex::RwMutexUpgradeableGuard<'_, T>>;\n    let mut _6: sync::rwmutex::RwMutexUpgradeableGuard<'_, T>;\n    let mut _7: isize;\n    let  _8: sync::rwmutex::RwMutexUpgradeableGuard<'_, T>;\n    let mut _9: &sync::rwmutex::RwMutex<T>;\n    debug self => _1;\n    debug guard => _0;\n    debug e => _8;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _9 = (_1.0: &sync::rwmutex::RwMutex<T>);\n        _3 = &((*_9).0: core::sync::atomic::AtomicUsize);\n        StorageLive(_4);\n        _4 = core::sync::atomic::Ordering::Acquire;\n        _2 = core::sync::atomic::AtomicUsize::fetch_or(move _3, sync::rwmutex::BEING_UPGRADED, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = move _1;\n        _5 = sync::rwmutex::RwMutexUpgradeableGuard::<'_, T>::try_upgrade(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb6, 1: bb5, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _8 = move ((_5 as variant#1).0: sync::rwmutex::RwMutexUpgradeableGuard<'_, T>);\n        _1 = _8;\n        StorageDead(_5);\n        goto -> bb2;\n    }\n    bb6: {\n        _0 = move ((_5 as variant#0).0: sync::rwmutex::RwMutexWriteGuard<'_, T>);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Upgrades this upread guard to a write guard atomically.\n\n After calling this method, subsequent readers will be blocked\n while previous readers remain unaffected.\n\n The calling thread will not sleep, but spin to wait for the existing\n reader to be released. There are two main reasons.\n - First, it needs to sleep in an extra waiting queue and needs extra wake-up logic and overhead.\n - Second, upgrading method usually requires a high response time (because the mutex is being used now).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}