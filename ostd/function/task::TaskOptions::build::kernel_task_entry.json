{
  "name": "task::TaskOptions::build::kernel_task_entry",
  "safe": false,
  "callees": {
    "task::processor::after_switching_to": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Does cleanups after switching to a task.\n\n # Safety\n\n This function must be called only once after switching to a task.\n",
      "adt": {}
    },
    "task::Task::current": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the current task.\n\n It returns `None` if the function is called in the bootstrap context.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "task::CurrentTask": "Constructor"
      }
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "task::utils::ForceSync::<T>::get": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner data.\n\n # Safety\n\n If the data type is not [`Sync`], the caller must ensure that the data is not accessed\n concurrently.\n",
      "adt": {
        "task::utils::ForceSync": "ImmutableAsArgument"
      }
    },
    "core::cell::Cell::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value of the cell, leaving `Default::default()` in its place.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n let five = c.take();\n\n assert_eq!(five, 5);\n assert_eq!(c.into_inner(), 0);\n ```\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "task::scheduler::exit_current": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dequeues the current task from its runqueue.\n\n This should only be called if the current is to exit.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "task::CurrentTask": [
      "Plain",
      "Ref"
    ],
    "task::Task": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "task::utils::ForceSync": [
      "Ref"
    ],
    "core::cell::Cell": [
      "Ref"
    ],
    "alloc::boxed::Box": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::task::TaskOptions::build::kernel_task_entry"
  },
  "span": "ostd/src/task/mod.rs:174:9: 197:10",
  "src": "unsafe extern \"C\" fn kernel_task_entry() -> ! {\n            // SAFETY: The new task is switched on a CPU for the first time, `after_switching_to`\n            // hasn't been called yet.\n            unsafe { processor::after_switching_to() };\n\n            let current_task = Task::current()\n                .expect(\"no current task, it should have current task in kernel task entry\");\n\n            // SAFETY: The `func` field will only be accessed by the current task in the task\n            // context, so the data won't be accessed concurrently.\n            let task_func = unsafe { current_task.func.get() };\n            let task_func = task_func\n                .take()\n                .expect(\"task function is `None` when trying to run\");\n            task_func();\n\n            // Manually drop all the on-stack variables to prevent memory leakage!\n            // This is needed because `scheduler::exit_current()` will never return.\n            //\n            // However, `current_task` _borrows_ the current task without holding\n            // an extra reference count. So we do nothing here.\n\n            scheduler::exit_current();\n        }",
  "mir": "fn task::TaskOptions::build::kernel_task_entry() -> ! {\n    let mut _0: !;\n    let  _1: ();\n    let  _2: task::CurrentTask;\n    let mut _3: core::option::Option<task::CurrentTask>;\n    let mut _4: &str;\n    let  _5: &core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>;\n    let mut _6: &task::utils::ForceSync<core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>>;\n    let  _7: &task::Task;\n    let mut _8: &task::CurrentTask;\n    let  _9: alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>;\n    let mut _10: core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>;\n    let mut _11: &str;\n    let  _12: ();\n    let  _13: !;\n    debug current_task => _2;\n    debug task_func => _5;\n    debug task_func => _9;\n    bb0: {\n        _1 = task::processor::after_switching_to() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = task::Task::current() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = \"no current task, it should have current task in kernel task entry\";\n        _2 = core::option::Option::<task::CurrentTask>::expect(move _3, move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_2;\n        _7 = <task::CurrentTask as core::ops::Deref>::deref(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _6 = &((*_7).0: task::utils::ForceSync<core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>>);\n        _5 = task::utils::ForceSync::<core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>>::get(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_10);\n        _10 = core::cell::Cell::<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>::take(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_11);\n        _11 = \"task function is `None` when trying to run\";\n        _9 = core::option::Option::<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>::expect(move _10, move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _12 = <alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send> as core::ops::FnOnce<()>>::call_once(_9, ()) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _13 = task::scheduler::exit_current() -> unwind unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}