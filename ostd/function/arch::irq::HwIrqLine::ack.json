{
  "name": "arch::irq::HwIrqLine::ack",
  "safe": true,
  "callees": {
    "arch::cpu::context::CpuException::is_cpu_exception": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "arch::kernel::apic::get_or_init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the local APIC instance of the current CPU.\n\n The reference to the APIC instance will not outlive the given\n [`PinCurrentCpu`] guard and the APIC instance does not implement\n [`Sync`], so it is safe to assume that the APIC instance belongs\n to the current CPU. Note that interrupts are not disabled, so the\n APIC instance may be accessed concurrently by interrupt handlers.\n\n At the first time the function is called, the local APIC instance\n is initialized and enabled if it was not enabled beforehand.\n\n # Examples\n\n ```rust\n use ostd::{\n     arch::x86::kernel::apic,\n     task::disable_preempt,\n };\n\n let preempt_guard = disable_preempt();\n let apic = apic::get_or_init(&preempt_guard as _);\n\n let ticks = apic.timer_current_count();\n apic.set_timer_init_count(0);\n ```\n",
      "adt": {}
    },
    "arch::kernel::apic::Apic::eoi": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " End of Interrupt, this function will inform APIC that this interrupt has been processed.\n",
      "adt": {}
    }
  },
  "adts": {
    "arch::irq::HwIrqLine": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::irq::HwIrqLine::ack"
  },
  "span": "ostd/src/arch/x86/irq/mod.rs:45:5: 52:6",
  "src": "pub(crate) fn ack(&self) {\n        debug_assert!(!cpu::context::CpuException::is_cpu_exception(\n            self.irq_num as usize\n        ));\n        // TODO: We're in the interrupt context, so `disable_preempt()` is not\n        // really necessary here.\n        kernel::apic::get_or_init(&crate::task::disable_preempt() as _).eoi();\n    }",
  "mir": "fn arch::irq::HwIrqLine::ack(_1: &arch::irq::HwIrqLine) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: usize;\n    let mut _4: u8;\n    let mut _5: !;\n    let  _6: ();\n    let  _7: &dyn arch::kernel::apic::Apic;\n    let mut _8: &dyn cpu::id::current::PinCurrentCpu;\n    let  _9: &task::preempt::guard::DisabledPreemptGuard;\n    let  _10: task::preempt::guard::DisabledPreemptGuard;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ((*_1).0: u8);\n        _3 = move _4 as usize;\n        StorageDead(_4);\n        _2 = arch::cpu::context::CpuException::is_cpu_exception(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        _5 = core::panicking::panic(\"assertion failed: !cpu::context::CpuException::is_cpu_exception(self.irq_num as usize)\") -> unwind unreachable;\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageDead(_2);\n        _10 = task::preempt::guard::disable_preempt() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = &_10;\n        _8 = _9 as &dyn cpu::id::current::PinCurrentCpu;\n        _7 = arch::kernel::apic::get_or_init(_8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _6 = <dyn arch::kernel::apic::Apic as arch::kernel::apic::Apic>::eoi(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        drop(_10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}