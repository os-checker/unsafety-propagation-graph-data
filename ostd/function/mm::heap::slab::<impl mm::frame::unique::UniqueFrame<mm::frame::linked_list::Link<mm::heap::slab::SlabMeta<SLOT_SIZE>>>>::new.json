{
  "name": "mm::heap::slab::<impl mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>::new",
  "safe": true,
  "callees": {
    "mm::frame::allocator::FrameAllocOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates new options for allocating the specified number of frames.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::zeroed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets whether the allocated frames should be initialized with zeros.\n\n If `zeroed` is `true`, the allocated frames are filled with zeros.\n If not, the allocated frames will contain sensitive data and the caller\n should clear them before sharing them with other components.\n\n By default, the frames are zero-initialized.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "MutableAsArgument"
      }
    },
    "mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty list.\n",
      "adt": {
        "mm::heap::slot_list::SlabSlotList": "Constructor"
      }
    },
    "mm::frame::linked_list::Link::<M>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new linked list metadata.\n",
      "adt": {
        "mm::frame::linked_list::Link": "Constructor"
      }
    },
    "mm::frame::allocator::FrameAllocOptions::alloc_frame_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a single frame with additional metadata.\n",
      "adt": {
        "mm::frame::allocator::FrameAllocOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "mm::frame::Frame": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "mm::mem_obj::HasPaddr::paddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the start physical address of the memory object.\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "core::iter::Iterator::step_by": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator starting at the same point, but stepping by\n the given amount at each iteration.\n\n Note 1: The first element of the iterator will always be returned,\n regardless of the step given.\n\n Note 2: The time at which ignored elements are pulled is not fixed.\n `StepBy` behaves like the sequence `self.next()`, `self.nth(step-1)`,\n `self.nth(step-1)`, …, but is also free to behave like the sequence\n `advance_n_and_return_first(&mut self, step)`,\n `advance_n_and_return_first(&mut self, step)`, …\n Which way is used may change for some iterators for performance reasons.\n The second way will advance the iterator earlier and may consume more items.\n\n `advance_n_and_return_first` is the equivalent of:\n ```\n fn advance_n_and_return_first<I>(iter: &mut I, n: usize) -> Option<I::Item>\n where\n     I: Iterator,\n {\n     let next = iter.next();\n     if n > 1 {\n         iter.nth(n - 2);\n     }\n     next\n }\n ```\n\n # Panics\n\n The method will panic if the given step is `0`.\n\n # Examples\n\n ```\n let a = [0, 1, 2, 3, 4, 5];\n let mut iter = a.into_iter().step_by(2);\n\n assert_eq!(iter.next(), Some(0));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull`.\n\n # Safety\n\n `ptr` must be non-null.\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = unsafe { NonNull::new_unchecked(&mut x as *mut _) };\n ```\n\n *Incorrect* usage of this function:\n\n ```rust,no_run\n use std::ptr::NonNull;\n\n // NEVER DO THAT!!! This is undefined behavior. ⚠️\n let ptr = unsafe { NonNull::<u32>::new_unchecked(std::ptr::null_mut()) };\n ```\n",
      "adt": {}
    },
    "mm::frame::unique::UniqueFrame::<M>::meta_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the mutable metadata of this page.\n",
      "adt": {
        "mm::frame::unique::UniqueFrame": "MutableAsArgument"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "mm::heap::slot::HeapSlot::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new pointer to a heap slot.\n\n # Safety\n\n The pointer to the slot must either:\n  - be a free slot in a [`super::Slab`], or\n  - be a free slot in a [`Segment`].\n\n If the pointer is from a [`super::Slab`] or [`Segment`], the slot must\n have a size that matches the slot size of the slab or segment respectively.\n",
      "adt": {
        "mm::heap::slot::HeapSlot": "Constructor"
      }
    },
    "mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Pushes a slot to the front of the list.\n\n # Panics\n\n Panics if\n  - the slot does not come from a slab\n    (i.e., `!matches(slot.info(), SlotInfo::SlabSlot(_))`);\n  - the size of the slot does not match `SLOT_SIZE`.\n",
      "adt": {
        "mm::heap::slot_list::SlabSlotList": "MutableAsArgument",
        "mm::heap::slot::HeapSlot": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::frame::allocator::FrameAllocOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "mm::heap::slot_list::SlabSlotList": [
      "Plain",
      "MutRef"
    ],
    "mm::heap::slab::SlabMeta": [
      "Plain",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "mm::frame::linked_list::Link": [
      "Plain",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4945, kind: RigidTy(Adt(AdtDef(DefId { id: 3414, name: \"mm::frame::Frame\" }), GenericArgs([Type(Ty { id: 4959, kind: RigidTy(Adt(AdtDef(DefId { id: 5035, name: \"mm::frame::linked_list::Link\" }), GenericArgs([Type(Ty { id: 4919, kind: RigidTy(Adt(AdtDef(DefId { id: 5194, name: \"mm::heap::slab::SlabMeta\" }), GenericArgs([Const(TyConst { kind: Param(ParamConst { index: 0, name: \"SLOT_SIZE\" }), id: TyConstId(50, ThreadLocalIndex) })]))) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::frame::Frame": [
      "Plain"
    ],
    "mm::frame::unique::UniqueFrame": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::iter::StepBy": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::ptr::NonNull": [
      "Plain"
    ],
    "mm::heap::slot::SlotInfo": [
      "Plain"
    ],
    "mm::heap::slot::HeapSlot": [
      "Plain"
    ]
  },
  "path": 2029,
  "span": "ostd/src/mm/heap/slab.rs:88:5: 118:6",
  "src": "pub fn new() -> crate::prelude::Result<Self> {\n        const { assert!(SLOT_SIZE <= PAGE_SIZE) };\n        // To ensure we can store a pointer in each slot.\n        const { assert!(SLOT_SIZE >= size_of::<usize>()) };\n        // To ensure `nr_allocated` can be stored in a `u16`.\n        const { assert!(PAGE_SIZE / SLOT_SIZE <= u16::MAX as usize) };\n\n        let mut slab: Slab<SLOT_SIZE> = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_frame_with(Link::new(SlabMeta::<SLOT_SIZE> {\n                free_list: SlabSlotList::new(),\n                nr_allocated: 0,\n            }))?\n            .try_into()\n            .unwrap();\n\n        let head_paddr = slab.paddr();\n        let head_vaddr = paddr_to_vaddr(head_paddr);\n\n        // Push each slot to the free list.\n        for slot_offset in (0..PAGE_SIZE).step_by(SLOT_SIZE) {\n            // SAFETY: The slot is within the slab so it can't be NULL.\n            let slot_ptr = unsafe { NonNull::new_unchecked((head_vaddr + slot_offset) as *mut u8) };\n            // SAFETY: The slot is newly allocated in the slab.\n            slab.meta_mut()\n                .free_list\n                .push(unsafe { HeapSlot::new(slot_ptr, super::SlotInfo::SlabSlot(SLOT_SIZE)) });\n        }\n\n        Ok(slab)\n    }",
  "mir": "fn mm::heap::slab::<impl mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>::new() -> core::result::Result<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, error::Error> {\n    let mut _0: core::result::Result<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, error::Error>;\n    let mut _1: mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>;\n    let mut _2: core::result::Result<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>;\n    let mut _4: core::result::Result<mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, error::Error>;\n    let mut _5: &mm::frame::allocator::FrameAllocOptions;\n    let  _6: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _7: &mut mm::frame::allocator::FrameAllocOptions;\n    let mut _8: mm::frame::allocator::FrameAllocOptions;\n    let mut _9: mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>;\n    let mut _10: mm::heap::slab::SlabMeta<SLOT_SIZE>;\n    let mut _11: mm::heap::slot_list::SlabSlotList<SLOT_SIZE>;\n    let mut _12: isize;\n    let  _13: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _14: mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>;\n    let  _15: usize;\n    let mut _16: &mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>;\n    let  _17: usize;\n    let mut _18: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _19: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _20: core::ops::Range<usize>;\n    let mut _21: core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _22: core::option::Option<usize>;\n    let mut _23: &mut core::iter::StepBy<core::ops::Range<usize>>;\n    let mut _24: isize;\n    let  _25: usize;\n    let  _26: core::ptr::NonNull<u8>;\n    let mut _27: *mut u8;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let  _30: ();\n    let mut _31: &mut mm::heap::slot_list::SlabSlotList<SLOT_SIZE>;\n    let mut _32: &mut mm::heap::slab::SlabMeta<SLOT_SIZE>;\n    let mut _33: &mut mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>;\n    let mut _34: &mut mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>;\n    let mut _35: mm::heap::slot::HeapSlot;\n    let mut _36: mm::heap::slot::SlotInfo;\n    let mut _37: mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>;\n    debug slab => _1;\n    debug residual => _13;\n    debug val => _14;\n    debug head_paddr => _15;\n    debug head_vaddr => _17;\n    debug iter => _21;\n    debug slot_offset => _25;\n    debug slot_ptr => _26;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = mm::frame::allocator::FrameAllocOptions::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _7 = &mut _8;\n        _6 = mm::frame::allocator::FrameAllocOptions::zeroed(move _7, false) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = &(*_6);\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::new() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _10 = SlabMeta(move _11, 0_u16);\n        StorageDead(_11);\n        _9 = mm::frame::linked_list::Link::<mm::heap::slab::SlabMeta<SLOT_SIZE>>::new(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _4 = mm::frame::allocator::FrameAllocOptions::alloc_frame_with::<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>(move _5, move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_5);\n        _3 = <core::result::Result<mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, error::Error> as core::ops::Try>::branch(move _4) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        _12 = discriminant(_3);\n        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _14 = move ((_3 as variant#0).0: mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>);\n        _2 = <mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>> as core::convert::TryInto<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>>::try_into(_14) -> [return: bb11, unwind unreachable];\n    }\n    bb9: {\n        _13 = ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_2);\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageDead(_1);\n        goto -> bb27;\n    }\n    bb11: {\n        _1 = core::result::Result::<mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>, mm::frame::Frame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>::unwrap(move _2) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_2);\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageLive(_16);\n        _16 = &_1;\n        _15 = <mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>> as mm::mem_obj::HasPaddr>::paddr(move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        _17 = mm::kspace::paddr_to_vaddr(_15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = Range(0_usize, mm::PAGE_SIZE);\n        _19 = <core::ops::Range<usize> as core::iter::Iterator>::step_by(move _20, SLOT_SIZE) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_20);\n        _18 = <core::iter::StepBy<core::ops::Range<usize>> as core::iter::IntoIterator>::into_iter(move _19) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_19);\n        StorageLive(_21);\n        _21 = move _18;\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_22);\n        _23 = &mut _21;\n        _22 = <core::iter::StepBy<core::ops::Range<usize>> as core::iter::Iterator>::next(_23) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _24 = discriminant(_22);\n        switchInt(move _24) -> [0: bb20, 1: bb19, otherwise: bb7];\n    }\n    bb19: {\n        _25 = ((_22 as variant#1).0: usize);\n        StorageLive(_27);\n        StorageLive(_28);\n        _29 = CheckedAdd(_17, _25);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _17, _25) -> [success: bb21, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_18);\n        StorageLive(_37);\n        _37 = move _1;\n        _0 = core::result::Result::Ok(move _37);\n        StorageDead(_37);\n        StorageDead(_1);\n        goto -> bb27;\n    }\n    bb21: {\n        _28 = move (_29.0: usize);\n        _27 = move _28 as *mut u8;\n        StorageDead(_28);\n        _26 = core::ptr::NonNull::<u8>::new_unchecked(move _27) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_34);\n        _34 = &mut _1;\n        _33 = mm::frame::unique::UniqueFrame::<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>::meta_mut(move _34) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _32 = <mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>> as core::ops::DerefMut>::deref_mut(_33) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_34);\n        _31 = &mut ((*_32).0: mm::heap::slot_list::SlabSlotList<SLOT_SIZE>);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = mm::heap::slot::SlotInfo::SlabSlot(SLOT_SIZE);\n        _35 = mm::heap::slot::HeapSlot::new(_26, move _36) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        _30 = mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push(move _31, move _35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_35);\n        StorageDead(_31);\n        StorageDead(_32);\n        StorageDead(_22);\n        goto -> bb17;\n    }\n    bb27: {\n        return;\n    }\n}\n",
  "doc": " Allocates a new slab of the given size.\n\n If the size is less than `SLOT_SIZE` or [`PAGE_SIZE`], the size will be\n the maximum of the two.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}