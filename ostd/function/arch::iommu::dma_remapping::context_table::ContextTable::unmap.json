{
  "name": "arch::iommu::dma_remapping::context_table::ContextTable::unmap",
  "safe": true,
  "callees": {
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "arch::iommu::dma_remapping::context_table::ContextTable::get_or_create_page_table": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::iommu::dma_remapping::context_table::ContextTable": "MutableAsArgument"
      }
    },
    "task::preempt::guard::disable_preempt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disables preemption.\n",
      "adt": {
        "task::preempt::guard::DisabledPreemptGuard": "Constructor"
      }
    },
    "mm::page_table::PageTable::<C>::cursor_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new cursor exclusively accessing the virtual address range for mapping.\n\n If another cursor is already accessing the range, the new cursor may wait until the\n previous cursor is dropped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "mm::page_table::PageTable": "ImmutableAsArgument",
        "core::ops::Range": "ImmutableAsArgument",
        "mm::page_table::cursor::CursorMut": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "mm::page_table::cursor::CursorMut::<'rcu, C>::take_next": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds and removes the first page table fragment in the following range.\n\n The range to be found in is the current virtual address with the\n provided length.\n\n The function stops and yields the fragment if it has actually removed a\n fragment, no matter if the following pages are also required to be\n unmapped. The returned virtual address is the virtual page that existed\n before the removal but having just been unmapped.\n\n It also makes the cursor moves forward to the next page after the\n removed one, when an actual page is removed. If no mapped pages exist\n in the following range, the cursor will stop at the end of the range\n and return [`None`].\n\n The caller should handle TLB coherence if necessary, using the returned\n virtual address range.\n\n # Safety\n\n The caller should ensure that the range being unmapped does not affect\n kernel's memory safety.\n\n # Panics\n\n Panics if:\n  - the length is longer than the remaining range of the cursor;\n  - the length is not page-aligned.\n",
      "adt": {
        "mm::page_table::cursor::CursorMut": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "arch::iommu::dma_remapping::PciDeviceLocation": [
      "Unknown([Field(1, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Field(2, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "Ref",
      "Plain",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "arch::iommu::dma_remapping::context_table::ContextTableError": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "log::Level": [
      "Plain",
      "Ref"
    ],
    "log::LevelFilter": [
      "Ref",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "arch::iommu::dma_remapping::context_table::ContextTable": [
      "MutRef"
    ],
    "mm::page_table::PageTable": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "task::preempt::guard::DisabledPreemptGuard": [
      "Plain",
      "Ref"
    ],
    "core::ops::Range": [
      "Plain",
      "Ref"
    ],
    "mm::page_table::cursor::CursorMut": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": 473,
  "span": "ostd/src/arch/x86/iommu/dma_remapping/context_table.rs:323:5: 341:6",
  "src": "fn unmap(&mut self, device: PciDeviceLocation, daddr: Daddr) -> Result<(), ContextTableError> {\n        if device.device >= 32 || device.function >= 8 {\n            return Err(ContextTableError::InvalidDeviceId);\n        }\n\n        trace!(\"Unmapping Daddr: {:x?} for device: {:x?}\", daddr, device);\n\n        let pt = self.get_or_create_page_table(device);\n        let preempt_guard = disable_preempt();\n        let mut cursor = pt\n            .cursor_mut(&preempt_guard, &(daddr..daddr + PAGE_SIZE))\n            .unwrap();\n\n        // SAFETY: This unmaps a page from the context table, which is always safe.\n        let frag = unsafe { cursor.take_next(PAGE_SIZE) };\n        debug_assert!(frag.is_some());\n\n        Ok(())\n    }",
  "mir": "fn arch::iommu::dma_remapping::context_table::ContextTable::unmap(_1: &mut arch::iommu::dma_remapping::context_table::ContextTable, _2: arch::iommu::dma_remapping::PciDeviceLocation, _3: usize) -> core::result::Result<(), arch::iommu::dma_remapping::context_table::ContextTableError> {\n    let mut _0: core::result::Result<(), arch::iommu::dma_remapping::context_table::ContextTableError>;\n    let mut _4: bool;\n    let mut _5: u8;\n    let mut _6: bool;\n    let mut _7: u8;\n    let mut _8: arch::iommu::dma_remapping::context_table::ContextTableError;\n    let  _9: log::Level;\n    let mut _10: bool;\n    let mut _11: &log::Level;\n    let mut _12: &log::LevelFilter;\n    let mut _13: bool;\n    let mut _14: &log::Level;\n    let mut _15: &log::LevelFilter;\n    let  _16: log::LevelFilter;\n    let  _17: ();\n    let mut _18: core::fmt::Arguments<'_>;\n    let  _19: (&usize, &arch::iommu::dma_remapping::PciDeviceLocation);\n    let mut _20: &usize;\n    let mut _21: &arch::iommu::dma_remapping::PciDeviceLocation;\n    let  _22: [core::fmt::rt::Argument<'_>; 2];\n    let mut _23: core::fmt::rt::Argument<'_>;\n    let mut _24: core::fmt::rt::Argument<'_>;\n    let mut _25: &[u8; 43];\n    let  _26: &[core::fmt::rt::Argument<'_>; 2];\n    let  _27: &(&str, &str, &core::panic::Location<'_>);\n    let  _28: (&str, &str, &core::panic::Location<'_>);\n    let mut _29: &str;\n    let  _30: &core::panic::Location<'_>;\n    let  _31: &mut mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let  _32: task::preempt::guard::DisabledPreemptGuard;\n    let mut _33: mm::page_table::cursor::CursorMut<'_, arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _34: core::result::Result<mm::page_table::cursor::CursorMut<'_, arch::iommu::dma_remapping::second_stage::IommuPtConfig>, mm::page_table::PageTableError>;\n    let mut _35: &mm::page_table::PageTable<arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let  _36: &task::preempt::guard::DisabledPreemptGuard;\n    let  _37: &core::ops::Range<usize>;\n    let  _38: core::ops::Range<usize>;\n    let mut _39: usize;\n    let mut _40: (usize, bool);\n    let  _41: core::option::Option<mm::page_table::cursor::PageTableFrag<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let mut _42: &mut mm::page_table::cursor::CursorMut<'_, arch::iommu::dma_remapping::second_stage::IommuPtConfig>;\n    let mut _43: bool;\n    let mut _44: &core::option::Option<mm::page_table::cursor::PageTableFrag<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>;\n    let mut _45: !;\n    let mut _46: &usize;\n    let mut _47: &arch::iommu::dma_remapping::PciDeviceLocation;\n    debug self => _1;\n    debug device => _2;\n    debug daddr => _3;\n    debug lvl => _9;\n    debug args => _19;\n    debug args => _22;\n    debug pt => _31;\n    debug preempt_guard => task::preempt::guard::DisabledPreemptGuard {{ _private: () }};\n    debug cursor => _33;\n    debug frag => _41;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = (_2.1: u8);\n        _4 = Ge(move _5, 32_u8);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_5);\n        goto -> bb4;\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = (_2.2: u8);\n        _6 = Ge(move _7, 8_u8);\n        switchInt(move _6) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_7);\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = arch::iommu::dma_remapping::context_table::ContextTableError::InvalidDeviceId;\n        _0 = core::result::Result::Err(move _8);\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb31;\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_4);\n        _9 = log::Level::Trace;\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_9;\n        StorageLive(_12);\n        _12 = arch::iommu::dma_remapping::context_table::ContextTable::unmap::promoted[0];\n        _10 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _11, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _10) -> [0: bb17, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_9;\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = log::max_level() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = &_16;\n        _13 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _14, move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _13) -> [0: bb16, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_3;\n        StorageLive(_21);\n        _21 = &_2;\n        _19 = (move _20, move _21);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        _46 = (_19.0: &usize);\n        _23 = core::fmt::rt::Argument::<'_>::new_debug::<usize>(_46) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_24);\n        _47 = (_19.1: &arch::iommu::dma_remapping::PciDeviceLocation);\n        _24 = core::fmt::rt::Argument::<'_>::new_debug::<arch::iommu::dma_remapping::PciDeviceLocation>(_47) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _22 = [move _23, move _24];\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_25);\n        _25 = b\"\\x11Unmapping Daddr: \\xc1 \\x00\\x00b\\r for device: \\xc1 \\x00\\x00b\\x00\";\n        _26 = &_22;\n        _18 = core::fmt::Arguments::<'_>::new::<43, 2>(move _25, _26) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_25);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = \"ostd::arch::iommu::dma_remapping::context_table\";\n        _30 = log::__private_api::loc() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _28 = (move _29, \"ostd::arch::iommu::dma_remapping::context_table\", _30);\n        StorageDead(_29);\n        _27 = &_28;\n        _17 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _18, _9, _27, ()) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_18);\n        StorageDead(_28);\n        StorageDead(_22);\n        StorageDead(_19);\n        goto -> bb18;\n    }\n    bb16: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageDead(_13);\n        StorageDead(_10);\n        StorageLive(_31);\n        _31 = arch::iommu::dma_remapping::context_table::ContextTable::get_or_create_page_table(_1, _2) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _32 = task::preempt::guard::disable_preempt() -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &(*_31);\n        _36 = &_32;\n        StorageLive(_38);\n        StorageLive(_39);\n        _40 = CheckedAdd(_3, mm::PAGE_SIZE);\n        assert(!move (_40.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _3, mm::PAGE_SIZE) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _39 = move (_40.0: usize);\n        _38 = Range(_3, move _39);\n        StorageDead(_39);\n        _37 = &_38;\n        _34 = mm::page_table::PageTable::<arch::iommu::dma_remapping::second_stage::IommuPtConfig>::cursor_mut::<task::preempt::guard::DisabledPreemptGuard>(move _35, _36, _37) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_35);\n        _33 = core::result::Result::<mm::page_table::cursor::CursorMut<'_, arch::iommu::dma_remapping::second_stage::IommuPtConfig>, mm::page_table::PageTableError>::unwrap(move _34) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_34);\n        StorageDead(_38);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &mut _33;\n        _41 = mm::page_table::cursor::CursorMut::<'_, arch::iommu::dma_remapping::second_stage::IommuPtConfig>::take_next(move _42, mm::PAGE_SIZE) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &_41;\n        _43 = core::option::Option::<mm::page_table::cursor::PageTableFrag<arch::iommu::dma_remapping::second_stage::IommuPtConfig>>::is_some(move _44) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _43) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_44);\n        StorageDead(_43);\n        _0 = core::result::Result::Ok(());\n        drop(_41) -> [return: bb28, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_44);\n        _45 = core::panicking::panic(\"assertion failed: frag.is_some()\") -> unwind unreachable;\n    }\n    bb28: {\n        StorageDead(_41);\n        drop(_33) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_33);\n        drop(_32) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_31);\n        goto -> bb31;\n    }\n    bb31: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}