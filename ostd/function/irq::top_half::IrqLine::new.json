{
  "name": "irq::top_half::IrqLine::new",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "arch::irq::remapping::IrqRemapping::init": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Initializes the remapping entry for the specific IRQ number.\n\n This will do nothing if the entry is already initialized or interrupt\n remapping is disabled or not supported by the architecture.\n",
      "adt": {
        "arch::irq::remapping::IrqRemapping": "ImmutableAsArgument"
      }
    },
    "alloc::sync::Arc::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Arc<T>`.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n ```\n",
      "adt": {}
    },
    "alloc::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "irq::top_half::InnerHandle": [
      "Plain",
      "Ref"
    ],
    "irq::top_half::Inner": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "arch::irq::remapping::IrqRemapping": [
      "Ref"
    ],
    "alloc::sync::Arc": [
      "Plain"
    ],
    "alloc::vec::Vec": [
      "Plain"
    ],
    "irq::top_half::IrqLine": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::irq::top_half::IrqLine::new"
  },
  "span": "ostd/src/irq/top_half.rs:60:5: 68:6",
  "src": "fn new(index: u8) -> Self {\n        let inner = InnerHandle { index };\n        inner.remapping.init(index + IRQ_NUM_MIN);\n\n        Self {\n            inner: Arc::new(inner),\n            callbacks: Vec::new(),\n        }\n    }",
  "mir": "fn irq::top_half::IrqLine::new(_1: u8) -> irq::top_half::IrqLine {\n    let mut _0: irq::top_half::IrqLine;\n    let  _2: irq::top_half::InnerHandle;\n    let  _3: ();\n    let mut _4: &arch::irq::remapping::IrqRemapping;\n    let  _5: &irq::top_half::Inner;\n    let mut _6: &irq::top_half::InnerHandle;\n    let mut _7: u8;\n    let mut _8: (u8, bool);\n    let mut _9: alloc::sync::Arc<irq::top_half::InnerHandle>;\n    let mut _10: alloc::vec::Vec<irq::top_half::CallbackHandle>;\n    debug index => _1;\n    debug inner => _2;\n    bb0: {\n        _2 = InnerHandle(_1);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = <irq::top_half::InnerHandle as core::ops::Deref>::deref(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _4 = &((*_5).1: arch::irq::remapping::IrqRemapping);\n        StorageLive(_7);\n        _8 = CheckedAdd(_1, arch::irq::IRQ_NUM_MIN);\n        assert(!move (_8.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _1, arch::irq::IRQ_NUM_MIN) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _7 = move (_8.0: u8);\n        _3 = arch::irq::remapping::IrqRemapping::init(move _4, move _7) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageDead(_4);\n        StorageDead(_5);\n        StorageLive(_9);\n        _9 = alloc::sync::Arc::<irq::top_half::InnerHandle>::new(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_10);\n        _10 = alloc::vec::Vec::<irq::top_half::CallbackHandle>::new() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = IrqLine(move _9, move _10);\n        StorageDead(_10);\n        StorageDead(_9);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}