{
  "name": "cpu::local::get_ap",
  "safe": true,
  "callees": {
    "util::id_set::Id::as_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an [`usize`] from the [`Id`]'s corresponding [`u32`].\n",
      "adt": {}
    },
    "core::num::<impl usize>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value if the [`Once`] has been initialized.\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "cpu::id::CpuId": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "spin::once::Once": [
      "Ref"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 1706,
  "span": "ostd/src/cpu/local/mod.rs:262:1: 278:2",
  "src": "pub(crate) fn get_ap(cpu_id: CpuId) -> Paddr {\n    let offset = cpu_id\n        .as_usize()\n        .checked_sub(1)\n        .expect(\"The BSP does not have allocated CPU-local storage\");\n\n    let paddr = CPU_LOCAL_STORAGES\n        .get()\n        .expect(\"No CPU-local storage has been allocated\")[offset];\n    assert_ne!(\n        paddr,\n        0,\n        \"The CPU-local storage for CPU {} is not allocated\",\n        cpu_id.as_usize(),\n    );\n    paddr\n}",
  "mir": "fn cpu::local::get_ap(_1: cpu::id::CpuId) -> usize {\n    let mut _0: usize;\n    let  _2: usize;\n    let mut _3: core::option::Option<usize>;\n    let mut _4: usize;\n    let mut _5: &str;\n    let mut _6: &&[usize];\n    let mut _7: core::option::Option<&&[usize]>;\n    let mut _8: &spin::once::Once<&[usize]>;\n    let mut _9: &str;\n    let mut _10: *const [usize];\n    let mut _11: usize;\n    let mut _12: bool;\n    let mut _13: (&usize, &usize);\n    let mut _14: &usize;\n    let mut _15: &usize;\n    let  _16: &usize;\n    let  _17: &usize;\n    let mut _18: bool;\n    let mut _19: usize;\n    let mut _20: usize;\n    let  _21: core::panicking::AssertKind;\n    let  _22: !;\n    let mut _23: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _24: core::fmt::Arguments<'_>;\n    let  _25: (&usize,);\n    let mut _26: &usize;\n    let  _27: usize;\n    let  _28: [core::fmt::rt::Argument<'_>; 1];\n    let mut _29: core::fmt::rt::Argument<'_>;\n    let mut _30: &[u8; 51];\n    let  _31: &[core::fmt::rt::Argument<'_>; 1];\n    let mut _32: &[usize];\n    let mut _33: &[usize];\n    let mut _34: &usize;\n    debug cpu_id => _1;\n    debug offset => _2;\n    debug paddr => _0;\n    debug left_val => _16;\n    debug right_val => _17;\n    debug kind => _21;\n    debug args => _25;\n    debug args => _28;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <cpu::id::CpuId as util::id_set::Id>::as_usize(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = core::num::<impl usize>::checked_sub(move _4, 1_usize) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = \"The BSP does not have allocated CPU-local storage\";\n        _2 = core::option::Option::<usize>::expect(move _3, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = {alloc773: &spin::once::Once<&[usize]>};\n        _7 = spin::once::Once::<&[usize]>::get(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_9);\n        _9 = \"No CPU-local storage has been allocated\";\n        _6 = core::option::Option::<&&[usize]>::expect(move _7, move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_7);\n        _32 = (*_6);\n        _10 = &raw const (fake) (*_32);\n        _11 = PtrMetadata(move _10);\n        _12 = Lt(_2, _11);\n        assert(move _12, \"index out of bounds: the length is {} but the index is {}\", move _11, _2) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _33 = (*_6);\n        _0 = (*_33)[_2];\n        StorageDead(_6);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_0;\n        StorageLive(_15);\n        _15 = cpu::local::get_ap::promoted[0];\n        _13 = (move _14, move _15);\n        StorageDead(_15);\n        StorageDead(_14);\n        _16 = (_13.0: &usize);\n        _17 = (_13.1: &usize);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = (*_16);\n        StorageLive(_20);\n        _20 = (*_17);\n        _18 = Eq(move _19, move _20);\n        switchInt(move _18) -> [0: bb11, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_20);\n        StorageDead(_19);\n        _21 = core::panicking::AssertKind::Ne;\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = <cpu::id::CpuId as util::id_set::Id>::as_usize(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _26 = &_27;\n        _25 = (move _26);\n        StorageDead(_26);\n        StorageLive(_28);\n        StorageLive(_29);\n        _34 = (_25.0: &usize);\n        _29 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_34) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _28 = [move _29];\n        StorageDead(_29);\n        StorageLive(_30);\n        _30 = b\"\\x1eThe CPU-local storage for CPU \\xc0\\x11 is not allocated\\x00\";\n        _31 = &_28;\n        _24 = core::fmt::Arguments::<'_>::new::<51, 1>(move _30, _31) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_30);\n        _23 = core::option::Option::Some(move _24);\n        StorageDead(_24);\n        _22 = core::panicking::assert_failed::<usize, usize>(_21, _16, _17, move _23) -> unwind unreachable;\n    }\n    bb11: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " Gets the pointer to the static CPU-local storage for the given AP.\n\n # Panics\n\n This method will panic if the `cpu_id` does not represent an AP or the AP's CPU-local storage\n has not been allocated.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}