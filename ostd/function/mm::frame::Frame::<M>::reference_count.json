{
  "name": "mm::frame::Frame::<M>::reference_count",
  "safe": true,
  "callees": {
    "mm::frame::Frame::<M>::slot": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "mm::frame::Frame": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicU64::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    }
  },
  "adts": {
    "mm::frame::Frame": [
      "Ref"
    ],
    "mm::frame::meta::MetaSlot": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::sync::atomic::AtomicU64": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::frame::Frame::<M>::reference_count"
  },
  "span": "ostd/src/mm/frame/mod.rs:167:5: 171:6",
  "src": "pub fn reference_count(&self) -> u64 {\n        let refcnt = self.slot().ref_count.load(Ordering::Relaxed);\n        debug_assert!(refcnt < meta::REF_COUNT_MAX);\n        refcnt\n    }",
  "mir": "fn mm::frame::Frame::<M>::reference_count(_1: &mm::frame::Frame<M>) -> u64 {\n    let mut _0: u64;\n    let mut _2: &core::sync::atomic::AtomicU64;\n    let  _3: &mm::frame::meta::MetaSlot;\n    let mut _4: core::sync::atomic::Ordering;\n    let mut _5: bool;\n    let mut _6: !;\n    debug self => _1;\n    debug refcnt => _0;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = mm::frame::Frame::<M>::slot(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = &((*_3).1: core::sync::atomic::AtomicU64);\n        StorageLive(_4);\n        _4 = core::sync::atomic::Ordering::Relaxed;\n        _0 = core::sync::atomic::AtomicU64::load(move _2, move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_2);\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = Lt(_0, mm::frame::meta::REF_COUNT_MAX);\n        switchInt(move _5) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        return;\n    }\n    bb4: {\n        _6 = core::panicking::panic(\"assertion failed: refcnt < meta::REF_COUNT_MAX\") -> unwind unreachable;\n    }\n}\n",
  "doc": " Gets the reference count of the frame.\n\n It returns the number of all references to the frame, including all the\n existing frame handles ([`Frame`], [`Frame<dyn AnyFrameMeta>`]), and all\n the mappings in the page table that points to the frame.\n\n # Safety\n\n The function is safe to call, but using it requires extra care. The\n reference count can be changed by other threads at any time including\n potentially between calling this method and acting on the result.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}