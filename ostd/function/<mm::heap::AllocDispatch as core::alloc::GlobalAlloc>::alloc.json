{
  "name": "<mm::heap::AllocDispatch as core::alloc::GlobalAlloc>::alloc",
  "safe": false,
  "callees": {
    "mm::heap::slot_size_from_layout": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the size and type of heap slots to serve allocations of the layout.\n\n This function is defined by the OSTD user and should be idempotent, as we\n require it to be implemented as a `const fn`.\n\n See [`crate::global_heap_allocator_slot_map`].\n",
      "adt": {
        "core::option::Option": "Constructor",
        "mm::heap::slot::SlotInfo": "Constructor"
      }
    },
    "log::max_level": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current maximum log level.\n\n The [`log!`], [`error!`], [`warn!`], [`info!`], [`debug!`], and [`trace!`] macros check\n this value and discard any message logged at a higher level. The maximum\n log level is set by the [`set_max_level`] function.\n\n [`log!`]: macro.log.html\n [`error!`]: macro.error.html\n [`warn!`]: macro.warn.html\n [`info!`]: macro.info.html\n [`debug!`]: macro.debug.html\n [`trace!`]: macro.trace.html\n [`set_max_level`]: fn.set_max_level.html\n",
      "adt": {}
    },
    "core::cmp::PartialOrd::le": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than or equal to (for `self` and `other`) and is used by the\n `<=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 <= 1.0, true);\n assert_eq!(1.0 <= 2.0, true);\n assert_eq!(2.0 <= 1.0, false);\n ```\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::loc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "log::__private_api::log": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "panic::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Aborts the system.\n\n This function will first attempt to power off the system. If that fails, it will halt all CPUs.\n",
      "adt": {}
    },
    "mm::heap::get_global_heap_allocator": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the reference to the user-defined global heap allocator.\n",
      "adt": {}
    },
    "mm::heap::GlobalHeapAllocator::alloc": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a [`HeapSlot`] according to the layout.\n\n OSTD calls this method to allocate memory from the global heap.\n\n The returned [`HeapSlot`] must be valid for the layout, i.e., the size\n must be at least the size of the layout and the alignment must be at\n least the alignment of the layout. Furthermore, the size of the\n returned [`HeapSlot`] must match the size returned by the function\n marked with [`crate::global_heap_allocator_slot_map`].\n",
      "adt": {}
    },
    "core::ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "mm::heap::slot::SlotInfo::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the size of the slot.\n",
      "adt": {
        "mm::heap::slot::SlotInfo": "MutableAsArgument"
      }
    },
    "mm::heap::slot::HeapSlot::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the size of the slot.\n",
      "adt": {
        "mm::heap::slot::HeapSlot": "ImmutableAsArgument"
      }
    },
    "core::alloc::Layout::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum size in bytes for a memory block of this layout.\n",
      "adt": {}
    },
    "mm::heap::slot::HeapSlot::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the pointer to the slot.\n",
      "adt": {
        "mm::heap::slot::HeapSlot": "ImmutableAsArgument"
      }
    },
    "core::alloc::Layout::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum byte alignment for a memory block of this layout.\n\n The returned alignment is guaranteed to be a power of two.\n",
      "adt": {}
    },
    "core::num::<impl usize>::is_multiple_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n\n This function is equivalent to `self % rhs == 0`, except that it will not panic\n for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n `n.is_multiple_of(0) == false`.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_pointer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_lower_hex": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4963, kind: RigidTy(Adt(AdtDef(DefId { id: 5211, name: \"mm::heap::slot::SlotInfo\" }), GenericArgs([]))) })])"
    ],
    "log::Level": [
      "Ref",
      "Plain"
    ],
    "log::LevelFilter": [
      "Plain",
      "Ref"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "mm::heap::slot::SlotInfo": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 5030, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 461, kind: RigidTy(RawPtr(Ty { id: 1, kind: RigidTy(Uint(U8)) }, Mut)) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 517, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 11, kind: RigidTy(Uint(Usize)) }, Not)) })])",
      "Unknown([Field(2, Ty { id: 4326, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3518, kind: RigidTy(Adt(AdtDef(DefId { id: 4726, name: \"core::alloc::Layout\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Field(3, Ty { id: 4978, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 4963, kind: RigidTy(Adt(AdtDef(DefId { id: 5211, name: \"mm::heap::slot::SlotInfo\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4933, kind: RigidTy(Adt(AdtDef(DefId { id: 5205, name: \"mm::heap::slot::HeapSlot\" }), GenericArgs([]))) })])"
    ],
    "mm::heap::slot::HeapSlot": [
      "Plain",
      "Ref"
    ],
    "mm::heap::AllocDispatch": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::<mm::heap::AllocDispatch as core::alloc::GlobalAlloc>::alloc"
  },
  "span": "ostd/src/mm/heap/mod.rs:101:5: 125:6",
  "src": "unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n        let Some(required_slot) = slot_size_from_layout(layout) else {\n            abort_with_message!(\"Heap allocation size not found for layout = {:#x?}\", layout);\n        };\n\n        let res = get_global_heap_allocator().alloc(layout);\n        let Ok(slot) = res else {\n            return core::ptr::null_mut();\n        };\n\n        if required_slot.size() != slot.size()\n            || slot.size() < layout.size()\n            || !(slot.as_ptr() as Vaddr).is_multiple_of(layout.align())\n        {\n            abort_with_message!(\n                \"Heap allocation mismatch: slot ptr = {:p}, size = {:x}; layout = {:#x?}; required_slot = {:#x?}\",\n                slot.as_ptr(),\n                slot.size(),\n                layout,\n                required_slot,\n            );\n        }\n\n        slot.as_ptr()\n    }",
  "mir": "fn <mm::heap::AllocDispatch as core::alloc::GlobalAlloc>::alloc(_1: &mm::heap::AllocDispatch, _2: core::alloc::Layout) -> *mut u8 {\n    let mut _0: *mut u8;\n    let  _3: log::Level;\n    let mut _4: bool;\n    let mut _5: &log::Level;\n    let mut _6: &log::LevelFilter;\n    let mut _7: bool;\n    let mut _8: &log::Level;\n    let mut _9: &log::LevelFilter;\n    let  _10: log::LevelFilter;\n    let  _11: ();\n    let mut _12: core::fmt::Arguments<'_>;\n    let  _13: (&core::alloc::Layout,);\n    let mut _14: &core::alloc::Layout;\n    let  _15: [core::fmt::rt::Argument<'_>; 1];\n    let mut _16: core::fmt::rt::Argument<'_>;\n    let mut _17: &[u8; 51];\n    let  _18: &[core::fmt::rt::Argument<'_>; 1];\n    let  _19: &(&str, &str, &core::panic::Location<'_>);\n    let  _20: (&str, &str, &core::panic::Location<'_>);\n    let mut _21: &str;\n    let  _22: &core::panic::Location<'_>;\n    let  _23: !;\n    let  _24: mm::heap::slot::SlotInfo;\n    let mut _25: core::option::Option<mm::heap::slot::SlotInfo>;\n    let mut _26: isize;\n    let  _27: core::result::Result<mm::heap::slot::HeapSlot, core::alloc::AllocError>;\n    let  _28: &dyn mm::heap::GlobalHeapAllocator;\n    let  _29: mm::heap::slot::HeapSlot;\n    let mut _30: isize;\n    let mut _31: bool;\n    let mut _32: usize;\n    let mut _33: &mm::heap::slot::SlotInfo;\n    let mut _34: usize;\n    let mut _35: &mm::heap::slot::HeapSlot;\n    let mut _36: bool;\n    let mut _37: usize;\n    let mut _38: &mm::heap::slot::HeapSlot;\n    let mut _39: usize;\n    let mut _40: &core::alloc::Layout;\n    let mut _41: bool;\n    let mut _42: usize;\n    let mut _43: *mut u8;\n    let mut _44: &mm::heap::slot::HeapSlot;\n    let mut _45: usize;\n    let mut _46: &core::alloc::Layout;\n    let  _47: log::Level;\n    let mut _48: bool;\n    let mut _49: &log::Level;\n    let mut _50: &log::LevelFilter;\n    let mut _51: bool;\n    let mut _52: &log::Level;\n    let mut _53: &log::LevelFilter;\n    let  _54: log::LevelFilter;\n    let  _55: ();\n    let mut _56: core::fmt::Arguments<'_>;\n    let  _57: (&*mut u8, &usize, &core::alloc::Layout, &mm::heap::slot::SlotInfo);\n    let mut _58: &*mut u8;\n    let  _59: *mut u8;\n    let mut _60: &mm::heap::slot::HeapSlot;\n    let mut _61: &usize;\n    let  _62: usize;\n    let mut _63: &mm::heap::slot::HeapSlot;\n    let mut _64: &core::alloc::Layout;\n    let mut _65: &mm::heap::slot::SlotInfo;\n    let  _66: [core::fmt::rt::Argument<'_>; 4];\n    let mut _67: core::fmt::rt::Argument<'_>;\n    let mut _68: core::fmt::rt::Argument<'_>;\n    let mut _69: core::fmt::rt::Argument<'_>;\n    let mut _70: core::fmt::rt::Argument<'_>;\n    let mut _71: &[u8; 92];\n    let  _72: &[core::fmt::rt::Argument<'_>; 4];\n    let  _73: &(&str, &str, &core::panic::Location<'_>);\n    let  _74: (&str, &str, &core::panic::Location<'_>);\n    let mut _75: &str;\n    let  _76: &core::panic::Location<'_>;\n    let  _77: !;\n    let mut _78: &mm::heap::slot::HeapSlot;\n    let mut _79: &core::alloc::Layout;\n    let mut _80: &*mut u8;\n    let mut _81: &usize;\n    let mut _82: &core::alloc::Layout;\n    let mut _83: &mm::heap::slot::SlotInfo;\n    debug self => _1;\n    debug layout => _2;\n    debug lvl => _3;\n    debug args => _13;\n    debug args => _15;\n    debug required_slot => _24;\n    debug res => _27;\n    debug slot => _29;\n    debug lvl => _47;\n    debug args => _57;\n    debug args => _66;\n    bb0: {\n        StorageLive(_25);\n        _25 = mm::heap::slot_size_from_layout(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _4) -> [0: bb11, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_3;\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = log::max_level() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _9 = &_10;\n        _7 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _8, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _7) -> [0: bb10, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_2;\n        _13 = (move _14);\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _79 = (_13.0: &core::alloc::Layout);\n        _16 = core::fmt::rt::Argument::<'_>::new_debug::<core::alloc::Layout>(_79) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _15 = [move _16];\n        StorageDead(_16);\n        StorageLive(_17);\n        _17 = b\",Heap allocation size not found for layout = \\xc1 \\x00\\x80b\\x00\";\n        _18 = &_15;\n        _12 = core::fmt::Arguments::<'_>::new::<51, 1>(move _17, _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_17);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = \"ostd::mm::heap\";\n        _22 = log::__private_api::loc() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _20 = (move _21, \"ostd::mm::heap\", _22);\n        StorageDead(_21);\n        _19 = &_20;\n        _11 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _12, _3, _19, ()) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_20);\n        StorageDead(_15);\n        StorageDead(_13);\n        goto -> bb12;\n    }\n    bb10: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_7);\n        StorageDead(_4);\n        _23 = panic::abort() -> unwind unreachable;\n    }\n    bb13: {\n        _26 = discriminant(_25);\n        switchInt(move _26) -> [1: bb14, 0: bb15, otherwise: bb54];\n    }\n    bb14: {\n        StorageLive(_24);\n        _24 = ((_25 as variant#1).0: mm::heap::slot::SlotInfo);\n        StorageDead(_25);\n        StorageLive(_27);\n        _28 = mm::heap::get_global_heap_allocator() -> [return: bb16, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        _3 = log::Level::Error;\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_3;\n        StorageLive(_6);\n        _6 = <mm::heap::AllocDispatch as core::alloc::GlobalAlloc>::alloc::promoted[0];\n        _4 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _5, move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb16: {\n        _27 = <dyn mm::heap::GlobalHeapAllocator as mm::heap::GlobalHeapAllocator>::alloc(_28, _2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _30 = discriminant(_27);\n        switchInt(move _30) -> [0: bb19, 1: bb18, otherwise: bb54];\n    }\n    bb18: {\n        _0 = core::ptr::null_mut::<u8>() -> [return: bb52, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_29);\n        _29 = move ((_27 as variant#0).0: mm::heap::slot::HeapSlot);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_24;\n        _32 = mm::heap::slot::SlotInfo::size(move _33) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_29;\n        _34 = mm::heap::slot::HeapSlot::size(move _35) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_35);\n        _31 = Ne(move _32, move _34);\n        switchInt(move _31) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_34);\n        StorageDead(_32);\n        goto -> bb33;\n    }\n    bb23: {\n        StorageDead(_34);\n        StorageDead(_32);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &_29;\n        _37 = mm::heap::slot::HeapSlot::size(move _38) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_2;\n        _39 = core::alloc::Layout::size(move _40) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_40);\n        _36 = Lt(move _37, move _39);\n        switchInt(move _36) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_39);\n        StorageDead(_37);\n        goto -> bb33;\n    }\n    bb27: {\n        StorageDead(_39);\n        StorageDead(_37);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &_29;\n        _43 = mm::heap::slot::HeapSlot::as_ptr(move _44) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_44);\n        _42 = move _43 as usize;\n        StorageDead(_43);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &_2;\n        _45 = core::alloc::Layout::align(move _46) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_46);\n        _41 = core::num::<impl usize>::is_multiple_of(move _42, move _45) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        switchInt(move _41) -> [0: bb32, otherwise: bb31];\n    }\n    bb31: {\n        StorageDead(_45);\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageDead(_36);\n        StorageDead(_31);\n        StorageLive(_78);\n        _78 = &_29;\n        _0 = mm::heap::slot::HeapSlot::as_ptr(move _78) -> [return: bb51, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_45);\n        StorageDead(_42);\n        goto -> bb33;\n    }\n    bb33: {\n        _47 = log::Level::Error;\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &_47;\n        StorageLive(_50);\n        _50 = <mm::heap::AllocDispatch as core::alloc::GlobalAlloc>::alloc::promoted[1];\n        _48 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _49, move _50) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        switchInt(move _48) -> [0: bb49, otherwise: bb35];\n    }\n    bb35: {\n        StorageDead(_50);\n        StorageDead(_49);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &_47;\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = log::max_level() -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _53 = &_54;\n        _51 = <log::Level as core::cmp::PartialOrd<log::LevelFilter>>::le(move _52, move _53) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        switchInt(move _51) -> [0: bb48, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageDead(_52);\n        StorageLive(_56);\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = &_29;\n        _59 = mm::heap::slot::HeapSlot::as_ptr(move _60) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_60);\n        _58 = &_59;\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = &_29;\n        _62 = mm::heap::slot::HeapSlot::size(move _63) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_63);\n        _61 = &_62;\n        StorageLive(_64);\n        _64 = &_2;\n        StorageLive(_65);\n        _65 = &_24;\n        _57 = (move _58, move _61, move _64, move _65);\n        StorageDead(_65);\n        StorageDead(_64);\n        StorageDead(_61);\n        StorageDead(_58);\n        StorageLive(_66);\n        StorageLive(_67);\n        _80 = (_57.0: &*mut u8);\n        _67 = core::fmt::rt::Argument::<'_>::new_pointer::<*mut u8>(_80) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageLive(_68);\n        _81 = (_57.1: &usize);\n        _68 = core::fmt::rt::Argument::<'_>::new_lower_hex::<usize>(_81) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageLive(_69);\n        _82 = (_57.2: &core::alloc::Layout);\n        _69 = core::fmt::rt::Argument::<'_>::new_debug::<core::alloc::Layout>(_82) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageLive(_70);\n        _83 = (_57.3: &mm::heap::slot::SlotInfo);\n        _70 = core::fmt::rt::Argument::<'_>::new_debug::<mm::heap::slot::SlotInfo>(_83) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _66 = [move _67, move _68, move _69, move _70];\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_67);\n        StorageLive(_71);\n        _71 = b\"%Heap allocation mismatch: slot ptr = \\xc0\\t, size = \\xc0\\x0b; layout = \\xc1 \\x00\\x80b\\x12; required_slot = \\xc1 \\x00\\x80b\\x00\";\n        _72 = &_66;\n        _56 = core::fmt::Arguments::<'_>::new::<92, 4>(move _71, _72) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_71);\n        StorageLive(_74);\n        StorageLive(_75);\n        _75 = \"ostd::mm::heap\";\n        _76 = log::__private_api::loc() -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _74 = (move _75, \"ostd::mm::heap\", _76);\n        StorageDead(_75);\n        _73 = &_74;\n        _55 = log::__private_api::log::<'_, (), log::__private_api::GlobalLogger>(log::__private_api::GlobalLogger, move _56, _47, _73, ()) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_56);\n        StorageDead(_74);\n        StorageDead(_66);\n        StorageDead(_62);\n        StorageDead(_59);\n        StorageDead(_57);\n        goto -> bb50;\n    }\n    bb48: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageDead(_52);\n        goto -> bb50;\n    }\n    bb49: {\n        StorageDead(_50);\n        StorageDead(_49);\n        goto -> bb50;\n    }\n    bb50: {\n        StorageDead(_51);\n        StorageDead(_48);\n        _77 = panic::abort() -> unwind unreachable;\n    }\n    bb51: {\n        StorageDead(_78);\n        StorageDead(_29);\n        StorageDead(_27);\n        StorageDead(_24);\n        goto -> bb53;\n    }\n    bb52: {\n        StorageDead(_27);\n        StorageDead(_24);\n        goto -> bb53;\n    }\n    bb53: {\n        return;\n    }\n    bb54: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}