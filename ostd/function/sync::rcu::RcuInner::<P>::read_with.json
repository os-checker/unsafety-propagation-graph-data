{
  "name": "sync::rcu::RcuInner::<P>::read_with",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicPtr::<T>::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the pointer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let ptr = &mut 5;\n let some_ptr = AtomicPtr::new(ptr);\n\n let value = some_ptr.load(Ordering::Relaxed);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::ptr::NonNull::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `NonNull` if `ptr` is non-null.\n\n # Panics during const evaluation\n\n This method will panic during const evaluation if the pointer cannot be\n determined to be null or not. See [`is_null`] for more information.\n\n [`is_null`]: ../primitive.pointer.html#method.is_null-1\n\n # Examples\n\n ```\n use std::ptr::NonNull;\n\n let mut x = 0u32;\n let ptr = NonNull::<u32>::new(&mut x as *mut _).expect(\"ptr is null!\");\n\n if let Some(ptr) = NonNull::<u32>::new(std::ptr::null_mut()) {\n     unreachable!();\n }\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicPtr": [
      "Ref"
    ],
    "sync::rcu::RcuInner": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2629,
  "span": "ostd/src/sync/rcu/mod.rs:175:5: 186:6",
  "src": "fn read_with<'a>(&'a self, _guard: &'a dyn InAtomicMode) -> Option<P::Ref<'a>> {\n        let obj_ptr = self.ptr.load(Acquire);\n        if obj_ptr.is_null() {\n            return None;\n        }\n        // SAFETY:\n        // 1. This pointer is not NULL.\n        // 2. The `_guard` guarantees atomic mode for the duration of lifetime\n        //    `'a`, the pointer is valid because other writers won't release the\n        //    allocation until this task passes the quiescent state.\n        NonNull::new(obj_ptr).map(|ptr| unsafe { P::raw_as_ref(ptr) })\n    }",
  "mir": "fn sync::rcu::RcuInner::<P>::read_with(_1: &sync::rcu::RcuInner<P>, _2: &dyn task::atomic_mode::InAtomicMode) -> core::option::Option<<P as sync::rcu::non_null::NonNullPtr>::Ref<'_>> {\n    let mut _0: core::option::Option<<P as sync::rcu::non_null::NonNullPtr>::Ref<'_>>;\n    let  _3: *mut <P as sync::rcu::non_null::NonNullPtr>::Target;\n    let mut _4: &core::sync::atomic::AtomicPtr<<P as sync::rcu::non_null::NonNullPtr>::Target>;\n    let mut _5: core::sync::atomic::Ordering;\n    let mut _6: bool;\n    let mut _7: core::option::Option<core::ptr::NonNull<<P as sync::rcu::non_null::NonNullPtr>::Target>>;\n    debug self => _1;\n    debug _guard => _2;\n    debug obj_ptr => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = &((*_1).0: core::sync::atomic::AtomicPtr<<P as sync::rcu::non_null::NonNullPtr>::Target>);\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Acquire;\n        _3 = core::sync::atomic::AtomicPtr::<<P as sync::rcu::non_null::NonNullPtr>::Target>::load(move _4, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = core::ptr::mut_ptr::<impl *mut <P as sync::rcu::non_null::NonNullPtr>::Target>::is_null(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _6) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _0 = core::option::Option::None;\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = core::ptr::NonNull::<<P as sync::rcu::non_null::NonNullPtr>::Target>::new(_3) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = core::option::Option::<core::ptr::NonNull<<P as sync::rcu::non_null::NonNullPtr>::Target>>::map::<<P as sync::rcu::non_null::NonNullPtr>::Ref<'_>, {closure@ostd/src/sync/rcu/mod.rs:185:35: 185:40}>(move _7, ZeroSized: {closure@ostd/src/sync/rcu/mod.rs:185:35: 185:40}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}