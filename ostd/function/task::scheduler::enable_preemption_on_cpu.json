{
  "name": "task::scheduler::enable_preemption_on_cpu",
  "safe": true,
  "callees": {
    "timer::register_callback_on_cpu": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Registers a function that will be executed during the timer interrupt on the current CPU.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "ostd::task::scheduler::enable_preemption_on_cpu"
  },
  "span": "ostd/src/task/scheduler/mod.rs:100:1: 109:2",
  "src": "pub fn enable_preemption_on_cpu() {\n    timer::register_callback_on_cpu(|| {\n        SCHEDULER.get().unwrap().mut_local_rq_with(&mut |local_rq| {\n            let should_pick_next = local_rq.update_current(UpdateFlags::Tick);\n            if should_pick_next {\n                cpu_local::set_need_preempt();\n            }\n        })\n    });\n}",
  "mir": "fn task::scheduler::enable_preemption_on_cpu() -> () {\n    let mut _0: ();\n    let  _1: ();\n    bb0: {\n        _1 = timer::register_callback_on_cpu::<{closure@ostd/src/task/scheduler/mod.rs:101:37: 101:39}>(ZeroSized: {closure@ostd/src/task/scheduler/mod.rs:101:37: 101:39}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Enables preemptive scheduling on the current CPU.\n\n After calling this function on a CPU,\n a task that is executing in the user mode may get preempted\n if another runnable task on the same CPU is deemed more urgent by the scheduler.\n\n OSTD achieves task preemption by registering a per-CPU timer callback\n to invoke the scheduler periodically.\n Thus, this function should be called _once_ on every CPU\n by an OSTD-based kernel during its initialization phase,\n after it has injected its scheduler via [`inject_scheduler`].\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}