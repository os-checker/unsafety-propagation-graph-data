{
  "name": "mm::vm_space::CursorMut::<'a>::unmap",
  "safe": true,
  "callees": {
    "mm::vm_space::CursorMut::<'a>::virt_addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Get the virtual address of the current slot.\n",
      "adt": {
        "mm::vm_space::CursorMut": "ImmutableAsArgument"
      }
    },
    "mm::page_table::cursor::CursorMut::<'rcu, C>::take_next": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Finds and removes the first page table fragment in the following range.\n\n The range to be found in is the current virtual address with the\n provided length.\n\n The function stops and yields the fragment if it has actually removed a\n fragment, no matter if the following pages are also required to be\n unmapped. The returned virtual address is the virtual page that existed\n before the removal but having just been unmapped.\n\n It also makes the cursor moves forward to the next page after the\n removed one, when an actual page is removed. If no mapped pages exist\n in the following range, the cursor will stop at the end of the range\n and return [`None`].\n\n The caller should handle TLB coherence if necessary, using the returned\n virtual address range.\n\n # Safety\n\n The caller should ensure that the range being unmapped does not affect\n kernel's memory safety.\n\n # Panics\n\n Panics if:\n  - the length is longer than the remaining range of the cursor;\n  - the length is not page-aligned.\n",
      "adt": {
        "mm::page_table::cursor::CursorMut": "MutableAsArgument",
        "core::option::Option": "Constructor",
        "mm::page_table::cursor::PageTableFrag": "Constructor"
      }
    },
    "mm::tlb::TlbFlushOp::for_single": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new TLB flush operation that flushes the TLB entry associated\n with the provided virtual address.\n",
      "adt": {
        "mm::tlb::TlbFlushOp": "Constructor"
      }
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "mm::tlb::TlbFlusher::<'a, G>::issue_tlb_flush_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Issues a TLB flush request that must happen before dropping the page.\n\n If we need to remove a mapped page from the page table, we can only\n recycle the page after all the relevant TLB entries in all CPUs are\n flushed. Otherwise if the page is recycled for other purposes, the user\n space program can still access the page through the TLB entries. This\n method is designed to be used in such cases.\n",
      "adt": {
        "mm::tlb::TlbFlusher": "MutableAsArgument"
      }
    },
    "mm::tlb::TlbFlusher::<'a, G>::issue_tlb_flush": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Issues a pending TLB flush request.\n\n This function does not guarantee to flush the TLB entries on either\n this CPU or remote CPUs. The flush requests are only performed when\n [`Self::dispatch_tlb_flush`] is called.\n",
      "adt": {
        "mm::tlb::TlbFlusher": "MutableAsArgument"
      }
    },
    "mm::tlb::TlbFlushOp::for_range": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new TLB flush operation that flushes the TLB entries for the\n specified virtual address range.\n\n If the range is too large, the resulting [`TlbFlushOp`] will flush all\n TLB entries instead.\n\n # Panics\n\n Panics if the range is not page-aligned or if the range is empty.\n",
      "adt": {
        "mm::tlb::TlbFlushOp": "Constructor"
      }
    },
    "mm::tlb::TlbFlusher::<'a, G>::dispatch_tlb_flush": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dispatches all the pending TLB flush requests.\n\n All previous pending requests issued by [`Self::issue_tlb_flush`] or\n [`Self::issue_tlb_flush_with`] starts to be processed after this\n function. But it may not be synchronous. Upon the return of this\n function, the TLB entries may not be coherent.\n",
      "adt": {
        "mm::tlb::TlbFlusher": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "mm::vm_space::CursorMut": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "mm::page_table::cursor::CursorMut": [
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6317, kind: RigidTy(Adt(AdtDef(DefId { id: 5332, name: \"mm::page_table::cursor::PageTableFrag\" }), GenericArgs([Type(Ty { id: 5959, kind: RigidTy(Adt(AdtDef(DefId { id: 5504, name: \"mm::vm_space::UserPtConfig\" }), GenericArgs([]))) })]))) })])"
    ],
    "mm::page_table::cursor::PageTableFrag": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4757, kind: RigidTy(Adt(AdtDef(DefId { id: 3414, name: \"mm::frame::Frame\" }), GenericArgs([Type(Ty { id: 4180, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 5105, name: \"mm::frame::meta::AnyFrameMeta\" }), generic_args: GenericArgs([]) }), bound_vars: [] }], Region { kind: ReErased })) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(1, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(2, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(3, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(1, Ty { id: 6277, kind: RigidTy(Adt(AdtDef(DefId { id: 5587, name: \"mm::vm_space::VmItem\" }), GenericArgs([]))) })])"
    ],
    "mm::frame::Frame": [
      "Plain"
    ],
    "mm::vm_space::VmItem": [
      "Plain",
      "Unknown([Field(1, Ty { id: 6338, kind: RigidTy(Adt(AdtDef(DefId { id: 5605, name: \"mm::vm_space::MappedItem\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 6338, kind: RigidTy(Adt(AdtDef(DefId { id: 5605, name: \"mm::vm_space::MappedItem\" }), GenericArgs([]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4909, kind: RigidTy(Adt(AdtDef(DefId { id: 3414, name: \"mm::frame::Frame\" }), GenericArgs([Type(Ty { id: 4095, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 4951, name: \"mm::frame::untyped::AnyUFrameMeta\" }), generic_args: GenericArgs([]) }), bound_vars: [] }], Region { kind: ReErased })) })]))) })])"
    ],
    "mm::tlb::TlbFlusher": [
      "MutRef"
    ],
    "mm::tlb::TlbFlushOp": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::mm::vm_space::CursorMut::<'a>::unmap"
  },
  "span": "ostd/src/mm/vm_space.rs:506:5: 556:6",
  "src": "pub fn unmap(&mut self, len: usize) -> usize {\n        let end_va = self.virt_addr() + len;\n        let mut num_unmapped: usize = 0;\n        loop {\n            // SAFETY: It is safe to un-map memory in the userspace.\n            let Some(frag) = (unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) })\n            else {\n                break; // No more mappings in the range.\n            };\n\n            match frag {\n                PageTableFrag::Mapped { va, item, .. } => {\n                    match item {\n                        VmItem {\n                            mapped_item: MappedItem::TrackedFrame(old_frame),\n                            ..\n                        } => {\n                            num_unmapped += 1;\n                            self.flusher\n                                .issue_tlb_flush_with(TlbFlushOp::for_single(va), old_frame.into());\n                        }\n                        VmItem {\n                            mapped_item: MappedItem::UntrackedIoMem { .. },\n                            ..\n                        } => {\n                            // Flush the TLB entry for the current address, but\n                            // in the current design, we cannot drop the\n                            // corresponding `IoMem`. This is because we manage\n                            // the range of I/O as a whole, but the frames\n                            // handled here might be one segment of it.\n                            self.flusher.issue_tlb_flush(TlbFlushOp::for_single(va));\n                        }\n                    }\n                }\n                PageTableFrag::StrayPageTable {\n                    pt,\n                    va,\n                    len,\n                    num_frames,\n                } => {\n                    num_unmapped += num_frames;\n                    self.flusher\n                        .issue_tlb_flush_with(TlbFlushOp::for_range(va..va + len), pt);\n                }\n            }\n        }\n\n        self.flusher.dispatch_tlb_flush();\n\n        num_unmapped\n    }",
  "mir": "fn mm::vm_space::CursorMut::<'a>::unmap(_1: &mut mm::vm_space::CursorMut<'_>, _2: usize) -> usize {\n    let mut _0: usize;\n    let  _3: usize;\n    let mut _4: usize;\n    let mut _5: &mm::vm_space::CursorMut<'_>;\n    let mut _6: (usize, bool);\n    let mut _7: usize;\n    let  _8: mm::page_table::cursor::PageTableFrag<mm::vm_space::UserPtConfig>;\n    let mut _9: core::option::Option<mm::page_table::cursor::PageTableFrag<mm::vm_space::UserPtConfig>>;\n    let mut _10: &mut mm::page_table::cursor::CursorMut<'_, mm::vm_space::UserPtConfig>;\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: &mm::vm_space::CursorMut<'_>;\n    let mut _14: (usize, bool);\n    let mut _15: isize;\n    let mut _16: isize;\n    let  _17: usize;\n    let  _18: mm::vm_space::VmItem;\n    let mut _19: isize;\n    let  _20: mm::frame::Frame<dyn mm::frame::untyped::AnyUFrameMeta>;\n    let mut _21: (usize, bool);\n    let  _22: ();\n    let mut _23: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    let mut _24: mm::tlb::TlbFlushOp;\n    let mut _25: mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>;\n    let  _26: ();\n    let mut _27: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    let mut _28: mm::tlb::TlbFlushOp;\n    let  _29: mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>;\n    let  _30: usize;\n    let  _31: usize;\n    let  _32: usize;\n    let mut _33: (usize, bool);\n    let  _34: ();\n    let mut _35: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    let mut _36: mm::tlb::TlbFlushOp;\n    let mut _37: core::ops::Range<usize>;\n    let mut _38: usize;\n    let mut _39: (usize, bool);\n    let  _40: ();\n    let mut _41: &mut mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>;\n    debug self => _1;\n    debug len => _2;\n    debug end_va => _3;\n    debug num_unmapped => _7;\n    debug frag => _8;\n    debug va => _17;\n    debug item => _18;\n    debug old_frame => _20;\n    debug pt => _29;\n    debug va => _30;\n    debug len => _31;\n    debug num_frames => _32;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = mm::vm_space::CursorMut::<'_>::virt_addr(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = CheckedAdd(_4, _2);\n        assert(!move (_6.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _4, _2) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = move (_6.0: usize);\n        StorageDead(_4);\n        StorageLive(_7);\n        _7 = 0_usize;\n        goto -> bb3;\n    }\n    bb3: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut ((*_1).0: mm::page_table::cursor::CursorMut<'_, mm::vm_space::UserPtConfig>);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &(*_1);\n        _12 = mm::vm_space::CursorMut::<'_>::virt_addr(move _13) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_13);\n        _14 = CheckedSub(_3, _12);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _12) -> [success: bb5, unwind unreachable];\n    }\n    bb5: {\n        _11 = move (_14.0: usize);\n        StorageDead(_12);\n        _9 = mm::page_table::cursor::CursorMut::<'_, mm::vm_space::UserPtConfig>::take_next(move _10, move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _15 = discriminant(_9);\n        switchInt(move _15) -> [1: bb7, 0: bb24, otherwise: bb8];\n    }\n    bb7: {\n        StorageLive(_8);\n        _8 = move ((_9 as variant#1).0: mm::page_table::cursor::PageTableFrag<mm::vm_space::UserPtConfig>);\n        StorageDead(_9);\n        _16 = discriminant(_8);\n        switchInt(move _16) -> [0: bb10, 1: bb9, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _29 = move ((_8 as variant#1).0: mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>);\n        _30 = ((_8 as variant#1).1: usize);\n        _31 = ((_8 as variant#1).2: usize);\n        _32 = ((_8 as variant#1).3: usize);\n        _33 = CheckedAdd(_7, _32);\n        assert(!move (_33.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _7, _32) -> [success: bb19, unwind unreachable];\n    }\n    bb10: {\n        _17 = ((_8 as variant#0).0: usize);\n        StorageLive(_18);\n        _18 = move ((_8 as variant#0).1: mm::vm_space::VmItem);\n        _19 = discriminant((_18.1: mm::vm_space::MappedItem));\n        switchInt(move _19) -> [0: bb12, 1: bb11, otherwise: bb8];\n    }\n    bb11: {\n        StorageLive(_27);\n        _27 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        StorageLive(_28);\n        _28 = mm::tlb::TlbFlushOp::for_single(_17) -> [return: bb17, unwind unreachable];\n    }\n    bb12: {\n        _20 = move (((_18.1: mm::vm_space::MappedItem) as variant#0).0: mm::frame::Frame<dyn mm::frame::untyped::AnyUFrameMeta>);\n        _21 = CheckedAdd(_7, 1_usize);\n        assert(!move (_21.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _7, 1_usize) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _7 = move (_21.0: usize);\n        StorageLive(_23);\n        _23 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        StorageLive(_24);\n        _24 = mm::tlb::TlbFlushOp::for_single(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_25);\n        _25 = <mm::frame::Frame<dyn mm::frame::untyped::AnyUFrameMeta> as core::convert::Into<mm::frame::Frame<dyn mm::frame::meta::AnyFrameMeta>>>::into(_20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _22 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::issue_tlb_flush_with(move _23, move _24, move _25) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        goto -> bb25;\n    }\n    bb17: {\n        _26 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::issue_tlb_flush(move _27, move _28) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_28);\n        StorageDead(_27);\n        goto -> bb25;\n    }\n    bb19: {\n        _7 = move (_33.0: usize);\n        StorageLive(_35);\n        _35 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _39 = CheckedAdd(_30, _31);\n        assert(!move (_39.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _30, _31) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _38 = move (_39.0: usize);\n        _37 = Range(_30, move _38);\n        StorageDead(_38);\n        _36 = mm::tlb::TlbFlushOp::for_range(move _37) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_37);\n        _34 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::issue_tlb_flush_with(move _35, move _36, _29) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_36);\n        StorageDead(_35);\n        goto -> bb26;\n    }\n    bb23: {\n        StorageDead(_41);\n        _0 = _7;\n        StorageDead(_7);\n        return;\n    }\n    bb24: {\n        StorageDead(_9);\n        StorageLive(_41);\n        _41 = &mut ((*_1).1: mm::tlb::TlbFlusher<'_, task::preempt::guard::DisabledPreemptGuard>);\n        _40 = mm::tlb::TlbFlusher::<'_, task::preempt::guard::DisabledPreemptGuard>::dispatch_tlb_flush(move _41) -> [return: bb23, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_18);\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_8);\n        goto -> bb3;\n    }\n}\n",
  "doc": " Clears the mapping starting from the current slot,\n and returns the number of unmapped pages.\n\n This method will bring the cursor forward by `len` bytes in the virtual\n address space after the modification.\n\n Already-absent mappings encountered by the cursor will be skipped. It\n is valid to unmap a range that is not mapped.\n\n It must issue and dispatch a TLB flush after the operation. Otherwise,\n the memory safety will be compromised. Please call this function less\n to avoid the overhead of TLB flush. Using a large `len` is wiser than\n splitting the operation into multiple small ones.\n\n # Panics\n Panics if:\n  - the length is longer than the remaining range of the cursor;\n  - the length is not page-aligned.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}