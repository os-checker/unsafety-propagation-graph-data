{
  "name": "arch::boot::multiboot2::parse_memory_regions",
  "safe": true,
  "callees": {
    "boot::memory_region::MemoryRegionArray::<LEN>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs an empty set.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "Constructor"
      }
    },
    "multiboot2::BootInformation::<'a>::memory_map_tag": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Search for the [`MemoryMapTag`].\n",
      "adt": {}
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "multiboot2::MemoryMapTag::memory_areas": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the slice of the provided [`MemoryArea`]s.\n\n Usually, this should already reflect the memory consumed by the\n code running this.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "multiboot2::MemoryArea::start_address": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The start address of the memory region.\n",
      "adt": {}
    },
    "arch::boot::multiboot2::parse_framebuffer_info": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "multiboot2::BootInformation": "ImmutableAsArgument",
        "core::option::Option": "Constructor",
        "boot::BootloaderFramebufferArg": "Constructor"
      }
    },
    "multiboot2::MemoryArea::end_address": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The end address of the memory region.\n",
      "adt": {}
    },
    "multiboot2::MemoryArea::typ": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The type of the memory region.\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "boot::memory_region::MemoryRegion::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a valid memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegionArray::<LEN>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends a region to the set.\n\n If the set is full, an error is returned.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::framebuffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a framebuffer memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor",
        "boot::BootloaderFramebufferArg": "ImmutableAsArgument"
      }
    },
    "boot::memory_region::MemoryRegion::kernel": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a memory region where kernel sections are loaded.\n\n Most boot protocols do not mark the place where the kernel loads as unusable. In this case,\n we need to explicitly construct and append this memory region.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::multiboot2::parse_initramfs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "multiboot2::BootInformation": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegion::module": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a module memory region from a byte slice that lives in the linear mapping.\n\n # Panics\n\n This method will panic if the byte slice does not live in the linear mapping.\n",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::smp::reclaimable_memory_region": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "boot::memory_region::MemoryRegion": "Constructor"
      }
    },
    "arch::boot::multiboot2::parse_kernel_commandline": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "multiboot2::BootInformation": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "arch::boot::multiboot2::parse_bootloader_name": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "multiboot2::BootInformation": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "boot::memory_region::MemoryRegionArray::<LEN>::into_non_overlapping": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the regions and returns a full set of non-overlapping regions.\n\n If an address is in multiple regions, the region with the lowest\n usability will be its type.\n\n All the addresses between 0 and the end of the last region will be in\n the resulting set. If an address is not in any region, it will be marked\n as [`MemoryRegionType::Unknown`].\n\n If any of the region boundaries are not page-aligned, they will be aligned\n according to the type of the region.\n\n # Panics\n\n This method will panic if the number of output regions is greater than `LEN`.\n",
      "adt": {
        "boot::memory_region::MemoryRegionArray": "Constructor"
      }
    }
  },
  "adts": {
    "boot::memory_region::MemoryRegionArray": [
      "Plain",
      "MutRef"
    ],
    "multiboot2::BootInformation": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 357, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 370, kind: RigidTy(Adt(AdtDef(DefId { id: 3030, name: \"multiboot2::MemoryArea\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 73, kind: RigidTy(Adt(AdtDef(DefId { id: 2784, name: \"boot::BootloaderFramebufferArg\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 23, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 33, kind: RigidTy(Slice(Ty { id: 1, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 4, kind: RigidTy(Str) }, Not)) })])"
    ],
    "multiboot2::MemoryMapTag": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "multiboot2::MemoryArea": [
      "Ref"
    ],
    "multiboot2::MemoryAreaTypeId": [
      "Plain"
    ],
    "multiboot2::MemoryAreaType": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegionType": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "boot::memory_region::MemoryRegion": [
      "Plain"
    ],
    "boot::BootloaderFramebufferArg": [
      "Plain",
      "Ref"
    ]
  },
  "path": 165,
  "span": "ostd/src/arch/x86/boot/multiboot2/mod.rs:88:1: 138:2",
  "src": "fn parse_memory_regions(mb2_info: &BootInformation) -> MemoryRegionArray {\n    let mut regions = MemoryRegionArray::new();\n\n    // Add the regions returned by Grub.\n    let memory_regions_tag = mb2_info\n        .memory_map_tag()\n        .expect(\"No memory regions are found in the Multiboot2 header!\");\n    for region in memory_regions_tag.memory_areas() {\n        let start = region.start_address();\n        let end = region.end_address();\n        let area_typ: MemoryRegionType = MemoryAreaType::from(region.typ()).into();\n        let region = MemoryRegion::new(\n            start.try_into().unwrap(),\n            (end - start).try_into().unwrap(),\n            area_typ,\n        );\n        regions.push(region).unwrap();\n    }\n\n    // Add the framebuffer region since Grub does not specify it.\n    if let Some(fb) = parse_framebuffer_info(mb2_info) {\n        regions.push(MemoryRegion::framebuffer(&fb)).unwrap();\n    }\n\n    // Add the kernel region since Grub does not specify it.\n    regions.push(MemoryRegion::kernel()).unwrap();\n\n    // Add the initramfs region.\n    if let Some(initramfs) = parse_initramfs(mb2_info) {\n        regions.push(MemoryRegion::module(initramfs)).unwrap();\n    }\n\n    // Add the AP boot code region that will be copied into by the BSP.\n    regions\n        .push(super::smp::reclaimable_memory_region())\n        .unwrap();\n\n    // Add the kernel cmdline and boot loader name region since Grub does not specify it.\n    if let Some(kcmdline) = parse_kernel_commandline(mb2_info) {\n        regions\n            .push(MemoryRegion::module(kcmdline.as_bytes()))\n            .unwrap();\n    }\n    if let Some(bootloader_name) = parse_bootloader_name(mb2_info) {\n        regions\n            .push(MemoryRegion::module(bootloader_name.as_bytes()))\n            .unwrap();\n    }\n\n    regions.into_non_overlapping()\n}",
  "mir": "fn arch::boot::multiboot2::parse_memory_regions(_1: &multiboot2::BootInformation<'_>) -> boot::memory_region::MemoryRegionArray<512> {\n    let mut _0: boot::memory_region::MemoryRegionArray<512>;\n    let mut _2: boot::memory_region::MemoryRegionArray<512>;\n    let  _3: &multiboot2::MemoryMapTag;\n    let mut _4: core::option::Option<&multiboot2::MemoryMapTag>;\n    let mut _5: &str;\n    let mut _6: core::slice::Iter<'_, multiboot2::MemoryArea>;\n    let mut _7: &[multiboot2::MemoryArea];\n    let mut _8: core::slice::Iter<'_, multiboot2::MemoryArea>;\n    let mut _9: core::option::Option<&multiboot2::MemoryArea>;\n    let mut _10: &mut core::slice::Iter<'_, multiboot2::MemoryArea>;\n    let mut _11: isize;\n    let  _12: &multiboot2::MemoryArea;\n    let  _13: u64;\n    let  _14: u64;\n    let  _15: boot::memory_region::MemoryRegionType;\n    let mut _16: multiboot2::MemoryAreaType;\n    let mut _17: multiboot2::MemoryAreaTypeId;\n    let  _18: boot::memory_region::MemoryRegion;\n    let mut _19: usize;\n    let mut _20: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _21: usize;\n    let mut _22: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _23: u64;\n    let mut _24: (u64, bool);\n    let  _25: ();\n    let mut _26: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _27: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _28: core::option::Option<boot::BootloaderFramebufferArg>;\n    let mut _29: isize;\n    let  _30: boot::BootloaderFramebufferArg;\n    let  _31: ();\n    let mut _32: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _33: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _34: boot::memory_region::MemoryRegion;\n    let  _35: &boot::BootloaderFramebufferArg;\n    let  _36: ();\n    let mut _37: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _38: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _39: boot::memory_region::MemoryRegion;\n    let mut _40: core::option::Option<&[u8]>;\n    let mut _41: isize;\n    let  _42: &[u8];\n    let  _43: ();\n    let mut _44: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _45: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _46: boot::memory_region::MemoryRegion;\n    let  _47: ();\n    let mut _48: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _49: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _50: boot::memory_region::MemoryRegion;\n    let mut _51: core::option::Option<&str>;\n    let mut _52: isize;\n    let  _53: &str;\n    let  _54: ();\n    let mut _55: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _56: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _57: boot::memory_region::MemoryRegion;\n    let  _58: &[u8];\n    let mut _59: core::option::Option<&str>;\n    let mut _60: isize;\n    let  _61: &str;\n    let  _62: ();\n    let mut _63: core::result::Result<(), boot::memory_region::ArrayFullError>;\n    let mut _64: &mut boot::memory_region::MemoryRegionArray<512>;\n    let mut _65: boot::memory_region::MemoryRegion;\n    let  _66: &[u8];\n    let mut _67: boot::memory_region::MemoryRegionArray<512>;\n    debug mb2_info => _1;\n    debug regions => _2;\n    debug memory_regions_tag => _3;\n    debug iter => _8;\n    debug region => _12;\n    debug start => _13;\n    debug end => _14;\n    debug area_typ => _15;\n    debug region => _18;\n    debug fb => _30;\n    debug initramfs => _42;\n    debug kcmdline => _53;\n    debug bootloader_name => _61;\n    bb0: {\n        StorageLive(_2);\n        _2 = boot::memory_region::MemoryRegionArray::<512>::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = multiboot2::BootInformation::<'_>::memory_map_tag(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = \"No memory regions are found in the Multiboot2 header!\";\n        _3 = core::option::Option::<&multiboot2::MemoryMapTag>::expect(move _4, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = multiboot2::MemoryMapTag::memory_areas(_3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = <&[multiboot2::MemoryArea] as core::iter::IntoIterator>::into_iter(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = move _6;\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_9);\n        _10 = &mut _8;\n        _9 = <core::slice::Iter<'_, multiboot2::MemoryArea> as core::iter::Iterator>::next(_10) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [0: bb10, 1: bb9, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        _12 = ((_9 as variant#1).0: &multiboot2::MemoryArea);\n        _13 = multiboot2::MemoryArea::start_address(_12) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageLive(_28);\n        _28 = arch::boot::multiboot2::parse_framebuffer_info(_1) -> [return: bb24, unwind unreachable];\n    }\n    bb11: {\n        _14 = multiboot2::MemoryArea::end_address(_12) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = multiboot2::MemoryArea::typ(_12) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _16 = <multiboot2::MemoryAreaType as core::convert::From<multiboot2::MemoryAreaTypeId>>::from(move _17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        _15 = <multiboot2::MemoryAreaType as core::convert::Into<boot::memory_region::MemoryRegionType>>::into(move _16) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = <u64 as core::convert::TryInto<usize>>::try_into(_13) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _19 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap(move _20) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _24 = CheckedSub(_14, _13);\n        assert(!move (_24.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _14, _13) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _23 = move (_24.0: u64);\n        _22 = <u64 as core::convert::TryInto<usize>>::try_into(move _23) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_23);\n        _21 = core::result::Result::<usize, core::num::TryFromIntError>::unwrap(move _22) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_22);\n        _18 = boot::memory_region::MemoryRegion::new(move _19, move _21, _15) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &mut _2;\n        _26 = boot::memory_region::MemoryRegionArray::<512>::push(move _27, _18) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        _25 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _26) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_26);\n        StorageDead(_9);\n        goto -> bb6;\n    }\n    bb24: {\n        _29 = discriminant(_28);\n        switchInt(move _29) -> [1: bb25, 0: bb29, otherwise: bb8];\n    }\n    bb25: {\n        StorageLive(_30);\n        _30 = ((_28 as variant#1).0: boot::BootloaderFramebufferArg);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &mut _2;\n        StorageLive(_34);\n        _35 = &_30;\n        _34 = boot::memory_region::MemoryRegion::framebuffer(_35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _32 = boot::memory_region::MemoryRegionArray::<512>::push(move _33, move _34) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_34);\n        StorageDead(_33);\n        _31 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _32) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_32);\n        StorageDead(_30);\n        StorageDead(_28);\n        goto -> bb30;\n    }\n    bb29: {\n        StorageDead(_28);\n        goto -> bb30;\n    }\n    bb30: {\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &mut _2;\n        StorageLive(_39);\n        _39 = boot::memory_region::MemoryRegion::kernel() -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _37 = boot::memory_region::MemoryRegionArray::<512>::push(move _38, move _39) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_39);\n        StorageDead(_38);\n        _36 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _37) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_37);\n        StorageLive(_40);\n        _40 = arch::boot::multiboot2::parse_initramfs(_1) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        _41 = discriminant(_40);\n        switchInt(move _41) -> [1: bb35, 0: bb39, otherwise: bb8];\n    }\n    bb35: {\n        _42 = ((_40 as variant#1).0: &[u8]);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &mut _2;\n        StorageLive(_46);\n        _46 = boot::memory_region::MemoryRegion::module(_42) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _44 = boot::memory_region::MemoryRegionArray::<512>::push(move _45, move _46) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_46);\n        StorageDead(_45);\n        _43 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _44) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_44);\n        StorageDead(_40);\n        goto -> bb40;\n    }\n    bb39: {\n        StorageDead(_40);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &mut _2;\n        StorageLive(_50);\n        _50 = arch::boot::smp::reclaimable_memory_region() -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _48 = boot::memory_region::MemoryRegionArray::<512>::push(move _49, move _50) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_50);\n        StorageDead(_49);\n        _47 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _48) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_48);\n        StorageLive(_51);\n        _51 = arch::boot::multiboot2::parse_kernel_commandline(_1) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _52 = discriminant(_51);\n        switchInt(move _52) -> [1: bb45, 0: bb50, otherwise: bb8];\n    }\n    bb45: {\n        _53 = ((_51 as variant#1).0: &str);\n        StorageLive(_55);\n        StorageLive(_56);\n        _56 = &mut _2;\n        StorageLive(_57);\n        _58 = core::str::<impl str>::as_bytes(_53) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _57 = boot::memory_region::MemoryRegion::module(_58) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _55 = boot::memory_region::MemoryRegionArray::<512>::push(move _56, move _57) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_57);\n        StorageDead(_56);\n        _54 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _55) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_55);\n        StorageDead(_51);\n        goto -> bb51;\n    }\n    bb50: {\n        StorageDead(_51);\n        goto -> bb51;\n    }\n    bb51: {\n        StorageLive(_59);\n        _59 = arch::boot::multiboot2::parse_bootloader_name(_1) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        _60 = discriminant(_59);\n        switchInt(move _60) -> [1: bb53, 0: bb58, otherwise: bb8];\n    }\n    bb53: {\n        _61 = ((_59 as variant#1).0: &str);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = &mut _2;\n        StorageLive(_65);\n        _66 = core::str::<impl str>::as_bytes(_61) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        _65 = boot::memory_region::MemoryRegion::module(_66) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        _63 = boot::memory_region::MemoryRegionArray::<512>::push(move _64, move _65) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_65);\n        StorageDead(_64);\n        _62 = core::result::Result::<(), boot::memory_region::ArrayFullError>::unwrap(move _63) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_63);\n        StorageDead(_59);\n        goto -> bb59;\n    }\n    bb58: {\n        StorageDead(_59);\n        goto -> bb59;\n    }\n    bb59: {\n        StorageLive(_67);\n        _67 = move _2;\n        _0 = boot::memory_region::MemoryRegionArray::<512>::into_non_overlapping(move _67) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_67);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}