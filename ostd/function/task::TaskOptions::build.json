{
  "name": "task::TaskOptions::build",
  "safe": true,
  "callees": {
    "task::kernel_stack::KernelStack::new_with_guard_page": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Generates a kernel stack with guard pages.\n\n 4 additional pages are allocated and regarded as guard pages, which\n should not be accessed.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "task::kernel_stack::KernelStack": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "arch::task::TaskContext::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "arch::task::TaskContext": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "arch::task::kernel_task_entry_wrapper": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "task::TaskContextApi::set_instruction_pointer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the instruction pointer.\n",
      "adt": {}
    },
    "task::kernel_stack::KernelStack::end_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "task::kernel_stack::KernelStack": "ImmutableAsArgument"
      }
    },
    "task::TaskContextApi::set_stack_pointer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the stack pointer.\n",
      "adt": {}
    },
    "core::cell::Cell::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `Cell` containing the given value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n ```\n",
      "adt": {}
    },
    "task::utils::ForceSync::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an instance with `data` as the inner data.\n",
      "adt": {
        "task::utils::ForceSync": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "core::cell::SyncUnsafeCell::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new instance of `SyncUnsafeCell` which will wrap the specified value.\n",
      "adt": {}
    },
    "core::default::Default::default": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the \"default value\" for a type.\n\n Default values are often some kind of initial value, identity value, or anything else that\n may make sense as a default.\n\n # Examples\n\n Using built-in default values:\n\n ```\n let i: i8 = Default::default();\n let (x, y): (Option<String>, f64) = Default::default();\n let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();\n ```\n\n Making your own:\n\n ```\n # #[allow(dead_code)]\n enum Kind {\n     A,\n     B,\n     C,\n }\n\n impl Default for Kind {\n     fn default() -> Self { Kind::A }\n }\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `AtomicBool`.\n\n # Examples\n\n ```\n use std::sync::atomic::AtomicBool;\n\n let atomic_true = AtomicBool::new(true);\n let atomic_false = AtomicBool::new(false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7292, kind: RigidTy(Adt(AdtDef(DefId { id: 5952, name: \"task::kernel_stack::KernelStack\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "task::kernel_stack::KernelStack": [
      "Plain",
      "Ref"
    ],
    "arch::task::TaskContext": [
      "Plain",
      "MutRef"
    ],
    "task::TaskOptions": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6596, kind: RigidTy(Adt(AdtDef(DefId { id: 2756, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 6582, kind: RigidTy(Adt(AdtDef(DefId { id: 3234, name: \"alloc::boxed::Box\" }), GenericArgs([Type(Ty { id: 6598, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 5719, name: \"core::ops::FnOnce\" }), generic_args: GenericArgs([Type(Ty { id: 107, kind: RigidTy(Tuple([])) })]) }), bound_vars: [] }, Binder { value: Projection(ExistentialProjection { def_id: TraitDef(DefId { id: 4861, name: \"core::ops::FnOnce::Output\" }), generic_args: GenericArgs([Type(Ty { id: 107, kind: RigidTy(Tuple([])) })]), term: Type(Ty { id: 107, kind: RigidTy(Tuple([])) }) }), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4862, name: \"core::marker::Send\" })), bound_vars: [] }], Region { kind: ReErased })) }), Type(Ty { id: 657, kind: RigidTy(Adt(AdtDef(DefId { id: 4225, name: \"alloc::alloc::Global\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 7594, kind: RigidTy(Adt(AdtDef(DefId { id: 2756, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 7586, kind: RigidTy(Adt(AdtDef(DefId { id: 3234, name: \"alloc::boxed::Box\" }), GenericArgs([Type(Ty { id: 7588, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 5158, name: \"core::any::Any\" }), generic_args: GenericArgs([]) }), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4862, name: \"core::marker::Send\" })), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4863, name: \"core::marker::Sync\" })), bound_vars: [] }], Region { kind: ReErased })) }), Type(Ty { id: 657, kind: RigidTy(Adt(AdtDef(DefId { id: 4225, name: \"alloc::alloc::Global\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 7595, kind: RigidTy(Adt(AdtDef(DefId { id: 2756, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 7592, kind: RigidTy(Adt(AdtDef(DefId { id: 3234, name: \"alloc::boxed::Box\" }), GenericArgs([Type(Ty { id: 7599, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 5158, name: \"core::any::Any\" }), generic_args: GenericArgs([]) }), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4862, name: \"core::marker::Send\" })), bound_vars: [] }], Region { kind: ReErased })) }), Type(Ty { id: 657, kind: RigidTy(Adt(AdtDef(DefId { id: 4225, name: \"alloc::alloc::Global\" }), GenericArgs([]))) })]))) })]))) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::cell::Cell": [
      "Plain"
    ],
    "task::utils::ForceSync": [
      "Plain"
    ],
    "alloc::boxed::Box": [
      "Plain"
    ],
    "core::cell::SyncUnsafeCell": [
      "Plain"
    ],
    "task::scheduler::info::AtomicCpuId": [
      "Plain"
    ],
    "task::scheduler::info::TaskScheduleInfo": [
      "Plain"
    ],
    "core::sync::atomic::AtomicBool": [
      "Plain"
    ],
    "task::Task": [
      "Plain"
    ]
  },
  "path": 2862,
  "span": "ostd/src/task/mod.rs:163:5: 228:6",
  "src": "pub fn build(self) -> Result<Task> {\n        // All tasks will enter this function. It is meant to execute the `task_fn` in `Task`.\n        //\n        // We provide an assembly wrapper for this function as the end of call stack so we\n        // have to disable name mangling for it.\n        //\n        // # Safety\n        //\n        // This function must be called from `switch.S` when the context is prepared correctly.\n        // SAFETY: The name does not collide with other symbols.\n        #[unsafe(no_mangle)]\n        unsafe extern \"C\" fn kernel_task_entry() -> ! {\n            // SAFETY: The new task is switched on a CPU for the first time, `after_switching_to`\n            // hasn't been called yet.\n            unsafe { processor::after_switching_to() };\n\n            let current_task = Task::current()\n                .expect(\"no current task, it should have current task in kernel task entry\");\n\n            // SAFETY: The `func` field will only be accessed by the current task in the task\n            // context, so the data won't be accessed concurrently.\n            let task_func = unsafe { current_task.func.get() };\n            let task_func = task_func\n                .take()\n                .expect(\"task function is `None` when trying to run\");\n            task_func();\n\n            // Manually drop all the on-stack variables to prevent memory leakage!\n            // This is needed because `scheduler::exit_current()` will never return.\n            //\n            // However, `current_task` _borrows_ the current task without holding\n            // an extra reference count. So we do nothing here.\n\n            scheduler::exit_current();\n        }\n\n        let kstack = KernelStack::new_with_guard_page()?;\n\n        let mut ctx = TaskContext::new();\n        ctx.set_instruction_pointer(\n            crate::arch::task::kernel_task_entry_wrapper as *const () as usize,\n        );\n        // We should reserve space for the return address in the stack, otherwise\n        // we will write across the page boundary due to the implementation of\n        // the context switch.\n        //\n        // According to the System V AMD64 ABI, the stack pointer should be aligned\n        // to at least 16 bytes. And a larger alignment is needed if larger arguments\n        // are passed to the function. The `kernel_task_entry` function does not\n        // have any arguments, so we only need to align the stack pointer to 16 bytes.\n        ctx.set_stack_pointer(kstack.end_vaddr() - 16);\n\n        let new_task = Task {\n            func: ForceSync::new(Cell::new(self.func)),\n            data: self.data.unwrap_or_else(|| Box::new(())),\n            local_data: ForceSync::new(self.local_data.unwrap_or_else(|| Box::new(()))),\n            ctx: SyncUnsafeCell::new(ctx),\n            kstack,\n            schedule_info: TaskScheduleInfo {\n                cpu: AtomicCpuId::default(),\n            },\n            switched_to_cpu: AtomicBool::new(false),\n        };\n\n        Ok(new_task)\n    }",
  "mir": "fn task::TaskOptions::build(_1: task::TaskOptions) -> core::result::Result<task::Task, error::Error> {\n    let mut _0: core::result::Result<task::Task, error::Error>;\n    let  _2: task::kernel_stack::KernelStack;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, task::kernel_stack::KernelStack>;\n    let mut _4: core::result::Result<task::kernel_stack::KernelStack, error::Error>;\n    let mut _5: isize;\n    let  _6: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _7: task::kernel_stack::KernelStack;\n    let mut _8: arch::task::TaskContext;\n    let  _9: ();\n    let mut _10: &mut arch::task::TaskContext;\n    let mut _11: usize;\n    let mut _12: *const ();\n    let mut _13: unsafe extern \"C\" fn();\n    let  _14: ();\n    let mut _15: &mut arch::task::TaskContext;\n    let mut _16: usize;\n    let mut _17: usize;\n    let mut _18: &task::kernel_stack::KernelStack;\n    let mut _19: (usize, bool);\n    let  _20: task::Task;\n    let mut _21: task::utils::ForceSync<core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>>;\n    let mut _22: core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>;\n    let mut _23: core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>;\n    let mut _24: alloc::boxed::Box<dyn core::any::Any + core::marker::Send + core::marker::Sync>;\n    let mut _25: core::option::Option<alloc::boxed::Box<dyn core::any::Any + core::marker::Send + core::marker::Sync>>;\n    let mut _26: task::utils::ForceSync<alloc::boxed::Box<dyn core::any::Any + core::marker::Send>>;\n    let mut _27: alloc::boxed::Box<dyn core::any::Any + core::marker::Send>;\n    let mut _28: core::option::Option<alloc::boxed::Box<dyn core::any::Any + core::marker::Send>>;\n    let mut _29: core::cell::SyncUnsafeCell<arch::task::TaskContext>;\n    let mut _30: arch::task::TaskContext;\n    let mut _31: task::kernel_stack::KernelStack;\n    let mut _32: task::scheduler::info::TaskScheduleInfo;\n    let mut _33: task::scheduler::info::AtomicCpuId;\n    let mut _34: core::sync::atomic::AtomicBool;\n    debug self => _1;\n    debug kstack => _2;\n    debug residual => _6;\n    debug val => _7;\n    debug ctx => _8;\n    debug new_task => _20;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = task::kernel_stack::KernelStack::new_with_guard_page() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <core::result::Result<task::kernel_stack::KernelStack, error::Error> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = move ((_3 as variant#0).0: task::kernel_stack::KernelStack);\n        _2 = move _7;\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_8);\n        _8 = arch::task::TaskContext::new() -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _6 = ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<task::Task, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        StorageDead(_2);\n        drop(_1) -> [return: bb20, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_10);\n        _10 = &mut _8;\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = arch::task::kernel_task_entry_wrapper as unsafe extern \"C\" fn();\n        _12 = move _13 as *const ();\n        StorageDead(_13);\n        _11 = move _12 as usize;\n        StorageDead(_12);\n        _9 = <arch::task::TaskContext as task::TaskContextApi>::set_instruction_pointer(move _10, move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_15);\n        _15 = &mut _8;\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_2;\n        _17 = task::kernel_stack::KernelStack::end_vaddr(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        _19 = CheckedSub(_17, 16_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _17, 16_usize) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _16 = move (_19.0: usize);\n        StorageDead(_17);\n        _14 = <arch::task::TaskContext as task::TaskContextApi>::set_stack_pointer(move _15, move _16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = move (_1.0: core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>);\n        _22 = core::cell::Cell::<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>::new(move _23) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_23);\n        _21 = task::utils::ForceSync::<core::cell::Cell<core::option::Option<alloc::boxed::Box<dyn core::ops::FnOnce() + core::marker::Send>>>>::new(move _22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_22);\n        StorageLive(_25);\n        _25 = move (_1.1: core::option::Option<alloc::boxed::Box<dyn core::any::Any + core::marker::Send + core::marker::Sync>>);\n        _24 = core::option::Option::<alloc::boxed::Box<dyn core::any::Any + core::marker::Send + core::marker::Sync>>::unwrap_or_else::<{closure@ostd/src/task/mod.rs:217:44: 217:46}>(move _25, ZeroSized: {closure@ostd/src/task/mod.rs:217:44: 217:46}) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_25);\n        StorageLive(_26);\n        StorageLive(_28);\n        _28 = move (_1.2: core::option::Option<alloc::boxed::Box<dyn core::any::Any + core::marker::Send>>);\n        _27 = core::option::Option::<alloc::boxed::Box<dyn core::any::Any + core::marker::Send>>::unwrap_or_else::<{closure@ostd/src/task/mod.rs:218:71: 218:73}>(move _28, ZeroSized: {closure@ostd/src/task/mod.rs:218:71: 218:73}) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_28);\n        _26 = task::utils::ForceSync::<alloc::boxed::Box<dyn core::any::Any + core::marker::Send>>::new(_27) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = move _8;\n        _29 = core::cell::SyncUnsafeCell::<arch::task::TaskContext>::new(move _30) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_30);\n        StorageLive(_31);\n        _31 = move _2;\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = <task::scheduler::info::AtomicCpuId as core::default::Default>::default() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _32 = TaskScheduleInfo(move _33);\n        StorageDead(_33);\n        StorageLive(_34);\n        _34 = core::sync::atomic::AtomicBool::new(false) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _20 = Task(move _21, _24, move _26, move _29, move _31, move _34, move _32);\n        StorageDead(_34);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_29);\n        StorageDead(_26);\n        StorageDead(_21);\n        _0 = core::result::Result::Ok(_20);\n        StorageDead(_8);\n        StorageDead(_2);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": " Builds a new task without running it immediately.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}