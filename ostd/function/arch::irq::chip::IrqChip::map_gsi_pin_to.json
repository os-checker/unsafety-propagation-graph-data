{
  "name": "arch::irq::chip::IrqChip::map_gsi_pin_to",
  "safe": true,
  "callees": {
    "sync::spin::SpinLock::<T, G>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the spin lock.\n",
      "adt": {
        "sync::spin::SpinLock": "ImmutableAsArgument",
        "sync::spin::SpinLockGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "arch::irq::chip::ioapic::IoApic::interrupt_base": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the base number of the global system interrupts controlled by the I/O APIC.\n",
      "adt": {
        "arch::irq::chip::ioapic::IoApic": "ImmutableAsArgument"
      }
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "arch::irq::chip::ioapic::IoApic::enable": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Enables an entry.\n\n The caller should ensure that the IRQ line is not released before the entry is disabled.\n Otherwise, it will be considered a logical error.\n\n # Errors\n\n This method will fail if the index exceeds the I/O APIC's maximum redirection entry, or if\n the entry is in use.\n",
      "adt": {
        "arch::irq::chip::ioapic::IoApic": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "irq::top_half::IrqLine": "ImmutableAsArgument"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::spin::SpinLock": [
      "Ref"
    ],
    "arch::irq::chip::IrqChip": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::spin::SpinLockGuard": [
      "Plain",
      "MutRef"
    ],
    "alloc::boxed::Box": [
      "MutRef",
      "Plain",
      "Deref",
      "Unknown([Field(0, Ty { id: 1899, kind: RigidTy(Adt(AdtDef(DefId { id: 3281, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 1932, kind: RigidTy(Slice(Ty { id: 1844, kind: RigidTy(Adt(AdtDef(DefId { id: 3848, name: \"arch::irq::chip::ioapic::IoApic\" }), GenericArgs([]))) })) })]))) }), Field(0, Ty { id: 1900, kind: RigidTy(Adt(AdtDef(DefId { id: 3282, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 1932, kind: RigidTy(Slice(Ty { id: 1844, kind: RigidTy(Adt(AdtDef(DefId { id: 3848, name: \"arch::irq::chip::ioapic::IoApic\" }), GenericArgs([]))) })) })]))) })])"
    ],
    "core::slice::IterMut": [
      "Plain"
    ],
    "core::iter::Rev": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "arch::irq::chip::ioapic::IoApic": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1, kind: RigidTy(Uint(U8)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1912, kind: RigidTy(Adt(AdtDef(DefId { id: 2763, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 31, kind: RigidTy(Adt(AdtDef(DefId { id: 3443, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 3864, name: \"error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "irq::top_half::IrqLine": [
      "Ref",
      "Plain"
    ],
    "arch::irq::chip::MappedIrqLine": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::arch::irq::chip::IrqChip::map_gsi_pin_to"
  },
  "span": "ostd/src/arch/x86/irq/chip/mod.rs:50:5: 72:6",
  "src": "pub fn map_gsi_pin_to(\n        &'static self,\n        irq_line: IrqLine,\n        gsi_index: u32,\n    ) -> Result<MappedIrqLine> {\n        let mut io_apics = self.io_apics.lock();\n\n        let io_apic = io_apics\n            .iter_mut()\n            .rev()\n            .find(|io_apic| io_apic.interrupt_base() <= gsi_index)\n            .unwrap();\n        let index_in_io_apic = (gsi_index - io_apic.interrupt_base())\n            .try_into()\n            .map_err(|_| Error::InvalidArgs)?;\n        io_apic.enable(index_in_io_apic, &irq_line)?;\n\n        Ok(MappedIrqLine {\n            irq_line,\n            gsi_index,\n            irq_chip: self,\n        })\n    }",
  "mir": "fn arch::irq::chip::IrqChip::map_gsi_pin_to(_1: &arch::irq::chip::IrqChip, _2: irq::top_half::IrqLine, _3: u32) -> core::result::Result<arch::irq::chip::MappedIrqLine, error::Error> {\n    let mut _0: core::result::Result<arch::irq::chip::MappedIrqLine, error::Error>;\n    let mut _4: sync::spin::SpinLockGuard<'_, alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>, sync::guard::PreemptDisabled>;\n    let mut _5: &sync::spin::SpinLock<alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>>;\n    let  _6: &mut arch::irq::chip::ioapic::IoApic;\n    let mut _7: core::option::Option<&mut arch::irq::chip::ioapic::IoApic>;\n    let mut _8: &mut core::iter::Rev<core::slice::IterMut<'_, arch::irq::chip::ioapic::IoApic>>;\n    let mut _9: core::iter::Rev<core::slice::IterMut<'_, arch::irq::chip::ioapic::IoApic>>;\n    let mut _10: core::slice::IterMut<'_, arch::irq::chip::ioapic::IoApic>;\n    let mut _11: &mut [arch::irq::chip::ioapic::IoApic];\n    let mut _12: &mut alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>;\n    let mut _13: &mut sync::spin::SpinLockGuard<'_, alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>, sync::guard::PreemptDisabled>;\n    let mut _14: {closure@ostd/src/arch/x86/irq/chip/mod.rs:60:19: 60:28};\n    let mut _15: &u32;\n    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>, u8>;\n    let mut _17: core::result::Result<u8, error::Error>;\n    let mut _18: core::result::Result<u8, core::num::TryFromIntError>;\n    let mut _19: u32;\n    let mut _20: u32;\n    let mut _21: &arch::irq::chip::ioapic::IoApic;\n    let mut _22: (u32, bool);\n    let mut _23: isize;\n    let  _24: core::result::Result<core::convert::Infallible, error::Error>;\n    let  _25: u8;\n    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, error::Error>>;\n    let mut _27: core::result::Result<(), error::Error>;\n    let  _28: &irq::top_half::IrqLine;\n    let mut _29: isize;\n    let  _30: core::result::Result<core::convert::Infallible, error::Error>;\n    let mut _31: arch::irq::chip::MappedIrqLine;\n    let mut _32: irq::top_half::IrqLine;\n    let mut _33: alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>;\n    let mut _34: *const [arch::irq::chip::ioapic::IoApic];\n    debug self => _1;\n    debug irq_line => _2;\n    debug gsi_index => _3;\n    debug io_apics => _4;\n    debug io_apic => _6;\n    debug index_in_io_apic => _25;\n    debug residual => _24;\n    debug val => _25;\n    debug residual => _30;\n    debug val => ();\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: sync::spin::SpinLock<alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>>);\n        _4 = sync::spin::SpinLock::<alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>>::lock(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut _4;\n        _12 = <sync::spin::SpinLockGuard<'_, alloc::boxed::Box<[arch::irq::chip::ioapic::IoApic]>, sync::guard::PreemptDisabled> as core::ops::DerefMut>::deref_mut(move _13) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _33 = (*_12);\n        _34 = ((_33.0: core::ptr::Unique<[arch::irq::chip::ioapic::IoApic]>).0: core::ptr::NonNull<[arch::irq::chip::ioapic::IoApic]>) as *const [arch::irq::chip::ioapic::IoApic];\n        _11 = &mut (*_34);\n        StorageDead(_13);\n        _10 = core::slice::<impl [arch::irq::chip::ioapic::IoApic]>::iter_mut(move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _9 = <core::slice::IterMut<'_, arch::irq::chip::ioapic::IoApic> as core::iter::Iterator>::rev(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _8 = &mut _9;\n        StorageDead(_10);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_3;\n        _14 = {closure@ostd/src/arch/x86/irq/chip/mod.rs:60:19: 60:28}(move _15);\n        StorageDead(_15);\n        _7 = <core::iter::Rev<core::slice::IterMut<'_, arch::irq::chip::ioapic::IoApic>> as core::iter::Iterator>::find::<{closure@ostd/src/arch/x86/irq/chip/mod.rs:60:19: 60:28}>(move _8, move _14) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageDead(_8);\n        _6 = core::option::Option::<&mut arch::irq::chip::ioapic::IoApic>::unwrap(move _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &(*_6);\n        _20 = arch::irq::chip::ioapic::IoApic::interrupt_base(move _21) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_21);\n        _22 = CheckedSub(_3, _20);\n        assert(!move (_22.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, move _20) -> [success: bb8, unwind unreachable];\n    }\n    bb8: {\n        _19 = move (_22.0: u32);\n        StorageDead(_20);\n        _18 = <u32 as core::convert::TryInto<u8>>::try_into(move _19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_19);\n        _17 = core::result::Result::<u8, core::num::TryFromIntError>::map_err::<error::Error, {closure@ostd/src/arch/x86/irq/chip/mod.rs:64:22: 64:25}>(move _18, ZeroSized: {closure@ostd/src/arch/x86/irq/chip/mod.rs:64:22: 64:25}) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        _16 = <core::result::Result<u8, error::Error> as core::ops::Try>::branch(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        _23 = discriminant(_16);\n        switchInt(move _23) -> [0: bb13, 1: bb14, otherwise: bb12];\n    }\n    bb12: {\n        unreachable;\n    }\n    bb13: {\n        _25 = ((_16 as variant#0).0: u8);\n        StorageDead(_16);\n        StorageLive(_26);\n        StorageLive(_27);\n        _28 = &_2;\n        _27 = arch::irq::chip::ioapic::IoApic::enable(_6, _25, _28) -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        _24 = ((_16 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<arch::irq::chip::MappedIrqLine, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_24) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_16);\n        goto -> bb22;\n    }\n    bb16: {\n        _26 = <core::result::Result<(), error::Error> as core::ops::Try>::branch(move _27) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_27);\n        _29 = discriminant(_26);\n        switchInt(move _29) -> [0: bb18, 1: bb19, otherwise: bb12];\n    }\n    bb18: {\n        StorageDead(_26);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = move _2;\n        _31 = MappedIrqLine(move _32, _3, _1);\n        StorageDead(_32);\n        _0 = core::result::Result::Ok(move _31);\n        StorageDead(_31);\n        drop(_4) -> [return: bb21, unwind unreachable];\n    }\n    bb19: {\n        _30 = ((_26 as variant#1).0: core::result::Result<core::convert::Infallible, error::Error>);\n        _0 = <core::result::Result<arch::irq::chip::MappedIrqLine, error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, error::Error>>>::from_residual(_30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_26);\n        goto -> bb22;\n    }\n    bb21: {\n        StorageDead(_4);\n        goto -> bb24;\n    }\n    bb22: {\n        drop(_4) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_4);\n        drop(_2) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        return;\n    }\n}\n",
  "doc": " Maps an IRQ pin specified by a GSI number to an IRQ line.\n\n ACPI represents all interrupts as \"flat\" values known as global system interrupts (GSIs).\n So GSI numbers are well defined on all systems where the ACPI support is present.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}