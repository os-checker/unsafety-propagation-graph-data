{
  "name": "mm::vm_space::CursorMut::<'a>::protect_next",
  "safe": true,
  "callees": {
    "mm::page_table::cursor::CursorMut::<'rcu, C>::protect_next": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Applies the operation to the next slot of mapping within the range.\n\n The range to be found in is the current virtual address with the\n provided length.\n\n The function stops and yields the actually protected range if it has\n actually protected a page, no matter if the following pages are also\n required to be protected.\n\n It also makes the cursor moves forward to the next page after the\n protected one. If no mapped pages exist in the following range, the\n cursor will stop at the end of the range and return [`None`].\n\n # Safety\n\n The caller should ensure that:\n  - the range being protected with the operation does not affect\n    kernel's memory safety;\n  - the privileged flag `AVAIL1` should not be altered, since this flag\n    is reserved for all page tables.\n\n # Panics\n\n Panics if:\n  - the length is longer than the remaining range of the cursor;\n  - the length is not page-aligned.\n",
      "adt": {
        "mm::page_table::cursor::CursorMut": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "mm::page_table::cursor::CursorMut": [
      "MutRef"
    ],
    "mm::vm_space::CursorMut": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2478,
  "span": "ostd/src/mm/vm_space.rs:578:5: 590:6",
  "src": "pub fn protect_next(\n        &mut self,\n        len: usize,\n        mut op: impl FnMut(&mut PageFlags, &mut CachePolicy),\n    ) -> Option<Range<Vaddr>> {\n        // SAFETY: It is safe to set `PageFlags` and `CachePolicy` of memory\n        // in the userspace.\n        unsafe {\n            self.pt_cursor.protect_next(len, &mut |prop| {\n                op(&mut prop.flags, &mut prop.cache);\n            })\n        }\n    }",
  "mir": "fn mm::vm_space::CursorMut::<'a>::protect_next(_1: &mut mm::vm_space::CursorMut<'_>, _2: usize, _3: impl FnMut(&mut PageFlags, &mut CachePolicy)) -> core::option::Option<core::ops::Range<usize>> {\n    let mut _0: core::option::Option<core::ops::Range<usize>>;\n    let mut _4: &mut mm::page_table::cursor::CursorMut<'_, mm::vm_space::UserPtConfig>;\n    let mut _5: &mut {closure@ostd/src/mm/vm_space.rs:586:51: 586:57};\n    let mut _6: {closure@ostd/src/mm/vm_space.rs:586:51: 586:57};\n    let mut _7: &mut impl FnMut(&mut PageFlags, &mut CachePolicy);\n    debug self => _1;\n    debug len => _2;\n    debug op => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: mm::page_table::cursor::CursorMut<'_, mm::vm_space::UserPtConfig>);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _3;\n        _6 = {closure@ostd/src/mm/vm_space.rs:586:51: 586:57}(move _7);\n        StorageDead(_7);\n        _5 = &mut _6;\n        _0 = mm::page_table::cursor::CursorMut::<'_, mm::vm_space::UserPtConfig>::protect_next::<{closure@ostd/src/mm/vm_space.rs:586:51: 586:57}>(move _4, _2, _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        StorageDead(_4);\n        drop(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        return;\n    }\n}\n",
  "doc": " Applies the operation to the next slot of mapping within the range.\n\n The range to be found in is the current virtual address with the\n provided length.\n\n The function stops and yields the actually protected range if it has\n actually protected a page, no matter if the following pages are also\n required to be protected.\n\n It also makes the cursor moves forward to the next page after the\n protected one. If no mapped pages exist in the following range, the\n cursor will stop at the end of the range and return [`None`].\n\n Note that it will **NOT** flush the TLB after the operation. Please\n make the decision yourself on when and how to flush the TLB using\n [`Self::flusher`].\n\n # Panics\n\n Panics if the length is longer than the remaining range of the cursor.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}