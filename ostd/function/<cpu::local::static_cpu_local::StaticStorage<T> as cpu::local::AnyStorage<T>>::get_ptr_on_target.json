{
  "name": "<cpu::local::static_cpu_local::StaticStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_target",
  "safe": true,
  "callees": {
    "cpu::local::is_used::debug_set_true": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "util::id_set::Id::as_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an [`usize`] from the [`Id`]'s corresponding [`u32`].\n",
      "adt": {}
    },
    "spin::once::Once::<T, R>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the inner value on the unchecked assumption that the  [`Once`] has been initialized.\n\n # Safety\n\n This is *extremely* unsafe if the `Once` has not already been initialized because a reference to uninitialized\n memory will be returned, immediately triggering undefined behaviour (even if the reference goes unused).\n However, this can be useful in some instances for exposing the `Once` to FFI or when the overhead of atomically\n checking initialization is unacceptable and the `Once` has already been initialized.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::get_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice, without doing bounds\n checking.\n\n For a safe alternative see [`get`].\n\n # Safety\n\n Calling this method with an out-of-bounds index is *[undefined behavior]*\n even if the resulting reference is not used.\n\n You can think of this like `.get(index).unwrap_unchecked()`.  It's UB\n to call `.get_unchecked(len)`, even if you immediately convert to a\n pointer.  And it's UB to call `.get_unchecked(..len + 1)`,\n `.get_unchecked(..=len)`, or similar.\n\n [`get`]: slice::get\n [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n\n unsafe {\n     assert_eq!(x.get_unchecked(1), &2);\n }\n ```\n",
      "adt": {}
    },
    "mm::kspace::paddr_to_vaddr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Convert physical address to virtual address using offset, only available inside `ostd`\n",
      "adt": {}
    },
    "cpu::local::static_cpu_local::StaticStorage::<T>::get_offset": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the offset of the CPU-local object in the CPU-local area.\n",
      "adt": {
        "cpu::local::static_cpu_local::StaticStorage": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "cpu::id::CpuId": [
      "Plain"
    ],
    "cpu::local::static_cpu_local::StaticStorage": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "spin::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "ostd::<cpu::local::static_cpu_local::StaticStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_target"
  },
  "span": "ostd/src/cpu/local/static_cpu_local.rs:105:5: 129:6",
  "src": "fn get_ptr_on_target(&self, cpu_id: CpuId) -> *const T {\n        super::is_used::debug_set_true();\n\n        let cpu_id = cpu_id.as_usize();\n\n        // If on the BSP, just use the statically linked storage.\n        if cpu_id == 0 {\n            return &self.0 as *const T;\n        }\n\n        let base = {\n            // SAFETY: At this time we have a non-BSP `CpuId`, which means that\n            // `init_cpu_nums` must have been called, so `copy_bsp_for_ap` must\n            // also have been called (see the implementation of `cpu::init_on_bsp`),\n            // so `CPU_LOCAL_STORAGES` must already be initialized.\n            let storages = unsafe { super::CPU_LOCAL_STORAGES.get_unchecked() };\n            // SAFETY: `cpu_id` is guaranteed to be in range because the type\n            // invariant of `CpuId`.\n            let storage = unsafe { *storages.get_unchecked(cpu_id - 1) };\n            crate::mm::paddr_to_vaddr(storage)\n        };\n\n        let offset = self.get_offset();\n        (base + offset) as *const T\n    }",
  "mir": "fn <cpu::local::static_cpu_local::StaticStorage<T> as cpu::local::AnyStorage<T>>::get_ptr_on_target(_1: &cpu::local::static_cpu_local::StaticStorage<T>, _2: cpu::id::CpuId) -> *const T {\n    let mut _0: *const T;\n    let  _3: ();\n    let  _4: usize;\n    let  _5: &T;\n    let  _6: usize;\n    let  _7: &&[usize];\n    let mut _8: &spin::once::Once<&[usize]>;\n    let  _9: usize;\n    let mut _10: &usize;\n    let mut _11: usize;\n    let mut _12: (usize, bool);\n    let  _13: usize;\n    let mut _14: usize;\n    let mut _15: (usize, bool);\n    let mut _16: &[usize];\n    debug self => _1;\n    debug cpu_id => _2;\n    debug cpu_id => _4;\n    debug base => _6;\n    debug storages => _7;\n    debug storage => _9;\n    debug offset => _13;\n    bb0: {\n        _3 = cpu::local::is_used::debug_set_true() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <cpu::id::CpuId as util::id_set::Id>::as_usize(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(_4) -> [0: bb3, otherwise: bb4];\n    }\n    bb3: {\n        StorageLive(_5);\n        _5 = &((*_1).0: T);\n        _0 = &raw const (*_5);\n        StorageDead(_5);\n        goto -> bb11;\n    }\n    bb4: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = {alloc773: &spin::once::Once<&[usize]>};\n        _7 = spin::once::Once::<&[usize]>::get_unchecked(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageLive(_10);\n        _16 = (*_7);\n        StorageLive(_11);\n        _12 = CheckedSub(_4, 1_usize);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, 1_usize) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _11 = move (_12.0: usize);\n        _10 = core::slice::<impl [usize]>::get_unchecked::<usize>(_16, move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _9 = (*_10);\n        StorageDead(_10);\n        _6 = mm::kspace::paddr_to_vaddr(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        _13 = cpu::local::static_cpu_local::StaticStorage::<T>::get_offset(_1) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_14);\n        _15 = CheckedAdd(_6, _13);\n        assert(!move (_15.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, _13) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _14 = move (_15.0: usize);\n        _0 = move _14 as *const T;\n        StorageDead(_14);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}