{
  "name": "ostd::mm::dma::dma_coherent::DmaCoherent::alloc_uninit",
  "span": "ostd/src/mm/dma/dma_coherent.rs:56:5: 56:88",
  "src": "pub fn alloc_uninit(nframes: usize, is_cache_coherent: bool) -> Result<Self, Error> {\n        let cvm = cvm_need_private_protection();\n\n        let (inner, paddr_range) = if is_cache_coherent && !cvm {\n            let segment = FrameAllocOptions::new()\n                .zeroed(false)\n                .alloc_segment(nframes)?;\n            let paddr_range = segment.paddr_range();\n\n            (Inner::Segment(segment), paddr_range)\n        } else {\n            let (kva, paddr) = alloc_kva(nframes, is_cache_coherent)?;\n\n            (Inner::Kva(kva, paddr), paddr..paddr + nframes * PAGE_SIZE)\n        };\n\n        // SAFETY: The physical address range is untyped DMA memory before `drop`.\n        let map_daddr = unsafe { prepare_dma(&paddr_range) };\n\n        Ok(Self {\n            inner,\n            map_daddr,\n            is_cache_coherent,\n        })\n    }"
}