{
  "name": "ostd::mm::vm_space::CursorMut::<'a>::unmap",
  "span": "ostd/src/mm/vm_space.rs:506:5: 506:49",
  "src": "pub fn unmap(&mut self, len: usize) -> usize {\n        let end_va = self.virt_addr() + len;\n        let mut num_unmapped: usize = 0;\n        loop {\n            // SAFETY: It is safe to un-map memory in the userspace.\n            let Some(frag) = (unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) })\n            else {\n                break; // No more mappings in the range.\n            };\n\n            match frag {\n                PageTableFrag::Mapped { va, item, .. } => {\n                    match item {\n                        VmItem {\n                            mapped_item: MappedItem::TrackedFrame(old_frame),\n                            ..\n                        } => {\n                            num_unmapped += 1;\n                            self.flusher\n                                .issue_tlb_flush_with(TlbFlushOp::for_single(va), old_frame.into());\n                        }\n                        VmItem {\n                            mapped_item: MappedItem::UntrackedIoMem { .. },\n                            ..\n                        } => {\n                            // Flush the TLB entry for the current address, but\n                            // in the current design, we cannot drop the\n                            // corresponding `IoMem`. This is because we manage\n                            // the range of I/O as a whole, but the frames\n                            // handled here might be one segment of it.\n                            self.flusher.issue_tlb_flush(TlbFlushOp::for_single(va));\n                        }\n                    }\n                }\n                PageTableFrag::StrayPageTable {\n                    pt,\n                    va,\n                    len,\n                    num_frames,\n                } => {\n                    num_unmapped += num_frames;\n                    self.flusher\n                        .issue_tlb_flush_with(TlbFlushOp::for_range(va..va + len), pt);\n                }\n            }\n        }\n\n        self.flusher.dispatch_tlb_flush();\n\n        num_unmapped\n    }"
}