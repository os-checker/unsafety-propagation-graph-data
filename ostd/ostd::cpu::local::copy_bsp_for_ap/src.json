{
  "name": "ostd::cpu::local::copy_bsp_for_ap",
  "span": "ostd/src/cpu/local/mod.rs:201:1: 201:54",
  "src": "pub(crate) unsafe fn copy_bsp_for_ap(num_cpus: usize) {\n    let num_aps = num_cpus - 1; // BSP does not need allocated storage.\n    if num_aps == 0 {\n        return;\n    }\n\n    // Allocate a region to store the pointers to the CPU-local storage segments.\n    let res = {\n        let size = size_of::<Paddr>()\n            .checked_mul(num_aps)\n            .unwrap()\n            .align_up(PAGE_SIZE);\n        let addr =\n            allocator::early_alloc(Layout::from_size_align(size, PAGE_SIZE).unwrap()).unwrap();\n        let ptr = paddr_to_vaddr(addr) as *mut Paddr;\n\n        // SAFETY: The memory is properly allocated. We exclusively own it. So it's valid to write.\n        unsafe {\n            core::ptr::write_bytes(ptr as *mut u8, 0, size);\n        }\n        // SAFETY: The memory is properly allocated and initialized. We exclusively own it. We\n        // never deallocate it so it lives for '`static'. So we can create a mutable slice on it.\n        unsafe { core::slice::from_raw_parts_mut(ptr, num_aps) }\n    };\n\n    let bsp_base_va = __cpu_local_start as *const () as usize;\n    let bsp_end_va = __cpu_local_end as *const () as usize;\n\n    // Allocate the CPU-local storage segments for APs.\n    for res_addr_mut in res.iter_mut() {\n        let nbytes = (bsp_end_va - bsp_base_va).align_up(PAGE_SIZE);\n        let ap_pages =\n            allocator::early_alloc(Layout::from_size_align(nbytes, PAGE_SIZE).unwrap()).unwrap();\n        let ap_pages_ptr = paddr_to_vaddr(ap_pages) as *mut u8;\n\n        // SAFETY:\n        // 1. The source is valid to read because it has not been used before,\n        //    so it contains only constants.\n        // 2. The destination is valid to write because it is just allocated.\n        // 3. The memory is aligned because the alignment of `u8` is 1.\n        // 4. The two memory regions do not overlap because allocated memory\n        //    regions never overlap with the kernel data.\n        unsafe {\n            core::ptr::copy_nonoverlapping(bsp_base_va as *const u8, ap_pages_ptr, nbytes);\n        }\n\n        *res_addr_mut = ap_pages;\n    }\n\n    is_used::debug_assert_false();\n\n    assert!(!CPU_LOCAL_STORAGES.is_completed());\n    CPU_LOCAL_STORAGES.call_once(|| res);\n}"
}