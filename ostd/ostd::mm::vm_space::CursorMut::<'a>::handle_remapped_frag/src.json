{
  "name": "ostd::mm::vm_space::CursorMut::<'a>::handle_remapped_frag",
  "span": "ostd/src/mm/vm_space.rs:459:5: 459:91",
  "src": "fn handle_remapped_frag(&mut self, frag: PageTableFrag<UserPtConfig>, start_va: Vaddr) {\n        match frag {\n            PageTableFrag::Mapped { va, item } => {\n                debug_assert_eq!(va, start_va);\n                match item.mapped_item {\n                    MappedItem::TrackedFrame(old_frame) => {\n                        self.flusher.issue_tlb_flush_with(\n                            TlbFlushOp::for_single(start_va),\n                            old_frame.into(),\n                        );\n                    }\n                    MappedItem::UntrackedIoMem { .. } => {\n                        // Flush the TLB entry for the current address, but in\n                        // the current design, we cannot drop the corresponding\n                        // `IoMem`. This is because we manage the range of I/O\n                        // as a whole, but the frames handled here might be one\n                        // segment of it.\n                        self.flusher\n                            .issue_tlb_flush(TlbFlushOp::for_single(start_va));\n                    }\n                }\n                self.flusher.dispatch_tlb_flush();\n            }\n            PageTableFrag::StrayPageTable { .. } => {\n                panic!(\"`UFrame` is base page sized but re-mapping out a child PT\");\n            }\n        }\n    }"
}