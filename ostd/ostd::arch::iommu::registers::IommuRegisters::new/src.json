{
  "name": "ostd::arch::iommu::registers::IommuRegisters::new",
  "span": "ostd/src/arch/x86/iommu/registers/mod.rs:266:5: 266:67",
  "src": "fn new(io_mem_builder: &IoMemAllocatorBuilder) -> Option<Self> {\n        let dmar = Dmar::new()?;\n        debug!(\"DMAR: {:#x?}\", dmar);\n\n        let base_address = dmar\n            .remapping_iter()\n            // TODO: Add support for multiple DMA remapping hardware unit definitions (DRHDs). Note\n            // that we use `rev()` here to select the last one, since DRHDs that control specific\n            // devices tend to be reported first.\n            //\n            // For example, Intel(R) Virtualization Technology for Directed I/O (Revision 5.0), 8.4\n            // DMA Remapping Hardware Unit Definition Structure says \"If a DRHD structure with\n            // INCLUDE_PCI_ALL flag Set is reported for a Segment, it must be enumerated by BIOS\n            // after all other DRHD structures for the same Segment\".\n            .rev()\n            .find_map(|remapping| match remapping {\n                Remapping::Drhd(drhd) => Some(drhd.register_base_addr()),\n                _ => None,\n            })\n            .expect(\"no DRHD structure found in the DMAR table\");\n        assert_ne!(base_address, 0, \"IOMMU address should not be zero\");\n        debug!(\"IOMMU base address: {:#x?}\", base_address);\n\n        io_mem_builder.remove(base_address as usize..(base_address as usize + PAGE_SIZE));\n        let base = NonNull::new(paddr_to_vaddr(base_address as usize) as *mut u8).unwrap();\n\n        // SAFETY:\n        // - We trust the ACPI tables (as well as the DRHD in them), from which the base address is\n        //   obtained, so it is a valid IOMMU base address.\n        // - `io_mem_builder.remove()` guarantees that we have exclusive ownership of all the IOMMU\n        //   registers.\n        let iommu_regs = unsafe {\n            fault::init(base);\n\n            Self {\n                version: VolatileRef::new_read_only(base.cast::<u32>()),\n                capability: VolatileRef::new_read_only(base.add(0x08).cast::<u64>()),\n                extended_capability: VolatileRef::new_read_only(base.add(0x10).cast::<u64>()),\n                global_command: VolatileRef::new_restricted(\n                    WriteOnly,\n                    base.add(0x18).cast::<u32>(),\n                ),\n                global_status: VolatileRef::new_read_only(base.add(0x1C).cast::<u32>()),\n                root_table_address: VolatileRef::new(base.add(0x20).cast::<u64>()),\n                context_command: VolatileRef::new(base.add(0x28).cast::<u64>()),\n\n                interrupt_remapping_table_addr: VolatileRef::new(base.add(0xb8).cast::<u64>()),\n\n                invalidate: InvalidationRegisters::new(base),\n            }\n        };\n\n        debug!(\"IOMMU registers:{:#x?}\", iommu_regs);\n        debug!(\"IOMMU capability:{:#x?}\", iommu_regs.read_capability());\n        debug!(\n            \"IOMMU extend capability:{:#x?}\",\n            iommu_regs.read_extended_capability()\n        );\n\n        Some(iommu_regs)\n    }"
}