{
  "name": "ostd::arch::iommu::registers::IommuRegisters::invalidate_interrupt_cache",
  "span": "ostd/src/arch/x86/iommu/registers/mod.rs:199:5: 199:56",
  "src": "pub(super) fn invalidate_interrupt_cache(&mut self) {\n        if !self.read_global_status().contains(GlobalStatus::QIES) {\n            self.global_invalidation();\n            return;\n        }\n\n        let mut queue = QUEUE.get().unwrap().lock();\n\n        // Currently, we don't support asynchronous processing in the queue. Therefore, when we\n        // lock the queue, we know that it is empty and that the Invalidation Completion Status\n        // Register has been cleared.\n\n        // Construct an Interrupt Entry Cache Invalidate Descriptor.\n        queue.append_descriptor(InterruptEntryCache::global_invalidation().0);\n        // Construct an Invalidation Wait Descriptor. We need to set the interrupt flag so that the\n        // Invalidation Completion Status Register can report the completion status.\n        queue.append_descriptor(InvalidationWait::with_interrupt_flag().0);\n\n        // Update the queue tail.\n        let tail = queue.tail();\n        self.invalidate\n            .queue_tail\n            .as_mut_ptr()\n            .write((tail << 4) as u64);\n\n        // Wait for completion.\n        while self.invalidate.completion_status.as_ptr().read() == 0 {}\n        // Clear the Invalidation Completion Status Register.\n        self.invalidate.completion_status.as_mut_ptr().write(1);\n    }"
}