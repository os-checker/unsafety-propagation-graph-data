{
  "name": "ostd::arch::trap::idt::init_on_cpu",
  "span": "ostd/src/arch/x86/trap/idt.rs:31:1: 31:28",
  "src": "pub(super) fn init_on_cpu() {\n    let idt = *GLOBAL_IDT.call_once(|| {\n        let idt = Box::leak(Box::new([const { Entry::missing() }; NUM_INTERRUPTS]));\n\n        // SAFETY: The vector array is properly initialized, lives for `'static`, and will never be\n        // mutated. So it's always fine to create an immutable borrow to it.\n        let vectors = unsafe { &VECTORS };\n\n        // Initialize the IDT entries.\n        for (intr_no, &handler) in vectors.iter().enumerate() {\n            let handler = VirtAddr::new(handler as u64);\n\n            let entry = &mut idt[intr_no];\n            // SAFETY: The handler defined in `trap.S` has a correct signature to handle the\n            // corresponding exception or interrupt.\n            let opt = unsafe { entry.set_handler_addr(handler) };\n\n            // Enable `int3` and `into` in the userspace.\n            if intr_no == 3 || intr_no == 4 {\n                opt.set_privilege_level(PrivilegeLevel::Ring3);\n            }\n        }\n\n        idt\n    });\n\n    let idtr = DescriptorTablePointer {\n        limit: (size_of_val(idt) - 1) as u16,\n        base: VirtAddr::new(idt.as_ptr().addr() as u64),\n    };\n    // SAFETY: The IDT is valid to load because:\n    //  - It lives for `'static`.\n    //  - It contains correct entries at correct indexes: all handlers are defined in `trap.S` with\n    //    correct handler signatures.\n    unsafe { lidt(&idtr) };\n}"
}