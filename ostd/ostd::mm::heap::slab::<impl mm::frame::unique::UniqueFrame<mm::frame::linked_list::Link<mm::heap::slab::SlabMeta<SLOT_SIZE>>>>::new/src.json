{
  "name": "ostd::mm::heap::slab::<impl mm::frame::unique::UniqueFrame<mm::frame::linked_list::Link<mm::heap::slab::SlabMeta<SLOT_SIZE>>>>::new",
  "span": "ostd/src/mm/heap/slab.rs:88:5: 88:49",
  "src": "pub fn new() -> crate::prelude::Result<Self> {\n        const { assert!(SLOT_SIZE <= PAGE_SIZE) };\n        // To ensure we can store a pointer in each slot.\n        const { assert!(SLOT_SIZE >= size_of::<usize>()) };\n        // To ensure `nr_allocated` can be stored in a `u16`.\n        const { assert!(PAGE_SIZE / SLOT_SIZE <= u16::MAX as usize) };\n\n        let mut slab: Slab<SLOT_SIZE> = FrameAllocOptions::new()\n            .zeroed(false)\n            .alloc_frame_with(Link::new(SlabMeta::<SLOT_SIZE> {\n                free_list: SlabSlotList::new(),\n                nr_allocated: 0,\n            }))?\n            .try_into()\n            .unwrap();\n\n        let head_paddr = slab.paddr();\n        let head_vaddr = paddr_to_vaddr(head_paddr);\n\n        // Push each slot to the free list.\n        for slot_offset in (0..PAGE_SIZE).step_by(SLOT_SIZE) {\n            // SAFETY: The slot is within the slab so it can't be NULL.\n            let slot_ptr = unsafe { NonNull::new_unchecked((head_vaddr + slot_offset) as *mut u8) };\n            // SAFETY: The slot is newly allocated in the slab.\n            slab.meta_mut()\n                .free_list\n                .push(unsafe { HeapSlot::new(slot_ptr, super::SlotInfo::SlabSlot(SLOT_SIZE)) });\n        }\n\n        Ok(slab)\n    }"
}