{
  "name": "ostd::sync::rcu::RcuReadGuardInner::<'_, P>::compare_exchange",
  "span": "ostd/src/sync/rcu/mod.rs:218:5: 218:75",
  "src": "fn compare_exchange(self, new_ptr: Option<P>) -> Result<(), Option<P>> {\n        let new_ptr = if let Some(new_ptr) = new_ptr {\n            <P as NonNullPtr>::into_raw(new_ptr).as_ptr()\n        } else {\n            core::ptr::null_mut()\n        };\n\n        if self\n            .rcu\n            .ptr\n            .compare_exchange(self.obj_ptr, new_ptr, AcqRel, Acquire)\n            .is_err()\n        {\n            let Some(new_ptr) = NonNull::new(new_ptr) else {\n                return Err(None);\n            };\n            // SAFETY:\n            // 1. It was previously returned by `into_raw`.\n            // 2. The `compare_exchange` fails so the pointer will not\n            //    be used by other threads via reading the RCU primitive.\n            return Err(Some(unsafe { <P as NonNullPtr>::from_raw(new_ptr) }));\n        }\n\n        if let Some(p) = NonNull::new(self.obj_ptr) {\n            // SAFETY:\n            // 1. The pointer was previously returned by `into_raw`.\n            // 2. The pointer is removed from the RCU slot so that no one will\n            //    use it after the end of the current grace period. The removal\n            //    is done atomically, so it will only be dropped once.\n            unsafe { delay_drop::<P>(p) };\n        }\n\n        Ok(())\n    }"
}