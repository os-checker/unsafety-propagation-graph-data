{
  "name": "ostd::arch::iommu::fault::primary_fault_handler",
  "span": "ostd/src/arch/x86/iommu/fault.rs:264:1: 264:69",
  "src": "fn primary_fault_handler(fault_event_regs: &mut FaultEventRegisters) {\n    let mut fault_status = fault_event_regs.status();\n    if !fault_status.contains(FaultStatus::PPF) {\n        return;\n    }\n\n    let start_index = ((fault_event_regs.status().bits & FaultStatus::FRI.bits) >> 8) as usize;\n    let mut fault_iter = fault_event_regs.recordings.iter_mut();\n    fault_iter.advance_by(start_index).unwrap();\n    for raw_recording in fault_iter {\n        let raw_recording = raw_recording.as_mut_ptr();\n        let mut recording = FaultRecording(raw_recording.read());\n        if !recording.is_fault() {\n            break;\n        }\n\n        // Report\n        error!(\n            \"Catch iommu page fault, doing nothing. recording:{:x?}\",\n            recording\n        );\n\n        // Clear Fault field\n        recording.clear_fault();\n        raw_recording.write(recording.0);\n    }\n\n    if fault_status.contains(FaultStatus::PFO) {\n        info!(\"Primary fault overflow detected.\");\n        fault_status.remove(FaultStatus::PFO);\n        fault_event_regs\n            .status\n            .as_mut_ptr()\n            .write(fault_status.bits);\n    }\n}"
}