{
  "name": "ostd::panic::print_stack_trace",
  "span": "ostd/src/panic.rs:54:1: 54:27",
  "src": "pub fn print_stack_trace() {\n    use core::ffi::c_void;\n\n    use gimli::Register;\n    use unwinding::abi::{\n        _Unwind_Backtrace, _Unwind_FindEnclosingFunction, _Unwind_GetGR, _Unwind_GetIP,\n        UnwindContext, UnwindReasonCode,\n    };\n\n    use crate::{early_print, sync::SpinLock};\n\n    /// We acquire a global lock to prevent the frames in the stack trace from\n    /// interleaving. The spin lock is used merely for its simplicity.\n    static BACKTRACE_PRINT_LOCK: SpinLock<()> = SpinLock::new(());\n    let _lock = BACKTRACE_PRINT_LOCK.lock();\n\n    early_println!(\"Printing stack trace:\");\n\n    struct CallbackData {\n        counter: usize,\n    }\n    extern \"C\" fn callback(unwind_ctx: &UnwindContext<'_>, arg: *mut c_void) -> UnwindReasonCode {\n        let data = unsafe { &mut *(arg as *mut CallbackData) };\n        data.counter += 1;\n        let pc = _Unwind_GetIP(unwind_ctx);\n        if pc > 0 {\n            let fde_initial_address = _Unwind_FindEnclosingFunction(pc as *mut c_void) as usize;\n            early_println!(\n                \"{:4}: fn {:#18x} - pc {:#18x} / registers:\",\n                data.counter,\n                fde_initial_address,\n                pc,\n            );\n        }\n        // Print the first 8 general registers for any architecture. The register number follows\n        // the DWARF standard.\n        for i in 0..8u16 {\n            let reg_i = _Unwind_GetGR(unwind_ctx, i as i32);\n            cfg_if::cfg_if! {\n                if #[cfg(target_arch = \"x86_64\")] {\n                    let reg_name = gimli::X86_64::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else if #[cfg(target_arch = \"riscv64\")] {\n                    let reg_name = gimli::RiscV::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else if #[cfg(target_arch = \"aarch64\")] {\n                    let reg_name = gimli::AArch64::register_name(Register(i)).unwrap_or(\"unknown\");\n                } else {\n                    let reg_name = \"unknown\";\n                }\n            }\n            if i.is_multiple_of(4) {\n                early_print!(\"\\n    \");\n            }\n            early_print!(\" {} {:#18x};\", reg_name, reg_i);\n        }\n        early_print!(\"\\n\\n\");\n        UnwindReasonCode::NO_REASON\n    }\n\n    let mut data = CallbackData { counter: 0 };\n    _Unwind_Backtrace(callback, &mut data as *mut _ as _);\n}"
}