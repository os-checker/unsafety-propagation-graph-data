{
  "name": "ostd::mm::io::VmReader::<'_>::read_val",
  "span": "ostd/src/mm/io.rs:571:5: 571:52",
  "src": "pub fn read_val<T: Pod>(&mut self) -> Result<T> {\n        if self.remain() < size_of::<T>() {\n            return Err(Error::InvalidArgs);\n        }\n\n        let mut val = MaybeUninit::<T>::uninit();\n\n        // SAFETY:\n        // - The memory range points to typed memory.\n        // - The validity requirements for write accesses are met because the pointer is converted\n        //   from a mutable pointer where the underlying storage outlives the temporary lifetime\n        //   and no other Rust references to the same storage exist during the lifetime.\n        // - The type, i.e., `T`, is plain-old-data.\n        let mut writer =\n            unsafe { VmWriter::from_kernel_space(val.as_mut_ptr().cast(), size_of::<T>()) };\n        self.read_fallible(&mut writer)\n            .map_err(|(err, copied_len)| {\n                // The `copied_len` is the number of bytes read so far.\n                // So the `cursor` can be moved back to the original position.\n                self.cursor = self.cursor.wrapping_sub(copied_len);\n                err\n            })?;\n        debug_assert!(!writer.has_avail());\n\n        // SAFETY:\n        // - `self.read_fallible` has initialized all the bytes in `val`.\n        // - The type is plain-old-data.\n        let val_inited = unsafe { val.assume_init() };\n        Ok(val_inited)\n    }"
}