{
  "name": "ostd::mm::page_table::node::entry::Entry::<'a, 'rcu, C>::alloc_if_none",
  "span": "ostd/src/mm/page_table/node/entry.rs:129:5: 132:41",
  "src": "pub(in crate::mm::page_table) fn alloc_if_none(\n        &mut self,\n        guard: &'rcu dyn InAtomicMode,\n    ) -> Option<PageTableGuard<'rcu, C>> {\n        if !(self.is_none() && self.node.level() > 1) {\n            return None;\n        }\n\n        let level = self.node.level();\n        let new_page = RcuDrop::new(PageTableNode::<C>::alloc(level - 1));\n\n        let paddr = new_page.paddr();\n        // SAFETY: The page table won't be dropped before the RCU grace period\n        // ends, so it outlives `'rcu`.\n        let pt_ref = unsafe { PageTableNodeRef::borrow_paddr(paddr) };\n\n        // Lock before writing the PTE, so no one else can operate on it.\n        let pt_lock_guard = pt_ref.lock(guard);\n\n        self.pte = Child::PageTable(new_page).into_pte();\n\n        // SAFETY:\n        //  1. The index is within the bounds.\n        //  2. The new PTE is a child in `C` and at the correct paging level.\n        //  3. The ownership of the child is passed to the page table node.\n        unsafe { self.node.write_pte(self.idx, self.pte) };\n\n        *self.node.nr_children_mut() += 1;\n\n        Some(pt_lock_guard)\n    }"
}