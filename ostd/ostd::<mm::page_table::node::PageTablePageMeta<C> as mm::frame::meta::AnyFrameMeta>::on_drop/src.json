{
  "name": "ostd::<mm::page_table::node::PageTablePageMeta<C> as mm::frame::meta::AnyFrameMeta>::on_drop",
  "span": "ostd/src/mm/page_table/node/mod.rs:303:5: 303:61",
  "src": "fn on_drop(&mut self, reader: &mut VmReader<Infallible>) {\n        let nr_children = self.nr_children.get_mut();\n        if *nr_children == 0 {\n            return;\n        }\n\n        let level = self.level;\n        let range = if level == C::NR_LEVELS {\n            C::TOP_LEVEL_INDEX_RANGE.clone()\n        } else {\n            0..nr_subpage_per_huge::<C>()\n        };\n\n        // Drop the children.\n        reader.skip(range.start * size_of::<C::E>());\n        for _ in range {\n            // Non-atomic read is OK because we have mutable access.\n            let pte = reader.read_once::<C::E>().unwrap();\n            if pte.is_present() {\n                let paddr = pte.paddr();\n                // As a fast path, we can ensure that the type of the child frame\n                // is `Self` if the PTE points to a child page table. Then we don't\n                // need to check the vtable for the drop method.\n                if !pte.is_last(level) {\n                    // SAFETY: The PTE points to a page table node. The ownership\n                    // of the child is transferred to the child then dropped.\n                    drop(unsafe { Frame::<Self>::from_raw(paddr) });\n                } else {\n                    // SAFETY: The PTE points to a mapped item. The ownership\n                    // of the item is transferred here then dropped.\n                    drop(unsafe { C::item_from_raw(paddr, level, pte.prop()) });\n                }\n            }\n        }\n    }"
}