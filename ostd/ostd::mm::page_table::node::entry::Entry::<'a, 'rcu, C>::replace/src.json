{
  "name": "ostd::mm::page_table::node::entry::Entry::<'a, 'rcu, C>::replace",
  "span": "ostd/src/mm/page_table/node/entry.rs:92:5: 92:77",
  "src": "pub(in crate::mm) fn replace(&mut self, new_child: Child<C>) -> Child<C> {\n        match &new_child {\n            Child::PageTable(node) => {\n                assert_eq!(node.level(), self.node.level() - 1);\n            }\n            Child::Frame(_, level, _) => {\n                assert_eq!(*level, self.node.level());\n            }\n            Child::None => {}\n        }\n\n        // SAFETY:\n        //  - The PTE is not referenced by other `ChildRef`s (since we have `&mut self`).\n        //  - The level matches the current node.\n        let old_child = unsafe { Child::from_pte(self.pte, self.node.level()) };\n\n        if old_child.is_none() && !new_child.is_none() {\n            *self.node.nr_children_mut() += 1;\n        } else if !old_child.is_none() && new_child.is_none() {\n            *self.node.nr_children_mut() -= 1;\n        }\n\n        self.pte = new_child.into_pte();\n\n        // SAFETY:\n        //  1. The index is within the bounds.\n        //  2. The new PTE is a child in `C` and at the correct paging level.\n        //  3. The ownership of the child is passed to the page table node.\n        unsafe { self.node.write_pte(self.idx, self.pte) };\n\n        old_child\n    }"
}