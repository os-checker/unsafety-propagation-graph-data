{
  "name": "ostd::mm::page_table::vaddr_range",
  "span": "ostd/src/mm/page_table/mod.rs:204:1: 204:79",
  "src": "pub(super) const fn vaddr_range<C: PageTableConfig>() -> RangeInclusive<Vaddr> {\n    const fn top_level_index_width<C: PageTableConfig>() -> usize {\n        C::ADDRESS_WIDTH - pte_index_bit_offset::<C>(C::NR_LEVELS)\n    }\n\n    const {\n        assert!(C::TOP_LEVEL_INDEX_RANGE.start < C::TOP_LEVEL_INDEX_RANGE.end);\n        assert!(top_level_index_width::<C>() <= nr_pte_index_bits::<C>(),);\n        assert!(C::TOP_LEVEL_INDEX_RANGE.start < 1 << top_level_index_width::<C>());\n        assert!(C::TOP_LEVEL_INDEX_RANGE.end <= 1 << top_level_index_width::<C>());\n    };\n\n    const fn pt_va_range_start<C: PageTableConfig>() -> Vaddr {\n        C::TOP_LEVEL_INDEX_RANGE.start << pte_index_bit_offset::<C>(C::NR_LEVELS)\n    }\n\n    const fn pt_va_range_end<C: PageTableConfig>() -> Vaddr {\n        C::TOP_LEVEL_INDEX_RANGE\n            .end\n            .unbounded_shl(pte_index_bit_offset::<C>(C::NR_LEVELS) as u32)\n            .wrapping_sub(1) // Inclusive end.\n    }\n\n    const fn sign_bit_of_va<C: PageTableConfig>(va: Vaddr) -> bool {\n        (va >> (C::ADDRESS_WIDTH - 1)) & 1 != 0\n    }\n\n    let mut start = pt_va_range_start::<C>();\n    let mut end = pt_va_range_end::<C>();\n\n    const {\n        assert!(\n            !C::VA_SIGN_EXT\n                || sign_bit_of_va::<C>(pt_va_range_start::<C>())\n                    == sign_bit_of_va::<C>(pt_va_range_end::<C>()),\n            \"The sign bit of both range endpoints must be the same if sign extension is enabled\"\n        )\n    }\n\n    if C::VA_SIGN_EXT && sign_bit_of_va::<C>(pt_va_range_start::<C>()) {\n        start |= !0 ^ ((1 << C::ADDRESS_WIDTH) - 1);\n        end |= !0 ^ ((1 << C::ADDRESS_WIDTH) - 1);\n    }\n\n    start..=end\n}"
}