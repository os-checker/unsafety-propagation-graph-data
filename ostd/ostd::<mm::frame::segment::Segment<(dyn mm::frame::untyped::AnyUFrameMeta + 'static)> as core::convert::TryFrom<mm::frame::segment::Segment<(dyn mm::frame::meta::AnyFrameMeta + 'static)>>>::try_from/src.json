{
  "name": "ostd::<mm::frame::segment::Segment<(dyn mm::frame::untyped::AnyUFrameMeta + 'static)> as core::convert::TryFrom<mm::frame::segment::Segment<(dyn mm::frame::meta::AnyFrameMeta + 'static)>>>::try_from",
  "span": "ostd/src/mm/frame/segment.rs:296:5: 296:91",
  "src": "fn try_from(seg: Segment<dyn AnyFrameMeta>) -> core::result::Result<Self, Self::Error> {\n        // SAFETY: for each page there would be a forgotten handle\n        // when creating the `Segment` object.\n        let first_frame = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(seg.range.start) };\n        let first_frame = ManuallyDrop::new(first_frame);\n        if !first_frame.dyn_meta().is_untyped() {\n            return Err(seg);\n        }\n        // Since segments are homogeneous, we can safely assume that the rest\n        // of the frames are of the same type. We just debug-check here.\n        #[cfg(debug_assertions)]\n        {\n            for paddr in seg.range.clone().step_by(PAGE_SIZE) {\n                let frame = unsafe { Frame::<dyn AnyFrameMeta>::from_raw(paddr) };\n                let frame = ManuallyDrop::new(frame);\n                debug_assert!(frame.dyn_meta().is_untyped());\n            }\n        }\n        // SAFETY: The metadata is coerceable and the struct is transmutable.\n        Ok(unsafe { core::mem::transmute::<Segment<dyn AnyFrameMeta>, USegment>(seg) })\n    }"
}