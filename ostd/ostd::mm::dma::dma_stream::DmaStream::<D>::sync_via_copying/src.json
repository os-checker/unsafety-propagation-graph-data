{
  "name": "ostd::mm::dma::dma_stream::DmaStream::<D>::sync_via_copying",
  "span": "ostd/src/mm/dma/dma_stream.rs:249:5: 255:6",
  "src": "fn sync_via_copying(\n        &self,\n        byte_range: Range<usize>,\n        is_from_device: bool,\n        seg: &USegment,\n        kva: &KVirtArea,\n    ) {\n        let skip = byte_range.start;\n        let limit = byte_range.len();\n\n        let (mut reader, mut writer) = if is_from_device {\n            // SAFETY:\n            //  - The memory range points to untyped memory.\n            //  - The KVA is alive in this scope.\n            //  - Using `VmReader` and `VmWriter` is the only way to access the KVA.\n            let kva_reader =\n                unsafe { VmReader::from_kernel_space(kva.start() as *const u8, kva.size()) };\n\n            (kva_reader, seg.writer())\n        } else {\n            // SAFETY:\n            //  - The memory range points to untyped memory.\n            //  - The KVA is alive in this scope.\n            //  - Using `VmReader` and `VmWriter` is the only way to access the KVA.\n            let kva_writer =\n                unsafe { VmWriter::from_kernel_space(kva.start() as *mut u8, kva.size()) };\n\n            (seg.reader(), kva_writer)\n        };\n\n        writer\n            .skip(skip)\n            .limit(limit)\n            .write(reader.skip(skip).limit(limit));\n    }"
}