{
  "name": "ostd::mm::frame::meta::init",
  "span": "ostd/src/mm/frame/meta.rs:456:1: 456:53",
  "src": "pub(crate) unsafe fn init() -> Segment<MetaPageMeta> {\n    let max_paddr = {\n        let regions = &crate::boot::EARLY_INFO.get().unwrap().memory_regions;\n        regions\n            .iter()\n            .filter(|r| r.typ().is_physical())\n            .map(|r| r.base() + r.len())\n            .max()\n            .unwrap()\n    };\n\n    info!(\n        \"Initializing frame metadata for physical memory up to {:x}\",\n        max_paddr\n    );\n\n    // In RISC-V, the boot page table has mapped the 512GB memory,\n    // so we don't need to add temporary linear mapping.\n    // In LoongArch, the DWM0 has mapped the whole memory,\n    // so we don't need to add temporary linear mapping.\n    #[cfg(target_arch = \"x86_64\")]\n    add_temp_linear_mapping(max_paddr);\n\n    let tot_nr_frames = max_paddr / page_size::<PagingConsts>(1);\n    let (nr_meta_pages, meta_pages) = alloc_meta_frames(tot_nr_frames);\n\n    // Map the metadata frames.\n    boot_pt::with_borrow(|boot_pt| {\n        for i in 0..nr_meta_pages {\n            let frame_paddr = meta_pages + i * PAGE_SIZE;\n            let vaddr = mapping::frame_to_meta::<PagingConsts>(0) + i * PAGE_SIZE;\n            let prop = PageProperty {\n                flags: PageFlags::RW,\n                cache: CachePolicy::Writeback,\n                priv_flags: PrivilegedPageFlags::GLOBAL,\n            };\n            // SAFETY: we are doing the metadata mappings for the kernel.\n            unsafe { boot_pt.map_base_page(vaddr, frame_paddr / PAGE_SIZE, prop) };\n        }\n    })\n    .unwrap();\n\n    // Now the metadata frames are mapped, we can initialize the metadata.\n    super::MAX_PADDR.store(max_paddr, Ordering::Relaxed);\n\n    let meta_page_range = meta_pages..meta_pages + nr_meta_pages * PAGE_SIZE;\n\n    let (range_1, range_2) = allocator::EARLY_ALLOCATOR\n        .lock()\n        .as_ref()\n        .unwrap()\n        .allocated_regions();\n    for r in range_difference(&range_1, &meta_page_range) {\n        let early_seg = Segment::from_unused(r, |_| EarlyAllocatedFrameMeta).unwrap();\n        let _ = ManuallyDrop::new(early_seg);\n    }\n    for r in range_difference(&range_2, &meta_page_range) {\n        let early_seg = Segment::from_unused(r, |_| EarlyAllocatedFrameMeta).unwrap();\n        let _ = ManuallyDrop::new(early_seg);\n    }\n\n    mark_unusable_ranges();\n\n    Segment::from_unused(meta_page_range, |_| MetaPageMeta {}).unwrap()\n}"
}