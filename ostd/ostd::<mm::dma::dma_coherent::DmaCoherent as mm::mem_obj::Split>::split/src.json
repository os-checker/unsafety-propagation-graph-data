{
  "name": "ostd::<mm::dma::dma_coherent::DmaCoherent as mm::mem_obj::Split>::split",
  "span": "ostd/src/mm/dma/dma_coherent.rs:84:5: 84:50",
  "src": "fn split(self, offset: usize) -> (Self, Self) {\n        assert!(offset.is_multiple_of(PAGE_SIZE));\n        assert!(0 < offset && offset < self.size());\n\n        let (inner, map_daddr, is_cache_coherent) = {\n            let this = ManuallyDrop::new(self);\n            (\n                // SAFETY: `this.inner` will never be used or dropped later.\n                unsafe { core::ptr::read(&this.inner as *const Inner) },\n                this.map_daddr,\n                this.is_cache_coherent,\n            )\n        };\n\n        let (inner1, inner2) = match inner {\n            Inner::Segment(segment) => {\n                let (s1, s2) = segment.split(offset);\n                (Inner::Segment(s1), Inner::Segment(s2))\n            }\n            Inner::Kva(kva, paddr) => {\n                let (kva1, kva2) = kva.split(offset);\n                let (paddr1, paddr2) = (paddr, paddr + offset);\n                (Inner::Kva(kva1, paddr1), Inner::Kva(kva2, paddr2))\n            }\n        };\n\n        let (daddr1, daddr2) = split_daddr(map_daddr, offset);\n\n        (\n            Self {\n                inner: inner1,\n                map_daddr: daddr1,\n                is_cache_coherent,\n            },\n            Self {\n                inner: inner2,\n                map_daddr: daddr2,\n                is_cache_coherent,\n            },\n        )\n    }"
}