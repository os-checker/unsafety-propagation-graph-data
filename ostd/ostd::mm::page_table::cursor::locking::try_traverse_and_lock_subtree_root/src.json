{
  "name": "ostd::mm::page_table::cursor::locking::try_traverse_and_lock_subtree_root",
  "span": "ostd/src/mm/page_table/cursor/locking.rs:90:1: 94:37",
  "src": "fn try_traverse_and_lock_subtree_root<'rcu, C: PageTableConfig>(\n    pt: &PageTable<C>,\n    guard: &'rcu dyn InAtomicMode,\n    va: &Range<Vaddr>,\n) -> Option<PageTableGuard<'rcu, C>> {\n    let mut cur_node_guard: Option<PageTableGuard<C>> = None;\n    let mut cur_pt_addr = pt.root.paddr();\n    for cur_level in (1..=C::NR_LEVELS).rev() {\n        let start_idx = pte_index::<C>(va.start, cur_level);\n        let level_too_high = {\n            let end_idx = pte_index::<C>(va.end - 1, cur_level);\n            cur_level > 1 && start_idx == end_idx\n        };\n        if !level_too_high {\n            break;\n        }\n\n        let cur_pt_ptr = paddr_to_vaddr(cur_pt_addr) as *mut C::E;\n        // SAFETY:\n        //  - The page table node is alive because (1) the root node is alive and\n        //    (2) all child nodes cannot be recycled because we're in the RCU critical section.\n        //  - The index is inside the bound, so the page table entry is valid.\n        //  - All page table entries are aligned and accessed with atomic operations only.\n        let cur_pte = unsafe { load_pte(cur_pt_ptr.add(start_idx), Ordering::Acquire) };\n\n        if cur_pte.is_present() {\n            if cur_pte.is_last(cur_level) {\n                break;\n            }\n            cur_pt_addr = cur_pte.paddr();\n            cur_node_guard = None;\n            continue;\n        }\n\n        // In case the child is absent, we should lock and allocate a new page table node.\n        let mut pt_guard = cur_node_guard.take().unwrap_or_else(|| {\n            // SAFETY: The node must be alive for at least `'rcu` since the\n            // address is read from the page table node.\n            let node_ref = unsafe { PageTableNodeRef::<'rcu, C>::borrow_paddr(cur_pt_addr) };\n            node_ref.lock(guard)\n        });\n        if *pt_guard.stray_mut() {\n            return None;\n        }\n\n        let mut cur_entry = pt_guard.entry(start_idx);\n        if cur_entry.is_none() {\n            let allocated_guard = cur_entry.alloc_if_none(guard).unwrap();\n            cur_pt_addr = allocated_guard.paddr();\n            cur_node_guard = Some(allocated_guard);\n        } else if cur_entry.is_node() {\n            let ChildRef::PageTable(pt) = cur_entry.to_ref() else {\n                unreachable!();\n            };\n            cur_pt_addr = pt.paddr();\n            cur_node_guard = None;\n        } else {\n            break;\n        }\n    }\n\n    let mut pt_guard = cur_node_guard.unwrap_or_else(|| {\n        // SAFETY: The node must be alive for at least `'rcu` since the\n        // address is read from the page table node.\n        let node_ref = unsafe { PageTableNodeRef::<'rcu, C>::borrow_paddr(cur_pt_addr) };\n        node_ref.lock(guard)\n    });\n    if *pt_guard.stray_mut() {\n        return None;\n    }\n\n    Some(pt_guard)\n}"
}