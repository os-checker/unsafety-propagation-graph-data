{
  "name": "ostd::mm::heap::slot_list::SlabSlotList::<SLOT_SIZE>::push",
  "span": "ostd/src/mm/heap/slot_list.rs:46:5: 46:43",
  "src": "pub fn push(&mut self, slot: HeapSlot) {\n        let slot_ptr = slot.as_ptr();\n        let super::SlotInfo::SlabSlot(slot_size) = slot.info() else {\n            panic!(\"The slot does not come from a slab\");\n        };\n\n        assert_eq!(slot_size, SLOT_SIZE);\n        const { assert!(SLOT_SIZE >= size_of::<usize>()) };\n\n        let original_head = self.head;\n\n        debug_assert!(!slot_ptr.is_null());\n        // SAFETY: A pointer to a slot must not be NULL;\n        self.head = Some(unsafe { NonNull::new_unchecked(slot_ptr) });\n        // Write the original head to the slot.\n        // SAFETY: A heap slot must be free so the pointer to the slot can be\n        // written to. The slot size is at least the size of a pointer.\n        unsafe {\n            slot_ptr\n                .cast::<usize>()\n                .write(original_head.map_or(0, |h| h.as_ptr() as usize));\n        }\n    }"
}