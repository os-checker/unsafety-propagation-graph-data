{
  "name": "ostd::cpu::local::dyn_cpu_local::DynCpuLocalChunk::<ITEM_SIZE>::try_dealloc",
  "span": "ostd/src/cpu/local/dyn_cpu_local.rs:198:5: 201:66",
  "src": "pub fn try_dealloc<T>(\n        &mut self,\n        mut cpu_local: CpuLocal<T, DynamicStorage<T>>,\n    ) -> core::result::Result<(), CpuLocal<T, DynamicStorage<T>>> {\n        let Some(index) = self.get_item_index(&cpu_local) else {\n            return Err(cpu_local);\n        };\n\n        self.bitmap.set(index, false);\n        for cpu in all_cpus() {\n            let ptr = cpu_local.storage.get_mut_ptr_on_target(cpu);\n            // SAFETY:\n            //  - `ptr` is valid for both reads and writes, because:\n            //    - The pointer of the CPU-local object on `cpu` is\n            //      non-null and dereferenceable.\n            //    - We can mutably borrow the CPU-local object on `cpu`\n            //      because we have the exclusive access to `cpu_local`.\n            //  - The pointer of the CPU-local object is properly aligned.\n            //  - The pointer of the CPU-local object points to a valid\n            //    instance of `T`.\n            //  - After the deallocation, no one will access the\n            //    dropped CPU-local object, since we explicitly forget\n            //    the `cpu_local`.\n            unsafe {\n                core::ptr::drop_in_place(ptr);\n            }\n        }\n        let _ = ManuallyDrop::new(cpu_local);\n        Ok(())\n    }"
}