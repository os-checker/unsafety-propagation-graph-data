{
  "name": "ostd::arch::irq::chip::init",
  "span": "ostd/src/arch/x86/irq/chip/mod.rs:164:1: 164:68",
  "src": "pub(in crate::arch) fn init(io_mem_builder: &IoMemAllocatorBuilder) {\n    use acpi::madt::{Madt, MadtEntry};\n\n    // If there are no ACPI tables, or the ACPI tables do not provide us with information about\n    // the I/O APIC, we may need to find another way to determine the I/O APIC address\n    // correctly and reliably (e.g., by parsing the MultiProcessor Specification, which has\n    // been deprecated for a long time and may not even exist in modern hardware).\n    let acpi_tables = get_acpi_tables().unwrap();\n    let madt_table = acpi_tables.find_table::<Madt>().unwrap();\n\n    // \"A one indicates that the system also has a PC-AT-compatible dual-8259 setup. The 8259\n    // vectors must be disabled (that is, masked) when enabling the ACPI APIC operation\"\n    const PCAT_COMPAT: u32 = 1;\n    if madt_table.get().flags & PCAT_COMPAT != 0 {\n        pic::init_and_disable();\n    }\n\n    let mut io_apics = Vec::with_capacity(2);\n    let mut isa_overrides = Vec::new();\n\n    const BUS_ISA: u8 = 0; // \"0 Constant, meaning ISA\".\n\n    for madt_entry in madt_table.get().entries() {\n        match madt_entry {\n            MadtEntry::IoApic(madt_io_apic) => {\n                // SAFETY: We trust the ACPI tables (as well as the MADTs in them), from which the\n                // base address is obtained, so it is a valid I/O APIC base address.\n                let io_apic = unsafe {\n                    IoApic::new(\n                        madt_io_apic.io_apic_address as usize,\n                        madt_io_apic.global_system_interrupt_base,\n                        io_mem_builder,\n                    )\n                };\n                io_apics.push(io_apic);\n            }\n            MadtEntry::InterruptSourceOverride(madt_isa_override)\n                if madt_isa_override.bus == BUS_ISA =>\n            {\n                let isa_override = IsaOverride {\n                    source: madt_isa_override.irq,\n                    target: madt_isa_override.global_system_interrupt,\n                };\n                isa_overrides.push(isa_override);\n            }\n            _ => {}\n        }\n    }\n\n    if isa_overrides.is_empty() {\n        // TODO: QEMU MicroVM does not provide any interrupt source overrides. Therefore, the timer\n        // interrupt used by the PIT will not work. Is this a bug in QEMU MicroVM? Why won't this\n        // affect operating systems such as Linux?\n        isa_overrides.push(IsaOverride {\n            source: 0, // Timer ISA IRQ\n            target: 2, // Timer GSI\n        });\n    }\n\n    for isa_override in isa_overrides.iter() {\n        info!(\n            \"[IOAPIC]: Override ISA interrupt {} for GSI {}\",\n            isa_override.source, isa_override.target\n        );\n    }\n\n    io_apics.sort_by_key(|io_apic| io_apic.interrupt_base());\n    assert!(!io_apics.is_empty(), \"No I/O APICs found\");\n    assert_eq!(\n        io_apics[0].interrupt_base(),\n        0,\n        \"No I/O APIC with zero interrupt base found\"\n    );\n\n    let irq_chip = IrqChip {\n        io_apics: SpinLock::new(io_apics.into_boxed_slice()),\n        overrides: isa_overrides.into_boxed_slice(),\n    };\n    IRQ_CHIP.call_once(|| irq_chip);\n}"
}