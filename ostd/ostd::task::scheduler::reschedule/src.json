{
  "name": "ostd::task::scheduler::reschedule",
  "span": "ostd/src/task/scheduler/mod.rs:549:1: 551:55",
  "src": "fn reschedule<F>(mut f: F)\nwhere\n    F: FnMut(&mut dyn LocalRunQueue) -> ReschedAction,\n{\n    // Even if the decision below is `DoNothing`, we should clear this flag. Meanwhile, to avoid\n    // race conditions, we should do this before making the decision.\n    cpu_local::clear_need_preempt();\n\n    let next_task = loop {\n        let mut action = ReschedAction::DoNothing;\n        SCHEDULER.get().unwrap().mut_local_rq_with(&mut |rq| {\n            action = f(rq);\n        });\n\n        match action {\n            ReschedAction::DoNothing => {\n                return;\n            }\n            ReschedAction::Retry => {\n                continue;\n            }\n            ReschedAction::SwitchTo(next_task) => {\n                break next_task;\n            }\n        };\n    };\n\n    // `switch_to_task` will spin if it finds that the next task is still running on some CPU core,\n    // which guarantees soundness regardless of the scheduler implementation.\n    //\n    // FIXME: The scheduler decision and context switching are not atomic, which can lead to some\n    // strange behavior even if the scheduler is implemented correctly. See \"Problem 2\" at\n    // <https://github.com/asterinas/asterinas/issues/1633> for details.\n    processor::switch_to_task(next_task);\n}"
}