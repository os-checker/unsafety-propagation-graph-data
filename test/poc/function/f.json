{
  "name": "f",
  "safe": true,
  "callees": {
    "alloc::alloc::exchange_malloc": {
      "instance_name": [
        "alloc::alloc::exchange_malloc"
      ],
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "std::vec::Vec::<T>::into_raw_parts": {
      "instance_name": [
        "std::vec::Vec::<u32>::into_raw_parts"
      ],
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Decomposes a `Vec<T>` into its raw components: `(pointer, length, capacity)`.\n\n Returns the raw pointer to the underlying data, the length of\n the vector (in elements), and the allocated capacity of the\n data (in elements). These are the same arguments in the same\n order as the arguments to [`from_raw_parts`].\n\n After calling this function, the caller is responsible for the\n memory previously managed by the `Vec`. Most often, one does\n this by converting the raw pointer, length, and capacity back\n into a `Vec` with the [`from_raw_parts`] function; more generally,\n if `T` is non-zero-sized and the capacity is nonzero, one may use\n any method that calls [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)`; if `T` is zero-sized or the\n capacity is zero, nothing needs to be done.\n\n [`from_raw_parts`]: Vec::from_raw_parts\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n\n # Examples\n\n ```\n let v: Vec<i32> = vec![-1, 0, 1];\n\n let (ptr, len, cap) = v.into_raw_parts();\n\n let rebuilt = unsafe {\n     // We can now make changes to the components, such as\n     // transmuting the raw pointer to a compatible type.\n     let ptr = ptr as *mut u32;\n\n     Vec::from_raw_parts(ptr, len, cap)\n };\n assert_eq!(rebuilt, [4294967295, 0, 1]);\n ```\n",
      "adt": {}
    },
    "SecretRegion::from": {
      "instance_name": [
        "SecretRegion::from"
      ],
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "ValidPtr"
            },
            "args": [
              "v"
            ]
          },
          {
            "tag": {
              "typ": null,
              "name": "InitializedInLen"
            },
            "args": [
              "l"
            ]
          }
        ],
        "spec": {},
        "docs": [
          "* ValidPtr\n* InitializedInLen\n"
        ]
      },
      "doc": "",
      "adt": {
        "SecretRegion": "Constructor"
      }
    },
    "SecretRegion::set_len": {
      "instance_name": [
        "SecretRegion::set_len"
      ],
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": "hazard",
              "name": "InitializedInLen"
            },
            "args": [
              "l"
            ]
          }
        ],
        "spec": {},
        "docs": [
          "* InitializedInLen\n"
        ]
      },
      "doc": "",
      "adt": {
        "SecretRegion": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "instance_name": [
        "core::slice::<impl [u32]>::as_mut_ptr"
      ],
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "SecretRegion::xor_secret_region": {
      "instance_name": [
        "SecretRegion::xor_secret_region"
      ],
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "ValidPtr"
            },
            "args": [
              "ptr"
            ]
          },
          {
            "tag": {
              "typ": null,
              "name": "ValidPtr"
            },
            "args": [
              "self . buffer",
              "offset"
            ]
          }
        ],
        "spec": {},
        "docs": [
          "* ValidPtr\n* ValidPtr\n"
        ]
      },
      "doc": "",
      "adt": {
        "SecretRegion": "ImmutableAsArgument"
      }
    },
    "std::slice::<impl [T]>::into_vec": {
      "instance_name": [
        "std::slice::<impl [u32]>::into_vec::<std::alloc::Global>"
      ],
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts `self` into a vector without clones or allocation.\n\n The resulting vector can be converted back into a box via\n `Vec<T>`'s `into_boxed_slice` method.\n\n # Examples\n\n ```\n let s: Box<[i32]> = Box::new([10, 40, 30]);\n let x = s.into_vec();\n // `s` cannot be used anymore because it has been converted into `x`.\n\n assert_eq!(x, vec![10, 40, 30]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "std::ptr::NonNull[[u32; 3]]": [
      "Plain"
    ],
    "std::ptr::Unique[[u32; 3]]": [
      "Plain"
    ],
    "std::boxed::Box[[u32; 3], std::alloc::Global]": [
      "Plain",
      "Unknown([Field(0, Ty { id: 6, kind: RigidTy(Adt(AdtDef(DefId { id: 7, name: \"std::ptr::Unique\" }), GenericArgs([Type(Ty { id: 1, kind: RigidTy(Array(Ty { id: 10, kind: RigidTy(Uint(U32)) }, TyConst { kind: Value(Ty { id: 2, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(3), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(0, ThreadLocalIndex) })) })]))) }), Field(0, Ty { id: 7, kind: RigidTy(Adt(AdtDef(DefId { id: 6, name: \"std::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 1, kind: RigidTy(Array(Ty { id: 10, kind: RigidTy(Uint(U32)) }, TyConst { kind: Value(Ty { id: 2, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(3), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(0, ThreadLocalIndex) })) })]))) })])"
    ],
    "std::vec::Vec[u32, std::alloc::Global]": [
      "Plain"
    ],
    "SecretRegion": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "std::boxed::Box[[u32], std::alloc::Global]": [
      "Plain"
    ]
  },
  "path": 1,
  "span": "tests/pass/poc.rs:33:1: 42:2",
  "src": "fn f() {\n    let v = vec![0xDEADBEEFu32, 0xCAFEBABE, 0x12345678];\n    let mut data = [0x11111111u32, 0x22222222, 0x33333333];\n    let (p, l, _c) = v.into_raw_parts();\n    let mut s = unsafe { SecretRegion::from(p, 0) };\n    unsafe {\n        s.set_len(l);\n        s.xor_secret_region(data.as_mut_ptr(), 0);\n    }\n}",
  "mir": "fn f() -> () {\n    let mut _0: ();\n    let  _1: std::vec::Vec<u32>;\n    let mut _2: std::boxed::Box<[u32]>;\n    let mut _3: *mut u8;\n    let mut _4: std::boxed::Box<[u32; 3]>;\n    let mut _5: [u32; 3];\n    let  _6: *mut u32;\n    let  _7: usize;\n    let  _8: usize;\n    let mut _9: (*mut u32, usize, usize);\n    let mut _10: SecretRegion;\n    let  _11: ();\n    let mut _12: &mut SecretRegion;\n    let  _13: u32;\n    let mut _14: &SecretRegion;\n    let mut _15: *mut u32;\n    let mut _16: &mut [u32];\n    let mut _17: &mut [u32; 3];\n    let mut _18: *const [u32; 3];\n    let mut _19: std::ptr::NonNull<[u32; 3]>;\n    let mut _20: std::ptr::Unique<[u32; 3]>;\n    let mut _21: *const [u32; 3];\n    let mut _22: *const ();\n    let mut _23: usize;\n    let mut _24: usize;\n    let mut _25: usize;\n    let mut _26: bool;\n    let mut _27: *const ();\n    let mut _28: usize;\n    let mut _29: bool;\n    let mut _30: bool;\n    let mut _31: bool;\n    let mut _32: bool;\n    debug v => _1;\n    debug data => _5;\n    debug p => _6;\n    debug l => _7;\n    debug _c => _8;\n    debug s => _10;\n    bb0: {\n        _3 = alloc::alloc::exchange_malloc(<[u32; 3] as std::mem::SizedTypeProperties>::SIZE, <[u32; 3] as std::mem::SizedTypeProperties>::ALIGN) -> [return: bb1, unwind continue];\n    }\n    bb1: {\n        _18 = move _3 as *const [u32; 3];\n        _19 = NonNull(move _18);\n        _20 = Unique(move _19, std::marker::PhantomData::<[u32; 3]>);\n        _4 = Box(move _20, std::alloc::Global);\n        _21 = ((_4.0: std::ptr::Unique<[u32; 3]>).0: std::ptr::NonNull<[u32; 3]>) as *const [u32; 3];\n        _22 = _21 as *const ();\n        _23 = _22 as usize;\n        _24 = Sub(<[u32; 3] as std::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _25 = BitAnd(_23, _24);\n        _26 = Eq(_25, 0_usize);\n        assert(_26, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<[u32; 3] as std::mem::SizedTypeProperties>::ALIGN, _23) -> [success: bb8, unwind unreachable];\n    }\n    bb2: {\n        _5 = [286331153_u32, 572662306_u32, 858993459_u32];\n        _9 = std::vec::Vec::<u32>::into_raw_parts(_1) -> [return: bb3, unwind continue];\n    }\n    bb3: {\n        _6 = (_9.0: *mut u32);\n        _7 = (_9.1: usize);\n        _8 = (_9.2: usize);\n        _10 = SecretRegion::from(_6, 0_usize) -> [return: bb4, unwind continue];\n    }\n    bb4: {\n        _12 = &mut _10;\n        _11 = SecretRegion::set_len(move _12, _7) -> [return: bb5, unwind continue];\n    }\n    bb5: {\n        _14 = &_10;\n        _17 = &mut _5;\n        _16 = move _17 as &mut [u32];\n        _15 = core::slice::<impl [u32]>::as_mut_ptr(move _16) -> [return: bb6, unwind continue];\n    }\n    bb6: {\n        _13 = SecretRegion::xor_secret_region(move _14, move _15, 0_isize) -> [return: bb7, unwind continue];\n    }\n    bb7: {\n        return;\n    }\n    bb8: {\n        _27 = _21 as *const ();\n        _28 = _27 as usize;\n        _29 = Ne(<[u32; 3] as std::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _30 = Eq(_28, 0_usize);\n        _31 = BitAnd(_30, _29);\n        _32 = Not(_31);\n        assert(_32, \"null pointer dereference occurred\") -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        (*_21) = [3735928559_u32, 3405691582_u32, 305419896_u32];\n        _2 = _4 as std::boxed::Box<[u32]>;\n        _1 = std::slice::<impl [u32]>::into_vec::<std::alloc::Global>(move _2) -> [return: bb2, unwind continue];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}