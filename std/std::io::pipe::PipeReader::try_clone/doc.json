{
  "name": "std::io::pipe::PipeReader::try_clone",
  "span": "$library/std/src/io/pipe.rs:178:5: 178:48",
  "doc": " Creates a new [`PipeReader`] instance that shares the same underlying file description.\n\n # Examples\n\n ```no_run\n # #[cfg(miri)] fn main() {}\n # #[cfg(not(miri))]\n # fn main() -> std::io::Result<()> {\n use std::fs;\n use std::io::{pipe, Write};\n use std::process::Command;\n const NUM_SLOT: u8 = 2;\n const NUM_PROC: u8 = 5;\n const OUTPUT: &str = \"work.txt\";\n\n let mut jobs = vec![];\n let (reader, mut writer) = pipe()?;\n\n // Write NUM_SLOT characters the pipe.\n writer.write_all(&[b'|'; NUM_SLOT as usize])?;\n\n // Spawn several processes that read a character from the pipe, do some work, then\n // write back to the pipe. When the pipe is empty, the processes block, so only\n // NUM_SLOT processes can be working at any given time.\n for _ in 0..NUM_PROC {\n     jobs.push(\n         Command::new(\"bash\")\n             .args([\"-c\",\n                 &format!(\n                      \"read -n 1\\n\\\n                       echo -n 'x' >> '{OUTPUT}'\\n\\\n                       echo -n '|'\",\n                 ),\n             ])\n             .stdin(reader.try_clone()?)\n             .stdout(writer.try_clone()?)\n             .spawn()?,\n     );\n }\n\n // Wait for all jobs to finish.\n for mut job in jobs {\n     job.wait()?;\n }\n\n // Check our work and clean up.\n let xs = fs::read_to_string(OUTPUT)?;\n fs::remove_file(OUTPUT)?;\n assert_eq!(xs, \"x\".repeat(NUM_PROC.into()));\n # Ok(())\n # }\n ```\n"
}