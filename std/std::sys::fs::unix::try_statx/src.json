{
  "name": "std::sys::fs::unix::try_statx",
  "span": "$library/std/src/sys/fs/unix.rs:149:5: 154:38",
  "src": "unsafe fn try_statx(\n        fd: c_int,\n        path: *const c_char,\n        flags: i32,\n        mask: u32,\n    ) -> Option<io::Result<FileAttr>> {\n        use crate::sync::atomic::{Atomic, AtomicU8, Ordering};\n\n        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`.\n        // We check for it on first failure and remember availability to avoid having to\n        // do it again.\n        #[repr(u8)]\n        enum STATX_STATE{ Unknown = 0, Present, Unavailable }\n        static STATX_SAVED_STATE: Atomic<u8> = AtomicU8::new(STATX_STATE::Unknown as u8);\n\n        syscall!(\n            fn statx(\n                fd: c_int,\n                pathname: *const c_char,\n                flags: c_int,\n                mask: libc::c_uint,\n                statxbuf: *mut libc::statx,\n            ) -> c_int;\n        );\n\n        let statx_availability = STATX_SAVED_STATE.load(Ordering::Relaxed);\n        if statx_availability == STATX_STATE::Unavailable as u8 {\n            return None;\n        }\n\n        let mut buf: libc::statx = mem::zeroed();\n        if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n            if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Present as u8 {\n                return Some(Err(err));\n            }\n\n            // We're not yet entirely sure whether `statx` is usable on this kernel\n            // or not. Syscalls can return errors from things other than the kernel\n            // per se, e.g. `EPERM` can be returned if seccomp is used to block the\n            // syscall, or `ENOSYS` might be returned from a faulty FUSE driver.\n            //\n            // Availability is checked by performing a call which expects `EFAULT`\n            // if the syscall is usable.\n            //\n            // See: https://github.com/rust-lang/rust/issues/65662\n            //\n            // FIXME what about transient conditions like `ENOMEM`?\n            let err2 = cvt(statx(0, ptr::null(), 0, libc::STATX_BASIC_STATS | libc::STATX_BTIME, ptr::null_mut()))\n                .err()\n                .and_then(|e| e.raw_os_error());\n            if err2 == Some(libc::EFAULT) {\n                STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n                return Some(Err(err));\n            } else {\n                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n                return None;\n            }\n        }\n        if statx_availability == STATX_STATE::Unknown as u8 {\n            STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n        }\n\n        // We cannot fill `stat64` exhaustively because of private padding fields.\n        let mut stat: stat64 = mem::zeroed();\n        // `c_ulong` on gnu-mips, `dev_t` otherwise\n        stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n        stat.st_ino = buf.stx_ino as libc::ino64_t;\n        stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n        stat.st_mode = buf.stx_mode as libc::mode_t;\n        stat.st_uid = buf.stx_uid as libc::uid_t;\n        stat.st_gid = buf.stx_gid as libc::gid_t;\n        stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n        stat.st_size = buf.stx_size as off64_t;\n        stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n        stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n        stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n        // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n        stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n        stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n        stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n        stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n        stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n\n        let extra = StatxExtraFields {\n            stx_mask: buf.stx_mask,\n            stx_btime: buf.stx_btime,\n            // Store full times to avoid 32-bit `time_t` truncation.\n            #[cfg(target_pointer_width = \"32\")]\n            stx_atime: buf.stx_atime,\n            #[cfg(target_pointer_width = \"32\")]\n            stx_ctime: buf.stx_ctime,\n            #[cfg(target_pointer_width = \"32\")]\n            stx_mtime: buf.stx_mtime,\n        };\n\n        Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n    }"
}