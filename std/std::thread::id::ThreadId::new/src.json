{
  "name": "std::thread::id::ThreadId::new",
  "span": "$library/std/src/thread/id.rs:35:5: 35:36",
  "src": "pub(crate) fn new() -> ThreadId {\n        #[cold]\n        fn exhausted() -> ! {\n            panic!(\"failed to generate unique thread ID: bitspace exhausted\")\n        }\n\n        cfg_select! {\n            target_has_atomic = \"64\" => {\n                use crate::sync::atomic::AtomicU64;\n\n                static COUNTER: Atomic<u64> = AtomicU64::new(0);\n\n                let mut last = COUNTER.load(Ordering::Relaxed);\n                loop {\n                    let Some(id) = last.checked_add(1) else {\n                        exhausted();\n                    };\n\n                    match COUNTER.compare_exchange_weak(last, id, Ordering::Relaxed, Ordering::Relaxed) {\n                        Ok(_) => return ThreadId(NonZero::new(id).unwrap()),\n                        Err(id) => last = id,\n                    }\n                }\n            }\n            _ => {\n                use crate::cell::SyncUnsafeCell;\n                use crate::hint::spin_loop;\n                use crate::sync::atomic::AtomicBool;\n                use crate::thread::yield_now;\n\n                // If we don't have a 64-bit atomic we use a small spinlock. We don't use Mutex\n                // here as we might be trying to get the current thread id in the global allocator,\n                // and on some platforms Mutex requires allocation.\n                static COUNTER_LOCKED: Atomic<bool> = AtomicBool::new(false);\n                static COUNTER: SyncUnsafeCell<u64> = SyncUnsafeCell::new(0);\n\n                // Acquire lock.\n                let mut spin = 0;\n                // Miri doesn't like it when we yield here as it interferes with deterministically\n                // scheduling threads, so avoid `compare_exchange_weak` to avoid spurious yields.\n                while COUNTER_LOCKED.swap(true, Ordering::Acquire) {\n                    if spin <= 3 {\n                        for _ in 0..(1 << spin) {\n                            spin_loop();\n                        }\n                    } else {\n                        yield_now();\n                    }\n                    spin += 1;\n                }\n                // This was `false` before the swap, so we got the lock.\n\n                // SAFETY: we have an exclusive lock on the counter.\n                unsafe {\n                    if let Some(id) = (*COUNTER.get()).checked_add(1) {\n                        *COUNTER.get() = id;\n                        COUNTER_LOCKED.store(false, Ordering::Release);\n                        ThreadId(NonZero::new(id).unwrap())\n                    } else {\n                        COUNTER_LOCKED.store(false, Ordering::Release);\n                        exhausted()\n                    }\n                }\n            }\n        }\n    }"
}