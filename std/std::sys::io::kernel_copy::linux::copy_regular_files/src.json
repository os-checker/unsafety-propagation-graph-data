{
  "name": "std::sys::io::kernel_copy::linux::copy_regular_files",
  "span": "$library/std/src/sys/io/kernel_copy/linux.rs:593:1: 593:80",
  "src": "fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) -> CopyResult {\n    use crate::cmp;\n\n    const NOT_PROBED: u8 = 0;\n    const UNAVAILABLE: u8 = 1;\n    const AVAILABLE: u8 = 2;\n\n    // Kernel prior to 4.5 don't have copy_file_range\n    // We store the availability in a global to avoid unnecessary syscalls\n    static HAS_COPY_FILE_RANGE: Atomic<u8> = AtomicU8::new(NOT_PROBED);\n\n    let mut have_probed = match HAS_COPY_FILE_RANGE.load(Ordering::Relaxed) {\n        NOT_PROBED => false,\n        UNAVAILABLE => return CopyResult::Fallback(0),\n        _ => true,\n    };\n\n    syscall!(\n        fn copy_file_range(\n            fd_in: libc::c_int,\n            off_in: *mut libc::loff_t,\n            fd_out: libc::c_int,\n            off_out: *mut libc::loff_t,\n            len: libc::size_t,\n            flags: libc::c_uint,\n        ) -> libc::ssize_t;\n    );\n\n    fn probe_copy_file_range_support() -> u8 {\n        // In some cases, we cannot determine availability from the first\n        // `copy_file_range` call. In this case, we probe with an invalid file\n        // descriptor so that the results are easily interpretable.\n        match unsafe {\n            cvt(copy_file_range(INVALID_FD, ptr::null_mut(), INVALID_FD, ptr::null_mut(), 1, 0))\n                .map_err(|e| e.raw_os_error())\n        } {\n            Err(Some(EPERM | ENOSYS)) => UNAVAILABLE,\n            Err(Some(EBADF)) => AVAILABLE,\n            Ok(_) => panic!(\"unexpected copy_file_range probe success\"),\n            // Treat other errors as the syscall\n            // being unavailable.\n            Err(_) => UNAVAILABLE,\n        }\n    }\n\n    let mut written = 0u64;\n    while written < max_len {\n        let bytes_to_copy = cmp::min(max_len - written, usize::MAX as u64);\n        // cap to 1GB chunks in case u64::MAX is passed as max_len and the file has a non-zero seek position\n        // this allows us to copy large chunks without hitting EOVERFLOW,\n        // unless someone sets a file offset close to u64::MAX - 1GB, in which case a fallback would be required\n        let bytes_to_copy = cmp::min(bytes_to_copy as usize, 0x4000_0000usize);\n        let copy_result = unsafe {\n            // We actually don't have to adjust the offsets,\n            // because copy_file_range adjusts the file offset automatically\n            cvt(copy_file_range(reader, ptr::null_mut(), writer, ptr::null_mut(), bytes_to_copy, 0))\n        };\n\n        if !have_probed && copy_result.is_ok() {\n            have_probed = true;\n            HAS_COPY_FILE_RANGE.store(AVAILABLE, Ordering::Relaxed);\n        }\n\n        match copy_result {\n            Ok(0) if written == 0 => {\n                // fallback to work around several kernel bugs where copy_file_range will fail to\n                // copy any bytes and return 0 instead of an error if\n                // - reading virtual files from the proc filesystem which appear to have 0 size\n                //   but are not empty. noted in coreutils to affect kernels at least up to 5.6.19.\n                // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n                return CopyResult::Fallback(0);\n            }\n            Ok(0) => return CopyResult::Ended(written), // reached EOF\n            Ok(ret) => written += ret as u64,\n            Err(err) => {\n                return match err.raw_os_error() {\n                    // when file offset + max_length > u64::MAX\n                    Some(EOVERFLOW) => CopyResult::Fallback(written),\n                    Some(raw_os_error @ (ENOSYS | EXDEV | EINVAL | EPERM | EOPNOTSUPP | EBADF))\n                        if written == 0 =>\n                    {\n                        if !have_probed {\n                            let available = if matches!(raw_os_error, ENOSYS | EOPNOTSUPP | EPERM) {\n                                // EPERM can indicate seccomp filters or an\n                                // immutable file. To distinguish these\n                                // cases we probe with invalid file\n                                // descriptors which should result in EBADF\n                                // if the syscall is supported and EPERM or\n                                // ENOSYS if it's not available.\n                                //\n                                // For EOPNOTSUPP, see below. In the case of\n                                // ENOSYS, we try to cover for faulty FUSE\n                                // drivers.\n                                probe_copy_file_range_support()\n                            } else {\n                                AVAILABLE\n                            };\n                            HAS_COPY_FILE_RANGE.store(available, Ordering::Relaxed);\n                        }\n\n                        // Try fallback io::copy if either:\n                        // - Kernel version is < 4.5 (ENOSYS¹)\n                        // - Files are mounted on different fs (EXDEV)\n                        // - copy_file_range is broken in various ways on RHEL/CentOS 7 (EOPNOTSUPP)\n                        // - copy_file_range file is immutable or syscall is blocked by seccomp¹ (EPERM)\n                        // - copy_file_range cannot be used with pipes or device nodes (EINVAL)\n                        // - the writer fd was opened with O_APPEND (EBADF²)\n                        // and no bytes were written successfully yet. (All these errnos should\n                        // not be returned if something was already written, but they happen in\n                        // the wild, see #91152.)\n                        //\n                        // ¹ these cases should be detected by the initial probe but we handle them here\n                        //   anyway in case syscall interception changes during runtime\n                        // ² actually invalid file descriptors would cause this too, but in that case\n                        //   the fallback code path is expected to encounter the same error again\n                        CopyResult::Fallback(0)\n                    }\n                    _ => CopyResult::Error(err, written),\n                };\n            }\n        }\n    }\n    CopyResult::Ended(written)\n}"
}