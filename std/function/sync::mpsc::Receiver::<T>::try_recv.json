{
  "name": "sync::mpsc::Receiver::<T>::try_recv",
  "safe": true,
  "callees": {
    "sync::mpmc::Receiver::<T>::try_recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to receive a message from the channel without blocking.\n\n This method will never block the caller in order to wait for data to\n become available. Instead, this will always return immediately with a\n possible option of pending data on the channel.\n\n If called on a zero-capacity channel, this method will receive a message only if there\n happens to be a send operation on the other side of the channel at the same time.\n\n This is useful for a flavor of \"optimistic check\" before deciding to\n block on a receiver.\n\n Compared with [`recv`], this function has two failure cases instead of one\n (one for disconnection, one for an empty buffer).\n\n [`recv`]: Self::recv\n\n # Examples\n\n ```rust\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc::{Receiver, channel};\n\n let (_, receiver): (_, Receiver<i32>) = channel();\n\n assert!(receiver.try_recv().is_err());\n ```\n",
      "adt": {
        "sync::mpmc::Receiver": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sync::mpmc::Receiver": [
      "Ref"
    ],
    "sync::mpsc::Receiver": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 3001,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpsc.rs:789:5: 791:6",
  "src": "pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        self.inner.try_recv()\n    }",
  "mir": "fn sync::mpsc::Receiver::<T>::try_recv(_1: &sync::mpsc::Receiver<T>) -> core::result::Result<T, sync::mpsc::TryRecvError> {\n    let mut _0: core::result::Result<T, sync::mpsc::TryRecvError>;\n    let mut _2: &sync::mpmc::Receiver<T>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = &((*_1).0: sync::mpmc::Receiver<T>);\n        _0 = sync::mpmc::Receiver::<T>::try_recv(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Attempts to return a pending value on this receiver without blocking.\n\n This method will never block the caller in order to wait for data to\n become available. Instead, this will always return immediately with a\n possible option of pending data on the channel.\n\n This is useful for a flavor of \"optimistic check\" before deciding to\n block on a receiver.\n\n Compared with [`recv`], this function has two failure cases instead of one\n (one for disconnection, one for an empty buffer).\n\n [`recv`]: Self::recv\n\n # Examples\n\n ```rust\n use std::sync::mpsc::{Receiver, channel};\n\n let (_, receiver): (_, Receiver<i32>) = channel();\n\n assert!(receiver.try_recv().is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}