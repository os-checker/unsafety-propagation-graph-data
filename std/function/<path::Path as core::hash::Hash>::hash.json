{
  "name": "<path::Path as core::hash::Hash>::hash",
  "safe": true,
  "callees": {
    "path::Path::as_u8_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "sys::path::unix::parse_prefix": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "path::Prefix": "Constructor"
      }
    },
    "core::hash::Hash::hash": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Feeds this value into the given [`Hasher`].\n\n # Examples\n\n ```\n use std::hash::{DefaultHasher, Hash, Hasher};\n\n let mut hasher = DefaultHasher::new();\n 7920.hash(&mut hasher);\n println!(\"Hash is {:x}!\", hasher.finish());\n ```\n",
      "adt": {}
    },
    "path::Prefix::<'a>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Prefix": "MutableAsArgument"
      }
    },
    "path::Prefix::<'a>::is_verbatim": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the prefix is verbatim, i.e., begins with `\\\\?\\`.\n\n # Examples\n\n ```\n use std::path::Prefix::*;\n use std::ffi::OsStr;\n\n assert!(Verbatim(OsStr::new(\"pictures\")).is_verbatim());\n assert!(VerbatimUNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n assert!(VerbatimDisk(b'C').is_verbatim());\n assert!(!DeviceNS(OsStr::new(\"BrainInterface\")).is_verbatim());\n assert!(!UNC(OsStr::new(\"server\"), OsStr::new(\"share\")).is_verbatim());\n assert!(!Disk(b'C').is_verbatim());\n ```\n",
      "adt": {
        "path::Prefix": "MutableAsArgument"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "sys::path::unix::is_verbatim_sep": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::path::unix::is_sep_byte": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::num::<impl usize>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::num::<impl usize>::rotate_right": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shifts the bits to the right by a specified amount, `n`,\n wrapping the truncated bits to the beginning of the resulting\n integer.\n\n `rotate_right(n)` is equivalent to applying `rotate_right(1)` a total of `n` times. In\n particular, a rotation by the number of bits in `self` returns the input value\n unchanged.\n\n Please note this isn't the same operation as the `>>` shifting operator!\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "core::hash::Hasher::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data into this `Hasher`.\n\n # Examples\n\n ```\n use std::hash::{DefaultHasher, Hasher};\n\n let mut hasher = DefaultHasher::new();\n let data = [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n\n hasher.write(&data);\n\n println!(\"Hash is {:x}!\", hasher.finish());\n ```\n\n # Note to Implementers\n\n You generally should not do length-prefixing as part of implementing\n this method.  It's up to the [`Hash`] implementation to call\n [`Hasher::write_length_prefix`] before sequences that need it.\n",
      "adt": {}
    },
    "core::hash::Hasher::write_usize": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a single `usize` into this hasher.\n",
      "adt": {}
    }
  },
  "adts": {
    "path::Path": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 9312, kind: RigidTy(Adt(AdtDef(DefId { id: 8706, name: \"path::Prefix\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "path::Prefix": [
      "Plain",
      "Ref"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 2409,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:3658:5: 3709:6",
  "src": "fn hash<H: Hasher>(&self, h: &mut H) {\n        let bytes = self.as_u8_slice();\n        let (prefix_len, verbatim) = match parse_prefix(&self.inner) {\n            Some(prefix) => {\n                prefix.hash(h);\n                (prefix.len(), prefix.is_verbatim())\n            }\n            None => (0, false),\n        };\n        let bytes = &bytes[prefix_len..];\n\n        let mut component_start = 0;\n        // track some extra state to avoid prefix collisions.\n        // [\"foo\", \"bar\"] and [\"foobar\"], will have the same payload bytes\n        // but result in different chunk_bits\n        let mut chunk_bits: usize = 0;\n\n        for i in 0..bytes.len() {\n            let is_sep = if verbatim { is_verbatim_sep(bytes[i]) } else { is_sep_byte(bytes[i]) };\n            if is_sep {\n                if i > component_start {\n                    let to_hash = &bytes[component_start..i];\n                    chunk_bits = chunk_bits.wrapping_add(to_hash.len());\n                    chunk_bits = chunk_bits.rotate_right(2);\n                    h.write(to_hash);\n                }\n\n                // skip over separator and optionally a following CurDir item\n                // since components() would normalize these away.\n                component_start = i + 1;\n\n                let tail = &bytes[component_start..];\n\n                if !verbatim {\n                    component_start += match tail {\n                        [b'.'] => 1,\n                        [b'.', sep, ..] if is_sep_byte(*sep) => 1,\n                        _ => 0,\n                    };\n                }\n            }\n        }\n\n        if component_start < bytes.len() {\n            let to_hash = &bytes[component_start..];\n            chunk_bits = chunk_bits.wrapping_add(to_hash.len());\n            chunk_bits = chunk_bits.rotate_right(2);\n            h.write(to_hash);\n        }\n\n        h.write_usize(chunk_bits);\n    }",
  "mir": "fn <path::Path as core::hash::Hash>::hash(_1: &path::Path, _2: &mut H) -> () {\n    let mut _0: ();\n    let  _3: &[u8];\n    let  _4: usize;\n    let  _5: bool;\n    let mut _6: (usize, bool);\n    let mut _7: core::option::Option<path::Prefix<'_>>;\n    let  _8: &ffi::os_str::OsStr;\n    let mut _9: isize;\n    let  _10: path::Prefix<'_>;\n    let  _11: ();\n    let mut _12: &path::Prefix<'_>;\n    let mut _13: usize;\n    let mut _14: &path::Prefix<'_>;\n    let mut _15: bool;\n    let mut _16: &path::Prefix<'_>;\n    let  _17: &[u8];\n    let mut _18: core::ops::RangeFrom<usize>;\n    let mut _19: usize;\n    let mut _20: usize;\n    let mut _21: core::ops::Range<usize>;\n    let mut _22: core::ops::Range<usize>;\n    let mut _23: usize;\n    let mut _24: core::ops::Range<usize>;\n    let mut _25: core::option::Option<usize>;\n    let mut _26: &mut core::ops::Range<usize>;\n    let mut _27: isize;\n    let  _28: usize;\n    let  _29: bool;\n    let mut _30: u8;\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: u8;\n    let mut _34: usize;\n    let mut _35: bool;\n    let mut _36: bool;\n    let mut _37: bool;\n    let mut _38: usize;\n    let  _39: &[u8];\n    let mut _40: core::ops::Range<usize>;\n    let mut _41: usize;\n    let mut _42: usize;\n    let mut _43: usize;\n    let mut _44: usize;\n    let mut _45: usize;\n    let mut _46: usize;\n    let  _47: ();\n    let mut _48: (usize, bool);\n    let  _49: &[u8];\n    let mut _50: core::ops::RangeFrom<usize>;\n    let mut _51: usize;\n    let mut _52: usize;\n    let mut _53: usize;\n    let mut _54: bool;\n    let mut _55: usize;\n    let  _56: &u8;\n    let  _57: &&u8;\n    let mut _58: bool;\n    let mut _59: u8;\n    let mut _60: (usize, bool);\n    let mut _61: bool;\n    let mut _62: usize;\n    let mut _63: usize;\n    let  _64: &[u8];\n    let mut _65: core::ops::RangeFrom<usize>;\n    let mut _66: usize;\n    let mut _67: usize;\n    let mut _68: usize;\n    let mut _69: usize;\n    let mut _70: usize;\n    let mut _71: usize;\n    let  _72: ();\n    let  _73: ();\n    let mut _74: usize;\n    let mut _75: &u8;\n    debug self => _1;\n    debug h => _2;\n    debug bytes => _3;\n    debug prefix_len => _4;\n    debug verbatim => _5;\n    debug prefix => _10;\n    debug bytes => _17;\n    debug component_start => _19;\n    debug chunk_bits => _20;\n    debug iter => _24;\n    debug i => _28;\n    debug is_sep => _29;\n    debug to_hash => _39;\n    debug tail => _49;\n    debug sep => _56;\n    debug sep => _57;\n    debug to_hash => _64;\n    bb0: {\n        _3 = path::Path::as_u8_slice(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _8 = &((*_1).0: ffi::os_str::OsStr);\n        _7 = sys::path::unix::parse_prefix(_8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _6 = (0_usize, false);\n        goto -> bb9;\n    }\n    bb5: {\n        StorageLive(_10);\n        _10 = ((_7 as variant#1).0: path::Prefix<'_>);\n        StorageLive(_12);\n        _12 = &_10;\n        _11 = <path::Prefix<'_> as core::hash::Hash>::hash::<H>(move _12, _2) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_10;\n        _13 = path::Prefix::<'_>::len(move _14) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_10;\n        _15 = path::Prefix::<'_>::is_verbatim(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _6 = (move _13, move _15);\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb9;\n    }\n    bb9: {\n        _4 = (_6.0: usize);\n        _5 = (_6.1: bool);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_18);\n        _18 = RangeFrom(_4);\n        _17 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_3, move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = 0_usize;\n        StorageLive(_20);\n        _20 = 0_usize;\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = PtrMetadata(_17);\n        _22 = Range(0_usize, move _23);\n        StorageDead(_23);\n        _21 = <core::ops::Range<usize> as core::iter::IntoIterator>::into_iter(move _22) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_22);\n        StorageLive(_24);\n        _24 = move _21;\n        goto -> bb12;\n    }\n    bb12: {\n        StorageLive(_25);\n        _26 = &mut _24;\n        _25 = <core::ops::Range<usize> as core::iter::Iterator>::next(_26) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _27 = discriminant(_25);\n        switchInt(move _27) -> [0: bb15, 1: bb14, otherwise: bb3];\n    }\n    bb14: {\n        _28 = ((_25 as variant#1).0: usize);\n        StorageLive(_29);\n        switchInt(_5) -> [0: bb19, otherwise: bb16];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_21);\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = _19;\n        StorageLive(_63);\n        _63 = PtrMetadata(_17);\n        _61 = Lt(move _62, move _63);\n        switchInt(move _61) -> [0: bb52, otherwise: bb47];\n    }\n    bb16: {\n        StorageLive(_30);\n        _31 = PtrMetadata(_17);\n        _32 = Lt(_28, _31);\n        assert(move _32, \"index out of bounds: the length is {} but the index is {}\", move _31, _28) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _30 = (*_17)[_28];\n        _29 = sys::path::unix::is_verbatim_sep(move _30) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_30);\n        goto -> bb22;\n    }\n    bb19: {\n        StorageLive(_33);\n        _34 = PtrMetadata(_17);\n        _35 = Lt(_28, _34);\n        assert(move _35, \"index out of bounds: the length is {} but the index is {}\", move _34, _28) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _33 = (*_17)[_28];\n        _29 = sys::path::unix::is_sep_byte(move _33) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_33);\n        goto -> bb22;\n    }\n    bb22: {\n        StorageLive(_36);\n        _36 = _29;\n        switchInt(move _36) -> [0: bb46, otherwise: bb23];\n    }\n    bb23: {\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _19;\n        _37 = Gt(_28, move _38);\n        switchInt(move _37) -> [0: bb29, otherwise: bb24];\n    }\n    bb24: {\n        StorageDead(_38);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = _19;\n        _40 = Range(move _41, _28);\n        StorageDead(_41);\n        _39 = <[u8] as core::ops::Index<core::ops::Range<usize>>>::index(_17, move _40) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_40);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = _20;\n        StorageLive(_44);\n        _44 = PtrMetadata(_39);\n        _42 = core::num::<impl usize>::wrapping_add(move _43, move _44) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_44);\n        StorageDead(_43);\n        _20 = move _42;\n        StorageDead(_42);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = _20;\n        _45 = core::num::<impl usize>::rotate_right(move _46, 2_u32) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_46);\n        _20 = move _45;\n        StorageDead(_45);\n        _47 = <H as core::hash::Hasher>::write(_2, _39) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        goto -> bb30;\n    }\n    bb29: {\n        StorageDead(_38);\n        goto -> bb30;\n    }\n    bb30: {\n        StorageDead(_37);\n        _48 = CheckedAdd(_28, 1_usize);\n        assert(!move (_48.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _28, 1_usize) -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _19 = move (_48.0: usize);\n        StorageLive(_50);\n        StorageLive(_51);\n        _51 = _19;\n        _50 = RangeFrom(move _51);\n        StorageDead(_51);\n        _49 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_17, move _50) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_50);\n        switchInt(_5) -> [0: bb33, otherwise: bb45];\n    }\n    bb33: {\n        StorageLive(_52);\n        _55 = PtrMetadata(_49);\n        switchInt(_55) -> [1: bb35, otherwise: bb36];\n    }\n    bb34: {\n        _52 = 0_usize;\n        goto -> bb43;\n    }\n    bb35: {\n        switchInt((*_49)[0 of 1]) -> [46: bb39, otherwise: bb34];\n    }\n    bb36: {\n        _53 = PtrMetadata(_49);\n        _54 = Ge(_53, 2_usize);\n        switchInt(move _54) -> [0: bb34, otherwise: bb37];\n    }\n    bb37: {\n        switchInt((*_49)[0 of 2]) -> [46: bb38, otherwise: bb34];\n    }\n    bb38: {\n        StorageLive(_57);\n        StorageLive(_56);\n        _56 = &(*_49)[1 of 2];\n        _57 = &_56;\n        StorageLive(_58);\n        StorageLive(_59);\n        _75 = (*_57);\n        _59 = (*_75);\n        _58 = sys::path::unix::is_sep_byte(move _59) -> [return: bb40, unwind unreachable];\n    }\n    bb39: {\n        _52 = 1_usize;\n        goto -> bb43;\n    }\n    bb40: {\n        switchInt(move _58) -> [0: bb42, otherwise: bb41];\n    }\n    bb41: {\n        StorageDead(_59);\n        StorageDead(_58);\n        _52 = 1_usize;\n        StorageDead(_56);\n        StorageDead(_57);\n        goto -> bb43;\n    }\n    bb42: {\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_56);\n        StorageDead(_57);\n        goto -> bb34;\n    }\n    bb43: {\n        _60 = CheckedAdd(_19, _52);\n        assert(!move (_60.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _19, move _52) -> [success: bb44, unwind unreachable];\n    }\n    bb44: {\n        _19 = move (_60.0: usize);\n        StorageDead(_52);\n        goto -> bb45;\n    }\n    bb45: {\n        goto -> bb46;\n    }\n    bb46: {\n        StorageDead(_36);\n        StorageDead(_29);\n        StorageDead(_25);\n        goto -> bb12;\n    }\n    bb47: {\n        StorageDead(_63);\n        StorageDead(_62);\n        StorageLive(_65);\n        StorageLive(_66);\n        _66 = _19;\n        _65 = RangeFrom(move _66);\n        StorageDead(_66);\n        _64 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_17, move _65) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_65);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = _20;\n        StorageLive(_69);\n        _69 = PtrMetadata(_64);\n        _67 = core::num::<impl usize>::wrapping_add(move _68, move _69) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_69);\n        StorageDead(_68);\n        _20 = move _67;\n        StorageDead(_67);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = _20;\n        _70 = core::num::<impl usize>::rotate_right(move _71, 2_u32) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_71);\n        _20 = move _70;\n        StorageDead(_70);\n        _72 = <H as core::hash::Hasher>::write(_2, _64) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        goto -> bb53;\n    }\n    bb52: {\n        StorageDead(_63);\n        StorageDead(_62);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_61);\n        StorageLive(_74);\n        _74 = _20;\n        _73 = <H as core::hash::Hasher>::write_usize(_2, move _74) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_74);\n        StorageDead(_20);\n        StorageDead(_19);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}