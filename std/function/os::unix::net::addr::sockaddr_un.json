{
  "name": "os::unix::net::addr::sockaddr_un",
  "safe": true,
  "callees": {
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "path::Path::as_os_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields the underlying [`OsStr`] slice.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let os_str = Path::new(\"foo.txt\").as_os_str();\n assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "os::unix::ffi::os_str::OsStrExt::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the underlying byte view of the [`OsStr`] slice.\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice contains an element with the given value.\n\n This operation is *O*(*n*).\n\n Note that if you have a sorted slice, [`binary_search`] may be faster.\n\n [`binary_search`]: slice::binary_search\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert!(v.contains(&30));\n assert!(!v.contains(&50));\n ```\n\n If you do not have a `&T`, but some other value that you can compare\n with one (for example, `String` implements `PartialEq<str>`), you can\n use `iter().any`:\n\n ```\n let v = [String::from(\"hello\"), String::from(\"world\")]; // slice of `String`\n assert!(v.iter().any(|e| e == \"hello\")); // search with `&str`\n assert!(!v.iter().any(|e| e == \"hi\"));\n ```\n",
      "adt": {}
    },
    "io::error::Error::from_static_message": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Creates a new I/O error from a known kind of error as well as a constant\n message.\n\n This function does not allocate.\n\n You should not use this directly, and instead use the `const_error!`\n macro: `io::const_error!(ErrorKind::Something, \"some_message\")`.\n\n This function should maybe change to `from_static_message<const MSG: &'static\n str>(kind: ErrorKind)` in the future, when const generics allow that.\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::hint::must_use": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An identity function that causes an `unused_must_use` warning to be\n triggered if the given value is not used (returned, stored in a variable,\n etc) by the caller.\n\n This is primarily intended for use in macro-generated code, in which a\n [`#[must_use]` attribute][must_use] either on a type or a function would not\n be convenient.\n\n [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n\n # Example\n\n ```\n #![feature(hint_must_use)]\n\n use core::fmt;\n\n pub struct Error(/* ... */);\n\n #[macro_export]\n macro_rules! make_error {\n     ($($args:expr),*) => {\n         core::hint::must_use({\n             let error = $crate::make_error(core::format_args!($($args),*));\n             error\n         })\n     };\n }\n\n // Implementation detail of make_error! macro.\n #[doc(hidden)]\n pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n     Error(/* ... */)\n }\n\n fn demo() -> Option<Error> {\n     if true {\n         // Oops, meant to write `return Some(make_error!(\"...\"));`\n         Some(make_error!(\"...\"));\n     }\n     None\n }\n #\n # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n # fn main() {}\n ```\n\n In the above example, we'd like an `unused_must_use` lint to apply to the\n value created by `make_error!`. However, neither `#[must_use]` on a struct\n nor `#[must_use]` on a function is appropriate here, so the macro expands\n using `core::hint::must_use` instead.\n\n - We wouldn't want `#[must_use]` on the `struct Error` because that would\n   make the following unproblematic code trigger a warning:\n\n   ```\n   # struct Error;\n   #\n   fn f(arg: &str) -> Result<(), Error>\n   # { Ok(()) }\n\n   #[test]\n   fn t() {\n       // Assert that `f` returns error if passed an empty string.\n       // A value of type `Error` is unused here but that's not a problem.\n       f(\"\").unwrap_err();\n   }\n   ```\n\n - Using `#[must_use]` on `fn make_error` can't help because the return value\n   *is* used, as the right-hand side of a `let` statement. The `let`\n   statement looks useless but is in fact necessary for ensuring that\n   temporaries within the `format_args` expansion are not kept alive past the\n   creation of the `Error`, as keeping them alive past that point can cause\n   autotrait issues in async code:\n\n   ```\n   # #![feature(hint_must_use)]\n   #\n   # struct Error;\n   #\n   # macro_rules! make_error {\n   #     ($($args:expr),*) => {\n   #         core::hint::must_use({\n   #             // If `let` isn't used, then `f()` produces a non-Send future.\n   #             let error = make_error(core::format_args!($($args),*));\n   #             error\n   #         })\n   #     };\n   # }\n   #\n   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n   #     Error\n   # }\n   #\n   async fn f() {\n       // Using `let` inside the make_error expansion causes temporaries like\n       // `unsync()` to drop at the semicolon of that `let` statement, which\n       // is prior to the await point. They would otherwise stay around until\n       // the semicolon on *this* statement, which is after the await point,\n       // and the enclosing Future would not implement Send.\n       log(make_error!(\"look: {:p}\", unsync())).await;\n   }\n\n   async fn log(error: Error) {/* ... */}\n\n   // Returns something without a Sync impl.\n   fn unsync() -> *const () {\n       0 as *const ()\n   }\n   #\n   # fn test() {\n   #     fn assert_send(_: impl Send) {}\n   #     assert_send(f());\n   # }\n   ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice depending on the type of\n index.\n\n - If given a position, returns a reference to the element at that\n   position or `None` if out of bounds.\n - If given a range, returns the subslice corresponding to that range,\n   or `None` if out of bounds.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&40), v.get(1));\n assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n assert_eq!(None, v.get(3));\n assert_eq!(None, v.get(0..4));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "libc::sockaddr_un": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1225, kind: RigidTy(Uint(U16)) })])",
      "Unknown([Field(1, Ty { id: 8105, kind: RigidTy(Array(Ty { id: 35, kind: RigidTy(Uint(U8)) }, TyConst { kind: Value(Ty { id: 393, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(108), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(23, ThreadLocalIndex) })) })])"
    ],
    "path::Path": [
      "Ref"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::os::unix::net::addr::sockaddr_un"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/addr.rs:26:1: 60:2",
  "src": "pub(super) fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n    // SAFETY: All zeros is a valid representation for `sockaddr_un`.\n    let mut addr: libc::sockaddr_un = unsafe { mem::zeroed() };\n    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n\n    let bytes = path.as_os_str().as_bytes();\n\n    if bytes.contains(&0) {\n        return Err(io::const_error!(\n            io::ErrorKind::InvalidInput,\n            \"paths must not contain interior null bytes\",\n        ));\n    }\n\n    if bytes.len() >= addr.sun_path.len() {\n        return Err(io::const_error!(\n            io::ErrorKind::InvalidInput,\n            \"path must be shorter than SUN_LEN\",\n        ));\n    }\n    // SAFETY: `bytes` and `addr.sun_path` are not overlapping and\n    // both point to valid memory.\n    // NOTE: We zeroed the memory above, so the path is already null\n    // terminated.\n    unsafe {\n        ptr::copy_nonoverlapping(bytes.as_ptr(), addr.sun_path.as_mut_ptr().cast(), bytes.len())\n    };\n\n    let mut len = SUN_PATH_OFFSET + bytes.len();\n    match bytes.get(0) {\n        Some(&0) | None => {}\n        Some(_) => len += 1,\n    }\n    Ok((addr, len as libc::socklen_t))\n}",
  "mir": "fn os::unix::net::addr::sockaddr_un(_1: &path::Path) -> core::result::Result<(libc::sockaddr_un, u32), io::error::Error> {\n    let mut _0: core::result::Result<(libc::sockaddr_un, u32), io::error::Error>;\n    let mut _2: libc::sockaddr_un;\n    let  _3: &[u8];\n    let  _4: &ffi::os_str::OsStr;\n    let mut _5: bool;\n    let  _6: &u8;\n    let mut _7: io::error::Error;\n    let mut _8: io::error::Error;\n    let mut _9: bool;\n    let mut _10: usize;\n    let mut _11: usize;\n    let mut _12: &[u8];\n    let mut _13: &[u8; 108];\n    let mut _14: io::error::Error;\n    let mut _15: io::error::Error;\n    let  _16: ();\n    let mut _17: *const u8;\n    let mut _18: *mut u8;\n    let mut _19: *mut u8;\n    let mut _20: &mut [u8];\n    let mut _21: &mut [u8; 108];\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: usize;\n    let mut _25: (usize, bool);\n    let mut _26: core::option::Option<&u8>;\n    let mut _27: isize;\n    let mut _28: (usize, bool);\n    let mut _29: (libc::sockaddr_un, u32);\n    let mut _30: libc::sockaddr_un;\n    let mut _31: u32;\n    let mut _32: usize;\n    let mut _33: &u8;\n    debug path => _1;\n    debug addr => _2;\n    debug bytes => _3;\n    debug len => _23;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::zeroed::<libc::sockaddr_un>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        (_2.0: u16) = libc::AF_UNIX as u16;\n        _4 = path::Path::as_os_str(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = <ffi::os_str::OsStr as os::unix::ffi::os_str::OsStrExt>::as_bytes(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_5);\n        _6 = os::unix::net::addr::sockaddr_un::promoted[0];\n        _5 = core::slice::<impl [u8]>::contains(_3, _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb8, otherwise: bb5];\n    }\n    bb5: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = io::error::Error::from_static_message(os::unix::net::addr::sockaddr_un::{constant#0}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _7 = core::hint::must_use::<io::error::Error>(move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        _0 = core::result::Result::Err(move _7);\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb24;\n    }\n    bb8: {\n        StorageDead(_5);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = PtrMetadata(_3);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &(_2.1: [u8; 108]);\n        _12 = move _13 as &[u8];\n        StorageDead(_13);\n        _11 = PtrMetadata(move _12);\n        StorageDead(_12);\n        _9 = Ge(move _10, move _11);\n        switchInt(move _9) -> [0: bb12, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = io::error::Error::from_static_message(os::unix::net::addr::sockaddr_un::{constant#1}) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _14 = core::hint::must_use::<io::error::Error>(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _0 = core::result::Result::Err(move _14);\n        StorageDead(_14);\n        StorageDead(_9);\n        goto -> bb24;\n    }\n    bb12: {\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_17);\n        _17 = core::slice::<impl [u8]>::as_ptr(_3) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &mut (_2.1: [u8; 108]);\n        _20 = move _21 as &mut [u8];\n        StorageDead(_21);\n        _19 = core::slice::<impl [u8]>::as_mut_ptr(move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        _18 = core::ptr::mut_ptr::<impl *mut u8>::cast::<u8>(move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = PtrMetadata(_3);\n        _16 = core::ptr::copy_nonoverlapping::<u8>(move _17, move _18, move _22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = PtrMetadata(_3);\n        _25 = CheckedAdd(os::unix::net::addr::SUN_PATH_OFFSET, _24);\n        assert(!move (_25.1: bool), \"attempt to compute `{} + {}`, which would overflow\", os::unix::net::addr::SUN_PATH_OFFSET, move _24) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        _23 = move (_25.0: usize);\n        StorageDead(_24);\n        StorageLive(_26);\n        _26 = core::slice::<impl [u8]>::get::<usize>(_3, 0_usize) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _27 = discriminant(_26);\n        switchInt(move _27) -> [0: bb23, 1: bb20, otherwise: bb19];\n    }\n    bb19: {\n        unreachable;\n    }\n    bb20: {\n        _33 = ((_26 as variant#1).0: &u8);\n        switchInt((*_33)) -> [0: bb23, otherwise: bb21];\n    }\n    bb21: {\n        _28 = CheckedAdd(_23, 1_usize);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _23, 1_usize) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _23 = move (_28.0: usize);\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_26);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = _2;\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _23;\n        _31 = move _32 as u32;\n        StorageDead(_32);\n        _29 = (move _30, move _31);\n        StorageDead(_31);\n        StorageDead(_30);\n        _0 = core::result::Result::Ok(move _29);\n        StorageDead(_29);\n        StorageDead(_23);\n        StorageDead(_2);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_2);\n        goto -> bb25;\n    }\n    bb25: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}