{
  "name": "path::PathBuf::_add_extension",
  "safe": true,
  "callees": {
    "path::validate_extension": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the string is valid as a file extension, or panics otherwise.\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "path::Path::file_name": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the final component of the `Path`, if there is one.\n\n If the path is a normal file, this is the file name. If it's the path of a directory, this\n is the directory name.\n\n Returns [`None`] if the path terminates in `..`.\n\n # Examples\n\n ```\n use std::path::Path;\n use std::ffi::OsStr;\n\n assert_eq!(Some(OsStr::new(\"bin\")), Path::new(\"/usr/bin/\").file_name());\n assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"tmp/foo.txt\").file_name());\n assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.\").file_name());\n assert_eq!(Some(OsStr::new(\"foo.txt\")), Path::new(\"foo.txt/.//\").file_name());\n assert_eq!(None, Path::new(\"foo.txt/..\").file_name());\n assert_eq!(None, Path::new(\"/\").file_name());\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "ffi::os_str::OsStr::as_encoded_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n string slice, use the [`OsStr::from_encoded_bytes_unchecked`] function.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n be treated as opaque and only comparable within the same Rust version built for the same\n target platform.  For example, sending the slice over the network or storing it in a file\n will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n and [`std::ffi`] for platform-specific, specified conversions.\n\n [`std::ffi`]: crate::ffi\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::num::<impl usize>::wrapping_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) subtraction. Computes `self - rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "ffi::os_str::OsString::truncate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Truncate the `OsString` to the specified length.\n\n # Panics\n Panics if `len` does not lie on a valid `OsStr` boundary\n (as described in [`OsStr::slice_encoded_bytes`]).\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "ffi::os_str::OsString::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves the minimum capacity for at least `additional` more capacity to\n be inserted in the given `OsString`. Does nothing if the capacity is\n already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`reserve`] if future insertions are expected.\n\n [`reserve`]: OsString::reserve\n\n See the main `OsString` documentation information about encoding and capacity units.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut s = OsString::new();\n s.reserve_exact(10);\n assert!(s.capacity() >= 10);\n ```\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "ffi::os_str::OsString::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends the string with the given <code>&[OsStr]</code> slice.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut os_string = OsString::from(\"foo\");\n os_string.push(\"bar\");\n assert_eq!(&os_string, \"foobar\");\n ```\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "ffi::os_str::OsString::extend_from_slice_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Provides plumbing to `Vec::extend_from_slice` without giving full\n mutable access to the `Vec`.\n\n # Safety\n\n The slice must be valid for the platform encoding (as described in\n [`OsStr::from_encoded_bytes_unchecked`]).\n\n This bypasses the encoding-dependent surrogate joining, so either\n `self` must not end with a leading surrogate half, or `other` must not\n start with a trailing surrogate half.\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "path::PathBuf": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2802, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2803, kind: RigidTy(Adt(AdtDef(DefId { id: 5587, name: \"ffi::os_str::OsStr\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "ffi::os_str::OsString": [
      "Ref",
      "MutRef"
    ]
  },
  "path": 2479,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:1707:5: 1732:6",
  "src": "fn _add_extension(&mut self, extension: &OsStr) -> bool {\n        validate_extension(extension);\n\n        let file_name = match self.file_name() {\n            None => return false,\n            Some(f) => f.as_encoded_bytes(),\n        };\n\n        let new = extension.as_encoded_bytes();\n        if !new.is_empty() {\n            // truncate until right after the file name\n            // this is necessary for trimming the trailing separator\n            let end_file_name = file_name[file_name.len()..].as_ptr().addr();\n            let start = self.inner.as_encoded_bytes().as_ptr().addr();\n            self.inner.truncate(end_file_name.wrapping_sub(start));\n\n            // append the new extension\n            self.inner.reserve_exact(new.len() + 1);\n            self.inner.push(\".\");\n            // SAFETY: Since a UTF-8 string was just pushed, it is not possible\n            // for the buffer to end with a surrogate half.\n            unsafe { self.inner.extend_from_slice_unchecked(new) };\n        }\n\n        true\n    }",
  "mir": "fn path::PathBuf::_add_extension(_1: &mut path::PathBuf, _2: &ffi::os_str::OsStr) -> bool {\n    let mut _0: bool;\n    let  _3: ();\n    let  _4: &[u8];\n    let mut _5: core::option::Option<&ffi::os_str::OsStr>;\n    let  _6: &path::Path;\n    let mut _7: &path::PathBuf;\n    let mut _8: isize;\n    let  _9: &ffi::os_str::OsStr;\n    let  _10: &[u8];\n    let mut _11: bool;\n    let  _12: usize;\n    let mut _13: *const u8;\n    let  _14: &[u8];\n    let mut _15: core::ops::RangeFrom<usize>;\n    let mut _16: usize;\n    let  _17: usize;\n    let mut _18: *const u8;\n    let  _19: &[u8];\n    let  _20: &ffi::os_str::OsStr;\n    let mut _21: &ffi::os_str::OsString;\n    let  _22: ();\n    let mut _23: &mut ffi::os_str::OsString;\n    let mut _24: usize;\n    let  _25: ();\n    let mut _26: &mut ffi::os_str::OsString;\n    let mut _27: usize;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let  _30: ();\n    let mut _31: &mut ffi::os_str::OsString;\n    let  _32: ();\n    let mut _33: &mut ffi::os_str::OsString;\n    debug self => _1;\n    debug extension => _2;\n    debug file_name => _4;\n    debug f => _9;\n    debug new => _10;\n    debug end_file_name => _12;\n    debug start => _17;\n    bb0: {\n        _3 = path::validate_extension(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = <path::PathBuf as core::ops::Deref>::deref(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = path::Path::file_name(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb6, 1: bb5, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _9 = ((_5 as variant#1).0: &ffi::os_str::OsStr);\n        _4 = ffi::os_str::OsStr::as_encoded_bytes(_9) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        _0 = false;\n        StorageDead(_5);\n        goto -> bb26;\n    }\n    bb7: {\n        StorageDead(_5);\n        _10 = ffi::os_str::OsStr::as_encoded_bytes(_2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_11);\n        _11 = core::slice::<impl [u8]>::is_empty(_10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _11) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        goto -> bb25;\n    }\n    bb11: {\n        StorageLive(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = PtrMetadata(_4);\n        _15 = RangeFrom(move _16);\n        StorageDead(_16);\n        _14 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_4, move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        _13 = core::slice::<impl [u8]>::as_ptr(_14) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _12 = core::ptr::const_ptr::<impl *const u8>::addr(move _13) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_13);\n        StorageLive(_18);\n        StorageLive(_21);\n        _21 = &((*_1).0: ffi::os_str::OsString);\n        _20 = <ffi::os_str::OsString as core::ops::Deref>::deref(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        _19 = ffi::os_str::OsStr::as_encoded_bytes(_20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _18 = core::slice::<impl [u8]>::as_ptr(_19) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _17 = core::ptr::const_ptr::<impl *const u8>::addr(move _18) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_18);\n        StorageLive(_23);\n        _23 = &mut ((*_1).0: ffi::os_str::OsString);\n        StorageLive(_24);\n        _24 = core::num::<impl usize>::wrapping_sub(_12, _17) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _22 = ffi::os_str::OsString::truncate(move _23, move _24) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_26);\n        _26 = &mut ((*_1).0: ffi::os_str::OsString);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = PtrMetadata(_10);\n        _29 = CheckedAdd(_28, 1_usize);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _28, 1_usize) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _27 = move (_29.0: usize);\n        StorageDead(_28);\n        _25 = ffi::os_str::OsString::reserve_exact(move _26, move _27) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_31);\n        _31 = &mut ((*_1).0: ffi::os_str::OsString);\n        _30 = ffi::os_str::OsString::push::<&str>(move _31, \".\") -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_31);\n        StorageLive(_33);\n        _33 = &mut ((*_1).0: ffi::os_str::OsString);\n        _32 = ffi::os_str::OsString::extend_from_slice_unchecked(move _33, _10) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_33);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_11);\n        _0 = true;\n        goto -> bb26;\n    }\n    bb26: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}