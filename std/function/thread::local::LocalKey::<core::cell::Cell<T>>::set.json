{
  "name": "thread::local::LocalKey::<core::cell::Cell<T>>::set",
  "safe": true,
  "callees": {
    "core::cell::Cell::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `Cell` containing the given value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n ```\n",
      "adt": {}
    },
    "thread::local::LocalKey::<T>::initialize_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a reference to the value in this TLS key, initializing it with\n `init` if it wasn't already initialized on this thread.\n\n If `init` was used to initialize the thread local variable, `None` is\n passed as the first argument to `f`. If it was already initialized,\n `Some(init)` is passed to `f`.\n\n # Panics\n\n This function will panic if the key currently has its destructor\n running, and it **may** panic if the destructor has previously been run\n for this thread.\n",
      "adt": {
        "thread::local::LocalKey": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::cell::Cell": [
      "Plain"
    ],
    "thread::local::LocalKey": [
      "Ref"
    ]
  },
  "path": 4523,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:573:5: 582:6",
  "src": "pub fn set(&'static self, value: T) {\n        self.initialize_with(Cell::new(value), |value, cell| {\n            if let Some(value) = value {\n                // The cell was already initialized, so `value` wasn't used to\n                // initialize it. So we overwrite the current value with the\n                // new one instead.\n                cell.set(value.into_inner());\n            }\n        });\n    }",
  "mir": "fn thread::local::LocalKey::<core::cell::Cell<T>>::set(_1: &thread::local::LocalKey<core::cell::Cell<T>>, _2: T) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: core::cell::Cell<T>;\n    debug self => _1;\n    debug value => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = core::cell::Cell::<T>::new(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = thread::local::LocalKey::<core::cell::Cell<T>>::initialize_with::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:574:48: 574:61}, ()>(_1, move _4, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:574:48: 574:61}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Sets or initializes the contained value.\n\n Unlike the other methods, this will *not* run the lazy initializer of\n the thread local. Instead, it will be directly initialized with the\n given value if it wasn't initialized yet.\n\n # Panics\n\n Panics if the key currently has its destructor running,\n and it **may** panic if the destructor has previously been run for this thread.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n thread_local! {\n     static X: Cell<i32> = panic!(\"!\");\n }\n\n // Calling X.get() here would result in a panic.\n\n X.set(123); // But X.set() is fine, as it skips the initializer above.\n\n assert_eq!(X.get(), 123);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}