{
  "name": "sync::reentrant_lock::ReentrantLock::<T>::lock",
  "safe": true,
  "callees": {
    "thread::current::current_id": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the unique identifier of the thread which invokes it.\n\n Calling this function may be more efficient than accessing the current\n thread id through the current thread handle. i.e. `thread::current().id()`.\n\n This function will always succeed, will always return the same value for\n one thread and is guaranteed not to call the global allocator.\n\n # Examples\n\n ```\n #![feature(current_thread_id)]\n\n use std::thread;\n\n let other_thread = thread::spawn(|| {\n     thread::current_id()\n });\n\n let other_thread_id = other_thread.join().unwrap();\n assert_ne!(thread::current_id(), other_thread_id);\n ```\n",
      "adt": {
        "thread::id::ThreadId": "Constructor"
      }
    },
    "sync::reentrant_lock::Tid::contains": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "thread::id::ThreadId": "ImmutableAsArgument",
        "sync::reentrant_lock::Tid": "ImmutableAsArgument"
      }
    },
    "sync::reentrant_lock::ReentrantLock::<T>::increment_lock_count": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::reentrant_lock::ReentrantLock": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n # Panics\n\n Panics if the value is a [`None`] with a custom panic message provided by\n `msg`.\n\n # Examples\n\n ```\n let x = Some(\"value\");\n assert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n x.expect(\"fruits are healthy\"); // panics with `fruits are healthy`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Option` should be `Some`.\n\n ```should_panic\n # let slice: &[u8] = &[];\n let item = slice.get(0)\n     .expect(\"slice should not be empty\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our\n recommendation please refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    },
    "sys::sync::mutex::futex::Mutex::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::mutex::futex::Mutex": "ImmutableAsArgument"
      }
    },
    "sync::reentrant_lock::Tid::set": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::reentrant_lock::Tid": "ImmutableAsArgument"
      }
    },
    "core::cell::UnsafeCell::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the wrapped value.\n\n This can be cast to a pointer of any kind. When creating references, you must uphold the\n aliasing rules; see [the type-level docs][UnsafeCell#aliasing-rules] for more discussion and\n caveats.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let uc = UnsafeCell::new(5);\n\n let five = uc.get();\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    }
  },
  "adts": {
    "thread::id::ThreadId": [
      "Plain"
    ],
    "sync::reentrant_lock::Tid": [
      "Ref"
    ],
    "sync::reentrant_lock::ReentrantLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "sys::sync::mutex::futex::Mutex": [
      "Ref"
    ],
    "core::cell::UnsafeCell": [
      "Ref"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "sync::reentrant_lock::ReentrantLockGuard": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::reentrant_lock::ReentrantLock::<T>::lock"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/reentrant_lock.rs:284:5: 300:6",
  "src": "pub fn lock(&self) -> ReentrantLockGuard<'_, T> {\n        let this_thread = current_id();\n        // Safety: We only touch lock_count when we own the inner mutex.\n        // Additionally, we only call `self.owner.set()` while holding\n        // the inner mutex, so no two threads can call it concurrently.\n        unsafe {\n            if self.owner.contains(this_thread) {\n                self.increment_lock_count().expect(\"lock count overflow in reentrant mutex\");\n            } else {\n                self.mutex.lock();\n                self.owner.set(Some(this_thread));\n                debug_assert_eq!(*self.lock_count.get(), 0);\n                *self.lock_count.get() = 1;\n            }\n        }\n        ReentrantLockGuard { lock: self }\n    }",
  "mir": "fn sync::reentrant_lock::ReentrantLock::<T>::lock(_1: &sync::reentrant_lock::ReentrantLock<T>) -> sync::reentrant_lock::ReentrantLockGuard<'_, T> {\n    let mut _0: sync::reentrant_lock::ReentrantLockGuard<'_, T>;\n    let  _2: thread::id::ThreadId;\n    let mut _3: bool;\n    let mut _4: &sync::reentrant_lock::Tid;\n    let  _5: ();\n    let mut _6: core::option::Option<()>;\n    let mut _7: &str;\n    let  _8: ();\n    let mut _9: &sys::sync::mutex::futex::Mutex;\n    let  _10: ();\n    let mut _11: &sync::reentrant_lock::Tid;\n    let mut _12: core::option::Option<thread::id::ThreadId>;\n    let mut _13: (&u32, &u32);\n    let mut _14: &u32;\n    let  _15: *mut u32;\n    let mut _16: &core::cell::UnsafeCell<u32>;\n    let mut _17: &u32;\n    let  _18: &u32;\n    let  _19: &u32;\n    let mut _20: bool;\n    let mut _21: u32;\n    let mut _22: u32;\n    let  _23: core::panicking::AssertKind;\n    let  _24: !;\n    let mut _25: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _26: *mut u32;\n    let mut _27: &core::cell::UnsafeCell<u32>;\n    let mut _28: *const ();\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: *const ();\n    let mut _34: usize;\n    let mut _35: usize;\n    let mut _36: usize;\n    let mut _37: bool;\n    let mut _38: *const ();\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: bool;\n    let mut _42: bool;\n    let mut _43: *const ();\n    let mut _44: usize;\n    let mut _45: bool;\n    let mut _46: bool;\n    let mut _47: bool;\n    let mut _48: bool;\n    debug self => _1;\n    debug this_thread => _2;\n    debug left_val => _18;\n    debug right_val => _19;\n    debug kind => _23;\n    bb0: {\n        _2 = thread::current::current_id() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).1: sync::reentrant_lock::Tid);\n        _3 = sync::reentrant_lock::Tid::contains(move _4, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _3) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = sync::reentrant_lock::ReentrantLock::<T>::increment_lock_count(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = \"lock count overflow in reentrant mutex\";\n        _5 = core::option::Option::<()>::expect(move _6, move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb13;\n    }\n    bb6: {\n        StorageDead(_4);\n        StorageLive(_9);\n        _9 = &((*_1).0: sys::sync::mutex::futex::Mutex);\n        _8 = sys::sync::mutex::futex::Mutex::lock(move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageLive(_11);\n        _11 = &((*_1).1: sync::reentrant_lock::Tid);\n        StorageLive(_12);\n        _12 = core::option::Option::Some(_2);\n        _10 = sync::reentrant_lock::Tid::set(move _11, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &((*_1).2: core::cell::UnsafeCell<u32>);\n        _15 = core::cell::UnsafeCell::<u32>::get(move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        _33 = _15 as *const ();\n        _34 = _33 as usize;\n        _35 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _36 = BitAnd(_34, _35);\n        _37 = Eq(_36, 0_usize);\n        assert(_37, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _34) -> [success: bb15, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_15);\n        StorageDead(_13);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &((*_1).2: core::cell::UnsafeCell<u32>);\n        _26 = core::cell::UnsafeCell::<u32>::get(move _27) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _23 = core::panicking::AssertKind::Eq;\n        StorageLive(_25);\n        _25 = core::option::Option::None;\n        _24 = core::panicking::assert_failed::<u32, u32>(_23, _18, _19, move _25) -> unwind unreachable;\n    }\n    bb12: {\n        StorageDead(_27);\n        _28 = _26 as *const ();\n        _29 = _28 as usize;\n        _30 = Sub(<u32 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _31 = BitAnd(_29, _30);\n        _32 = Eq(_31, 0_usize);\n        assert(_32, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<u32 as core::mem::SizedTypeProperties>::ALIGN, _29) -> [success: bb14, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_3);\n        _0 = ReentrantLockGuard(_1);\n        return;\n    }\n    bb14: {\n        _43 = _26 as *const ();\n        _44 = _43 as usize;\n        _45 = Ne(<u32 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _46 = Eq(_44, 0_usize);\n        _47 = BitAnd(_46, _45);\n        _48 = Not(_47);\n        assert(_48, \"null pointer dereference occurred\") -> [success: bb17, unwind unreachable];\n    }\n    bb15: {\n        _38 = _15 as *const ();\n        _39 = _38 as usize;\n        _40 = Eq(_39, 0_usize);\n        _41 = BitAnd(_40, true);\n        _42 = Not(_41);\n        assert(_42, \"null pointer dereference occurred\") -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        _14 = &(*_15);\n        StorageLive(_17);\n        _17 = sync::reentrant_lock::ReentrantLock::<T>::lock::promoted[0];\n        _13 = (move _14, move _17);\n        StorageDead(_17);\n        StorageDead(_14);\n        _18 = (_13.0: &u32);\n        _19 = (_13.1: &u32);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = (*_18);\n        StorageLive(_22);\n        _22 = (*_19);\n        _20 = Eq(move _21, move _22);\n        switchInt(move _20) -> [0: bb11, otherwise: bb10];\n    }\n    bb17: {\n        (*_26) = 1_u32;\n        StorageDead(_26);\n        goto -> bb13;\n    }\n}\n",
  "doc": " Acquires the lock, blocking the current thread until it is able to do\n so.\n\n This function will block the caller until it is available to acquire\n the lock. Upon returning, the thread is the only thread with the lock\n held. When the thread calling this method already holds the lock, the\n call succeeds without blocking.\n\n # Examples\n\n ```\n #![feature(reentrant_lock)]\n use std::cell::Cell;\n use std::sync::{Arc, ReentrantLock};\n use std::thread;\n\n let lock = Arc::new(ReentrantLock::new(Cell::new(0)));\n let c_lock = Arc::clone(&lock);\n\n thread::spawn(move || {\n     c_lock.lock().set(10);\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(lock.lock().get(), 10);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}