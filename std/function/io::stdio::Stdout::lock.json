{
  "name": "io::stdio::Stdout::lock",
  "safe": true,
  "callees": {
    "sync::reentrant_lock::ReentrantLock::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires the lock, blocking the current thread until it is able to do\n so.\n\n This function will block the caller until it is available to acquire\n the lock. Upon returning, the thread is the only thread with the lock\n held. When the thread calling this method already holds the lock, the\n call succeeds without blocking.\n\n # Examples\n\n ```\n #![feature(reentrant_lock)]\n use std::cell::Cell;\n use std::sync::{Arc, ReentrantLock};\n use std::thread;\n\n let lock = Arc::new(ReentrantLock::new(Cell::new(0)));\n let c_lock = Arc::clone(&lock);\n\n thread::spawn(move || {\n     c_lock.lock().set(10);\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(lock.lock().get(), 10);\n ```\n",
      "adt": {
        "sync::reentrant_lock::ReentrantLock": "ImmutableAsArgument",
        "sync::reentrant_lock::ReentrantLockGuard": "Constructor"
      }
    }
  },
  "adts": {
    "sync::reentrant_lock::ReentrantLock": [
      "Ref"
    ],
    "io::stdio::Stdout": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::reentrant_lock::ReentrantLockGuard": [
      "Plain"
    ],
    "io::stdio::StdoutLock": [
      "Plain"
    ]
  },
  "path": 1644,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:765:5: 770:6",
  "src": "pub fn lock(&self) -> StdoutLock<'static> {\n        // Locks this handle with 'static lifetime. This depends on the\n        // implementation detail that the underlying `ReentrantMutex` is\n        // static.\n        StdoutLock { inner: self.inner.lock() }\n    }",
  "mir": "fn io::stdio::Stdout::lock(_1: &io::stdio::Stdout) -> io::stdio::StdoutLock<'_> {\n    let mut _0: io::stdio::StdoutLock<'_>;\n    let mut _2: sync::reentrant_lock::ReentrantLockGuard<'_, core::cell::RefCell<io::buffered::linewriter::LineWriter<io::stdio::StdoutRaw>>>;\n    let mut _3: &sync::reentrant_lock::ReentrantLock<core::cell::RefCell<io::buffered::linewriter::LineWriter<io::stdio::StdoutRaw>>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _3 = ((*_1).0: &sync::reentrant_lock::ReentrantLock<core::cell::RefCell<io::buffered::linewriter::LineWriter<io::stdio::StdoutRaw>>>);\n        _2 = sync::reentrant_lock::ReentrantLock::<core::cell::RefCell<io::buffered::linewriter::LineWriter<io::stdio::StdoutRaw>>>::lock(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = StdoutLock(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Locks this handle to the standard output stream, returning a writable\n guard.\n\n The lock is released when the returned lock goes out of scope. The\n returned guard also implements the `Write` trait for writing data.\n\n # Examples\n\n ```no_run\n use std::io::{self, Write};\n\n fn main() -> io::Result<()> {\n     let mut stdout = io::stdout().lock();\n\n     stdout.write_all(b\"hello world\")?;\n\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}