{
  "name": "<io::buffered::bufwriter::BufWriter<I> as io::copy::BufferedWriterSpec>::copy_from",
  "safe": true,
  "callees": {
    "io::buffered::bufwriter::BufWriter::<W>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes the internal buffer can hold without flushing.\n\n # Examples\n\n ```no_run\n use std::io::BufWriter;\n use std::net::TcpStream;\n\n let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n\n // Check the capacity of the inner buffer\n let capacity = buf_writer.capacity();\n // Calculate how many bytes can be written without flushing\n let without_flush = capacity - buf_writer.buffer().len();\n ```\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "ImmutableAsArgument"
      }
    },
    "io::copy::stack_buffer_copy": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::buffer_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the internal buffer.\n\n This can be used to write data directly into the buffer without triggering writers\n to the underlying writer.\n\n That the buffer is a `Vec` is an implementation detail.\n Callers should not modify the capacity as there currently is no public API to do so\n and thus any capacity changes would be unexpected by the user.\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::spare_capacity_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the remaining spare capacity of the vector as a slice of\n `MaybeUninit<T>`.\n\n The returned slice can be used to fill the vector with data (e.g. by\n reading from a file) before marking the data as initialized using the\n [`set_len`] method.\n\n [`set_len`]: Vec::set_len\n\n # Examples\n\n ```\n // Allocate vector big enough for 10 elements.\n let mut v = Vec::with_capacity(10);\n\n // Fill in the first 3 elements.\n let uninit = v.spare_capacity_mut();\n uninit[0].write(0);\n uninit[1].write(1);\n uninit[2].write(2);\n\n // Mark the first 3 elements of the vector as being initialized.\n unsafe {\n     v.set_len(3);\n }\n\n assert_eq!(&v, &[0, 1, 2]);\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "core::io::BorrowedBuf::<'data>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total capacity of the buffer.\n",
      "adt": {}
    },
    "core::io::BorrowedBuf::<'data>::unfilled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a cursor over the unfilled part of the buffer.\n",
      "adt": {}
    },
    "core::io::BorrowedCursor::<'a>::reborrow": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reborrows this cursor by cloning it with a smaller lifetime.\n\n Since a cursor maintains unique access to its underlying buffer, the borrowed cursor is\n not accessible while the new cursor exists.\n",
      "adt": {}
    },
    "io::Read::read_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Pull some bytes from this source into the specified buffer.\n\n This is equivalent to the [`read`](Read::read) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to allow use\n with uninitialized buffers. The new data will be appended to any existing contents of `buf`.\n\n The default implementation delegates to `read`.\n\n This method makes it possible to return both data and an error but it is advised against.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "io::error::Error::is_interrupted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::io::BorrowedCursor::<'a>::written": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes written to the `BorrowedBuf` this cursor was created from.\n\n In particular, the count returned is shared by all reborrows of the cursor.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "io::buffered::bufwriter::BufWriter": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::io::BorrowedBuf": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "core::io::BorrowedCursor": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "io::error::Error": [
      "Ref",
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": 1333,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/copy.rs:211:5: 245:6",
  "src": "fn copy_from<R: Read + ?Sized>(&mut self, reader: &mut R) -> Result<u64> {\n        if self.capacity() < DEFAULT_BUF_SIZE {\n            return stack_buffer_copy(reader, self);\n        }\n\n        let mut len = 0;\n\n        loop {\n            let buf = self.buffer_mut();\n            let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n\n            if read_buf.capacity() >= DEFAULT_BUF_SIZE {\n                let mut cursor = read_buf.unfilled();\n                match reader.read_buf(cursor.reborrow()) {\n                    Ok(()) => {\n                        let bytes_read = cursor.written();\n                        if bytes_read == 0 {\n                            return Ok(len);\n                        }\n                        len += bytes_read as u64;\n\n                        // SAFETY: BorrowedBuf guarantees all of its filled bytes are init\n                        unsafe { buf.set_len(buf.len() + bytes_read) };\n\n                        // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                        // This will occur if the reader returns short reads\n                    }\n                    Err(ref e) if e.is_interrupted() => {}\n                    Err(e) => return Err(e),\n                }\n            } else {\n                self.flush_buf()?;\n            }\n        }\n    }",
  "mir": "fn <io::buffered::bufwriter::BufWriter<I> as io::copy::BufferedWriterSpec>::copy_from(_1: &mut io::buffered::bufwriter::BufWriter<I>, _2: &mut R) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: &io::buffered::bufwriter::BufWriter<I>;\n    let mut _6: u64;\n    let  _7: &mut alloc_crate::vec::Vec<u8>;\n    let mut _8: core::io::BorrowedBuf<'_>;\n    let mut _9: &mut [core::mem::MaybeUninit<u8>];\n    let mut _10: bool;\n    let mut _11: usize;\n    let mut _12: &core::io::BorrowedBuf<'_>;\n    let mut _13: core::io::BorrowedCursor<'_>;\n    let mut _14: &mut core::io::BorrowedBuf<'_>;\n    let mut _15: core::result::Result<(), io::error::Error>;\n    let mut _16: core::io::BorrowedCursor<'_>;\n    let mut _17: &mut core::io::BorrowedCursor<'_>;\n    let mut _18: isize;\n    let  _19: usize;\n    let mut _20: &core::io::BorrowedCursor<'_>;\n    let mut _21: u64;\n    let mut _22: u64;\n    let mut _23: (u64, bool);\n    let  _24: ();\n    let mut _25: usize;\n    let mut _26: usize;\n    let mut _27: &alloc_crate::vec::Vec<u8>;\n    let mut _28: (usize, bool);\n    let  _29: &io::error::Error;\n    let  _30: &&io::error::Error;\n    let mut _31: bool;\n    let  _32: io::error::Error;\n    let mut _33: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _34: core::result::Result<(), io::error::Error>;\n    let mut _35: isize;\n    let  _36: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _37: &io::error::Error;\n    let mut _38: bool;\n    let mut _39: isize;\n    debug self => _1;\n    debug reader => _2;\n    debug len => _6;\n    debug buf => _7;\n    debug read_buf => _8;\n    debug cursor => _13;\n    debug bytes_read => _19;\n    debug e => _29;\n    debug e => _30;\n    debug e => _32;\n    debug residual => _36;\n    debug val => ();\n    bb0: {\n        _38 = false;\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = io::buffered::bufwriter::BufWriter::<I>::capacity(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = Lt(move _4, io::DEFAULT_BUF_SIZE);\n        switchInt(move _3) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        _0 = io::copy::stack_buffer_copy::<R, io::buffered::bufwriter::BufWriter<I>>(_2, _1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        goto -> bb35;\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        _6 = 0_u64;\n        goto -> bb5;\n    }\n    bb5: {\n        _7 = io::buffered::bufwriter::BufWriter::<I>::buffer_mut(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_8);\n        _9 = alloc_crate::vec::Vec::<u8>::spare_capacity_mut(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _8 = <&mut [core::mem::MaybeUninit<u8>] as core::convert::Into<core::io::BorrowedBuf<'_>>>::into(_9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_8;\n        _11 = core::io::BorrowedBuf::<'_>::capacity(move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        _10 = Ge(move _11, io::DEFAULT_BUF_SIZE);\n        switchInt(move _10) -> [0: bb27, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &mut _8;\n        _13 = core::io::BorrowedBuf::<'_>::unfilled(move _14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _13;\n        _16 = core::io::BorrowedCursor::<'_>::reborrow(move _17) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_17);\n        _15 = <R as io::Read>::read_buf(_2, move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _38 = true;\n        StorageDead(_16);\n        _18 = discriminant(_15);\n        switchInt(move _18) -> [0: bb16, 1: bb15, otherwise: bb14];\n    }\n    bb14: {\n        unreachable;\n    }\n    bb15: {\n        StorageLive(_30);\n        StorageLive(_29);\n        _29 = &((_15 as variant#1).0: io::error::Error);\n        _30 = &_29;\n        StorageLive(_31);\n        _37 = (*_30);\n        _31 = io::error::Error::is_interrupted(_37) -> [return: bb24, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_20);\n        _20 = &_13;\n        _19 = core::io::BorrowedCursor::<'_>::written(move _20) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_20);\n        switchInt(_19) -> [0: bb18, otherwise: bb19];\n    }\n    bb18: {\n        StorageLive(_21);\n        _21 = _6;\n        _0 = core::result::Result::Ok(move _21);\n        StorageDead(_21);\n        goto -> bb40;\n    }\n    bb19: {\n        StorageLive(_22);\n        _22 = _19 as u64;\n        _23 = CheckedAdd(_6, _22);\n        assert(!move (_23.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _6, move _22) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        _6 = move (_23.0: u64);\n        StorageDead(_22);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &(*_7);\n        _26 = alloc_crate::vec::Vec::<u8>::len(move _27) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_27);\n        _28 = CheckedAdd(_26, _19);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _26, _19) -> [success: bb22, unwind unreachable];\n    }\n    bb22: {\n        _25 = move (_28.0: usize);\n        StorageDead(_26);\n        _24 = alloc_crate::vec::Vec::<u8>::set_len(_7, move _25) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_25);\n        goto -> bb39;\n    }\n    bb24: {\n        switchInt(move _31) -> [0: bb26, otherwise: bb25];\n    }\n    bb25: {\n        StorageDead(_31);\n        StorageDead(_29);\n        StorageDead(_30);\n        goto -> bb39;\n    }\n    bb26: {\n        StorageDead(_31);\n        StorageDead(_29);\n        StorageDead(_30);\n        _38 = false;\n        _32 = move ((_15 as variant#1).0: io::error::Error);\n        _0 = core::result::Result::Err(_32);\n        goto -> bb40;\n    }\n    bb27: {\n        StorageDead(_11);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = io::buffered::bufwriter::BufWriter::<I>::flush_buf(_1) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _33 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _34) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_34);\n        _35 = discriminant(_33);\n        switchInt(move _35) -> [0: bb30, 1: bb31, otherwise: bb14];\n    }\n    bb30: {\n        StorageDead(_33);\n        goto -> bb33;\n    }\n    bb31: {\n        _36 = move ((_33 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_36) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_33);\n        goto -> bb34;\n    }\n    bb33: {\n        StorageDead(_10);\n        StorageDead(_8);\n        goto -> bb5;\n    }\n    bb34: {\n        StorageDead(_10);\n        StorageDead(_8);\n        StorageDead(_6);\n        goto -> bb35;\n    }\n    bb35: {\n        return;\n    }\n    bb36: {\n        _38 = false;\n        StorageDead(_15);\n        StorageDead(_13);\n        goto -> bb33;\n    }\n    bb37: {\n        switchInt(_38) -> [0: bb36, otherwise: bb38];\n    }\n    bb38: {\n        drop(((_15 as variant#1).0: io::error::Error)) -> [return: bb36, unwind unreachable];\n    }\n    bb39: {\n        _39 = discriminant(_15);\n        switchInt(move _39) -> [1: bb37, 0: bb36, otherwise: bb14];\n    }\n    bb40: {\n        _38 = false;\n        StorageDead(_15);\n        StorageDead(_13);\n        goto -> bb34;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}