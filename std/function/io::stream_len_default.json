{
  "name": "io::stream_len_default",
  "safe": true,
  "callees": {
    "io::Seek::stream_position": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current seek position from the start of the stream.\n\n This is equivalent to `self.seek(SeekFrom::Current(0))`.\n\n # Example\n\n ```no_run\n use std::{\n     io::{self, BufRead, BufReader, Seek},\n     fs::File,\n };\n\n fn main() -> io::Result<()> {\n     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n\n     let before = f.stream_position()?;\n     f.read_line(&mut String::new())?;\n     let after = f.stream_position()?;\n\n     println!(\"The first line was {} bytes long\", after - before);\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::Seek::seek": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Seek to an offset, in bytes, in a stream.\n\n A seek beyond the end of a stream is allowed, but behavior is defined\n by the implementation.\n\n If the seek operation completed successfully,\n this method returns the new position from the start of the stream.\n That position can be used later with [`SeekFrom::Start`].\n\n # Errors\n\n Seeking can fail, for example because it might involve flushing a buffer.\n\n Seeking to a negative offset is considered an error.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "io::SeekFrom": [
      "Plain"
    ]
  },
  "path": 1736,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/mod.rs:2181:1: 2192:2",
  "src": "pub(crate) fn stream_len_default<T: Seek + ?Sized>(self_: &mut T) -> Result<u64> {\n    let old_pos = self_.stream_position()?;\n    let len = self_.seek(SeekFrom::End(0))?;\n\n    // Avoid seeking a third time when we were already at the end of the\n    // stream. The branch is usually way cheaper than a seek operation.\n    if old_pos != len {\n        self_.seek(SeekFrom::Start(old_pos))?;\n    }\n\n    Ok(len)\n}",
  "mir": "fn io::stream_len_default(_1: &mut T) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let mut _2: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _3: core::result::Result<u64, io::error::Error>;\n    let mut _4: isize;\n    let  _5: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _6: u64;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _8: core::result::Result<u64, io::error::Error>;\n    let mut _9: io::SeekFrom;\n    let mut _10: isize;\n    let  _11: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _12: u64;\n    let mut _13: bool;\n    let mut _14: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _15: core::result::Result<u64, io::error::Error>;\n    let mut _16: io::SeekFrom;\n    let mut _17: isize;\n    let  _18: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _19: u64;\n    debug self_ => _1;\n    debug old_pos => _6;\n    debug residual => _5;\n    debug val => _6;\n    debug len => _12;\n    debug residual => _11;\n    debug val => _12;\n    debug residual => _18;\n    debug val => _19;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = <T as io::Seek>::stream_position(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _6 = ((_2 as variant#0).0: u64);\n        StorageDead(_2);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = io::SeekFrom::End(0_i64);\n        _8 = <T as io::Seek>::seek(_1, move _9) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _5 = move ((_2 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_2);\n        goto -> bb21;\n    }\n    bb7: {\n        StorageDead(_9);\n        _7 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        _10 = discriminant(_7);\n        switchInt(move _10) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        _12 = ((_7 as variant#0).0: u64);\n        StorageDead(_7);\n        StorageLive(_13);\n        _13 = Ne(_6, _12);\n        switchInt(move _13) -> [0: bb18, otherwise: bb12];\n    }\n    bb10: {\n        _11 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_7);\n        goto -> bb20;\n    }\n    bb12: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = io::SeekFrom::Start(_6);\n        _15 = <T as io::Seek>::seek(_1, move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        _14 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_15);\n        _17 = discriminant(_14);\n        switchInt(move _17) -> [0: bb15, 1: bb16, otherwise: bb3];\n    }\n    bb15: {\n        StorageLive(_19);\n        _19 = ((_14 as variant#0).0: u64);\n        StorageDead(_19);\n        StorageDead(_14);\n        goto -> bb19;\n    }\n    bb16: {\n        _18 = move ((_14 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_18) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb20;\n    }\n    bb18: {\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_13);\n        _0 = core::result::Result::Ok(_12);\n        goto -> bb22;\n    }\n    bb20: {\n        goto -> bb21;\n    }\n    bb21: {\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}