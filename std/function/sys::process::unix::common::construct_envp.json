{
  "name": "sys::process::unix::common::construct_envp",
  "safe": true,
  "callees": {
    "alloc_crate::collections::BTreeMap::<K, V, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the map.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut a = BTreeMap::new();\n assert_eq!(a.len(), 0);\n a.insert(1, \"a\");\n assert_eq!(a.len(), 1);\n ```\n",
      "adt": {}
    },
    "sys::process::unix::common::cstring_array::CStringArray::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `CStringArray` with enough capacity to hold `capacity`\n strings.\n",
      "adt": {
        "sys::process::unix::common::cstring_array::CStringArray": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "ffi::os_str::OsStr::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the length of this `OsStr`.\n\n Note that this does **not** return the number of bytes in the string in\n OS string form.\n\n The length returned is that of the underlying storage used by `OsStr`.\n As discussed in the [`OsString`] introduction, [`OsString`] and `OsStr`\n store strings in a form best suited for cheap inter-conversion between\n native-platform and Rust string forms, which may differ significantly\n from both of them, including in storage size and encoding.\n\n This number is simply useful for passing to other methods, like\n [`OsString::with_capacity`] to avoid reallocations.\n\n See the main `OsString` documentation information about encoding and capacity units.\n\n # Examples\n\n ```\n use std::ffi::OsStr;\n\n let os_str = OsStr::new(\"\");\n assert_eq!(os_str.len(), 0);\n\n let os_str = OsStr::new(\"foo\");\n assert_eq!(os_str.len(), 3);\n ```\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "ffi::os_str::OsString::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves the minimum capacity for at least `additional` more capacity to\n be inserted in the given `OsString`. Does nothing if the capacity is\n already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`reserve`] if future insertions are expected.\n\n [`reserve`]: OsString::reserve\n\n See the main `OsString` documentation information about encoding and capacity units.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut s = OsString::new();\n s.reserve_exact(10);\n assert!(s.capacity() >= 10);\n ```\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "ffi::os_str::OsString::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends the string with the given <code>&[OsStr]</code> slice.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut os_string = OsString::from(\"foo\");\n os_string.push(\"bar\");\n assert_eq!(&os_string, \"foobar\");\n ```\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "os::unix::ffi::os_str::OsStringExt::into_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields the underlying byte vector of this [`OsString`].\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "alloc_crate::ffi::CString::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new C-compatible string from a container of bytes.\n\n This function will consume the provided data and use the\n underlying bytes to construct a new string, ensuring that\n there is a trailing 0 byte. This trailing 0 byte will be\n appended by this function; the provided data should *not*\n contain any 0 bytes in it.\n\n # Examples\n\n ```ignore (extern-declaration)\n use std::ffi::CString;\n use std::os::raw::c_char;\n\n extern \"C\" { fn puts(s: *const c_char); }\n\n let to_print = CString::new(\"Hello!\").expect(\"CString::new failed\");\n unsafe {\n     puts(to_print.as_ptr());\n }\n ```\n\n # Errors\n\n This function will return an error if the supplied bytes contain an\n internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n the position of the nul byte.\n",
      "adt": {}
    },
    "sys::process::unix::common::cstring_array::CStringArray::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Push an additional string to the array.\n",
      "adt": {
        "sys::process::unix::common::cstring_array::CStringArray": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "alloc_crate::collections::BTreeMap": [
      "Ref",
      "Plain"
    ],
    "sys::process::unix::common::cstring_array::CStringArray": [
      "Plain",
      "MutRef"
    ],
    "alloc_crate::collections::btree_map::IntoIter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2775, kind: RigidTy(Tuple([Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }])) }), Field(0, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2775, kind: RigidTy(Tuple([Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }])) }), Field(1, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])"
    ],
    "ffi::os_str::OsString": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "alloc_crate::vec::Vec": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 979, kind: RigidTy(Adt(AdtDef(DefId { id: 4790, name: \"alloc_crate::ffi::CString\" }), GenericArgs([]))) })])"
    ],
    "alloc_crate::ffi::CString": [
      "Plain"
    ]
  },
  "path": 4115,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/common.rs:376:1: 393:2",
  "src": "fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n    let mut result = CStringArray::with_capacity(env.len());\n    for (mut k, v) in env {\n        // Reserve additional space for '=' and null terminator\n        k.reserve_exact(v.len() + 2);\n        k.push(\"=\");\n        k.push(&v);\n\n        // Add the new entry into the array\n        if let Ok(item) = CString::new(k.into_vec()) {\n            result.push(item);\n        } else {\n            *saw_nul = true;\n        }\n    }\n\n    result\n}",
  "mir": "fn sys::process::unix::common::construct_envp(_1: alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>, _2: &mut bool) -> sys::process::unix::common::cstring_array::CStringArray {\n    let mut _0: sys::process::unix::common::cstring_array::CStringArray;\n    let mut _3: sys::process::unix::common::cstring_array::CStringArray;\n    let mut _4: usize;\n    let mut _5: &alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _6: alloc_crate::collections::btree_map::IntoIter<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _7: alloc_crate::collections::btree_map::IntoIter<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _8: core::option::Option<(ffi::os_str::OsString, ffi::os_str::OsString)>;\n    let mut _9: &mut alloc_crate::collections::btree_map::IntoIter<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _10: isize;\n    let mut _11: ffi::os_str::OsString;\n    let  _12: ffi::os_str::OsString;\n    let  _13: ();\n    let mut _14: &mut ffi::os_str::OsString;\n    let mut _15: usize;\n    let mut _16: usize;\n    let  _17: &ffi::os_str::OsStr;\n    let mut _18: &ffi::os_str::OsString;\n    let mut _19: (usize, bool);\n    let  _20: ();\n    let mut _21: &mut ffi::os_str::OsString;\n    let  _22: ();\n    let mut _23: &mut ffi::os_str::OsString;\n    let mut _24: &ffi::os_str::OsString;\n    let mut _25: core::result::Result<alloc_crate::ffi::CString, alloc_crate::ffi::NulError>;\n    let mut _26: alloc_crate::vec::Vec<u8>;\n    let mut _27: ffi::os_str::OsString;\n    let mut _28: isize;\n    let  _29: alloc_crate::ffi::CString;\n    let  _30: ();\n    let mut _31: &mut sys::process::unix::common::cstring_array::CStringArray;\n    let mut _32: isize;\n    let mut _33: isize;\n    debug env => _1;\n    debug saw_nul => _2;\n    debug result => _3;\n    debug iter => _7;\n    debug k => _11;\n    debug v => _12;\n    debug item => _29;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &_1;\n        _4 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, ffi::os_str::OsString>::len(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = sys::process::unix::common::cstring_array::CStringArray::with_capacity(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = <alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString> as core::iter::IntoIterator>::into_iter(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_7);\n        _7 = move _6;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_8);\n        _9 = &mut _7;\n        _8 = <alloc_crate::collections::btree_map::IntoIter<ffi::os_str::OsString, ffi::os_str::OsString> as core::iter::Iterator>::next(_9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _10 = discriminant(_8);\n        switchInt(move _10) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        StorageLive(_11);\n        _11 = move (((_8 as variant#1).0: (ffi::os_str::OsString, ffi::os_str::OsString)).0: ffi::os_str::OsString);\n        StorageLive(_12);\n        _12 = move (((_8 as variant#1).0: (ffi::os_str::OsString, ffi::os_str::OsString)).1: ffi::os_str::OsString);\n        StorageLive(_14);\n        _14 = &mut _11;\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = &_12;\n        _17 = <ffi::os_str::OsString as core::ops::Deref>::deref(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        drop(_7) -> [return: bb21, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        _16 = ffi::os_str::OsStr::len(_17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _19 = CheckedAdd(_16, 2_usize);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _16, 2_usize) -> [success: bb11, unwind unreachable];\n    }\n    bb11: {\n        _15 = move (_19.0: usize);\n        StorageDead(_16);\n        _13 = ffi::os_str::OsString::reserve_exact(move _14, move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_21);\n        _21 = &mut _11;\n        _20 = ffi::os_str::OsString::push::<&str>(move _21, \"=\") -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageLive(_23);\n        _23 = &mut _11;\n        StorageLive(_24);\n        _24 = &_12;\n        _22 = ffi::os_str::OsString::push::<&ffi::os_str::OsString>(move _23, move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = move _11;\n        _26 = <ffi::os_str::OsString as os::unix::ffi::os_str::OsStringExt>::into_vec(move _27) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_27);\n        _25 = alloc_crate::ffi::CString::new::<alloc_crate::vec::Vec<u8>>(move _26) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_26);\n        _28 = discriminant(_25);\n        switchInt(move _28) -> [0: bb17, 1: bb24, otherwise: bb6];\n    }\n    bb17: {\n        _29 = move ((_25 as variant#0).0: alloc_crate::ffi::CString);\n        StorageLive(_31);\n        _31 = &mut _3;\n        _30 = sys::process::unix::common::cstring_array::CStringArray::push(move _31, _29) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_31);\n        _33 = discriminant(_25);\n        switchInt(move _33) -> [0: bb25, 1: bb26, otherwise: bb6];\n    }\n    bb19: {\n        drop(_12) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_8);\n        goto -> bb4;\n    }\n    bb21: {\n        StorageDead(_7);\n        StorageDead(_6);\n        _0 = move _3;\n        StorageDead(_3);\n        return;\n    }\n    bb22: {\n        StorageDead(_25);\n        (*_2) = true;\n        goto -> bb19;\n    }\n    bb23: {\n        drop(_25) -> [return: bb22, unwind unreachable];\n    }\n    bb24: {\n        _32 = discriminant(_25);\n        switchInt(move _32) -> [0: bb22, 1: bb23, otherwise: bb6];\n    }\n    bb25: {\n        StorageDead(_25);\n        goto -> bb19;\n    }\n    bb26: {\n        drop(_25) -> [return: bb25, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}