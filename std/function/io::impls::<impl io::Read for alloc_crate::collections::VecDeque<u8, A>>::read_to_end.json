{
  "name": "io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_to_end",
  "safe": true,
  "callees": {
    "alloc_crate::collections::VecDeque::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n assert_eq!(deque.len(), 0);\n deque.push_back(1);\n assert_eq!(deque.len(), 1);\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::try_reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tries to reserve capacity for at least `additional` more elements to be inserted\n in the given `Vec<T>`. The collection may reserve more space to speculatively avoid\n frequent reallocations. After calling `try_reserve`, capacity will be\n greater than or equal to `self.len() + additional` if it returns\n `Ok(())`. Does nothing if capacity is already sufficient. This method\n preserves the contents even if an error occurs.\n\n # Errors\n\n If the capacity overflows, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n\n fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     let mut output = Vec::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve(data.len())?;\n\n     // Now we know this can't OOM in the middle of our complex work\n     output.extend(data.iter().map(|&val| {\n         val * 2 + 5 // very complicated\n     }));\n\n     Ok(output)\n }\n # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::extend_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clones and appends all elements in a slice to the `Vec`.\n\n Iterates over the slice `other`, clones each element, and then appends\n it to this `Vec`. The `other` slice is traversed in-order.\n\n Note that this function is the same as [`extend`],\n except that it also works with slice elements that are Clone but not Copy.\n If Rust gets specialization this function may be deprecated.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.extend_from_slice(&[2, 3, 4]);\n assert_eq!(vec, [1, 2, 3, 4]);\n ```\n\n [`extend`]: Vec::extend\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the deque, removing all values.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n deque.push_back(1);\n deque.clear();\n assert!(deque.is_empty());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::collections::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3680, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 1482, kind: RigidTy(Adt(AdtDef(DefId { id: 5039, name: \"alloc_crate::collections::TryReserveError\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_to_end"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/impls.rs:592:5: 602:6",
  "src": "fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        // The total len is known upfront so we can reserve it in a single call.\n        let len = self.len();\n        buf.try_reserve(len)?;\n\n        let (front, back) = self.as_slices();\n        buf.extend_from_slice(front);\n        buf.extend_from_slice(back);\n        self.clear();\n        Ok(len)\n    }",
  "mir": "fn io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_to_end(_1: &mut alloc_crate::collections::VecDeque<u8, A>, _2: &mut alloc_crate::vec::Vec<u8>) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let  _3: usize;\n    let mut _4: &alloc_crate::collections::VecDeque<u8, A>;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>;\n    let mut _6: core::result::Result<(), alloc_crate::collections::TryReserveError>;\n    let mut _7: isize;\n    let  _8: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>;\n    let  _9: &[u8];\n    let  _10: &[u8];\n    let mut _11: (&[u8], &[u8]);\n    let mut _12: &alloc_crate::collections::VecDeque<u8, A>;\n    let  _13: ();\n    let  _14: ();\n    let  _15: ();\n    debug self => _1;\n    debug buf => _2;\n    debug len => _3;\n    debug residual => _8;\n    debug val => ();\n    debug front => _9;\n    debug back => _10;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = alloc_crate::collections::VecDeque::<u8, A>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = alloc_crate::vec::Vec::<u8>::try_reserve(_2, _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _5 = <core::result::Result<(), alloc_crate::collections::TryReserveError> as core::ops::Try>::branch(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &(*_1);\n        _11 = alloc_crate::collections::VecDeque::<u8, A>::as_slices(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _8 = move ((_5 as variant#1).0: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>>::from_residual(_8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_5);\n        goto -> bb12;\n    }\n    bb8: {\n        StorageDead(_12);\n        _9 = (_11.0: &[u8]);\n        _10 = (_11.1: &[u8]);\n        StorageDead(_11);\n        _13 = alloc_crate::vec::Vec::<u8>::extend_from_slice(_2, _9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _14 = alloc_crate::vec::Vec::<u8>::extend_from_slice(_2, _10) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _15 = alloc_crate::collections::VecDeque::<u8, A>::clear(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _0 = core::result::Result::Ok(_3);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}