{
  "name": "fs::OpenOptions::append",
  "safe": true,
  "callees": {
    "sys::fs::unix::OpenOptions::append": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "sys::fs::unix::OpenOptions": [
      "MutRef"
    ],
    "fs::OpenOptions": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 1223,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:1665:5: 1668:6",
  "src": "pub fn append(&mut self, append: bool) -> &mut Self {\n        self.0.append(append);\n        self\n    }",
  "mir": "fn fs::OpenOptions::append(_1: &mut fs::OpenOptions, _2: bool) -> &mut fs::OpenOptions {\n    let mut _0: &mut fs::OpenOptions;\n    let  _3: ();\n    let mut _4: &mut sys::fs::unix::OpenOptions;\n    debug self => _1;\n    debug append => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: sys::fs::unix::OpenOptions);\n        _3 = sys::fs::unix::OpenOptions::append(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = _1;\n        return;\n    }\n}\n",
  "doc": " Sets the option for the append mode.\n\n This option, when true, means that writes will append to a file instead\n of overwriting previous contents.\n Note that setting `.write(true).append(true)` has the same effect as\n setting only `.append(true)`.\n\n Append mode guarantees that writes will be positioned at the current end of file,\n even when there are other processes or threads appending to the same file. This is\n unlike <code>[seek]\\([SeekFrom]::[End]\\(0))</code> followed by `write()`, which\n has a race between seeking and writing during which another writer can write, with\n our `write()` overwriting their data.\n\n Keep in mind that this does not necessarily guarantee that data appended by\n different processes or threads does not interleave. The amount of data accepted a\n single `write()` call depends on the operating system and file system. A\n successful `write()` is allowed to write only part of the given data, so even if\n you're careful to provide the whole message in a single call to `write()`, there\n is no guarantee that it will be written out in full. If you rely on the filesystem\n accepting the message in a single write, make sure that all data that belongs\n together is written in one operation. This can be done by concatenating strings\n before passing them to [`write()`].\n\n If a file is opened with both read and append access, beware that after\n opening, and after every write, the position for reading may be set at the\n end of the file. So, before writing, save the current position (using\n <code>[Seek]::[stream_position]</code>), and restore it before the next read.\n\n ## Note\n\n This function doesn't create the file if it doesn't exist. Use the\n [`OpenOptions::create`] method to do so.\n\n [`write()`]: Write::write \"io::Write::write\"\n [`flush()`]: Write::flush \"io::Write::flush\"\n [stream_position]: Seek::stream_position \"io::Seek::stream_position\"\n [seek]: Seek::seek \"io::Seek::seek\"\n [Current]: SeekFrom::Current \"io::SeekFrom::Current\"\n [End]: SeekFrom::End \"io::SeekFrom::End\"\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().append(true).open(\"foo.txt\");\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}