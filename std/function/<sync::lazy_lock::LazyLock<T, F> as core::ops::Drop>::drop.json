{
  "name": "<sync::lazy_lock::LazyLock<T, F> as core::ops::Drop>::drop",
  "safe": true,
  "callees": {
    "sync::once::Once::state": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current state of the `Once` instance.\n\n Since this takes a mutable reference, no initialization can currently\n be running, so the state must be either \"incomplete\", \"poisoned\" or\n \"complete\".\n",
      "adt": {
        "sync::once::Once": "MutableAsArgument",
        "sync::once::OnceExclusiveState": "Constructor"
      }
    },
    "core::cell::UnsafeCell::<T>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the underlying data.\n\n This call borrows the `UnsafeCell` mutably (at compile-time) which\n guarantees that we possess the only reference.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let mut c = UnsafeCell::new(5);\n *c.get_mut() += 1;\n\n assert_eq!(*c.get_mut(), 6);\n ```\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::drop": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Manually drops the contained value.\n\n This is exactly equivalent to calling [`ptr::drop_in_place`] with a\n pointer to the contained value. As such, unless the contained value is a\n packed struct, the destructor will be called in-place without moving the\n value, and thus can be used to safely drop [pinned] data.\n\n If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n\n # Safety\n\n This function runs the destructor of the contained value. Other than changes made by\n the destructor itself, the memory is left unchanged, and so as far as the compiler is\n concerned still holds a bit-pattern which is valid for the type `T`.\n\n However, this \"zombie\" value should not be exposed to safe code, and this function\n should not be called more than once. To use a value after it's been dropped, or drop\n a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n This is normally prevented by the type system, but users of `ManuallyDrop` must\n uphold those guarantees without assistance from the compiler.\n\n [pinned]: crate::pin\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::once::Once": [
      "MutRef"
    ],
    "sync::lazy_lock::LazyLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "sync::once::OnceExclusiveState": [
      "Plain"
    ],
    "core::cell::UnsafeCell": [
      "MutRef"
    ],
    "sync::lazy_lock::Data": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::mem::ManuallyDrop": [
      "MutRef"
    ]
  },
  "path": 2768,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/lazy_lock.rs:339:5: 349:6",
  "src": "fn drop(&mut self) {\n        match self.once.state() {\n            OnceExclusiveState::Incomplete => unsafe {\n                ManuallyDrop::drop(&mut self.data.get_mut().f)\n            },\n            OnceExclusiveState::Complete => unsafe {\n                ManuallyDrop::drop(&mut self.data.get_mut().value)\n            },\n            OnceExclusiveState::Poisoned => {}\n        }\n    }",
  "mir": "fn <sync::lazy_lock::LazyLock<T, F> as core::ops::Drop>::drop(_1: &mut sync::lazy_lock::LazyLock<T, F>) -> () {\n    let mut _0: ();\n    let mut _2: sync::once::OnceExclusiveState;\n    let mut _3: &mut sync::once::Once;\n    let mut _4: isize;\n    let mut _5: &mut core::mem::ManuallyDrop<F>;\n    let mut _6: &mut sync::lazy_lock::Data<T, F>;\n    let mut _7: &mut core::cell::UnsafeCell<sync::lazy_lock::Data<T, F>>;\n    let mut _8: &mut core::mem::ManuallyDrop<T>;\n    let mut _9: &mut sync::lazy_lock::Data<T, F>;\n    let mut _10: &mut core::cell::UnsafeCell<sync::lazy_lock::Data<T, F>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: sync::once::Once);\n        _2 = sync::once::Once::state(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb4, 1: bb9, 2: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut ((*_1).1: core::cell::UnsafeCell<sync::lazy_lock::Data<T, F>>);\n        _9 = core::cell::UnsafeCell::<sync::lazy_lock::Data<T, F>>::get_mut(move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut ((*_1).1: core::cell::UnsafeCell<sync::lazy_lock::Data<T, F>>);\n        _6 = core::cell::UnsafeCell::<sync::lazy_lock::Data<T, F>>::get_mut(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _5 = &mut ((*_6).1: core::mem::ManuallyDrop<F>);\n        _0 = core::mem::ManuallyDrop::<F>::drop(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        goto -> bb9;\n    }\n    bb7: {\n        StorageDead(_10);\n        _8 = &mut ((*_9).0: core::mem::ManuallyDrop<T>);\n        _0 = core::mem::ManuallyDrop::<T>::drop(_8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}