{
  "name": "<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_vectored",
  "safe": true,
  "callees": {
    "io::Write::is_write_vectored": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if this `Write`r has an efficient [`write_vectored`]\n implementation.\n\n If a `Write`r does not override the default [`write_vectored`]\n implementation, code using it may want to avoid the method all together\n and coalesce writes into a single buffer for higher performance.\n\n The default implementation returns `false`.\n\n [`write_vectored`]: Write::write_vectored\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "io::Write::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a buffer into this writer, returning how many bytes were written.\n\n This function will attempt to write the entire contents of `buf`, but\n the entire write might not succeed, or the write may also generate an\n error. Typically, a call to `write` represents one attempt to write to\n any wrapped object.\n\n Calls to `write` are not guaranteed to block waiting for data to be\n written, and a write which would otherwise block can be indicated through\n an [`Err`] variant.\n\n If this method consumed `n > 0` bytes of `buf` it must return [`Ok(n)`].\n If the return value is `Ok(n)` then `n` must satisfy `n <= buf.len()`.\n A return value of `Ok(0)` typically means that the underlying object is\n no longer able to accept bytes and will likely not be able to in the\n future as well, or that the buffer provided is empty.\n\n # Errors\n\n Each call to `write` may generate an I/O error indicating that the\n operation could not be completed. If an error is returned then no bytes\n in the buffer were written to this writer.\n\n It is **not** considered an error if the entire buffer could not be\n written to this writer.\n\n An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n write operation should be retried if there is nothing else to do.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // Writes some prefix of the byte string, not necessarily all of it.\n     buffer.write(b\"some bytes\")?;\n     Ok(())\n }\n ```\n\n [`Ok(n)`]: Ok\n",
      "adt": {}
    },
    "core::iter::Iterator::enumerate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which gives the current iteration count as well as\n the next value.\n\n The iterator returned yields pairs `(i, val)`, where `i` is the\n current index of iteration and `val` is the value returned by the\n iterator.\n\n `enumerate()` keeps its count as a [`usize`]. If you want to count by a\n different sized integer, the [`zip`] function provides similar\n functionality.\n\n # Overflow Behavior\n\n The method does no guarding against overflows, so enumerating more than\n [`usize::MAX`] elements either produces the wrong result or panics. If\n overflow checks are enabled, a panic is guaranteed.\n\n # Panics\n\n The returned iterator might panic if the to-be-returned index would\n overflow a [`usize`].\n\n [`zip`]: Iterator::zip\n\n # Examples\n\n ```\n let a = ['a', 'b', 'c'];\n\n let mut iter = a.into_iter().enumerate();\n\n assert_eq!(iter.next(), Some((0, 'a')));\n assert_eq!(iter.next(), Some((1, 'b')));\n assert_eq!(iter.next(), Some((2, 'c')));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::rev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reverses an iterator's direction.\n\n Usually, iterators iterate from left to right. After using `rev()`,\n an iterator will instead iterate from right to left.\n\n This is only possible if the iterator has an end, so `rev()` only\n works on [`DoubleEndedIterator`]s.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter().rev();\n\n assert_eq!(iter.next(), Some(3));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(1));\n\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Applies function to the elements of iterator and returns\n the first non-none result.\n\n `iter.find_map(f)` is equivalent to `iter.filter_map(f).next()`.\n\n # Examples\n\n ```\n let a = [\"lol\", \"NaN\", \"2\", \"5\"];\n\n let first_number = a.iter().find_map(|s| s.parse().ok());\n\n assert_eq!(first_number, Some(2));\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::flush_if_completed_line": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Flushes the buffer iff the last byte is a newline (indicating that an\n earlier write only succeeded partially, and we want to retry flushing\n the buffered line before continuing with a subsequent write).\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::Write::write_vectored": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Like [`write`], except that it writes from a slice of buffers.\n\n Data is copied from each buffer in order, with the final buffer\n read from possibly being only partially consumed. This method must\n behave as a call to [`write`] with the buffers concatenated would.\n\n The default implementation calls [`write`] with either the first nonempty\n buffer provided, or an empty one if none exists.\n\n # Examples\n\n ```no_run\n use std::io::IoSlice;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let data1 = [1; 8];\n     let data2 = [15; 8];\n     let io_slice1 = IoSlice::new(&data1);\n     let io_slice2 = IoSlice::new(&data2);\n\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // Writes some prefix of the byte string, not necessarily all of it.\n     buffer.write_vectored(&[io_slice1, io_slice2])?;\n     Ok(())\n }\n ```\n\n [`write`]: Write::write\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::inner_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the inner writer (that is, the writer\n wrapped by the BufWriter). Be careful with this writer, as writes to\n it will bypass the buffer.\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "MutableAsArgument"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::num::<impl usize>::saturating_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::filter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which uses a closure to determine if an element\n should be yielded.\n\n Given an element the closure must return `true` or `false`. The returned\n iterator will yield only the elements for which the closure returns\n `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0i32, 1, 2];\n\n let mut iter = a.into_iter().filter(|x| x.is_positive());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `filter()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|x| **x > 1); // needs two *s!\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n It's common to instead use destructuring on the argument to strip away one:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&x| *x > 1); // both & and *\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n or both:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&&x| x > 1); // two &s\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n of these layers.\n\n Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::take_while": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that yields elements based on a predicate.\n\n `take_while()` takes a closure as an argument. It will call this\n closure on each element of the iterator, and yield elements\n while it returns `true`.\n\n After `false` is returned, `take_while()`'s job is over, and the\n rest of the elements are ignored.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [-1i32, 0, 1];\n\n let mut iter = a.into_iter().take_while(|x| x.is_negative());\n\n assert_eq!(iter.next(), Some(-1));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `take_while()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[-1, 0, 1];\n\n let mut iter = s.iter().take_while(|x| **x < 0); // need two *s!\n\n assert_eq!(iter.next(), Some(&-1));\n assert_eq!(iter.next(), None);\n ```\n\n Stopping after an initial `false`:\n\n ```\n let a = [-1, 0, 1, -2];\n\n let mut iter = a.into_iter().take_while(|&x| x < 0);\n\n assert_eq!(iter.next(), Some(-1));\n\n // We have more elements that are less than zero, but since we already\n // got a false, take_while() ignores the remaining elements.\n assert_eq!(iter.next(), None);\n ```\n\n Because `take_while()` needs to look at the value in order to see if it\n should be included or not, consuming iterators will see that it is\n removed:\n\n ```\n let a = [1, 2, 3, 4];\n let mut iter = a.into_iter();\n\n let result: Vec<i32> = iter.by_ref().take_while(|&n| n != 3).collect();\n\n assert_eq!(result, [1, 2]);\n\n let result: Vec<i32> = iter.collect();\n\n assert_eq!(result, [4]);\n ```\n\n The `3` is no longer there, because it was consumed in order to see if\n the iteration should stop, but wasn't placed back into the iterator.\n",
      "adt": {}
    },
    "core::iter::Iterator::sum": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sums the elements of an iterator.\n\n Takes each element, adds them together, and returns the result.\n\n An empty iterator returns the *additive identity* (\"zero\") of the type,\n which is `0` for integers and `-0.0` for floats.\n\n `sum()` can be used to sum any type implementing [`Sum`][`core::iter::Sum`],\n including [`Option`][`Option::sum`] and [`Result`][`Result::sum`].\n\n # Panics\n\n When calling `sum()` and a primitive integer type is being returned, this\n method will panic if the computation overflows and overflow checks are\n enabled.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n let sum: i32 = a.iter().sum();\n\n assert_eq!(sum, 6);\n\n let b: Vec<f32> = vec![];\n let sum: f32 = b.iter().sum();\n assert_eq!(sum, -0.0_f32);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "io::buffered::linewritershim::LineWriterShim": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4824, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3938, kind: RigidTy(Adt(AdtDef(DefId { id: 6507, name: \"io::IoSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "io::IoSlice": [
      "Ref"
    ],
    "core::iter::Enumerate": [
      "Plain"
    ],
    "core::iter::Rev": [
      "Plain",
      "MutRef"
    ],
    "io::buffered::bufwriter::BufWriter": [
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::iter::Filter": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain"
    ],
    "core::iter::TakeWhile": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_vectored"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:178:5: 253:6",
  "src": "fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n        // If there's no specialized behavior for write_vectored, just use\n        // write. This has the benefit of more granular partial-line handling.\n        if !self.is_write_vectored() {\n            return match bufs.iter().find(|buf| !buf.is_empty()) {\n                Some(buf) => self.write(buf),\n                None => Ok(0),\n            };\n        }\n\n        // Find the buffer containing the last newline\n        // FIXME: This is overly slow if there are very many bufs and none contain\n        // newlines. e.g. writev() on Linux only writes up to 1024 slices, so\n        // scanning the rest is wasted effort. This makes write_all_vectored()\n        // quadratic.\n        let last_newline_buf_idx = bufs\n            .iter()\n            .enumerate()\n            .rev()\n            .find_map(|(i, buf)| memchr::memchr(b'\\n', buf).map(|_| i));\n\n        // If there are no new newlines (that is, if this write is less than\n        // one line), just do a regular buffered write\n        let last_newline_buf_idx = match last_newline_buf_idx {\n            // No newlines; just do a normal buffered write\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write_vectored(bufs);\n            }\n            Some(i) => i,\n        };\n\n        // Flush existing content to prepare for our write\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let (lines, tail) = bufs.split_at(last_newline_buf_idx + 1);\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.panicked here.\n        let flushed = self.inner_mut().write_vectored(lines)?;\n\n        // If inner returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Don't try to reconstruct the exact amount written; just bail\n        // in the event of a partial write\n        let mut lines_len: usize = 0;\n        for buf in lines {\n            // With overlapping/duplicate slices the total length may in theory\n            // exceed usize::MAX\n            lines_len = lines_len.saturating_add(buf.len());\n            if flushed < lines_len {\n                return Ok(flushed);\n            }\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of the\n        // rest as possible)\n        let buffered: usize = tail\n            .iter()\n            .filter(|buf| !buf.is_empty())\n            .map(|buf| self.buffer.write_to_buf(buf))\n            .take_while(|&n| n > 0)\n            .sum();\n\n        Ok(flushed + buffered)\n    }",
  "mir": "fn <io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_vectored(_1: &mut io::buffered::linewritershim::LineWriterShim<'_, W>, _2: &[io::IoSlice<'_>]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: bool;\n    let mut _4: &&mut io::buffered::linewritershim::LineWriterShim<'_, W>;\n    let mut _5: core::option::Option<&io::IoSlice<'_>>;\n    let mut _6: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _7: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _8: isize;\n    let  _9: &io::IoSlice<'_>;\n    let  _10: &[u8];\n    let  _11: core::option::Option<usize>;\n    let mut _12: &mut core::iter::Rev<core::iter::Enumerate<core::slice::Iter<'_, io::IoSlice<'_>>>>;\n    let mut _13: core::iter::Rev<core::iter::Enumerate<core::slice::Iter<'_, io::IoSlice<'_>>>>;\n    let mut _14: core::iter::Enumerate<core::slice::Iter<'_, io::IoSlice<'_>>>;\n    let mut _15: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _16: isize;\n    let mut _17: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _18: core::result::Result<(), io::error::Error>;\n    let mut _19: isize;\n    let  _20: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _21: usize;\n    let mut _22: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _23: core::result::Result<(), io::error::Error>;\n    let mut _24: isize;\n    let  _25: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _26: &[io::IoSlice<'_>];\n    let  _27: &[io::IoSlice<'_>];\n    let mut _28: (&[io::IoSlice<'_>], &[io::IoSlice<'_>]);\n    let mut _29: usize;\n    let mut _30: (usize, bool);\n    let mut _31: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _32: core::result::Result<usize, io::error::Error>;\n    let mut _33: &mut W;\n    let mut _34: isize;\n    let  _35: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _36: usize;\n    let mut _37: usize;\n    let mut _38: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _39: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _40: core::option::Option<&io::IoSlice<'_>>;\n    let mut _41: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _42: isize;\n    let  _43: &io::IoSlice<'_>;\n    let mut _44: usize;\n    let mut _45: usize;\n    let mut _46: usize;\n    let  _47: &[u8];\n    let mut _48: bool;\n    let mut _49: usize;\n    let  _50: usize;\n    let mut _51: core::iter::TakeWhile<core::iter::Map<core::iter::Filter<core::slice::Iter<'_, io::IoSlice<'_>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:249:25: 249:29}>;\n    let mut _52: core::iter::Map<core::iter::Filter<core::slice::Iter<'_, io::IoSlice<'_>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23}>;\n    let mut _53: core::iter::Filter<core::slice::Iter<'_, io::IoSlice<'_>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}>;\n    let mut _54: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _55: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23};\n    let mut _56: usize;\n    let mut _57: (usize, bool);\n    let mut _58: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _59: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _60: &mut io::buffered::bufwriter::BufWriter<W>;\n    debug self => _1;\n    debug bufs => _2;\n    debug buf => _9;\n    debug last_newline_buf_idx => _11;\n    debug last_newline_buf_idx => _21;\n    debug residual => _20;\n    debug val => ();\n    debug i => _21;\n    debug residual => _25;\n    debug val => ();\n    debug lines => _26;\n    debug tail => _27;\n    debug flushed => _36;\n    debug residual => _35;\n    debug val => _36;\n    debug lines_len => _37;\n    debug iter => _39;\n    debug buf => _43;\n    debug buffered => _50;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = <&mut io::buffered::linewritershim::LineWriterShim<'_, W> as io::Write>::is_write_vectored(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = core::slice::<impl [io::IoSlice<'_>]>::iter(_2) -> [return: bb11, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = core::slice::<impl [io::IoSlice<'_>]>::iter(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = &mut _7;\n        _5 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::find::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:182:43: 182:48}>(move _6, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:182:43: 182:48}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _0 = core::result::Result::Ok(0_usize);\n        goto -> bb55;\n    }\n    bb8: {\n        _9 = ((_5 as variant#1).0: &io::IoSlice<'_>);\n        _10 = <io::IoSlice<'_> as core::ops::Deref>::deref(_9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _0 = <io::buffered::linewritershim::LineWriterShim<'_, W> as io::Write>::write(_1, _10) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        goto -> bb55;\n    }\n    bb11: {\n        _14 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::enumerate(move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        _13 = <core::iter::Enumerate<core::slice::Iter<'_, io::IoSlice<'_>>> as core::iter::Iterator>::rev(move _14) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _12 = &mut _13;\n        StorageDead(_14);\n        _11 = <core::iter::Rev<core::iter::Enumerate<core::slice::Iter<'_, io::IoSlice<'_>>>> as core::iter::Iterator>::find_map::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:197:23: 197:33}>(move _12, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:197:23: 197:33}) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_12);\n        StorageDead(_13);\n        _16 = discriminant(_11);\n        switchInt(move _16) -> [0: bb16, 1: bb15, otherwise: bb6];\n    }\n    bb15: {\n        _21 = ((_11 as variant#1).0: usize);\n        StorageLive(_22);\n        StorageLive(_23);\n        _58 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _23 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_58) -> [return: bb23, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = io::buffered::linewritershim::LineWriterShim::<'_, W>::flush_if_completed_line(_1) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _17 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _18) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_18);\n        _19 = discriminant(_17);\n        switchInt(move _19) -> [0: bb19, 1: bb20, otherwise: bb6];\n    }\n    bb19: {\n        StorageDead(_17);\n        _59 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _0 = <io::buffered::bufwriter::BufWriter<W> as io::Write>::write_vectored(_59, _2) -> [return: bb22, unwind unreachable];\n    }\n    bb20: {\n        _20 = move ((_17 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_20) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_17);\n        goto -> bb54;\n    }\n    bb22: {\n        goto -> bb54;\n    }\n    bb23: {\n        _22 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _23) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_23);\n        _24 = discriminant(_22);\n        switchInt(move _24) -> [0: bb25, 1: bb26, otherwise: bb6];\n    }\n    bb25: {\n        StorageDead(_22);\n        StorageLive(_28);\n        StorageLive(_29);\n        _30 = CheckedAdd(_21, 1_usize);\n        assert(!move (_30.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _21, 1_usize) -> [success: bb28, unwind unreachable];\n    }\n    bb26: {\n        _25 = move ((_22 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_25) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_22);\n        goto -> bb54;\n    }\n    bb28: {\n        _29 = move (_30.0: usize);\n        _28 = core::slice::<impl [io::IoSlice<'_>]>::split_at(_2, move _29) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_29);\n        _26 = (_28.0: &[io::IoSlice<'_>]);\n        _27 = (_28.1: &[io::IoSlice<'_>]);\n        StorageDead(_28);\n        StorageLive(_31);\n        StorageLive(_32);\n        _33 = io::buffered::linewritershim::LineWriterShim::<'_, W>::inner_mut(_1) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        _32 = <W as io::Write>::write_vectored(_33, _26) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _31 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _32) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_32);\n        _34 = discriminant(_31);\n        switchInt(move _34) -> [0: bb33, 1: bb34, otherwise: bb6];\n    }\n    bb33: {\n        _36 = ((_31 as variant#0).0: usize);\n        StorageDead(_31);\n        switchInt(_36) -> [0: bb36, otherwise: bb37];\n    }\n    bb34: {\n        _35 = move ((_31 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_35) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_31);\n        goto -> bb53;\n    }\n    bb36: {\n        _0 = core::result::Result::Ok(0_usize);\n        goto -> bb53;\n    }\n    bb37: {\n        StorageLive(_37);\n        _37 = 0_usize;\n        StorageLive(_38);\n        _38 = <&[io::IoSlice<'_>] as core::iter::IntoIterator>::into_iter(_26) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageLive(_39);\n        _39 = move _38;\n        goto -> bb39;\n    }\n    bb39: {\n        StorageLive(_40);\n        _41 = &mut _39;\n        _40 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::next(_41) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _42 = discriminant(_40);\n        switchInt(move _42) -> [0: bb42, 1: bb41, otherwise: bb6];\n    }\n    bb41: {\n        _43 = ((_40 as variant#1).0: &io::IoSlice<'_>);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = _37;\n        StorageLive(_46);\n        _47 = <io::IoSlice<'_> as core::ops::Deref>::deref(_43) -> [return: bb43, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = core::slice::<impl [io::IoSlice<'_>]>::iter(_27) -> [return: bb47, unwind unreachable];\n    }\n    bb43: {\n        _46 = PtrMetadata(_47);\n        _44 = core::num::<impl usize>::saturating_add(move _45, move _46) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_46);\n        StorageDead(_45);\n        _37 = move _44;\n        StorageDead(_44);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = _37;\n        _48 = Lt(_36, move _49);\n        switchInt(move _48) -> [0: bb46, otherwise: bb45];\n    }\n    bb45: {\n        StorageDead(_49);\n        _0 = core::result::Result::Ok(_36);\n        StorageDead(_48);\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb53;\n    }\n    bb46: {\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageDead(_40);\n        goto -> bb39;\n    }\n    bb47: {\n        _53 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::filter::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}>(move _54, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_54);\n        StorageLive(_55);\n        _60 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _55 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23}(_60);\n        _52 = <core::iter::Filter<core::slice::Iter<'_, io::IoSlice<'_>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}> as core::iter::Iterator>::map::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23}>(move _53, move _55) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_55);\n        StorageDead(_53);\n        _51 = <core::iter::Map<core::iter::Filter<core::slice::Iter<'_, io::IoSlice<'_>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23}> as core::iter::Iterator>::take_while::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:249:25: 249:29}>(move _52, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:249:25: 249:29}) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_52);\n        _50 = <core::iter::TakeWhile<core::iter::Map<core::iter::Filter<core::slice::Iter<'_, io::IoSlice<'_>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:247:21: 247:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:248:18: 248:23}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:249:25: 249:29}> as core::iter::Iterator>::sum::<usize>(move _51) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_51);\n        StorageLive(_56);\n        _57 = CheckedAdd(_36, _50);\n        assert(!move (_57.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _36, _50) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        _56 = move (_57.0: usize);\n        _0 = core::result::Result::Ok(move _56);\n        StorageDead(_56);\n        StorageDead(_37);\n        StorageDead(_11);\n        goto -> bb56;\n    }\n    bb53: {\n        goto -> bb54;\n    }\n    bb54: {\n        StorageDead(_11);\n        goto -> bb56;\n    }\n    bb55: {\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb56;\n    }\n    bb56: {\n        return;\n    }\n}\n",
  "doc": " Writes some vectored data into this BufReader with line buffering.\n\n This means that, if any newlines are present in the data, the data up to\n and including the buffer containing the last newline is sent directly to\n the inner writer, and the data after it is buffered. Returns the number\n of bytes written.\n\n This function operates on a \"best effort basis\"; in keeping with the\n convention of `Write::write`, it makes at most one attempt to write\n new data to the underlying writer.\n\n Because this function attempts to send completed lines to the underlying\n writer, it will also flush the existing buffer if it contains any\n newlines.\n\n Because sorting through an array of `IoSlice` can be a bit convoluted,\n This method differs from write in the following ways:\n\n - It attempts to write the full content of all the buffers up to and\n   including the one containing the last newline. This means that it\n   may attempt to write a partial line, that buffer has data past the\n   newline.\n - If the write only reports partial success, it does not attempt to\n   find the precise location of the written bytes and buffer the rest.\n\n If the underlying vector doesn't support vectored writing, we instead\n simply write the first non-empty buffer with `write`. This way, we\n get the benefits of more granular partial-line handling without losing\n anything in efficiency\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}