{
  "name": "io::buffered::bufwriter::BufWriter::<W>::into_inner",
  "safe": true,
  "callees": {
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::into_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disassembles this `BufWriter<W>`, returning the underlying writer, and any buffered but\n unwritten data.\n\n If the underlying writer panicked, it is not known what portion of the data was written.\n In this case, we return `WriterPanicked` for the buffered data (from which the buffer\n contents can still be recovered).\n\n `into_parts` makes no attempt to flush data and cannot fail.\n\n # Examples\n\n ```\n use std::io::{BufWriter, Write};\n\n let mut buffer = [0u8; 10];\n let mut stream = BufWriter::new(buffer.as_mut());\n write!(stream, \"too much data\").unwrap();\n stream.flush().expect_err(\"it doesn't fit\");\n let (recovered_writer, buffered_data) = stream.into_parts();\n assert_eq!(recovered_writer.len(), 0);\n assert_eq!(&buffered_data.unwrap(), b\"ata\");\n ```\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "io::buffered::IntoInnerError::<W>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new IntoInnerError\n",
      "adt": {
        "io::buffered::IntoInnerError": "Constructor"
      }
    }
  },
  "adts": {
    "io::buffered::bufwriter::BufWriter": [
      "MutRef",
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])",
      "Unknown([Field(0, Ty { id: 3792, kind: Param(ParamTy { index: 0, name: \"W\" }) })])",
      "Unknown([Field(1, Ty { id: 4703, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 4707, kind: RigidTy(Adt(AdtDef(DefId { id: 6441, name: \"io::buffered::bufwriter::WriterPanicked\" }), GenericArgs([]))) })]))) })])"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "io::buffered::IntoInnerError": [
      "Plain"
    ]
  },
  "path": 1347,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:145:5: 150:6",
  "src": "pub fn into_inner(mut self) -> Result<W, IntoInnerError<BufWriter<W>>> {\n        match self.flush_buf() {\n            Err(e) => Err(IntoInnerError::new(self, e)),\n            Ok(()) => Ok(self.into_parts().0),\n        }\n    }",
  "mir": "fn io::buffered::bufwriter::BufWriter::<W>::into_inner(_1: io::buffered::bufwriter::BufWriter<W>) -> core::result::Result<W, io::buffered::IntoInnerError<io::buffered::bufwriter::BufWriter<W>>> {\n    let mut _0: core::result::Result<W, io::buffered::IntoInnerError<io::buffered::bufwriter::BufWriter<W>>>;\n    let mut _2: core::result::Result<(), io::error::Error>;\n    let mut _3: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _4: isize;\n    let  _5: io::error::Error;\n    let mut _6: io::buffered::IntoInnerError<io::buffered::bufwriter::BufWriter<W>>;\n    let mut _7: io::buffered::bufwriter::BufWriter<W>;\n    let mut _8: W;\n    let mut _9: (W, core::result::Result<alloc_crate::vec::Vec<u8>, io::buffered::bufwriter::WriterPanicked>);\n    let mut _10: io::buffered::bufwriter::BufWriter<W>;\n    debug self => _1;\n    debug e => _5;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &mut _1;\n        _2 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb3, 1: bb4, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = move _1;\n        _9 = io::buffered::bufwriter::BufWriter::<W>::into_parts(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        _5 = move ((_2 as variant#1).0: io::error::Error);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = move _1;\n        _6 = io::buffered::IntoInnerError::<io::buffered::bufwriter::BufWriter<W>>::new(move _7, _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _0 = core::result::Result::Err(move _6);\n        StorageDead(_6);\n        goto -> bb8;\n    }\n    bb6: {\n        StorageDead(_10);\n        _8 = move (_9.0: W);\n        _0 = core::result::Result::Ok(move _8);\n        StorageDead(_8);\n        drop((_9.1: core::result::Result<alloc_crate::vec::Vec<u8>, io::buffered::bufwriter::WriterPanicked>)) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Unwraps this `BufWriter<W>`, returning the underlying writer.\n\n The buffer is written out before returning the writer.\n\n # Errors\n\n An [`Err`] will be returned if an error occurs while flushing the buffer.\n\n # Examples\n\n ```no_run\n use std::io::BufWriter;\n use std::net::TcpStream;\n\n let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n\n // unwrap the TcpStream and flush the buffer\n let stream = buffer.into_inner().unwrap();\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}