{
  "name": "thread::functions::sleep_ms",
  "safe": true,
  "callees": {
    "core::time::Duration::from_millis": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `Duration` from the specified number of milliseconds.\n\n # Examples\n\n ```\n use std::time::Duration;\n\n let duration = Duration::from_millis(2_569);\n\n assert_eq!(2, duration.as_secs());\n assert_eq!(569_000_000, duration.subsec_nanos());\n ```\n",
      "adt": {}
    },
    "thread::functions::sleep": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Puts the current thread to sleep for at least the specified amount of time.\n\n The thread may sleep longer than the duration specified due to scheduling\n specifics or platform-dependent functionality. It will never sleep less.\n\n This function is blocking, and should not be used in `async` functions.\n\n # Platform-specific behavior\n\n On Unix platforms, the underlying syscall may be interrupted by a\n spurious wakeup or signal handler. To ensure the sleep occurs for at least\n the specified duration, this function may invoke that system call multiple\n times.\n Platforms which do not support nanosecond precision for sleeping will\n have `dur` rounded up to the nearest granularity of time they can sleep for.\n\n Currently, specifying a zero duration on Unix platforms returns immediately\n without invoking the underlying [`nanosleep`] syscall, whereas on Windows\n platforms the underlying [`Sleep`] syscall is always invoked.\n If the intention is to yield the current time-slice you may want to use\n [`yield_now`] instead.\n\n [`nanosleep`]: https://linux.die.net/man/2/nanosleep\n [`Sleep`]: https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep\n\n # Examples\n\n ```no_run\n use std::{thread, time};\n\n let ten_millis = time::Duration::from_millis(10);\n let now = time::Instant::now();\n\n thread::sleep(ten_millis);\n\n assert!(now.elapsed() >= ten_millis);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::time::Duration": [
      "Plain"
    ]
  },
  "path": 4465,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/functions.rs:246:1: 248:2",
  "src": "pub fn sleep_ms(ms: u32) {\n    sleep(Duration::from_millis(ms as u64))\n}",
  "mir": "fn thread::functions::sleep_ms(_1: u32) -> () {\n    let mut _0: ();\n    let mut _2: core::time::Duration;\n    let mut _3: u64;\n    debug ms => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = _1 as u64;\n        _2 = core::time::Duration::from_millis(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = thread::functions::sleep(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Uses [`sleep`].\n\n Puts the current thread to sleep for at least the specified amount of time.\n\n The thread may sleep longer than the duration specified due to scheduling\n specifics or platform-dependent functionality. It will never sleep less.\n\n This function is blocking, and should not be used in `async` functions.\n\n # Platform-specific behavior\n\n On Unix platforms, the underlying syscall may be interrupted by a\n spurious wakeup or signal handler. To ensure the sleep occurs for at least\n the specified duration, this function may invoke that system call multiple\n times.\n\n # Examples\n\n ```no_run\n use std::thread;\n\n // Let's sleep for 2 seconds:\n thread::sleep_ms(2000);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}