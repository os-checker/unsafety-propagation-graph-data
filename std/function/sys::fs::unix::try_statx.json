{
  "name": "sys::fs::unix::try_statx",
  "safe": false,
  "callees": {
    "core::sync::atomic::AtomicU8::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "sys::fs::unix::try_statx::statx": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ptr::null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*const T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *const i32 = ptr::null();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "core::ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<E>`].\n\n Converts `self` into an [`Option<E>`], consuming `self`,\n and discarding the success value, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.err(), None);\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.err(), Some(\"Nothing here\"));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::and_then": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns [`None`] if the option is [`None`], otherwise calls `f` with the\n wrapped value and returns the result.\n\n Some languages call this operation flatmap.\n\n # Examples\n\n ```\n fn sq_then_to_string(x: u32) -> Option<String> {\n     x.checked_mul(x).map(|sq| sq.to_string())\n }\n\n assert_eq!(Some(2).and_then(sq_then_to_string), Some(4.to_string()));\n assert_eq!(Some(1_000_000).and_then(sq_then_to_string), None); // overflowed!\n assert_eq!(None.and_then(sq_then_to_string), None);\n ```\n\n Often used to chain fallible operations that may return [`None`].\n\n ```\n let arr_2d = [[\"A0\", \"A1\"], [\"B0\", \"B1\"]];\n\n let item_0_1 = arr_2d.get(0).and_then(|row| row.get(1));\n assert_eq!(item_0_1, Some(&\"A1\"));\n\n let item_2_0 = arr_2d.get(2).and_then(|row| row.get(0));\n assert_eq!(item_2_0, None);\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU8::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    },
    "libc::makedev": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicU8": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ],
    "libc::statx": [
      "Plain",
      "MutRef",
      "Deref",
      "Unknown([Field(18, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(19, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(8, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Field(3, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(6, Ty { id: 1225, kind: RigidTy(Uint(U16)) })])",
      "Unknown([Field(4, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(5, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(16, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(17, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(9, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(10, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Field(12, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) }), Field(0, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(12, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) }), Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(15, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) }), Field(0, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(15, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) }), Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(14, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) }), Field(0, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(14, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) }), Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(0, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(13, Ty { id: 15612, kind: RigidTy(Adt(AdtDef(DefId { id: 11569, name: \"libc::statx_timestamp\" }), GenericArgs([]))) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "libc::stat64": [
      "Plain",
      "Unknown([Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Field(1, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Field(3, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(2, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(4, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(5, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(6, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Field(8, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(9, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Field(11, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(12, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(13, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(14, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(15, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(16, Ty { id: 4522, kind: RigidTy(Int(I64)) })])",
      "Unknown([Field(17, Ty { id: 4522, kind: RigidTy(Int(I64)) })])"
    ],
    "libc::statx_timestamp": [
      "Plain"
    ],
    "sys::fs::unix::StatxExtraFields": [
      "Plain"
    ],
    "sys::fs::unix::FileAttr": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::fs::unix::try_statx"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:149:5: 245:6",
  "src": "unsafe fn try_statx(\n        fd: c_int,\n        path: *const c_char,\n        flags: i32,\n        mask: u32,\n    ) -> Option<io::Result<FileAttr>> {\n        use crate::sync::atomic::{Atomic, AtomicU8, Ordering};\n\n        // Linux kernel prior to 4.11 or glibc prior to glibc 2.28 don't support `statx`.\n        // We check for it on first failure and remember availability to avoid having to\n        // do it again.\n        #[repr(u8)]\n        enum STATX_STATE{ Unknown = 0, Present, Unavailable }\n        static STATX_SAVED_STATE: Atomic<u8> = AtomicU8::new(STATX_STATE::Unknown as u8);\n\n        syscall!(\n            fn statx(\n                fd: c_int,\n                pathname: *const c_char,\n                flags: c_int,\n                mask: libc::c_uint,\n                statxbuf: *mut libc::statx,\n            ) -> c_int;\n        );\n\n        let statx_availability = STATX_SAVED_STATE.load(Ordering::Relaxed);\n        if statx_availability == STATX_STATE::Unavailable as u8 {\n            return None;\n        }\n\n        let mut buf: libc::statx = mem::zeroed();\n        if let Err(err) = cvt(statx(fd, path, flags, mask, &mut buf)) {\n            if STATX_SAVED_STATE.load(Ordering::Relaxed) == STATX_STATE::Present as u8 {\n                return Some(Err(err));\n            }\n\n            // We're not yet entirely sure whether `statx` is usable on this kernel\n            // or not. Syscalls can return errors from things other than the kernel\n            // per se, e.g. `EPERM` can be returned if seccomp is used to block the\n            // syscall, or `ENOSYS` might be returned from a faulty FUSE driver.\n            //\n            // Availability is checked by performing a call which expects `EFAULT`\n            // if the syscall is usable.\n            //\n            // See: https://github.com/rust-lang/rust/issues/65662\n            //\n            // FIXME what about transient conditions like `ENOMEM`?\n            let err2 = cvt(statx(0, ptr::null(), 0, libc::STATX_BASIC_STATS | libc::STATX_BTIME, ptr::null_mut()))\n                .err()\n                .and_then(|e| e.raw_os_error());\n            if err2 == Some(libc::EFAULT) {\n                STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n                return Some(Err(err));\n            } else {\n                STATX_SAVED_STATE.store(STATX_STATE::Unavailable as u8, Ordering::Relaxed);\n                return None;\n            }\n        }\n        if statx_availability == STATX_STATE::Unknown as u8 {\n            STATX_SAVED_STATE.store(STATX_STATE::Present as u8, Ordering::Relaxed);\n        }\n\n        // We cannot fill `stat64` exhaustively because of private padding fields.\n        let mut stat: stat64 = mem::zeroed();\n        // `c_ulong` on gnu-mips, `dev_t` otherwise\n        stat.st_dev = libc::makedev(buf.stx_dev_major, buf.stx_dev_minor) as _;\n        stat.st_ino = buf.stx_ino as libc::ino64_t;\n        stat.st_nlink = buf.stx_nlink as libc::nlink_t;\n        stat.st_mode = buf.stx_mode as libc::mode_t;\n        stat.st_uid = buf.stx_uid as libc::uid_t;\n        stat.st_gid = buf.stx_gid as libc::gid_t;\n        stat.st_rdev = libc::makedev(buf.stx_rdev_major, buf.stx_rdev_minor) as _;\n        stat.st_size = buf.stx_size as off64_t;\n        stat.st_blksize = buf.stx_blksize as libc::blksize_t;\n        stat.st_blocks = buf.stx_blocks as libc::blkcnt64_t;\n        stat.st_atime = buf.stx_atime.tv_sec as libc::time_t;\n        // `i64` on gnu-x86_64-x32, `c_ulong` otherwise.\n        stat.st_atime_nsec = buf.stx_atime.tv_nsec as _;\n        stat.st_mtime = buf.stx_mtime.tv_sec as libc::time_t;\n        stat.st_mtime_nsec = buf.stx_mtime.tv_nsec as _;\n        stat.st_ctime = buf.stx_ctime.tv_sec as libc::time_t;\n        stat.st_ctime_nsec = buf.stx_ctime.tv_nsec as _;\n\n        let extra = StatxExtraFields {\n            stx_mask: buf.stx_mask,\n            stx_btime: buf.stx_btime,\n            // Store full times to avoid 32-bit `time_t` truncation.\n            #[cfg(target_pointer_width = \"32\")]\n            stx_atime: buf.stx_atime,\n            #[cfg(target_pointer_width = \"32\")]\n            stx_ctime: buf.stx_ctime,\n            #[cfg(target_pointer_width = \"32\")]\n            stx_mtime: buf.stx_mtime,\n        };\n\n        Some(Ok(FileAttr { stat, statx_extra_fields: Some(extra) }))\n    }",
  "mir": "fn sys::fs::unix::try_statx(_1: i32, _2: *const u8, _3: i32, _4: u32) -> core::option::Option<core::result::Result<sys::fs::unix::FileAttr, io::error::Error>> {\n    let mut _0: core::option::Option<core::result::Result<sys::fs::unix::FileAttr, io::error::Error>>;\n    let  _5: u8;\n    let mut _6: &core::sync::atomic::AtomicU8;\n    let mut _7: core::sync::atomic::Ordering;\n    let mut _8: bool;\n    let mut _9: u8;\n    let mut _10: (u8, bool);\n    let mut _11: libc::statx;\n    let mut _12: core::result::Result<i32, io::error::Error>;\n    let mut _13: i32;\n    let mut _14: *mut libc::statx;\n    let mut _15: &mut libc::statx;\n    let mut _16: isize;\n    let  _17: io::error::Error;\n    let mut _18: bool;\n    let mut _19: u8;\n    let mut _20: &core::sync::atomic::AtomicU8;\n    let mut _21: core::sync::atomic::Ordering;\n    let mut _22: u8;\n    let mut _23: (u8, bool);\n    let mut _24: core::result::Result<sys::fs::unix::FileAttr, io::error::Error>;\n    let mut _25: io::error::Error;\n    let  _26: core::option::Option<i32>;\n    let mut _27: core::option::Option<io::error::Error>;\n    let mut _28: core::result::Result<i32, io::error::Error>;\n    let mut _29: i32;\n    let mut _30: *const u8;\n    let mut _31: u32;\n    let mut _32: *mut libc::statx;\n    let mut _33: bool;\n    let mut _34: &core::option::Option<i32>;\n    let mut _35: &core::option::Option<i32>;\n    let  _36: ();\n    let mut _37: &core::sync::atomic::AtomicU8;\n    let mut _38: u8;\n    let mut _39: (u8, bool);\n    let mut _40: core::sync::atomic::Ordering;\n    let mut _41: core::result::Result<sys::fs::unix::FileAttr, io::error::Error>;\n    let mut _42: io::error::Error;\n    let  _43: ();\n    let mut _44: &core::sync::atomic::AtomicU8;\n    let mut _45: u8;\n    let mut _46: (u8, bool);\n    let mut _47: core::sync::atomic::Ordering;\n    let mut _48: bool;\n    let mut _49: u8;\n    let mut _50: (u8, bool);\n    let  _51: ();\n    let mut _52: &core::sync::atomic::AtomicU8;\n    let mut _53: u8;\n    let mut _54: (u8, bool);\n    let mut _55: core::sync::atomic::Ordering;\n    let mut _56: libc::stat64;\n    let mut _57: u64;\n    let mut _58: u32;\n    let mut _59: u32;\n    let mut _60: u64;\n    let mut _61: u32;\n    let mut _62: u16;\n    let mut _63: u32;\n    let mut _64: u32;\n    let mut _65: u64;\n    let mut _66: u32;\n    let mut _67: u32;\n    let mut _68: u64;\n    let mut _69: u32;\n    let mut _70: u64;\n    let mut _71: i64;\n    let mut _72: i64;\n    let mut _73: u32;\n    let mut _74: i64;\n    let mut _75: i64;\n    let mut _76: u32;\n    let mut _77: i64;\n    let mut _78: i64;\n    let mut _79: u32;\n    let  _80: sys::fs::unix::StatxExtraFields;\n    let mut _81: u32;\n    let mut _82: libc::statx_timestamp;\n    let mut _83: core::result::Result<sys::fs::unix::FileAttr, io::error::Error>;\n    let mut _84: sys::fs::unix::FileAttr;\n    let mut _85: libc::stat64;\n    let mut _86: core::option::Option<sys::fs::unix::StatxExtraFields>;\n    let mut _87: bool;\n    debug fd => _1;\n    debug path => _2;\n    debug flags => _3;\n    debug mask => _4;\n    debug statx_availability => _5;\n    debug buf => _11;\n    debug err => _17;\n    debug err2 => _26;\n    debug stat => _56;\n    debug extra => _80;\n    bb0: {\n        _87 = false;\n        StorageLive(_6);\n        _6 = {alloc417: &core::sync::atomic::AtomicU8};\n        StorageLive(_7);\n        _7 = core::sync::atomic::Ordering::Relaxed;\n        _5 = core::sync::atomic::AtomicU8::load(move _6, move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_8);\n        _10 = CheckedAdd(sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 2_u8);\n        assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 2_u8) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _9 = move (_10.0: u8);\n        _8 = Eq(_5, _9);\n        switchInt(move _8) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _0 = core::option::Option::None;\n        StorageDead(_8);\n        goto -> bb37;\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageLive(_11);\n        _11 = core::mem::zeroed::<libc::statx>() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _11;\n        _14 = &raw mut (*_15);\n        _13 = sys::fs::unix::try_statx::statx(_1, _2, _3, _4, move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _12 = sys::pal::unix::cvt::<i32>(move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        _16 = discriminant(_12);\n        switchInt(move _16) -> [1: bb8, 0: bb39, otherwise: bb42];\n    }\n    bb8: {\n        StorageLive(_17);\n        _87 = true;\n        _17 = move ((_12 as variant#1).0: io::error::Error);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = {alloc417: &core::sync::atomic::AtomicU8};\n        StorageLive(_21);\n        _21 = core::sync::atomic::Ordering::Relaxed;\n        _19 = core::sync::atomic::AtomicU8::load(move _20, move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        StorageDead(_20);\n        _23 = CheckedAdd(sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 1_u8);\n        assert(!move (_23.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 1_u8) -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _22 = move (_23.0: u8);\n        _18 = Eq(move _19, _22);\n        switchInt(move _18) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageLive(_24);\n        StorageLive(_25);\n        _87 = false;\n        _25 = move _17;\n        _24 = core::result::Result::Err(move _25);\n        StorageDead(_25);\n        _0 = core::option::Option::Some(move _24);\n        StorageDead(_24);\n        StorageDead(_18);\n        goto -> bb41;\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = core::ptr::null::<u8>() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_31);\n        _31 = BitOr(libc::STATX_BASIC_STATS, libc::STATX_BTIME);\n        StorageLive(_32);\n        _32 = core::ptr::null_mut::<libc::statx>() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _29 = sys::fs::unix::try_statx::statx(0_i32, move _30, 0_i32, move _31, move _32) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageDead(_30);\n        _28 = sys::pal::unix::cvt::<i32>(move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        _27 = core::result::Result::<i32, io::error::Error>::err(move _28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_28);\n        _26 = core::option::Option::<io::error::Error>::and_then::<i32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:198:27: 198:30}>(move _27, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:198:27: 198:30}) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_27);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &_26;\n        StorageLive(_35);\n        _35 = sys::fs::unix::try_statx::promoted[0];\n        _33 = <core::option::Option<i32> as core::cmp::PartialEq>::eq(move _34, move _35) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        switchInt(move _33) -> [0: bb23, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_37);\n        _37 = {alloc417: &core::sync::atomic::AtomicU8};\n        _39 = CheckedAdd(sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 1_u8);\n        assert(!move (_39.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 1_u8) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _38 = move (_39.0: u8);\n        StorageLive(_40);\n        _40 = core::sync::atomic::Ordering::Relaxed;\n        _36 = core::sync::atomic::AtomicU8::store(move _37, _38, move _40) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_40);\n        StorageDead(_37);\n        StorageLive(_41);\n        StorageLive(_42);\n        _87 = false;\n        _42 = move _17;\n        _41 = core::result::Result::Err(move _42);\n        StorageDead(_42);\n        _0 = core::option::Option::Some(move _41);\n        StorageDead(_41);\n        goto -> bb35;\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageLive(_44);\n        _44 = {alloc417: &core::sync::atomic::AtomicU8};\n        _46 = CheckedAdd(sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 2_u8);\n        assert(!move (_46.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 2_u8) -> [success: bb24, unwind unreachable];\n    }\n    bb24: {\n        _45 = move (_46.0: u8);\n        StorageLive(_47);\n        _47 = core::sync::atomic::Ordering::Relaxed;\n        _43 = core::sync::atomic::AtomicU8::store(move _44, _45, move _47) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_47);\n        StorageDead(_44);\n        _0 = core::option::Option::None;\n        goto -> bb35;\n    }\n    bb26: {\n        _49 = move (_50.0: u8);\n        _48 = Eq(_5, _49);\n        switchInt(move _48) -> [0: bb30, otherwise: bb27];\n    }\n    bb27: {\n        StorageLive(_52);\n        _52 = {alloc417: &core::sync::atomic::AtomicU8};\n        _54 = CheckedAdd(sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 1_u8);\n        assert(!move (_54.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 1_u8) -> [success: bb28, unwind unreachable];\n    }\n    bb28: {\n        _53 = move (_54.0: u8);\n        StorageLive(_55);\n        _55 = core::sync::atomic::Ordering::Relaxed;\n        _51 = core::sync::atomic::AtomicU8::store(move _52, _53, move _55) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_55);\n        StorageDead(_52);\n        goto -> bb31;\n    }\n    bb30: {\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_48);\n        StorageLive(_56);\n        _56 = core::mem::zeroed::<libc::stat64>() -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageLive(_58);\n        _58 = (_11.18: u32);\n        StorageLive(_59);\n        _59 = (_11.19: u32);\n        _57 = libc::makedev(move _58, move _59) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_59);\n        StorageDead(_58);\n        (_56.0: u64) = _57;\n        StorageLive(_60);\n        _60 = (_11.8: u64);\n        (_56.1: u64) = move _60;\n        StorageDead(_60);\n        StorageLive(_61);\n        _61 = (_11.3: u32);\n        (_56.3: u32) = move _61;\n        StorageDead(_61);\n        StorageLive(_62);\n        _62 = (_11.6: u16);\n        (_56.2: u32) = move _62 as u32;\n        StorageDead(_62);\n        StorageLive(_63);\n        _63 = (_11.4: u32);\n        (_56.4: u32) = move _63;\n        StorageDead(_63);\n        StorageLive(_64);\n        _64 = (_11.5: u32);\n        (_56.5: u32) = move _64;\n        StorageDead(_64);\n        StorageLive(_66);\n        _66 = (_11.16: u32);\n        StorageLive(_67);\n        _67 = (_11.17: u32);\n        _65 = libc::makedev(move _66, move _67) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_67);\n        StorageDead(_66);\n        (_56.6: u64) = _65;\n        StorageLive(_68);\n        _68 = (_11.9: u64);\n        (_56.8: i64) = move _68 as i64;\n        StorageDead(_68);\n        StorageLive(_69);\n        _69 = (_11.1: u32);\n        (_56.9: i32) = move _69 as i32;\n        StorageDead(_69);\n        StorageLive(_70);\n        _70 = (_11.10: u64);\n        (_56.11: i64) = move _70 as i64;\n        StorageDead(_70);\n        StorageLive(_71);\n        _71 = ((_11.12: libc::statx_timestamp).0: i64);\n        (_56.12: i64) = move _71;\n        StorageDead(_71);\n        StorageLive(_73);\n        _73 = ((_11.12: libc::statx_timestamp).1: u32);\n        _72 = move _73 as i64;\n        StorageDead(_73);\n        (_56.13: i64) = _72;\n        StorageLive(_74);\n        _74 = ((_11.15: libc::statx_timestamp).0: i64);\n        (_56.14: i64) = move _74;\n        StorageDead(_74);\n        StorageLive(_76);\n        _76 = ((_11.15: libc::statx_timestamp).1: u32);\n        _75 = move _76 as i64;\n        StorageDead(_76);\n        (_56.15: i64) = _75;\n        StorageLive(_77);\n        _77 = ((_11.14: libc::statx_timestamp).0: i64);\n        (_56.16: i64) = move _77;\n        StorageDead(_77);\n        StorageLive(_79);\n        _79 = ((_11.14: libc::statx_timestamp).1: u32);\n        _78 = move _79 as i64;\n        StorageDead(_79);\n        (_56.17: i64) = _78;\n        StorageLive(_81);\n        _81 = (_11.0: u32);\n        StorageLive(_82);\n        _82 = (_11.13: libc::statx_timestamp);\n        _80 = StatxExtraFields(move _81, move _82);\n        StorageDead(_82);\n        StorageDead(_81);\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = _56;\n        StorageLive(_86);\n        _86 = core::option::Option::Some(_80);\n        _84 = FileAttr(move _85, move _86);\n        StorageDead(_86);\n        StorageDead(_85);\n        _83 = core::result::Result::Ok(move _84);\n        StorageDead(_84);\n        _0 = core::option::Option::Some(move _83);\n        StorageDead(_83);\n        StorageDead(_56);\n        StorageDead(_11);\n        goto -> bb38;\n    }\n    bb35: {\n        StorageDead(_33);\n        StorageDead(_26);\n        goto -> bb41;\n    }\n    bb36: {\n        _87 = false;\n        StorageDead(_17);\n        StorageDead(_15);\n        StorageDead(_12);\n        StorageDead(_11);\n        goto -> bb37;\n    }\n    bb37: {\n        goto -> bb38;\n    }\n    bb38: {\n        return;\n    }\n    bb39: {\n        StorageDead(_15);\n        StorageDead(_12);\n        StorageLive(_48);\n        _50 = CheckedAdd(sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 0_u8);\n        assert(!move (_50.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::fs::unix::try_statx::STATX_STATE::Unknown::{constant#0}, 0_u8) -> [success: bb26, unwind unreachable];\n    }\n    bb40: {\n        drop(_17) -> [return: bb36, unwind unreachable];\n    }\n    bb41: {\n        switchInt(_87) -> [0: bb36, otherwise: bb40];\n    }\n    bb42: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}