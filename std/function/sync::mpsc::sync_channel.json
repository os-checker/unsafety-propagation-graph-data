{
  "name": "sync::mpsc::sync_channel",
  "safe": true,
  "callees": {
    "sync::mpmc::sync_channel": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new synchronous, bounded channel.\n\n All data sent on the [`Sender`] will become available on the [`Receiver`]\n in the same order as it was sent. Like asynchronous [`channel`]s, the\n [`Receiver`] will block until a message becomes available. `sync_channel`\n differs greatly in the semantics of the sender, however.\n\n This channel has an internal buffer on which messages will be queued.\n `bound` specifies the buffer size. When the internal buffer becomes full,\n future sends will *block* waiting for the buffer to open up. Note that a\n buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n where each [`send`] will not return until a [`recv`] is paired with it.\n\n The [`Sender`] can be cloned to [`send`] to the same channel multiple\n times. The [`Receiver`] also can be cloned to have multi receivers.\n\n Like asynchronous channels, if the [`Receiver`] is disconnected while trying\n to [`send`] with the [`Sender`], the [`send`] method will return a\n [`SendError`]. Similarly, If the [`Sender`] is disconnected while trying\n to [`recv`], the [`recv`] method will return a [`RecvError`].\n\n [`send`]: Sender::send\n [`recv`]: Receiver::recv\n\n # Examples\n\n ```\n use std::sync::mpsc::sync_channel;\n use std::thread;\n\n let (sender, receiver) = sync_channel(1);\n\n // this returns immediately\n sender.send(1).unwrap();\n\n thread::spawn(move || {\n     // this will block until the previous message has been received\n     sender.send(2).unwrap();\n });\n\n assert_eq!(receiver.recv().unwrap(), 1);\n assert_eq!(receiver.recv().unwrap(), 2);\n ```\n",
      "adt": {
        "sync::mpmc::Sender": "Constructor",
        "sync::mpmc::Receiver": "Constructor"
      }
    }
  },
  "adts": {
    "sync::mpmc::Sender": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11129, kind: RigidTy(Adt(AdtDef(DefId { id: 9502, name: \"sync::mpmc::Sender\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])",
      "Unknown([Field(1, Ty { id: 11131, kind: RigidTy(Adt(AdtDef(DefId { id: 9504, name: \"sync::mpmc::Receiver\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "sync::mpmc::Receiver": [
      "Plain",
      "Unknown([Field(0, Ty { id: 11129, kind: RigidTy(Adt(AdtDef(DefId { id: 9502, name: \"sync::mpmc::Sender\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])",
      "Unknown([Field(1, Ty { id: 11131, kind: RigidTy(Adt(AdtDef(DefId { id: 9504, name: \"sync::mpmc::Receiver\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "sync::mpsc::SyncSender": [
      "Plain"
    ],
    "sync::mpsc::Receiver": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpsc::sync_channel"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpsc.rs:569:1: 572:2",
  "src": "pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n    let (tx, rx) = mpmc::sync_channel(bound);\n    (SyncSender { inner: tx }, Receiver { inner: rx })\n}",
  "mir": "fn sync::mpsc::sync_channel(_1: usize) -> (sync::mpsc::SyncSender<T>, sync::mpsc::Receiver<T>) {\n    let mut _0: (sync::mpsc::SyncSender<T>, sync::mpsc::Receiver<T>);\n    let  _2: sync::mpmc::Sender<T>;\n    let  _3: sync::mpmc::Receiver<T>;\n    let mut _4: (sync::mpmc::Sender<T>, sync::mpmc::Receiver<T>);\n    let mut _5: sync::mpsc::SyncSender<T>;\n    let mut _6: sync::mpsc::Receiver<T>;\n    debug bound => _1;\n    debug tx => _2;\n    debug rx => _3;\n    bb0: {\n        StorageLive(_4);\n        _4 = sync::mpmc::sync_channel::<T>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = move (_4.0: sync::mpmc::Sender<T>);\n        _3 = move (_4.1: sync::mpmc::Receiver<T>);\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = SyncSender(_2);\n        StorageLive(_6);\n        _6 = Receiver(_3);\n        _0 = (move _5, move _6);\n        StorageDead(_6);\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Creates a new synchronous, bounded channel.\n\n All data sent on the [`SyncSender`] will become available on the [`Receiver`]\n in the same order as it was sent. Like asynchronous [`channel`]s, the\n [`Receiver`] will block until a message becomes available. `sync_channel`\n differs greatly in the semantics of the sender, however.\n\n This channel has an internal buffer on which messages will be queued.\n `bound` specifies the buffer size. When the internal buffer becomes full,\n future sends will *block* waiting for the buffer to open up. Note that a\n buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n where each [`send`] will not return until a [`recv`] is paired with it.\n\n The [`SyncSender`] can be cloned to [`send`] to the same channel multiple\n times, but only one [`Receiver`] is supported.\n\n Like asynchronous channels, if the [`Receiver`] is disconnected while trying\n to [`send`] with the [`SyncSender`], the [`send`] method will return a\n [`SendError`]. Similarly, If the [`SyncSender`] is disconnected while trying\n to [`recv`], the [`recv`] method will return a [`RecvError`].\n\n [`send`]: SyncSender::send\n [`recv`]: Receiver::recv\n\n # Examples\n\n ```\n use std::sync::mpsc::sync_channel;\n use std::thread;\n\n let (sender, receiver) = sync_channel(1);\n\n // this returns immediately\n sender.send(1).unwrap();\n\n thread::spawn(move || {\n     // this will block until the previous message has been received\n     sender.send(2).unwrap();\n });\n\n assert_eq!(receiver.recv().unwrap(), 1);\n assert_eq!(receiver.recv().unwrap(), 2);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}