{
  "name": "os::unix::net::datagram::UnixDatagram::peek_from",
  "safe": true,
  "callees": {
    "os::unix::net::datagram::UnixDatagram::recv_from_flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "os::unix::net::datagram::UnixDatagram": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "os::unix::net::datagram::UnixDatagram": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2168,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/datagram.rs:960:5: 962:6",
  "src": "pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.recv_from_flags(buf, libc::MSG_PEEK)\n    }",
  "mir": "fn os::unix::net::datagram::UnixDatagram::peek_from(_1: &os::unix::net::datagram::UnixDatagram, _2: &mut [u8]) -> core::result::Result<(usize, os::unix::net::addr::SocketAddr), io::error::Error> {\n    let mut _0: core::result::Result<(usize, os::unix::net::addr::SocketAddr), io::error::Error>;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        _0 = os::unix::net::datagram::UnixDatagram::recv_from_flags(_1, _2, libc::MSG_PEEK) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Receives a single datagram message on the socket, without removing it from the\n queue. On success, returns the number of bytes read and the origin.\n\n The function must be called with valid byte array `buf` of sufficient size to\n hold the message bytes. If a message is too long to fit in the supplied buffer,\n excess bytes may be discarded.\n\n Successive calls return the same data. This is accomplished by passing\n `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n\n Do not use this function to implement busy waiting, instead use `libc::poll` to\n synchronize IO events on one or more sockets.\n\n # Examples\n\n ```no_run\n #![feature(unix_socket_peek)]\n\n use std::os::unix::net::UnixDatagram;\n\n fn main() -> std::io::Result<()> {\n     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n     let mut buf = [0; 10];\n     let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}