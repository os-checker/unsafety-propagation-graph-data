{
  "name": "env::set_var",
  "safe": false,
  "callees": {
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "sys::env::unix::setenv": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::env::set_var"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:358:1: 363:2",
  "src": "pub unsafe fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(key: K, value: V) {\n    let (key, value) = (key.as_ref(), value.as_ref());\n    unsafe { env_imp::setenv(key, value) }.unwrap_or_else(|e| {\n        panic!(\"failed to set environment variable `{key:?}` to `{value:?}`: {e}\")\n    })\n}",
  "mir": "fn env::set_var(_1: K, _2: V) -> () {\n    let mut _0: ();\n    let  _3: &ffi::os_str::OsStr;\n    let  _4: &ffi::os_str::OsStr;\n    let mut _5: (&ffi::os_str::OsStr, &ffi::os_str::OsStr);\n    let mut _6: &ffi::os_str::OsStr;\n    let mut _7: &K;\n    let mut _8: &ffi::os_str::OsStr;\n    let mut _9: &V;\n    let mut _10: core::result::Result<(), io::error::Error>;\n    let mut _11: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:360:59: 360:62};\n    let mut _12: &&ffi::os_str::OsStr;\n    let mut _13: &&ffi::os_str::OsStr;\n    debug key => _1;\n    debug value => _2;\n    debug key => _3;\n    debug value => _4;\n    bb0: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_1;\n        _6 = <K as core::convert::AsRef<ffi::os_str::OsStr>>::as_ref(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_2;\n        _8 = <V as core::convert::AsRef<ffi::os_str::OsStr>>::as_ref(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        _5 = (move _6, move _8);\n        StorageDead(_8);\n        StorageDead(_6);\n        _3 = (_5.0: &ffi::os_str::OsStr);\n        _4 = (_5.1: &ffi::os_str::OsStr);\n        StorageDead(_5);\n        StorageLive(_10);\n        _10 = sys::env::unix::setenv(_3, _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_3;\n        StorageLive(_13);\n        _13 = &_4;\n        _11 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:360:59: 360:62}(move _12, move _13);\n        StorageDead(_13);\n        StorageDead(_12);\n        _0 = core::result::Result::<(), io::error::Error>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:360:59: 360:62}>(move _10, move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageDead(_10);\n        drop(_2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        drop(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Sets the environment variable `key` to the value `value` for the currently running\n process.\n\n # Safety\n\n This function is safe to call in a single-threaded program.\n\n This function is also always safe to call on Windows, in single-threaded\n and multi-threaded programs.\n\n In multi-threaded programs on other operating systems, the only safe option is\n to not use `set_var` or `remove_var` at all.\n\n The exact requirement is: you\n must ensure that there are no other threads concurrently writing or\n *reading*(!) the environment through functions or global variables other\n than the ones in this module. The problem is that these operating systems\n do not provide a thread-safe way to read the environment, and most C\n libraries, including libc itself, do not advertise which functions read\n from the environment. Even functions from the Rust standard library may\n read the environment without going through this module, e.g. for DNS\n lookups from [`std::net::ToSocketAddrs`]. No stable guarantee is made about\n which functions may read from the environment in future versions of a\n library. All this makes it not practically possible for you to guarantee\n that no other thread will read the environment, so the only safe option is\n to not use `set_var` or `remove_var` in multi-threaded programs at all.\n\n Discussion of this unsafety on Unix may be found in:\n\n  - [Austin Group Bugzilla (for POSIX)](https://austingroupbugs.net/view.php?id=188)\n  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n\n To pass an environment variable to a child process, you can instead use [`Command::env`].\n\n [`std::net::ToSocketAddrs`]: crate::net::ToSocketAddrs\n [`Command::env`]: crate::process::Command::env\n\n # Panics\n\n This function may panic if `key` is empty, contains an ASCII equals sign `'='`\n or the NUL character `'\\0'`, or when `value` contains the NUL character.\n\n # Examples\n\n ```\n use std::env;\n\n let key = \"KEY\";\n unsafe {\n     env::set_var(key, \"VALUE\");\n }\n assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}