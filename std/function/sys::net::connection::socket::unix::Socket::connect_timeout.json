{
  "name": "sys::net::connection::socket::unix::Socket::connect_timeout",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::unix::Socket::set_nonblocking": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "sys::net::connection::socket::socket_addr_to_c": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::net::SocketAddr": "MutableAsArgument",
        "sys::net::connection::socket::SocketAddrCRepr": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "sys::net::connection::socket::SocketAddrCRepr::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::SocketAddrCRepr": "MutableAsArgument"
      }
    },
    "libc::connect": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "io::error::Error::raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS error that this error represents (if any).\n\n If this [`Error`] was constructed via [`last_os_error`] or\n [`from_raw_os_error`], then this function will return [`Some`], otherwise\n it will return [`None`].\n\n [`last_os_error`]: Error::last_os_error\n [`from_raw_os_error`]: Error::from_raw_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_os_error(err: &Error) {\n     if let Some(raw_os_err) = err.raw_os_error() {\n         println!(\"raw OS error: {raw_os_err:?}\");\n     } else {\n         println!(\"Not an OS error\");\n     }\n }\n\n fn main() {\n     // Will print \"raw OS error: ...\".\n     print_os_error(&Error::last_os_error());\n     // Will print \"Not an OS error\".\n     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "io::error::Error": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::time::Duration::as_secs": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of _whole_ seconds contained by this `Duration`.\n\n The returned value does not include the fractional (nanosecond) part of the\n duration, which can be obtained using [`subsec_nanos`].\n\n # Examples\n\n ```\n use std::time::Duration;\n\n let duration = Duration::new(5, 730_023_852);\n assert_eq!(duration.as_secs(), 5);\n ```\n\n To determine the total number of seconds represented by the `Duration`\n including the fractional part, use [`as_secs_f64`] or [`as_secs_f32`]\n\n [`as_secs_f64`]: Duration::as_secs_f64\n [`as_secs_f32`]: Duration::as_secs_f32\n [`subsec_nanos`]: Duration::subsec_nanos\n",
      "adt": {}
    },
    "core::time::Duration::subsec_nanos": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the fractional part of this `Duration`, in nanoseconds.\n\n This method does **not** return the length of the duration when\n represented by nanoseconds. The returned number always represents a\n fractional portion of a second (i.e., it is less than one billion).\n\n # Examples\n\n ```\n use std::time::Duration;\n\n let duration = Duration::from_millis(5_010);\n assert_eq!(duration.as_secs(), 5);\n assert_eq!(duration.subsec_nanos(), 10_000_000);\n ```\n",
      "adt": {}
    },
    "time::Instant::now": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an instant corresponding to \"now\".\n\n # Examples\n\n ```\n use std::time::Instant;\n\n let now = Instant::now();\n ```\n",
      "adt": {
        "time::Instant": "Constructor"
      }
    },
    "time::Instant::elapsed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the amount of time elapsed since this instant.\n\n # Panics\n\n Previous Rust versions panicked when the current time was earlier than self. Currently this\n method returns a Duration of zero in that case. Future versions may reintroduce the panic.\n See [Monotonicity].\n\n [Monotonicity]: Instant#monotonicity\n\n # Examples\n\n ```no_run\n use std::thread::sleep;\n use std::time::{Duration, Instant};\n\n let instant = Instant::now();\n let three_secs = Duration::from_secs(3);\n sleep(three_secs);\n assert!(instant.elapsed() >= three_secs);\n ```\n",
      "adt": {
        "core::time::Duration": "Constructor",
        "time::Instant": "MutableAsArgument"
      }
    },
    "core::cmp::PartialOrd::ge": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests greater than or equal to (for `self` and `other`) and is used by\n the `>=` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 >= 1.0, true);\n assert_eq!(1.0 >= 2.0, false);\n assert_eq!(2.0 >= 1.0, true);\n ```\n",
      "adt": {}
    },
    "io::error::Error::from_static_message": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Creates a new I/O error from a known kind of error as well as a constant\n message.\n\n This function does not allocate.\n\n You should not use this directly, and instead use the `const_error!`\n macro: `io::const_error!(ErrorKind::Something, \"some_message\")`.\n\n This function should maybe change to `from_static_message<const MSG: &'static\n str>(kind: ErrorKind)` in the future, when const generics allow that.\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::hint::must_use": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An identity function that causes an `unused_must_use` warning to be\n triggered if the given value is not used (returned, stored in a variable,\n etc) by the caller.\n\n This is primarily intended for use in macro-generated code, in which a\n [`#[must_use]` attribute][must_use] either on a type or a function would not\n be convenient.\n\n [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n\n # Example\n\n ```\n #![feature(hint_must_use)]\n\n use core::fmt;\n\n pub struct Error(/* ... */);\n\n #[macro_export]\n macro_rules! make_error {\n     ($($args:expr),*) => {\n         core::hint::must_use({\n             let error = $crate::make_error(core::format_args!($($args),*));\n             error\n         })\n     };\n }\n\n // Implementation detail of make_error! macro.\n #[doc(hidden)]\n pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n     Error(/* ... */)\n }\n\n fn demo() -> Option<Error> {\n     if true {\n         // Oops, meant to write `return Some(make_error!(\"...\"));`\n         Some(make_error!(\"...\"));\n     }\n     None\n }\n #\n # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n # fn main() {}\n ```\n\n In the above example, we'd like an `unused_must_use` lint to apply to the\n value created by `make_error!`. However, neither `#[must_use]` on a struct\n nor `#[must_use]` on a function is appropriate here, so the macro expands\n using `core::hint::must_use` instead.\n\n - We wouldn't want `#[must_use]` on the `struct Error` because that would\n   make the following unproblematic code trigger a warning:\n\n   ```\n   # struct Error;\n   #\n   fn f(arg: &str) -> Result<(), Error>\n   # { Ok(()) }\n\n   #[test]\n   fn t() {\n       // Assert that `f` returns error if passed an empty string.\n       // A value of type `Error` is unused here but that's not a problem.\n       f(\"\").unwrap_err();\n   }\n   ```\n\n - Using `#[must_use]` on `fn make_error` can't help because the return value\n   *is* used, as the right-hand side of a `let` statement. The `let`\n   statement looks useless but is in fact necessary for ensuring that\n   temporaries within the `format_args` expansion are not kept alive past the\n   creation of the `Error`, as keeping them alive past that point can cause\n   autotrait issues in async code:\n\n   ```\n   # #![feature(hint_must_use)]\n   #\n   # struct Error;\n   #\n   # macro_rules! make_error {\n   #     ($($args:expr),*) => {\n   #         core::hint::must_use({\n   #             // If `let` isn't used, then `f()` produces a non-Send future.\n   #             let error = make_error(core::format_args!($($args),*));\n   #             error\n   #         })\n   #     };\n   # }\n   #\n   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n   #     Error\n   # }\n   #\n   async fn f() {\n       // Using `let` inside the make_error expansion causes temporaries like\n       // `unsync()` to drop at the semicolon of that `let` statement, which\n       // is prior to the await point. They would otherwise stay around until\n       // the semicolon on *this* statement, which is after the await point,\n       // and the enclosing Future would not implement Send.\n       log(make_error!(\"look: {:p}\", unsync())).await;\n   }\n\n   async fn log(error: Error) {/* ... */}\n\n   // Returns something without a Sync impl.\n   fn unsync() -> *const () {\n       0 as *const ()\n   }\n   #\n   # fn test() {\n   #     fn assert_send(_: impl Send) {}\n   #     assert_send(f());\n   # }\n   ```\n",
      "adt": {}
    },
    "core::ops::Sub::sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the `-` operation.\n\n # Example\n\n ```\n assert_eq!(12 - 1, 11);\n ```\n",
      "adt": {}
    },
    "core::num::<impl u64>::saturating_mul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer multiplication. Computes `self * rhs`,\n saturating at the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::num::<impl u64>::saturating_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Saturating integer addition. Computes `self + rhs`, saturating at\n the numeric bounds instead of overflowing.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "libc::poll": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "io::error::Error::is_interrupted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "sys::net::connection::socket::unix::Socket::take_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7535, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::net::SocketAddr": [
      "Ref"
    ],
    "sys::net::connection::socket::SocketAddrCRepr": [
      "Plain",
      "Unknown([Field(0, Ty { id: 16251, kind: RigidTy(Adt(AdtDef(DefId { id: 11930, name: \"sys::net::connection::socket::SocketAddrCRepr\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Ref"
    ],
    "io::error::Error": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ],
    "libc::pollfd": [
      "Plain",
      "MutRef",
      "Deref",
      "Unknown([Field(2, Ty { id: 791, kind: RigidTy(Int(I16)) })])"
    ],
    "core::time::Duration": [
      "Ref",
      "Plain"
    ],
    "time::Instant": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::net::connection::socket::unix::Socket::connect_timeout"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/net/connection/socket/unix.rs:165:5: 239:6",
  "src": "pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n        self.set_nonblocking(true)?;\n        let r = unsafe {\n            let (addr, len) = socket_addr_to_c(addr);\n            cvt(libc::connect(self.as_raw_fd(), addr.as_ptr(), len))\n        };\n        self.set_nonblocking(false)?;\n\n        match r {\n            Ok(_) => return Ok(()),\n            // there's no ErrorKind for EINPROGRESS :(\n            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n            Err(e) => return Err(e),\n        }\n\n        let mut pollfd = libc::pollfd { fd: self.as_raw_fd(), events: libc::POLLOUT, revents: 0 };\n\n        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n            return Err(io::Error::ZERO_TIMEOUT);\n        }\n\n        let start = Instant::now();\n\n        loop {\n            let elapsed = start.elapsed();\n            if elapsed >= timeout {\n                return Err(io::const_error!(io::ErrorKind::TimedOut, \"connection timed out\"));\n            }\n\n            let timeout = timeout - elapsed;\n            let mut timeout = timeout\n                .as_secs()\n                .saturating_mul(1_000)\n                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n            if timeout == 0 {\n                timeout = 1;\n            }\n\n            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n\n            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n                -1 => {\n                    let err = io::Error::last_os_error();\n                    if !err.is_interrupted() {\n                        return Err(err);\n                    }\n                }\n                0 => {}\n                _ => {\n                    if cfg!(target_os = \"vxworks\") {\n                        // VxWorks poll does not return  POLLHUP or POLLERR in revents. Check if the\n                        // connection actually succeeded and return ok only when the socket is\n                        // ready and no errors were found.\n                        if let Some(e) = self.take_error()? {\n                            return Err(e);\n                        }\n                    } else {\n                        // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n                        // for POLLHUP or POLLERR rather than read readiness\n                        if pollfd.revents & (libc::POLLHUP | libc::POLLERR) != 0 {\n                            let e = self.take_error()?.unwrap_or_else(|| {\n                                io::const_error!(\n                                    io::ErrorKind::Uncategorized,\n                                    \"no error set after POLLHUP\",\n                                )\n                            });\n                            return Err(e);\n                        }\n                    }\n\n                    return Ok(());\n                }\n            }\n        }\n    }",
  "mir": "fn sys::net::connection::socket::unix::Socket::connect_timeout(_1: &sys::net::connection::socket::unix::Socket, _2: &core::net::SocketAddr, _3: core::time::Duration) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _5: core::result::Result<(), io::error::Error>;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _8: core::result::Result<i32, io::error::Error>;\n    let  _9: sys::net::connection::socket::SocketAddrCRepr;\n    let  _10: u32;\n    let mut _11: (sys::net::connection::socket::SocketAddrCRepr, u32);\n    let mut _12: i32;\n    let mut _13: i32;\n    let mut _14: *const libc::sockaddr;\n    let mut _15: &sys::net::connection::socket::SocketAddrCRepr;\n    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _17: core::result::Result<(), io::error::Error>;\n    let mut _18: isize;\n    let  _19: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _20: isize;\n    let  _21: &io::error::Error;\n    let  _22: &&io::error::Error;\n    let mut _23: bool;\n    let mut _24: &core::option::Option<i32>;\n    let  _25: core::option::Option<i32>;\n    let mut _26: &core::option::Option<i32>;\n    let  _27: io::error::Error;\n    let mut _28: libc::pollfd;\n    let mut _29: i32;\n    let mut _30: u64;\n    let mut _31: &core::time::Duration;\n    let mut _32: u32;\n    let mut _33: &core::time::Duration;\n    let  _34: time::Instant;\n    let  _35: core::time::Duration;\n    let mut _36: &time::Instant;\n    let mut _37: bool;\n    let mut _38: &core::time::Duration;\n    let mut _39: &core::time::Duration;\n    let mut _40: io::error::Error;\n    let mut _41: io::error::Error;\n    let  _42: core::time::Duration;\n    let mut _43: u64;\n    let mut _44: u64;\n    let mut _45: u64;\n    let mut _46: &core::time::Duration;\n    let mut _47: u64;\n    let mut _48: u64;\n    let mut _49: u32;\n    let mut _50: &core::time::Duration;\n    let mut _51: bool;\n    let mut _52: u64;\n    let  _53: i32;\n    let mut _54: u64;\n    let mut _55: u64;\n    let mut _56: u64;\n    let mut _57: i32;\n    let mut _58: *mut libc::pollfd;\n    let mut _59: &mut libc::pollfd;\n    let  _60: io::error::Error;\n    let mut _61: bool;\n    let mut _62: &io::error::Error;\n    let mut _63: io::error::Error;\n    let  _64: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _65: core::option::Option<io::error::Error>;\n    let  _66: io::error::Error;\n    let mut _67: i16;\n    let mut _68: i16;\n    let mut _69: i16;\n    let  _70: io::error::Error;\n    let mut _71: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, core::option::Option<io::error::Error>>;\n    let mut _72: core::result::Result<core::option::Option<io::error::Error>, io::error::Error>;\n    let mut _73: isize;\n    let  _74: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _75: core::option::Option<io::error::Error>;\n    let mut _76: &io::error::Error;\n    let mut _77: bool;\n    let mut _78: isize;\n    debug self => _1;\n    debug addr => _2;\n    debug timeout => _3;\n    debug residual => _7;\n    debug val => ();\n    debug r => _8;\n    debug addr => _9;\n    debug len => _10;\n    debug residual => _19;\n    debug val => ();\n    debug e => _21;\n    debug e => _22;\n    debug e => _27;\n    debug pollfd => _28;\n    debug start => _34;\n    debug elapsed => _35;\n    debug timeout => _42;\n    debug timeout => _43;\n    debug timeout => _53;\n    debug err => _60;\n    debug residual => _64;\n    debug val => _65;\n    debug e => _66;\n    debug e => _70;\n    debug residual => _74;\n    debug val => _75;\n    bb0: {\n        _77 = false;\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = sys::net::connection::socket::unix::Socket::set_nonblocking(_1, true) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageLive(_8);\n        StorageLive(_11);\n        _11 = sys::net::connection::socket::socket_addr_to_c(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _7 = move ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        goto -> bb69;\n    }\n    bb7: {\n        StorageLive(_9);\n        _9 = move (_11.0: sys::net::connection::socket::SocketAddrCRepr);\n        _10 = (_11.1: u32);\n        StorageDead(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = <sys::net::connection::socket::unix::Socket as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_9;\n        _14 = sys::net::connection::socket::SocketAddrCRepr::as_ptr(move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        _12 = libc::connect(move _13, move _14, _10) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _8 = sys::pal::unix::cvt::<i32>(move _12) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _77 = true;\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = sys::net::connection::socket::unix::Socket::set_nonblocking(_1, false) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _16 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb14, 1: bb15, otherwise: bb3];\n    }\n    bb14: {\n        StorageDead(_16);\n        _20 = discriminant(_8);\n        switchInt(move _20) -> [0: bb18, 1: bb17, otherwise: bb3];\n    }\n    bb15: {\n        _19 = move ((_16 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_19) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_16);\n        goto -> bb73;\n    }\n    bb17: {\n        StorageLive(_22);\n        StorageLive(_21);\n        _21 = &((_8 as variant#1).0: io::error::Error);\n        _22 = &_21;\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _76 = (*_22);\n        _25 = io::error::Error::raw_os_error(_76) -> [return: bb19, unwind unreachable];\n    }\n    bb18: {\n        _0 = core::result::Result::Ok(());\n        goto -> bb73;\n    }\n    bb19: {\n        _24 = &_25;\n        StorageLive(_26);\n        _26 = sys::net::connection::socket::unix::Socket::connect_timeout::promoted[0];\n        _23 = <core::option::Option<i32> as core::cmp::PartialEq>::eq(move _24, move _26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        switchInt(move _23) -> [0: bb22, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_21);\n        StorageDead(_22);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = <sys::net::connection::socket::unix::Socket as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb23, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_21);\n        StorageDead(_22);\n        _77 = false;\n        _27 = move ((_8 as variant#1).0: io::error::Error);\n        _0 = core::result::Result::Err(_27);\n        goto -> bb73;\n    }\n    bb23: {\n        _28 = pollfd(move _29, libc::POLLOUT, 0_i16);\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = &_3;\n        _30 = core::time::Duration::as_secs(move _31) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_31);\n        switchInt(move _30) -> [0: bb25, otherwise: bb29];\n    }\n    bb25: {\n        StorageDead(_30);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_3;\n        _32 = core::time::Duration::subsec_nanos(move _33) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_33);\n        switchInt(move _32) -> [0: bb27, otherwise: bb28];\n    }\n    bb27: {\n        StorageDead(_32);\n        _0 = core::result::Result::Err(io::error::Error::ZERO_TIMEOUT);\n        goto -> bb68;\n    }\n    bb28: {\n        StorageDead(_32);\n        goto -> bb30;\n    }\n    bb29: {\n        StorageDead(_30);\n        goto -> bb30;\n    }\n    bb30: {\n        StorageLive(_34);\n        _34 = time::Instant::now() -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageLive(_36);\n        _36 = &_34;\n        _35 = time::Instant::elapsed(move _36) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &_35;\n        StorageLive(_39);\n        _39 = &_3;\n        _37 = <core::time::Duration as core::cmp::PartialOrd>::ge(move _38, move _39) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        switchInt(move _37) -> [0: bb37, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageLive(_40);\n        StorageLive(_41);\n        _41 = io::error::Error::from_static_message(sys::net::connection::socket::unix::Socket::connect_timeout::{constant#0}) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _40 = core::hint::must_use::<io::error::Error>(move _41) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_41);\n        _0 = core::result::Result::Err(move _40);\n        StorageDead(_40);\n        StorageDead(_37);\n        goto -> bb67;\n    }\n    bb37: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageLive(_42);\n        _42 = <core::time::Duration as core::ops::Sub>::sub(_3, _35) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = &_42;\n        _45 = core::time::Duration::as_secs(move _46) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_46);\n        _44 = core::num::<impl u64>::saturating_mul(move _45, 1000_u64) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_45);\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        StorageLive(_50);\n        _50 = &_42;\n        _49 = core::time::Duration::subsec_nanos(move _50) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_50);\n        _48 = move _49 as u64;\n        StorageDead(_49);\n        _51 = Eq(1000000_u64, 0_u64);\n        assert(!move _51, \"attempt to divide `{}` by zero\", _48) -> [success: bb42, unwind unreachable];\n    }\n    bb42: {\n        _47 = Div(move _48, 1000000_u64);\n        StorageDead(_48);\n        _43 = core::num::<impl u64>::saturating_add(move _44, move _47) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_47);\n        StorageDead(_44);\n        StorageLive(_52);\n        _52 = _43;\n        switchInt(move _52) -> [0: bb44, otherwise: bb45];\n    }\n    bb44: {\n        StorageDead(_52);\n        _43 = 1_u64;\n        goto -> bb46;\n    }\n    bb45: {\n        StorageDead(_52);\n        goto -> bb46;\n    }\n    bb46: {\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = _43;\n        StorageLive(_56);\n        _56 = core::num::<impl i32>::MAX as u64;\n        _54 = core::cmp::min::<u64>(move _55, move _56) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_56);\n        StorageDead(_55);\n        _53 = move _54 as i32;\n        StorageDead(_54);\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = &mut _28;\n        _58 = &raw mut (*_59);\n        _57 = libc::poll(move _58, 1_u64, _53) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_59);\n        StorageDead(_58);\n        switchInt(_57) -> [4294967295: bb49, 0: bb64, otherwise: bb55];\n    }\n    bb49: {\n        StorageLive(_60);\n        _60 = io::error::Error::last_os_error() -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = &_60;\n        _61 = io::error::Error::is_interrupted(move _62) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        switchInt(move _61) -> [0: bb53, otherwise: bb52];\n    }\n    bb52: {\n        StorageDead(_62);\n        StorageDead(_61);\n        drop(_60) -> [return: bb54, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_62);\n        StorageLive(_63);\n        _63 = move _60;\n        _0 = core::result::Result::Err(move _63);\n        StorageDead(_63);\n        StorageDead(_61);\n        StorageDead(_60);\n        goto -> bb66;\n    }\n    bb54: {\n        StorageDead(_60);\n        goto -> bb64;\n    }\n    bb55: {\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = (_28.2: i16);\n        StorageLive(_69);\n        _69 = BitOr(libc::POLLHUP, libc::POLLERR);\n        _67 = BitAnd(move _68, move _69);\n        StorageDead(_69);\n        StorageDead(_68);\n        switchInt(move _67) -> [0: bb63, otherwise: bb56];\n    }\n    bb56: {\n        StorageDead(_67);\n        StorageLive(_71);\n        StorageLive(_72);\n        _72 = sys::net::connection::socket::unix::Socket::take_error(_1) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        _71 = <core::result::Result<core::option::Option<io::error::Error>, io::error::Error> as core::ops::Try>::branch(move _72) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_72);\n        _73 = discriminant(_71);\n        switchInt(move _73) -> [0: bb59, 1: bb60, otherwise: bb3];\n    }\n    bb59: {\n        _75 = move ((_71 as variant#0).0: core::option::Option<io::error::Error>);\n        _70 = core::option::Option::<io::error::Error>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/net/connection/socket/unix.rs:225:71: 225:73}>(_75, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/net/connection/socket/unix.rs:225:71: 225:73}) -> [return: bb62, unwind unreachable];\n    }\n    bb60: {\n        _74 = move ((_71 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_74) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_71);\n        goto -> bb65;\n    }\n    bb62: {\n        StorageDead(_71);\n        _0 = core::result::Result::Err(_70);\n        goto -> bb65;\n    }\n    bb63: {\n        StorageDead(_67);\n        _0 = core::result::Result::Ok(());\n        goto -> bb66;\n    }\n    bb64: {\n        StorageDead(_57);\n        StorageDead(_43);\n        StorageDead(_42);\n        goto -> bb31;\n    }\n    bb65: {\n        goto -> bb66;\n    }\n    bb66: {\n        StorageDead(_57);\n        StorageDead(_43);\n        StorageDead(_42);\n        goto -> bb67;\n    }\n    bb67: {\n        StorageDead(_34);\n        goto -> bb68;\n    }\n    bb68: {\n        StorageDead(_28);\n        goto -> bb73;\n    }\n    bb69: {\n        return;\n    }\n    bb70: {\n        _77 = false;\n        StorageDead(_8);\n        goto -> bb69;\n    }\n    bb71: {\n        switchInt(_77) -> [0: bb70, otherwise: bb72];\n    }\n    bb72: {\n        drop(((_8 as variant#1).0: io::error::Error)) -> [return: bb70, unwind unreachable];\n    }\n    bb73: {\n        _78 = discriminant(_8);\n        switchInt(move _78) -> [1: bb71, 0: bb70, otherwise: bb3];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}