{
  "name": "sys::personality::dwarf::eh::read_encoded_pointer",
  "safe": false,
  "callees": {
    "core::ptr::const_ptr::<impl *const T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"Follow the rabbit\";\n let ptr: *const u8 = s.as_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::ptr::null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*const T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *const i32 = ptr::null();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "sys::personality::dwarf::eh::round_up": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::with_addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new pointer with the given address and the [provenance][crate::ptr#provenance] of\n `self`.\n\n This is similar to a `addr as *const T` cast, but copies\n the *provenance* of `self` to the new pointer.\n This avoids the inherent ambiguity of the unary cast.\n\n This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset\n `self` to the given address, and therefore has all the same capabilities and restrictions.\n\n This is a [Strict Provenance][crate::ptr#strict-provenance] API.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sys::personality::dwarf::DwarfReader::read": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Read a type T and then bump the pointer by that amount.\n\n DWARF streams are \"packed\", so all types must be read at align 1.\n",
      "adt": {
        "sys::personality::dwarf::DwarfReader": "MutableAsArgument"
      }
    },
    "sys::personality::dwarf::eh::read_encoded_offset": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads an offset (`usize`) from `reader` whose encoding is described by `encoding`.\n\n `encoding` must be a [DWARF Exception Header Encoding as described by the LSB spec][LSB-dwarf-ext].\n In addition the upper (\"application\") part must be zero.\n\n # Errors\n Returns `Err` if `encoding`\n * is not a valid DWARF Exception Header Encoding,\n * is `DW_EH_PE_omit`, or\n * has a non-zero application part.\n\n [LSB-dwarf-ext]: https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/dwarfext.html\n",
      "adt": {
        "core::result::Result": "Constructor",
        "sys::personality::dwarf::DwarfReader": "MutableAsArgument"
      }
    },
    "core::ptr::const_ptr::<impl *const T>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds an unsigned offset to a pointer using wrapping arithmetic.\n\n `count` is in units of T; e.g., a `count` of 3 represents a pointer\n offset of `3 * size_of::<T>()` bytes.\n\n # Safety\n\n This operation itself is always safe, but using the resulting pointer is not.\n\n The resulting pointer \"remembers\" the [allocation] that `self` points to; it must not\n be used to read or write other allocations.\n\n In other words, `let z = x.wrapping_add((y as usize) - (x as usize))` does *not* make `z`\n the same as `y` even if we assume `T` has size `1` and there is no overflow: `z` is still\n attached to the object `x` is attached to, and dereferencing it is Undefined Behavior unless\n `x` and `y` point into the same allocation.\n\n Compared to [`add`], this method basically delays the requirement of staying within the\n same allocation: [`add`] is immediate Undefined Behavior when crossing object\n boundaries; `wrapping_add` produces a pointer but still leads to Undefined Behavior if a\n pointer is dereferenced when it is out-of-bounds of the object it is attached to. [`add`]\n can be optimized better and is thus preferable in performance-sensitive code.\n\n The delayed check only considers the value of the pointer that was dereferenced, not the\n intermediate values used during the computation of the final result. For example,\n `x.wrapping_add(o).wrapping_sub(o)` is always the same as `x`. In other words, leaving the\n allocation and then re-entering it later is permitted.\n\n [`add`]: #method.add\n [allocation]: crate::ptr#allocation\n\n # Examples\n\n ```\n # use std::fmt::Write;\n // Iterate using a raw pointer in increments of two elements\n let data = [1u8, 2, 3, 4, 5];\n let mut ptr: *const u8 = data.as_ptr();\n let step = 2;\n let end_rounded_up = ptr.wrapping_add(6);\n\n let mut out = String::new();\n while ptr != end_rounded_up {\n     unsafe {\n         write!(&mut out, \"{}, \", *ptr)?;\n     }\n     ptr = ptr.wrapping_add(step);\n }\n assert_eq!(out, \"1, 3, 5, \");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "sys::personality::dwarf::DwarfReader": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "sys::personality::dwarf::eh::EHContext": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::personality::dwarf::eh::read_encoded_pointer"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/personality/dwarf/eh.rs:225:1: 271:2",
  "src": "unsafe fn read_encoded_pointer(\n    reader: &mut DwarfReader,\n    context: &EHContext<'_>,\n    encoding: u8,\n) -> Result<*const u8, ()> {\n    if encoding == DW_EH_PE_omit {\n        return Err(());\n    }\n\n    let base_ptr = match encoding & 0x70 {\n        DW_EH_PE_absptr => core::ptr::null(),\n        // relative to address of the encoded value, despite the name\n        DW_EH_PE_pcrel => reader.ptr,\n        DW_EH_PE_funcrel => {\n            if context.func_start.is_null() {\n                return Err(());\n            }\n            context.func_start\n        }\n        DW_EH_PE_textrel => (*context.get_text_start)(),\n        DW_EH_PE_datarel => (*context.get_data_start)(),\n        // aligned means the value is aligned to the size of a pointer\n        DW_EH_PE_aligned => {\n            reader.ptr = reader.ptr.with_addr(round_up(reader.ptr.addr(), size_of::<*const u8>())?);\n            core::ptr::null()\n        }\n        _ => return Err(()),\n    };\n\n    let mut ptr = if base_ptr.is_null() {\n        // any value encoding other than absptr would be nonsensical here;\n        // there would be no source of pointer provenance\n        if encoding & 0x0F != DW_EH_PE_absptr {\n            return Err(());\n        }\n        unsafe { reader.read::<*const u8>() }\n    } else {\n        let offset = unsafe { read_encoded_offset(reader, encoding & 0x0F)? };\n        base_ptr.wrapping_add(offset)\n    };\n\n    if encoding & DW_EH_PE_indirect != 0 {\n        ptr = unsafe { *(ptr.cast::<*const u8>()) };\n    }\n\n    Ok(ptr)\n}",
  "mir": "fn sys::personality::dwarf::eh::read_encoded_pointer(_1: &mut sys::personality::dwarf::DwarfReader, _2: &sys::personality::dwarf::eh::EHContext<'_>, _3: u8) -> core::result::Result<*const u8, ()> {\n    let mut _0: core::result::Result<*const u8, ()>;\n    let mut _4: bool;\n    let  _5: *const u8;\n    let mut _6: u8;\n    let mut _7: bool;\n    let mut _8: *const u8;\n    let mut _9: *const u8;\n    let mut _10: *const u8;\n    let mut _11: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, ()>, usize>;\n    let mut _12: core::result::Result<usize, ()>;\n    let mut _13: usize;\n    let mut _14: *const u8;\n    let mut _15: usize;\n    let mut _16: isize;\n    let  _17: usize;\n    let mut _18: *const u8;\n    let mut _19: bool;\n    let mut _20: *const u8;\n    let mut _21: bool;\n    let mut _22: u8;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, ()>, usize>;\n    let mut _24: core::result::Result<usize, ()>;\n    let mut _25: u8;\n    let mut _26: isize;\n    let  _27: usize;\n    let mut _28: *const u8;\n    let mut _29: u8;\n    let mut _30: *const u8;\n    let mut _31: *const *const u8;\n    let mut _32: *const u8;\n    let mut _33: *const u8;\n    let mut _34: &dyn core::ops::Fn() -> *const u8;\n    let mut _35: &dyn core::ops::Fn() -> *const u8;\n    let mut _36: *const ();\n    let mut _37: usize;\n    let mut _38: usize;\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: *const ();\n    let mut _42: usize;\n    let mut _43: bool;\n    let mut _44: bool;\n    let mut _45: bool;\n    let mut _46: bool;\n    debug reader => _1;\n    debug context => _2;\n    debug encoding => _3;\n    debug base_ptr => _5;\n    debug residual => core::result::Result::<core::convert::Infallible, ()>::Err(());\n    debug val => _17;\n    debug ptr => _18;\n    debug offset => _27;\n    debug residual => core::result::Result::<core::convert::Infallible, ()>::Err(());\n    debug val => _27;\n    bb0: {\n        StorageLive(_4);\n        _4 = Eq(_3, sys::personality::dwarf::eh::DW_EH_PE_omit);\n        switchInt(move _4) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = core::result::Result::Err(());\n        StorageDead(_4);\n        goto -> bb45;\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = BitAnd(_3, 112_u8);\n        switchInt(_6) -> [0: bb9, 16: bb8, 64: bb7, 32: bb6, 48: bb5, 80: bb4, otherwise: bb3];\n    }\n    bb3: {\n        _0 = core::result::Result::Err(());\n        goto -> bb43;\n    }\n    bb4: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = ((*_1).0: *const u8);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = ((*_1).0: *const u8);\n        _13 = core::ptr::const_ptr::<impl *const u8>::addr(move _14) -> [return: bb15, unwind unreachable];\n    }\n    bb5: {\n        _34 = ((*_2).3: &dyn core::ops::Fn() -> *const u8);\n        _5 = <dyn core::ops::Fn() -> *const u8 as core::ops::Fn<()>>::call(_34, ()) -> [return: bb14, unwind unreachable];\n    }\n    bb6: {\n        _35 = ((*_2).2: &dyn core::ops::Fn() -> *const u8);\n        _5 = <dyn core::ops::Fn() -> *const u8 as core::ops::Fn<()>>::call(_35, ()) -> [return: bb13, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = ((*_2).1: *const u8);\n        _7 = core::ptr::const_ptr::<impl *const u8>::is_null(move _8) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _5 = ((*_1).0: *const u8);\n        goto -> bb24;\n    }\n    bb9: {\n        _5 = core::ptr::null::<u8>() -> [return: bb24, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _7) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_8);\n        _0 = core::result::Result::Err(());\n        StorageDead(_7);\n        goto -> bb43;\n    }\n    bb12: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _5 = ((*_2).1: *const u8);\n        goto -> bb24;\n    }\n    bb13: {\n        goto -> bb24;\n    }\n    bb14: {\n        goto -> bb24;\n    }\n    bb15: {\n        StorageDead(_14);\n        StorageLive(_15);\n        _15 = core::mem::size_of::<*const u8>() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _12 = sys::personality::dwarf::eh::round_up(move _13, move _15) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_15);\n        StorageDead(_13);\n        _11 = <core::result::Result<usize, ()> as core::ops::Try>::branch(move _12) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_12);\n        _16 = discriminant(_11);\n        switchInt(move _16) -> [0: bb20, 1: bb21, otherwise: bb19];\n    }\n    bb19: {\n        unreachable;\n    }\n    bb20: {\n        _17 = ((_11 as variant#0).0: usize);\n        _9 = core::ptr::const_ptr::<impl *const u8>::with_addr(move _10, _17) -> [return: bb23, unwind unreachable];\n    }\n    bb21: {\n        _0 = <core::result::Result<*const u8, ()> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, ()>>>::from_residual(core::result::Result::<core::convert::Infallible, ()>::Err(())) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_11);\n        goto -> bb43;\n    }\n    bb23: {\n        StorageDead(_10);\n        ((*_1).0: *const u8) = move _9;\n        StorageDead(_9);\n        StorageDead(_11);\n        _5 = core::ptr::null::<u8>() -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_6);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = _5;\n        _19 = core::ptr::const_ptr::<impl *const u8>::is_null(move _20) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _19) -> [0: bb30, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = BitAnd(_3, 15_u8);\n        _21 = Ne(move _22, sys::personality::dwarf::eh::DW_EH_PE_absptr);\n        switchInt(move _21) -> [0: bb28, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_22);\n        _0 = core::result::Result::Err(());\n        StorageDead(_21);\n        goto -> bb42;\n    }\n    bb28: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _18 = sys::personality::dwarf::DwarfReader::read::<*const u8>(_1) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        goto -> bb37;\n    }\n    bb30: {\n        StorageDead(_20);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = BitAnd(_3, 15_u8);\n        _24 = sys::personality::dwarf::eh::read_encoded_offset(_1, move _25) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_25);\n        _23 = <core::result::Result<usize, ()> as core::ops::Try>::branch(move _24) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_24);\n        _26 = discriminant(_23);\n        switchInt(move _26) -> [0: bb33, 1: bb34, otherwise: bb19];\n    }\n    bb33: {\n        _27 = ((_23 as variant#0).0: usize);\n        StorageDead(_23);\n        StorageLive(_28);\n        _28 = _5;\n        _18 = core::ptr::const_ptr::<impl *const u8>::wrapping_add(move _28, _27) -> [return: bb36, unwind unreachable];\n    }\n    bb34: {\n        _0 = <core::result::Result<*const u8, ()> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, ()>>>::from_residual(core::result::Result::<core::convert::Infallible, ()>::Err(())) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_23);\n        goto -> bb42;\n    }\n    bb36: {\n        StorageDead(_28);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_19);\n        StorageLive(_29);\n        _29 = BitAnd(_3, sys::personality::dwarf::eh::DW_EH_PE_indirect);\n        switchInt(move _29) -> [0: bb40, otherwise: bb38];\n    }\n    bb38: {\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = _18;\n        _31 = core::ptr::const_ptr::<impl *const u8>::cast::<*const u8>(move _32) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_32);\n        _36 = _31 as *const ();\n        _37 = _36 as usize;\n        _38 = Sub(<*const u8 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _39 = BitAnd(_37, _38);\n        _40 = Eq(_39, 0_usize);\n        assert(_40, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<*const u8 as core::mem::SizedTypeProperties>::ALIGN, _37) -> [success: bb46, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_29);\n        goto -> bb41;\n    }\n    bb41: {\n        StorageLive(_33);\n        _33 = _18;\n        _0 = core::result::Result::Ok(move _33);\n        StorageDead(_33);\n        StorageDead(_18);\n        StorageDead(_5);\n        goto -> bb45;\n    }\n    bb42: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb44;\n    }\n    bb43: {\n        StorageDead(_6);\n        goto -> bb44;\n    }\n    bb44: {\n        StorageDead(_5);\n        goto -> bb45;\n    }\n    bb45: {\n        return;\n    }\n    bb46: {\n        _41 = _31 as *const ();\n        _42 = _41 as usize;\n        _43 = Ne(<*const u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _44 = Eq(_42, 0_usize);\n        _45 = BitAnd(_44, _43);\n        _46 = Not(_45);\n        assert(_46, \"null pointer dereference occurred\") -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _30 = (*_31);\n        StorageDead(_31);\n        _18 = move _30;\n        StorageDead(_30);\n        goto -> bb41;\n    }\n}\n",
  "doc": " Reads a pointer from `reader` whose encoding is described by `encoding`.\n\n `encoding` must be a [DWARF Exception Header Encoding as described by the LSB spec][LSB-dwarf-ext].\n\n # Errors\n Returns `Err` if `encoding`\n * is not a valid DWARF Exception Header Encoding,\n * is `DW_EH_PE_omit`, or\n * combines `DW_EH_PE_absptr` or `DW_EH_PE_aligned` application part with an integer encoding\n   (not `DW_EH_PE_absptr`) in the value format part.\n\n [LSB-dwarf-ext]: https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/dwarfext.html\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}