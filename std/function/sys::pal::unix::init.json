{
  "name": "sys::pal::unix::init",
  "safe": false,
  "callees": {
    "sys::pal::unix::init::sanitize_standard_fds": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::init::reset_sigpipe": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::stack_overflow::imp::init": {
      "safe": false,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "unsafe_op_in_unsafe_fn"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* unsafe_op_in_unsafe_fn\n"
        ]
      },
      "doc": " # Safety\n Must be called only once\n",
      "adt": {}
    },
    "sys::args::unix::init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " One-time global initialization.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 4042,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:26:1: 192:2",
  "src": "pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n    // The standard streams might be closed on application startup. To prevent\n    // std::io::{stdin, stdout,stderr} objects from using other unrelated file\n    // resources opened later, we reopen standards streams when they are closed.\n    sanitize_standard_fds();\n\n    // By default, some platforms will send a *signal* when an EPIPE error\n    // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n    // handler, causing it to kill the program, which isn't exactly what we\n    // want!\n    //\n    // Hence, we set SIGPIPE to ignore when the program starts up in order\n    // to prevent this problem. Use `-Zon-broken-pipe=...` to alter this\n    // behavior.\n    reset_sigpipe(sigpipe);\n\n    stack_overflow::init();\n    #[cfg(not(target_os = \"vita\"))]\n    crate::sys::args::init(argc, argv);\n\n    // Normally, `thread::spawn` will call `Thread::set_name` but since this thread\n    // already exists, we have to call it ourselves. We only do this on Apple targets\n    // because some unix-like operating systems such as Linux share process-id and\n    // thread-id for the main thread and so renaming the main thread will rename the\n    // process and we only want to enable this on platforms we've tested.\n    if cfg!(target_vendor = \"apple\") {\n        crate::sys::thread::set_name(c\"main\");\n    }\n\n    unsafe fn sanitize_standard_fds() {\n        #[allow(dead_code, unused_variables, unused_mut)]\n        let mut opened_devnull = -1;\n        #[allow(dead_code, unused_variables, unused_mut)]\n        let mut open_devnull = || {\n            #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n            use libc::open;\n            #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n            use libc::open64 as open;\n\n            if opened_devnull != -1 {\n                if libc::dup(opened_devnull) != -1 {\n                    return;\n                }\n            }\n            opened_devnull = open(c\"/dev/null\".as_ptr(), libc::O_RDWR, 0);\n            if opened_devnull == -1 {\n                // If the stream is closed but we failed to reopen it, abort the\n                // process. Otherwise we wouldn't preserve the safety of\n                // operations on the corresponding Rust object Stdin, Stdout, or\n                // Stderr.\n                libc::abort();\n            }\n        };\n\n        // fast path with a single syscall for systems with poll()\n        #[cfg(not(any(\n            miri,\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"vxworks\",\n            target_os = \"redox\",\n            target_os = \"l4re\",\n            target_os = \"horizon\",\n            target_os = \"vita\",\n            target_os = \"rtems\",\n            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n            target_vendor = \"apple\",\n        )))]\n        'poll: {\n            use crate::sys::os::errno;\n            let pfds: &mut [_] = &mut [\n                libc::pollfd { fd: 0, events: 0, revents: 0 },\n                libc::pollfd { fd: 1, events: 0, revents: 0 },\n                libc::pollfd { fd: 2, events: 0, revents: 0 },\n            ];\n\n            while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n                match errno() {\n                    libc::EINTR => continue,\n                    #[cfg(target_vendor = \"unikraft\")]\n                    libc::ENOSYS => {\n                        // Not all configurations of Unikraft enable `LIBPOSIX_EVENT`.\n                        break 'poll;\n                    }\n                    libc::EINVAL | libc::EAGAIN | libc::ENOMEM => {\n                        // RLIMIT_NOFILE or temporary allocation failures\n                        // may be preventing use of poll(), fall back to fcntl\n                        break 'poll;\n                    }\n                    _ => libc::abort(),\n                }\n            }\n            for pfd in pfds {\n                if pfd.revents & libc::POLLNVAL == 0 {\n                    continue;\n                }\n                open_devnull();\n            }\n            return;\n        }\n\n        // fallback in case poll isn't available or limited by RLIMIT_NOFILE\n        #[cfg(not(any(\n            // The standard fds are always available in Miri.\n            miri,\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"vxworks\",\n            target_os = \"l4re\",\n            target_os = \"horizon\",\n            target_os = \"vita\",\n        )))]\n        {\n            use crate::sys::os::errno;\n            for fd in 0..3 {\n                if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n                    open_devnull();\n                }\n            }\n        }\n    }\n\n    unsafe fn reset_sigpipe(#[allow(unused_variables)] sigpipe: u8) {\n        #[cfg(not(any(\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"horizon\",\n            target_os = \"vxworks\",\n            target_os = \"vita\",\n            // Unikraft's `signal` implementation is currently broken:\n            // https://github.com/unikraft/lib-musl/issues/57\n            target_vendor = \"unikraft\",\n        )))]\n        {\n            // We don't want to add this as a public type to std, nor do we\n            // want to `include!` a file from the compiler (which would break\n            // Miri and xargo for example), so we choose to duplicate these\n            // constants from `compiler/rustc_session/src/config/sigpipe.rs`.\n            // See the other file for docs. NOTE: Make sure to keep them in\n            // sync!\n            mod sigpipe {\n                pub const DEFAULT: u8 = 0;\n                pub const INHERIT: u8 = 1;\n                pub const SIG_IGN: u8 = 2;\n                pub const SIG_DFL: u8 = 3;\n            }\n\n            let (sigpipe_attr_specified, handler) = match sigpipe {\n                sigpipe::DEFAULT => (false, Some(libc::SIG_IGN)),\n                sigpipe::INHERIT => (true, None),\n                sigpipe::SIG_IGN => (true, Some(libc::SIG_IGN)),\n                sigpipe::SIG_DFL => (true, Some(libc::SIG_DFL)),\n                _ => unreachable!(),\n            };\n            if sigpipe_attr_specified {\n                ON_BROKEN_PIPE_FLAG_USED.store(true, crate::sync::atomic::Ordering::Relaxed);\n            }\n            if let Some(handler) = handler {\n                rtassert!(signal(libc::SIGPIPE, handler) != libc::SIG_ERR);\n                #[cfg(target_os = \"hurd\")]\n                {\n                    rtassert!(signal(libc::SIGLOST, handler) != libc::SIG_ERR);\n                }\n            }\n        }\n    }\n}",
  "mir": "fn sys::pal::unix::init(_1: isize, _2: *const *const u8, _3: u8) -> () {\n    let mut _0: ();\n    let  _4: ();\n    let  _5: ();\n    let  _6: ();\n    let  _7: ();\n    debug argc => _1;\n    debug argv => _2;\n    debug sigpipe => _3;\n    bb0: {\n        _4 = sys::pal::unix::init::sanitize_standard_fds() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = sys::pal::unix::init::reset_sigpipe(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _6 = sys::pal::unix::stack_overflow::imp::init() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = sys::args::unix::init(_1, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}