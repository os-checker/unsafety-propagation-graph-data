{
  "name": "<io::buffered::bufreader::BufReader<R> as io::Seek>::stream_position",
  "safe": true,
  "callees": {
    "io::buffered::bufreader::buffer::Buffer::filled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "ImmutableAsArgument"
      }
    },
    "io::buffered::bufreader::buffer::Buffer::pos": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "ImmutableAsArgument"
      }
    },
    "io::Seek::stream_position": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current seek position from the start of the stream.\n\n This is equivalent to `self.seek(SeekFrom::Current(0))`.\n\n # Example\n\n ```no_run\n use std::{\n     io::{self, BufRead, BufReader, Seek},\n     fs::File,\n };\n\n fn main() -> io::Result<()> {\n     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n\n     let before = f.stream_position()?;\n     f.read_line(&mut String::new())?;\n     let after = f.stream_position()?;\n\n     println!(\"The first line was {} bytes long\", after - before);\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "io::buffered::bufreader::buffer::Buffer": [
      "Ref"
    ],
    "io::buffered::bufreader::BufReader": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::buffered::bufreader::BufReader<R> as io::Seek>::stream_position"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:553:5: 560:6",
  "src": "fn stream_position(&mut self) -> io::Result<u64> {\n        let remainder = (self.buf.filled() - self.buf.pos()) as u64;\n        self.inner.stream_position().map(|pos| {\n            pos.checked_sub(remainder).expect(\n                \"overflow when subtracting remaining buffer size from inner stream position\",\n            )\n        })\n    }",
  "mir": "fn <io::buffered::bufreader::BufReader<R> as io::Seek>::stream_position(_1: &mut io::buffered::bufreader::BufReader<R>) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let  _2: u64;\n    let mut _3: usize;\n    let mut _4: usize;\n    let mut _5: &io::buffered::bufreader::buffer::Buffer;\n    let mut _6: usize;\n    let mut _7: &io::buffered::bufreader::buffer::Buffer;\n    let mut _8: (usize, bool);\n    let mut _9: core::result::Result<u64, io::error::Error>;\n    let mut _10: &mut R;\n    let mut _11: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:555:42: 555:47};\n    let mut _12: &u64;\n    debug self => _1;\n    debug remainder => _2;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        _4 = io::buffered::bufreader::buffer::Buffer::filled(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        _6 = io::buffered::bufreader::buffer::Buffer::pos(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _8 = CheckedSub(_4, _6);\n        assert(!move (_8.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _4, move _6) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _3 = move (_8.0: usize);\n        StorageDead(_6);\n        StorageDead(_4);\n        _2 = move _3 as u64;\n        StorageDead(_3);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut ((*_1).1: R);\n        _9 = <R as io::Seek>::stream_position(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_2;\n        _11 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:555:42: 555:47}(move _12);\n        StorageDead(_12);\n        _0 = core::result::Result::<u64, io::error::Error>::map::<u64, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:555:42: 555:47}>(move _9, move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        StorageDead(_9);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns the current seek position from the start of the stream.\n\n The value returned is equivalent to `self.seek(SeekFrom::Current(0))`\n but does not flush the internal buffer. Due to this optimization the\n function does not guarantee that calling `.into_inner()` immediately\n afterwards will yield the underlying reader at the same position. Use\n [`BufReader::seek`] instead if you require that guarantee.\n\n # Panics\n\n This function will panic if the position of the inner reader is smaller\n than the amount of buffered data. That can happen if the inner reader\n has an incorrect implementation of [`Seek::stream_position`], or if the\n position has gone out of sync due to calling [`Seek::seek`] directly on\n the underlying reader.\n\n # Example\n\n ```no_run\n use std::{\n     io::{self, BufRead, BufReader, Seek},\n     fs::File,\n };\n\n fn main() -> io::Result<()> {\n     let mut f = BufReader::new(File::open(\"foo.txt\")?);\n\n     let before = f.stream_position()?;\n     f.read_line(&mut String::new())?;\n     let after = f.stream_position()?;\n\n     println!(\"The first line was {} bytes long\", after - before);\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}