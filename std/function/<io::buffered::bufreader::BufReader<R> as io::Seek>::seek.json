{
  "name": "<io::buffered::bufreader::BufReader<R> as io::Seek>::seek",
  "safe": true,
  "callees": {
    "io::buffered::bufreader::buffer::Buffer::filled": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "ImmutableAsArgument"
      }
    },
    "io::buffered::bufreader::buffer::Buffer::pos": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufreader::buffer::Buffer": "ImmutableAsArgument"
      }
    },
    "core::num::<impl i64>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning `None` if\n overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "io::Seek::seek": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Seek to an offset, in bytes, in a stream.\n\n A seek beyond the end of a stream is allowed, but behavior is defined\n by the implementation.\n\n If the seek operation completed successfully,\n this method returns the new position from the start of the stream.\n That position can be used later with [`SeekFrom::Start`].\n\n # Errors\n\n Seeking can fail, for example because it might involve flushing a buffer.\n\n Seeking to a negative offset is considered an error.\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::buffered::bufreader::BufReader::<R>::discard_buffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invalidates all data in the internal buffer.\n",
      "adt": {
        "io::buffered::bufreader::BufReader": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "io::SeekFrom": [
      "Plain",
      "Unknown([Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 4522, kind: RigidTy(Int(I64)) })])"
    ],
    "io::buffered::bufreader::buffer::Buffer": [
      "Ref"
    ],
    "io::buffered::bufreader::BufReader": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4522, kind: RigidTy(Int(I64)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::buffered::bufreader::BufReader<R> as io::Seek>::seek"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:493:5: 516:6",
  "src": "fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n        let result: u64;\n        if let SeekFrom::Current(n) = pos {\n            let remainder = (self.buf.filled() - self.buf.pos()) as i64;\n            // it should be safe to assume that remainder fits within an i64 as the alternative\n            // means we managed to allocate 8 exbibytes and that's absurd.\n            // But it's not out of the realm of possibility for some weird underlying reader to\n            // support seeking by i64::MIN so we need to handle underflow when subtracting\n            // remainder.\n            if let Some(offset) = n.checked_sub(remainder) {\n                result = self.inner.seek(SeekFrom::Current(offset))?;\n            } else {\n                // seek backwards by our remainder, and then by the offset\n                self.inner.seek(SeekFrom::Current(-remainder))?;\n                self.discard_buffer();\n                result = self.inner.seek(SeekFrom::Current(n))?;\n            }\n        } else {\n            // Seeking with Start/End doesn't care about our buffer length.\n            result = self.inner.seek(pos)?;\n        }\n        self.discard_buffer();\n        Ok(result)\n    }",
  "mir": "fn <io::buffered::bufreader::BufReader<R> as io::Seek>::seek(_1: &mut io::buffered::bufreader::BufReader<R>, _2: io::SeekFrom) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let  _3: u64;\n    let mut _4: isize;\n    let  _5: i64;\n    let  _6: i64;\n    let mut _7: usize;\n    let mut _8: usize;\n    let mut _9: &io::buffered::bufreader::buffer::Buffer;\n    let mut _10: usize;\n    let mut _11: &io::buffered::bufreader::buffer::Buffer;\n    let mut _12: (usize, bool);\n    let mut _13: core::option::Option<i64>;\n    let mut _14: isize;\n    let  _15: i64;\n    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _17: core::result::Result<u64, io::error::Error>;\n    let mut _18: &mut R;\n    let mut _19: io::SeekFrom;\n    let mut _20: isize;\n    let  _21: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _22: u64;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _24: core::result::Result<u64, io::error::Error>;\n    let mut _25: &mut R;\n    let mut _26: io::SeekFrom;\n    let mut _27: i64;\n    let mut _28: bool;\n    let mut _29: isize;\n    let  _30: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _31: u64;\n    let  _32: ();\n    let mut _33: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _34: core::result::Result<u64, io::error::Error>;\n    let mut _35: &mut R;\n    let mut _36: io::SeekFrom;\n    let mut _37: isize;\n    let  _38: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _39: u64;\n    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _41: core::result::Result<u64, io::error::Error>;\n    let mut _42: &mut R;\n    let mut _43: isize;\n    let  _44: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _45: u64;\n    let  _46: ();\n    let mut _47: u64;\n    debug self => _1;\n    debug pos => _2;\n    debug result => _3;\n    debug n => _5;\n    debug remainder => _6;\n    debug offset => _15;\n    debug residual => _21;\n    debug val => _22;\n    debug residual => _30;\n    debug val => _31;\n    debug residual => _38;\n    debug val => _39;\n    debug residual => _44;\n    debug val => _45;\n    bb0: {\n        StorageLive(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [2: bb1, otherwise: bb27];\n    }\n    bb1: {\n        _5 = ((_2 as variant#2).0: i64);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        _8 = io::buffered::bufreader::buffer::Buffer::filled(move _9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &((*_1).0: io::buffered::bufreader::buffer::Buffer);\n        _10 = io::buffered::bufreader::buffer::Buffer::pos(move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _12 = CheckedSub(_8, _10);\n        assert(!move (_12.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _8, move _10) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = move (_12.0: usize);\n        StorageDead(_10);\n        StorageDead(_8);\n        _6 = move _7 as i64;\n        StorageDead(_7);\n        StorageLive(_13);\n        _13 = core::num::<impl i64>::checked_sub(_5, _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _14 = discriminant(_13);\n        switchInt(move _14) -> [1: bb6, 0: bb13, otherwise: bb9];\n    }\n    bb6: {\n        _15 = ((_13 as variant#1).0: i64);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &mut ((*_1).1: R);\n        StorageLive(_19);\n        _19 = io::SeekFrom::Current(_15);\n        _17 = <R as io::Seek>::seek(move _18, move _19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_19);\n        StorageDead(_18);\n        _16 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _17) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_17);\n        _20 = discriminant(_16);\n        switchInt(move _20) -> [0: bb10, 1: bb11, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        _22 = ((_16 as variant#0).0: u64);\n        _3 = _22;\n        StorageDead(_16);\n        StorageDead(_13);\n        goto -> bb26;\n    }\n    bb11: {\n        _21 = move ((_16 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_21) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        StorageDead(_13);\n        goto -> bb35;\n    }\n    bb13: {\n        StorageDead(_13);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &mut ((*_1).1: R);\n        StorageLive(_26);\n        StorageLive(_27);\n        _28 = Eq(_6, i64::MIN);\n        assert(!move _28, \"attempt to negate `{}`, which would overflow\", _6) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _27 = Neg(_6);\n        _26 = io::SeekFrom::Current(move _27);\n        StorageDead(_27);\n        _24 = <R as io::Seek>::seek(move _25, move _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_26);\n        StorageDead(_25);\n        _23 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_24);\n        _29 = discriminant(_23);\n        switchInt(move _29) -> [0: bb17, 1: bb18, otherwise: bb9];\n    }\n    bb17: {\n        StorageLive(_31);\n        _31 = ((_23 as variant#0).0: u64);\n        StorageDead(_31);\n        StorageDead(_23);\n        _32 = io::buffered::bufreader::BufReader::<R>::discard_buffer(_1) -> [return: bb20, unwind unreachable];\n    }\n    bb18: {\n        _30 = move ((_23 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_30) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_23);\n        goto -> bb35;\n    }\n    bb20: {\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &mut ((*_1).1: R);\n        StorageLive(_36);\n        _36 = io::SeekFrom::Current(_5);\n        _34 = <R as io::Seek>::seek(move _35, move _36) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_36);\n        StorageDead(_35);\n        _33 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _34) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_34);\n        _37 = discriminant(_33);\n        switchInt(move _37) -> [0: bb23, 1: bb24, otherwise: bb9];\n    }\n    bb23: {\n        _39 = ((_33 as variant#0).0: u64);\n        _3 = _39;\n        StorageDead(_33);\n        goto -> bb26;\n    }\n    bb24: {\n        _38 = move ((_33 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_38) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_33);\n        goto -> bb35;\n    }\n    bb26: {\n        goto -> bb33;\n    }\n    bb27: {\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &mut ((*_1).1: R);\n        _41 = <R as io::Seek>::seek(move _42, _2) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_42);\n        _40 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _41) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_41);\n        _43 = discriminant(_40);\n        switchInt(move _43) -> [0: bb30, 1: bb31, otherwise: bb9];\n    }\n    bb30: {\n        _45 = ((_40 as variant#0).0: u64);\n        _3 = _45;\n        StorageDead(_40);\n        goto -> bb33;\n    }\n    bb31: {\n        _44 = move ((_40 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_44) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_40);\n        goto -> bb36;\n    }\n    bb33: {\n        _46 = io::buffered::bufreader::BufReader::<R>::discard_buffer(_1) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageLive(_47);\n        _47 = _3;\n        _0 = core::result::Result::Ok(move _47);\n        StorageDead(_47);\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb35: {\n        goto -> bb36;\n    }\n    bb36: {\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb37: {\n        return;\n    }\n}\n",
  "doc": " Seek to an offset, in bytes, in the underlying reader.\n\n The position used for seeking with <code>[SeekFrom::Current]\\(_)</code> is the\n position the underlying reader would be at if the `BufReader<R>` had no\n internal buffer.\n\n Seeking always discards the internal buffer, even if the seek position\n would otherwise fall within it. This guarantees that calling\n [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n at the same position.\n\n To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n\n See [`std::io::Seek`] for more details.\n\n Note: In the edge case where you're seeking with <code>[SeekFrom::Current]\\(n)</code>\n where `n` minus the internal buffer length overflows an `i64`, two\n seeks will be performed instead of one. If the second seek returns\n [`Err`], the underlying reader will be left at the same position it would\n have if you called `seek` with <code>[SeekFrom::Current]\\(0)</code>.\n\n [`std::io::Seek`]: Seek\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}