{
  "name": "backtrace_rs::symbolize::gimli::elf::Object::<'a>::search_symtab",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::binary_search_by_key": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Binary searches this slice with a key extraction function.\n\n Assumes that the slice is sorted by the key, for instance with\n [`sort_by_key`] using the same key extraction function.\n If the slice is not sorted by the key, the returned result is\n unspecified and meaningless.\n\n If the value is found then [`Result::Ok`] is returned, containing the\n index of the matching element. If there are multiple matches, then any\n one of the matches could be returned. The index is chosen\n deterministically, but is subject to change in future versions of Rust.\n If the value is not found then [`Result::Err`] is returned, containing\n the index where a matching element could be inserted while maintaining\n sorted order.\n\n See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n\n [`sort_by_key`]: slice::sort_by_key\n [`binary_search`]: slice::binary_search\n [`binary_search_by`]: slice::binary_search_by\n [`partition_point`]: slice::partition_point\n\n # Examples\n\n Looks up a series of four elements in a slice of pairs sorted by\n their second elements. The first is found, with a uniquely\n determined position; the second and third are not found; the\n fourth could match any position in `[1, 4]`.\n\n ```\n let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n          (1, 21), (2, 34), (4, 55)];\n\n assert_eq!(s.binary_search_by_key(&13, |&(a, b)| b),  Ok(9));\n assert_eq!(s.binary_search_by_key(&4, |&(a, b)| b),   Err(7));\n assert_eq!(s.binary_search_by_key(&100, |&(a, b)| b), Err(13));\n let r = s.binary_search_by_key(&1, |&(a, b)| b);\n assert!(match r { Ok(1..=4) => true, _ => false, });\n ```\n",
      "adt": {}
    },
    "core::num::<impl usize>::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked integer subtraction. Computes `self - rhs`, returning\n `None` if overflow occurred.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to an element or subslice depending on the type of\n index.\n\n - If given a position, returns a reference to the element at that\n   position or `None` if out of bounds.\n - If given a range, returns the subslice corresponding to that range,\n   or `None` if out of bounds.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&40), v.get(1));\n assert_eq!(Some(&[10, 40][..]), v.get(0..2));\n assert_eq!(None, v.get(3));\n assert_eq!(None, v.get(0..4));\n ```\n",
      "adt": {}
    },
    "object::StringTable::<'data, R>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the string at the given offset.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Ref"
    ],
    "backtrace_rs::symbolize::gimli::elf::Object": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(4)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18325, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 18190, kind: RigidTy(Adt(AdtDef(DefId { id: 12834, name: \"backtrace_rs::symbolize::gimli::elf::ParsedSym\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "backtrace_rs::symbolize::gimli::elf::ParsedSym": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "object::StringTable": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::elf::Object::<'a>::search_symtab"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:283:5: 295:6",
  "src": "pub fn search_symtab(&self, addr: u64) -> Option<&[u8]> {\n        // Same sort of binary search as Windows above\n        let i = match self.syms.binary_search_by_key(&addr, |sym| sym.address) {\n            Ok(i) => i,\n            Err(i) => i.checked_sub(1)?,\n        };\n        let sym = self.syms.get(i)?;\n        if sym.address <= addr && addr <= sym.address + sym.size {\n            self.strings.get(sym.name).ok()\n        } else {\n            None\n        }\n    }",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::Object::<'a>::search_symtab(_1: &backtrace_rs::symbolize::gimli::elf::Object<'_>, _2: u64) -> core::option::Option<&[u8]> {\n    let mut _0: core::option::Option<&[u8]>;\n    let  _3: usize;\n    let mut _4: core::result::Result<usize, usize>;\n    let  _5: &[backtrace_rs::symbolize::gimli::elf::ParsedSym];\n    let mut _6: &alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    let  _7: &u64;\n    let mut _8: isize;\n    let  _9: usize;\n    let  _10: usize;\n    let mut _11: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;\n    let mut _12: core::option::Option<usize>;\n    let mut _13: isize;\n    let  _14: usize;\n    let mut _15: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    let mut _16: core::option::Option<&backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    let  _17: &[backtrace_rs::symbolize::gimli::elf::ParsedSym];\n    let mut _18: &alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    let mut _19: usize;\n    let mut _20: isize;\n    let  _21: &backtrace_rs::symbolize::gimli::elf::ParsedSym;\n    let mut _22: bool;\n    let mut _23: u64;\n    let mut _24: bool;\n    let mut _25: u64;\n    let mut _26: u64;\n    let mut _27: u64;\n    let mut _28: (u64, bool);\n    let mut _29: core::result::Result<&[u8], ()>;\n    let mut _30: &object::StringTable<'_>;\n    let mut _31: u32;\n    debug self => _1;\n    debug addr => _2;\n    debug i => _3;\n    debug i => _9;\n    debug i => _10;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _14;\n    debug sym => _21;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _21;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_6);\n        _6 = &((*_1).4: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>);\n        _5 = <alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym> as core::ops::Deref>::deref(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _7 = &_2;\n        _4 = core::slice::<impl [backtrace_rs::symbolize::gimli::elf::ParsedSym]>::binary_search_by_key::<'_, u64, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:285:61: 285:66}>(_5, _7, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:285:61: 285:66}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _8 = discriminant(_4);\n        switchInt(move _8) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _10 = ((_4 as variant#1).0: usize);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = core::num::<impl usize>::checked_sub(_10, 1_usize) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_9);\n        _9 = ((_4 as variant#0).0: usize);\n        _3 = _9;\n        StorageDead(_9);\n        goto -> bb11;\n    }\n    bb6: {\n        _11 = <core::option::Option<usize> as core::ops::Try>::branch(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb8, 1: bb9, otherwise: bb3];\n    }\n    bb8: {\n        StorageLive(_14);\n        _14 = ((_11 as variant#0).0: usize);\n        _3 = _14;\n        StorageDead(_14);\n        StorageDead(_11);\n        goto -> bb11;\n    }\n    bb9: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageDead(_4);\n        goto -> bb27;\n    }\n    bb11: {\n        StorageDead(_4);\n        StorageLive(_15);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = &((*_1).4: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>);\n        _17 = <alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym> as core::ops::Deref>::deref(move _18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = _3;\n        _16 = core::slice::<impl [backtrace_rs::symbolize::gimli::elf::ParsedSym]>::get::<usize>(_17, move _19) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        _15 = <core::option::Option<&backtrace_rs::symbolize::gimli::elf::ParsedSym> as core::ops::Try>::branch(move _16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_16);\n        _20 = discriminant(_15);\n        switchInt(move _20) -> [0: bb15, 1: bb16, otherwise: bb3];\n    }\n    bb15: {\n        _21 = ((_15 as variant#0).0: &backtrace_rs::symbolize::gimli::elf::ParsedSym);\n        StorageDead(_15);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = ((*_21).0: u64);\n        _22 = Le(move _23, _2);\n        switchInt(move _22) -> [0: bb19, otherwise: bb18];\n    }\n    bb16: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_15);\n        goto -> bb27;\n    }\n    bb18: {\n        StorageDead(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = ((*_21).0: u64);\n        StorageLive(_27);\n        _27 = ((*_21).1: u64);\n        _28 = CheckedAdd(_26, _27);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _26, move _27) -> [success: bb20, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_23);\n        goto -> bb25;\n    }\n    bb20: {\n        _25 = move (_28.0: u64);\n        StorageDead(_27);\n        StorageDead(_26);\n        _24 = Le(_2, move _25);\n        switchInt(move _24) -> [0: bb24, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_25);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &((*_1).3: object::StringTable<'_>);\n        StorageLive(_31);\n        _31 = ((*_21).2: u32);\n        _29 = object::StringTable::<'_>::get(move _30, move _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_31);\n        StorageDead(_30);\n        _0 = core::result::Result::<&[u8], ()>::ok(move _29) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_29);\n        goto -> bb26;\n    }\n    bb24: {\n        StorageDead(_25);\n        goto -> bb25;\n    }\n    bb25: {\n        _0 = core::option::Option::None;\n        goto -> bb26;\n    }\n    bb26: {\n        StorageDead(_24);\n        StorageDead(_22);\n        StorageDead(_3);\n        goto -> bb28;\n    }\n    bb27: {\n        StorageDead(_3);\n        goto -> bb28;\n    }\n    bb28: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}