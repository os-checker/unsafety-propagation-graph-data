{
  "name": "<backtrace::Backtrace as core::fmt::Display>::fmt",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data to the underlying buffer contained within this\n formatter.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_str(\"Foo\")\n         // This is equivalent to:\n         // write!(formatter, \"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo}\"), \"Foo\");\n assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n ```\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::alternate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Determines if the `#` flag was specified.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if formatter.alternate() {\n             write!(formatter, \"Foo({})\", self.0)\n         } else {\n             write!(formatter, \"{}\", self.0)\n         }\n     }\n }\n\n assert_eq!(format!(\"{:#}\", Foo(23)), \"Foo(23)\");\n assert_eq!(format!(\"{}\", Foo(23)), \"23\");\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "env::current_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current working directory as a [`PathBuf`].\n\n # Platform-specific behavior\n\n This function [currently] corresponds to the `getcwd` function on Unix\n and the `GetCurrentDirectoryW` function on Windows.\n\n [currently]: crate::io#platform-specific-behavior\n\n # Errors\n\n Returns an [`Err`] if the current working directory value is invalid.\n Possible cases:\n\n * Current directory does not exist.\n * There are insufficient permissions to access the current directory.\n\n # Examples\n\n ```\n use std::env;\n\n fn main() -> std::io::Result<()> {\n     let path = env::current_dir()?;\n     println!(\"The current directory is {}\", path.display());\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a new `BacktraceFmt` which will write output to the provided\n `fmt`.\n\n The `format` argument will control the style in which the backtrace is\n printed, and the `print_path` argument will be used to print the\n `BytesOrWideString` instances of filenames. This type itself doesn't do\n any printing of filenames, but this callback is required to do so.\n",
      "adt": {
        "core::fmt::Formatter": "MutableAsArgument",
        "backtrace_rs::print::BacktraceFmt": "Constructor"
      }
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::add_context": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Prints a preamble for the backtrace about to be printed.\n\n This is required on some platforms for backtraces to be fully\n symbolicated later, and otherwise this should just be the first method\n you call after creating a `BacktraceFmt`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "backtrace_rs::print::BacktraceFmt": "MutableAsArgument"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {}
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::finish": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Completes the backtrace output.\n\n This is currently a no-op but is added for future compatibility with\n backtrace formats.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "backtrace_rs::print::BacktraceFmt": "MutableAsArgument"
      }
    },
    "backtrace_rs::print::BacktraceFmt::<'a, 'b>::frame": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a frame to the backtrace output.\n\n This commit returns an RAII instance of a `BacktraceFrameFmt` which can be used\n to actually print a frame, and on destruction it will increment the\n frame counter.\n",
      "adt": {
        "backtrace_rs::print::BacktraceFmt": "MutableAsArgument",
        "backtrace_rs::print::BacktraceFrameFmt": "Constructor"
      }
    },
    "backtrace::RawFrame::ip": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "backtrace::RawFrame": "ImmutableAsArgument"
      }
    },
    "backtrace_rs::print::BacktraceFrameFmt::<'_, '_, '_>::print_raw": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a raw frame to the backtrace output.\n\n This method, unlike the previous, takes the raw arguments in case\n they're being source from different locations. Note that this may be\n called multiple times for one frame.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "backtrace_rs::print::BacktraceFrameFmt": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&Option<T>` to `Option<&T>`.\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n reference to the value inside the original.\n\n [`map`]: Option::map\n [String]: ../../std/string/struct.String.html \"String\"\n [`String`]: ../../std/string/struct.String.html \"String\"\n\n ```\n let text: Option<String> = Some(\"Hello, world!\".to_string());\n // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n // then consume *that* with `map`, leaving `text` on the stack.\n let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n println!(\"still can print text: {text:?}\");\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "backtrace_rs::print::BacktraceFrameFmt::<'_, '_, '_>::print_raw_with_column": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a raw frame to the backtrace output, including column information.\n\n This method, like the previous, takes the raw arguments in case\n they're being source from different locations. Note that this may be\n called multiple times for one frame.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "backtrace_rs::print::BacktraceFrameFmt": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "backtrace::Inner": [
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 1098, kind: RigidTy(Adt(AdtDef(DefId { id: 4833, name: \"sync::lazy_lock::LazyLock\" }), GenericArgs([Type(Ty { id: 1132, kind: RigidTy(Adt(AdtDef(DefId { id: 4849, name: \"backtrace::Capture\" }), GenericArgs([]))) }), Type(Ty { id: 1133, kind: RigidTy(Closure(ClosureDef(DefId { id: 4873, name: \"backtrace::helper::lazy_resolve::{closure#0}\" }), GenericArgs([Type(Ty { id: 44, kind: RigidTy(Int(I32)) }), Type(Ty { id: 1163, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 1, kind: RigidTy(Tuple([])) }, Ty { id: 1132, kind: RigidTy(Adt(AdtDef(DefId { id: 4849, name: \"backtrace::Capture\" }), GenericArgs([]))) }], c_variadic: false, safety: Safe, abi: RustCall }, bound_vars: [] })) }), Type(Ty { id: 1164, kind: RigidTy(Tuple([Ty { id: 1132, kind: RigidTy(Adt(AdtDef(DefId { id: 4849, name: \"backtrace::Capture\" }), GenericArgs([]))) }])) })]))) })]))) })])"
    ],
    "backtrace::Backtrace": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::lazy_lock::LazyLock": [
      "Ref"
    ],
    "backtrace::Capture": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::fmt::Formatter": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "alloc_crate::vec::Vec": [
      "Ref"
    ],
    "backtrace_rs::print::PrintFmt": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1120, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1138, kind: RigidTy(Slice(Ty { id: 1134, kind: RigidTy(Adt(AdtDef(DefId { id: 4857, name: \"backtrace::BacktraceFrame\" }), GenericArgs([]))) })) }, Not)) })])",
      "Unknown([Field(1, Ty { id: 1220, kind: RigidTy(Adt(AdtDef(DefId { id: 4897, name: \"backtrace_rs::print::PrintFmt\" }), GenericArgs([]))) })])"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "backtrace_rs::print::BacktraceFmt": [
      "Plain",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1110, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1134, kind: RigidTy(Adt(AdtDef(DefId { id: 4857, name: \"backtrace::BacktraceFrame\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 1137, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 1136, kind: RigidTy(Adt(AdtDef(DefId { id: 4881, name: \"backtrace::BacktraceSymbol\" }), GenericArgs([]))) }, Not)) })])",
      "Ref"
    ],
    "backtrace::BacktraceFrame": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "backtrace_rs::print::BacktraceFrameFmt": [
      "Plain",
      "MutRef"
    ],
    "backtrace::RawFrame": [
      "Ref"
    ],
    "backtrace::BacktraceSymbol": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(3)))"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<backtrace::Backtrace as core::fmt::Display>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:383:5: 428:6",
  "src": "fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let capture = match &self.inner {\n            Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n            Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n            Inner::Captured(c) => &**c,\n        };\n\n        let full = fmt.alternate();\n        let (frames, style) = if full {\n            (&capture.frames[..], backtrace_rs::PrintFmt::Full)\n        } else {\n            (&capture.frames[capture.actual_start..], backtrace_rs::PrintFmt::Short)\n        };\n\n        // When printing paths we try to strip the cwd if it exists, otherwise\n        // we just print the path as-is. Note that we also only do this for the\n        // short format, because if it's full we presumably want to print\n        // everything.\n        let cwd = crate::env::current_dir();\n        let mut print_path = move |fmt: &mut fmt::Formatter<'_>, path: BytesOrWideString<'_>| {\n            output_filename(fmt, path, style, cwd.as_ref().ok())\n        };\n\n        let mut f = backtrace_rs::BacktraceFmt::new(fmt, style, &mut print_path);\n        f.add_context()?;\n        for frame in frames {\n            if frame.symbols.is_empty() {\n                f.frame().print_raw(frame.frame.ip(), None, None, None)?;\n            } else {\n                for symbol in frame.symbols.iter() {\n                    f.frame().print_raw_with_column(\n                        frame.frame.ip(),\n                        symbol.name.as_ref().map(|b| backtrace_rs::SymbolName::new(b)),\n                        symbol.filename.as_ref().map(|b| match b {\n                            BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n                            BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n                        }),\n                        symbol.lineno,\n                        symbol.colno,\n                    )?;\n                }\n            }\n        }\n        f.finish()?;\n        Ok(())\n    }",
  "mir": "fn <backtrace::Backtrace as core::fmt::Display>::fmt(_1: &backtrace::Backtrace, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: &backtrace::Inner;\n    let mut _4: isize;\n    let mut _5: &str;\n    let mut _6: &str;\n    let  _7: &sync::lazy_lock::LazyLock<backtrace::Capture, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:437:9: 437:16}>;\n    let  _8: &backtrace::Capture;\n    let  _9: bool;\n    let mut _10: &core::fmt::Formatter<'_>;\n    let  _11: &[backtrace::BacktraceFrame];\n    let  _12: backtrace_rs::print::PrintFmt;\n    let mut _13: (&[backtrace::BacktraceFrame], backtrace_rs::print::PrintFmt);\n    let  _14: &[backtrace::BacktraceFrame];\n    let mut _15: &alloc_crate::vec::Vec<backtrace::BacktraceFrame>;\n    let mut _16: backtrace_rs::print::PrintFmt;\n    let  _17: &[backtrace::BacktraceFrame];\n    let mut _18: &alloc_crate::vec::Vec<backtrace::BacktraceFrame>;\n    let mut _19: core::ops::RangeFrom<usize>;\n    let mut _20: usize;\n    let mut _21: backtrace_rs::print::PrintFmt;\n    let  _22: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _23: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:402:30: 402:94};\n    let mut _24: backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _25: &mut dyn for<'a, 'b, 'c> core::ops::FnMut(&'a mut core::fmt::Formatter<'b>, backtrace_rs::types::BytesOrWideString<'c>) -> core::result::Result<(), core::fmt::Error>;\n    let mut _26: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:402:30: 402:94};\n    let mut _27: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _28: core::result::Result<(), core::fmt::Error>;\n    let mut _29: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _30: isize;\n    let mut _31: core::slice::Iter<'_, backtrace::BacktraceFrame>;\n    let mut _32: core::slice::Iter<'_, backtrace::BacktraceFrame>;\n    let mut _33: core::option::Option<&backtrace::BacktraceFrame>;\n    let mut _34: &mut core::slice::Iter<'_, backtrace::BacktraceFrame>;\n    let mut _35: isize;\n    let  _36: &backtrace::BacktraceFrame;\n    let mut _37: bool;\n    let mut _38: &alloc_crate::vec::Vec<backtrace::BacktraceSymbol>;\n    let mut _39: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _40: core::result::Result<(), core::fmt::Error>;\n    let mut _41: &mut backtrace_rs::print::BacktraceFrameFmt<'_, '_, '_>;\n    let mut _42: backtrace_rs::print::BacktraceFrameFmt<'_, '_, '_>;\n    let mut _43: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _44: *mut libc::c_void;\n    let mut _45: &backtrace::RawFrame;\n    let mut _46: core::option::Option<backtrace_rs::symbolize::SymbolName<'_>>;\n    let mut _47: core::option::Option<backtrace_rs::types::BytesOrWideString<'_>>;\n    let mut _48: core::option::Option<u32>;\n    let mut _49: isize;\n    let mut _50: core::slice::Iter<'_, backtrace::BacktraceSymbol>;\n    let mut _51: core::slice::Iter<'_, backtrace::BacktraceSymbol>;\n    let  _52: &[backtrace::BacktraceSymbol];\n    let mut _53: &alloc_crate::vec::Vec<backtrace::BacktraceSymbol>;\n    let mut _54: core::slice::Iter<'_, backtrace::BacktraceSymbol>;\n    let mut _55: core::option::Option<&backtrace::BacktraceSymbol>;\n    let mut _56: &mut core::slice::Iter<'_, backtrace::BacktraceSymbol>;\n    let mut _57: isize;\n    let  _58: &backtrace::BacktraceSymbol;\n    let mut _59: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _60: core::result::Result<(), core::fmt::Error>;\n    let mut _61: &mut backtrace_rs::print::BacktraceFrameFmt<'_, '_, '_>;\n    let mut _62: backtrace_rs::print::BacktraceFrameFmt<'_, '_, '_>;\n    let mut _63: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _64: *mut libc::c_void;\n    let mut _65: &backtrace::RawFrame;\n    let mut _66: core::option::Option<backtrace_rs::symbolize::SymbolName<'_>>;\n    let mut _67: core::option::Option<&alloc_crate::vec::Vec<u8>>;\n    let mut _68: &core::option::Option<alloc_crate::vec::Vec<u8>>;\n    let mut _69: core::option::Option<backtrace_rs::types::BytesOrWideString<'_>>;\n    let mut _70: core::option::Option<&backtrace::BytesOrWide>;\n    let mut _71: &core::option::Option<backtrace::BytesOrWide>;\n    let mut _72: core::option::Option<u32>;\n    let mut _73: core::option::Option<u32>;\n    let mut _74: isize;\n    let mut _75: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _76: core::result::Result<(), core::fmt::Error>;\n    let mut _77: &mut backtrace_rs::print::BacktraceFmt<'_, '_>;\n    let mut _78: isize;\n    debug self => _1;\n    debug fmt => _2;\n    debug capture => _8;\n    debug c => _7;\n    debug full => _9;\n    debug frames => _11;\n    debug style => _12;\n    debug cwd => _22;\n    debug print_path => _23;\n    debug f => _24;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug iter => _32;\n    debug frame => _36;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug iter => _54;\n    debug symbol => _58;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: backtrace::Inner);\n        _4 = discriminant((*_3));\n        switchInt(move _4) -> [0: bb4, 1: bb3, 2: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _7 = &(((*_3) as variant#2).0: sync::lazy_lock::LazyLock<backtrace::Capture, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:437:9: 437:16}>);\n        _8 = <sync::lazy_lock::LazyLock<backtrace::Capture, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:437:9: 437:16}> as core::ops::Deref>::deref(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_6);\n        _6 = \"disabled backtrace\";\n        _0 = core::fmt::Formatter::<'_>::write_str(_2, move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_5);\n        _5 = \"unsupported backtrace\";\n        _0 = core::fmt::Formatter::<'_>::write_str(_2, move _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        goto -> bb68;\n    }\n    bb6: {\n        StorageDead(_6);\n        goto -> bb68;\n    }\n    bb7: {\n        StorageDead(_3);\n        StorageLive(_10);\n        _10 = &(*_2);\n        _9 = core::fmt::Formatter::<'_>::alternate(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_13);\n        switchInt(_9) -> [0: bb11, otherwise: bb9];\n    }\n    bb9: {\n        StorageLive(_15);\n        _15 = &((*_8).1: alloc_crate::vec::Vec<backtrace::BacktraceFrame>);\n        _14 = <alloc_crate::vec::Vec<backtrace::BacktraceFrame> as core::ops::Index<core::ops::RangeFull>>::index(move _15, core::ops::RangeFull) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageLive(_16);\n        _16 = backtrace_rs::print::PrintFmt::Full;\n        _13 = (_14, move _16);\n        StorageDead(_16);\n        goto -> bb13;\n    }\n    bb11: {\n        StorageLive(_18);\n        _18 = &((*_8).1: alloc_crate::vec::Vec<backtrace::BacktraceFrame>);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = ((*_8).0: usize);\n        _19 = RangeFrom(move _20);\n        StorageDead(_20);\n        _17 = <alloc_crate::vec::Vec<backtrace::BacktraceFrame> as core::ops::Index<core::ops::RangeFrom<usize>>>::index(move _18, move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_21);\n        _21 = backtrace_rs::print::PrintFmt::Short;\n        _13 = (_17, move _21);\n        StorageDead(_21);\n        goto -> bb13;\n    }\n    bb13: {\n        _11 = (_13.0: &[backtrace::BacktraceFrame]);\n        _12 = (_13.1: backtrace_rs::print::PrintFmt);\n        StorageDead(_13);\n        StorageLive(_22);\n        _22 = env::current_dir() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageLive(_23);\n        _23 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:402:30: 402:94}(_12, move _22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _26 = &mut _23;\n        _25 = _26 as &mut dyn for<'a, 'b, 'c> core::ops::FnMut(&'a mut core::fmt::Formatter<'b>, backtrace_rs::types::BytesOrWideString<'c>) -> core::result::Result<(), core::fmt::Error>;\n        _24 = backtrace_rs::print::BacktraceFmt::<'_, '_>::new(_2, _12, move _25) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_25);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = &mut _24;\n        _28 = backtrace_rs::print::BacktraceFmt::<'_, '_>::add_context(move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        _27 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_28);\n        _30 = discriminant(_27);\n        switchInt(move _30) -> [0: bb18, 1: bb19, otherwise: bb1];\n    }\n    bb18: {\n        StorageDead(_27);\n        StorageLive(_31);\n        _31 = <&[backtrace::BacktraceFrame] as core::iter::IntoIterator>::into_iter(_11) -> [return: bb21, unwind unreachable];\n    }\n    bb19: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_27);\n        goto -> bb66;\n    }\n    bb21: {\n        StorageLive(_32);\n        _32 = move _31;\n        goto -> bb22;\n    }\n    bb22: {\n        StorageLive(_33);\n        _34 = &mut _32;\n        _33 = <core::slice::Iter<'_, backtrace::BacktraceFrame> as core::iter::Iterator>::next(_34) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _35 = discriminant(_33);\n        switchInt(move _35) -> [0: bb25, 1: bb24, otherwise: bb1];\n    }\n    bb24: {\n        StorageLive(_36);\n        _36 = ((_33 as variant#1).0: &backtrace::BacktraceFrame);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &((*_36).1: alloc_crate::vec::Vec<backtrace::BacktraceSymbol>);\n        _37 = alloc_crate::vec::Vec::<backtrace::BacktraceSymbol>::is_empty(move _38) -> [return: bb26, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        StorageLive(_75);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = &mut _24;\n        _76 = backtrace_rs::print::BacktraceFmt::<'_, '_>::finish(move _77) -> [return: bb57, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _37) -> [0: bb36, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = &mut _24;\n        _42 = backtrace_rs::print::BacktraceFmt::<'_, '_>::frame(move _43) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        _41 = &mut _42;\n        StorageDead(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &((*_36).0: backtrace::RawFrame);\n        _44 = backtrace::RawFrame::ip(move _45) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_45);\n        StorageLive(_46);\n        _46 = core::option::Option::None;\n        StorageLive(_47);\n        _47 = core::option::Option::None;\n        StorageLive(_48);\n        _48 = core::option::Option::None;\n        _40 = backtrace_rs::print::BacktraceFrameFmt::<'_, '_, '_>::print_raw(move _41, move _44, move _46, move _47, move _48) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageDead(_44);\n        StorageDead(_41);\n        _39 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _40) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_40);\n        _49 = discriminant(_39);\n        switchInt(move _49) -> [0: bb32, 1: bb33, otherwise: bb1];\n    }\n    bb32: {\n        drop(_42) -> [return: bb35, unwind unreachable];\n    }\n    bb33: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        drop(_42) -> [return: bb64, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_42);\n        StorageDead(_39);\n        goto -> bb56;\n    }\n    bb36: {\n        StorageDead(_38);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_53);\n        _53 = &((*_36).1: alloc_crate::vec::Vec<backtrace::BacktraceSymbol>);\n        _52 = <alloc_crate::vec::Vec<backtrace::BacktraceSymbol> as core::ops::Deref>::deref(move _53) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_53);\n        _51 = core::slice::<impl [backtrace::BacktraceSymbol]>::iter(_52) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        _50 = <core::slice::Iter<'_, backtrace::BacktraceSymbol> as core::iter::IntoIterator>::into_iter(move _51) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_51);\n        StorageLive(_54);\n        _54 = move _50;\n        goto -> bb40;\n    }\n    bb40: {\n        StorageLive(_55);\n        _56 = &mut _54;\n        _55 = <core::slice::Iter<'_, backtrace::BacktraceSymbol> as core::iter::Iterator>::next(_56) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        _57 = discriminant(_55);\n        switchInt(move _57) -> [0: bb43, 1: bb42, otherwise: bb1];\n    }\n    bb42: {\n        StorageLive(_58);\n        _58 = ((_55 as variant#1).0: &backtrace::BacktraceSymbol);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = &mut _24;\n        _62 = backtrace_rs::print::BacktraceFmt::<'_, '_>::frame(move _63) -> [return: bb44, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_50);\n        goto -> bb56;\n    }\n    bb44: {\n        _61 = &mut _62;\n        StorageDead(_63);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = &((*_36).0: backtrace::RawFrame);\n        _64 = backtrace::RawFrame::ip(move _65) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = &((*_58).0: core::option::Option<alloc_crate::vec::Vec<u8>>);\n        _67 = core::option::Option::<alloc_crate::vec::Vec<u8>>::as_ref(move _68) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_68);\n        _66 = core::option::Option::<&alloc_crate::vec::Vec<u8>>::map::<backtrace_rs::symbolize::SymbolName<'_>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:415:50: 415:53}>(move _67, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:415:50: 415:53}) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        StorageDead(_67);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = &((*_58).1: core::option::Option<backtrace::BytesOrWide>);\n        _70 = core::option::Option::<backtrace::BytesOrWide>::as_ref(move _71) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_71);\n        _69 = core::option::Option::<&backtrace::BytesOrWide>::map::<backtrace_rs::types::BytesOrWideString<'_>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:416:54: 416:57}>(move _70, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/backtrace.rs:416:54: 416:57}) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_70);\n        StorageLive(_72);\n        _72 = ((*_58).2: core::option::Option<u32>);\n        StorageLive(_73);\n        _73 = ((*_58).3: core::option::Option<u32>);\n        _60 = backtrace_rs::print::BacktraceFrameFmt::<'_, '_, '_>::print_raw_with_column(move _61, move _64, move _66, move _69, move _72, move _73) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_73);\n        StorageDead(_72);\n        StorageDead(_69);\n        StorageDead(_66);\n        StorageDead(_64);\n        StorageDead(_61);\n        _59 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _60) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_60);\n        _74 = discriminant(_59);\n        switchInt(move _74) -> [0: bb52, 1: bb53, otherwise: bb1];\n    }\n    bb52: {\n        drop(_62) -> [return: bb55, unwind unreachable];\n    }\n    bb53: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        drop(_62) -> [return: bb63, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_62);\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_55);\n        goto -> bb40;\n    }\n    bb56: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_33);\n        goto -> bb22;\n    }\n    bb57: {\n        StorageDead(_77);\n        _75 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _76) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_76);\n        _78 = discriminant(_75);\n        switchInt(move _78) -> [0: bb59, 1: bb60, otherwise: bb1];\n    }\n    bb59: {\n        StorageDead(_75);\n        _0 = core::result::Result::Ok(());\n        StorageDead(_24);\n        drop(_23) -> [return: bb62, unwind unreachable];\n    }\n    bb60: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_75);\n        goto -> bb66;\n    }\n    bb62: {\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb70;\n    }\n    bb63: {\n        StorageDead(_62);\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_55);\n        StorageDead(_54);\n        StorageDead(_50);\n        goto -> bb65;\n    }\n    bb64: {\n        StorageDead(_42);\n        StorageDead(_39);\n        goto -> bb65;\n    }\n    bb65: {\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageDead(_31);\n        goto -> bb66;\n    }\n    bb66: {\n        StorageDead(_24);\n        drop(_23) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb69;\n    }\n    bb68: {\n        StorageDead(_3);\n        goto -> bb69;\n    }\n    bb69: {\n        goto -> bb70;\n    }\n    bb70: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}