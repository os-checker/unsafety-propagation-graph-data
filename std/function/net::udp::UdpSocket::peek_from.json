{
  "name": "net::udp::UdpSocket::peek_from",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::UdpSocket::peek_from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::UdpSocket": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::net::connection::socket::UdpSocket": [
      "Ref"
    ],
    "net::udp::UdpSocket": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::net::udp::UdpSocket::peek_from"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/net/udp.rs:174:5: 176:6",
  "src": "pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n        self.0.peek_from(buf)\n    }",
  "mir": "fn net::udp::UdpSocket::peek_from(_1: &net::udp::UdpSocket, _2: &mut [u8]) -> core::result::Result<(usize, core::net::SocketAddr), io::error::Error> {\n    let mut _0: core::result::Result<(usize, core::net::SocketAddr), io::error::Error>;\n    let mut _3: &sys::net::connection::socket::UdpSocket;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::net::connection::socket::UdpSocket);\n        _0 = sys::net::connection::socket::UdpSocket::peek_from(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Receives a single datagram message on the socket, without removing it from the\n queue. On success, returns the number of bytes read and the origin.\n\n The function must be called with valid byte array `buf` of sufficient size to\n hold the message bytes. If a message is too long to fit in the supplied buffer,\n excess bytes may be discarded.\n\n Successive calls return the same data. This is accomplished by passing\n `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n\n Do not use this function to implement busy waiting, instead use `libc::poll` to\n synchronize IO events on one or more sockets.\n\n # Examples\n\n ```no_run\n use std::net::UdpSocket;\n\n let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n let mut buf = [0; 10];\n let (number_of_bytes, src_addr) = socket.peek_from(&mut buf)\n                                         .expect(\"Didn't receive data\");\n let filled_buf = &mut buf[..number_of_bytes];\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}