{
  "name": "sys::io::kernel_copy::linux::fd_to_meta",
  "safe": true,
  "callees": {
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "os::fd::raw::FromRawFd::from_raw_fd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new instance of `Self` from the given raw file\n descriptor.\n\n This function is typically used to **consume ownership** of the\n specified file descriptor. When used in this way, the returned object\n will take responsibility for closing it when the object goes out of\n scope.\n\n However, consuming ownership is not strictly required. Use a\n [`From<OwnedFd>::from`] implementation for an API which strictly\n consumes ownership.\n\n # Safety\n\n The `fd` passed in must be an [owned file descriptor][io-safety];\n in particular, it must be open.\n\n [io-safety]: io#io-safety\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{FromRawFd, IntoRawFd, RawFd};\n\n let f = File::open(\"foo.txt\")?;\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.into_raw_fd();\n // SAFETY: no other functions should call `from_raw_fd`, so there\n // is only one owner for the file descriptor.\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let f = unsafe { File::from_raw_fd(raw_fd) };\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "fs::File::metadata": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Queries metadata about the underlying file.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let metadata = f.metadata()?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::File": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "fs::Metadata": "Constructor"
      }
    }
  },
  "adts": {
    "fs::File": [
      "Plain",
      "Ref"
    ],
    "core::mem::ManuallyDrop": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3692, kind: RigidTy(Adt(AdtDef(DefId { id: 6032, name: \"fs::Metadata\" }), GenericArgs([]))) })])"
    ],
    "sys::io::kernel_copy::linux::FdMeta": [
      "Plain"
    ],
    "fs::Metadata": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::io::kernel_copy::linux::fd_to_meta"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/io/kernel_copy/linux.rs:555:1: 562:2",
  "src": "fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n    let fd = fd.as_raw_fd();\n    let file: ManuallyDrop<File> = ManuallyDrop::new(unsafe { File::from_raw_fd(fd) });\n    match file.metadata() {\n        Ok(meta) => FdMeta::Metadata(meta),\n        Err(_) => FdMeta::NoneObtained,\n    }\n}",
  "mir": "fn sys::io::kernel_copy::linux::fd_to_meta(_1: &T) -> sys::io::kernel_copy::linux::FdMeta {\n    let mut _0: sys::io::kernel_copy::linux::FdMeta;\n    let  _2: i32;\n    let  _3: core::mem::ManuallyDrop<fs::File>;\n    let mut _4: fs::File;\n    let mut _5: core::result::Result<fs::Metadata, io::error::Error>;\n    let  _6: &fs::File;\n    let mut _7: &core::mem::ManuallyDrop<fs::File>;\n    let mut _8: isize;\n    let  _9: fs::Metadata;\n    let mut _10: isize;\n    debug fd => _1;\n    debug fd => _2;\n    debug file => _3;\n    debug meta => _9;\n    bb0: {\n        _2 = <T as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <fs::File as os::fd::raw::FromRawFd>::from_raw_fd(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = core::mem::ManuallyDrop::<fs::File>::new(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &_3;\n        _6 = <core::mem::ManuallyDrop<fs::File> as core::ops::Deref>::deref(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = fs::File::metadata(_6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb8, 1: bb7, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _0 = sys::io::kernel_copy::linux::FdMeta::NoneObtained;\n        goto -> bb11;\n    }\n    bb8: {\n        _9 = move ((_5 as variant#0).0: fs::Metadata);\n        _0 = sys::io::kernel_copy::linux::FdMeta::Metadata(_9);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageDead(_5);\n        StorageDead(_3);\n        return;\n    }\n    bb10: {\n        drop(_5) -> [return: bb9, unwind unreachable];\n    }\n    bb11: {\n        _10 = discriminant(_5);\n        switchInt(move _10) -> [0: bb9, 1: bb10, otherwise: bb6];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}