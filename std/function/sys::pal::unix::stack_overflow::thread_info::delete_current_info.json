{
  "name": "sys::pal::unix::stack_overflow::thread_info::delete_current_info",
  "safe": true,
  "callees": {
    "sys::pal::unix::os::errno_location": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n [without_provenance]: without_provenance_mut\n",
      "adt": {}
    },
    "sync::poison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Errors\n\n If another user of this mutex panicked while holding the mutex, then\n this call will return an error once the mutex is acquired. The acquired\n mutex guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock().unwrap() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock().unwrap(), 10);\n ```\n",
      "adt": {
        "sync::poison::mutex::Mutex": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sys::pal::unix::stack_overflow::thread_info::spin_lock_in_setup": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::pal::unix::stack_overflow::thread_info::UnlockOnDrop": "Constructor"
      }
    },
    "alloc_crate::collections::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::poison::mutex::Mutex": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "sys::pal::unix::stack_overflow::thread_info::UnlockOnDrop": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc_crate::collections::BTreeMap": [
      "MutRef"
    ]
  },
  "path": 3972,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/stack_overflow/thread_info.rs:125:1: 133:2",
  "src": "pub fn delete_current_info() {\n    let this = errno_location().addr();\n    let _lock_guard = LOCK.lock();\n    let _spin_guard = spin_lock_in_setup(this);\n\n    // SAFETY: we own the spin lock, so `THREAD_INFO` cannot not be aliased.\n    let thread_info = unsafe { &mut *(&raw mut THREAD_INFO) };\n    thread_info.remove(&this);\n}",
  "mir": "fn sys::pal::unix::stack_overflow::thread_info::delete_current_info() -> () {\n    let mut _0: ();\n    let  _1: usize;\n    let mut _2: *mut i32;\n    let  _3: core::result::Result<sync::poison::mutex::MutexGuard<'_, ()>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, ()>>>;\n    let mut _4: &sync::poison::mutex::Mutex<()>;\n    let  _5: sys::pal::unix::stack_overflow::thread_info::UnlockOnDrop;\n    let mut _6: &mut alloc_crate::collections::BTreeMap<usize, sys::pal::unix::stack_overflow::thread_info::ThreadInfo>;\n    let mut _7: *mut alloc_crate::collections::BTreeMap<usize, sys::pal::unix::stack_overflow::thread_info::ThreadInfo>;\n    let  _8: core::option::Option<sys::pal::unix::stack_overflow::thread_info::ThreadInfo>;\n    let  _9: &usize;\n    let mut _10: *const ();\n    let mut _11: usize;\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: bool;\n    let mut _15: *const ();\n    let mut _16: usize;\n    let mut _17: bool;\n    let mut _18: bool;\n    let mut _19: bool;\n    debug this => _1;\n    debug _lock_guard => _3;\n    debug _spin_guard => sys::pal::unix::stack_overflow::thread_info::UnlockOnDrop;\n    debug thread_info => _6;\n    bb0: {\n        StorageLive(_2);\n        _2 = sys::pal::unix::os::errno_location() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = core::ptr::mut_ptr::<impl *mut i32>::addr(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = {alloc323: &sync::poison::mutex::Mutex<()>};\n        _3 = sync::poison::mutex::Mutex::<()>::lock(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _5 = sys::pal::unix::stack_overflow::thread_info::spin_lock_in_setup(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = {alloc336: *mut alloc_crate::collections::BTreeMap<usize, sys::pal::unix::stack_overflow::thread_info::ThreadInfo>};\n        _10 = _7 as *const ();\n        _11 = _10 as usize;\n        _12 = Sub(<alloc_crate::collections::BTreeMap<usize, sys::pal::unix::stack_overflow::thread_info::ThreadInfo> as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _13 = BitAnd(_11, _12);\n        _14 = Eq(_13, 0_usize);\n        assert(_14, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<alloc_crate::collections::BTreeMap<usize, sys::pal::unix::stack_overflow::thread_info::ThreadInfo> as core::mem::SizedTypeProperties>::ALIGN, _11) -> [success: bb9, unwind unreachable];\n    }\n    bb5: {\n        drop(_8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_7);\n        drop(_5) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        drop(_3) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_3);\n        return;\n    }\n    bb9: {\n        _15 = _7 as *const ();\n        _16 = _15 as usize;\n        _17 = Eq(_16, 0_usize);\n        _18 = BitAnd(_17, true);\n        _19 = Not(_18);\n        assert(_19, \"null pointer dereference occurred\") -> [success: bb10, unwind unreachable];\n    }\n    bb10: {\n        _6 = &mut (*_7);\n        StorageLive(_8);\n        _9 = &_1;\n        _8 = alloc_crate::collections::BTreeMap::<usize, sys::pal::unix::stack_overflow::thread_info::ThreadInfo>::remove::<usize>(_6, _9) -> [return: bb5, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}