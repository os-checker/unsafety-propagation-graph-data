{
  "name": "panicking::begin_panic",
  "safe": true,
  "callees": {
    "core::panic::Location::<'a>::caller": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the source location of the caller of this function. If that function's caller is\n annotated then its call location will be returned, and so on up the stack to the first call\n within a non-tracked function body.\n\n # Examples\n\n ```standalone_crate\n use std::panic::Location;\n\n /// ```\n ///      |1        |11       |21       |31       |41\n ///    +-|---------|---------|---------|---------|--------\n /// 15 | #[track_caller]\n /// 16 | fn new_location() -> &'static Location<'static> {\n /// 17 |     Location::caller()\n ///    |     ------------------| the value of this expression depends on the caller,\n ///    |                       | since the function is marked #[track_caller]\n /// 18 | }\n /// ```\n #[track_caller]\n fn new_location() -> &'static Location<'static> {\n     Location::caller()\n }\n\n /// ```\n ///      |1  |5    |11       |21       |31       |41       |51\n ///    +-|---|-----|---------|---------|---------|---------|---\n /// 29 | fn constant_location() -> &'static Location<'static> {\n /// 30 |     new_location()\n ///    |     ^ any invocation of constant_location() points here,\n ///    |       no matter the location it is called from\n /// 31 | }\n /// ```\n fn constant_location() -> &'static Location<'static> {\n     new_location()\n }\n\n fn main() {\n     //      |1  |5    |11       |21       |31       |41       |51\n     //    +-|---|-----|---------|---------|---------|---------|---\n     // 29 | fn constant_location() -> &'static Location<'static> {\n     // 30 |     new_location()\n     //    |     ^ `let constant` points here\n     // 31 | }\n     let constant = constant_location();\n     assert_eq!(constant.file(), file!());\n     assert_eq!((constant.line(), constant.column()), (30, 5));\n\n     let constant_2 = constant_location();\n     assert_eq!(\n         (constant.file(), constant.line(), constant.column()),\n         (constant_2.file(), constant_2.line(), constant_2.column())\n     );\n\n     //      |1        |11  |16  |21       |31\n     //    +-|---------|----|----|---------|------\n     // 55 |     let here = new_location();\n     //    |                ^ `let here` points here, as `new_location()` is the callsite\n     // 56 |     assert_eq!(here.file(), file!());\n     let here = new_location();\n     assert_eq!(here.file(), file!());\n     assert_eq!((here.line(), here.column()), (55, 16));\n\n     //      |1        |11       |21       ||32      |41       |51\n     //    +-|---------|---------|---------||--------|---------|------\n     // 64 |     let yet_another_location = new_location();\n     //    |                                ^ `let yet_another_location` points here\n     // 65 |     assert_eq!(here.file(), yet_another_location.file());\n     let yet_another_location = new_location();\n     assert_eq!(here.file(), yet_another_location.file());\n     assert_ne!(\n         (here.line(), here.column()),\n         (yet_another_location.line(), yet_another_location.column())\n     );\n }\n ```\n",
      "adt": {}
    },
    "sys::backtrace::__rust_end_short_backtrace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n this is only inline(never) when backtraces in std are enabled, otherwise\n it's fine to optimize away.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::panic::Location": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::panicking::begin_panic"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:720:1: 769:2",
  "src": "pub const fn begin_panic<M: Any + Send>(msg: M) -> ! {\n    if cfg!(panic = \"immediate-abort\") {\n        intrinsics::abort()\n    }\n\n    struct Payload<A> {\n        inner: Option<A>,\n    }\n\n    unsafe impl<A: Send + 'static> PanicPayload for Payload<A> {\n        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n            // Note that this should be the only allocation performed in this code path. Currently\n            // this means that panic!() on OOM will invoke this code path, but then again we're not\n            // really ready for panic on OOM anyway. If we do start doing this, then we should\n            // propagate this allocation to be performed in the parent of this thread instead of the\n            // thread that's panicking.\n            let data = match self.inner.take() {\n                Some(a) => Box::new(a) as Box<dyn Any + Send>,\n                None => process::abort(),\n            };\n            Box::into_raw(data)\n        }\n\n        fn get(&mut self) -> &(dyn Any + Send) {\n            match self.inner {\n                Some(ref a) => a,\n                None => process::abort(),\n            }\n        }\n    }\n\n    impl<A: 'static> fmt::Display for Payload<A> {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            match &self.inner {\n                Some(a) => f.write_str(payload_as_str(a)),\n                None => process::abort(),\n            }\n        }\n    }\n\n    let loc = Location::caller();\n    crate::sys::backtrace::__rust_end_short_backtrace(move || {\n        panic_with_hook(\n            &mut Payload { inner: Some(msg) },\n            loc,\n            /* can_unwind */ true,\n            /* force_no_backtrace */ false,\n        )\n    })\n}",
  "mir": "fn panicking::begin_panic(_1: M) -> ! {\n    let mut _0: !;\n    let  _2: &core::panic::Location<'_>;\n    let mut _3: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:761:55: 761:62};\n    debug msg => _1;\n    debug loc => _2;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::panic::Location::<'_>::caller() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:761:55: 761:62}(move _1, _2);\n        _0 = sys::backtrace::__rust_end_short_backtrace::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:761:55: 761:62}, !>(move _3) -> unwind unreachable;\n    }\n}\n",
  "doc": " This is the entry point of panicking for the non-format-string variants of\n panic!() and assert!(). In particular, this is the only entry point that supports\n arbitrary payloads, not just format strings.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}