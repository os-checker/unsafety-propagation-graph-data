{
  "name": "sync::nonpoison::rwlock::RwLock::<T>::try_read",
  "safe": true,
  "callees": {
    "sys::sync::rwlock::futex::RwLock::try_read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::rwlock::futex::RwLock": "ImmutableAsArgument"
      }
    },
    "sync::nonpoison::rwlock::RwLockReadGuard::<'rwlock, T>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of `RwLockReadGuard<T>` from a `RwLock<T>`.\n\n # Safety\n\n This function is safe if and only if the same thread has successfully and safely called\n `lock.inner.read()`, `lock.inner.try_read()`, or `lock.inner.downgrade()` before\n instantiating this object.\n",
      "adt": {
        "sync::nonpoison::rwlock::RwLock": "ImmutableAsArgument",
        "sync::nonpoison::rwlock::RwLockReadGuard": "Constructor"
      }
    }
  },
  "adts": {
    "sys::sync::rwlock::futex::RwLock": [
      "Ref"
    ],
    "sync::nonpoison::rwlock::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::nonpoison::rwlock::RwLockReadGuard": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 3121,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/nonpoison/rwlock.rs:361:5: 365:6",
  "src": "pub fn try_read(&self) -> TryLockResult<RwLockReadGuard<'_, T>> {\n        unsafe {\n            if self.inner.try_read() { Ok(RwLockReadGuard::new(self)) } else { Err(WouldBlock) }\n        }\n    }",
  "mir": "fn sync::nonpoison::rwlock::RwLock::<T>::try_read(_1: &sync::nonpoison::rwlock::RwLock<T>) -> core::result::Result<sync::nonpoison::rwlock::RwLockReadGuard<'_, T>, sync::nonpoison::WouldBlock> {\n    let mut _0: core::result::Result<sync::nonpoison::rwlock::RwLockReadGuard<'_, T>, sync::nonpoison::WouldBlock>;\n    let mut _2: bool;\n    let mut _3: &sys::sync::rwlock::futex::RwLock;\n    let mut _4: sync::nonpoison::rwlock::RwLockReadGuard<'_, T>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::sync::rwlock::futex::RwLock);\n        _2 = sys::sync::rwlock::futex::RwLock::try_read(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = sync::nonpoison::rwlock::RwLockReadGuard::<'_, T>::new(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core::result::Result::Ok(move _4);\n        StorageDead(_4);\n        goto -> bb5;\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = core::result::Result::Err(sync::nonpoison::WouldBlock);\n        goto -> bb5;\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Attempts to acquire this `RwLock` with shared read access.\n\n If the access could not be granted at this time, then `Err` is returned.\n Otherwise, an RAII guard is returned which will release the shared access\n when it is dropped.\n\n This function does not block.\n\n This function does not provide any guarantees with respect to the ordering\n of whether contentious readers or writers will acquire the lock first.\n\n # Errors\n\n This function will return the [`WouldBlock`] error if the `RwLock` could\n not be acquired because it was already locked exclusively.\n\n # Examples\n\n ```\n #![feature(nonpoison_rwlock)]\n\n use std::sync::nonpoison::RwLock;\n\n let lock = RwLock::new(1);\n\n match lock.try_read() {\n     Ok(n) => assert_eq!(*n, 1),\n     Err(_) => unreachable!(),\n };\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}