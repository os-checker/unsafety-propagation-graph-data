{
  "name": "sys::env::unix::env",
  "safe": true,
  "callees": {
    "sys::env::unix::env_read_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "sys::env::unix::environ": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"Follow the rabbit\";\n let ptr: *const u8 = s.as_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::ffi::CStr::to_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice.\n\n The returned slice will **not** contain the trailing nul terminator that this C\n string has.\n\n > **Note**: This method is currently implemented as a constant-time\n > cast, but it is planned to alter its definition in the future to\n > perform the length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes(), b\"foo\");\n ```\n",
      "adt": {}
    },
    "sys::env::unix::env::parse": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "ffi::os_str::OsString": "Constructor"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"123\";\n let ptr: *const u8 = s.as_ptr();\n\n unsafe {\n     assert_eq!(*ptr.add(1), b'2');\n     assert_eq!(*ptr.add(2), b'3');\n }\n ```\n",
      "adt": {}
    },
    "sys::env::common::Env::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::env::common::Env": "Constructor"
      }
    },
    "alloc_crate::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::poison::rwlock::RwLockReadGuard": [
      "Plain"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2775, kind: RigidTy(Tuple([Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }])) })])"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef",
      "Plain"
    ],
    "sys::env::common::Env": [
      "Plain"
    ]
  },
  "path": 3391,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/env/unix.rs:58:1: 90:2",
  "src": "pub fn env() -> Env {\n    unsafe {\n        let _guard = env_read_lock();\n        let mut environ = *environ();\n        let mut result = Vec::new();\n        if !environ.is_null() {\n            while !(*environ).is_null() {\n                if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n                    result.push(key_value);\n                }\n                environ = environ.add(1);\n            }\n        }\n        return Env::new(result);\n    }\n\n    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n        // Strategy (copied from glibc): Variable name and value are separated\n        // by an ASCII equals sign '='. Since a variable name must not be\n        // empty, allow variable names starting with an equals sign. Skip all\n        // malformed lines.\n        if input.is_empty() {\n            return None;\n        }\n        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n        pos.map(|p| {\n            (\n                OsStringExt::from_vec(input[..p].to_vec()),\n                OsStringExt::from_vec(input[p + 1..].to_vec()),\n            )\n        })\n    }\n}",
  "mir": "fn sys::env::unix::env() -> sys::env::common::Env {\n    let mut _0: sys::env::common::Env;\n    let  _1: sync::poison::rwlock::RwLockReadGuard<'_, ()>;\n    let mut _2: *const *const u8;\n    let mut _3: *mut *const *const u8;\n    let mut _4: alloc_crate::vec::Vec<(ffi::os_str::OsString, ffi::os_str::OsString)>;\n    let mut _5: bool;\n    let mut _6: *const *const u8;\n    let mut _7: bool;\n    let mut _8: *const u8;\n    let mut _9: core::option::Option<(ffi::os_str::OsString, ffi::os_str::OsString)>;\n    let  _10: &[u8];\n    let  _11: &core::ffi::CStr;\n    let mut _12: *const u8;\n    let mut _13: isize;\n    let  _14: (ffi::os_str::OsString, ffi::os_str::OsString);\n    let  _15: ();\n    let mut _16: &mut alloc_crate::vec::Vec<(ffi::os_str::OsString, ffi::os_str::OsString)>;\n    let mut _17: *const *const u8;\n    let mut _18: *const *const u8;\n    let mut _19: alloc_crate::vec::Vec<(ffi::os_str::OsString, ffi::os_str::OsString)>;\n    let mut _20: *const ();\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: bool;\n    let mut _25: *const ();\n    let mut _26: usize;\n    let mut _27: usize;\n    let mut _28: usize;\n    let mut _29: bool;\n    let mut _30: *const ();\n    let mut _31: usize;\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: bool;\n    let mut _35: *const ();\n    let mut _36: usize;\n    let mut _37: bool;\n    let mut _38: bool;\n    let mut _39: bool;\n    let mut _40: bool;\n    let mut _41: *const ();\n    let mut _42: usize;\n    let mut _43: bool;\n    let mut _44: bool;\n    let mut _45: bool;\n    let mut _46: bool;\n    let mut _47: *const ();\n    let mut _48: usize;\n    let mut _49: bool;\n    let mut _50: bool;\n    let mut _51: bool;\n    let mut _52: bool;\n    debug _guard => _1;\n    debug environ => _2;\n    debug result => _4;\n    debug key_value => _14;\n    bb0: {\n        StorageLive(_1);\n        _1 = sys::env::unix::env_read_lock() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = sys::env::unix::environ() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _30 = _3 as *const ();\n        _31 = _30 as usize;\n        _32 = Sub(<*const *const u8 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _33 = BitAnd(_31, _32);\n        _34 = Eq(_33, 0_usize);\n        assert(_34, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<*const *const u8 as core::mem::SizedTypeProperties>::ALIGN, _31) -> [success: bb24, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = _2;\n        _5 = core::ptr::const_ptr::<impl *const *const u8>::is_null(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_6);\n        goto -> bb18;\n    }\n    bb6: {\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _25 = _2 as *const ();\n        _26 = _25 as usize;\n        _27 = Sub(<*const u8 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _28 = BitAnd(_26, _27);\n        _29 = Eq(_28, 0_usize);\n        assert(_29, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<*const u8 as core::mem::SizedTypeProperties>::ALIGN, _26) -> [success: bb23, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _7) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb18;\n    }\n    bb10: {\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_12);\n        _20 = _2 as *const ();\n        _21 = _20 as usize;\n        _22 = Sub(<*const u8 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _23 = BitAnd(_21, _22);\n        _24 = Eq(_23, 0_usize);\n        assert(_24, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<*const u8 as core::mem::SizedTypeProperties>::ALIGN, _21) -> [success: bb22, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_12);\n        _10 = core::ffi::CStr::to_bytes(_11) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _9 = sys::env::unix::env::parse(_10) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _13 = discriminant(_9);\n        switchInt(move _13) -> [1: bb14, 0: bb21, otherwise: bb28];\n    }\n    bb14: {\n        _14 = move ((_9 as variant#1).0: (ffi::os_str::OsString, ffi::os_str::OsString));\n        StorageLive(_16);\n        _16 = &mut _4;\n        _15 = alloc_crate::vec::Vec::<(ffi::os_str::OsString, ffi::os_str::OsString)>::push(move _16, _14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_16);\n        StorageDead(_9);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = _2;\n        _17 = core::ptr::const_ptr::<impl *const *const u8>::add(move _18, 1_usize) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_18);\n        _2 = move _17;\n        StorageDead(_17);\n        StorageDead(_7);\n        goto -> bb7;\n    }\n    bb18: {\n        StorageDead(_5);\n        StorageLive(_19);\n        _19 = move _4;\n        _0 = sys::env::common::Env::new(move _19) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_19);\n        StorageDead(_4);\n        StorageDead(_2);\n        drop(_1) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_1);\n        return;\n    }\n    bb21: {\n        StorageDead(_9);\n        goto -> bb16;\n    }\n    bb22: {\n        _47 = _2 as *const ();\n        _48 = _47 as usize;\n        _49 = Ne(<*const u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _50 = Eq(_48, 0_usize);\n        _51 = BitAnd(_50, _49);\n        _52 = Not(_51);\n        assert(_52, \"null pointer dereference occurred\") -> [success: bb27, unwind unreachable];\n    }\n    bb23: {\n        _41 = _2 as *const ();\n        _42 = _41 as usize;\n        _43 = Ne(<*const u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _44 = Eq(_42, 0_usize);\n        _45 = BitAnd(_44, _43);\n        _46 = Not(_45);\n        assert(_46, \"null pointer dereference occurred\") -> [success: bb26, unwind unreachable];\n    }\n    bb24: {\n        _35 = _3 as *const ();\n        _36 = _35 as usize;\n        _37 = Ne(<*const *const u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _38 = Eq(_36, 0_usize);\n        _39 = BitAnd(_38, _37);\n        _40 = Not(_39);\n        assert(_40, \"null pointer dereference occurred\") -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _2 = (*_3);\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = alloc_crate::vec::Vec::<(ffi::os_str::OsString, ffi::os_str::OsString)>::new() -> [return: bb3, unwind unreachable];\n    }\n    bb26: {\n        _8 = (*_2);\n        _7 = core::ptr::const_ptr::<impl *const u8>::is_null(move _8) -> [return: bb8, unwind unreachable];\n    }\n    bb27: {\n        _12 = (*_2);\n        _11 = core::ffi::CStr::from_ptr::<'_>(move _12) -> [return: bb11, unwind unreachable];\n    }\n    bb28: {\n        unreachable;\n    }\n}\n",
  "doc": " Returns a vector of (variable, value) byte-vector pairs for all the\n environment variables of the current process.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}