{
  "name": "path::Path::has_trailing_sep",
  "safe": true,
  "callees": {
    "path::Path::as_os_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields the underlying [`OsStr`] slice.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let os_str = Path::new(\"foo.txt\").as_os_str();\n assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "ffi::os_str::OsStr::as_encoded_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n string slice, use the [`OsStr::from_encoded_bytes_unchecked`] function.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n be treated as opaque and only comparable within the same Rust version built for the same\n target platform.  For example, sending the slice over the network or storing it in a file\n will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n and [`std::ffi`] for platform-specific, specified conversions.\n\n [`std::ffi`]: crate::ffi\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::last": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the last element of the slice, or `None` if it is empty.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&30), v.last());\n\n let w: &[i32] = &[];\n assert_eq!(None, w.last());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<&T>::copied": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n option.\n\n # Examples\n\n ```\n let x = 12;\n let opt_x = Some(&x);\n assert_eq!(opt_x, Some(&12));\n let copied = opt_x.copied();\n assert_eq!(copied, Some(12));\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::is_some_and": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] and the value inside of it matches a predicate.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some_and(|x| x > 1), true);\n\n let x: Option<u32> = Some(0);\n assert_eq!(x.is_some_and(|x| x > 1), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some_and(|x| x > 1), false);\n\n let x: Option<String> = Some(\"ownership\".to_string());\n assert_eq!(x.as_ref().is_some_and(|x| x.len() > 1), true);\n println!(\"still alive {:?}\", x);\n ```\n",
      "adt": {}
    },
    "sys::path::unix::is_sep_byte": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 2432,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:2904:5: 2906:6",
  "src": "pub fn has_trailing_sep(&self) -> bool {\n        self.as_os_str().as_encoded_bytes().last().copied().is_some_and(is_sep_byte)\n    }",
  "mir": "fn path::Path::has_trailing_sep(_1: &path::Path) -> bool {\n    let mut _0: bool;\n    let mut _2: core::option::Option<u8>;\n    let mut _3: core::option::Option<&u8>;\n    let  _4: &[u8];\n    let  _5: &ffi::os_str::OsStr;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _5 = path::Path::as_os_str(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = ffi::os_str::OsStr::as_encoded_bytes(_5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = core::slice::<impl [u8]>::last(_4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _2 = core::option::Option::<&u8>::copied(move _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = core::option::Option::<u8>::is_some_and::<fn(u8) -> bool {sys::path::unix::is_sep_byte}>(move _2, sys::path::unix::is_sep_byte) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Checks whether the path ends in a trailing [separator](MAIN_SEPARATOR).\n\n This is generally done to ensure that a path is treated as a directory, not a file,\n although it does not actually guarantee that such a path is a directory on the underlying\n file system.\n\n Despite this behavior, two paths are still considered the same in Rust whether they have a\n trailing separator or not.\n\n # Examples\n\n ```\n #![feature(path_trailing_sep)]\n use std::path::Path;\n\n assert!(Path::new(\"dir/\").has_trailing_sep());\n assert!(!Path::new(\"file.rs\").has_trailing_sep());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}