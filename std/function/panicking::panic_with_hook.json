{
  "name": "panicking::panic_with_hook",
  "safe": true,
  "callees": {
    "panicking::panic_count::increase": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "panicking::panic_count::MustAbort": "Constructor"
      }
    },
    "sys::stdio::unix::panic_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::stdio::unix::Stderr": "Constructor"
      }
    },
    "core::panic::PanicPayload::as_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tries to borrow the contents as `&str`, if possible without doing any allocations.\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or_default": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a default.\n\n Consumes the `self` argument then, if [`Some`], returns the contained\n value, otherwise if [`None`], returns the [default value] for that\n type.\n\n # Examples\n\n ```\n let x: Option<u32> = None;\n let y: Option<u32> = Some(12);\n\n assert_eq!(x.unwrap_or_default(), 0);\n assert_eq!(y.unwrap_or_default(), 12);\n ```\n\n [default value]: Default::default\n [`parse`]: str::parse\n [`FromStr`]: crate::str::FromStr\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::Write::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a formatted string into this writer, returning any error\n encountered.\n\n This method is primarily used to interface with the\n [`format_args!()`] macro, and it is rare that this should\n explicitly be called. The [`write!()`] macro should be favored to\n invoke this method instead.\n\n This function internally uses the [`write_all`] method on\n this trait and hence will continuously write data so long as no errors\n are received. This also means that partial writes are not indicated in\n this signature.\n\n [`write_all`]: Write::write_all\n\n # Errors\n\n This function will return any I/O error reported while formatting.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // this call\n     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n     // turns into this:\n     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::fmt::Arguments": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "process::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Terminates the process in an abnormal fashion.\n\n The function will never return and will immediately terminate the current\n process in a platform specific \"abnormal\" manner. As a consequence,\n no destructors on the current stack or any other thread's stack\n will be run, Rust IO buffers (eg, from `BufWriter`) will not be flushed,\n and C stdio buffers will (on most platforms) not be flushed.\n\n This is in contrast to the default behavior of [`panic!`] which unwinds\n the current thread's stack and calls all destructors.\n When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n [`panic!`] will still call the [panic hook] while `abort` will not.\n\n If a clean shutdown is needed it is recommended to only call\n this function at a known point where there are no more destructors left\n to run.\n\n The process's termination will be similar to that from the C `abort()`\n function.  On Unix, the process will terminate with signal `SIGABRT`, which\n typically means that the shell prints \"Aborted\".\n\n # Examples\n\n ```no_run\n use std::process;\n\n fn main() {\n     println!(\"aborting\");\n\n     process::abort();\n\n     // execution never gets here\n }\n ```\n\n The `abort` function terminates the process, so the destructor will not\n get run on the example below:\n\n ```no_run\n use std::process;\n\n struct HasDrop;\n\n impl Drop for HasDrop {\n     fn drop(&mut self) {\n         println!(\"This will never be printed!\");\n     }\n }\n\n fn main() {\n     let _x = HasDrop;\n     process::abort();\n     // the destructor implemented for HasDrop will never get run\n }\n ```\n\n [panic hook]: crate::panic::set_hook\n",
      "adt": {}
    },
    "sync::nonpoison::rwlock::RwLock::<T>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks this `RwLock` with shared read access, blocking the current thread\n until it can be acquired.\n\n The calling thread will be blocked until there are no more writers which\n hold the lock. There may be other readers currently inside the lock when\n this method returns. This method does not provide any guarantees with\n respect to the ordering of whether contentious readers or writers will\n acquire the lock first.\n\n Returns an RAII guard which will release this thread's shared access\n once it is dropped.\n\n # Panics\n\n This function might panic when called if the lock is already held by the current thread.\n\n # Examples\n\n ```\n #![feature(nonpoison_rwlock)]\n\n use std::sync::Arc;\n use std::sync::nonpoison::RwLock;\n use std::thread;\n\n let lock = Arc::new(RwLock::new(1));\n let c_lock = Arc::clone(&lock);\n\n let n = lock.read();\n assert_eq!(*n, 1);\n\n thread::spawn(move || {\n     let r = c_lock.read();\n }).join().unwrap();\n ```\n",
      "adt": {
        "sync::nonpoison::rwlock::RwLock": "ImmutableAsArgument",
        "sync::nonpoison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::panic::PanicPayload::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Just borrow the contents.\n",
      "adt": {}
    },
    "core::option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {}
    },
    "panic::PanicHookInfo::<'a>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::panic::Location": "ImmutableAsArgument",
        "panic::PanicHookInfo": "Constructor"
      }
    },
    "panicking::default_hook": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The default panic handler.\n",
      "adt": {
        "panic::PanicHookInfo": "ImmutableAsArgument"
      }
    },
    "core::ops::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "panicking::panic_count::finished_panic_hook": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "panicking::rust_panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A function with a fixed suffix (through `rustc_std_internal_symbol`)\n on which to slap yer breakpoints.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 13205, kind: RigidTy(Adt(AdtDef(DefId { id: 10313, name: \"panicking::panic_count::MustAbort\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "panicking::panic_count::MustAbort": [
      "Plain"
    ],
    "sys::stdio::unix::Stderr": [
      "MutRef",
      "Plain"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "sync::nonpoison::rwlock::RwLock": [
      "Ref"
    ],
    "sync::nonpoison::rwlock::RwLockReadGuard": [
      "Plain",
      "Ref"
    ],
    "panicking::Hook": [
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 13140, kind: RigidTy(Adt(AdtDef(DefId { id: 4386, name: \"alloc_crate::boxed::Box\" }), GenericArgs([Type(Ty { id: 13145, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 4409, name: \"core::ops::Fn\" }), generic_args: GenericArgs([Type(Ty { id: 13146, kind: RigidTy(Tuple([Ty { id: 13150, kind: RigidTy(Ref(Region { kind: ReBound(0, BoundRegion { var: 0, kind: BrAnon }) }, Ty { id: 13151, kind: RigidTy(Adt(AdtDef(DefId { id: 8683, name: \"panic::PanicHookInfo\" }), GenericArgs([Lifetime(Region { kind: ReBound(0, BoundRegion { var: 1, kind: BrAnon }) })]))) }, Not)) }])) })]) }), bound_vars: [Region(BrAnon), Region(BrAnon)] }, Binder { value: Projection(ExistentialProjection { def_id: TraitDef(DefId { id: 4410, name: \"core::ops::FnOnce::Output\" }), generic_args: GenericArgs([Type(Ty { id: 13146, kind: RigidTy(Tuple([Ty { id: 13150, kind: RigidTy(Ref(Region { kind: ReBound(0, BoundRegion { var: 0, kind: BrAnon }) }, Ty { id: 13151, kind: RigidTy(Adt(AdtDef(DefId { id: 8683, name: \"panic::PanicHookInfo\" }), GenericArgs([Lifetime(Region { kind: ReBound(0, BoundRegion { var: 1, kind: BrAnon }) })]))) }, Not)) }])) })]), term: Type(Ty { id: 1, kind: RigidTy(Tuple([])) }) }), bound_vars: [Region(BrAnon), Region(BrAnon)] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4411, name: \"core::marker::Sync\" })), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4634, name: \"core::marker::Send\" })), bound_vars: [] }], Region { kind: ReErased })) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])"
    ],
    "alloc_crate::boxed::Box": [
      "Ref"
    ],
    "panic::PanicHookInfo": [
      "Plain",
      "Ref"
    ]
  },
  "path": 2326,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:787:1: 851:2",
  "src": "fn panic_with_hook(\n    payload: &mut dyn PanicPayload,\n    location: &Location<'_>,\n    can_unwind: bool,\n    force_no_backtrace: bool,\n) -> ! {\n    let must_abort = panic_count::increase(true);\n\n    // Check if we need to abort immediately.\n    if let Some(must_abort) = must_abort {\n        match must_abort {\n            panic_count::MustAbort::PanicInHook => {\n                // Don't try to format the message in this case, perhaps that is causing the\n                // recursive panics. However if the message is just a string, no user-defined\n                // code is involved in printing it, so that is risk-free.\n                let message: &str = payload.as_str().unwrap_or_default();\n                rtprintpanic!(\n                    \"panicked at {location}:\\n{message}\\nthread panicked while processing panic. aborting.\\n\"\n                );\n            }\n            panic_count::MustAbort::AlwaysAbort => {\n                // Unfortunately, this does not print a backtrace, because creating\n                // a `Backtrace` will allocate, which we must avoid here.\n                rtprintpanic!(\"aborting due to panic at {location}:\\n{payload}\\n\");\n            }\n        }\n        crate::process::abort();\n    }\n\n    match *HOOK.read() {\n        // Some platforms (like wasm) know that printing to stderr won't ever actually\n        // print anything, and if that's the case we can skip the default\n        // hook. Since string formatting happens lazily when calling `payload`\n        // methods, this means we avoid formatting the string at all!\n        // (The panic runtime might still call `payload.take_box()` though and trigger\n        // formatting.)\n        Hook::Default if panic_output().is_none() => {}\n        Hook::Default => {\n            default_hook(&PanicHookInfo::new(\n                location,\n                payload.get(),\n                can_unwind,\n                force_no_backtrace,\n            ));\n        }\n        Hook::Custom(ref hook) => {\n            hook(&PanicHookInfo::new(location, payload.get(), can_unwind, force_no_backtrace));\n        }\n    }\n\n    // Indicate that we have finished executing the panic hook. After this point\n    // it is fine if there is a panic while executing destructors, as long as it\n    // it contained within a `catch_unwind`.\n    panic_count::finished_panic_hook();\n\n    if !can_unwind {\n        // If a thread panics while running destructors or tries to unwind\n        // through a nounwind function (e.g. extern \"C\") then we cannot continue\n        // unwinding and have to abort immediately.\n        rtprintpanic!(\"thread caused non-unwinding panic. aborting.\\n\");\n        crate::process::abort();\n    }\n\n    rust_panic(payload)\n}",
  "mir": "fn panicking::panic_with_hook(_1: &mut dyn core::panic::PanicPayload, _2: &core::panic::Location<'_>, _3: bool, _4: bool) -> ! {\n    let mut _0: !;\n    let  _5: core::option::Option<panicking::panic_count::MustAbort>;\n    let mut _6: isize;\n    let  _7: panicking::panic_count::MustAbort;\n    let mut _8: isize;\n    let  _9: &str;\n    let  _10: &str;\n    let mut _11: core::option::Option<&str>;\n    let mut _12: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _13: isize;\n    let mut _14: sys::stdio::unix::Stderr;\n    let mut _15: core::result::Result<(), io::error::Error>;\n    let mut _16: &mut sys::stdio::unix::Stderr;\n    let mut _17: core::fmt::Arguments<'_>;\n    let  _18: (&&core::panic::Location<'_>, &&str);\n    let mut _19: &&core::panic::Location<'_>;\n    let mut _20: &&str;\n    let  _21: [core::fmt::rt::Argument<'_>; 2];\n    let mut _22: core::fmt::rt::Argument<'_>;\n    let mut _23: core::fmt::rt::Argument<'_>;\n    let mut _24: &[u8; 71];\n    let  _25: &[core::fmt::rt::Argument<'_>; 2];\n    let mut _26: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _27: isize;\n    let mut _28: sys::stdio::unix::Stderr;\n    let mut _29: core::result::Result<(), io::error::Error>;\n    let mut _30: &mut sys::stdio::unix::Stderr;\n    let mut _31: core::fmt::Arguments<'_>;\n    let  _32: (&&core::panic::Location<'_>, &&mut dyn core::panic::PanicPayload);\n    let mut _33: &&core::panic::Location<'_>;\n    let mut _34: &&mut dyn core::panic::PanicPayload;\n    let  _35: [core::fmt::rt::Argument<'_>; 2];\n    let mut _36: core::fmt::rt::Argument<'_>;\n    let mut _37: core::fmt::rt::Argument<'_>;\n    let mut _38: &[u8; 34];\n    let  _39: &[core::fmt::rt::Argument<'_>; 2];\n    let  _40: !;\n    let mut _41: &panicking::Hook;\n    let mut _42: &sync::nonpoison::rwlock::RwLockReadGuard<'_, panicking::Hook>;\n    let  _43: sync::nonpoison::rwlock::RwLockReadGuard<'_, panicking::Hook>;\n    let mut _44: &sync::nonpoison::rwlock::RwLock<panicking::Hook>;\n    let mut _45: isize;\n    let mut _46: bool;\n    let mut _47: &core::option::Option<sys::stdio::unix::Stderr>;\n    let  _48: core::option::Option<sys::stdio::unix::Stderr>;\n    let  _49: ();\n    let  _50: &panic::PanicHookInfo<'_>;\n    let  _51: panic::PanicHookInfo<'_>;\n    let  _52: &dyn core::any::Any + core::marker::Send;\n    let  _53: &alloc_crate::boxed::Box<dyn for<'a, 'b> core::ops::Fn(&'a panic::PanicHookInfo<'b>) + core::marker::Send + core::marker::Sync>;\n    let  _54: ();\n    let mut _55: (&panic::PanicHookInfo<'_>,);\n    let  _56: &panic::PanicHookInfo<'_>;\n    let  _57: panic::PanicHookInfo<'_>;\n    let  _58: &dyn core::any::Any + core::marker::Send;\n    let  _59: ();\n    let mut _60: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _61: isize;\n    let mut _62: sys::stdio::unix::Stderr;\n    let mut _63: core::result::Result<(), io::error::Error>;\n    let mut _64: &mut sys::stdio::unix::Stderr;\n    let mut _65: core::fmt::Arguments<'_>;\n    let  _66: !;\n    let mut _67: &&core::panic::Location<'_>;\n    let mut _68: &&str;\n    let mut _69: &&core::panic::Location<'_>;\n    let mut _70: &&mut dyn core::panic::PanicPayload;\n    debug payload => _1;\n    debug location => _2;\n    debug can_unwind => _3;\n    debug force_no_backtrace => _4;\n    debug must_abort => _5;\n    debug must_abort => _7;\n    debug message => _9;\n    debug out => sys::stdio::unix::Stderr;\n    debug args => _18;\n    debug args => _21;\n    debug out => sys::stdio::unix::Stderr;\n    debug args => _32;\n    debug args => _35;\n    debug hook => _53;\n    debug out => sys::stdio::unix::Stderr;\n    bb0: {\n        StorageLive(_5);\n        _5 = panicking::panic_count::increase(true) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = discriminant(_5);\n        switchInt(move _6) -> [1: bb2, 0: bb26, otherwise: bb3];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = move ((_5 as variant#1).0: panicking::panic_count::MustAbort);\n        _8 = discriminant(_7);\n        switchInt(move _8) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_26);\n        _26 = sys::stdio::unix::panic_output() -> [return: bb17, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = <dyn core::panic::PanicPayload as core::panic::PanicPayload>::as_str(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _10 = core::option::Option::<&str>::unwrap_or_default(move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = _10;\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_12);\n        _12 = sys::stdio::unix::panic_output() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _13 = discriminant(_12);\n        switchInt(move _13) -> [1: bb9, 0: bb15, otherwise: bb3];\n    }\n    bb9: {\n        StorageLive(_15);\n        _16 = &mut _14;\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_2;\n        StorageLive(_20);\n        _20 = &_9;\n        _18 = (move _19, move _20);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageLive(_21);\n        StorageLive(_22);\n        _67 = (_18.0: &&core::panic::Location<'_>);\n        _22 = core::fmt::rt::Argument::<'_>::new_display::<&core::panic::Location<'_>>(_67) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_23);\n        _68 = (_18.1: &&str);\n        _23 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_68) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _21 = [move _22, move _23];\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_24);\n        _24 = b\"\\x0cpanicked at \\xc0\\x02:\\n\\xc03\\nthread panicked while processing panic. aborting.\\n\\x00\";\n        _25 = &_21;\n        _17 = core::fmt::Arguments::<'_>::new::<71, 2>(move _24, _25) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        _15 = <sys::stdio::unix::Stderr as io::Write>::write_fmt(_16, move _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        drop(_15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_21);\n        StorageDead(_18);\n        StorageDead(_15);\n        StorageDead(_12);\n        goto -> bb16;\n    }\n    bb15: {\n        StorageDead(_12);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_9);\n        goto -> bb25;\n    }\n    bb17: {\n        _27 = discriminant(_26);\n        switchInt(move _27) -> [1: bb18, 0: bb24, otherwise: bb3];\n    }\n    bb18: {\n        StorageLive(_29);\n        _30 = &mut _28;\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_2;\n        StorageLive(_34);\n        _34 = &_1;\n        _32 = (move _33, move _34);\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageLive(_35);\n        StorageLive(_36);\n        _69 = (_32.0: &&core::panic::Location<'_>);\n        _36 = core::fmt::rt::Argument::<'_>::new_display::<&core::panic::Location<'_>>(_69) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageLive(_37);\n        _70 = (_32.1: &&mut dyn core::panic::PanicPayload);\n        _37 = core::fmt::rt::Argument::<'_>::new_display::<&mut dyn core::panic::PanicPayload>(_70) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _35 = [move _36, move _37];\n        StorageDead(_37);\n        StorageDead(_36);\n        StorageLive(_38);\n        _38 = b\"\\x19aborting due to panic at \\xc0\\x02:\\n\\xc0\\x01\\n\\x00\";\n        _39 = &_35;\n        _31 = core::fmt::Arguments::<'_>::new::<34, 2>(move _38, _39) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_38);\n        _29 = <sys::stdio::unix::Stderr as io::Write>::write_fmt(_30, move _31) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_31);\n        drop(_29) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_35);\n        StorageDead(_32);\n        StorageDead(_29);\n        StorageDead(_26);\n        goto -> bb25;\n    }\n    bb24: {\n        StorageDead(_26);\n        goto -> bb25;\n    }\n    bb25: {\n        _40 = process::abort() -> unwind unreachable;\n    }\n    bb26: {\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = {alloc632: &sync::nonpoison::rwlock::RwLock<panicking::Hook>};\n        _43 = sync::nonpoison::rwlock::RwLock::<panicking::Hook>::read(move _44) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _42 = &_43;\n        StorageDead(_44);\n        _41 = <sync::nonpoison::rwlock::RwLockReadGuard<'_, panicking::Hook> as core::ops::Deref>::deref(move _42) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_42);\n        _45 = discriminant((*_41));\n        switchInt(move _45) -> [0: bb30, 1: bb29, otherwise: bb3];\n    }\n    bb29: {\n        _53 = &(((*_41) as variant#1).0: alloc_crate::boxed::Box<dyn for<'a, 'b> core::ops::Fn(&'a panic::PanicHookInfo<'b>) + core::marker::Send + core::marker::Sync>);\n        StorageLive(_55);\n        StorageLive(_57);\n        _58 = <dyn core::panic::PanicPayload as core::panic::PanicPayload>::get(_1) -> [return: bb38, unwind unreachable];\n    }\n    bb30: {\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = sys::stdio::unix::panic_output() -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        _47 = &_48;\n        _46 = core::option::Option::<sys::stdio::unix::Stderr>::is_none(move _47) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        switchInt(move _46) -> [0: bb34, otherwise: bb33];\n    }\n    bb33: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageDead(_46);\n        goto -> bb41;\n    }\n    bb34: {\n        StorageDead(_48);\n        StorageDead(_47);\n        StorageDead(_46);\n        StorageLive(_51);\n        _52 = <dyn core::panic::PanicPayload as core::panic::PanicPayload>::get(_1) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _51 = panic::PanicHookInfo::<'_>::new(_2, _52, _3, _4) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        _50 = &_51;\n        _49 = panicking::default_hook(_50) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_51);\n        goto -> bb41;\n    }\n    bb38: {\n        _57 = panic::PanicHookInfo::<'_>::new(_2, _58, _3, _4) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _56 = &_57;\n        _55 = (_56);\n        _54 = <alloc_crate::boxed::Box<dyn for<'a, 'b> core::ops::Fn(&'a panic::PanicHookInfo<'b>) + core::marker::Send + core::marker::Sync> as core::ops::Fn<(&panic::PanicHookInfo<'_>,)>>::call(_53, move _55) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_55);\n        StorageDead(_57);\n        goto -> bb41;\n    }\n    bb41: {\n        drop(_43) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_43);\n        StorageDead(_41);\n        _59 = panicking::panic_count::finished_panic_hook() -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        switchInt(_3) -> [0: bb44, otherwise: bb52];\n    }\n    bb44: {\n        StorageLive(_60);\n        _60 = sys::stdio::unix::panic_output() -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        _61 = discriminant(_60);\n        switchInt(move _61) -> [1: bb46, 0: bb50, otherwise: bb3];\n    }\n    bb46: {\n        StorageLive(_63);\n        _64 = &mut _62;\n        StorageLive(_65);\n        _65 = core::fmt::Arguments::<'_>::from_str(\"thread caused non-unwinding panic. aborting.\\n\") -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _63 = <sys::stdio::unix::Stderr as io::Write>::write_fmt(_64, move _65) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_65);\n        drop(_63) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_63);\n        StorageDead(_60);\n        goto -> bb51;\n    }\n    bb50: {\n        StorageDead(_60);\n        goto -> bb51;\n    }\n    bb51: {\n        _66 = process::abort() -> unwind unreachable;\n    }\n    bb52: {\n        _0 = panicking::rust_panic(_1) -> unwind unreachable;\n    }\n}\n",
  "doc": " Central point for dispatching panics.\n\n Executes the primary logic for a panic, including checking for recursive\n panics, panic hooks, and finally dispatching to the panic runtime to either\n abort or unwind.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}