{
  "name": "fs::<impl io::Read for alloc_crate::sync::Arc<fs::File>>::read_to_end",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "io::Read::read_to_end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until EOF in this source, placing them into `buf`.\n\n All bytes read from this source will be appended to the specified buffer\n `buf`. This function will continuously call [`read()`] to append more data to\n `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n non-[`ErrorKind::Interrupted`] kind.\n\n If successful, this function will return the total number of bytes read.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If any other read error is encountered then this function immediately\n returns. Any bytes which have already been read will be appended to\n `buf`.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read()`]: Read::read\n [`Ok(0)`]: Ok\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = Vec::new();\n\n     // read the whole file\n     f.read_to_end(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read`] convenience function for reading from a\n file.)\n\n [`std::fs::read`]: crate::fs::read\n\n ## Implementing `read_to_end`\n\n When implementing the `io::Read` trait, it is recommended to allocate\n memory using [`Vec::try_reserve`]. However, this behavior is not guaranteed\n by all implementations, and `read_to_end` may not handle out-of-memory\n situations gracefully.\n\n ```no_run\n # use std::io::{self, BufRead};\n # struct Example { example_datasource: io::Empty } impl Example {\n # fn get_some_data_for_the_example(&self) -> &'static [u8] { &[] }\n fn read_to_end(&mut self, dest_vec: &mut Vec<u8>) -> io::Result<usize> {\n     let initial_vec_len = dest_vec.len();\n     loop {\n         let src_buf = self.example_datasource.fill_buf()?;\n         if src_buf.is_empty() {\n             break;\n         }\n         dest_vec.try_reserve(src_buf.len())?;\n         dest_vec.extend_from_slice(src_buf);\n\n         // Any irreversible side effects should happen after `try_reserve` succeeds,\n         // to avoid losing data on allocation error.\n         let read = src_buf.len();\n         self.example_datasource.consume(read);\n     }\n     Ok(dest_vec.len() - initial_vec_len)\n }\n # }\n ```\n\n # Usage Notes\n\n `read_to_end` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_end` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`Vec::try_reserve`]: crate::vec::Vec::try_reserve\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "alloc_crate::sync::Arc": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "fs::File": [
      "Ref"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1840,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:1521:5: 1523:6",
  "src": "fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        (&**self).read_to_end(buf)\n    }",
  "mir": "fn fs::<impl io::Read for alloc_crate::sync::Arc<fs::File>>::read_to_end(_1: &mut alloc_crate::sync::Arc<fs::File>, _2: &mut alloc_crate::vec::Vec<u8>) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: &mut &fs::File;\n    let mut _4: &fs::File;\n    let  _5: &fs::File;\n    let mut _6: &alloc_crate::sync::Arc<fs::File>;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = <alloc_crate::sync::Arc<fs::File> as core::ops::Deref>::deref(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _4 = _5;\n        _3 = &mut _4;\n        _0 = <&fs::File as io::Read>::read_to_end(move _3, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}