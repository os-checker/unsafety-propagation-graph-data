{
  "name": "sys::sync::once_box::OnceBox::<T>::take",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicPtr::<T>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the underlying pointer.\n\n This is safe because the mutable reference guarantees that no other threads are\n concurrently accessing the atomic data.\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicPtr, Ordering};\n\n let mut data = 10;\n let mut atomic_ptr = AtomicPtr::new(&mut data);\n let mut other_data = 5;\n *atomic_ptr.get_mut() = &mut other_data;\n assert_eq!(unsafe { *atomic_ptr.load(Ordering::SeqCst) }, 5);\n ```\n",
      "adt": {}
    },
    "core::ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "core::mem::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves `src` into the referenced `dest`, returning the previous `dest` value.\n\n Neither value is dropped.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a default value, see [`take`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n assert_eq!(vec![1, 2], old_v);\n assert_eq!(vec![3, 4, 5], v);\n ```\n\n `replace` allows consumption of a struct field by replacing it with another value.\n Without `replace` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let t = self.buf[i];\n         self.buf[i] = v;\n         t\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n avoid the move. But `replace` can be used to disassociate the original value at that index from\n `self`, allowing it to be returned:\n\n ```\n # #![allow(dead_code)]\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         mem::replace(&mut self.buf[i], v)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf[0], 0);\n\n assert_eq!(buffer.replace_index(0, 2), 0);\n assert_eq!(buffer.buf[0], 2);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "alloc_crate::boxed::Box::<T>::from_raw": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a box from a raw pointer.\n\n After calling this function, the raw pointer is owned by the\n resulting `Box`. Specifically, the `Box` destructor will call\n the destructor of `T` and free the allocated memory. For this\n to be safe, the memory must have been allocated in accordance\n with the [memory layout] used by `Box` .\n\n # Safety\n\n This function is unsafe because improper use may lead to\n memory problems. For example, a double-free may occur if the\n function is called twice on the same raw pointer.\n\n The raw pointer must point to a block of memory allocated by the global allocator.\n\n The safety conditions are described in the [memory layout] section.\n\n # Examples\n\n Recreate a `Box` which was previously converted to a raw pointer\n using [`Box::into_raw`]:\n ```\n let x = Box::new(5);\n let ptr = Box::into_raw(x);\n let x = unsafe { Box::from_raw(ptr) };\n ```\n Manually create a `Box` from scratch by using the global allocator:\n ```\n use std::alloc::{alloc, Layout};\n\n unsafe {\n     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n     // In general .write is required to avoid attempting to destruct\n     // the (uninitialized) previous contents of `ptr`, though for this\n     // simple example `*ptr = 5` would have worked as well.\n     ptr.write(5);\n     let x = Box::from_raw(ptr);\n }\n ```\n\n [memory layout]: self#memory-layout\n",
      "adt": {}
    },
    "core::pin::Pin::<Ptr>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Pin<Ptr>` around a reference to some data of a type that\n may or may not implement [`Unpin`].\n\n If `pointer` dereferences to an [`Unpin`] type, [`Pin::new`] should be used\n instead.\n\n # Safety\n\n This constructor is unsafe because we cannot guarantee that the data\n pointed to by `pointer` is pinned. At its core, pinning a value means making the\n guarantee that the value's data will not be moved nor have its storage invalidated until\n it gets dropped. For a more thorough explanation of pinning, see the [`pin` module docs].\n\n If the caller that is constructing this `Pin<Ptr>` does not ensure that the data `Ptr`\n points to is pinned, that is a violation of the API contract and may lead to undefined\n behavior in later (even safe) operations.\n\n By using this method, you are also making a promise about the [`Deref`],\n [`DerefMut`], and [`Drop`] implementations of `Ptr`, if they exist. Most importantly, they\n must not move out of their `self` arguments: `Pin::as_mut` and `Pin::as_ref`\n will call `DerefMut::deref_mut` and `Deref::deref` *on the pointer type `Ptr`*\n and expect these methods to uphold the pinning invariants.\n Moreover, by calling this method you promise that the reference `Ptr`\n dereferences to will not be moved out of again; in particular, it\n must not be possible to obtain a `&mut Ptr::Target` and then\n move out of that reference (using, for example [`mem::swap`]).\n\n For example, calling `Pin::new_unchecked` on an `&'a mut T` is unsafe because\n while you are able to pin it for the given lifetime `'a`, you have no control\n over whether it is kept pinned once `'a` ends, and therefore cannot uphold the\n guarantee that a value, once pinned, remains pinned until it is dropped:\n\n ```\n use std::mem;\n use std::pin::Pin;\n\n fn move_pinned_ref<T>(mut a: T, mut b: T) {\n     unsafe {\n         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n         // This should mean the pointee `a` can never move again.\n     }\n     mem::swap(&mut a, &mut b); // Potential UB down the road ⚠️\n     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n     // though we have previously pinned it! We have violated the pinning API contract.\n }\n ```\n A value, once pinned, must remain pinned until it is dropped (unless its type implements\n `Unpin`). Because `Pin<&mut T>` does not own the value, dropping the `Pin` will not drop\n the value and will not end the pinning contract. So moving the value after dropping the\n `Pin<&mut T>` is still a violation of the API contract.\n\n Similarly, calling `Pin::new_unchecked` on an `Rc<T>` is unsafe because there could be\n aliases to the same data that are not subject to the pinning restrictions:\n ```\n use std::rc::Rc;\n use std::pin::Pin;\n\n fn move_pinned_rc<T>(mut x: Rc<T>) {\n     // This should mean the pointee can never move again.\n     let pin = unsafe { Pin::new_unchecked(Rc::clone(&x)) };\n     {\n         let p: Pin<&T> = pin.as_ref();\n         // ...\n     }\n     drop(pin);\n\n     let content = Rc::get_mut(&mut x).unwrap(); // Potential UB down the road ⚠️\n     // Now, if `x` was the only reference, we have a mutable reference to\n     // data that we pinned above, which we could use to move it as we have\n     // seen in the previous example. We have violated the pinning API contract.\n }\n ```\n\n ## Pinning of closure captures\n\n Particular care is required when using `Pin::new_unchecked` in a closure:\n `Pin::new_unchecked(&mut var)` where `var` is a by-value (moved) closure capture\n implicitly makes the promise that the closure itself is pinned, and that *all* uses\n of this closure capture respect that pinning.\n ```\n use std::pin::Pin;\n use std::task::Context;\n use std::future::Future;\n\n fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n     // Create a closure that moves `x`, and then internally uses it in a pinned way.\n     let mut closure = move || unsafe {\n         let _ignore = Pin::new_unchecked(&mut x).poll(cx);\n     };\n     // Call the closure, so the future can assume it has been pinned.\n     closure();\n     // Move the closure somewhere else. This also moves `x`!\n     let mut moved = closure;\n     // Calling it again means we polled the future from two different locations,\n     // violating the pinning API contract.\n     moved(); // Potential UB ⚠️\n }\n ```\n When passing a closure to another API, it might be moving the closure any time, so\n `Pin::new_unchecked` on closure captures may only be used if the API explicitly documents\n that the closure is pinned.\n\n The better alternative is to avoid all that trouble and do the pinning in the outer function\n instead (here using the [`pin!`][crate::pin::pin] macro):\n ```\n use std::pin::pin;\n use std::task::Context;\n use std::future::Future;\n\n fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n     let mut x = pin!(x);\n     // Create a closure that captures `x: Pin<&mut _>`, which is safe to move.\n     let mut closure = move || {\n         let _ignore = x.as_mut().poll(cx);\n     };\n     // Call the closure, so the future can assume it has been pinned.\n     closure();\n     // Move the closure somewhere else.\n     let mut moved = closure;\n     // Calling it again here is fine (except that we might be polling a future that already\n     // returned `Poll::Ready`, but that is a separate problem).\n     moved();\n }\n ```\n\n [`mem::swap`]: crate::mem::swap\n [`pin` module docs]: self\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicPtr": [
      "MutRef"
    ],
    "sys::sync::once_box::OnceBox": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc_crate::boxed::Box": [
      "Plain"
    ],
    "core::pin::Pin": [
      "Plain"
    ]
  },
  "path": 4304,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/once_box.rs:56:5: 59:6",
  "src": "pub fn take(&mut self) -> Option<Pin<Box<T>>> {\n        let ptr = replace(self.ptr.get_mut(), null_mut());\n        if !ptr.is_null() { Some(unsafe { Pin::new_unchecked(Box::from_raw(ptr)) }) } else { None }\n    }",
  "mir": "fn sys::sync::once_box::OnceBox::<T>::take(_1: &mut sys::sync::once_box::OnceBox<T>) -> core::option::Option<core::pin::Pin<alloc_crate::boxed::Box<T>>> {\n    let mut _0: core::option::Option<core::pin::Pin<alloc_crate::boxed::Box<T>>>;\n    let  _2: *mut T;\n    let mut _3: &mut *mut T;\n    let mut _4: &mut core::sync::atomic::AtomicPtr<T>;\n    let mut _5: *mut T;\n    let mut _6: bool;\n    let mut _7: core::pin::Pin<alloc_crate::boxed::Box<T>>;\n    let mut _8: alloc_crate::boxed::Box<T>;\n    debug self => _1;\n    debug ptr => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: core::sync::atomic::AtomicPtr<T>);\n        _3 = core::sync::atomic::AtomicPtr::<T>::get_mut(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = core::ptr::null_mut::<T>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _2 = core::mem::replace::<*mut T>(_3, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = core::ptr::mut_ptr::<impl *mut T>::is_null(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _6) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        _0 = core::option::Option::None;\n        goto -> bb9;\n    }\n    bb6: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = alloc_crate::boxed::Box::<T>::from_raw(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _7 = core::pin::Pin::<alloc_crate::boxed::Box<T>>::new_unchecked(move _8) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        _0 = core::option::Option::Some(move _7);\n        StorageDead(_7);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_6);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}