{
  "name": "io::stdio::Stdin::lock",
  "safe": true,
  "callees": {
    "sync::poison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Errors\n\n If another user of this mutex panicked while holding the mutex, then\n this call will return an error once the mutex is acquired. The acquired\n mutex guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock().unwrap() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock().unwrap(), 10);\n ```\n",
      "adt": {
        "sync::poison::mutex::Mutex": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::poison::mutex::Mutex": [
      "Ref"
    ],
    "io::stdio::Stdin": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "sync::poison::mutex::MutexGuard": [
      "Plain"
    ],
    "io::stdio::StdinLock": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::stdio::Stdin::lock"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:372:5: 376:6",
  "src": "pub fn lock(&self) -> StdinLock<'static> {\n        // Locks this handle with 'static lifetime. This depends on the\n        // implementation detail that the underlying `Mutex` is static.\n        StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n    }",
  "mir": "fn io::stdio::Stdin::lock(_1: &io::stdio::Stdin) -> io::stdio::StdinLock<'_> {\n    let mut _0: io::stdio::StdinLock<'_>;\n    let mut _2: sync::poison::mutex::MutexGuard<'_, io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>;\n    let mut _3: core::result::Result<sync::poison::mutex::MutexGuard<'_, io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>>>;\n    let mut _4: &sync::poison::mutex::Mutex<io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _4 = ((*_1).0: &sync::poison::mutex::Mutex<io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>);\n        _3 = sync::poison::mutex::Mutex::<io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>::lock(_4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::result::Result::<sync::poison::mutex::MutexGuard<'_, io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, io::buffered::bufreader::BufReader<io::stdio::StdinRaw>>>>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:375:61: 375:64}>(move _3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:375:61: 375:64}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = StdinLock(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Locks this handle to the standard input stream, returning a readable\n guard.\n\n The lock is released when the returned lock goes out of scope. The\n returned guard also implements the [`Read`] and [`BufRead`] traits for\n accessing the underlying data.\n\n # Examples\n\n ```no_run\n use std::io::{self, BufRead};\n\n fn main() -> io::Result<()> {\n     let mut buffer = String::new();\n     let stdin = io::stdin();\n     let mut handle = stdin.lock();\n\n     handle.read_line(&mut buffer)?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}