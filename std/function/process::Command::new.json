{
  "name": "process::Command::new",
  "safe": true,
  "callees": {
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument",
        "sys::process::unix::common::Command": "Constructor"
      }
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "sys::process::unix::common::Command": [
      "Plain"
    ],
    "process::Command": [
      "Plain"
    ]
  },
  "path": 2636,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/process.rs:666:5: 668:6",
  "src": "pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n        Command { inner: imp::Command::new(program.as_ref()) }\n    }",
  "mir": "fn process::Command::new(_1: S) -> process::Command {\n    let mut _0: process::Command;\n    let mut _2: sys::process::unix::common::Command;\n    let  _3: &ffi::os_str::OsStr;\n    let mut _4: &S;\n    debug program => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = <S as core::convert::AsRef<ffi::os_str::OsStr>>::as_ref(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = sys::process::unix::common::Command::new(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = Command(move _2);\n        StorageDead(_2);\n        drop(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        return;\n    }\n}\n",
  "doc": " Constructs a new `Command` for launching the program at\n path `program`, with the following default configuration:\n\n * No arguments to the program\n * Inherit the current process's environment\n * Inherit the current process's working directory\n * Inherit stdin/stdout/stderr for [`spawn`] or [`status`], but create pipes for [`output`]\n\n [`spawn`]: Self::spawn\n [`status`]: Self::status\n [`output`]: Self::output\n\n Builder methods are provided to change these defaults and\n otherwise configure the process.\n\n If `program` is not an absolute path, the `PATH` will be searched in\n an OS-defined way.\n\n The search path to be used may be controlled by setting the\n `PATH` environment variable on the Command,\n but this has some implementation limitations on Windows\n (see issue #37519).\n\n # Platform-specific behavior\n\n Note on Windows: For executable files with the .exe extension,\n it can be omitted when specifying the program for this Command.\n However, if the file has a different extension,\n a filename including the extension needs to be provided,\n otherwise the file won't be found.\n\n # Examples\n\n ```no_run\n use std::process::Command;\n\n Command::new(\"sh\")\n     .spawn()\n     .expect(\"sh command failed to start\");\n ```\n\n # Caveats\n\n [`Command::new`] is only intended to accept the path of the program. If you pass a program\n path along with arguments like `Command::new(\"ls -l\").spawn()`, it will try to search for\n `ls -l` literally. The arguments need to be passed separately, such as via [`arg`] or\n [`args`].\n\n ```no_run\n use std::process::Command;\n\n Command::new(\"ls\")\n     .arg(\"-l\") // arg passed separately\n     .spawn()\n     .expect(\"ls command failed to start\");\n ```\n\n [`arg`]: Self::arg\n [`args`]: Self::args\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}