{
  "name": "process::Stdio::piped",
  "safe": true,
  "callees": {},
  "adts": {
    "sys::process::unix::common::Stdio": [
      "Plain"
    ],
    "process::Stdio": [
      "Plain"
    ]
  },
  "path": 2714,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/process.rs:1481:5: 1483:6",
  "src": "pub fn piped() -> Stdio {\n        Stdio(imp::Stdio::MakePipe)\n    }",
  "mir": "fn process::Stdio::piped() -> process::Stdio {\n    let mut _0: process::Stdio;\n    let mut _1: sys::process::unix::common::Stdio;\n    bb0: {\n        StorageLive(_1);\n        _1 = sys::process::unix::common::Stdio::MakePipe;\n        _0 = Stdio(move _1);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " A new pipe should be arranged to connect the parent and child processes.\n\n # Examples\n\n With stdout:\n\n ```no_run\n use std::process::{Command, Stdio};\n\n let output = Command::new(\"echo\")\n     .arg(\"Hello, world!\")\n     .stdout(Stdio::piped())\n     .output()\n     .expect(\"Failed to execute command\");\n\n assert_eq!(String::from_utf8_lossy(&output.stdout), \"Hello, world!\\n\");\n // Nothing echoed to console\n ```\n\n With stdin:\n\n ```no_run\n use std::io::Write;\n use std::process::{Command, Stdio};\n\n let mut child = Command::new(\"rev\")\n     .stdin(Stdio::piped())\n     .stdout(Stdio::piped())\n     .spawn()\n     .expect(\"Failed to spawn child process\");\n\n let mut stdin = child.stdin.take().expect(\"Failed to open stdin\");\n std::thread::spawn(move || {\n     stdin.write_all(\"Hello, world!\".as_bytes()).expect(\"Failed to write to stdin\");\n });\n\n let output = child.wait_with_output().expect(\"Failed to read stdout\");\n assert_eq!(String::from_utf8_lossy(&output.stdout), \"!dlrow ,olleH\");\n ```\n\n Writing more than a pipe buffer's worth of input to stdin without also reading\n stdout and stderr at the same time may cause a deadlock.\n This is an issue when running any program that doesn't guarantee that it reads\n its entire stdin before writing more than a pipe buffer's worth of output.\n The size of a pipe buffer varies on different targets.\n\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}