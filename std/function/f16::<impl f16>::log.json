{
  "name": "f16::<impl f16>::log",
  "safe": true,
  "callees": {
    "f16::<impl f16>::ln": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the natural logarithm of the number.\n\n This returns NaN when the number is negative, and negative infinity when number is zero.\n\n # Unspecified precision\n\n The precision of this function is non-deterministic. This means it varies by platform,\n Rust version, and can even differ within the same execution from one invocation to the next.\n\n # Examples\n\n ```\n #![feature(f16)]\n # #[cfg(not(miri))]\n # #[cfg(target_has_reliable_f16_math)] {\n\n let one = 1.0f16;\n // e^1\n let e = one.exp();\n\n // ln(e) - 1 == 0\n let abs_difference = (e.ln() - 1.0).abs();\n\n assert!(abs_difference <= f16::EPSILON);\n # }\n ```\n\n Non-positive values:\n ```\n #![feature(f16)]\n # #[cfg(not(miri))]\n # #[cfg(target_has_reliable_f16_math)] {\n\n assert_eq!(0_f16.ln(), f16::NEG_INFINITY);\n assert!((-42_f16).ln().is_nan());\n # }\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": 269,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/num/f16.rs:206:5: 208:6",
  "src": "pub fn log(self, base: f16) -> f16 {\n        self.ln() / base.ln()\n    }",
  "mir": "fn f16::<impl f16>::log(_1: f16, _2: f16) -> f16 {\n    let mut _0: f16;\n    let mut _3: f16;\n    let mut _4: f16;\n    debug self => _1;\n    debug base => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = f16::<impl f16>::ln(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = f16::<impl f16>::ln(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = Div(move _3, move _4);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns the logarithm of the number with respect to an arbitrary base.\n\n This returns NaN when the number is negative, and negative infinity when number is zero.\n\n The result might not be correctly rounded owing to implementation details;\n `self.log2()` can produce more accurate results for base 2, and\n `self.log10()` can produce more accurate results for base 10.\n\n # Unspecified precision\n\n The precision of this function is non-deterministic. This means it varies by platform,\n Rust version, and can even differ within the same execution from one invocation to the next.\n\n # Examples\n\n ```\n #![feature(f16)]\n # #[cfg(not(miri))]\n # #[cfg(target_has_reliable_f16_math)] {\n\n let five = 5.0f16;\n\n // log5(5) - 1 == 0\n let abs_difference = (five.log(5.0) - 1.0).abs();\n\n assert!(abs_difference <= f16::EPSILON);\n # }\n ```\n\n Non-positive values:\n ```\n #![feature(f16)]\n # #[cfg(not(miri))]\n # #[cfg(target_has_reliable_f16_math)] {\n\n assert_eq!(0_f16.log(10.0), f16::NEG_INFINITY);\n assert!((-42_f16).log(10.0).is_nan());\n # }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}