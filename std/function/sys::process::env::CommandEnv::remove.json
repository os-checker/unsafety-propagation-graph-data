{
  "name": "sys::process::env::CommandEnv::remove",
  "safe": true,
  "callees": {
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "sys::process::env::CommandEnv::maybe_saw_path": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ffi::os_str::OsString": "ImmutableAsArgument",
        "sys::process::env::CommandEnv": "MutableAsArgument"
      }
    },
    "alloc_crate::collections::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::BTreeMap::<K, V, A>::insert": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a key-value pair into the map.\n\n If the map did not have this key present, `None` is returned.\n\n If the map did have this key present, the value is updated, and the old\n value is returned. The key is not updated, though; this matters for\n types that can be `==` without being identical. See the [module-level\n documentation] for more.\n\n [module-level documentation]: index.html#insert-and-complex-keys\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n assert_eq!(map.insert(37, \"a\"), None);\n assert_eq!(map.is_empty(), false);\n\n map.insert(37, \"b\");\n assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n assert_eq!(map[&37], \"c\");\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "ffi::os_str::OsString": [
      "Plain",
      "Ref"
    ],
    "sys::process::env::CommandEnv": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "alloc_crate::collections::BTreeMap": [
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 4089,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/env.rs:56:5: 64:6",
  "src": "pub fn remove(&mut self, key: &OsStr) {\n        let key = EnvKey::from(key);\n        self.maybe_saw_path(&key);\n        if self.clear {\n            self.vars.remove(&key);\n        } else {\n            self.vars.insert(key, None);\n        }\n    }",
  "mir": "fn sys::process::env::CommandEnv::remove(_1: &mut sys::process::env::CommandEnv, _2: &ffi::os_str::OsStr) -> () {\n    let mut _0: ();\n    let  _3: ffi::os_str::OsString;\n    let  _4: ();\n    let  _5: &ffi::os_str::OsString;\n    let mut _6: bool;\n    let  _7: core::option::Option<core::option::Option<ffi::os_str::OsString>>;\n    let mut _8: &mut alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>;\n    let  _9: &ffi::os_str::OsString;\n    let  _10: core::option::Option<core::option::Option<ffi::os_str::OsString>>;\n    let mut _11: &mut alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>;\n    let mut _12: ffi::os_str::OsString;\n    let mut _13: core::option::Option<ffi::os_str::OsString>;\n    let mut _14: bool;\n    debug self => _1;\n    debug key => _2;\n    debug key => _3;\n    bb0: {\n        _14 = false;\n        StorageLive(_3);\n        _3 = <ffi::os_str::OsString as core::convert::From<&ffi::os_str::OsStr>>::from(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _14 = true;\n        _5 = &_3;\n        _4 = sys::process::env::CommandEnv::maybe_saw_path(_1, _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_6);\n        _6 = ((*_1).0: bool);\n        switchInt(move _6) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &mut ((*_1).2: alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>);\n        _9 = &_3;\n        _7 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>::remove::<ffi::os_str::OsString>(move _8, _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        drop(_7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        goto -> bb9;\n    }\n    bb6: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &mut ((*_1).2: alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>);\n        StorageLive(_12);\n        _14 = false;\n        _12 = move _3;\n        StorageLive(_13);\n        _13 = core::option::Option::None;\n        _10 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>::insert(move _11, move _12, move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        drop(_10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_6);\n        switchInt(_14) -> [0: bb10, otherwise: bb11];\n    }\n    bb10: {\n        _14 = false;\n        StorageDead(_3);\n        return;\n    }\n    bb11: {\n        drop(_3) -> [return: bb10, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}