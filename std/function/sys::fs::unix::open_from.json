{
  "name": "sys::fs::unix::open_from",
  "safe": true,
  "callees": {
    "fs::File::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode.\n\n See the [`OpenOptions::open`] method for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Read;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut data = vec![];\n     f.read_to_end(&mut data)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fs::File::metadata": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Queries metadata about the underlying file.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let metadata = f.metadata()?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument",
        "fs::Metadata": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "fs::Metadata::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this metadata is for a regular file. The\n result is mutually exclusive to the result of\n [`Metadata::is_dir`], and will be false for symlink metadata\n obtained from [`symlink_metadata`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`File::open`] or\n [`OpenOptions::open`] for more information.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert!(metadata.is_file());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3692, kind: RigidTy(Adt(AdtDef(DefId { id: 6032, name: \"fs::Metadata\" }), GenericArgs([]))) })])"
    ],
    "fs::File": [
      "Plain",
      "Ref"
    ],
    "fs::Metadata": [
      "Plain",
      "Ref"
    ]
  },
  "path": 3471,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:2127:1: 2137:2",
  "src": "fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n    use crate::fs::File;\n    use crate::sys::fs::common::NOT_FILE_ERROR;\n\n    let reader = File::open(from)?;\n    let metadata = reader.metadata()?;\n    if !metadata.is_file() {\n        return Err(NOT_FILE_ERROR);\n    }\n    Ok((reader, metadata))\n}",
  "mir": "fn sys::fs::unix::open_from(_1: &path::Path) -> core::result::Result<(fs::File, fs::Metadata), io::error::Error> {\n    let mut _0: core::result::Result<(fs::File, fs::Metadata), io::error::Error>;\n    let  _2: fs::File;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _4: core::result::Result<fs::File, io::error::Error>;\n    let mut _5: isize;\n    let  _6: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _7: fs::File;\n    let  _8: fs::Metadata;\n    let mut _9: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::Metadata>;\n    let mut _10: core::result::Result<fs::Metadata, io::error::Error>;\n    let mut _11: &fs::File;\n    let mut _12: isize;\n    let  _13: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _14: fs::Metadata;\n    let mut _15: bool;\n    let mut _16: &fs::Metadata;\n    let mut _17: (fs::File, fs::Metadata);\n    let mut _18: fs::File;\n    debug from => _1;\n    debug reader => _2;\n    debug residual => _6;\n    debug val => _7;\n    debug metadata => _8;\n    debug residual => _13;\n    debug val => _14;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = fs::File::open::<&path::Path>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = move ((_3 as variant#0).0: fs::File);\n        _2 = move _7;\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_2;\n        _10 = fs::File::metadata(move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _6 = move ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(fs::File, fs::Metadata), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        goto -> bb16;\n    }\n    bb7: {\n        StorageDead(_11);\n        _9 = <core::result::Result<fs::Metadata, io::error::Error> as core::ops::Try>::branch(move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        _12 = discriminant(_9);\n        switchInt(move _12) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        StorageLive(_14);\n        _14 = move ((_9 as variant#0).0: fs::Metadata);\n        _8 = move _14;\n        StorageDead(_14);\n        StorageDead(_9);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_8;\n        _15 = fs::Metadata::is_file(move _16) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _13 = move ((_9 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(fs::File, fs::Metadata), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_13) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_9);\n        goto -> bb15;\n    }\n    bb12: {\n        switchInt(move _15) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = move _2;\n        _17 = (move _18, _8);\n        StorageDead(_18);\n        _0 = core::result::Result::Ok(move _17);\n        StorageDead(_17);\n        StorageDead(_2);\n        goto -> bb17;\n    }\n    bb14: {\n        StorageDead(_16);\n        _0 = core::result::Result::Err(sys::fs::common::NOT_FILE_ERROR);\n        StorageDead(_15);\n        goto -> bb15;\n    }\n    bb15: {\n        drop(_2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_2);\n        goto -> bb17;\n    }\n    bb17: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}