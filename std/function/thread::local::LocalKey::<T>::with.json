{
  "name": "thread::local::LocalKey::<T>::with",
  "safe": true,
  "callees": {
    "thread::local::LocalKey::<T>::try_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a reference to the value in this TLS key.\n\n This will lazily initialize the value if this thread has not referenced\n this key yet. If the key has been destroyed (which may happen if this is called\n in a destructor), this function will return an [`AccessError`].\n\n # Panics\n\n This function will still `panic!()` if the key is uninitialized and the\n key's initializer panics.\n\n # Examples\n\n ```\n thread_local! {\n     pub static STATIC: String = String::from(\"I am\");\n }\n\n assert_eq!(\n     STATIC.try_with(|original_value| format!(\"{original_value} initialized\")),\n     Ok(String::from(\"I am initialized\")),\n );\n ```\n",
      "adt": {
        "thread::local::LocalKey": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "thread::local::panic_access_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "thread::local::LocalKey": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 409, kind: Param(ParamTy { index: 2, name: \"R\" }) })])"
    ]
  },
  "path": 4527,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:473:5: 481:6",
  "src": "pub fn with<F, R>(&'static self, f: F) -> R\n    where\n        F: FnOnce(&T) -> R,\n    {\n        match self.try_with(f) {\n            Ok(r) => r,\n            Err(err) => panic_access_error(err),\n        }\n    }",
  "mir": "fn thread::local::LocalKey::<T>::with(_1: &thread::local::LocalKey<T>, _2: F) -> R {\n    let mut _0: R;\n    let mut _3: core::result::Result<R, thread::local::AccessError>;\n    let mut _4: isize;\n    let mut _5: !;\n    debug self => _1;\n    debug f => _2;\n    debug r => _0;\n    debug err => thread::local::AccessError;\n    bb0: {\n        StorageLive(_3);\n        _3 = thread::local::LocalKey::<T>::try_with::<F, R>(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = discriminant(_3);\n        switchInt(move _4) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _5 = thread::local::panic_access_error(thread::local::AccessError) -> unwind unreachable;\n    }\n    bb4: {\n        _0 = move ((_3 as variant#0).0: R);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Acquires a reference to the value in this TLS key.\n\n This will lazily initialize the value if this thread has not referenced\n this key yet.\n\n # Panics\n\n This function will `panic!()` if the key currently has its\n destructor running, and it **may** panic if the destructor has\n previously been run for this thread.\n\n # Examples\n\n ```\n thread_local! {\n     pub static STATIC: String = String::from(\"I am\");\n }\n\n assert_eq!(\n     STATIC.with(|original_value| format!(\"{original_value} initialized\")),\n     \"I am initialized\",\n );\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}