{
  "name": "io::buffered::linewritershim::LineWriterShim::<'a, W>::flush_if_completed_line",
  "safe": true,
  "callees": {
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::buffered": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the content currently buffered in self.buffer\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::last": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the last element of the slice, or `None` if it is empty.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert_eq!(Some(&30), v.last());\n\n let w: &[i32] = &[];\n assert_eq!(None, w.last());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<&T>::copied": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n option.\n\n # Examples\n\n ```\n let x = 12;\n let opt_x = Some(&x);\n assert_eq!(opt_x, Some(&12));\n let copied = opt_x.copied();\n assert_eq!(copied, Some(12));\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "io::buffered::linewritershim::LineWriterShim": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 35, kind: RigidTy(Uint(U8)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "io::buffered::bufwriter::BufWriter": [
      "MutRef"
    ]
  },
  "path": 1386,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:46:5: 51:6",
  "src": "fn flush_if_completed_line(&mut self) -> io::Result<()> {\n        match self.buffered().last().copied() {\n            Some(b'\\n') => self.buffer.flush_buf(),\n            _ => Ok(()),\n        }\n    }",
  "mir": "fn io::buffered::linewritershim::LineWriterShim::<'a, W>::flush_if_completed_line(_1: &mut io::buffered::linewritershim::LineWriterShim<'_, W>) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _2: core::option::Option<u8>;\n    let mut _3: core::option::Option<&u8>;\n    let  _4: &[u8];\n    let mut _5: &io::buffered::linewritershim::LineWriterShim<'_, W>;\n    let mut _6: isize;\n    let mut _7: &mut io::buffered::bufwriter::BufWriter<W>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = io::buffered::linewritershim::LineWriterShim::<'_, W>::buffered(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = core::slice::<impl [u8]>::last(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _2 = core::option::Option::<&u8>::copied(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        _6 = discriminant(_2);\n        switchInt(move _6) -> [1: bb5, 0: bb4, otherwise: bb9];\n    }\n    bb4: {\n        _0 = core::result::Result::Ok(());\n        goto -> bb8;\n    }\n    bb5: {\n        switchInt(((_2 as variant#1).0: u8)) -> [10: bb6, otherwise: bb4];\n    }\n    bb6: {\n        _7 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _0 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_2);\n        return;\n    }\n    bb9: {\n        unreachable;\n    }\n}\n",
  "doc": " Flushes the buffer iff the last byte is a newline (indicating that an\n earlier write only succeeded partially, and we want to retry flushing\n the buffered line before continuing with a subsequent write).\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}