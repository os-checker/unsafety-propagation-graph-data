{
  "name": "sys::pal::unix::os::home_dir::fallback",
  "safe": false,
  "callees": {
    "libc::sysconf": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {}
    },
    "core::ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "libc::getuid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<Vec<u32>>`.\n // This is okay because we initialized it.\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n x_vec.push(3);\n assert_eq!(x_vec.len(), 4);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {}
    },
    "libc::getpwuid_r": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::ffi::CStr::to_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice.\n\n The returned slice will **not** contain the trailing nul terminator that this C\n string has.\n\n > **Note**: This method is currently implemented as a constant-time\n > cast, but it is planned to alter its definition in the future to\n > perform the length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes(), b\"foo\");\n ```\n",
      "adt": {}
    },
    "alloc_crate::slice::<impl [T]>::to_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `self` into a new `Vec`.\n\n # Examples\n\n ```\n let s = [10, 40, 30];\n let x = s.to_vec();\n // Here, `s` and `x` can be modified independently.\n ```\n",
      "adt": {}
    },
    "os::unix::ffi::os_str::OsStringExt::from_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an [`OsString`] from a byte vector.\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::mem::MaybeUninit": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ]
  },
  "path": 3915,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/os.rs:641:5: 663:6",
  "src": "unsafe fn fallback() -> Option<OsString> {\n        let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {\n            n if n < 0 => 512 as usize,\n            n => n as usize,\n        };\n        let mut buf = Vec::with_capacity(amt);\n        let mut p = mem::MaybeUninit::<libc::passwd>::uninit();\n        let mut result = ptr::null_mut();\n        match libc::getpwuid_r(\n            libc::getuid(),\n            p.as_mut_ptr(),\n            buf.as_mut_ptr(),\n            buf.capacity(),\n            &mut result,\n        ) {\n            0 if !result.is_null() => {\n                let ptr = (*result).pw_dir as *const _;\n                let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n                Some(OsStringExt::from_vec(bytes))\n            }\n            _ => None,\n        }\n    }",
  "mir": "fn sys::pal::unix::os::home_dir::fallback() -> core::option::Option<ffi::os_str::OsString> {\n    let mut _0: core::option::Option<ffi::os_str::OsString>;\n    let  _1: usize;\n    let mut _2: i64;\n    let  _3: &i64;\n    let mut _4: bool;\n    let mut _5: i64;\n    let mut _6: alloc_crate::vec::Vec<u8>;\n    let mut _7: usize;\n    let mut _8: core::mem::MaybeUninit<libc::passwd>;\n    let mut _9: *mut libc::passwd;\n    let mut _10: i32;\n    let mut _11: u32;\n    let mut _12: *mut libc::passwd;\n    let mut _13: &mut core::mem::MaybeUninit<libc::passwd>;\n    let mut _14: *mut u8;\n    let mut _15: &mut alloc_crate::vec::Vec<u8>;\n    let mut _16: usize;\n    let mut _17: &alloc_crate::vec::Vec<u8>;\n    let mut _18: *mut *mut libc::passwd;\n    let mut _19: &mut *mut libc::passwd;\n    let mut _20: bool;\n    let mut _21: *mut libc::passwd;\n    let mut _22: *const u8;\n    let mut _23: *mut u8;\n    let  _24: alloc_crate::vec::Vec<u8>;\n    let  _25: &[u8];\n    let  _26: &core::ffi::CStr;\n    let mut _27: ffi::os_str::OsString;\n    let mut _28: *const ();\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: usize;\n    let mut _32: bool;\n    let mut _33: *const ();\n    let mut _34: usize;\n    let mut _35: bool;\n    let mut _36: bool;\n    let mut _37: bool;\n    let mut _38: bool;\n    debug amt => _1;\n    debug n => _2;\n    debug n => _3;\n    debug n => _2;\n    debug buf => _6;\n    debug p => _8;\n    debug result => _9;\n    debug ptr => _22;\n    debug bytes => _24;\n    bb0: {\n        StorageLive(_1);\n        _2 = libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = &_2;\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = (*_3);\n        _4 = Lt(move _5, 0_i64);\n        switchInt(move _4) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _1 = 512_usize;\n        StorageDead(_3);\n        goto -> bb4;\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        _1 = _2 as usize;\n        goto -> bb4;\n    }\n    bb4: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _1;\n        _6 = alloc_crate::vec::Vec::<u8>::with_capacity(move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageLive(_8);\n        _8 = core::mem::MaybeUninit::<libc::passwd>::uninit() -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_9);\n        _9 = core::ptr::null_mut::<libc::passwd>() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = libc::getuid() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut _8;\n        _12 = core::mem::MaybeUninit::<libc::passwd>::as_mut_ptr(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _6;\n        _14 = alloc_crate::vec::Vec::<u8>::as_mut_ptr(move _15) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_6;\n        _16 = alloc_crate::vec::Vec::<u8>::capacity(move _17) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _9;\n        _18 = &raw mut (*_19);\n        _10 = libc::getpwuid_r(move _11, move _12, move _14, move _16, move _18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_18);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_11);\n        switchInt(_10) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        _0 = core::option::Option::None;\n        goto -> bb22;\n    }\n    bb14: {\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = _9;\n        _20 = core::ptr::mut_ptr::<impl *mut libc::passwd>::is_null(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _20) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb13;\n    }\n    bb17: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_23);\n        _28 = _9 as *const ();\n        _29 = _28 as usize;\n        _30 = Sub(<libc::passwd as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _31 = BitAnd(_29, _30);\n        _32 = Eq(_31, 0_usize);\n        assert(_32, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::passwd as core::mem::SizedTypeProperties>::ALIGN, _29) -> [success: bb24, unwind unreachable];\n    }\n    bb18: {\n        _25 = core::ffi::CStr::to_bytes(_26) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _24 = alloc_crate::slice::<impl [u8]>::to_vec(_25) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageLive(_27);\n        _27 = <ffi::os_str::OsString as os::unix::ffi::os_str::OsStringExt>::from_vec(_24) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _0 = core::option::Option::Some(move _27);\n        StorageDead(_27);\n        goto -> bb22;\n    }\n    bb22: {\n        StorageDead(_19);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_8);\n        drop(_6) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_6);\n        StorageDead(_1);\n        return;\n    }\n    bb24: {\n        _33 = _9 as *const ();\n        _34 = _33 as usize;\n        _35 = Ne(<libc::passwd as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _36 = Eq(_34, 0_usize);\n        _37 = BitAnd(_36, _35);\n        _38 = Not(_37);\n        assert(_38, \"null pointer dereference occurred\") -> [success: bb25, unwind unreachable];\n    }\n    bb25: {\n        _23 = ((*_9).5: *mut u8);\n        _22 = move _23 as *const u8;\n        StorageDead(_23);\n        _26 = core::ffi::CStr::from_ptr::<'_>(_22) -> [return: bb18, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}