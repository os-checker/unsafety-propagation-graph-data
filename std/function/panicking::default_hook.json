{
  "name": "panicking::default_hook",
  "safe": true,
  "callees": {
    "panic::PanicHookInfo::<'a>::force_no_backtrace": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": "",
      "adt": {
        "panic::PanicHookInfo": "ImmutableAsArgument"
      }
    },
    "panicking::panic_count::get_count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "panic::BacktraceStyle::full": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "panic::get_backtrace_style": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the standard library's panic hook will capture and print a\n backtrace.\n\n This function will, if a backtrace style has not been set via\n [`set_backtrace_style`], read the environment variable `RUST_BACKTRACE` to\n determine a default value for the backtrace formatting:\n\n The first call to `get_backtrace_style` may read the `RUST_BACKTRACE`\n environment variable if `set_backtrace_style` has not been called to\n override the default value. After a call to `set_backtrace_style` or\n `get_backtrace_style`, any changes to `RUST_BACKTRACE` will have no effect.\n\n `RUST_BACKTRACE` is read according to these rules:\n\n * `0` for `BacktraceStyle::Off`\n * `full` for `BacktraceStyle::Full`\n * `1` for `BacktraceStyle::Short`\n * Other values are currently `BacktraceStyle::Short`, but this may change in\n   the future\n\n Returns `None` if backtraces aren't currently supported.\n",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "panic::PanicHookInfo::<'a>::location": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns information about the location from which the panic originated,\n if available.\n\n This method will currently always return [`Some`], but this may change\n in future versions.\n\n # Examples\n\n ```should_panic\n use std::panic;\n\n panic::set_hook(Box::new(|panic_info| {\n     if let Some(location) = panic_info.location() {\n         println!(\"panic occurred in file '{}' at line {}\",\n             location.file(),\n             location.line(),\n         );\n     } else {\n         println!(\"panic occurred but can't get location information...\");\n     }\n }));\n\n panic!(\"Normal panic\");\n ```\n",
      "adt": {
        "panic::PanicHookInfo": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "panic::PanicHookInfo::<'a>::payload": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the payload associated with the panic.\n\n This will commonly, but not always, be a `&'static str` or [`String`].\n If you only care about such payloads, use [`payload_as_str`] instead.\n\n A invocation of the `panic!()` macro in Rust 2021 or later will always result in a\n panic payload of type `&'static str` or `String`.\n\n Only an invocation of [`panic_any`]\n (or, in Rust 2018 and earlier, `panic!(x)` where `x` is something other than a string)\n can result in a panic payload other than a `&'static str` or `String`.\n\n [`String`]: ../../std/string/struct.String.html\n [`payload_as_str`]: PanicHookInfo::payload_as_str\n\n # Examples\n\n ```should_panic\n use std::panic;\n\n panic::set_hook(Box::new(|panic_info| {\n     if let Some(s) = panic_info.payload().downcast_ref::<&str>() {\n         println!(\"panic occurred: {s:?}\");\n     } else if let Some(s) = panic_info.payload().downcast_ref::<String>() {\n         println!(\"panic occurred: {s:?}\");\n     } else {\n         println!(\"panic occurred\");\n     }\n }));\n\n panic!(\"Normal panic\");\n ```\n",
      "adt": {
        "panic::PanicHookInfo": "ImmutableAsArgument"
      }
    },
    "panicking::payload_as_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::stdio::try_set_output_capture": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Tries to set the thread-local output capture buffer and returns the old one.\n This may fail once thread-local destructors are called. It's used in panic\n handling instead of `set_output_capture`.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "core::result::Result": "Constructor",
        "alloc_crate::sync::Arc": "Constructor",
        "sync::poison::mutex::Mutex": "Constructor",
        "alloc_crate::vec::Vec": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sync::poison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Errors\n\n If another user of this mutex panicked while holding the mutex, then\n this call will return an error once the mutex is acquired. The acquired\n mutex guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock().unwrap() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock().unwrap(), 10);\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "sync::poison::mutex::Mutex": "ImmutableAsArgument",
        "sync::poison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::ops::Fn::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "sys::stdio::unix::panic_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::stdio::unix::Stderr": "Constructor"
      }
    }
  },
  "adts": {
    "panic::PanicHookInfo": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ],
    "core::panic::Location": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 6687, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 6689, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 6690, kind: RigidTy(Adt(AdtDef(DefId { id: 7206, name: \"sync::poison::mutex::Mutex\" }), GenericArgs([Type(Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 6687, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 6689, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 6690, kind: RigidTy(Adt(AdtDef(DefId { id: 7206, name: \"sync::poison::mutex::Mutex\" }), GenericArgs([Type(Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 6689, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 6690, kind: RigidTy(Adt(AdtDef(DefId { id: 7206, name: \"sync::poison::mutex::Mutex\" }), GenericArgs([Type(Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])"
    ],
    "alloc_crate::sync::Arc": [
      "Plain",
      "Ref"
    ],
    "sync::poison::mutex::Mutex": [
      "Ref"
    ],
    "sync::poison::mutex::MutexGuard": [
      "Plain",
      "MutRef"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ],
    "sys::stdio::unix::Stderr": [
      "MutRef",
      "Plain"
    ]
  },
  "path": 2322,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:240:1: 321:2",
  "src": "fn default_hook(info: &PanicHookInfo<'_>) {\n    // If this is a double panic, make sure that we print a backtrace\n    // for this panic. Otherwise only print it if logging is enabled.\n    let backtrace = if info.force_no_backtrace() {\n        None\n    } else if panic_count::get_count() >= 2 {\n        BacktraceStyle::full()\n    } else {\n        crate::panic::get_backtrace_style()\n    };\n\n    // The current implementation always returns `Some`.\n    let location = info.location().unwrap();\n\n    let msg = payload_as_str(info.payload());\n\n    let write = #[optimize(size)]\n    |err: &mut dyn crate::io::Write| {\n        // Use a lock to prevent mixed output in multithreading context.\n        // Some platforms also require it when printing a backtrace, like `SymFromAddr` on Windows.\n        let mut lock = backtrace::lock();\n\n        thread::with_current_name(|name| {\n            let name = name.unwrap_or(\"<unnamed>\");\n            let tid = thread::current_os_id();\n\n            // Try to write the panic message to a buffer first to prevent other concurrent outputs\n            // interleaving with it.\n            let mut buffer = [0u8; 512];\n            let mut cursor = crate::io::Cursor::new(&mut buffer[..]);\n\n            let write_msg = |dst: &mut dyn crate::io::Write| {\n                // We add a newline to ensure the panic message appears at the start of a line.\n                writeln!(dst, \"\\nthread '{name}' ({tid}) panicked at {location}:\\n{msg}\")\n            };\n\n            if write_msg(&mut cursor).is_ok() {\n                let pos = cursor.position() as usize;\n                let _ = err.write_all(&buffer[0..pos]);\n            } else {\n                // The message did not fit into the buffer, write it directly instead.\n                let _ = write_msg(err);\n            };\n        });\n\n        static FIRST_PANIC: Atomic<bool> = AtomicBool::new(true);\n\n        match backtrace {\n            Some(BacktraceStyle::Short) => {\n                drop(lock.print(err, crate::backtrace_rs::PrintFmt::Short))\n            }\n            Some(BacktraceStyle::Full) => {\n                drop(lock.print(err, crate::backtrace_rs::PrintFmt::Full))\n            }\n            Some(BacktraceStyle::Off) => {\n                if FIRST_PANIC.swap(false, Ordering::Relaxed) {\n                    let _ = writeln!(\n                        err,\n                        \"note: run with `RUST_BACKTRACE=1` environment variable to display a \\\n                             backtrace\"\n                    );\n                    if cfg!(miri) {\n                        let _ = writeln!(\n                            err,\n                            \"note: in Miri, you may have to set `MIRIFLAGS=-Zmiri-env-forward=RUST_BACKTRACE` \\\n                                for the environment variable to have an effect\"\n                        );\n                    }\n                }\n            }\n            // If backtraces aren't supported or are forced-off, do nothing.\n            None => {}\n        }\n    };\n\n    if let Ok(Some(local)) = try_set_output_capture(None) {\n        write(&mut *local.lock().unwrap_or_else(|e| e.into_inner()));\n        try_set_output_capture(Some(local)).ok();\n    } else if let Some(mut out) = panic_output() {\n        write(&mut out);\n    }\n}",
  "mir": "fn panicking::default_hook(_1: &panic::PanicHookInfo<'_>) -> () {\n    let mut _0: ();\n    let  _2: core::option::Option<panic::BacktraceStyle>;\n    let mut _3: bool;\n    let mut _4: bool;\n    let mut _5: usize;\n    let  _6: &core::panic::Location<'_>;\n    let mut _7: core::option::Option<&core::panic::Location<'_>>;\n    let  _8: &str;\n    let mut _9: &dyn core::any::Any;\n    let  _10: &dyn core::any::Any + core::marker::Send;\n    let  _11: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:257:5: 257:37};\n    let mut _12: &&core::panic::Location<'_>;\n    let mut _13: &&str;\n    let mut _14: &core::option::Option<panic::BacktraceStyle>;\n    let mut _15: core::result::Result<core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>, thread::local::AccessError>;\n    let mut _16: core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>;\n    let mut _17: isize;\n    let mut _18: isize;\n    let  _19: alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>;\n    let  _20: ();\n    let mut _21: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:257:5: 257:37};\n    let mut _22: (&mut dyn io::Write,);\n    let mut _23: &mut dyn io::Write;\n    let mut _24: &mut alloc_crate::vec::Vec<u8>;\n    let mut _25: &mut sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>>;\n    let mut _26: sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>>;\n    let mut _27: core::result::Result<sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>>>>;\n    let  _28: &sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>;\n    let mut _29: &alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>;\n    let  _30: core::option::Option<core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>>;\n    let mut _31: core::result::Result<core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>, thread::local::AccessError>;\n    let mut _32: core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>;\n    let mut _33: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _34: isize;\n    let mut _35: sys::stdio::unix::Stderr;\n    let  _36: ();\n    let mut _37: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:257:5: 257:37};\n    let mut _38: (&mut dyn io::Write,);\n    let mut _39: &mut dyn io::Write;\n    let mut _40: &mut sys::stdio::unix::Stderr;\n    let mut _41: isize;\n    let mut _42: isize;\n    debug info => _1;\n    debug backtrace => _2;\n    debug location => _6;\n    debug msg => _8;\n    debug write => _11;\n    debug local => _19;\n    debug out => sys::stdio::unix::Stderr;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = panic::PanicHookInfo::<'_>::force_no_backtrace(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        _2 = core::option::Option::None;\n        goto -> bb8;\n    }\n    bb3: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = panicking::panic_count::get_count() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _4 = Ge(move _5, 2_usize);\n        switchInt(move _4) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_5);\n        _2 = panic::BacktraceStyle::full() -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        _2 = panic::get_backtrace_style() -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_4);\n        goto -> bb8;\n    }\n    bb8: {\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = panic::PanicHookInfo::<'_>::location(_1) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _6 = core::option::Option::<&core::panic::Location<'_>>::unwrap(move _7) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _10 = panic::PanicHookInfo::<'_>::payload(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _9 = _10 as &dyn core::any::Any;\n        _8 = panicking::payload_as_str(move _9) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_6;\n        StorageLive(_13);\n        _13 = &_8;\n        StorageLive(_14);\n        _14 = &_2;\n        _11 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:257:5: 257:37}(move _12, move _13, move _14);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = core::option::Option::None;\n        _15 = io::stdio::try_set_output_capture(move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        _18 = discriminant(_15);\n        switchInt(move _18) -> [0: bb14, 1: bb32, otherwise: bb35];\n    }\n    bb14: {\n        _17 = discriminant(((_15 as variant#0).0: core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>));\n        switchInt(move _17) -> [1: bb15, 0: bb32, otherwise: bb35];\n    }\n    bb15: {\n        _19 = move ((((_15 as variant#0).0: core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>) as variant#1).0: alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>);\n        StorageLive(_21);\n        _21 = &_11;\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_29);\n        _29 = &_19;\n        _28 = <alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>> as core::ops::Deref>::deref(move _29) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_29);\n        _27 = sync::poison::mutex::Mutex::<alloc_crate::vec::Vec<u8>>::lock(_28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _26 = core::result::Result::<sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>>>>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:316:49: 316:52}>(move _27, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:316:49: 316:52}) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _25 = &mut _26;\n        StorageDead(_27);\n        _24 = <sync::poison::mutex::MutexGuard<'_, alloc_crate::vec::Vec<u8>> as core::ops::DerefMut>::deref_mut(move _25) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_25);\n        _23 = _24 as &mut dyn io::Write;\n        _22 = (move _23);\n        _20 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:257:5: 257:37} as core::ops::Fn<(&mut dyn io::Write,)>>::call(move _21, move _22) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        drop(_26) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_26);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = core::option::Option::Some(_19);\n        _31 = io::stdio::try_set_output_capture(move _32) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_32);\n        _30 = core::result::Result::<core::option::Option<alloc_crate::sync::Arc<sync::poison::mutex::Mutex<alloc_crate::vec::Vec<u8>>>>, thread::local::AccessError>::ok(move _31) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_31);\n        drop(_30) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_30);\n        _42 = discriminant(_15);\n        switchInt(move _42) -> [0: bb34, 1: bb33, otherwise: bb35];\n    }\n    bb25: {\n        _34 = discriminant(_33);\n        switchInt(move _34) -> [1: bb26, 0: bb28, otherwise: bb35];\n    }\n    bb26: {\n        StorageLive(_37);\n        _37 = &_11;\n        StorageLive(_38);\n        StorageLive(_39);\n        _40 = &mut _35;\n        _39 = _40 as &mut dyn io::Write;\n        _38 = (move _39);\n        _36 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panicking.rs:257:5: 257:37} as core::ops::Fn<(&mut dyn io::Write,)>>::call(move _37, move _38) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_39);\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageDead(_33);\n        goto -> bb29;\n    }\n    bb28: {\n        StorageDead(_33);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_11);\n        StorageDead(_8);\n        StorageDead(_6);\n        StorageDead(_2);\n        return;\n    }\n    bb30: {\n        StorageDead(_15);\n        StorageLive(_33);\n        _33 = sys::stdio::unix::panic_output() -> [return: bb25, unwind unreachable];\n    }\n    bb31: {\n        goto -> bb30;\n    }\n    bb32: {\n        _41 = discriminant(_15);\n        switchInt(move _41) -> [0: bb31, 1: bb30, otherwise: bb35];\n    }\n    bb33: {\n        StorageDead(_15);\n        goto -> bb29;\n    }\n    bb34: {\n        goto -> bb33;\n    }\n    bb35: {\n        unreachable;\n    }\n}\n",
  "doc": " The default panic handler.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}