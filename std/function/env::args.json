{
  "name": "env::args",
  "safe": true,
  "callees": {
    "env::args_os": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the arguments that this program was started with (normally passed\n via the command line).\n\n The first element is traditionally the path of the executable, but it can be\n set to arbitrary text, and might not even exist. This means this property should\n not be relied upon for security purposes.\n\n On Unix systems the shell usually expands unquoted arguments with glob patterns\n (such as `*` and `?`). On Windows this is not done, and such arguments are\n passed as-is.\n\n On glibc Linux systems, arguments are retrieved by placing a function in `.init_array`.\n glibc passes `argc`, `argv`, and `envp` to functions in `.init_array`, as a non-standard\n extension. This allows `std::env::args_os` to work even in a `cdylib` or `staticlib`, as it\n does on macOS and Windows.\n\n Note that the returned iterator will not check if the arguments to the\n process are valid Unicode. If you want to panic on invalid UTF-8,\n use the [`args`] function instead.\n\n # Examples\n\n ```\n use std::env;\n\n // Prints each argument on a separate line\n for argument in env::args_os() {\n     println!(\"{argument:?}\");\n }\n ```\n",
      "adt": {
        "env::ArgsOs": "Constructor"
      }
    }
  },
  "adts": {
    "env::ArgsOs": [
      "Plain"
    ],
    "env::Args": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::env::args"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:821:1: 823:2",
  "src": "pub fn args() -> Args {\n    Args { inner: args_os() }\n}",
  "mir": "fn env::args() -> env::Args {\n    let mut _0: env::Args;\n    let mut _1: env::ArgsOs;\n    bb0: {\n        StorageLive(_1);\n        _1 = env::args_os() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Args(move _1);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": " Returns the arguments that this program was started with (normally passed\n via the command line).\n\n The first element is traditionally the path of the executable, but it can be\n set to arbitrary text, and might not even exist. This means this property should\n not be relied upon for security purposes.\n\n On Unix systems the shell usually expands unquoted arguments with glob patterns\n (such as `*` and `?`). On Windows this is not done, and such arguments are\n passed as-is.\n\n On glibc Linux systems, arguments are retrieved by placing a function in `.init_array`.\n glibc passes `argc`, `argv`, and `envp` to functions in `.init_array`, as a non-standard\n extension. This allows `std::env::args` to work even in a `cdylib` or `staticlib`, as it\n does on macOS and Windows.\n\n # Panics\n\n The returned iterator will panic during iteration if any argument to the\n process is not valid Unicode. If this is not desired,\n use the [`args_os`] function instead.\n\n # Examples\n\n ```\n use std::env;\n\n // Prints each argument on a separate line\n for argument in env::args() {\n     println!(\"{argument}\");\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}