{
  "name": "sync::mpmc::Receiver::<T>::try_recv",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sync::mpmc::array::Channel::<T>::try_recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to receive a message without blocking.\n",
      "adt": {
        "sync::mpmc::array::Channel": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::list::Channel::<T>::try_recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to receive a message without blocking.\n",
      "adt": {
        "sync::mpmc::list::Channel": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::zero::Channel::<T>::try_recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to receive a message without blocking.\n",
      "adt": {
        "sync::mpmc::zero::Channel": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sync::mpmc::ReceiverFlavor": [
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 11136, kind: RigidTy(Adt(AdtDef(DefId { id: 9340, name: \"sync::mpmc::counter::Receiver\" }), GenericArgs([Type(Ty { id: 11057, kind: RigidTy(Adt(AdtDef(DefId { id: 9477, name: \"sync::mpmc::zero::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11126, kind: RigidTy(Adt(AdtDef(DefId { id: 9340, name: \"sync::mpmc::counter::Receiver\" }), GenericArgs([Type(Ty { id: 10845, kind: RigidTy(Adt(AdtDef(DefId { id: 9390, name: \"sync::mpmc::list::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11139, kind: RigidTy(Adt(AdtDef(DefId { id: 9340, name: \"sync::mpmc::counter::Receiver\" }), GenericArgs([Type(Ty { id: 10556, kind: RigidTy(Adt(AdtDef(DefId { id: 9234, name: \"sync::mpmc::array::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])"
    ],
    "sync::mpmc::Receiver": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::mpmc::counter::Receiver": [
      "Ref"
    ],
    "sync::mpmc::zero::Channel": [
      "Ref"
    ],
    "sync::mpmc::list::Channel": [
      "Ref"
    ],
    "sync::mpmc::array::Channel": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2965,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:915:5: 921:6",
  "src": "pub fn try_recv(&self) -> Result<T, TryRecvError> {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.try_recv(),\n            ReceiverFlavor::List(chan) => chan.try_recv(),\n            ReceiverFlavor::Zero(chan) => chan.try_recv(),\n        }\n    }",
  "mir": "fn sync::mpmc::Receiver::<T>::try_recv(_1: &sync::mpmc::Receiver<T>) -> core::result::Result<T, sync::mpsc::TryRecvError> {\n    let mut _0: core::result::Result<T, sync::mpsc::TryRecvError>;\n    let mut _2: &sync::mpmc::ReceiverFlavor<T>;\n    let mut _3: isize;\n    let  _4: &sync::mpmc::counter::Receiver<sync::mpmc::array::Channel<T>>;\n    let  _5: &sync::mpmc::array::Channel<T>;\n    let  _6: &sync::mpmc::counter::Receiver<sync::mpmc::list::Channel<T>>;\n    let  _7: &sync::mpmc::list::Channel<T>;\n    let  _8: &sync::mpmc::counter::Receiver<sync::mpmc::zero::Channel<T>>;\n    let  _9: &sync::mpmc::zero::Channel<T>;\n    debug self => _1;\n    debug chan => _4;\n    debug chan => _6;\n    debug chan => _8;\n    bb0: {\n        StorageLive(_2);\n        _2 = &((*_1).0: sync::mpmc::ReceiverFlavor<T>);\n        _3 = discriminant((*_2));\n        switchInt(move _3) -> [0: bb4, 1: bb3, 2: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _8 = &(((*_2) as variant#2).0: sync::mpmc::counter::Receiver<sync::mpmc::zero::Channel<T>>);\n        _9 = <sync::mpmc::counter::Receiver<sync::mpmc::zero::Channel<T>> as core::ops::Deref>::deref(_8) -> [return: bb9, unwind unreachable];\n    }\n    bb3: {\n        _6 = &(((*_2) as variant#1).0: sync::mpmc::counter::Receiver<sync::mpmc::list::Channel<T>>);\n        _7 = <sync::mpmc::counter::Receiver<sync::mpmc::list::Channel<T>> as core::ops::Deref>::deref(_6) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        _4 = &(((*_2) as variant#0).0: sync::mpmc::counter::Receiver<sync::mpmc::array::Channel<T>>);\n        _5 = <sync::mpmc::counter::Receiver<sync::mpmc::array::Channel<T>> as core::ops::Deref>::deref(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = sync::mpmc::array::Channel::<T>::try_recv(_5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb11;\n    }\n    bb7: {\n        _0 = sync::mpmc::list::Channel::<T>::try_recv(_7) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        goto -> bb11;\n    }\n    bb9: {\n        _0 = sync::mpmc::zero::Channel::<T>::try_recv(_9) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Attempts to receive a message from the channel without blocking.\n\n This method will never block the caller in order to wait for data to\n become available. Instead, this will always return immediately with a\n possible option of pending data on the channel.\n\n If called on a zero-capacity channel, this method will receive a message only if there\n happens to be a send operation on the other side of the channel at the same time.\n\n This is useful for a flavor of \"optimistic check\" before deciding to\n block on a receiver.\n\n Compared with [`recv`], this function has two failure cases instead of one\n (one for disconnection, one for an empty buffer).\n\n [`recv`]: Self::recv\n\n # Examples\n\n ```rust\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc::{Receiver, channel};\n\n let (_, receiver): (_, Receiver<i32>) = channel();\n\n assert!(receiver.try_recv().is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}