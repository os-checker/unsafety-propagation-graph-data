{
  "name": "<io::cursor::Cursor<T> as io::Read>::read_exact",
  "safe": true,
  "callees": {
    "io::cursor::Cursor::<T>::split": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Splits the underlying slice at the cursor position and returns them.\n\n # Examples\n\n ```\n #![feature(cursor_split)]\n use std::io::Cursor;\n\n let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n\n assert_eq!(buff.split(), ([].as_slice(), [1, 2, 3, 4, 5].as_slice()));\n\n buff.set_position(2);\n assert_eq!(buff.split(), ([1, 2].as_slice(), [3, 4, 5].as_slice()));\n\n buff.set_position(6);\n assert_eq!(buff.split(), ([1, 2, 3, 4, 5].as_slice(), [].as_slice()));\n ```\n",
      "adt": {
        "io::cursor::Cursor": "ImmutableAsArgument"
      }
    },
    "io::Read::read_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the exact number of bytes required to fill `buf`.\n\n This function reads as many bytes as necessary to completely fill the\n specified buffer `buf`.\n\n *Implementations* of this method can make no assumptions about the contents of `buf` when\n this function is called. It is recommended that implementations only write data to `buf`\n instead of reading its contents. The documentation on [`read`] has a more detailed\n explanation of this subject.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If this function encounters an \"end of file\" before completely filling\n the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n The contents of `buf` are unspecified in this case.\n\n If any other read error is encountered then this function immediately\n returns. The contents of `buf` are unspecified in this case.\n\n If this function returns an error, it is unspecified how many bytes it\n has read, but it will never read more than would be necessary to\n completely fill the buffer.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read`]: Read::read\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = [0; 10];\n\n     // read exactly 10 bytes\n     f.read_exact(&mut buffer)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    }
  },
  "adts": {
    "io::cursor::Cursor": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1431,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/cursor.rs:360:5: 370:6",
  "src": "fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        let result = Read::read_exact(&mut Cursor::split(self).1, buf);\n\n        match result {\n            Ok(_) => self.pos += buf.len() as u64,\n            // The only possible error condition is EOF, so place the cursor at \"EOF\"\n            Err(_) => self.pos = self.inner.as_ref().len() as u64,\n        }\n\n        result\n    }",
  "mir": "fn <io::cursor::Cursor<T> as io::Read>::read_exact(_1: &mut io::cursor::Cursor<T>, _2: &mut [u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: &mut &[u8];\n    let mut _4: (&[u8], &[u8]);\n    let mut _5: &io::cursor::Cursor<T>;\n    let mut _6: isize;\n    let mut _7: u64;\n    let mut _8: usize;\n    let mut _9: &[u8];\n    let mut _10: (u64, bool);\n    let mut _11: usize;\n    let  _12: &[u8];\n    let mut _13: &T;\n    debug self => _1;\n    debug buf => _2;\n    debug result => _0;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = io::cursor::Cursor::<T>::split(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = &mut (_4.1: &[u8]);\n        _0 = <&[u8] as io::Read>::read_exact(_3, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = discriminant(_0);\n        switchInt(move _6) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_11);\n        StorageLive(_13);\n        _13 = &((*_1).0: T);\n        _12 = <T as core::convert::AsRef<[u8]>>::as_ref(move _13) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &(*_2);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        _7 = move _8 as u64;\n        StorageDead(_8);\n        _10 = CheckedAdd(((*_1).1: u64), _7);\n        assert(!move (_10.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_1).1: u64), move _7) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        ((*_1).1: u64) = move (_10.0: u64);\n        StorageDead(_7);\n        goto -> bb8;\n    }\n    bb7: {\n        StorageDead(_13);\n        _11 = PtrMetadata(_12);\n        ((*_1).1: u64) = move _11 as u64;\n        StorageDead(_11);\n        goto -> bb8;\n    }\n    bb8: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}