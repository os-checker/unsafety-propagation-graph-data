{
  "name": "backtrace_rs::symbolize::gimli::resolve",
  "safe": false,
  "callees": {
    "backtrace_rs::symbolize::ResolveWhat::<'a>::address_or_ip": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "backtrace_rs::symbolize::ResolveWhat": "MutableAsArgument"
      }
    },
    "backtrace_rs::symbolize::gimli::Cache::with_global": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "backtrace_rs::symbolize::ResolveWhat": [
      "Ref",
      "Plain"
    ]
  },
  "path": 541,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:441:1: 501:2",
  "src": "pub unsafe fn resolve(what: ResolveWhat<'_>, cb: &mut dyn FnMut(&super::Symbol)) {\n    let addr = what.address_or_ip();\n    let mut call = |sym: Symbol<'_>| {\n        // Extend the lifetime of `sym` to `'static` since we are unfortunately\n        // required to here, but it's only ever going out as a reference so no\n        // reference to it should be persisted beyond this frame anyway.\n        // SAFETY: praying the above is correct\n        let sym = unsafe { mem::transmute::<Symbol<'_>, Symbol<'static>>(sym) };\n        (cb)(&super::Symbol { inner: sym });\n    };\n\n    unsafe {\n        Cache::with_global(|cache| {\n            let (lib, addr) = match cache.avma_to_svma(addr.cast_const().cast::<u8>()) {\n                Some(pair) => pair,\n                None => return,\n            };\n\n            // Finally, get a cached mapping or create a new mapping for this file, and\n            // evaluate the DWARF info to find the file/line/name for this address.\n            let (cx, stash) = match cache.mapping_for_lib(lib) {\n                Some((cx, stash)) => (cx, stash),\n                None => return,\n            };\n            let mut any_frames = false;\n            if let Ok(mut frames) = cx.find_frames(stash, addr as u64) {\n                while let Ok(Some(frame)) = frames.next() {\n                    any_frames = true;\n                    let name = match frame.function {\n                        Some(f) => Some(f.name.slice()),\n                        None => cx.object.search_symtab(addr as u64),\n                    };\n                    call(Symbol::Frame {\n                        addr: addr as *mut c_void,\n                        location: frame.location,\n                        name,\n                    });\n                }\n            }\n            if !any_frames {\n                if let Some((object_cx, object_addr)) = cx.object.search_object_map(addr as u64) {\n                    if let Ok(mut frames) = object_cx.find_frames(stash, object_addr) {\n                        while let Ok(Some(frame)) = frames.next() {\n                            any_frames = true;\n                            call(Symbol::Frame {\n                                addr: addr as *mut c_void,\n                                location: frame.location,\n                                name: frame.function.map(|f| f.name.slice()),\n                            });\n                        }\n                    }\n                }\n            }\n            if !any_frames {\n                if let Some(name) = cx.object.search_symtab(addr as u64) {\n                    call(Symbol::Symtab { name });\n                }\n            }\n        });\n    }\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::resolve(_1: backtrace_rs::symbolize::ResolveWhat<'_>, _2: &mut dyn for<'a> core::ops::FnMut(&'a backtrace_rs::symbolize::Symbol)) -> () {\n    let mut _0: ();\n    let  _3: *mut libc::c_void;\n    let mut _4: &backtrace_rs::symbolize::ResolveWhat<'_>;\n    let mut _5: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:443:20: 443:37};\n    let  _6: ();\n    let mut _7: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:453:28: 453:35};\n    let mut _8: &*mut libc::c_void;\n    let mut _9: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:443:20: 443:37};\n    debug what => _1;\n    debug cb => _2;\n    debug addr => _3;\n    debug call => _5;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = backtrace_rs::symbolize::ResolveWhat::<'_>::address_or_ip(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:443:20: 443:37}(_2);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_3;\n        StorageLive(_9);\n        _9 = &mut _5;\n        _7 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:453:28: 453:35}(move _8, move _9);\n        StorageDead(_9);\n        StorageDead(_8);\n        _6 = backtrace_rs::symbolize::gimli::Cache::with_global::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli.rs:453:28: 453:35}>(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        StorageDead(_5);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}