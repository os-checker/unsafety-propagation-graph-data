{
  "name": "io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_buf_exact",
  "safe": true,
  "callees": {
    "core::io::BorrowedCursor::<'a>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the available space in the cursor.\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at_checked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index, returning `None` if the slice is\n too short.\n\n If `mid â‰¤ len` returns a pair of slices where the first will contain all\n indices from `[0, mid)` (excluding the index `mid` itself) and the\n second will contain all indices from `[mid, len)` (excluding the index\n `len` itself).\n\n Otherwise, if `mid > len`, returns `None`.\n\n # Examples\n\n ```\n let v = [1, -2, 3, -4, 5, -6];\n\n {\n    let (left, right) = v.split_at_checked(0).unwrap();\n    assert_eq!(left, []);\n    assert_eq!(right, [1, -2, 3, -4, 5, -6]);\n }\n\n {\n     let (left, right) = v.split_at_checked(2).unwrap();\n     assert_eq!(left, [1, -2]);\n     assert_eq!(right, [3, -4, 5, -6]);\n }\n\n {\n     let (left, right) = v.split_at_checked(6).unwrap();\n     assert_eq!(left, [1, -2, 3, -4, 5, -6]);\n     assert_eq!(right, []);\n }\n\n assert_eq!(None, v.split_at_checked(7));\n ```\n",
      "adt": {}
    },
    "core::io::BorrowedCursor::<'a>::append": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends data to the cursor, advancing position within its buffer.\n\n # Panics\n\n Panics if `self.capacity()` is less than `buf.len()`.\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the deque, removing all values.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n deque.push_back(1);\n deque.clear();\n assert!(deque.is_empty());\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::drain": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the specified range from the deque in bulk, returning all\n removed elements as an iterator. If the iterator is dropped before\n being fully consumed, it drops the remaining removed elements.\n\n The returned iterator keeps a mutable borrow on the queue to optimize\n its implementation.\n\n\n # Panics\n\n Panics if the range has `start_bound > end_bound`, or, if the range is\n bounded on either end and past the length of the deque.\n\n # Leaking\n\n If the returned iterator goes out of scope without being dropped (due to\n [`mem::forget`], for example), the deque may have lost and leaked\n elements arbitrarily, including elements outside the range.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque: VecDeque<_> = [1, 2, 3].into();\n let drained = deque.drain(2..).collect::<VecDeque<_>>();\n assert_eq!(drained, [3]);\n assert_eq!(deque, [1, 2]);\n\n // A full range clears all contents, like `clear()` does\n deque.drain(..);\n assert!(deque.is_empty());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::io::BorrowedCursor": [
      "Ref",
      "Plain",
      "MutRef"
    ],
    "alloc_crate::collections::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 5024, kind: RigidTy(Tuple([Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) }, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) }])) }), Field(0, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "alloc_crate::collections::vec_deque::Drain": [
      "Plain"
    ]
  },
  "path": 1833,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/impls.rs:568:5: 589:6",
  "src": "fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n        let len = cursor.capacity();\n        let (front, back) = self.as_slices();\n\n        match front.split_at_checked(cursor.capacity()) {\n            Some((front, _)) => cursor.append(front),\n            None => {\n                cursor.append(front);\n                match back.split_at_checked(cursor.capacity()) {\n                    Some((back, _)) => cursor.append(back),\n                    None => {\n                        cursor.append(back);\n                        self.clear();\n                        return Err(io::Error::READ_EXACT_EOF);\n                    }\n                }\n            }\n        }\n\n        self.drain(..len);\n        Ok(())\n    }",
  "mir": "fn io::impls::<impl io::Read for alloc_crate::collections::VecDeque<u8, A>>::read_buf_exact(_1: &mut alloc_crate::collections::VecDeque<u8, A>, _2: core::io::BorrowedCursor<'_>) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let  _3: usize;\n    let mut _4: &core::io::BorrowedCursor<'_>;\n    let  _5: &[u8];\n    let  _6: &[u8];\n    let mut _7: (&[u8], &[u8]);\n    let mut _8: &alloc_crate::collections::VecDeque<u8, A>;\n    let  _9: ();\n    let mut _10: core::option::Option<(&[u8], &[u8])>;\n    let mut _11: usize;\n    let mut _12: &core::io::BorrowedCursor<'_>;\n    let mut _13: isize;\n    let  _14: &[u8];\n    let mut _15: &mut core::io::BorrowedCursor<'_>;\n    let  _16: ();\n    let mut _17: &mut core::io::BorrowedCursor<'_>;\n    let mut _18: core::option::Option<(&[u8], &[u8])>;\n    let mut _19: usize;\n    let mut _20: &core::io::BorrowedCursor<'_>;\n    let mut _21: isize;\n    let  _22: &[u8];\n    let mut _23: &mut core::io::BorrowedCursor<'_>;\n    let  _24: ();\n    let mut _25: &mut core::io::BorrowedCursor<'_>;\n    let  _26: ();\n    let  _27: alloc_crate::collections::vec_deque::Drain<'_, u8, A>;\n    let mut _28: core::ops::RangeTo<usize>;\n    debug self => _1;\n    debug cursor => _2;\n    debug len => _3;\n    debug front => _5;\n    debug back => _6;\n    debug front => _14;\n    debug back => _22;\n    bb0: {\n        StorageLive(_4);\n        _4 = &_2;\n        _3 = core::io::BorrowedCursor::<'_>::capacity(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_1);\n        _7 = alloc_crate::collections::VecDeque::<u8, A>::as_slices(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _5 = (_7.0: &[u8]);\n        _6 = (_7.1: &[u8]);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_2;\n        _11 = core::io::BorrowedCursor::<'_>::capacity(move _12) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_12);\n        _10 = core::slice::<impl [u8]>::split_at_checked(_5, move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        _13 = discriminant(_10);\n        switchInt(move _13) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_17);\n        _17 = &mut _2;\n        _16 = core::io::BorrowedCursor::<'_>::append(move _17, _5) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _14 = (((_10 as variant#1).0: (&[u8], &[u8])).0: &[u8]);\n        StorageLive(_15);\n        _15 = &mut _2;\n        _9 = core::io::BorrowedCursor::<'_>::append(move _15, _14) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_15);\n        goto -> bb17;\n    }\n    bb9: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &_2;\n        _19 = core::io::BorrowedCursor::<'_>::capacity(move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        _18 = core::slice::<impl [u8]>::split_at_checked(_6, move _19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        _21 = discriminant(_18);\n        switchInt(move _21) -> [0: bb12, 1: bb13, otherwise: bb5];\n    }\n    bb12: {\n        StorageLive(_25);\n        _25 = &mut _2;\n        _24 = core::io::BorrowedCursor::<'_>::append(move _25, _6) -> [return: bb15, unwind unreachable];\n    }\n    bb13: {\n        _22 = (((_18 as variant#1).0: (&[u8], &[u8])).0: &[u8]);\n        StorageLive(_23);\n        _23 = &mut _2;\n        _9 = core::io::BorrowedCursor::<'_>::append(move _23, _22) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        StorageDead(_18);\n        goto -> bb17;\n    }\n    bb15: {\n        StorageDead(_25);\n        _26 = alloc_crate::collections::VecDeque::<u8, A>::clear(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _0 = core::result::Result::Err(io::error::Error::READ_EXACT_EOF);\n        StorageDead(_18);\n        StorageDead(_10);\n        goto -> bb20;\n    }\n    bb17: {\n        StorageDead(_10);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = RangeTo(_3);\n        _27 = alloc_crate::collections::VecDeque::<u8, A>::drain::<core::ops::RangeTo<usize>>(_1, move _28) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_28);\n        drop(_27) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_27);\n        _0 = core::result::Result::Ok(());\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}