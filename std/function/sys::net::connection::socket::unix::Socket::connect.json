{
  "name": "sys::net::connection::socket::unix::Socket::connect",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::socket_addr_to_c": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::net::SocketAddr": "MutableAsArgument",
        "sys::net::connection::socket::SocketAddrCRepr": "Constructor"
      }
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "sys::net::connection::socket::SocketAddrCRepr::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::SocketAddrCRepr": "MutableAsArgument"
      }
    },
    "libc::connect": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::IsMinusOne::is_minus_one": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::os::errno": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the platform-specific value of errno\n",
      "adt": {}
    },
    "io::error::Error::from_raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of an [`Error`] from a particular OS error code.\n\n # Examples\n\n On Linux:\n\n ```\n # if cfg!(target_os = \"linux\") {\n use std::io;\n\n let error = io::Error::from_raw_os_error(22);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n\n On Windows:\n\n ```\n # if cfg!(windows) {\n use std::io;\n\n let error = io::Error::from_raw_os_error(10022);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    }
  },
  "adts": {
    "core::net::SocketAddr": [
      "Ref"
    ],
    "sys::net::connection::socket::SocketAddrCRepr": [
      "Plain",
      "Unknown([Field(0, Ty { id: 16251, kind: RigidTy(Adt(AdtDef(DefId { id: 11930, name: \"sys::net::connection::socket::SocketAddrCRepr\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Ref"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 3683,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/net/connection/socket/unix.rs:149:5: 163:6",
  "src": "pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n        let (addr, len) = socket_addr_to_c(addr);\n        loop {\n            let result = unsafe { libc::connect(self.as_raw_fd(), addr.as_ptr(), len) };\n            if result.is_minus_one() {\n                let err = crate::sys::os::errno();\n                match err {\n                    libc::EINTR => continue,\n                    libc::EISCONN => return Ok(()),\n                    _ => return Err(io::Error::from_raw_os_error(err)),\n                }\n            }\n            return Ok(());\n        }\n    }",
  "mir": "fn sys::net::connection::socket::unix::Socket::connect(_1: &sys::net::connection::socket::unix::Socket, _2: &core::net::SocketAddr) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let  _3: sys::net::connection::socket::SocketAddrCRepr;\n    let  _4: u32;\n    let mut _5: (sys::net::connection::socket::SocketAddrCRepr, u32);\n    let  _6: i32;\n    let mut _7: i32;\n    let mut _8: *const libc::sockaddr;\n    let mut _9: &sys::net::connection::socket::SocketAddrCRepr;\n    let mut _10: bool;\n    let mut _11: &i32;\n    let  _12: i32;\n    let mut _13: io::error::Error;\n    debug self => _1;\n    debug addr => _2;\n    debug addr => _3;\n    debug len => _4;\n    debug result => _6;\n    debug err => _12;\n    bb0: {\n        StorageLive(_5);\n        _5 = sys::net::connection::socket::socket_addr_to_c(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = move (_5.0: sys::net::connection::socket::SocketAddrCRepr);\n        _4 = (_5.1: u32);\n        StorageDead(_5);\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = <sys::net::connection::socket::unix::Socket as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_3;\n        _8 = sys::net::connection::socket::SocketAddrCRepr::as_ptr(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _6 = libc::connect(move _7, move _8, _4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_6;\n        _10 = <i32 as sys::pal::unix::IsMinusOne>::is_minus_one(move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _10) -> [0: bb12, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_11);\n        _12 = sys::pal::unix::os::errno() -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(_12) -> [4: bb13, 106: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageLive(_13);\n        _13 = io::error::Error::from_raw_os_error(_12) -> [return: bb11, unwind unreachable];\n    }\n    bb10: {\n        _0 = core::result::Result::Ok(());\n        goto -> bb14;\n    }\n    bb11: {\n        _0 = core::result::Result::Err(move _13);\n        StorageDead(_13);\n        goto -> bb14;\n    }\n    bb12: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _0 = core::result::Result::Ok(());\n        goto -> bb15;\n    }\n    bb13: {\n        StorageDead(_10);\n        StorageDead(_6);\n        goto -> bb2;\n    }\n    bb14: {\n        StorageDead(_10);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_6);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}