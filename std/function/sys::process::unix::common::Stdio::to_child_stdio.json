{
  "name": "sys::process::unix::common::Stdio::to_child_stdio",
  "safe": true,
  "callees": {
    "sys::fs::unix::OpenOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "Constructor"
      }
    },
    "sys::pal::unix::pipe::anon_pipe": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "sys::pal::unix::pipe::AnonPipe": "Constructor"
      }
    },
    "os::fd::owned::BorrowedFd::<'_>::try_clone_to_owned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `OwnedFd` instance that shares the same underlying file\n description as the existing `BorrowedFd` instance.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "os::fd::owned::BorrowedFd": "ImmutableAsArgument",
        "os::fd::owned::OwnedFd": "Constructor"
      }
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "sys::fd::unix::FileDesc::duplicate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "sys::fd::unix::FileDesc": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sys_common::FromInner::from_inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys_common::IntoInner::into_inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::fs::unix::OpenOptions::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "MutableAsArgument"
      }
    },
    "sys::fs::unix::OpenOptions::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "MutableAsArgument"
      }
    },
    "sys::fs::unix::File::open_c": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "core::ffi::CStr": "ImmutableAsArgument",
        "sys::fs::unix::File": "Constructor"
      }
    }
  },
  "adts": {
    "sys::process::unix::common::Stdio": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(4, ThreadLocalIndex)), Field(0, Ty { id: 8080, kind: RigidTy(Adt(AdtDef(DefId { id: 8084, name: \"os::fd::owned::BorrowedFd\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(3, ThreadLocalIndex)), Field(0, Ty { id: 6037, kind: RigidTy(Adt(AdtDef(DefId { id: 7071, name: \"sys::fd::unix::FileDesc\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "sys::fs::unix::OpenOptions": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "os::fd::owned::BorrowedFd": [
      "Plain",
      "Ref"
    ],
    "sys::fd::unix::FileDesc": [
      "Ref",
      "Plain"
    ],
    "sys::process::unix::common::ChildStdio": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 6037, kind: RigidTy(Adt(AdtDef(DefId { id: 7071, name: \"sys::fd::unix::FileDesc\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8512, kind: RigidTy(Adt(AdtDef(DefId { id: 8314, name: \"os::fd::owned::OwnedFd\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 14998, kind: RigidTy(Tuple([Ty { id: 8883, kind: RigidTy(Adt(AdtDef(DefId { id: 8520, name: \"sys::pal::unix::pipe::AnonPipe\" }), GenericArgs([]))) }, Ty { id: 8883, kind: RigidTy(Adt(AdtDef(DefId { id: 8520, name: \"sys::pal::unix::pipe::AnonPipe\" }), GenericArgs([]))) }])) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3800, kind: RigidTy(Adt(AdtDef(DefId { id: 6013, name: \"sys::fs::unix::File\" }), GenericArgs([]))) })])"
    ],
    "os::fd::owned::OwnedFd": [
      "Plain"
    ],
    "sys::pal::unix::pipe::AnonPipe": [
      "Plain",
      "Unknown([Field(0, Ty { id: 8883, kind: RigidTy(Adt(AdtDef(DefId { id: 8520, name: \"sys::pal::unix::pipe::AnonPipe\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 8883, kind: RigidTy(Adt(AdtDef(DefId { id: 8520, name: \"sys::pal::unix::pipe::AnonPipe\" }), GenericArgs([]))) })])"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "sys::fs::unix::File": [
      "Plain"
    ]
  },
  "path": 4189,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/common.rs:396:5: 438:6",
  "src": "pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n        match *self {\n            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n\n            // Make sure that the source descriptors are not an stdio\n            // descriptor, otherwise the order which we set the child's\n            // descriptors may blow away a descriptor which we are hoping to\n            // save. For example, suppose we want the child's stderr to be the\n            // parent's stdout, and the child's stdout to be the parent's\n            // stderr. No matter which we dup first, the second will get\n            // overwritten prematurely.\n            Stdio::Fd(ref fd) => {\n                if fd.as_raw_fd() >= 0 && fd.as_raw_fd() <= libc::STDERR_FILENO {\n                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                } else {\n                    Ok((ChildStdio::Explicit(fd.as_raw_fd()), None))\n                }\n            }\n\n            Stdio::StaticFd(fd) => {\n                let fd = FileDesc::from_inner(fd.try_clone_to_owned()?);\n                Ok((ChildStdio::Owned(fd), None))\n            }\n\n            Stdio::MakePipe => {\n                let (reader, writer) = pipe::anon_pipe()?;\n                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n                Ok((ChildStdio::Owned(theirs.into_inner()), Some(ours)))\n            }\n\n            #[cfg(not(target_os = \"fuchsia\"))]\n            Stdio::Null => {\n                let mut opts = OpenOptions::new();\n                opts.read(readable);\n                opts.write(!readable);\n                let fd = File::open_c(DEV_NULL, &opts)?;\n                Ok((ChildStdio::Owned(fd.into_inner()), None))\n            }\n\n            #[cfg(target_os = \"fuchsia\")]\n            Stdio::Null => Ok((ChildStdio::Null, None)),\n        }\n    }",
  "mir": "fn sys::process::unix::common::Stdio::to_child_stdio(_1: &sys::process::unix::common::Stdio, _2: bool) -> core::result::Result<(sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>), io::error::Error> {\n    let mut _0: core::result::Result<(sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>), io::error::Error>;\n    let mut _3: isize;\n    let mut _4: (sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>);\n    let mut _5: sys::process::unix::common::ChildStdio;\n    let mut _6: core::option::Option<sys::pal::unix::pipe::AnonPipe>;\n    let  _7: &sys::fd::unix::FileDesc;\n    let mut _8: bool;\n    let mut _9: i32;\n    let mut _10: bool;\n    let mut _11: i32;\n    let mut _12: (sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>);\n    let mut _13: sys::process::unix::common::ChildStdio;\n    let mut _14: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, sys::fd::unix::FileDesc>;\n    let mut _15: core::result::Result<sys::fd::unix::FileDesc, io::error::Error>;\n    let mut _16: isize;\n    let  _17: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _18: sys::fd::unix::FileDesc;\n    let mut _19: core::option::Option<sys::pal::unix::pipe::AnonPipe>;\n    let mut _20: (sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>);\n    let mut _21: sys::process::unix::common::ChildStdio;\n    let mut _22: i32;\n    let mut _23: core::option::Option<sys::pal::unix::pipe::AnonPipe>;\n    let  _24: os::fd::owned::BorrowedFd<'_>;\n    let  _25: sys::fd::unix::FileDesc;\n    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, os::fd::owned::OwnedFd>;\n    let mut _27: core::result::Result<os::fd::owned::OwnedFd, io::error::Error>;\n    let mut _28: &os::fd::owned::BorrowedFd<'_>;\n    let mut _29: isize;\n    let  _30: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _31: os::fd::owned::OwnedFd;\n    let mut _32: (sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>);\n    let mut _33: sys::process::unix::common::ChildStdio;\n    let mut _34: core::option::Option<sys::pal::unix::pipe::AnonPipe>;\n    let  _35: sys::pal::unix::pipe::AnonPipe;\n    let  _36: sys::pal::unix::pipe::AnonPipe;\n    let mut _37: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, (sys::pal::unix::pipe::AnonPipe, sys::pal::unix::pipe::AnonPipe)>;\n    let mut _38: core::result::Result<(sys::pal::unix::pipe::AnonPipe, sys::pal::unix::pipe::AnonPipe), io::error::Error>;\n    let mut _39: isize;\n    let  _40: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _41: (sys::pal::unix::pipe::AnonPipe, sys::pal::unix::pipe::AnonPipe);\n    let  _42: sys::pal::unix::pipe::AnonPipe;\n    let  _43: sys::pal::unix::pipe::AnonPipe;\n    let mut _44: (sys::pal::unix::pipe::AnonPipe, sys::pal::unix::pipe::AnonPipe);\n    let mut _45: (sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>);\n    let mut _46: sys::process::unix::common::ChildStdio;\n    let mut _47: sys::fd::unix::FileDesc;\n    let mut _48: core::option::Option<sys::pal::unix::pipe::AnonPipe>;\n    let mut _49: sys::fs::unix::OpenOptions;\n    let  _50: ();\n    let mut _51: &mut sys::fs::unix::OpenOptions;\n    let  _52: ();\n    let mut _53: &mut sys::fs::unix::OpenOptions;\n    let mut _54: bool;\n    let mut _55: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, sys::fs::unix::File>;\n    let mut _56: core::result::Result<sys::fs::unix::File, io::error::Error>;\n    let mut _57: &core::ffi::CStr;\n    let  _58: &sys::fs::unix::OpenOptions;\n    let mut _59: isize;\n    let  _60: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _61: sys::fs::unix::File;\n    let mut _62: (sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>);\n    let mut _63: sys::process::unix::common::ChildStdio;\n    let mut _64: sys::fd::unix::FileDesc;\n    let mut _65: core::option::Option<sys::pal::unix::pipe::AnonPipe>;\n    debug self => _1;\n    debug readable => _2;\n    debug fd => _7;\n    debug residual => _17;\n    debug val => _18;\n    debug fd => _24;\n    debug fd => _25;\n    debug residual => _30;\n    debug val => _31;\n    debug reader => _35;\n    debug writer => _36;\n    debug residual => _40;\n    debug val => _41;\n    debug ours => _42;\n    debug theirs => _43;\n    debug opts => _49;\n    debug fd => _61;\n    debug residual => _60;\n    debug val => _61;\n    bb0: {\n        _3 = discriminant((*_1));\n        switchInt(move _3) -> [0: bb6, 1: bb2, 2: bb3, 3: bb5, 4: bb4, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        StorageLive(_49);\n        _49 = sys::fs::unix::OpenOptions::new() -> [return: bb36, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = sys::pal::unix::pipe::anon_pipe() -> [return: bb27, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_24);\n        _24 = (((*_1) as variant#4).0: os::fd::owned::BorrowedFd<'_>);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &_24;\n        _27 = os::fd::owned::BorrowedFd::<'_>::try_clone_to_owned(move _28) -> [return: bb21, unwind unreachable];\n    }\n    bb5: {\n        _7 = &(((*_1) as variant#3).0: sys::fd::unix::FileDesc);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = sys::process::unix::common::ChildStdio::Inherit;\n        StorageLive(_6);\n        _6 = core::option::Option::None;\n        _4 = (move _5, move _6);\n        StorageDead(_6);\n        StorageDead(_5);\n        _0 = core::result::Result::Ok(move _4);\n        StorageDead(_4);\n        goto -> bb45;\n    }\n    bb7: {\n        _8 = Ge(move _9, 0_i32);\n        switchInt(move _8) -> [0: bb17, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(_7) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _10 = Le(move _11, libc::STDERR_FILENO);\n        switchInt(move _10) -> [0: bb16, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = sys::fd::unix::FileDesc::duplicate(_7) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _14 = <core::result::Result<sys::fd::unix::FileDesc, io::error::Error> as core::ops::Try>::branch(move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        _16 = discriminant(_14);\n        switchInt(move _16) -> [0: bb13, 1: bb14, otherwise: bb1];\n    }\n    bb13: {\n        _18 = move ((_14 as variant#0).0: sys::fd::unix::FileDesc);\n        _13 = sys::process::unix::common::ChildStdio::Owned(_18);\n        StorageLive(_19);\n        _19 = core::option::Option::None;\n        _12 = (move _13, move _19);\n        StorageDead(_19);\n        StorageDead(_13);\n        _0 = core::result::Result::Ok(move _12);\n        StorageDead(_14);\n        StorageDead(_12);\n        goto -> bb20;\n    }\n    bb14: {\n        _17 = move ((_14 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_17) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_13);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_10);\n        StorageDead(_8);\n        goto -> bb45;\n    }\n    bb16: {\n        StorageDead(_11);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_9);\n        goto -> bb18;\n    }\n    bb18: {\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(_7) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _21 = sys::process::unix::common::ChildStdio::Explicit(move _22);\n        StorageDead(_22);\n        StorageLive(_23);\n        _23 = core::option::Option::None;\n        _20 = (move _21, move _23);\n        StorageDead(_23);\n        StorageDead(_21);\n        _0 = core::result::Result::Ok(move _20);\n        StorageDead(_20);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_10);\n        StorageDead(_8);\n        goto -> bb45;\n    }\n    bb21: {\n        StorageDead(_28);\n        _26 = <core::result::Result<os::fd::owned::OwnedFd, io::error::Error> as core::ops::Try>::branch(move _27) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        _29 = discriminant(_26);\n        switchInt(move _29) -> [0: bb23, 1: bb24, otherwise: bb1];\n    }\n    bb23: {\n        _31 = move ((_26 as variant#0).0: os::fd::owned::OwnedFd);\n        _25 = <sys::fd::unix::FileDesc as sys_common::FromInner<os::fd::owned::OwnedFd>>::from_inner(_31) -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _30 = move ((_26 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_30) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_26);\n        StorageDead(_24);\n        goto -> bb45;\n    }\n    bb26: {\n        StorageDead(_26);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = sys::process::unix::common::ChildStdio::Owned(_25);\n        StorageLive(_34);\n        _34 = core::option::Option::None;\n        _32 = (move _33, move _34);\n        StorageDead(_34);\n        StorageDead(_33);\n        _0 = core::result::Result::Ok(move _32);\n        StorageDead(_32);\n        StorageDead(_24);\n        goto -> bb45;\n    }\n    bb27: {\n        _37 = <core::result::Result<(sys::pal::unix::pipe::AnonPipe, sys::pal::unix::pipe::AnonPipe), io::error::Error> as core::ops::Try>::branch(move _38) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_38);\n        _39 = discriminant(_37);\n        switchInt(move _39) -> [0: bb29, 1: bb30, otherwise: bb1];\n    }\n    bb29: {\n        _41 = move ((_37 as variant#0).0: (sys::pal::unix::pipe::AnonPipe, sys::pal::unix::pipe::AnonPipe));\n        _35 = (_41.0: sys::pal::unix::pipe::AnonPipe);\n        _36 = (_41.1: sys::pal::unix::pipe::AnonPipe);\n        StorageDead(_37);\n        StorageLive(_44);\n        switchInt(_2) -> [0: bb33, otherwise: bb32];\n    }\n    bb30: {\n        _40 = move ((_37 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_40) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_37);\n        goto -> bb45;\n    }\n    bb32: {\n        _44 = (_36, _35);\n        goto -> bb34;\n    }\n    bb33: {\n        _44 = (_35, _36);\n        goto -> bb34;\n    }\n    bb34: {\n        _42 = move (_44.0: sys::pal::unix::pipe::AnonPipe);\n        _43 = move (_44.1: sys::pal::unix::pipe::AnonPipe);\n        StorageDead(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = <sys::pal::unix::pipe::AnonPipe as sys_common::IntoInner<sys::fd::unix::FileDesc>>::into_inner(_43) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        _46 = sys::process::unix::common::ChildStdio::Owned(move _47);\n        StorageDead(_47);\n        StorageLive(_48);\n        _48 = core::option::Option::Some(_42);\n        _45 = (move _46, move _48);\n        StorageDead(_48);\n        StorageDead(_46);\n        _0 = core::result::Result::Ok(move _45);\n        StorageDead(_45);\n        goto -> bb45;\n    }\n    bb36: {\n        StorageLive(_51);\n        _51 = &mut _49;\n        _50 = sys::fs::unix::OpenOptions::read(move _51, _2) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_51);\n        StorageLive(_53);\n        _53 = &mut _49;\n        StorageLive(_54);\n        _54 = Not(_2);\n        _52 = sys::fs::unix::OpenOptions::write(move _53, move _54) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = sys::process::unix::common::DEV_NULL;\n        _58 = &_49;\n        _56 = sys::fs::unix::File::open_c(move _57, _58) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_57);\n        _55 = <core::result::Result<sys::fs::unix::File, io::error::Error> as core::ops::Try>::branch(move _56) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_56);\n        _59 = discriminant(_55);\n        switchInt(move _59) -> [0: bb41, 1: bb42, otherwise: bb1];\n    }\n    bb41: {\n        _61 = move ((_55 as variant#0).0: sys::fs::unix::File);\n        StorageDead(_55);\n        StorageLive(_62);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = <sys::fs::unix::File as sys_common::IntoInner<sys::fd::unix::FileDesc>>::into_inner(_61) -> [return: bb44, unwind unreachable];\n    }\n    bb42: {\n        _60 = move ((_55 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::common::ChildStdio, core::option::Option<sys::pal::unix::pipe::AnonPipe>), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_60) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_55);\n        StorageDead(_49);\n        goto -> bb45;\n    }\n    bb44: {\n        _63 = sys::process::unix::common::ChildStdio::Owned(move _64);\n        StorageDead(_64);\n        StorageLive(_65);\n        _65 = core::option::Option::None;\n        _62 = (move _63, move _65);\n        StorageDead(_65);\n        StorageDead(_63);\n        _0 = core::result::Result::Ok(move _62);\n        StorageDead(_62);\n        StorageDead(_49);\n        goto -> bb45;\n    }\n    bb45: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}