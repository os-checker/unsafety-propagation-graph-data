{
  "name": "sys::pal::unix::stack_overflow::imp::make_handler",
  "safe": false,
  "callees": {
    "core::sync::atomic::AtomicBool::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the bool.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n assert_eq!(some_bool.load(Ordering::Relaxed), true);\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::stack_overflow::Handler::null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::pal::unix::stack_overflow::Handler": "Constructor"
      }
    },
    "sys::pal::unix::stack_overflow::imp::current_guard": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "core::ops::Range": "Constructor"
      }
    },
    "sys::pal::unix::stack_overflow::thread_info::set_current_info": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::ptr::null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*const T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *const i32 = ptr::null();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "libc::sigaltstack": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::stack_overflow::imp::get_stack": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "libc::stack_t": "Constructor"
      }
    },
    "core::ptr::null_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null mutable raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*mut T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *mut i32 = ptr::null_mut();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "sys::pal::unix::stack_overflow::Handler": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3405, kind: RigidTy(Adt(AdtDef(DefId { id: 5850, name: \"core::ops::Range\" }), GenericArgs([Type(Ty { id: 393, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "libc::stack_t": [
      "Plain",
      "MutRef",
      "Deref",
      "Unknown([Field(1, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Ref",
      "Unknown([Field(0, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::pal::unix::stack_overflow::imp::make_handler"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/stack_overflow.rs:250:5: 276:6",
  "src": "pub unsafe fn make_handler(main_thread: bool) -> Handler {\n        if cfg!(panic = \"immediate-abort\") || !NEED_ALTSTACK.load(Ordering::Acquire) {\n            return Handler::null();\n        }\n\n        if !main_thread {\n            if let Some(guard_page_range) = unsafe { current_guard() } {\n                set_current_info(guard_page_range);\n            }\n        }\n\n        // SAFETY: assuming stack_t is zero-initializable\n        let mut stack = unsafe { mem::zeroed() };\n        // SAFETY: reads current stack_t into stack\n        unsafe { sigaltstack(ptr::null(), &mut stack) };\n        // Configure alternate signal stack, if one is not already set.\n        if stack.ss_flags & SS_DISABLE != 0 {\n            // SAFETY: We warned our caller this would happen!\n            unsafe {\n                stack = get_stack();\n                sigaltstack(&stack, ptr::null_mut());\n            }\n            Handler { data: stack.ss_sp as *mut libc::c_void }\n        } else {\n            Handler::null()\n        }\n    }",
  "mir": "fn sys::pal::unix::stack_overflow::imp::make_handler(_1: bool) -> sys::pal::unix::stack_overflow::Handler {\n    let mut _0: sys::pal::unix::stack_overflow::Handler;\n    let mut _2: bool;\n    let mut _3: &core::sync::atomic::AtomicBool;\n    let mut _4: core::sync::atomic::Ordering;\n    let mut _5: core::option::Option<core::ops::Range<usize>>;\n    let mut _6: isize;\n    let  _7: core::ops::Range<usize>;\n    let  _8: ();\n    let mut _9: libc::stack_t;\n    let  _10: i32;\n    let mut _11: *const libc::stack_t;\n    let mut _12: *mut libc::stack_t;\n    let mut _13: &mut libc::stack_t;\n    let mut _14: i32;\n    let mut _15: i32;\n    let mut _16: libc::stack_t;\n    let  _17: i32;\n    let mut _18: *const libc::stack_t;\n    let  _19: &libc::stack_t;\n    let mut _20: *mut libc::stack_t;\n    let mut _21: *mut libc::c_void;\n    debug main_thread => _1;\n    debug guard_page_range => _7;\n    debug stack => _9;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = {alloc350: &core::sync::atomic::AtomicBool};\n        StorageLive(_4);\n        _4 = core::sync::atomic::Ordering::Acquire;\n        _2 = core::sync::atomic::AtomicBool::load(move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        switchInt(_1) -> [0: bb4, otherwise: bb9];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        _0 = sys::pal::unix::stack_overflow::Handler::null() -> [return: bb19, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_5);\n        _5 = sys::pal::unix::stack_overflow::imp::current_guard() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _6 = discriminant(_5);\n        switchInt(move _6) -> [1: bb6, 0: bb8, otherwise: bb21];\n    }\n    bb6: {\n        _7 = move ((_5 as variant#1).0: core::ops::Range<usize>);\n        _8 = sys::pal::unix::stack_overflow::thread_info::set_current_info(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb8: {\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_9);\n        _9 = core::mem::zeroed::<libc::stack_t>() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = core::ptr::null::<libc::stack_t>() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut _9;\n        _12 = &raw mut (*_13);\n        _10 = libc::sigaltstack(move _11, move _12) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (_9.1: i32);\n        _14 = BitAnd(move _15, libc::SS_DISABLE);\n        StorageDead(_15);\n        switchInt(move _14) -> [0: bb17, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = sys::pal::unix::stack_overflow::imp::get_stack() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _9 = move _16;\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_9;\n        _18 = &raw const (*_19);\n        StorageLive(_20);\n        _20 = core::ptr::null_mut::<libc::stack_t>() -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _17 = libc::sigaltstack(move _18, move _20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_20);\n        StorageDead(_18);\n        StorageDead(_19);\n        StorageDead(_17);\n        _21 = (_9.0: *mut libc::c_void);\n        _0 = Handler(_21);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_14);\n        _0 = sys::pal::unix::stack_overflow::Handler::null() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_9);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_2);\n        goto -> bb20;\n    }\n    bb20: {\n        return;\n    }\n    bb21: {\n        unreachable;\n    }\n}\n",
  "doc": " # Safety\n Mutates the alternate signal stack\n",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "unsafe_op_in_unsafe_fn"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* unsafe_op_in_unsafe_fn\n"
    ]
  }
}