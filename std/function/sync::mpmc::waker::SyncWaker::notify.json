{
  "name": "sync::mpmc::waker::SyncWaker::notify",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicBool::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the bool.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n assert_eq!(some_bool.load(Ordering::Relaxed), true);\n ```\n",
      "adt": {}
    },
    "sync::poison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Errors\n\n If another user of this mutex panicked while holding the mutex, then\n this call will return an error once the mutex is acquired. The acquired\n mutex guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock().unwrap() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock().unwrap(), 10);\n ```\n",
      "adt": {
        "sync::poison::mutex::Mutex": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "sync::mpmc::waker::Waker::try_select": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to find another thread's entry, select the operation, and wake it up.\n",
      "adt": {
        "sync::mpmc::waker::Waker": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sync::mpmc::waker::Waker::notify": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Notifies all operations waiting to be ready.\n",
      "adt": {
        "sync::mpmc::waker::Waker": "MutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the bool.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n some_bool.store(false, Ordering::Relaxed);\n assert_eq!(some_bool.load(Ordering::Relaxed), false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicBool": [
      "Ref"
    ],
    "sync::mpmc::waker::SyncWaker": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "sync::poison::mutex::Mutex": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "sync::poison::mutex::MutexGuard": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "sync::mpmc::waker::Waker": [
      "MutRef",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc_crate::vec::Vec": [
      "Ref"
    ]
  },
  "path": 2908,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/waker.rs:171:5: 183:6",
  "src": "pub(crate) fn notify(&self) {\n        if !self.is_empty.load(Ordering::SeqCst) {\n            let mut inner = self.inner.lock().unwrap();\n            if !self.is_empty.load(Ordering::SeqCst) {\n                inner.try_select();\n                inner.notify();\n                self.is_empty.store(\n                    inner.selectors.is_empty() && inner.observers.is_empty(),\n                    Ordering::SeqCst,\n                );\n            }\n        }\n    }",
  "mir": "fn sync::mpmc::waker::SyncWaker::notify(_1: &sync::mpmc::waker::SyncWaker) -> () {\n    let mut _0: ();\n    let mut _2: bool;\n    let mut _3: &core::sync::atomic::AtomicBool;\n    let mut _4: core::sync::atomic::Ordering;\n    let mut _5: sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>;\n    let mut _6: core::result::Result<sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>>>;\n    let mut _7: &sync::poison::mutex::Mutex<sync::mpmc::waker::Waker>;\n    let mut _8: bool;\n    let mut _9: &core::sync::atomic::AtomicBool;\n    let mut _10: core::sync::atomic::Ordering;\n    let  _11: core::option::Option<sync::mpmc::waker::Entry>;\n    let mut _12: &mut sync::mpmc::waker::Waker;\n    let mut _13: &mut sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>;\n    let  _14: ();\n    let mut _15: &mut sync::mpmc::waker::Waker;\n    let mut _16: &mut sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>;\n    let  _17: ();\n    let mut _18: &core::sync::atomic::AtomicBool;\n    let mut _19: bool;\n    let mut _20: bool;\n    let mut _21: &alloc_crate::vec::Vec<sync::mpmc::waker::Entry>;\n    let  _22: &sync::mpmc::waker::Waker;\n    let mut _23: &sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>;\n    let mut _24: &alloc_crate::vec::Vec<sync::mpmc::waker::Entry>;\n    let  _25: &sync::mpmc::waker::Waker;\n    let mut _26: &sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>;\n    let mut _27: core::sync::atomic::Ordering;\n    debug self => _1;\n    debug inner => _5;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).1: core::sync::atomic::AtomicBool);\n        StorageLive(_4);\n        _4 = core::sync::atomic::Ordering::SeqCst;\n        _2 = core::sync::atomic::AtomicBool::load(move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        goto -> bb24;\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &((*_1).0: sync::poison::mutex::Mutex<sync::mpmc::waker::Waker>);\n        _6 = sync::poison::mutex::Mutex::<sync::mpmc::waker::Waker>::lock(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = core::result::Result::<sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>, sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker>>>::unwrap(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &((*_1).1: core::sync::atomic::AtomicBool);\n        StorageLive(_10);\n        _10 = core::sync::atomic::Ordering::SeqCst;\n        _8 = core::sync::atomic::AtomicBool::load(move _9, move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb22;\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_11);\n        StorageLive(_13);\n        _13 = &mut _5;\n        _12 = <sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker> as core::ops::DerefMut>::deref_mut(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _11 = sync::mpmc::waker::Waker::try_select(_12) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        drop(_11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_11);\n        StorageLive(_16);\n        _16 = &mut _5;\n        _15 = <sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker> as core::ops::DerefMut>::deref_mut(move _16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        _14 = sync::mpmc::waker::Waker::notify(_15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_18);\n        _18 = &((*_1).1: core::sync::atomic::AtomicBool);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &_5;\n        _22 = <sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker> as core::ops::Deref>::deref(move _23) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_23);\n        _21 = &((*_22).0: alloc_crate::vec::Vec<sync::mpmc::waker::Entry>);\n        _20 = alloc_crate::vec::Vec::<sync::mpmc::waker::Entry>::is_empty(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _20) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_5;\n        _25 = <sync::poison::mutex::MutexGuard<'_, sync::mpmc::waker::Waker> as core::ops::Deref>::deref(move _26) -> [return: bb18, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _19 = false;\n        goto -> bb20;\n    }\n    bb18: {\n        StorageDead(_26);\n        _24 = &((*_25).1: alloc_crate::vec::Vec<sync::mpmc::waker::Entry>);\n        _19 = alloc_crate::vec::Vec::<sync::mpmc::waker::Entry>::is_empty(move _24) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_25);\n        StorageDead(_24);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_20);\n        StorageLive(_27);\n        _27 = core::sync::atomic::Ordering::SeqCst;\n        _17 = core::sync::atomic::AtomicBool::store(move _18, move _19, move _27) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_27);\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb22;\n    }\n    bb22: {\n        StorageDead(_8);\n        drop(_5) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_5);\n        goto -> bb24;\n    }\n    bb24: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Attempts to find one thread (not the current one), select its operation, and wake it up.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}