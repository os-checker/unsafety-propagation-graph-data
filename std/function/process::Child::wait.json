{
  "name": "process::Child::wait",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "sys::process::unix::unix::Process::wait": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::unix::Process": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "process::ExitStatus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Describes the result of a process after it has terminated.\n\n This `struct` is used to represent the exit status or other termination of a child process.\n Child processes are created via the [`Command`] struct and their exit\n status is exposed through the [`status`] method, or the [`wait`] method\n of a [`Child`] process.\n\n An `ExitStatus` represents every possible disposition of a process.  On Unix this\n is the **wait status**.  It is *not* simply an *exit status* (a value passed to `exit`).\n\n For proper error reporting of failed processes, print the value of `ExitStatus` or\n `ExitStatusError` using their implementations of [`Display`](crate::fmt::Display).\n\n # Differences from `ExitCode`\n\n [`ExitCode`] is intended for terminating the currently running process, via\n the `Termination` trait, in contrast to `ExitStatus`, which represents the\n termination of a child process. These APIs are separate due to platform\n compatibility differences and their expected usage; it is not generally\n possible to exactly reproduce an `ExitStatus` from a child for the current\n process after the fact.\n\n [`status`]: Command::status\n [`wait`]: Child::wait\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain"
    ],
    "process::Child": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "sys::process::unix::unix::Process": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2564,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/process.rs:2292:5: 2295:6",
  "src": "pub fn wait(&mut self) -> io::Result<ExitStatus> {\n        drop(self.stdin.take());\n        self.handle.wait().map(ExitStatus)\n    }",
  "mir": "fn process::Child::wait(_1: &mut process::Child) -> core::result::Result<process::ExitStatus, io::error::Error> {\n    let mut _0: core::result::Result<process::ExitStatus, io::error::Error>;\n    let  _2: ();\n    let mut _3: core::option::Option<process::ChildStdin>;\n    let mut _4: &mut core::option::Option<process::ChildStdin>;\n    let mut _5: core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let mut _6: &mut sys::process::unix::unix::Process;\n    debug self => _1;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).1: core::option::Option<process::ChildStdin>);\n        _3 = core::option::Option::<process::ChildStdin>::take(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = core::mem::drop::<core::option::Option<process::ChildStdin>>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut ((*_1).0: sys::process::unix::unix::Process);\n        _5 = sys::process::unix::unix::Process::wait(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _0 = core::result::Result::<sys::process::unix::unix::ExitStatus, io::error::Error>::map::<process::ExitStatus, fn(sys::process::unix::unix::ExitStatus) -> process::ExitStatus {process::ExitStatus}>(move _5, process::ExitStatus) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": " Waits for the child to exit completely, returning the status that it\n exited with. This function will continue to have the same return value\n after it has been called at least once.\n\n The stdin handle to the child process, if any, will be closed\n before waiting. This helps avoid deadlock: it ensures that the\n child does not block waiting for input from the parent, while\n the parent waits for the child to exit.\n\n # Examples\n\n ```no_run\n use std::process::Command;\n\n let mut command = Command::new(\"ls\");\n if let Ok(mut child) = command.spawn() {\n     child.wait().expect(\"command wasn't running\");\n     println!(\"Child has finished its execution!\");\n } else {\n     println!(\"ls command didn't start\");\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}