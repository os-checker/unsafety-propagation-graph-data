{
  "name": "io::cursor::vec_write_all_vectored",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::fold": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Folds every element into an accumulator by applying an operation,\n returning the final result.\n\n `fold()` takes two arguments: an initial value, and a closure with two\n arguments: an 'accumulator', and an element. The closure returns the value that\n the accumulator should have for the next iteration.\n\n The initial value is the value the accumulator will have on the first\n call.\n\n After applying this closure to every element of the iterator, `fold()`\n returns the accumulator.\n\n This operation is sometimes called 'reduce' or 'inject'.\n\n Folding is useful whenever you have a collection of something, and want\n to produce a single value from it.\n\n Note: `fold()`, and similar methods that traverse the entire iterator,\n might not terminate for infinite iterators, even on traits for which a\n result is determinable in finite time.\n\n Note: [`reduce()`] can be used to use the first element as the initial\n value, if the accumulator type and item type is the same.\n\n Note: `fold()` combines elements in a *left-associative* fashion. For associative\n operators like `+`, the order the elements are combined in is not important, but for non-associative\n operators like `-` the order will affect the final result.\n For a *right-associative* version of `fold()`, see [`DoubleEndedIterator::rfold()`].\n\n # Note to Implementors\n\n Several of the other (forward) methods have default implementations in\n terms of this one, so try to implement this explicitly if it can\n do something better than the default `for` loop implementation.\n\n In particular, try to have this call `fold()` on the internal parts\n from which this iterator is composed.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n // the sum of all of the elements of the array\n let sum = a.iter().fold(0, |acc, x| acc + x);\n\n assert_eq!(sum, 6);\n ```\n\n Let's walk through each step of the iteration here:\n\n | element | acc | x | result |\n |---------|-----|---|--------|\n |         | 0   |   |        |\n | 1       | 0   | 1 | 1      |\n | 2       | 1   | 2 | 3      |\n | 3       | 3   | 3 | 6      |\n\n And so, our final result, `6`.\n\n This example demonstrates the left-associative nature of `fold()`:\n it builds a string, starting with an initial value\n and continuing with each element from the front until the back:\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let zero = \"0\".to_string();\n\n let result = numbers.iter().fold(zero, |acc, &x| {\n     format!(\"({acc} + {x})\")\n });\n\n assert_eq!(result, \"(((((0 + 1) + 2) + 3) + 4) + 5)\");\n ```\n It's common for people who haven't used iterators a lot to\n use a `for` loop with a list of things to build up a result. Those\n can be turned into `fold()`s:\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n ```\n let numbers = [1, 2, 3, 4, 5];\n\n let mut result = 0;\n\n // for loop:\n for i in &numbers {\n     result = result + i;\n }\n\n // fold:\n let result2 = numbers.iter().fold(0, |acc, &x| acc + x);\n\n // they're the same\n assert_eq!(result, result2);\n ```\n\n [`reduce()`]: Iterator::reduce\n",
      "adt": {}
    },
    "io::cursor::reserve_and_pad": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves the required space, and pads the vec with 0s if necessary.\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {}
    },
    "io::cursor::vec_write_all_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes the slice to the vec without allocating.\n\n # Safety\n\n `vec` must have `buf.len()` spare capacity.\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {}
    }
  },
  "adts": {
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4824, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 3938, kind: RigidTy(Adt(AdtDef(DefId { id: 6507, name: \"io::IoSlice\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) }, Not)) })])"
    ],
    "io::IoSlice": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::cursor::vec_write_all_vectored"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/cursor.rs:559:1: 587:2",
  "src": "fn vec_write_all_vectored<A>(\n    pos_mut: &mut u64,\n    vec: &mut Vec<u8, A>,\n    bufs: &[IoSlice<'_>],\n) -> io::Result<usize>\nwhere\n    A: Allocator,\n{\n    // For safety reasons, we don't want this sum to overflow ever.\n    // If this saturates, the reserve should panic to avoid any unsound writing.\n    let buf_len = bufs.iter().fold(0usize, |a, b| a.saturating_add(b.len()));\n    let mut pos = reserve_and_pad(pos_mut, vec, buf_len)?;\n\n    // Write the buf then progress the vec forward if necessary\n    // Safety: we have ensured that the capacity is available\n    // and that all bytes get written up to the last pos\n    unsafe {\n        for buf in bufs {\n            pos = vec_write_all_unchecked(pos, vec, buf);\n        }\n        if pos > vec.len() {\n            vec.set_len(pos);\n        }\n    }\n\n    // Bump us forward\n    *pos_mut += buf_len as u64;\n    Ok(buf_len)\n}",
  "mir": "fn io::cursor::vec_write_all_vectored(_1: &mut u64, _2: &mut alloc_crate::vec::Vec<u8, A>, _3: &[io::IoSlice<'_>]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let  _4: usize;\n    let mut _5: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _6: usize;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _8: core::result::Result<usize, io::error::Error>;\n    let mut _9: isize;\n    let  _10: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _11: usize;\n    let mut _12: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _13: core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _14: core::option::Option<&io::IoSlice<'_>>;\n    let mut _15: &mut core::slice::Iter<'_, io::IoSlice<'_>>;\n    let mut _16: isize;\n    let  _17: &io::IoSlice<'_>;\n    let mut _18: usize;\n    let mut _19: usize;\n    let  _20: &[u8];\n    let mut _21: bool;\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: &alloc_crate::vec::Vec<u8, A>;\n    let  _25: ();\n    let mut _26: usize;\n    let mut _27: u64;\n    let mut _28: (u64, bool);\n    debug pos_mut => _1;\n    debug vec => _2;\n    debug bufs => _3;\n    debug buf_len => _4;\n    debug pos => _6;\n    debug residual => _10;\n    debug val => _11;\n    debug iter => _13;\n    debug buf => _17;\n    bb0: {\n        StorageLive(_5);\n        _5 = core::slice::<impl [io::IoSlice<'_>]>::iter(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::fold::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/cursor.rs:569:44: 569:50}>(move _5, 0_usize, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/cursor.rs:569:44: 569:50}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = io::cursor::reserve_and_pad::<A>(_1, _2, _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_11);\n        _11 = ((_7 as variant#0).0: usize);\n        _6 = _11;\n        StorageDead(_11);\n        StorageDead(_7);\n        StorageLive(_12);\n        _12 = <&[io::IoSlice<'_>] as core::iter::IntoIterator>::into_iter(_3) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _10 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb22;\n    }\n    bb9: {\n        StorageLive(_13);\n        _13 = move _12;\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_14);\n        _15 = &mut _13;\n        _14 = <core::slice::Iter<'_, io::IoSlice<'_>> as core::iter::Iterator>::next(_15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _16 = discriminant(_14);\n        switchInt(move _16) -> [0: bb13, 1: bb12, otherwise: bb5];\n    }\n    bb12: {\n        _17 = ((_14 as variant#1).0: &io::IoSlice<'_>);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = _6;\n        _20 = <io::IoSlice<'_> as core::ops::Deref>::deref(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _6;\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &(*_2);\n        _23 = alloc_crate::vec::Vec::<u8, A>::len(move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        _18 = io::cursor::vec_write_all_unchecked::<A>(move _19, _2, _20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        _6 = move _18;\n        StorageDead(_18);\n        StorageDead(_14);\n        goto -> bb10;\n    }\n    bb16: {\n        StorageDead(_24);\n        _21 = Gt(move _22, move _23);\n        switchInt(move _21) -> [0: bb19, otherwise: bb17];\n    }\n    bb17: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_26);\n        _26 = _6;\n        _25 = alloc_crate::vec::Vec::<u8, A>::set_len(_2, move _26) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_26);\n        goto -> bb20;\n    }\n    bb19: {\n        StorageDead(_23);\n        StorageDead(_22);\n        goto -> bb20;\n    }\n    bb20: {\n        StorageDead(_21);\n        StorageLive(_27);\n        _27 = _4 as u64;\n        _28 = CheckedAdd((*_1), _27);\n        assert(!move (_28.1: bool), \"attempt to compute `{} + {}`, which would overflow\", (*_1), move _27) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        (*_1) = move (_28.0: u64);\n        StorageDead(_27);\n        _0 = core::result::Result::Ok(_4);\n        StorageDead(_6);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n}\n",
  "doc": " Resizing `write_all_vectored` implementation for [`Cursor`].\n\n Cursor is allowed to have a pre-allocated and initialised\n vector body, but with a position of 0. This means the [`Write`]\n will overwrite the contents of the vec.\n\n This also allows for the vec body to be empty, but with a position of N.\n This means that [`Write`] will pad the vec with 0 initially,\n before writing anything from that point\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}