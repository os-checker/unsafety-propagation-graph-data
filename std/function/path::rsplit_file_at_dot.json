{
  "name": "path::rsplit_file_at_dot",
  "safe": true,
  "callees": {
    "ffi::os_str::OsStr::as_encoded_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n string slice, use the [`OsStr::from_encoded_bytes_unchecked`] function.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n be treated as opaque and only comparable within the same Rust version built for the same\n target platform.  For example, sending the slice over the network or storing it in a file\n will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n and [`std::ffi`] for platform-specific, specified conversions.\n\n [`std::ffi`]: crate::ffi\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::rsplitn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over subslices separated by elements that match\n `pred` limited to returning at most `n` items. This starts at the end of\n the slice and works backwards. The matched element is not contained in\n the subslices.\n\n The last element returned, if any, will contain the remainder of the\n slice.\n\n # Examples\n\n Print the slice split once, starting from the end, by numbers divisible\n by 3 (i.e., `[50]`, `[10, 40, 30, 20]`):\n\n ```\n let v = [10, 40, 30, 20, 60, 50];\n\n for group in v.rsplitn(2, |num| *num % 3 == 0) {\n     println!(\"{group:?}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ],
    "core::slice::RSplitN": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 2355,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:308:1: 330:2",
  "src": "fn rsplit_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n    if file.as_encoded_bytes() == b\"..\" {\n        return (Some(file), None);\n    }\n\n    // The unsafety here stems from converting between &OsStr and &[u8]\n    // and back. This is safe to do because (1) we only look at ASCII\n    // contents of the encoding and (2) new &OsStr values are produced\n    // only from ASCII-bounded slices of existing &OsStr values.\n    let mut iter = file.as_encoded_bytes().rsplitn(2, |b| *b == b'.');\n    let after = iter.next();\n    let before = iter.next();\n    if before == Some(b\"\") {\n        (Some(file), None)\n    } else {\n        unsafe {\n            (\n                before.map(|s| OsStr::from_encoded_bytes_unchecked(s)),\n                after.map(|s| OsStr::from_encoded_bytes_unchecked(s)),\n            )\n        }\n    }\n}",
  "mir": "fn path::rsplit_file_at_dot(_1: &ffi::os_str::OsStr) -> (core::option::Option<&ffi::os_str::OsStr>, core::option::Option<&ffi::os_str::OsStr>) {\n    let mut _0: (core::option::Option<&ffi::os_str::OsStr>, core::option::Option<&ffi::os_str::OsStr>);\n    let mut _2: bool;\n    let mut _3: &&[u8];\n    let  _4: &[u8];\n    let mut _5: &&[u8; 2];\n    let mut _6: core::option::Option<&ffi::os_str::OsStr>;\n    let mut _7: core::option::Option<&ffi::os_str::OsStr>;\n    let mut _8: core::slice::RSplitN<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}>;\n    let  _9: &[u8];\n    let  _10: core::option::Option<&[u8]>;\n    let mut _11: &mut core::slice::RSplitN<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}>;\n    let  _12: core::option::Option<&[u8]>;\n    let mut _13: &mut core::slice::RSplitN<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}>;\n    let mut _14: bool;\n    let mut _15: &core::option::Option<&[u8]>;\n    let mut _16: &core::option::Option<&[u8]>;\n    let mut _17: core::option::Option<&ffi::os_str::OsStr>;\n    let mut _18: core::option::Option<&ffi::os_str::OsStr>;\n    let mut _19: core::option::Option<&ffi::os_str::OsStr>;\n    let mut _20: core::option::Option<&ffi::os_str::OsStr>;\n    debug file => _1;\n    debug iter => _8;\n    debug after => _10;\n    debug before => _12;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = ffi::os_str::OsStr::as_encoded_bytes(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &_4;\n        StorageLive(_5);\n        _5 = path::rsplit_file_at_dot::promoted[1];\n        _2 = <&[u8] as core::cmp::PartialEq<&[u8; 2]>>::eq(move _3, move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _2) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        _6 = core::option::Option::Some(_1);\n        StorageLive(_7);\n        _7 = core::option::Option::None;\n        _0 = (move _6, move _7);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_2);\n        goto -> bb15;\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_8);\n        _9 = ffi::os_str::OsStr::as_encoded_bytes(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _8 = core::slice::<impl [u8]>::rsplitn::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}>(_9, 2_usize, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_11);\n        _11 = &mut _8;\n        _10 = <core::slice::RSplitN<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}> as core::iter::Iterator>::next(move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        StorageLive(_13);\n        _13 = &mut _8;\n        _12 = <core::slice::RSplitN<'_, u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:317:55: 317:58}> as core::iter::Iterator>::next(move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_12;\n        StorageLive(_16);\n        _16 = path::rsplit_file_at_dot::promoted[0];\n        _14 = <core::option::Option<&[u8]> as core::cmp::PartialEq>::eq(move _15, move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _14) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_17);\n        _17 = core::option::Option::Some(_1);\n        StorageLive(_18);\n        _18 = core::option::Option::None;\n        _0 = (move _17, move _18);\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb14;\n    }\n    bb11: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageLive(_19);\n        _19 = core::option::Option::<&[u8]>::map::<&ffi::os_str::OsStr, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:325:28: 325:31}>(_12, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:325:28: 325:31}) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_20);\n        _20 = core::option::Option::<&[u8]>::map::<&ffi::os_str::OsStr, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:326:27: 326:30}>(_10, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:326:27: 326:30}) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _0 = (move _19, move _20);\n        StorageDead(_20);\n        StorageDead(_19);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_14);\n        StorageDead(_8);\n        goto -> bb15;\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}