{
  "name": "sys::thread_local::native::eager::Storage::<T>::initialize",
  "safe": false,
  "callees": {
    "core::ptr::from_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a reference to a raw pointer.\n\n For `r: &T`, `from_ref(r)` is equivalent to `r as *const T` (except for the caveat noted below),\n but is a bit safer since it will never silently change type or mutability, in particular if the\n code is refactored.\n\n The caller must ensure that the pointee outlives the pointer this function returns, or else it\n will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to is never\n written to (except inside an `UnsafeCell`) using this pointer or any pointer derived from it. If\n you need to mutate the pointee, use [`from_mut`]. Specifically, to turn a mutable reference `m:\n &mut T` into `*const T`, prefer `from_mut(m).cast_const()` to obtain a pointer that can later be\n used for mutation.\n\n ## Interaction with lifetime extension\n\n Note that this has subtle interactions with the rules for lifetime extension of temporaries in\n tail expressions. This code is valid, albeit in a non-obvious way:\n ```rust\n # type T = i32;\n # fn foo() -> T { 42 }\n // The temporary holding the return value of `foo` has its lifetime extended,\n // because the surrounding expression involves no function call.\n let p = &foo() as *const T;\n unsafe { p.read() };\n ```\n Naively replacing the cast with `from_ref` is not valid:\n ```rust,no_run\n # use std::ptr;\n # type T = i32;\n # fn foo() -> T { 42 }\n // The temporary holding the return value of `foo` does *not* have its lifetime extended,\n // because the surrounding expression involves a function call.\n let p = ptr::from_ref(&foo());\n unsafe { p.read() }; // UB! Reading from a dangling pointer ⚠️\n ```\n The recommended way to write this code is to avoid relying on lifetime extension\n when raw pointers are involved:\n ```rust\n # use std::ptr;\n # type T = i32;\n # fn foo() -> T { 42 }\n let x = foo();\n let p = ptr::from_ref(&x);\n unsafe { p.read() };\n ```\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes constness without changing the type.\n\n This is a bit safer than `as` because it wouldn't silently change the type if the code is\n refactored.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "sys::thread_local::native::eager::destroy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transition an `Alive` TLS variable into the `Destroyed` state, dropping its\n value.\n\n # Safety\n * Must only be called at thread destruction.\n * `ptr` must point to an instance of `Storage` with `Alive` state and be\n   valid for accessing that instance.\n",
      "adt": {}
    },
    "sys::thread_local::destructors::linux_like::register": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::cell::Cell::<T>::set": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the contained value.\n\n # Examples\n\n ```\n use std::cell::Cell;\n\n let c = Cell::new(5);\n\n c.set(10);\n ```\n",
      "adt": {}
    },
    "core::cell::UnsafeCell::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the wrapped value.\n\n This can be cast to a pointer of any kind. When creating references, you must uphold the\n aliasing rules; see [the type-level docs][UnsafeCell#aliasing-rules] for more discussion and\n caveats.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let uc = UnsafeCell::new(5);\n\n let five = uc.get();\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::thread_local::native::eager::Storage": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::cell::Cell": [
      "Ref"
    ],
    "sys::thread_local::native::eager::State": [
      "Plain"
    ],
    "core::cell::UnsafeCell": [
      "Ref"
    ]
  },
  "path": 4401,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/eager.rs:43:5: 54:6",
  "src": "unsafe fn initialize(&self) -> *const T {\n        // Register the destructor\n\n        // SAFETY:\n        // The caller guarantees that `self` will be valid until thread destruction.\n        unsafe {\n            destructors::register(ptr::from_ref(self).cast_mut().cast(), destroy::<T>);\n        }\n\n        self.state.set(State::Alive);\n        self.val.get()\n    }",
  "mir": "fn sys::thread_local::native::eager::Storage::<T>::initialize(_1: &sys::thread_local::native::eager::Storage<T>) -> *const T {\n    let mut _0: *const T;\n    let  _2: ();\n    let mut _3: *mut u8;\n    let mut _4: *mut sys::thread_local::native::eager::Storage<T>;\n    let mut _5: *const sys::thread_local::native::eager::Storage<T>;\n    let mut _6: unsafe extern \"C\" fn(*mut u8);\n    let  _7: ();\n    let mut _8: &core::cell::Cell<sys::thread_local::native::eager::State>;\n    let mut _9: sys::thread_local::native::eager::State;\n    let mut _10: *mut T;\n    let mut _11: &core::cell::UnsafeCell<T>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = core::ptr::from_ref::<sys::thread_local::native::eager::Storage<T>>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = core::ptr::const_ptr::<impl *const sys::thread_local::native::eager::Storage<T>>::cast_mut(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = core::ptr::mut_ptr::<impl *mut sys::thread_local::native::eager::Storage<T>>::cast::<u8>(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = sys::thread_local::native::eager::destroy::<T> as unsafe extern \"C\" fn(*mut u8);\n        _2 = sys::thread_local::destructors::linux_like::register(move _3, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageLive(_8);\n        _8 = &((*_1).1: core::cell::Cell<sys::thread_local::native::eager::State>);\n        StorageLive(_9);\n        _9 = sys::thread_local::native::eager::State::Alive;\n        _7 = core::cell::Cell::<sys::thread_local::native::eager::State>::set(move _8, move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &((*_1).0: core::cell::UnsafeCell<T>);\n        _10 = core::cell::UnsafeCell::<T>::get(move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _0 = move _10 as *const T;\n        StorageDead(_11);\n        StorageDead(_10);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}