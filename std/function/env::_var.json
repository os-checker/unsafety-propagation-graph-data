{
  "name": "env::_var",
  "safe": true,
  "callees": {
    "env::var_os": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fetches the environment variable `key` from the current process, returning\n [`None`] if the variable isn't set or if there is another error.\n\n It may return `None` if the environment variable's name contains\n the equal sign character (`=`) or the NUL character.\n\n Note that this function will not check if the environment variable\n is valid Unicode. If you want to have an error on invalid UTF-8,\n use the [`var`] function instead.\n\n # Examples\n\n ```\n use std::env;\n\n let key = \"HOME\";\n match env::var_os(key) {\n     Some(val) => println!(\"{key}: {val:?}\"),\n     None => println!(\"{key} is not defined in the environment.\")\n }\n ```\n\n If expecting a delimited variable (such as `PATH`), [`split_paths`]\n can be used to separate items.\n",
      "adt": {
        "core::option::Option": "Constructor",
        "ffi::os_str::OsString": "Constructor"
      }
    },
    "ffi::os_str::OsString::into_string": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the `OsString` into a [`String`] if it contains valid Unicode data.\n\n On failure, ownership of the original `OsString` is returned.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let os_string = OsString::from(\"foo\");\n let string = os_string.into_string();\n assert_eq!(string, Ok(String::from(\"foo\")));\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "ffi::os_str::OsString": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "env::VarError::NotUnicode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The specified environment variable was found, but it did not contain\n valid unicode data. The found data is returned as a payload of this\n variant.\n",
      "adt": {}
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])"
    ],
    "env::VarError": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::env::_var"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:226:1: 231:2",
  "src": "fn _var(key: &OsStr) -> Result<String, VarError> {\n    match var_os(key) {\n        Some(s) => s.into_string().map_err(VarError::NotUnicode),\n        None => Err(VarError::NotPresent),\n    }\n}",
  "mir": "fn env::_var(_1: &ffi::os_str::OsStr) -> core::result::Result<alloc_crate::string::String, env::VarError> {\n    let mut _0: core::result::Result<alloc_crate::string::String, env::VarError>;\n    let mut _2: core::option::Option<ffi::os_str::OsString>;\n    let mut _3: isize;\n    let  _4: ffi::os_str::OsString;\n    let mut _5: core::result::Result<alloc_crate::string::String, ffi::os_str::OsString>;\n    let mut _6: env::VarError;\n    debug key => _1;\n    debug s => _4;\n    bb0: {\n        StorageLive(_2);\n        _2 = env::var_os::<&ffi::os_str::OsStr>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = discriminant(_2);\n        switchInt(move _3) -> [0: bb3, 1: bb4, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        StorageLive(_6);\n        _6 = env::VarError::NotPresent;\n        _0 = core::result::Result::Err(move _6);\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb4: {\n        _4 = move ((_2 as variant#1).0: ffi::os_str::OsString);\n        StorageLive(_5);\n        _5 = ffi::os_str::OsString::into_string(_4) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _0 = core::result::Result::<alloc_crate::string::String, ffi::os_str::OsString>::map_err::<env::VarError, fn(ffi::os_str::OsString) -> env::VarError {env::VarError::NotUnicode}>(move _5, env::VarError::NotUnicode) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}