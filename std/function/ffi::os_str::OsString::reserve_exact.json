{
  "name": "ffi::os_str::OsString::reserve_exact",
  "safe": true,
  "callees": {
    "sys::os_str::bytes::Buf::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::os_str::bytes::Buf": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "sys::os_str::bytes::Buf": [
      "MutRef"
    ],
    "ffi::os_str::OsString": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": 1044,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/ffi/os_str.rs:439:5: 441:6",
  "src": "pub fn reserve_exact(&mut self, additional: usize) {\n        self.inner.reserve_exact(additional)\n    }",
  "mir": "fn ffi::os_str::OsString::reserve_exact(_1: &mut ffi::os_str::OsString, _2: usize) -> () {\n    let mut _0: ();\n    let mut _3: &mut sys::os_str::bytes::Buf;\n    debug self => _1;\n    debug additional => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: sys::os_str::bytes::Buf);\n        _0 = sys::os_str::bytes::Buf::reserve_exact(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Reserves the minimum capacity for at least `additional` more capacity to\n be inserted in the given `OsString`. Does nothing if the capacity is\n already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`reserve`] if future insertions are expected.\n\n [`reserve`]: OsString::reserve\n\n See the main `OsString` documentation information about encoding and capacity units.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut s = OsString::new();\n s.reserve_exact(10);\n assert!(s.capacity() >= 10);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}