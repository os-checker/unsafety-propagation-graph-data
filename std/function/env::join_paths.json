{
  "name": "env::join_paths",
  "safe": true,
  "callees": {
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::os::join_paths": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 891,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:577:1: 583:2",
  "src": "pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\nwhere\n    I: IntoIterator<Item = T>,\n    T: AsRef<OsStr>,\n{\n    os_imp::join_paths(paths.into_iter()).map_err(|e| JoinPathsError { inner: e })\n}",
  "mir": "fn env::join_paths(_1: I) -> core::result::Result<ffi::os_str::OsString, env::JoinPathsError> {\n    let mut _0: core::result::Result<ffi::os_str::OsString, env::JoinPathsError>;\n    let mut _2: core::result::Result<ffi::os_str::OsString, sys::pal::unix::os::JoinPathsError>;\n    let mut _3: <I as core::iter::IntoIterator>::IntoIter;\n    debug paths => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = <I as core::iter::IntoIterator>::into_iter(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = sys::pal::unix::os::join_paths::<<I as core::iter::IntoIterator>::IntoIter, T>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = core::result::Result::<ffi::os_str::OsString, sys::pal::unix::os::JoinPathsError>::map_err::<env::JoinPathsError, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:582:51: 582:54}>(move _2, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:582:51: 582:54}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Joins a collection of [`Path`]s appropriately for the `PATH`\n environment variable.\n\n # Errors\n\n Returns an [`Err`] (containing an error message) if one of the input\n [`Path`]s contains an invalid character for constructing the `PATH`\n variable (a double quote on Windows or a colon on Unix), or if the system\n does not have a `PATH`-like variable (e.g. UEFI or WASI).\n\n # Examples\n\n Joining paths on a Unix-like platform:\n\n ```\n use std::env;\n use std::ffi::OsString;\n use std::path::Path;\n\n fn main() -> Result<(), env::JoinPathsError> {\n # if cfg!(unix) {\n     let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bin\")];\n     let path_os_string = env::join_paths(paths.iter())?;\n     assert_eq!(path_os_string, OsString::from(\"/bin:/usr/bin\"));\n # }\n     Ok(())\n }\n ```\n\n Joining a path containing a colon on a Unix-like platform results in an\n error:\n\n ```\n # if cfg!(unix) {\n use std::env;\n use std::path::Path;\n\n let paths = [Path::new(\"/bin\"), Path::new(\"/usr/bi:n\")];\n assert!(env::join_paths(paths.iter()).is_err());\n # }\n ```\n\n Using `env::join_paths()` with [`env::split_paths()`] to append an item to\n the `PATH` environment variable:\n\n ```\n use std::env;\n use std::path::PathBuf;\n\n fn main() -> Result<(), env::JoinPathsError> {\n     if let Some(path) = env::var_os(\"PATH\") {\n         let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n         paths.push(PathBuf::from(\"/home/xyz/bin\"));\n         let new_path = env::join_paths(paths)?;\n         unsafe { env::set_var(\"PATH\", &new_path); }\n     }\n\n     Ok(())\n }\n ```\n\n [`env::split_paths()`]: split_paths\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}