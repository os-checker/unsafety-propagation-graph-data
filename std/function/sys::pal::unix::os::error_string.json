{
  "name": "sys::pal::unix::os::error_string",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::os::error_string::strerror_r": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    },
    "core::ffi::CStr::to_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice.\n\n The returned slice will **not** contain the trailing nul terminator that this C\n string has.\n\n > **Note**: This method is currently implemented as a constant-time\n > cast, but it is planned to alter its definition in the future to\n > perform the length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes(), b\"foo\");\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::from_utf8_lossy": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to a string, including invalid characters.\n\n Strings are made of bytes ([`u8`]), and a slice of bytes\n ([`&[u8]`][byteslice]) is made of bytes, so this function converts\n between the two. Not all byte slices are valid strings, however: strings\n are required to be valid UTF-8. During this conversion,\n `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD], which looks like this: ï¿½\n\n [byteslice]: prim@slice\n [U+FFFD]: core::char::REPLACEMENT_CHARACTER\n\n If you are sure that the byte slice is valid UTF-8, and you don't want\n to incur the overhead of the conversion, there is an unsafe version\n of this function, [`from_utf8_unchecked`], which has the same behavior\n but skips the checks.\n\n [`from_utf8_unchecked`]: String::from_utf8_unchecked\n\n This function returns a [`Cow<'a, str>`]. If our byte slice is invalid\n UTF-8, then we need to insert the replacement characters, which will\n change the size of the string, and hence, require a `String`. But if\n it's already valid UTF-8, we don't need a new allocation. This return\n type allows us to handle both cases.\n\n [`Cow<'a, str>`]: crate::borrow::Cow \"borrow::Cow\"\n\n # Examples\n\n Basic usage:\n\n ```\n // some bytes, in a vector\n let sparkle_heart = vec![240, 159, 146, 150];\n\n let sparkle_heart = String::from_utf8_lossy(&sparkle_heart);\n\n assert_eq!(\"ðŸ’–\", sparkle_heart);\n ```\n\n Incorrect bytes:\n\n ```\n // some invalid bytes\n let input = b\"Hello \\xF0\\x90\\x80World\";\n let output = String::from_utf8_lossy(input);\n\n assert_eq!(\"Hello ï¿½World\", output);\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "alloc_crate::borrow::Cow": [
      "Plain"
    ],
    "alloc_crate::string::String": [
      "Plain"
    ]
  },
  "path": 3913,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/os.rs:114:1: 144:2",
  "src": "pub fn error_string(errno: i32) -> String {\n    unsafe extern \"C\" {\n        #[cfg_attr(\n            all(\n                any(\n                    target_os = \"linux\",\n                    target_os = \"hurd\",\n                    target_env = \"newlib\",\n                    target_os = \"cygwin\"\n                ),\n                not(target_env = \"ohos\")\n            ),\n            link_name = \"__xpg_strerror_r\"\n        )]\n        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t) -> c_int;\n    }\n\n    let mut buf = [0 as c_char; TMPBUF_SZ];\n\n    let p = buf.as_mut_ptr();\n    unsafe {\n        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n            panic!(\"strerror_r failure\");\n        }\n\n        let p = p as *const _;\n        // We can't always expect a UTF-8 environment. When we don't get that luxury,\n        // it's better to give a low-quality error message than none at all.\n        String::from_utf8_lossy(CStr::from_ptr(p).to_bytes()).into()\n    }\n}",
  "mir": "fn sys::pal::unix::os::error_string(_1: i32) -> alloc_crate::string::String {\n    let mut _0: alloc_crate::string::String;\n    let mut _2: [u8; 128];\n    let  _3: *mut u8;\n    let mut _4: &mut [u8];\n    let mut _5: &mut [u8; 128];\n    let mut _6: bool;\n    let mut _7: i32;\n    let mut _8: usize;\n    let mut _9: &[u8];\n    let mut _10: &[u8; 128];\n    let  _11: !;\n    let mut _12: core::fmt::Arguments<'_>;\n    let mut _13: *const u8;\n    let mut _14: alloc_crate::borrow::Cow<'_, str>;\n    let  _15: &[u8];\n    let  _16: &core::ffi::CStr;\n    debug errno => _1;\n    debug buf => _2;\n    debug p => _3;\n    debug p => _13;\n    bb0: {\n        StorageLive(_2);\n        _2 = [0_u8; 128];\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut _2;\n        _4 = move _5 as &mut [u8];\n        StorageDead(_5);\n        _3 = core::slice::<impl [u8]>::as_mut_ptr(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &_2;\n        _9 = move _10 as &[u8];\n        StorageDead(_10);\n        _8 = PtrMetadata(move _9);\n        StorageDead(_9);\n        _7 = sys::pal::unix::os::error_string::strerror_r(_1, _3, move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _6 = Lt(move _7, 0_i32);\n        switchInt(move _6) -> [0: bb5, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_7);\n        StorageLive(_12);\n        _12 = core::fmt::Arguments::<'_>::from_str(\"strerror_r failure\") -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _11 = core::panicking::panic_fmt(move _12) -> unwind unreachable;\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        _13 = _3 as *const u8;\n        StorageLive(_14);\n        _16 = core::ffi::CStr::from_ptr::<'_>(_13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _15 = core::ffi::CStr::to_bytes(_16) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _14 = alloc_crate::string::String::from_utf8_lossy(_15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _0 = <alloc_crate::borrow::Cow<'_, str> as core::convert::Into<alloc_crate::string::String>>::into(move _14) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Gets a detailed string description for the given error number.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}