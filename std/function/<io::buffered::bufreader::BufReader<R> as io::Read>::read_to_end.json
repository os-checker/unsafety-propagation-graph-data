{
  "name": "<io::buffered::bufreader::BufReader<R> as io::Read>::read_to_end",
  "safe": true,
  "callees": {
    "io::buffered::bufreader::BufReader::<R>::buffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a reference to the internally buffered data.\n\n Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n\n [`fill_buf`]: BufRead::fill_buf\n\n # Examples\n\n ```no_run\n use std::io::{BufReader, BufRead};\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let f = File::open(\"log.txt\")?;\n     let mut reader = BufReader::new(f);\n     assert!(reader.buffer().is_empty());\n\n     if reader.fill_buf()?.len() > 0 {\n         assert!(!reader.buffer().is_empty());\n     }\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::buffered::bufreader::BufReader": "ImmutableAsArgument"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::try_reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tries to reserve capacity for at least `additional` more elements to be inserted\n in the given `Vec<T>`. The collection may reserve more space to speculatively avoid\n frequent reallocations. After calling `try_reserve`, capacity will be\n greater than or equal to `self.len() + additional` if it returns\n `Ok(())`. Does nothing if capacity is already sufficient. This method\n preserves the contents even if an error occurs.\n\n # Errors\n\n If the capacity overflows, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n\n fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     let mut output = Vec::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve(data.len())?;\n\n     // Now we know this can't OOM in the middle of our complex work\n     output.extend(data.iter().map(|&val| {\n         val * 2 + 5 // very complicated\n     }));\n\n     Ok(output)\n }\n # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::extend_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clones and appends all elements in a slice to the `Vec`.\n\n Iterates over the slice `other`, clones each element, and then appends\n it to this `Vec`. The `other` slice is traversed in-order.\n\n Note that this function is the same as [`extend`],\n except that it also works with slice elements that are Clone but not Copy.\n If Rust gets specialization this function may be deprecated.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.extend_from_slice(&[2, 3, 4]);\n assert_eq!(vec, [1, 2, 3, 4]);\n ```\n\n [`extend`]: Vec::extend\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::buffered::bufreader::BufReader::<R>::discard_buffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invalidates all data in the internal buffer.\n",
      "adt": {
        "io::buffered::bufreader::BufReader": "MutableAsArgument"
      }
    },
    "io::Read::read_to_end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until EOF in this source, placing them into `buf`.\n\n All bytes read from this source will be appended to the specified buffer\n `buf`. This function will continuously call [`read()`] to append more data to\n `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n non-[`ErrorKind::Interrupted`] kind.\n\n If successful, this function will return the total number of bytes read.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If any other read error is encountered then this function immediately\n returns. Any bytes which have already been read will be appended to\n `buf`.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read()`]: Read::read\n [`Ok(0)`]: Ok\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = Vec::new();\n\n     // read the whole file\n     f.read_to_end(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read`] convenience function for reading from a\n file.)\n\n [`std::fs::read`]: crate::fs::read\n\n ## Implementing `read_to_end`\n\n When implementing the `io::Read` trait, it is recommended to allocate\n memory using [`Vec::try_reserve`]. However, this behavior is not guaranteed\n by all implementations, and `read_to_end` may not handle out-of-memory\n situations gracefully.\n\n ```no_run\n # use std::io::{self, BufRead};\n # struct Example { example_datasource: io::Empty } impl Example {\n # fn get_some_data_for_the_example(&self) -> &'static [u8] { &[] }\n fn read_to_end(&mut self, dest_vec: &mut Vec<u8>) -> io::Result<usize> {\n     let initial_vec_len = dest_vec.len();\n     loop {\n         let src_buf = self.example_datasource.fill_buf()?;\n         if src_buf.is_empty() {\n             break;\n         }\n         dest_vec.try_reserve(src_buf.len())?;\n         dest_vec.extend_from_slice(src_buf);\n\n         // Any irreversible side effects should happen after `try_reserve` succeeds,\n         // to avoid losing data on allocation error.\n         let read = src_buf.len();\n         self.example_datasource.consume(read);\n     }\n     Ok(dest_vec.len() - initial_vec_len)\n }\n # }\n ```\n\n # Usage Notes\n\n `read_to_end` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_end` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`Vec::try_reserve`]: crate::vec::Vec::try_reserve\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "io::buffered::bufreader::BufReader": [
      "Ref",
      "Deref",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3680, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 1482, kind: RigidTy(Adt(AdtDef(DefId { id: 5039, name: \"alloc_crate::collections::TryReserveError\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::buffered::bufreader::BufReader<R> as io::Read>::read_to_end"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufreader.rs:401:5: 408:6",
  "src": "fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n        let inner_buf = self.buffer();\n        buf.try_reserve(inner_buf.len())?;\n        buf.extend_from_slice(inner_buf);\n        let nread = inner_buf.len();\n        self.discard_buffer();\n        Ok(nread + self.inner.read_to_end(buf)?)\n    }",
  "mir": "fn <io::buffered::bufreader::BufReader<R> as io::Read>::read_to_end(_1: &mut io::buffered::bufreader::BufReader<R>, _2: &mut alloc_crate::vec::Vec<u8>) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let  _3: &[u8];\n    let mut _4: &io::buffered::bufreader::BufReader<R>;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>;\n    let mut _6: core::result::Result<(), alloc_crate::collections::TryReserveError>;\n    let mut _7: usize;\n    let mut _8: isize;\n    let  _9: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>;\n    let  _10: ();\n    let  _11: usize;\n    let  _12: ();\n    let mut _13: usize;\n    let mut _14: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _15: core::result::Result<usize, io::error::Error>;\n    let mut _16: &mut R;\n    let mut _17: isize;\n    let  _18: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _19: usize;\n    let mut _20: (usize, bool);\n    debug self => _1;\n    debug buf => _2;\n    debug inner_buf => _3;\n    debug residual => _9;\n    debug val => ();\n    debug nread => _11;\n    debug residual => _18;\n    debug val => _19;\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = io::buffered::bufreader::BufReader::<R>::buffer(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = PtrMetadata(_3);\n        _6 = alloc_crate::vec::Vec::<u8>::try_reserve(_2, move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = <core::result::Result<(), alloc_crate::collections::TryReserveError> as core::ops::Try>::branch(move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageDead(_5);\n        _10 = alloc_crate::vec::Vec::<u8>::extend_from_slice(_2, _3) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _9 = move ((_5 as variant#1).0: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>>::from_residual(_9) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_5);\n        goto -> bb16;\n    }\n    bb8: {\n        _11 = PtrMetadata(_3);\n        _12 = io::buffered::bufreader::BufReader::<R>::discard_buffer(_1) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut ((*_1).1: R);\n        _15 = <R as io::Read>::read_to_end(move _16, _2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_16);\n        _14 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        _17 = discriminant(_14);\n        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb4];\n    }\n    bb12: {\n        _19 = ((_14 as variant#0).0: usize);\n        _20 = CheckedAdd(_11, _19);\n        assert(!move (_20.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _11, _19) -> [success: bb15, unwind unreachable];\n    }\n    bb13: {\n        _18 = move ((_14 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_18) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb16;\n    }\n    bb15: {\n        _13 = move (_20.0: usize);\n        _0 = core::result::Result::Ok(move _13);\n        StorageDead(_14);\n        StorageDead(_13);\n        goto -> bb17;\n    }\n    bb16: {\n        goto -> bb17;\n    }\n    bb17: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}