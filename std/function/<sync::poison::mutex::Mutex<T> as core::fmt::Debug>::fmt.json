{
  "name": "<sync::poison::mutex::Mutex<T> as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "sync::poison::mutex::Mutex::<T>::try_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to acquire this lock.\n\n If the lock could not be acquired at this time, then [`Err`] is returned.\n Otherwise, an RAII guard is returned. The lock will be unlocked when the\n guard is dropped.\n\n This function does not block.\n\n # Errors\n\n If another user of this mutex panicked while holding the mutex, then\n this call will return the [`Poisoned`] error if the mutex would\n otherwise be acquired. An acquired lock guard will be contained\n in the returned error.\n\n If the mutex could not be acquired because it is already locked, then\n this call will return the [`WouldBlock`] error.\n\n [`Poisoned`]: TryLockError::Poisoned\n [`WouldBlock`]: TryLockError::WouldBlock\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     let mut lock = c_mutex.try_lock();\n     if let Ok(ref mut mutex) = lock {\n         **mutex = 10;\n     } else {\n         println!(\"try_lock failed\");\n     }\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock().unwrap(), 10);\n ```\n",
      "adt": {
        "sync::poison::mutex::Mutex": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "sync::poison::PoisonError::<T>::get_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reaches into this error indicating that a lock is poisoned, returning a\n reference to the associated data.\n",
      "adt": {
        "sync::poison::PoisonError": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish_non_exhaustive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marks the struct as non-exhaustive, indicating to the reader that there are some other\n fields that are not shown in the debug representation.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     hidden: f32,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .finish_non_exhaustive() // Show that some other field(s) exist.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n     \"Bar { bar: 10, .. }\",\n );\n ```\n",
      "adt": {}
    },
    "sync::poison::Flag::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::Flag": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "sync::poison::mutex::Mutex": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12151, kind: RigidTy(Adt(AdtDef(DefId { id: 9938, name: \"sync::poison::TryLockError\" }), GenericArgs([Type(Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12151, kind: RigidTy(Adt(AdtDef(DefId { id: 9938, name: \"sync::poison::TryLockError\" }), GenericArgs([Type(Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12071, kind: RigidTy(Adt(AdtDef(DefId { id: 9910, name: \"sync::poison::PoisonError\" }), GenericArgs([Type(Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "sync::poison::PoisonError": [
      "Plain",
      "Ref"
    ],
    "sync::poison::mutex::MutexGuard": [
      "Ref",
      "Plain"
    ],
    "sync::poison::Flag": [
      "Ref"
    ]
  },
  "path": 3214,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/mutex.rs:700:5: 715:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut d = f.debug_struct(\"Mutex\");\n        match self.try_lock() {\n            Ok(guard) => {\n                d.field(\"data\", &&*guard);\n            }\n            Err(TryLockError::Poisoned(err)) => {\n                d.field(\"data\", &&**err.get_ref());\n            }\n            Err(TryLockError::WouldBlock) => {\n                d.field(\"data\", &\"<locked>\");\n            }\n        }\n        d.field(\"poisoned\", &self.poison.get());\n        d.finish_non_exhaustive()\n    }",
  "mir": "fn <sync::poison::mutex::Mutex<T> as core::fmt::Debug>::fmt(_1: &sync::poison::mutex::Mutex<T>, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: core::fmt::DebugStruct<'_, '_>;\n    let mut _4: &str;\n    let mut _5: core::result::Result<sync::poison::mutex::MutexGuard<'_, T>, sync::poison::TryLockError<sync::poison::mutex::MutexGuard<'_, T>>>;\n    let mut _6: isize;\n    let mut _7: isize;\n    let  _8: sync::poison::mutex::MutexGuard<'_, T>;\n    let  _9: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _10: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _11: &str;\n    let mut _12: &dyn core::fmt::Debug;\n    let  _13: &&T;\n    let  _14: &T;\n    let  _15: &T;\n    let mut _16: &sync::poison::mutex::MutexGuard<'_, T>;\n    let  _17: sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, T>>;\n    let  _18: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _19: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _20: &str;\n    let mut _21: &dyn core::fmt::Debug;\n    let  _22: &&T;\n    let  _23: &T;\n    let  _24: &T;\n    let  _25: &sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _26: &sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, T>>;\n    let  _27: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _28: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _29: &str;\n    let mut _30: &dyn core::fmt::Debug;\n    let  _31: &&str;\n    let  _32: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _33: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _34: &str;\n    let mut _35: &dyn core::fmt::Debug;\n    let  _36: &bool;\n    let  _37: bool;\n    let mut _38: &sync::poison::Flag;\n    let mut _39: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _40: isize;\n    debug self => _1;\n    debug f => _2;\n    debug d => _3;\n    debug guard => _8;\n    debug err => _17;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = \"Mutex\";\n        _3 = core::fmt::Formatter::<'_>::debug_struct(_2, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = sync::poison::mutex::Mutex::<T>::try_lock(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb7, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _6 = discriminant(((_5 as variant#1).0: sync::poison::TryLockError<sync::poison::mutex::MutexGuard<'_, T>>));\n        switchInt(move _6) -> [0: bb6, 1: bb5, otherwise: bb3];\n    }\n    bb5: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &mut _3;\n        StorageLive(_29);\n        _29 = \"data\";\n        StorageLive(_30);\n        _31 = <sync::poison::mutex::Mutex<T> as core::fmt::Debug>::fmt::promoted[0];\n        _30 = _31 as &dyn core::fmt::Debug;\n        _27 = core::fmt::DebugStruct::<'_, '_>::field(move _28, move _29, move _30) -> [return: bb15, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_17);\n        _17 = move ((((_5 as variant#1).0: sync::poison::TryLockError<sync::poison::mutex::MutexGuard<'_, T>>) as variant#0).0: sync::poison::PoisonError<sync::poison::mutex::MutexGuard<'_, T>>);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _3;\n        StorageLive(_20);\n        _20 = \"data\";\n        StorageLive(_21);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_26);\n        _26 = &_17;\n        _25 = sync::poison::PoisonError::<sync::poison::mutex::MutexGuard<'_, T>>::get_ref(move _26) -> [return: bb11, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_8);\n        _8 = move ((_5 as variant#0).0: sync::poison::mutex::MutexGuard<'_, T>);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut _3;\n        StorageLive(_11);\n        _11 = \"data\";\n        StorageLive(_12);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_8;\n        _15 = <sync::poison::mutex::MutexGuard<'_, T> as core::ops::Deref>::deref(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _14 = _15;\n        _13 = &_14;\n        _12 = _13 as &dyn core::fmt::Debug;\n        _9 = core::fmt::DebugStruct::<'_, '_>::field(move _10, move _11, move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_9);\n        drop(_8) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_8);\n        goto -> bb21;\n    }\n    bb11: {\n        StorageDead(_26);\n        _24 = <sync::poison::mutex::MutexGuard<'_, T> as core::ops::Deref>::deref(_25) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _23 = _24;\n        _22 = &_23;\n        _21 = _22 as &dyn core::fmt::Debug;\n        _18 = core::fmt::DebugStruct::<'_, '_>::field(move _19, move _20, move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_18);\n        drop(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        goto -> bb21;\n    }\n    bb15: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_27);\n        goto -> bb21;\n    }\n    bb16: {\n        StorageDead(_38);\n        _36 = &_37;\n        _35 = _36 as &dyn core::fmt::Debug;\n        _32 = core::fmt::DebugStruct::<'_, '_>::field(move _33, move _34, move _35) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        StorageDead(_37);\n        StorageDead(_32);\n        StorageLive(_39);\n        _39 = &mut _3;\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish_non_exhaustive(move _39) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_39);\n        StorageDead(_3);\n        return;\n    }\n    bb19: {\n        StorageDead(_5);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &mut _3;\n        StorageLive(_34);\n        _34 = \"poisoned\";\n        StorageLive(_35);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &((*_1).1: sync::poison::Flag);\n        _37 = sync::poison::Flag::get(move _38) -> [return: bb16, unwind unreachable];\n    }\n    bb20: {\n        goto -> bb19;\n    }\n    bb21: {\n        _40 = discriminant(_5);\n        switchInt(move _40) -> [0: bb19, 1: bb20, otherwise: bb3];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}