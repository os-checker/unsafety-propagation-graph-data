{
  "name": "sys::process::unix::unix::<impl sys::process::unix::common::Command>::exec",
  "safe": true,
  "callees": {
    "sys::process::unix::common::Command::capture_env": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::common::Command::saw_nul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "io::error::Error::from_static_message": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Creates a new I/O error from a known kind of error as well as a constant\n message.\n\n This function does not allocate.\n\n You should not use this directly, and instead use the `const_error!`\n macro: `io::const_error!(ErrorKind::Something, \"some_message\")`.\n\n This function should maybe change to `from_static_message<const MSG: &'static\n str>(kind: ErrorKind)` in the future, when const generics allow that.\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::hint::must_use": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An identity function that causes an `unused_must_use` warning to be\n triggered if the given value is not used (returned, stored in a variable,\n etc) by the caller.\n\n This is primarily intended for use in macro-generated code, in which a\n [`#[must_use]` attribute][must_use] either on a type or a function would not\n be convenient.\n\n [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n\n # Example\n\n ```\n #![feature(hint_must_use)]\n\n use core::fmt;\n\n pub struct Error(/* ... */);\n\n #[macro_export]\n macro_rules! make_error {\n     ($($args:expr),*) => {\n         core::hint::must_use({\n             let error = $crate::make_error(core::format_args!($($args),*));\n             error\n         })\n     };\n }\n\n // Implementation detail of make_error! macro.\n #[doc(hidden)]\n pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n     Error(/* ... */)\n }\n\n fn demo() -> Option<Error> {\n     if true {\n         // Oops, meant to write `return Some(make_error!(\"...\"));`\n         Some(make_error!(\"...\"));\n     }\n     None\n }\n #\n # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n # fn main() {}\n ```\n\n In the above example, we'd like an `unused_must_use` lint to apply to the\n value created by `make_error!`. However, neither `#[must_use]` on a struct\n nor `#[must_use]` on a function is appropriate here, so the macro expands\n using `core::hint::must_use` instead.\n\n - We wouldn't want `#[must_use]` on the `struct Error` because that would\n   make the following unproblematic code trigger a warning:\n\n   ```\n   # struct Error;\n   #\n   fn f(arg: &str) -> Result<(), Error>\n   # { Ok(()) }\n\n   #[test]\n   fn t() {\n       // Assert that `f` returns error if passed an empty string.\n       // A value of type `Error` is unused here but that's not a problem.\n       f(\"\").unwrap_err();\n   }\n   ```\n\n - Using `#[must_use]` on `fn make_error` can't help because the return value\n   *is* used, as the right-hand side of a `let` statement. The `let`\n   statement looks useless but is in fact necessary for ensuring that\n   temporaries within the `format_args` expansion are not kept alive past the\n   creation of the `Error`, as keeping them alive past that point can cause\n   autotrait issues in async code:\n\n   ```\n   # #![feature(hint_must_use)]\n   #\n   # struct Error;\n   #\n   # macro_rules! make_error {\n   #     ($($args:expr),*) => {\n   #         core::hint::must_use({\n   #             // If `let` isn't used, then `f()` produces a non-Send future.\n   #             let error = make_error(core::format_args!($($args),*));\n   #             error\n   #         })\n   #     };\n   # }\n   #\n   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n   #     Error\n   # }\n   #\n   async fn f() {\n       // Using `let` inside the make_error expansion causes temporaries like\n       // `unsync()` to drop at the semicolon of that `let` statement, which\n       // is prior to the await point. They would otherwise stay around until\n       // the semicolon on *this* statement, which is after the await point,\n       // and the enclosing Future would not implement Send.\n       log(make_error!(\"look: {:p}\", unsync())).await;\n   }\n\n   async fn log(error: Error) {/* ... */}\n\n   // Returns something without a Sync impl.\n   fn unsync() -> *const () {\n       0 as *const ()\n   }\n   #\n   # fn test() {\n   #     fn assert_send(_: impl Send) {}\n   #     assert_send(f());\n   # }\n   ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::setup_io": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "io::error::Error": "Constructor",
        "sys::process::unix::common::Stdio": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sys::process::unix::common::ChildPipes": "Constructor"
      }
    },
    "sys::env::unix::env_read_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "core::option::Option::<T>::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&Option<T>` to `Option<&T>`.\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n reference to the value inside the original.\n\n [`map`]: Option::map\n [String]: ../../std/string/struct.String.html \"String\"\n [`String`]: ../../std/string/struct.String.html \"String\"\n\n ```\n let text: Option<String> = Some(\"Hello, world!\".to_string());\n // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n // then consume *that* with `map`, leaving `text` on the stack.\n let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n println!(\"still can print text: {text:?}\");\n ```\n",
      "adt": {}
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::process::unix::common::Command": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "sys::process::unix::common::Stdio": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 16779, kind: RigidTy(Tuple([Ty { id: 10101, kind: RigidTy(Adt(AdtDef(DefId { id: 9038, name: \"process::StdioPipes\" }), GenericArgs([]))) }, Ty { id: 16786, kind: RigidTy(Adt(AdtDef(DefId { id: 12176, name: \"sys::process::unix::common::ChildPipes\" }), GenericArgs([]))) }])) }), Field(1, Ty { id: 16786, kind: RigidTy(Adt(AdtDef(DefId { id: 12176, name: \"sys::process::unix::common::ChildPipes\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 16779, kind: RigidTy(Tuple([Ty { id: 10101, kind: RigidTy(Adt(AdtDef(DefId { id: 9038, name: \"process::StdioPipes\" }), GenericArgs([]))) }, Ty { id: 16786, kind: RigidTy(Adt(AdtDef(DefId { id: 12176, name: \"sys::process::unix::common::ChildPipes\" }), GenericArgs([]))) }])) }), Field(0, Ty { id: 10101, kind: RigidTy(Adt(AdtDef(DefId { id: 9038, name: \"process::StdioPipes\" }), GenericArgs([]))) })])"
    ],
    "sys::process::unix::common::ChildPipes": [
      "Plain"
    ],
    "sync::poison::rwlock::RwLockReadGuard": [
      "Plain"
    ]
  },
  "path": 4129,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:224:5: 245:6",
  "src": "pub fn exec(&mut self, default: Stdio) -> io::Error {\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return io::const_error!(ErrorKind::InvalidInput, \"nul byte found in provided data\");\n        }\n\n        match self.setup_io(default, true) {\n            Ok((_, theirs)) => {\n                unsafe {\n                    // Similar to when forking, we want to ensure that access to\n                    // the environment is synchronized, so make sure to grab the\n                    // environment lock before we try to exec.\n                    let _lock = sys::env::env_read_lock();\n\n                    let Err(e) = self.do_exec(theirs, envp.as_ref());\n                    e\n                }\n            }\n            Err(e) => e,\n        }\n    }",
  "mir": "fn sys::process::unix::unix::<impl sys::process::unix::common::Command>::exec(_1: &mut sys::process::unix::common::Command, _2: sys::process::unix::common::Stdio) -> io::error::Error {\n    let mut _0: io::error::Error;\n    let  _3: core::option::Option<sys::process::unix::common::cstring_array::CStringArray>;\n    let mut _4: bool;\n    let mut _5: &sys::process::unix::common::Command;\n    let mut _6: io::error::Error;\n    let mut _7: core::result::Result<(process::StdioPipes, sys::process::unix::common::ChildPipes), io::error::Error>;\n    let mut _8: &sys::process::unix::common::Command;\n    let mut _9: sys::process::unix::common::Stdio;\n    let mut _10: isize;\n    let  _11: sys::process::unix::common::ChildPipes;\n    let  _12: sync::poison::rwlock::RwLockReadGuard<'_, ()>;\n    let  _13: io::error::Error;\n    let mut _14: core::result::Result<!, io::error::Error>;\n    let mut _15: core::option::Option<&sys::process::unix::common::cstring_array::CStringArray>;\n    let mut _16: &core::option::Option<sys::process::unix::common::cstring_array::CStringArray>;\n    let  _17: io::error::Error;\n    let mut _18: bool;\n    let mut _19: isize;\n    debug self => _1;\n    debug default => _2;\n    debug envp => _3;\n    debug theirs => _11;\n    debug _lock => _12;\n    debug e => _13;\n    debug e => _17;\n    bb0: {\n        _18 = false;\n        StorageLive(_3);\n        _3 = sys::process::unix::common::Command::capture_env(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = sys::process::unix::common::Command::saw_nul(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = io::error::Error::from_static_message(sys::process::unix::unix::<impl sys::process::unix::common::Command>::exec::{constant#0}) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _0 = core::hint::must_use::<io::error::Error>(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        StorageDead(_4);\n        drop(_3) -> [return: bb17, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_1);\n        StorageLive(_9);\n        _9 = move _2;\n        _7 = sys::process::unix::common::Command::setup_io(move _8, move _9, true) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _18 = true;\n        StorageDead(_9);\n        StorageDead(_8);\n        _10 = discriminant(_7);\n        switchInt(move _10) -> [0: bb10, 1: bb9, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageLive(_17);\n        _17 = move ((_7 as variant#1).0: io::error::Error);\n        _0 = move _17;\n        StorageDead(_17);\n        goto -> bb15;\n    }\n    bb10: {\n        _11 = move (((_7 as variant#0).0: (process::StdioPipes, sys::process::unix::common::ChildPipes)).1: sys::process::unix::common::ChildPipes);\n        StorageLive(_12);\n        _12 = sys::env::unix::env_read_lock() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_3;\n        _15 = core::option::Option::<sys::process::unix::common::cstring_array::CStringArray>::as_ref(move _16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        _14 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec(_1, _11, move _15) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_15);\n        StorageLive(_13);\n        _13 = move ((_14 as variant#1).0: io::error::Error);\n        StorageDead(_14);\n        _0 = move _13;\n        StorageDead(_13);\n        drop(_12) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_12);\n        goto -> bb15;\n    }\n    bb15: {\n        _19 = discriminant(_7);\n        switchInt(move _19) -> [0: bb20, 1: bb19, otherwise: bb8];\n    }\n    bb16: {\n        StorageDead(_3);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        return;\n    }\n    bb19: {\n        _18 = false;\n        StorageDead(_7);\n        drop(_3) -> [return: bb16, unwind unreachable];\n    }\n    bb20: {\n        switchInt(_18) -> [0: bb21, otherwise: bb22];\n    }\n    bb21: {\n        _18 = false;\n        goto -> bb19;\n    }\n    bb22: {\n        drop((((_7 as variant#0).0: (process::StdioPipes, sys::process::unix::common::ChildPipes)).0: process::StdioPipes)) -> [return: bb21, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}