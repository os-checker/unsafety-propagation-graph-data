{
  "name": "sys::alloc::realloc_fallback",
  "safe": false,
  "callees": {
    "core::alloc::Layout::align": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum byte alignment for a memory block of this layout.\n\n The returned alignment is guaranteed to be a power of two.\n",
      "adt": {}
    },
    "core::alloc::Layout::from_size_align_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a layout, bypassing all checks.\n\n # Safety\n\n This function is unsafe as it does not verify the preconditions from\n [`Layout::from_size_align`].\n",
      "adt": {}
    },
    "core::alloc::GlobalAlloc::alloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates memory as described by the given `layout`.\n\n Returns a pointer to newly-allocated memory,\n or null to indicate allocation failure.\n\n # Safety\n\n `layout` must have non-zero size. Attempting to allocate for a zero-sized `layout` will\n result in undefined behavior.\n\n (Extension subtraits might provide more specific bounds on\n behavior, e.g., guarantee a sentinel address or a null pointer\n in response to a zero-size allocation request.)\n\n The allocated block of memory may or may not be initialized.\n\n # Errors\n\n Returning a null pointer indicates that either memory is exhausted\n or `layout` does not meet this allocator's size or alignment constraints.\n\n Implementations are encouraged to return null on memory\n exhaustion rather than aborting, but this is not\n a strict requirement. (Specifically: it is *legal* to\n implement this trait atop an underlying native allocation\n library that aborts on memory exhaustion.)\n\n Clients wishing to abort computation in response to an\n allocation error are encouraged to call the [`handle_alloc_error`] function,\n rather than directly invoking `panic!` or similar.\n\n [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::alloc::Layout::size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The minimum size in bytes for a memory block of this layout.\n",
      "adt": {}
    },
    "core::cmp::Ord::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.min(2), 1);\n assert_eq!(2.min(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").min(Equal(\"other\")).0, \"self\");\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "core::alloc::GlobalAlloc::dealloc": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Deallocates the block of memory at the given `ptr` pointer with the given `layout`.\n\n # Safety\n\n The caller must ensure:\n\n * `ptr` is a block of memory currently allocated via this allocator and,\n\n * `layout` is the same layout that was used to allocate that block of\n   memory.\n\n Otherwise the behavior is undefined.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::alloc::Layout": [
      "Ref",
      "Plain"
    ],
    "alloc::System": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::alloc::realloc_fallback"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/alloc/mod.rs:50:1: 69:2",
  "src": "unsafe fn realloc_fallback(\n    alloc: &System,\n    ptr: *mut u8,\n    old_layout: Layout,\n    new_size: usize,\n) -> *mut u8 {\n    // SAFETY: Docs for GlobalAlloc::realloc require this to be valid\n    unsafe {\n        let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n\n        let new_ptr = GlobalAlloc::alloc(alloc, new_layout);\n        if !new_ptr.is_null() {\n            let size = usize::min(old_layout.size(), new_size);\n            ptr::copy_nonoverlapping(ptr, new_ptr, size);\n            GlobalAlloc::dealloc(alloc, ptr, old_layout);\n        }\n\n        new_ptr\n    }\n}",
  "mir": "fn sys::alloc::realloc_fallback(_1: &alloc::System, _2: *mut u8, _3: core::alloc::Layout, _4: usize) -> *mut u8 {\n    let mut _0: *mut u8;\n    let  _5: core::alloc::Layout;\n    let mut _6: usize;\n    let mut _7: &core::alloc::Layout;\n    let mut _8: bool;\n    let  _9: usize;\n    let mut _10: usize;\n    let mut _11: &core::alloc::Layout;\n    let  _12: ();\n    let mut _13: *const u8;\n    let  _14: ();\n    debug alloc => _1;\n    debug ptr => _2;\n    debug old_layout => _3;\n    debug new_size => _4;\n    debug new_layout => _5;\n    debug new_ptr => _0;\n    debug size => _9;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_3;\n        _6 = core::alloc::Layout::align(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_7);\n        _5 = core::alloc::Layout::from_size_align_unchecked(_4, move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _0 = <alloc::System as core::alloc::GlobalAlloc>::alloc(_1, _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_8);\n        _8 = core::ptr::mut_ptr::<impl *mut u8>::is_null(_0) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _8) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        goto -> bb11;\n    }\n    bb6: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_3;\n        _10 = core::alloc::Layout::size(move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_11);\n        _9 = <usize as core::cmp::Ord>::min(move _10, _4) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_13);\n        _13 = _2 as *const u8;\n        _12 = core::ptr::copy_nonoverlapping::<u8>(move _13, _0, _9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        _14 = <alloc::System as core::alloc::GlobalAlloc>::dealloc(_1, _2, _3) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_8);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "dead_code"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* dead_code\n"
    ]
  }
}