{
  "name": "os::unix::net::ancillary::recv_vectored_with_ancillary_from",
  "safe": true,
  "callees": {
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "sys::net::connection::socket::unix::Socket::recv_msg": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "libc::msghdr": "MutableAsArgument",
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "os::unix::net::addr::SocketAddr::from_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "libc::sockaddr_un": [
      "Plain"
    ],
    "libc::msghdr": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(2, Ty { id: 8190, kind: RigidTy(RawPtr(Ty { id: 8201, kind: RigidTy(Adt(AdtDef(DefId { id: 8157, name: \"libc::iovec\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(3, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(5, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(4, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "MutRef",
      "Unknown([Field(6, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "os::unix::net::ancillary::SocketAncillary": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::os::unix::net::ancillary::recv_vectored_with_ancillary_from"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/ancillary.rs:33:1: 61:2",
  "src": "pub(super) fn recv_vectored_with_ancillary_from(\n    socket: &Socket,\n    bufs: &mut [IoSliceMut<'_>],\n    ancillary: &mut SocketAncillary<'_>,\n) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n    unsafe {\n        let mut msg_name: libc::sockaddr_un = zeroed();\n        let mut msg: libc::msghdr = zeroed();\n        msg.msg_name = (&raw mut msg_name) as *mut _;\n        msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n        msg.msg_iov = bufs.as_mut_ptr().cast();\n        msg.msg_iovlen = bufs.len() as _;\n        msg.msg_controllen = ancillary.buffer.len() as _;\n        // macos requires that the control pointer is null when the len is 0.\n        if msg.msg_controllen > 0 {\n            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n        }\n\n        let count = socket.recv_msg(&mut msg)?;\n\n        ancillary.length = msg.msg_controllen as usize;\n        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n\n        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);\n\n        Ok((count, truncated, addr))\n    }\n}",
  "mir": "fn os::unix::net::ancillary::recv_vectored_with_ancillary_from(_1: &sys::net::connection::socket::unix::Socket, _2: &mut [io::IoSliceMut<'_>], _3: &mut os::unix::net::ancillary::SocketAncillary<'_>) -> core::result::Result<(usize, bool, core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>), io::error::Error> {\n    let mut _0: core::result::Result<(usize, bool, core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>), io::error::Error>;\n    let mut _4: libc::sockaddr_un;\n    let mut _5: libc::msghdr;\n    let mut _6: *mut libc::c_void;\n    let mut _7: *mut libc::sockaddr_un;\n    let mut _8: usize;\n    let mut _9: *mut libc::iovec;\n    let mut _10: *mut io::IoSliceMut<'_>;\n    let mut _11: usize;\n    let mut _12: &[io::IoSliceMut<'_>];\n    let mut _13: usize;\n    let mut _14: &[u8];\n    let mut _15: bool;\n    let mut _16: usize;\n    let mut _17: *mut libc::c_void;\n    let mut _18: *mut u8;\n    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _20: core::result::Result<usize, io::error::Error>;\n    let mut _21: &mut libc::msghdr;\n    let mut _22: isize;\n    let  _23: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _24: usize;\n    let mut _25: usize;\n    let mut _26: i32;\n    let mut _27: i32;\n    let  _28: bool;\n    let mut _29: i32;\n    let mut _30: i32;\n    let  _31: core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>;\n    let mut _32: libc::sockaddr_un;\n    let mut _33: u32;\n    let mut _34: (usize, bool, core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>);\n    let mut _35: &mut [u8];\n    let mut _36: &mut [u8];\n    debug socket => _1;\n    debug bufs => _2;\n    debug ancillary => _3;\n    debug msg_name => _4;\n    debug msg => _5;\n    debug count => _24;\n    debug residual => _23;\n    debug val => _24;\n    debug truncated => _28;\n    debug addr => _31;\n    bb0: {\n        StorageLive(_4);\n        _4 = core::mem::zeroed::<libc::sockaddr_un>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        _5 = core::mem::zeroed::<libc::msghdr>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = &raw mut _4;\n        _6 = move _7 as *mut libc::c_void;\n        StorageDead(_7);\n        (_5.0: *mut libc::c_void) = _6;\n        StorageLive(_8);\n        _8 = core::mem::size_of::<libc::sockaddr_un>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        (_5.1: u32) = move _8 as u32;\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = core::slice::<impl [io::IoSliceMut<'_>]>::as_mut_ptr(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _9 = core::ptr::mut_ptr::<impl *mut io::IoSliceMut<'_>>::cast::<libc::iovec>(move _10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_10);\n        (_5.2: *mut libc::iovec) = move _9;\n        StorageDead(_9);\n        StorageLive(_12);\n        _12 = &(*_2);\n        _11 = PtrMetadata(move _12);\n        StorageDead(_12);\n        (_5.3: usize) = _11;\n        StorageLive(_14);\n        _35 = ((*_3).0: &mut [u8]);\n        _14 = &(*_35);\n        _13 = PtrMetadata(move _14);\n        StorageDead(_14);\n        (_5.5: usize) = _13;\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = (_5.5: usize);\n        _15 = Gt(move _16, 0_usize);\n        switchInt(move _15) -> [0: bb9, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _36 = ((*_3).0: &mut [u8]);\n        _18 = core::slice::<impl [u8]>::as_mut_ptr(_36) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _17 = core::ptr::mut_ptr::<impl *mut u8>::cast::<libc::c_void>(move _18) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_18);\n        (_5.4: *mut libc::c_void) = move _17;\n        StorageDead(_17);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_16);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_15);\n        StorageLive(_19);\n        StorageLive(_20);\n        _21 = &mut _5;\n        _20 = sys::net::connection::socket::unix::Socket::recv_msg(_1, _21) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _19 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        _22 = discriminant(_19);\n        switchInt(move _22) -> [0: bb14, 1: bb15, otherwise: bb13];\n    }\n    bb13: {\n        unreachable;\n    }\n    bb14: {\n        _24 = ((_19 as variant#0).0: usize);\n        StorageDead(_19);\n        StorageLive(_25);\n        _25 = (_5.5: usize);\n        ((*_3).1: usize) = move _25;\n        StorageDead(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = (_5.6: i32);\n        _26 = BitAnd(move _27, libc::MSG_CTRUNC);\n        StorageDead(_27);\n        ((*_3).2: bool) = Eq(move _26, libc::MSG_CTRUNC);\n        StorageDead(_26);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = (_5.6: i32);\n        _29 = BitAnd(move _30, libc::MSG_TRUNC);\n        StorageDead(_30);\n        _28 = Eq(move _29, libc::MSG_TRUNC);\n        StorageDead(_29);\n        StorageLive(_32);\n        _32 = _4;\n        StorageLive(_33);\n        _33 = (_5.1: u32);\n        _31 = os::unix::net::addr::SocketAddr::from_parts(move _32, move _33) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _23 = move ((_19 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(usize, bool, core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_23) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_19);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb18;\n    }\n    bb17: {\n        StorageDead(_33);\n        StorageDead(_32);\n        StorageLive(_34);\n        _34 = (_24, _28, _31);\n        _0 = core::result::Result::Ok(move _34);\n        StorageDead(_34);\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb18;\n    }\n    bb18: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}