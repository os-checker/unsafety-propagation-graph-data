{
  "name": "fs::Permissions::set_readonly",
  "safe": true,
  "callees": {
    "sys::fs::unix::FilePermissions::set_readonly": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::FilePermissions": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "sys::fs::unix::FilePermissions": [
      "MutRef"
    ],
    "fs::Permissions": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::fs::Permissions::set_readonly"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:2245:5: 2247:6",
  "src": "pub fn set_readonly(&mut self, readonly: bool) {\n        self.0.set_readonly(readonly)\n    }",
  "mir": "fn fs::Permissions::set_readonly(_1: &mut fs::Permissions, _2: bool) -> () {\n    let mut _0: ();\n    let mut _3: &mut sys::fs::unix::FilePermissions;\n    debug self => _1;\n    debug readonly => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: sys::fs::unix::FilePermissions);\n        _0 = sys::fs::unix::FilePermissions::set_readonly(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Modifies the readonly flag for this set of permissions. If the\n `readonly` argument is `true`, using the resulting `Permission` will\n update file permissions to forbid writing. Conversely, if it's `false`,\n using the resulting `Permission` will update file permissions to allow\n writing.\n\n This operation does **not** modify the files attributes. This only\n changes the in-memory value of these attributes for this `Permissions`\n instance. To modify the files attributes use the [`set_permissions`]\n function which commits these attribute changes to the file.\n\n # Note\n\n `set_readonly(false)` makes the file *world-writable* on Unix.\n You can use the [`PermissionsExt`] trait on Unix to avoid this issue.\n\n It also does not take Access Control Lists (ACLs) or Unix group\n membership into account.\n\n # Windows\n\n On Windows this sets or clears [`FILE_ATTRIBUTE_READONLY`](https://docs.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants).\n If `FILE_ATTRIBUTE_READONLY` is set then writes to the file will fail\n but the user may still have permission to change this flag. If\n `FILE_ATTRIBUTE_READONLY` is *not* set then the write may still fail if\n the user does not have permission to write to the file.\n\n In Windows 7 and earlier this attribute prevents deleting empty\n directories. It does not prevent modifying the directory contents.\n On later versions of Windows this attribute is ignored for directories.\n\n # Unix (including macOS)\n\n On Unix-based platforms this sets or clears the write access bit for\n the owner, group *and* others, equivalent to `chmod a+w <file>`\n or `chmod a-w <file>` respectively. The latter will grant write access\n to all users! You can use the [`PermissionsExt`] trait on Unix\n to avoid this issue.\n\n [`PermissionsExt`]: crate::os::unix::fs::PermissionsExt\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let f = File::create(\"foo.txt\")?;\n     let metadata = f.metadata()?;\n     let mut permissions = metadata.permissions();\n\n     permissions.set_readonly(true);\n\n     // filesystem doesn't change, only the in memory state of the\n     // readonly permission\n     assert_eq!(false, metadata.permissions().readonly());\n\n     // just this particular `permissions`.\n     assert_eq!(true, permissions.readonly());\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}