{
  "name": "<() as sys::thread_local::native::lazy::DestroyedState>::register_dtor",
  "safe": true,
  "callees": {
    "core::ptr::from_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a reference to a raw pointer.\n\n For `r: &T`, `from_ref(r)` is equivalent to `r as *const T` (except for the caveat noted below),\n but is a bit safer since it will never silently change type or mutability, in particular if the\n code is refactored.\n\n The caller must ensure that the pointee outlives the pointer this function returns, or else it\n will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to is never\n written to (except inside an `UnsafeCell`) using this pointer or any pointer derived from it. If\n you need to mutate the pointee, use [`from_mut`]. Specifically, to turn a mutable reference `m:\n &mut T` into `*const T`, prefer `from_mut(m).cast_const()` to obtain a pointer that can later be\n used for mutation.\n\n ## Interaction with lifetime extension\n\n Note that this has subtle interactions with the rules for lifetime extension of temporaries in\n tail expressions. This code is valid, albeit in a non-obvious way:\n ```rust\n # type T = i32;\n # fn foo() -> T { 42 }\n // The temporary holding the return value of `foo` has its lifetime extended,\n // because the surrounding expression involves no function call.\n let p = &foo() as *const T;\n unsafe { p.read() };\n ```\n Naively replacing the cast with `from_ref` is not valid:\n ```rust,no_run\n # use std::ptr;\n # type T = i32;\n # fn foo() -> T { 42 }\n // The temporary holding the return value of `foo` does *not* have its lifetime extended,\n // because the surrounding expression involves a function call.\n let p = ptr::from_ref(&foo());\n unsafe { p.read() }; // UB! Reading from a dangling pointer ⚠️\n ```\n The recommended way to write this code is to avoid relying on lifetime extension\n when raw pointers are involved:\n ```rust\n # use std::ptr;\n # type T = i32;\n # fn foo() -> T { 42 }\n let x = foo();\n let p = ptr::from_ref(&x);\n unsafe { p.read() };\n ```\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes constness without changing the type.\n\n This is a bit safer than `as` because it wouldn't silently change the type if the code is\n refactored.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "sys::thread_local::native::lazy::destroy": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transition an `Alive` TLS variable into the `Destroyed` state, dropping its\n value.\n\n # Safety\n * Must only be called at thread destruction.\n * `ptr` must point to an instance of `Storage<T, ()>` and be valid for\n   accessing that instance.\n",
      "adt": {}
    },
    "sys::thread_local::destructors::linux_like::register": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "sys::thread_local::native::lazy::Storage": [
      "Ref"
    ]
  },
  "path": 194,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/lazy.rs:15:5: 19:6",
  "src": "fn register_dtor<T>(s: &Storage<T, ()>) {\n        unsafe {\n            destructors::register(ptr::from_ref(s).cast_mut().cast(), destroy::<T>);\n        }\n    }",
  "mir": "fn <() as sys::thread_local::native::lazy::DestroyedState>::register_dtor(_1: &sys::thread_local::native::lazy::Storage<T, ()>) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: *mut u8;\n    let mut _4: *mut sys::thread_local::native::lazy::Storage<T, ()>;\n    let mut _5: *const sys::thread_local::native::lazy::Storage<T, ()>;\n    let mut _6: unsafe extern \"C\" fn(*mut u8);\n    debug s => _1;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = core::ptr::from_ref::<sys::thread_local::native::lazy::Storage<T, ()>>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = core::ptr::const_ptr::<impl *const sys::thread_local::native::lazy::Storage<T, ()>>::cast_mut(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = core::ptr::mut_ptr::<impl *mut sys::thread_local::native::lazy::Storage<T, ()>>::cast::<u8>(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = sys::thread_local::native::lazy::destroy::<T> as unsafe extern \"C\" fn(*mut u8);\n        _2 = sys::thread_local::destructors::linux_like::register(move _3, move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}