{
  "name": "net::udp::UdpSocket::bind",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::UdpSocket::bind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "net::udp::UdpSocket": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A UDP socket.\n\n After creating a `UdpSocket` by [`bind`]ing it to a socket address, data can be\n [sent to] and [received from] any other socket address.\n\n Although UDP is a connectionless protocol, this implementation provides an interface\n to set an address where data should be sent and received from. After setting a remote\n address with [`connect`], data can be sent to and received from that address with\n [`send`] and [`recv`].\n\n As stated in the User Datagram Protocol's specification in [IETF RFC 768], UDP is\n an unordered, unreliable protocol; refer to [`TcpListener`] and [`TcpStream`] for TCP\n primitives.\n\n [`bind`]: UdpSocket::bind\n [`connect`]: UdpSocket::connect\n [IETF RFC 768]: https://tools.ietf.org/html/rfc768\n [`recv`]: UdpSocket::recv\n [received from]: UdpSocket::recv_from\n [`send`]: UdpSocket::send\n [sent to]: UdpSocket::send_to\n [`TcpListener`]: crate::net::TcpListener\n [`TcpStream`]: crate::net::TcpStream\n\n # Examples\n\n ```no_run\n use std::net::UdpSocket;\n\n fn main() -> std::io::Result<()> {\n     {\n         let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n\n         // Receives a single datagram message on the socket. If `buf` is too small to hold\n         // the message, it will be cut off.\n         let mut buf = [0; 10];\n         let (amt, src) = socket.recv_from(&mut buf)?;\n\n         // Redeclare `buf` as slice of the received data and send reverse data back to origin.\n         let buf = &mut buf[..amt];\n         buf.reverse();\n         socket.send_to(buf, &src)?;\n     } // the socket is closed here\n     Ok(())\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::net::udp::UdpSocket::bind"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/net/udp.rs:122:5: 124:6",
  "src": "pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n        net_imp::UdpSocket::bind(addr).map(UdpSocket)\n    }",
  "mir": "fn net::udp::UdpSocket::bind(_1: A) -> core::result::Result<net::udp::UdpSocket, io::error::Error> {\n    let mut _0: core::result::Result<net::udp::UdpSocket, io::error::Error>;\n    let mut _2: core::result::Result<sys::net::connection::socket::UdpSocket, io::error::Error>;\n    debug addr => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = sys::net::connection::socket::UdpSocket::bind::<A>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = core::result::Result::<sys::net::connection::socket::UdpSocket, io::error::Error>::map::<net::udp::UdpSocket, fn(sys::net::connection::socket::UdpSocket) -> net::udp::UdpSocket {net::udp::UdpSocket}>(move _2, net::udp::UdpSocket) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates a UDP socket from the given address.\n\n The address type can be any implementor of [`ToSocketAddrs`] trait. See\n its documentation for concrete examples.\n\n If `addr` yields multiple addresses, `bind` will be attempted with\n each of the addresses until one succeeds and returns the socket. If none\n of the addresses succeed in creating a socket, the error returned from\n the last attempt (the last address) is returned.\n\n # Examples\n\n Creates a UDP socket bound to `127.0.0.1:3400`:\n\n ```no_run\n use std::net::UdpSocket;\n\n let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n ```\n\n Creates a UDP socket bound to `127.0.0.1:3400`. If the socket cannot be\n bound to that address, create a UDP socket bound to `127.0.0.1:3401`:\n\n ```no_run\n use std::net::{SocketAddr, UdpSocket};\n\n let addrs = [\n     SocketAddr::from(([127, 0, 0, 1], 3400)),\n     SocketAddr::from(([127, 0, 0, 1], 3401)),\n ];\n let socket = UdpSocket::bind(&addrs[..]).expect(\"couldn't bind to address\");\n ```\n\n Creates a UDP socket bound to a port assigned by the operating system\n at `127.0.0.1`.\n\n ```no_run\n use std::net::UdpSocket;\n\n let socket = UdpSocket::bind(\"127.0.0.1:0\").unwrap();\n ```\n\n Note that `bind` declares the scope of your network connection.\n You can only receive datagrams from and send datagrams to\n participants in that view of the network.\n For instance, binding to a loopback address as in the example\n above will prevent you from sending datagrams to another device\n in your local network.\n\n In order to limit your view of the network the least, `bind` to\n [`Ipv4Addr::UNSPECIFIED`] or [`Ipv6Addr::UNSPECIFIED`].\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}