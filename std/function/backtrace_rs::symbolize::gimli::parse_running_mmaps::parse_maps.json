{
  "name": "backtrace_rs::symbolize::gimli::parse_running_mmaps::parse_maps",
  "safe": true,
  "callees": {
    "alloc_crate::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    },
    "fs::File::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode.\n\n See the [`OpenOptions::open`] method for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Read;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut data = vec![];\n     f.read_to_end(&mut data)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String`.\n\n Given that the `String` is empty, this will not allocate any initial\n buffer. While that means that this initial operation is very\n inexpensive, it may cause excessive allocation later when you add\n data. If you have an idea of how much data the `String` will hold,\n consider the [`with_capacity`] method to prevent excessive\n re-allocation.\n\n [`with_capacity`]: String::with_capacity\n\n # Examples\n\n ```\n let s = String::new();\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::Read::read_to_string": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until EOF in this source, appending them to `buf`.\n\n If successful, this function returns the number of bytes which were read\n and appended to `buf`.\n\n # Errors\n\n If the data in this stream is *not* valid UTF-8 then an error is\n returned and `buf` is unchanged.\n\n See [`read_to_end`] for other error semantics.\n\n [`read_to_end`]: Read::read_to_end\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = String::new();\n\n     f.read_to_string(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read_to_string`] convenience function for\n reading from a file.)\n\n # Usage Notes\n\n `read_to_string` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_string` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`std::fs::read_to_string`]: crate::fs::read_to_string\n",
      "adt": {
        "core::result::Result": "Constructor",
        "alloc_crate::string::String": "MutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::str::<impl str>::lines": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the lines of a string, as string slices.\n\n Lines are split at line endings that are either newlines (`\\n`) or\n sequences of a carriage return followed by a line feed (`\\r\\n`).\n\n Line terminators are not included in the lines returned by the iterator.\n\n Note that any carriage return (`\\r`) not immediately followed by a\n line feed (`\\n`) does not split a line. These carriage returns are\n thereby included in the produced lines.\n\n The final line ending is optional. A string that ends with a final line\n ending will return the same lines as an otherwise identical string\n without a final line ending.\n\n An empty string returns an empty iterator.\n\n # Examples\n\n Basic usage:\n\n ```\n let text = \"foo\\r\\nbar\\n\\nbaz\\r\";\n let mut lines = text.lines();\n\n assert_eq!(Some(\"foo\"), lines.next());\n assert_eq!(Some(\"bar\"), lines.next());\n assert_eq!(Some(\"\"), lines.next());\n // Trailing carriage return is included in the last line\n assert_eq!(Some(\"baz\\r\"), lines.next());\n\n assert_eq!(None, lines.next());\n ```\n\n The final line does not require any ending:\n\n ```\n let text = \"foo\\nbar\\n\\r\\nbaz\";\n let mut lines = text.lines();\n\n assert_eq!(Some(\"foo\"), lines.next());\n assert_eq!(Some(\"bar\"), lines.next());\n assert_eq!(Some(\"\"), lines.next());\n assert_eq!(Some(\"baz\"), lines.next());\n\n assert_eq!(None, lines.next());\n ```\n\n An empty string returns an empty iterator:\n\n ```\n let text = \"\";\n let mut lines = text.lines();\n\n assert_eq!(lines.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::str::<impl str>::parse": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Parses this string slice into another type.\n\n Because `parse` is so general, it can cause problems with type\n inference. As such, `parse` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which type\n you're trying to parse into.\n\n `parse` can parse into any type that implements the [`FromStr`] trait.\n\n # Errors\n\n Will return [`Err`] if it's not possible to parse this string slice into\n the desired type.\n\n [`Err`]: FromStr::Err\n\n # Examples\n\n Basic usage:\n\n ```\n let four: u32 = \"4\".parse().unwrap();\n\n assert_eq!(4, four);\n ```\n\n Using the 'turbofish' instead of annotating `four`:\n\n ```\n let four = \"4\".parse::<u32>();\n\n assert_eq!(Ok(4), four);\n ```\n\n Failing to parse:\n\n ```\n let nope = \"j\".parse::<u32>();\n\n assert!(nope.is_err());\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Appends an element to the back of a collection.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1, 2];\n vec.push(3);\n assert_eq!(vec, [1, 2, 3]);\n ```\n\n # Time complexity\n\n Takes amortized *O*(1) time. If the vector's length would exceed its\n capacity after the push, *O*(*capacity*) time is taken to copy the\n vector's elements to a larger allocation. This expensive operation is\n offset by the *capacity* *O*(1) insertions it allows.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 18544, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18486, kind: RigidTy(Adt(AdtDef(DefId { id: 12922, name: \"backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry\" }), GenericArgs([]))) })])"
    ],
    "fs::File": [
      "Plain",
      "MutRef"
    ],
    "alloc_crate::string::String": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "core::str::Lines": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])"
    ],
    "backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::parse_running_mmaps::parse_maps"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:58:1: 71:2",
  "src": "pub(super) fn parse_maps() -> Result<Vec<MapsEntry>, &'static str> {\n    let mut v = Vec::new();\n    let mut proc_self_maps =\n        File::open(\"/proc/self/maps\").map_err(|_| \"Couldn't open /proc/self/maps\")?;\n    let mut buf = String::new();\n    let _bytes_read = proc_self_maps\n        .read_to_string(&mut buf)\n        .map_err(|_| \"Couldn't read /proc/self/maps\")?;\n    for line in buf.lines() {\n        v.push(line.parse()?);\n    }\n\n    Ok(v)\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::parse_running_mmaps::parse_maps() -> core::result::Result<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>, &str> {\n    let mut _0: core::result::Result<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>, &str>;\n    let mut _1: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let mut _2: fs::File;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, fs::File>;\n    let mut _4: core::result::Result<fs::File, &str>;\n    let mut _5: core::result::Result<fs::File, io::error::Error>;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, &str>;\n    let  _8: fs::File;\n    let mut _9: alloc_crate::string::String;\n    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, usize>;\n    let mut _11: core::result::Result<usize, &str>;\n    let mut _12: core::result::Result<usize, io::error::Error>;\n    let mut _13: &mut fs::File;\n    let mut _14: &mut alloc_crate::string::String;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, &str>;\n    let  _17: usize;\n    let mut _18: core::str::Lines<'_>;\n    let mut _19: core::str::Lines<'_>;\n    let  _20: &str;\n    let mut _21: &alloc_crate::string::String;\n    let mut _22: core::str::Lines<'_>;\n    let mut _23: core::option::Option<&str>;\n    let mut _24: &mut core::str::Lines<'_>;\n    let mut _25: isize;\n    let  _26: &str;\n    let  _27: ();\n    let mut _28: &mut alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let mut _29: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, &str>, backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let mut _30: core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str>;\n    let mut _31: isize;\n    let  _32: core::result::Result<core::convert::Infallible, &str>;\n    let  _33: backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry;\n    let mut _34: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    debug v => _1;\n    debug proc_self_maps => _2;\n    debug residual => _7;\n    debug val => _8;\n    debug buf => _9;\n    debug _bytes_read => _17;\n    debug residual => _16;\n    debug val => _17;\n    debug iter => _22;\n    debug line => _26;\n    debug residual => _32;\n    debug val => _33;\n    bb0: {\n        StorageLive(_1);\n        _1 = alloc_crate::vec::Vec::<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = fs::File::open::<&str>(\"/proc/self/maps\") -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = core::result::Result::<fs::File, io::error::Error>::map_err::<&str, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:61:47: 61:50}>(move _5, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:61:47: 61:50}) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        _3 = <core::result::Result<fs::File, &str> as core::ops::Try>::branch(move _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_8);\n        _8 = move ((_3 as variant#0).0: fs::File);\n        _2 = move _8;\n        StorageDead(_8);\n        StorageDead(_3);\n        StorageLive(_9);\n        _9 = alloc_crate::string::String::new() -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _7 = ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_7) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_3);\n        goto -> bb33;\n    }\n    bb9: {\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut _2;\n        _14 = &mut _9;\n        _12 = <fs::File as io::Read>::read_to_string(move _13, _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        _11 = core::result::Result::<usize, io::error::Error>::map_err::<&str, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:65:18: 65:21}>(move _12, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/parse_running_mmaps_unix.rs:65:18: 65:21}) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_12);\n        _10 = <core::result::Result<usize, &str> as core::ops::Try>::branch(move _11) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_11);\n        _15 = discriminant(_10);\n        switchInt(move _15) -> [0: bb13, 1: bb14, otherwise: bb5];\n    }\n    bb13: {\n        _17 = ((_10 as variant#0).0: usize);\n        StorageDead(_10);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_21);\n        _21 = &_9;\n        _20 = <alloc_crate::string::String as core::ops::Deref>::deref(move _21) -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        _16 = ((_10 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_16) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_10);\n        goto -> bb31;\n    }\n    bb16: {\n        StorageDead(_21);\n        _19 = core::str::<impl str>::lines(_20) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _18 = <core::str::Lines<'_> as core::iter::IntoIterator>::into_iter(move _19) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_19);\n        StorageLive(_22);\n        _22 = move _18;\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_23);\n        _24 = &mut _22;\n        _23 = <core::str::Lines<'_> as core::iter::Iterator>::next(_24) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _25 = discriminant(_23);\n        switchInt(move _25) -> [0: bb22, 1: bb21, otherwise: bb5];\n    }\n    bb21: {\n        _26 = ((_23 as variant#1).0: &str);\n        StorageLive(_28);\n        _28 = &mut _1;\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = core::str::<impl str>::parse::<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>(_26) -> [return: bb23, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_18);\n        StorageLive(_34);\n        _34 = move _1;\n        _0 = core::result::Result::Ok(move _34);\n        StorageDead(_34);\n        drop(_9) -> [return: bb29, unwind unreachable];\n    }\n    bb23: {\n        _29 = <core::result::Result<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry, &str> as core::ops::Try>::branch(move _30) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_30);\n        _31 = discriminant(_29);\n        switchInt(move _31) -> [0: bb25, 1: bb26, otherwise: bb5];\n    }\n    bb25: {\n        _33 = move ((_29 as variant#0).0: backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry);\n        _27 = alloc_crate::vec::Vec::<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>::push(move _28, _33) -> [return: bb28, unwind unreachable];\n    }\n    bb26: {\n        _32 = ((_29 as variant#1).0: core::result::Result<core::convert::Infallible, &str>);\n        _0 = <core::result::Result<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>, &str> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, &str>>>::from_residual(_32) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_28);\n        StorageDead(_29);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_18);\n        goto -> bb31;\n    }\n    bb28: {\n        StorageDead(_28);\n        StorageDead(_29);\n        StorageDead(_23);\n        goto -> bb19;\n    }\n    bb29: {\n        StorageDead(_9);\n        drop(_2) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_2);\n        StorageDead(_1);\n        goto -> bb35;\n    }\n    bb31: {\n        drop(_9) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_9);\n        drop(_2) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_2);\n        drop(_1) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_1);\n        goto -> bb35;\n    }\n    bb35: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}