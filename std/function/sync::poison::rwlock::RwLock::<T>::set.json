{
  "name": "sync::poison::rwlock::RwLock::<T>::set",
  "safe": true,
  "callees": {
    "core::mem::needs_drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if dropping values of type `T` matters.\n\n This is purely an optimization hint, and may be implemented conservatively:\n it may return `true` for types that don't actually need to be dropped.\n As such always returning `true` would be a valid implementation of\n this function. However if this function actually returns `false`, then you\n can be certain dropping `T` has no side effect.\n\n Low level implementations of things like collections, which need to manually\n drop their data, should use this function to avoid unnecessarily\n trying to drop all their contents when they are destroyed. This might not\n make a difference in release builds (where a loop that has no side-effects\n is easily detected and eliminated), but is often a big win for debug builds.\n\n Note that [`drop_in_place`] already performs this check, so if your workload\n can be reduced to some small number of [`drop_in_place`] calls, using this is\n unnecessary. In particular note that you can [`drop_in_place`] a slice, and that\n will do a single needs_drop check for all the values.\n\n Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n `needs_drop` explicitly. Types like [`HashMap`], on the other hand, have to drop\n values one at a time and should use this API.\n\n [`drop_in_place`]: crate::ptr::drop_in_place\n [`HashMap`]: ../../std/collections/struct.HashMap.html\n\n # Examples\n\n Here's an example of how a collection might make use of `needs_drop`:\n\n ```\n use std::{mem, ptr};\n\n pub struct MyCollection<T> {\n #   data: [T; 1],\n     /* ... */\n }\n # impl<T> MyCollection<T> {\n #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n #   fn free_buffer(&mut self) {}\n # }\n\n impl<T> Drop for MyCollection<T> {\n     fn drop(&mut self) {\n         unsafe {\n             // drop the data\n             if mem::needs_drop::<T>() {\n                 for x in self.iter_mut() {\n                     ptr::drop_in_place(x);\n                 }\n             }\n             self.free_buffer();\n         }\n     }\n }\n ```\n",
      "adt": {}
    },
    "sync::poison::rwlock::RwLock::<T>::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Replaces the contained value with `value`, and returns the old contained value.\n\n # Errors\n\n This function will return an error containing the provided `value` if\n the `RwLock` is poisoned. An `RwLock` is poisoned whenever a writer\n panics while holding an exclusive lock.\n\n # Examples\n\n ```\n #![feature(lock_value_accessors)]\n\n use std::sync::RwLock;\n\n let mut lock = RwLock::new(7);\n\n assert_eq!(lock.replace(11).unwrap(), 7);\n assert_eq!(lock.get_cloned().unwrap(), 11);\n ```\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "sync::poison::rwlock::RwLock::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks this `RwLock` with exclusive write access, blocking the current\n thread until it can be acquired.\n\n This function will not return while other writers or other readers\n currently have access to the lock.\n\n Returns an RAII guard which will drop the write access of this `RwLock`\n when dropped.\n\n # Errors\n\n This function will return an error if the `RwLock` is poisoned. An\n `RwLock` is poisoned whenever a writer panics while holding an exclusive\n lock. An error will be returned when the lock is acquired. The acquired\n lock guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by the current thread.\n\n # Examples\n\n ```\n use std::sync::RwLock;\n\n let lock = RwLock::new(1);\n\n let mut n = lock.write().unwrap();\n *n = 2;\n\n assert!(lock.try_read().is_err());\n ```\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::rwlock::RwLockWriteGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::poison::rwlock::RwLock": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12274, kind: RigidTy(Adt(AdtDef(DefId { id: 9991, name: \"sync::poison::rwlock::RwLockWriteGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "sync::poison::rwlock::RwLockWriteGuard": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 3264,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/rwlock.rs:303:5: 318:6",
  "src": "pub fn set(&self, value: T) -> Result<(), PoisonError<T>> {\n        if mem::needs_drop::<T>() {\n            // If the contained value has non-trivial destructor, we\n            // call that destructor after the lock being released.\n            self.replace(value).map(drop)\n        } else {\n            match self.write() {\n                Ok(mut guard) => {\n                    *guard = value;\n\n                    Ok(())\n                }\n                Err(_) => Err(PoisonError::new(value)),\n            }\n        }\n    }",
  "mir": "fn sync::poison::rwlock::RwLock::<T>::set(_1: &sync::poison::rwlock::RwLock<T>, _2: T) -> core::result::Result<(), sync::poison::PoisonError<T>> {\n    let mut _0: core::result::Result<(), sync::poison::PoisonError<T>>;\n    let mut _3: bool;\n    let mut _4: core::result::Result<T, sync::poison::PoisonError<T>>;\n    let mut _5: core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>;\n    let mut _6: sync::poison::rwlock::RwLockWriteGuard<'_, T>;\n    let mut _7: &mut T;\n    let mut _8: &mut sync::poison::rwlock::RwLockWriteGuard<'_, T>;\n    let mut _9: isize;\n    debug self => _1;\n    debug value => _2;\n    debug guard => _6;\n    bb0: {\n        StorageLive(_3);\n        _3 = core::mem::needs_drop::<T>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb5, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = sync::poison::rwlock::RwLock::<T>::replace(_1, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core::result::Result::<T, sync::poison::PoisonError<T>>::map::<(), fn(T) {core::mem::drop::<T>}>(move _4, core::mem::drop::<T>) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb5: {\n        StorageLive(_5);\n        _5 = sync::poison::rwlock::RwLock::<T>::write(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_6);\n        _6 = move ((_5 as variant#0).0: sync::poison::rwlock::RwLockWriteGuard<'_, T>);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &mut _6;\n        _7 = <sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        drop((*_7)) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        (*_7) = _2;\n        StorageDead(_7);\n        _0 = core::result::Result::Ok(());\n        drop(_6) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        _9 = discriminant(_5);\n        switchInt(move _9) -> [0: bb11, otherwise: bb12];\n    }\n    bb10: {\n        StorageDead(_3);\n        return;\n    }\n    bb11: {\n        StorageDead(_5);\n        goto -> bb10;\n    }\n    bb12: {\n        unreachable;\n    }\n}\n",
  "doc": " Sets the contained value.\n\n # Errors\n\n This function will return an error containing the provided `value` if\n the `RwLock` is poisoned. An `RwLock` is poisoned whenever a writer\n panics while holding an exclusive lock.\n\n # Examples\n\n ```\n #![feature(lock_value_accessors)]\n\n use std::sync::RwLock;\n\n let mut lock = RwLock::new(7);\n\n assert_eq!(lock.get_cloned().unwrap(), 7);\n lock.set(11).unwrap();\n assert_eq!(lock.get_cloned().unwrap(), 11);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}