{
  "name": "<alloc_crate::collections::VecDeque<u8, A> as io::copy::BufferedReaderSpec>::copy_to",
  "safe": true,
  "callees": {
    "alloc_crate::collections::VecDeque::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the deque.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n assert_eq!(deque.len(), 0);\n deque.push_back(1);\n assert_eq!(deque.len(), 1);\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::as_slices": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pair of slices which contain, in order, the contents of the\n deque.\n\n If [`make_contiguous`] was previously called, all elements of the\n deque will be in the first slice and the second slice will be empty.\n Otherwise, the exact split point depends on implementation details\n and is not guaranteed.\n\n [`make_contiguous`]: VecDeque::make_contiguous\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n\n deque.push_back(0);\n deque.push_back(1);\n deque.push_back(2);\n\n let expected = [0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n\n deque.push_front(10);\n deque.push_front(9);\n\n let expected = [9, 10, 0, 1, 2];\n let (front, back) = deque.as_slices();\n assert_eq!(&expected[..front.len()], front);\n assert_eq!(&expected[front.len()..], back);\n ```\n",
      "adt": {}
    },
    "io::IoSlice::<'a>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `IoSlice` wrapping a byte slice.\n\n # Panics\n\n Panics on Windows if the slice is larger than 4GB.\n",
      "adt": {
        "io::IoSlice": "Constructor"
      }
    },
    "io::Write::write_all_vectored": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to write multiple buffers into this writer.\n\n This method will continuously call [`write_vectored`] until there is no\n more data to be written or an error of non-[`ErrorKind::Interrupted`]\n kind is returned. This method will not return until all buffers have\n been successfully written or such an error occurs. The first error that\n is not of [`ErrorKind::Interrupted`] kind generated from this method\n will be returned.\n\n If the buffer contains no data, this will never call [`write_vectored`].\n\n # Notes\n\n Unlike [`write_vectored`], this takes a *mutable* reference to\n a slice of [`IoSlice`]s, not an immutable one. That's because we need to\n modify the slice to keep track of the bytes already written.\n\n Once this function returns, the contents of `bufs` are unspecified, as\n this depends on how many calls to [`write_vectored`] were necessary. It is\n best to understand this function as taking ownership of `bufs` and to\n not use `bufs` afterwards. The underlying buffers, to which the\n [`IoSlice`]s point (but not the [`IoSlice`]s themselves), are unchanged and\n can be reused.\n\n [`write_vectored`]: Write::write_vectored\n\n # Examples\n\n ```\n #![feature(write_all_vectored)]\n # fn main() -> std::io::Result<()> {\n\n use std::io::{Write, IoSlice};\n\n let mut writer = Vec::new();\n let bufs = &mut [\n     IoSlice::new(&[1]),\n     IoSlice::new(&[2, 3]),\n     IoSlice::new(&[4, 5, 6]),\n ];\n\n writer.write_all_vectored(bufs)?;\n // Note: the contents of `bufs` is now undefined, see the Notes section.\n\n assert_eq!(writer, &[1, 2, 3, 4, 5, 6]);\n # Ok(()) }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::VecDeque::<T, A>::clear": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clears the deque, removing all values.\n\n # Examples\n\n ```\n use std::collections::VecDeque;\n\n let mut deque = VecDeque::new();\n deque.push_back(1);\n deque.clear();\n assert!(deque.is_empty());\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::collections::VecDeque": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "io::IoSlice": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<alloc_crate::collections::VecDeque<u8, A> as io::copy::BufferedReaderSpec>::copy_to"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/copy.rs:138:5: 145:6",
  "src": "fn copy_to(&mut self, to: &mut (impl Write + ?Sized)) -> Result<u64> {\n        let len = self.len();\n        let (front, back) = self.as_slices();\n        let bufs = &mut [IoSlice::new(front), IoSlice::new(back)];\n        to.write_all_vectored(bufs)?;\n        self.clear();\n        Ok(len as u64)\n    }",
  "mir": "fn <alloc_crate::collections::VecDeque<u8, A> as io::copy::BufferedReaderSpec>::copy_to(_1: &mut alloc_crate::collections::VecDeque<u8, A>, _2: &mut impl Write + ?Sized) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let  _3: usize;\n    let mut _4: &alloc_crate::collections::VecDeque<u8, A>;\n    let  _5: &[u8];\n    let  _6: &[u8];\n    let mut _7: (&[u8], &[u8]);\n    let mut _8: &alloc_crate::collections::VecDeque<u8, A>;\n    let  _9: &mut [io::IoSlice<'_>; 2];\n    let mut _10: [io::IoSlice<'_>; 2];\n    let mut _11: io::IoSlice<'_>;\n    let mut _12: io::IoSlice<'_>;\n    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _14: core::result::Result<(), io::error::Error>;\n    let mut _15: &mut [io::IoSlice<'_>];\n    let mut _16: isize;\n    let  _17: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _18: ();\n    let mut _19: u64;\n    debug self => _1;\n    debug to => _2;\n    debug len => _3;\n    debug front => _5;\n    debug back => _6;\n    debug bufs => _9;\n    debug residual => _17;\n    debug val => ();\n    bb0: {\n        StorageLive(_4);\n        _4 = &(*_1);\n        _3 = alloc_crate::collections::VecDeque::<u8, A>::len(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &(*_1);\n        _7 = alloc_crate::collections::VecDeque::<u8, A>::as_slices(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _5 = (_7.0: &[u8]);\n        _6 = (_7.1: &[u8]);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = io::IoSlice::<'_>::new(_5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_12);\n        _12 = io::IoSlice::<'_>::new(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = [move _11, move _12];\n        StorageDead(_12);\n        StorageDead(_11);\n        _9 = &mut _10;\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = _9 as &mut [io::IoSlice<'_>];\n        _14 = <impl Write + ?Sized as io::Write>::write_all_vectored(_2, move _15) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_15);\n        _13 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _16 = discriminant(_13);\n        switchInt(move _16) -> [0: bb8, 1: bb9, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        StorageDead(_13);\n        _18 = alloc_crate::collections::VecDeque::<u8, A>::clear(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb9: {\n        _17 = move ((_13 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_17) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageLive(_19);\n        _19 = _3 as u64;\n        _0 = core::result::Result::Ok(move _19);\n        StorageDead(_19);\n        StorageDead(_10);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}