{
  "name": "thread::lifecycle::JoinInner::<'scope, T>::is_finished",
  "safe": true,
  "callees": {
    "alloc_crate::sync::Arc::<T, A>::strong_count": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the number of strong (`Arc`) pointers to this allocation.\n\n # Safety\n\n This method by itself is safe, but using it correctly requires extra care.\n Another thread can change the strong count at any time,\n including potentially between calling this method and acting on the result.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n let _also_five = Arc::clone(&five);\n\n // This assertion is deterministic because we haven't shared\n // the `Arc` between threads.\n assert_eq!(2, Arc::strong_count(&five));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::sync::Arc": [
      "Ref"
    ],
    "thread::lifecycle::JoinInner": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Ref"
    ]
  },
  "path": 4501,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/lifecycle.rs:228:5: 230:6",
  "src": "pub(super) fn is_finished(&self) -> bool {\n        Arc::strong_count(&self.packet) == 1\n    }",
  "mir": "fn thread::lifecycle::JoinInner::<'scope, T>::is_finished(_1: &thread::lifecycle::JoinInner<'_, T>) -> bool {\n    let mut _0: bool;\n    let mut _2: usize;\n    let  _3: &alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _3 = &((*_1).2: alloc_crate::sync::Arc<thread::lifecycle::Packet<'_, T>>);\n        _2 = alloc_crate::sync::Arc::<thread::lifecycle::Packet<'_, T>>::strong_count(_3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _0 = Eq(move _2, 1_usize);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}