{
  "name": "<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write",
  "safe": true,
  "callees": {
    "core::slice::memchr::memrchr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the last index matching the byte `x` in `text`.\n",
      "adt": {}
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::flush_if_completed_line": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Flushes the buffer iff the last byte is a newline (indicating that an\n earlier write only succeeded partially, and we want to retry flushing\n the buffered line before continuing with a subsequent write).\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::Write::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a buffer into this writer, returning how many bytes were written.\n\n This function will attempt to write the entire contents of `buf`, but\n the entire write might not succeed, or the write may also generate an\n error. Typically, a call to `write` represents one attempt to write to\n any wrapped object.\n\n Calls to `write` are not guaranteed to block waiting for data to be\n written, and a write which would otherwise block can be indicated through\n an [`Err`] variant.\n\n If this method consumed `n > 0` bytes of `buf` it must return [`Ok(n)`].\n If the return value is `Ok(n)` then `n` must satisfy `n <= buf.len()`.\n A return value of `Ok(0)` typically means that the underlying object is\n no longer able to accept bytes and will likely not be able to in the\n future as well, or that the buffer provided is empty.\n\n # Errors\n\n Each call to `write` may generate an I/O error indicating that the\n operation could not be completed. If an error is returned then no bytes\n in the buffer were written to this writer.\n\n It is **not** considered an error if the entire buffer could not be\n written to this writer.\n\n An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the\n write operation should be retried if there is nothing else to do.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // Writes some prefix of the byte string, not necessarily all of it.\n     buffer.write(b\"some bytes\")?;\n     Ok(())\n }\n ```\n\n [`Ok(n)`]: Ok\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::inner_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the inner writer (that is, the writer\n wrapped by the BufWriter). Be careful with this writer, as writes to\n it will bypass the buffer.\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "MutableAsArgument"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes the internal buffer can hold without flushing.\n\n # Examples\n\n ```no_run\n use std::io::BufWriter;\n use std::net::TcpStream;\n\n let buf_writer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n\n // Check the capacity of the inner buffer\n let capacity = buf_writer.capacity();\n // Calculate how many bytes can be written without flushing\n let without_flush = capacity - buf_writer.buffer().len();\n ```\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "ImmutableAsArgument"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::write_to_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Buffer some data without flushing it, regardless of the size of the\n data. Writes as much as possible without exceeding capacity. Returns\n the number of bytes written.\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "io::buffered::linewritershim::LineWriterShim": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "io::buffered::bufwriter::BufWriter": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::ops::RangeTo": [
      "Plain"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:69:5: 143:6",
  "src": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        let newline_idx = match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                return self.buffer.write(buf);\n            }\n            // Otherwise, arrange for the lines to be written directly to the\n            // inner writer.\n            Some(newline_idx) => newline_idx + 1,\n        };\n\n        // Flush existing content to prepare for our write. We have to do this\n        // before attempting to write `buf` in order to maintain consistency;\n        // if we add `buf` to the buffer then try to flush it all at once,\n        // we're obligated to return Ok(), which would mean suppressing any\n        // errors that occur during flush.\n        self.buffer.flush_buf()?;\n\n        // This is what we're going to try to write directly to the inner\n        // writer. The rest will be buffered, if nothing goes wrong.\n        let lines = &buf[..newline_idx];\n\n        // Write `lines` directly to the inner writer. In keeping with the\n        // `write` convention, make at most one attempt to add new (unbuffered)\n        // data. Because this write doesn't touch the BufWriter state directly,\n        // and the buffer is known to be empty, we don't need to worry about\n        // self.buffer.panicked here.\n        let flushed = self.inner_mut().write(lines)?;\n\n        // If buffer returns Ok(0), propagate that to the caller without\n        // doing additional buffering; otherwise we're just guaranteeing\n        // an \"ErrorKind::WriteZero\" later.\n        if flushed == 0 {\n            return Ok(0);\n        }\n\n        // Now that the write has succeeded, buffer the rest (or as much of\n        // the rest as possible). If there were any unwritten newlines, we\n        // only buffer out to the last unwritten newline that fits in the\n        // buffer; this helps prevent flushing partial lines on subsequent\n        // calls to LineWriterShim::write.\n\n        // Handle the cases in order of most-common to least-common, under\n        // the presumption that most writes succeed in totality, and that most\n        // writes are smaller than the buffer.\n        // - Is this a partial line (ie, no newlines left in the unwritten tail)\n        // - If not, does the data out to the last unwritten newline fit in\n        //   the buffer?\n        // - If not, scan for the last newline that *does* fit in the buffer\n        let tail = if flushed >= newline_idx {\n            let tail = &buf[flushed..];\n            // Avoid unnecessary short writes by not splitting the remaining\n            // bytes if they're larger than the buffer.\n            // They can be written in full by the next call to write.\n            if tail.len() >= self.buffer.capacity() {\n                return Ok(flushed);\n            }\n            tail\n        } else if newline_idx - flushed <= self.buffer.capacity() {\n            &buf[flushed..newline_idx]\n        } else {\n            let scan_area = &buf[flushed..];\n            let scan_area = &scan_area[..self.buffer.capacity()];\n            match memchr::memrchr(b'\\n', scan_area) {\n                Some(newline_idx) => &scan_area[..newline_idx + 1],\n                None => scan_area,\n            }\n        };\n\n        let buffered = self.buffer.write_to_buf(tail);\n        Ok(flushed + buffered)\n    }",
  "mir": "fn <io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write(_1: &mut io::buffered::linewritershim::LineWriterShim<'_, W>, _2: &[u8]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let  _3: usize;\n    let mut _4: core::option::Option<usize>;\n    let mut _5: isize;\n    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _7: core::result::Result<(), io::error::Error>;\n    let mut _8: isize;\n    let  _9: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _10: usize;\n    let mut _11: (usize, bool);\n    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _13: core::result::Result<(), io::error::Error>;\n    let mut _14: isize;\n    let  _15: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _16: &[u8];\n    let mut _17: core::ops::RangeTo<usize>;\n    let mut _18: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _19: core::result::Result<usize, io::error::Error>;\n    let mut _20: &mut W;\n    let mut _21: isize;\n    let  _22: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _23: usize;\n    let  _24: &[u8];\n    let mut _25: bool;\n    let  _26: &[u8];\n    let mut _27: core::ops::RangeFrom<usize>;\n    let mut _28: bool;\n    let mut _29: usize;\n    let mut _30: usize;\n    let mut _31: &io::buffered::bufwriter::BufWriter<W>;\n    let  _32: &[u8];\n    let mut _33: bool;\n    let mut _34: usize;\n    let mut _35: (usize, bool);\n    let mut _36: usize;\n    let mut _37: &io::buffered::bufwriter::BufWriter<W>;\n    let  _38: &[u8];\n    let mut _39: core::ops::Range<usize>;\n    let  _40: &[u8];\n    let  _41: &[u8];\n    let mut _42: core::ops::RangeFrom<usize>;\n    let  _43: &[u8];\n    let mut _44: core::ops::RangeTo<usize>;\n    let mut _45: usize;\n    let mut _46: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _47: core::option::Option<usize>;\n    let mut _48: isize;\n    let  _49: usize;\n    let  _50: &[u8];\n    let mut _51: core::ops::RangeTo<usize>;\n    let mut _52: usize;\n    let mut _53: (usize, bool);\n    let  _54: usize;\n    let mut _55: &[u8];\n    let mut _56: usize;\n    let mut _57: (usize, bool);\n    let mut _58: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _59: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _60: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _61: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _62: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _63: &mut io::buffered::bufwriter::BufWriter<W>;\n    debug self => _1;\n    debug buf => _2;\n    debug newline_idx => _3;\n    debug residual => _9;\n    debug val => ();\n    debug newline_idx => _10;\n    debug residual => _15;\n    debug val => ();\n    debug lines => _16;\n    debug flushed => _23;\n    debug residual => _22;\n    debug val => _23;\n    debug tail => _24;\n    debug tail => _26;\n    debug scan_area => _41;\n    debug scan_area => _43;\n    debug newline_idx => _49;\n    debug buffered => _54;\n    bb0: {\n        StorageLive(_4);\n        _4 = core::slice::memchr::memrchr(10_u8, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = discriminant(_4);\n        switchInt(move _5) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _10 = ((_4 as variant#1).0: usize);\n        _11 = CheckedAdd(_10, 1_usize);\n        assert(!move (_11.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _10, 1_usize) -> [success: bb11, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = io::buffered::linewritershim::LineWriterShim::<'_, W>::flush_if_completed_line(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _6 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        _8 = discriminant(_6);\n        switchInt(move _8) -> [0: bb7, 1: bb8, otherwise: bb2];\n    }\n    bb7: {\n        StorageDead(_6);\n        _58 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _0 = <io::buffered::bufwriter::BufWriter<W> as io::Write>::write(_58, _2) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _9 = move ((_6 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        goto -> bb51;\n    }\n    bb10: {\n        goto -> bb51;\n    }\n    bb11: {\n        _3 = move (_11.0: usize);\n        StorageDead(_4);\n        StorageLive(_12);\n        StorageLive(_13);\n        _59 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _13 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_59) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _12 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _13) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_13);\n        _14 = discriminant(_12);\n        switchInt(move _14) -> [0: bb14, 1: bb15, otherwise: bb2];\n    }\n    bb14: {\n        StorageDead(_12);\n        StorageLive(_17);\n        _17 = RangeTo(_3);\n        _16 = <[u8] as core::ops::Index<core::ops::RangeTo<usize>>>::index(_2, move _17) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _15 = move ((_12 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_15) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_12);\n        goto -> bb52;\n    }\n    bb17: {\n        StorageDead(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = io::buffered::linewritershim::LineWriterShim::<'_, W>::inner_mut(_1) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _19 = <W as io::Write>::write(_20, _16) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _18 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _19) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_19);\n        _21 = discriminant(_18);\n        switchInt(move _21) -> [0: bb21, 1: bb22, otherwise: bb2];\n    }\n    bb21: {\n        _23 = ((_18 as variant#0).0: usize);\n        StorageDead(_18);\n        switchInt(_23) -> [0: bb24, otherwise: bb25];\n    }\n    bb22: {\n        _22 = move ((_18 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_22) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_18);\n        goto -> bb50;\n    }\n    bb24: {\n        _0 = core::result::Result::Ok(0_usize);\n        goto -> bb50;\n    }\n    bb25: {\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = Ge(_23, _3);\n        switchInt(move _25) -> [0: bb27, otherwise: bb26];\n    }\n    bb26: {\n        StorageLive(_27);\n        _27 = RangeFrom(_23);\n        _26 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_2, move _27) -> [return: bb28, unwind unreachable];\n    }\n    bb27: {\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _35 = CheckedSub(_3, _23);\n        assert(!move (_35.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _3, _23) -> [success: bb32, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = PtrMetadata(_26);\n        StorageLive(_30);\n        StorageLive(_31);\n        _60 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _31 = &(*_60);\n        _30 = io::buffered::bufwriter::BufWriter::<W>::capacity(move _31) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_31);\n        _28 = Ge(move _29, move _30);\n        switchInt(move _28) -> [0: bb31, otherwise: bb30];\n    }\n    bb30: {\n        StorageDead(_30);\n        StorageDead(_29);\n        _0 = core::result::Result::Ok(_23);\n        StorageDead(_28);\n        StorageDead(_25);\n        StorageDead(_24);\n        goto -> bb50;\n    }\n    bb31: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        _24 = _26;\n        goto -> bb47;\n    }\n    bb32: {\n        _34 = move (_35.0: usize);\n        StorageLive(_36);\n        StorageLive(_37);\n        _61 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _37 = &(*_61);\n        _36 = io::buffered::bufwriter::BufWriter::<W>::capacity(move _37) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_37);\n        _33 = Le(move _34, move _36);\n        switchInt(move _33) -> [0: bb36, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_36);\n        StorageDead(_34);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = Range(_23, _3);\n        _38 = <[u8] as core::ops::Index<core::ops::Range<usize>>>::index(_2, move _39) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_39);\n        _32 = _38;\n        goto -> bb46;\n    }\n    bb36: {\n        StorageDead(_36);\n        StorageDead(_34);\n        StorageLive(_40);\n        StorageLive(_42);\n        _42 = RangeFrom(_23);\n        _41 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_2, move _42) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_42);\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _62 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _46 = &(*_62);\n        _45 = io::buffered::bufwriter::BufWriter::<W>::capacity(move _46) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_46);\n        _44 = RangeTo(move _45);\n        StorageDead(_45);\n        _43 = <[u8] as core::ops::Index<core::ops::RangeTo<usize>>>::index(_41, move _44) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_44);\n        StorageLive(_47);\n        _47 = core::slice::memchr::memrchr(10_u8, _43) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _48 = discriminant(_47);\n        switchInt(move _48) -> [0: bb41, 1: bb42, otherwise: bb2];\n    }\n    bb41: {\n        _40 = _43;\n        goto -> bb45;\n    }\n    bb42: {\n        _49 = ((_47 as variant#1).0: usize);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        _53 = CheckedAdd(_49, 1_usize);\n        assert(!move (_53.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _49, 1_usize) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _52 = move (_53.0: usize);\n        _51 = RangeTo(move _52);\n        StorageDead(_52);\n        _50 = <[u8] as core::ops::Index<core::ops::RangeTo<usize>>>::index(_43, move _51) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_51);\n        _40 = _50;\n        goto -> bb45;\n    }\n    bb45: {\n        StorageDead(_47);\n        _32 = _40;\n        StorageDead(_40);\n        goto -> bb46;\n    }\n    bb46: {\n        _24 = _32;\n        StorageDead(_33);\n        StorageDead(_32);\n        goto -> bb47;\n    }\n    bb47: {\n        StorageDead(_25);\n        _63 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        StorageLive(_55);\n        _55 = _24;\n        _54 = io::buffered::bufwriter::BufWriter::<W>::write_to_buf(_63, move _55) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_55);\n        StorageLive(_56);\n        _57 = CheckedAdd(_23, _54);\n        assert(!move (_57.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _23, _54) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _56 = move (_57.0: usize);\n        _0 = core::result::Result::Ok(move _56);\n        StorageDead(_56);\n        StorageDead(_50);\n        StorageDead(_38);\n        StorageDead(_24);\n        goto -> bb53;\n    }\n    bb50: {\n        goto -> bb52;\n    }\n    bb51: {\n        StorageDead(_4);\n        goto -> bb52;\n    }\n    bb52: {\n        goto -> bb53;\n    }\n    bb53: {\n        return;\n    }\n}\n",
  "doc": " Writes some data into this BufReader with line buffering.\n\n This means that, if any newlines are present in the data, the data up to\n the last newline is sent directly to the underlying writer, and data\n after it is buffered. Returns the number of bytes written.\n\n This function operates on a \"best effort basis\"; in keeping with the\n convention of `Write::write`, it makes at most one attempt to write\n new data to the underlying writer. If that write only reports a partial\n success, the remaining data will be buffered.\n\n Because this function attempts to send completed lines to the underlying\n writer, it will also flush the existing buffer if it ends with a\n newline, even if the incoming data does not contain any newlines.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}