{
  "name": "io::impls::<impl io::Read for alloc_crate::boxed::Box<R>>::read_exact",
  "safe": true,
  "callees": {
    "io::Read::read_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the exact number of bytes required to fill `buf`.\n\n This function reads as many bytes as necessary to completely fill the\n specified buffer `buf`.\n\n *Implementations* of this method can make no assumptions about the contents of `buf` when\n this function is called. It is recommended that implementations only write data to `buf`\n instead of reading its contents. The documentation on [`read`] has a more detailed\n explanation of this subject.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If this function encounters an \"end of file\" before completely filling\n the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n The contents of `buf` are unspecified in this case.\n\n If any other read error is encountered then this function immediately\n returns. The contents of `buf` are unspecified in this case.\n\n If this function returns an error, it is unspecified how many bytes it\n has read, but it will never read more than would be necessary to\n completely fill the buffer.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read`]: Read::read\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = [0; 10];\n\n     // read exactly 10 bytes\n     f.read_exact(&mut buffer)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "alloc_crate::boxed::Box": [
      "Plain",
      "Deref",
      "Unknown([Field(0, Ty { id: 5751, kind: RigidTy(Adt(AdtDef(DefId { id: 4689, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 3404, kind: Param(ParamTy { index: 0, name: \"R\" }) })]))) }), Field(0, Ty { id: 5752, kind: RigidTy(Adt(AdtDef(DefId { id: 4690, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 3404, kind: Param(ParamTy { index: 0, name: \"R\" }) })]))) })])",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1827,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/impls.rs:184:5: 186:6",
  "src": "fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        (**self).read_exact(buf)\n    }",
  "mir": "fn io::impls::<impl io::Read for alloc_crate::boxed::Box<R>>::read_exact(_1: &mut alloc_crate::boxed::Box<R>, _2: &mut [u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: &mut R;\n    let mut _4: alloc_crate::boxed::Box<R>;\n    let mut _5: *const R;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        _4 = (*_1);\n        _5 = ((_4.0: core::ptr::Unique<R>).0: core::ptr::NonNull<R>) as *const R;\n        _3 = &mut (*_5);\n        _0 = <R as io::Read>::read_exact(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}