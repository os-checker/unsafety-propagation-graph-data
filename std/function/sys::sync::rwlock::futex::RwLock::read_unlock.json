{
  "name": "sys::sync::rwlock::futex::RwLock::read_unlock",
  "safe": false,
  "callees": {
    "core::sync::atomic::AtomicU32::fetch_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Subtracts from the current value, returning the previous value.\n\n This operation wraps around on overflow.\n\n `fetch_sub` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. All ordering modes are possible. Note that using\n [`Acquire`] makes the store part of this operation [`Relaxed`], and\n using [`Release`] makes the load part [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Examples\n\n ```\n\n assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 20);\n assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\n",
      "adt": {}
    },
    "sys::sync::rwlock::futex::has_readers_waiting": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::sync::rwlock::futex::has_writers_waiting": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "sys::sync::rwlock::futex::is_unlocked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::sync::rwlock::futex::RwLock::wake_writer_or_readers": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wakes up waiting threads after unlocking.\n\n If both are waiting, this will wake up only one writer, but will fall\n back to waking up readers if there was no writer to wake up.\n",
      "adt": {
        "sys::sync::rwlock::futex::RwLock": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::sync::atomic::AtomicU32": [
      "Ref"
    ],
    "sys::sync::rwlock::futex::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::sync::rwlock::futex::RwLock::read_unlock"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/rwlock/futex.rs:110:5: 121:6",
  "src": "pub unsafe fn read_unlock(&self) {\n        let state = self.state.fetch_sub(READ_LOCKED, Release) - READ_LOCKED;\n\n        // It's impossible for a reader to be waiting on a read-locked RwLock,\n        // except if there is also a writer waiting.\n        debug_assert!(!has_readers_waiting(state) || has_writers_waiting(state));\n\n        // Wake up a writer if we were the last reader and there's a writer waiting.\n        if is_unlocked(state) && has_writers_waiting(state) {\n            self.wake_writer_or_readers(state);\n        }\n    }",
  "mir": "fn sys::sync::rwlock::futex::RwLock::read_unlock(_1: &sys::sync::rwlock::futex::RwLock) -> () {\n    let mut _0: ();\n    let  _2: u32;\n    let mut _3: u32;\n    let mut _4: &core::sync::atomic::AtomicU32;\n    let mut _5: core::sync::atomic::Ordering;\n    let mut _6: (u32, bool);\n    let mut _7: bool;\n    let mut _8: bool;\n    let mut _9: !;\n    let mut _10: bool;\n    let mut _11: bool;\n    let  _12: ();\n    debug self => _1;\n    debug state => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: core::sync::atomic::AtomicU32);\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Release;\n        _3 = core::sync::atomic::AtomicU32::fetch_sub(move _4, sys::sync::rwlock::futex::READ_LOCKED, move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _6 = CheckedSub(_3, sys::sync::rwlock::futex::READ_LOCKED);\n        assert(!move (_6.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _3, sys::sync::rwlock::futex::READ_LOCKED) -> [success: bb2, unwind unreachable];\n    }\n    bb2: {\n        _2 = move (_6.0: u32);\n        StorageDead(_3);\n        StorageLive(_7);\n        _7 = sys::sync::rwlock::futex::has_readers_waiting(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _7) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = sys::sync::rwlock::futex::has_writers_waiting(_2) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        goto -> bb9;\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        goto -> bb9;\n    }\n    bb8: {\n        _9 = core::panicking::panic(\"assertion failed: !has_readers_waiting(state) || has_writers_waiting(state)\") -> unwind unreachable;\n    }\n    bb9: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        _10 = sys::sync::rwlock::futex::is_unlocked(_2) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _10) -> [0: bb16, otherwise: bb11];\n    }\n    bb11: {\n        StorageLive(_11);\n        _11 = sys::sync::rwlock::futex::has_writers_waiting(_2) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _11) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        _12 = sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(_1, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        goto -> bb17;\n    }\n    bb15: {\n        goto -> bb17;\n    }\n    bb16: {\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_11);\n        StorageDead(_10);\n        return;\n    }\n}\n",
  "doc": " # Safety\n\n The `RwLock` must be read-locked (N readers) in order to call this.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}