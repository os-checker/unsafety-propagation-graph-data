{
  "name": "<thread::thread::thread_name_string::ThreadNameString as core::convert::From<alloc_crate::string::String>>::from",
  "safe": true,
  "callees": {
    "alloc_crate::ffi::CString::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new C-compatible string from a container of bytes.\n\n This function will consume the provided data and use the\n underlying bytes to construct a new string, ensuring that\n there is a trailing 0 byte. This trailing 0 byte will be\n appended by this function; the provided data should *not*\n contain any 0 bytes in it.\n\n # Examples\n\n ```ignore (extern-declaration)\n use std::ffi::CString;\n use std::os::raw::c_char;\n\n extern \"C\" { fn puts(s: *const c_char); }\n\n let to_print = CString::new(\"Hello!\").expect(\"CString::new failed\");\n unsafe {\n     puts(to_print.as_ptr());\n }\n ```\n\n # Errors\n\n This function will return an error if the supplied bytes contain an\n internal 0 byte. The [`NulError`] returned will contain the bytes as well as\n the position of the nul byte.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::string::String": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "alloc_crate::ffi::CString": [
      "Plain"
    ],
    "thread::thread::thread_name_string::ThreadNameString": [
      "Plain"
    ]
  },
  "path": 4561,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/thread.rs:22:9: 26:10",
  "src": "fn from(s: String) -> Self {\n            Self {\n                inner: CString::new(s).expect(\"thread name may not contain interior null bytes\"),\n            }\n        }",
  "mir": "fn <thread::thread::thread_name_string::ThreadNameString as core::convert::From<alloc_crate::string::String>>::from(_1: alloc_crate::string::String) -> thread::thread::thread_name_string::ThreadNameString {\n    let mut _0: thread::thread::thread_name_string::ThreadNameString;\n    let mut _2: alloc_crate::ffi::CString;\n    let mut _3: core::result::Result<alloc_crate::ffi::CString, alloc_crate::ffi::NulError>;\n    let mut _4: &str;\n    debug s => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = alloc_crate::ffi::CString::new::<alloc_crate::string::String>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = \"thread name may not contain interior null bytes\";\n        _2 = core::result::Result::<alloc_crate::ffi::CString, alloc_crate::ffi::NulError>::expect(move _3, move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        _0 = ThreadNameString(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}