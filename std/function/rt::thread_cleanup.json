{
  "name": "rt::thread_cleanup",
  "safe": true,
  "callees": {
    "panic::catch_unwind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n\n This function will return `Ok` with the closure's result if the closure does\n not panic, and will return `Err(cause)` if the closure panics. The `cause`\n returned is the object with which panic was originally invoked.\n\n Rust functions that are expected to be called from foreign code that does\n not support unwinding (such as C compiled with `-fno-exceptions`) should be\n defined using `extern \"C\"`, which ensures that if the Rust code panics, it\n is automatically caught and the process is aborted. If this is the desired\n behavior, it is not necessary to use `catch_unwind` explicitly. This\n function should instead be used when more graceful error-handling is needed.\n\n It is **not** recommended to use this function for a general try/catch\n mechanism. The [`Result`] type is more appropriate to use for functions that\n can fail on a regular basis. Additionally, this function is not guaranteed\n to catch all panics, see the \"Notes\" section below.\n\n The closure provided is required to adhere to the [`UnwindSafe`] trait to\n ensure that all captured variables are safe to cross this boundary. The\n purpose of this bound is to encode the concept of [exception safety][rfc] in\n the type system. Most usage of this function should not need to worry about\n this bound as programs are naturally unwind safe without `unsafe` code. If\n it becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to\n quickly assert that the usage here is indeed unwind safe.\n\n [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n\n # Notes\n\n This function **might not catch all Rust panics**. A Rust panic is not\n always implemented via unwinding, but can be implemented by aborting the\n process as well. This function *only* catches unwinding panics, not those\n that abort the process.\n\n If a custom panic hook has been set, it will be invoked before the panic is\n caught, before unwinding.\n\n Although unwinding into Rust code with a foreign exception (e.g. an\n exception thrown from C++ code, or a `panic!` in Rust code compiled or\n linked with a different runtime) via an appropriate ABI (e.g. `\"C-unwind\"`)\n is permitted, catching such an exception using this function will have one\n of two behaviors, and it is unspecified which will occur:\n\n * The process aborts, after executing all destructors of `f` and the\n   functions it called.\n * The function returns a `Result::Err` containing an opaque type.\n\n Finally, be **careful in how you drop the result of this function**. If it\n is `Err`, it contains the panic payload, and dropping that may in turn\n panic!\n\n # Examples\n\n ```\n use std::panic;\n\n let result = panic::catch_unwind(|| {\n     println!(\"hello!\");\n });\n assert!(result.is_ok());\n\n let result = panic::catch_unwind(|| {\n     panic!(\"oh no!\");\n });\n assert!(result.is_err());\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    },
    "rt::handle_rt_panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::rt::thread_cleanup"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:126:1: 134:2",
  "src": "pub(crate) fn thread_cleanup() {\n    // This function is run in situations where unwinding leads to an abort\n    // (think `extern \"C\"` functions). Abort here instead so that we can\n    // print a nice message.\n    panic::catch_unwind(|| {\n        crate::thread::drop_current();\n    })\n    .unwrap_or_else(handle_rt_panic);\n}",
  "mir": "fn rt::thread_cleanup() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let mut _2: core::result::Result<(), alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>;\n    bb0: {\n        StorageLive(_2);\n        _2 = panic::catch_unwind::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:130:25: 130:27}, ()>(ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:130:25: 130:27}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = core::result::Result::<(), alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>::unwrap_or_else::<fn(alloc_crate::boxed::Box<(dyn core::any::Any + core::marker::Send + 'static)>) {rt::handle_rt_panic::<()>}>(move _2, rt::handle_rt_panic::<()>) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Clean up the thread-local runtime state. This *should* be run after all other\n code managed by the Rust runtime, but will not cause UB if that condition is\n not fulfilled. Also note that this function is not guaranteed to be run, but\n skipping it will cause leaks and therefore is to be avoided.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}