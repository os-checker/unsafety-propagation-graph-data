{
  "name": "sys::fs::common::remove_dir_all_recursive",
  "safe": true,
  "callees": {
    "fs::read_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the entries within a directory.\n\n The iterator will yield instances of <code>[io::Result]<[DirEntry]></code>.\n New errors may be encountered after an iterator is initially constructed.\n Entries for the current and parent directories (typically `.` and `..`) are\n skipped.\n\n The order in which `read_dir` returns entries can change between calls. If reproducible\n ordering is required, the entries should be explicitly sorted.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `opendir` function on Unix\n and the `FindFirstFileEx` function on Windows. Advancing the iterator\n currently corresponds to `readdir` on Unix and `FindNextFile` on Windows.\n Note that, this [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n The order in which this iterator returns entries is platform and filesystem\n dependent.\n\n # Errors\n\n This function will return an error in the following situations, but is not\n limited to just these cases:\n\n * The provided `path` doesn't exist.\n * The process lacks permissions to view the contents.\n * The `path` points at a non-directory file.\n\n # Examples\n\n ```\n use std::io;\n use std::fs::{self, DirEntry};\n use std::path::Path;\n\n // one possible implementation of walking a directory only visiting files\n fn visit_dirs(dir: &Path, cb: &dyn Fn(&DirEntry)) -> io::Result<()> {\n     if dir.is_dir() {\n         for entry in fs::read_dir(dir)? {\n             let entry = entry?;\n             let path = entry.path();\n             if path.is_dir() {\n                 visit_dirs(&path, cb)?;\n             } else {\n                 cb(&entry);\n             }\n         }\n     }\n     Ok(())\n }\n ```\n\n ```rust,no_run\n use std::{fs, io};\n\n fn main() -> io::Result<()> {\n     let mut entries = fs::read_dir(\".\")?\n         .map(|res| res.map(|e| e.path()))\n         .collect::<Result<Vec<_>, io::Error>>()?;\n\n     // The order in which `read_dir` returns entries is not guaranteed. If reproducible\n     // ordering is required the entries should be explicitly sorted.\n\n     entries.sort();\n\n     // The entries have now been sorted by their path.\n\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::ReadDir": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "fs::DirEntry::file_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the file type for the file that this entry points at.\n\n This function will not traverse symlinks if this entry points at a\n symlink.\n\n # Platform-specific behavior\n\n On Windows and most Unix platforms this function is free (no extra\n system calls needed), but some Unix platforms may require the equivalent\n call to `symlink_metadata` to learn about the target file type.\n\n # Examples\n\n ```\n use std::fs;\n\n if let Ok(entries) = fs::read_dir(\".\") {\n     for entry in entries {\n         if let Ok(entry) = entry {\n             // Here, `entry` is a `DirEntry`.\n             if let Ok(file_type) = entry.file_type() {\n                 // Now let's show our entry's file type!\n                 println!(\"{:?}: {:?}\", entry.path(), file_type);\n             } else {\n                 println!(\"Couldn't get file type for {:?}\", entry.path());\n             }\n         }\n     }\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::DirEntry": "ImmutableAsArgument",
        "fs::FileType": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::try_trait::residual_into_try_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "fs::FileType::is_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests whether this file type represents a directory. The\n result is mutually exclusive to the results of\n [`is_file`] and [`is_symlink`]; only zero or one of these\n tests may pass.\n\n [`is_file`]: FileType::is_file\n [`is_symlink`]: FileType::is_symlink\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs;\n\n     let metadata = fs::metadata(\"foo.txt\")?;\n     let file_type = metadata.file_type();\n\n     assert_eq!(file_type.is_dir(), false);\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::FileType": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sys::fs::common::remove_dir_all_recursive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "fs::remove_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a file from the filesystem.\n\n Note that there is no\n guarantee that the file is immediately deleted (e.g., depending on\n platform, other open file descriptors may prevent immediate removal).\n\n # Platform-specific behavior\n\n This function currently corresponds to the `unlink` function on Unix.\n On Windows, `DeleteFile` is used or `CreateFileW` and `SetInformationByHandle` for readonly files.\n Note that, this [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n # Errors\n\n This function will return an error in the following situations, but is not\n limited to just these cases:\n\n * `path` points to a directory.\n * The file doesn't exist.\n * The user lacks permissions to remove the file.\n\n This function will only ever return an error of kind `NotFound` if the given\n path does not exist. Note that the inverse is not true,\n ie. if a path does not exist, its removal may fail for a number of reasons,\n such as insufficient permissions.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     fs::remove_file(\"a.txt\")?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    },
    "io::error::Error::kind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the corresponding [`ErrorKind`] for this error.\n\n This may be a value set by Rust code constructing custom `io::Error`s,\n or if this `io::Error` was sourced from the operating system,\n it will be a value inferred from the system's error encoding.\n See [`last_os_error`] for more details.\n\n [`last_os_error`]: Error::last_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_error(err: Error) {\n     println!(\"{:?}\", err.kind());\n }\n\n fn main() {\n     // As no error has (visibly) occurred, this may print anything!\n     // It likely prints a placeholder for unidentified (non-)errors.\n     print_error(Error::last_os_error());\n     // Will print \"AddrInUse\".\n     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "io::error::Error": "ImmutableAsArgument",
        "io::error::ErrorKind": "Constructor"
      }
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "fs::remove_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes an empty directory.\n\n If you want to remove a directory that is not empty, as well as all\n of its contents recursively, consider using [`remove_dir_all`]\n instead.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `rmdir` function on Unix\n and the `RemoveDirectory` function on Windows.\n Note that, this [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n # Errors\n\n This function will return an error in the following situations, but is not\n limited to just these cases:\n\n * `path` doesn't exist.\n * `path` isn't a directory.\n * The user lacks permissions to remove the directory at the provided `path`.\n * The directory isn't empty.\n\n This function will only ever return an error of kind `NotFound` if the given\n path does not exist. Note that the inverse is not true,\n ie. if a path does not exist, its removal may fail for a number of reasons,\n such as insufficient permissions.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     fs::remove_dir(\"/some/dir\")?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "sys_common::ignore_notfound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "fs::DirEntry::path": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the full path to the file that this entry represents.\n\n The full path is created by joining the original path to `read_dir`\n with the filename of this entry.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     for entry in fs::read_dir(\".\")? {\n         let dir = entry?;\n         println!(\"{:?}\", dir.path());\n     }\n     Ok(())\n }\n ```\n\n This prints output like:\n\n ```text\n \"./whatever.txt\"\n \"./foo.html\"\n \"./hello_world.rs\"\n ```\n\n The exact text, of course, depends on what files you have in `.`.\n",
      "adt": {
        "fs::DirEntry": "ImmutableAsArgument",
        "path::PathBuf": "Constructor"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4224, kind: RigidTy(Adt(AdtDef(DefId { id: 6245, name: \"fs::ReadDir\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4225, kind: RigidTy(Adt(AdtDef(DefId { id: 6247, name: \"fs::DirEntry\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4118, kind: RigidTy(Adt(AdtDef(DefId { id: 6195, name: \"fs::FileType\" }), GenericArgs([]))) })])"
    ],
    "fs::ReadDir": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4222, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 4225, kind: RigidTy(Adt(AdtDef(DefId { id: 6247, name: \"fs::DirEntry\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "fs::DirEntry": [
      "Plain",
      "Ref"
    ],
    "fs::FileType": [
      "Plain",
      "Ref"
    ],
    "path::PathBuf": [
      "Ref",
      "Plain"
    ],
    "io::error::Error": [
      "Ref"
    ],
    "io::error::ErrorKind": [
      "Plain",
      "Ref"
    ]
  },
  "path": 3434,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/common.rs:34:1: 52:2",
  "src": "fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n    for child in fs::read_dir(path)? {\n        let result: io::Result<()> = try {\n            let child = child?;\n            if child.file_type()?.is_dir() {\n                remove_dir_all_recursive(&child.path())?;\n            } else {\n                fs::remove_file(&child.path())?;\n            }\n        };\n        // ignore internal NotFound errors to prevent race conditions\n        if let Err(err) = &result\n            && err.kind() != io::ErrorKind::NotFound\n        {\n            return result;\n        }\n    }\n    ignore_notfound(fs::remove_dir(path))\n}",
  "mir": "fn sys::fs::common::remove_dir_all_recursive(_1: &path::Path) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _2: fs::ReadDir;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::ReadDir>;\n    let mut _4: core::result::Result<fs::ReadDir, io::error::Error>;\n    let mut _5: isize;\n    let  _6: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _7: fs::ReadDir;\n    let mut _8: fs::ReadDir;\n    let mut _9: core::option::Option<core::result::Result<fs::DirEntry, io::error::Error>>;\n    let mut _10: &mut fs::ReadDir;\n    let mut _11: isize;\n    let  _12: core::result::Result<fs::DirEntry, io::error::Error>;\n    let  _13: core::result::Result<(), io::error::Error>;\n    let  _14: fs::DirEntry;\n    let mut _15: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::DirEntry>;\n    let mut _16: isize;\n    let  _17: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _18: fs::DirEntry;\n    let mut _19: bool;\n    let mut _20: &fs::FileType;\n    let  _21: fs::FileType;\n    let mut _22: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::FileType>;\n    let mut _23: core::result::Result<fs::FileType, io::error::Error>;\n    let mut _24: &fs::DirEntry;\n    let mut _25: isize;\n    let  _26: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _27: fs::FileType;\n    let mut _28: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _29: core::result::Result<(), io::error::Error>;\n    let  _30: &path::Path;\n    let  _31: &path::PathBuf;\n    let  _32: path::PathBuf;\n    let mut _33: &fs::DirEntry;\n    let mut _34: isize;\n    let  _35: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _37: core::result::Result<(), io::error::Error>;\n    let mut _38: &path::PathBuf;\n    let  _39: path::PathBuf;\n    let mut _40: &fs::DirEntry;\n    let mut _41: isize;\n    let  _42: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _43: &core::result::Result<(), io::error::Error>;\n    let mut _44: isize;\n    let  _45: &io::error::Error;\n    let mut _46: bool;\n    let mut _47: &io::error::ErrorKind;\n    let  _48: io::error::ErrorKind;\n    let mut _49: &io::error::ErrorKind;\n    let mut _50: core::result::Result<(), io::error::Error>;\n    debug path => _1;\n    debug residual => _6;\n    debug val => _7;\n    debug iter => _8;\n    debug child => _12;\n    debug result => _13;\n    debug child => _14;\n    debug residual => _17;\n    debug val => _18;\n    debug residual => _26;\n    debug val => _27;\n    debug residual => _35;\n    debug val => ();\n    debug residual => _42;\n    debug val => ();\n    debug err => _45;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = fs::read_dir::<&path::Path>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <core::result::Result<fs::ReadDir, io::error::Error> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _7 = move ((_3 as variant#0).0: fs::ReadDir);\n        _2 = <fs::ReadDir as core::iter::IntoIterator>::into_iter(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _6 = move ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb59;\n    }\n    bb7: {\n        StorageLive(_8);\n        _8 = move _2;\n        goto -> bb8;\n    }\n    bb8: {\n        StorageLive(_9);\n        _10 = &mut _8;\n        _9 = <fs::ReadDir as core::iter::Iterator>::next(_10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [0: bb11, 1: bb10, otherwise: bb3];\n    }\n    bb10: {\n        _12 = move ((_9 as variant#1).0: core::result::Result<fs::DirEntry, io::error::Error>);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = <core::result::Result<fs::DirEntry, io::error::Error> as core::ops::Try>::branch(_12) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_9);\n        drop(_8) -> [return: bb52, unwind unreachable];\n    }\n    bb12: {\n        _16 = discriminant(_15);\n        switchInt(move _16) -> [0: bb13, 1: bb14, otherwise: bb3];\n    }\n    bb13: {\n        StorageLive(_18);\n        _18 = move ((_15 as variant#0).0: fs::DirEntry);\n        _14 = move _18;\n        StorageDead(_18);\n        StorageDead(_15);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_14;\n        _23 = fs::DirEntry::file_type(move _24) -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        _17 = move ((_15 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _13 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_17) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_15);\n        goto -> bb43;\n    }\n    bb16: {\n        StorageDead(_24);\n        _22 = <core::result::Result<fs::FileType, io::error::Error> as core::ops::Try>::branch(move _23) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_23);\n        _25 = discriminant(_22);\n        switchInt(move _25) -> [0: bb18, 1: bb19, otherwise: bb3];\n    }\n    bb18: {\n        StorageLive(_27);\n        _27 = ((_22 as variant#0).0: fs::FileType);\n        _21 = _27;\n        StorageDead(_27);\n        _20 = &_21;\n        _19 = fs::FileType::is_dir(move _20) -> [return: bb21, unwind unreachable];\n    }\n    bb19: {\n        _26 = move ((_22 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _13 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_26) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb42;\n    }\n    bb21: {\n        switchInt(move _19) -> [0: bb58, otherwise: bb57];\n    }\n    bb22: {\n        StorageDead(_33);\n        _31 = &_32;\n        _30 = <path::PathBuf as core::ops::Deref>::deref(_31) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _29 = sys::fs::common::remove_dir_all_recursive(_30) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _28 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _29) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_29);\n        _34 = discriminant(_28);\n        switchInt(move _34) -> [0: bb26, 1: bb27, otherwise: bb3];\n    }\n    bb26: {\n        drop(_32) -> [return: bb29, unwind unreachable];\n    }\n    bb27: {\n        _35 = move ((_28 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _13 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_35) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        drop(_32) -> [return: bb41, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_32);\n        StorageDead(_28);\n        goto -> bb37;\n    }\n    bb30: {\n        StorageDead(_40);\n        _38 = &_39;\n        _37 = fs::remove_file::<&path::PathBuf>(move _38) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_38);\n        _36 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _37) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_37);\n        _41 = discriminant(_36);\n        switchInt(move _41) -> [0: bb33, 1: bb34, otherwise: bb3];\n    }\n    bb33: {\n        drop(_39) -> [return: bb36, unwind unreachable];\n    }\n    bb34: {\n        _42 = move ((_36 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _13 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_42) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        drop(_39) -> [return: bb40, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_39);\n        StorageDead(_36);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_19);\n        _13 = <core::result::Result<(), io::error::Error> as core::ops::Try>::from_output(()) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        drop(_14) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_14);\n        goto -> bb44;\n    }\n    bb40: {\n        StorageDead(_39);\n        StorageDead(_36);\n        goto -> bb42;\n    }\n    bb41: {\n        StorageDead(_32);\n        StorageDead(_28);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageDead(_19);\n        drop(_14) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_14);\n        goto -> bb44;\n    }\n    bb44: {\n        StorageLive(_43);\n        _43 = &_13;\n        _44 = discriminant((*_43));\n        switchInt(move _44) -> [1: bb45, 0: bb50, otherwise: bb3];\n    }\n    bb45: {\n        _45 = &(((*_43) as variant#1).0: io::error::Error);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = io::error::Error::kind(_45) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        _47 = &_48;\n        StorageLive(_49);\n        _49 = sys::fs::common::remove_dir_all_recursive::promoted[0];\n        _46 = <io::error::ErrorKind as core::cmp::PartialEq>::ne(move _47, move _49) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        switchInt(move _46) -> [0: bb49, otherwise: bb48];\n    }\n    bb48: {\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageDead(_47);\n        _0 = move _13;\n        StorageDead(_43);\n        StorageDead(_46);\n        StorageDead(_13);\n        StorageDead(_9);\n        drop(_8) -> [return: bb55, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_49);\n        StorageDead(_48);\n        StorageDead(_47);\n        goto -> bb50;\n    }\n    bb50: {\n        StorageDead(_43);\n        StorageDead(_46);\n        drop(_13) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_13);\n        StorageDead(_9);\n        goto -> bb8;\n    }\n    bb52: {\n        StorageDead(_8);\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_50);\n        _50 = fs::remove_dir::<&path::Path>(_1) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        _0 = sys_common::ignore_notfound::<()>(move _50) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_50);\n        goto -> bb56;\n    }\n    bb55: {\n        StorageDead(_8);\n        goto -> bb59;\n    }\n    bb56: {\n        return;\n    }\n    bb57: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_14;\n        _32 = fs::DirEntry::path(move _33) -> [return: bb22, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_14;\n        _39 = fs::DirEntry::path(move _40) -> [return: bb30, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb56;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}