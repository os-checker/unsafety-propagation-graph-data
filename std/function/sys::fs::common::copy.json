{
  "name": "sys::fs::common::copy",
  "safe": true,
  "callees": {
    "fs::File::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode.\n\n See the [`OpenOptions::open`] method for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Read;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut data = vec![];\n     f.read_to_end(&mut data)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fs::File::metadata": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Queries metadata about the underlying file.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let metadata = f.metadata()?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument",
        "fs::Metadata": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "fs::Metadata::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this metadata is for a regular file. The\n result is mutually exclusive to the result of\n [`Metadata::is_dir`], and will be false for symlink metadata\n obtained from [`symlink_metadata`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`File::open`] or\n [`OpenOptions::open`] for more information.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert!(metadata.is_file());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument"
      }
    },
    "fs::File::create": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Opens a file in write-only mode.\n\n This function will create a file if it does not exist,\n and will truncate it if it does.\n\n Depending on the platform, this function may fail if the\n full directory path does not exist.\n See the [`OpenOptions::open`] function for more details.\n\n See also [`std::fs::write()`][self::write] for a simple function to\n create a file with some given data.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Write;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::create(\"foo.txt\")?;\n     f.write_all(&1234_u32.to_be_bytes())?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "fs::Metadata::permissions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the permissions of the file this metadata is for.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert!(!metadata.permissions().readonly());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument",
        "fs::Permissions": "Constructor"
      }
    },
    "io::copy::copy": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies the entire contents of a reader into a writer.\n\n This function will continuously read data from `reader` and then\n write it into `writer` in a streaming fashion until `reader`\n returns EOF.\n\n On success, the total number of bytes that were copied from\n `reader` to `writer` is returned.\n\n If you want to copy the contents of one file to another and youâ€™re\n working with filesystem paths, see the [`fs::copy`] function.\n\n [`fs::copy`]: crate::fs::copy\n\n # Errors\n\n This function will return an error immediately if any call to [`read`] or\n [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n handled by this function and the underlying operation is retried.\n\n [`read`]: Read::read\n [`write`]: Write::write\n [`ErrorKind::Interrupted`]: crate::io::ErrorKind::Interrupted\n\n # Examples\n\n ```\n use std::io;\n\n fn main() -> io::Result<()> {\n     let mut reader: &[u8] = b\"hello\";\n     let mut writer: Vec<u8> = vec![];\n\n     io::copy(&mut reader, &mut writer)?;\n\n     assert_eq!(&b\"hello\"[..], &writer[..]);\n     Ok(())\n }\n ```\n\n # Platform-specific behavior\n\n On Linux (including Android), this function uses `copy_file_range(2)`,\n `sendfile(2)` or `splice(2)` syscalls to move data directly between file\n descriptors if possible.\n\n Note that platform-specific behavior [may change in the future][changes].\n\n [changes]: crate::io#platform-specific-behavior\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "fs::File::set_permissions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes the permissions on the underlying file.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `fchmod` function on Unix and\n the `SetFileInformationByHandle` function on Windows. Note that, this\n [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n # Errors\n\n This function will return an error if the user lacks permission change\n attributes on the underlying file. It may also return an error in other\n os-specific unspecified cases.\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs::File;\n\n     let file = File::open(\"foo.txt\")?;\n     let mut perms = file.metadata()?.permissions();\n     perms.set_readonly(true);\n     file.set_permissions(perms)?;\n     Ok(())\n }\n ```\n\n Note that this method alters the permissions of the underlying file,\n even though it takes `&self` rather than `&mut self`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3692, kind: RigidTy(Adt(AdtDef(DefId { id: 6032, name: \"fs::Metadata\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])"
    ],
    "fs::File": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "fs::Metadata": [
      "Plain",
      "Ref"
    ],
    "fs::Permissions": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::fs::common::copy"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/common.rs:13:1: 27:2",
  "src": "pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n    let mut reader = fs::File::open(from)?;\n    let metadata = reader.metadata()?;\n\n    if !metadata.is_file() {\n        return Err(NOT_FILE_ERROR);\n    }\n\n    let mut writer = fs::File::create(to)?;\n    let perm = metadata.permissions();\n\n    let ret = io::copy(&mut reader, &mut writer)?;\n    writer.set_permissions(perm)?;\n    Ok(ret)\n}",
  "mir": "fn sys::fs::common::copy(_1: &path::Path, _2: &path::Path) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let mut _3: fs::File;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _5: core::result::Result<fs::File, io::error::Error>;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _8: fs::File;\n    let  _9: fs::Metadata;\n    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::Metadata>;\n    let mut _11: core::result::Result<fs::Metadata, io::error::Error>;\n    let mut _12: &fs::File;\n    let mut _13: isize;\n    let  _14: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _15: fs::Metadata;\n    let mut _16: bool;\n    let mut _17: &fs::Metadata;\n    let mut _18: fs::File;\n    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _20: core::result::Result<fs::File, io::error::Error>;\n    let mut _21: isize;\n    let  _22: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _23: fs::File;\n    let  _24: fs::Permissions;\n    let mut _25: &fs::Metadata;\n    let mut _26: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _27: core::result::Result<u64, io::error::Error>;\n    let mut _28: &mut fs::File;\n    let mut _29: &mut fs::File;\n    let mut _30: isize;\n    let  _31: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _32: u64;\n    let mut _33: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _34: core::result::Result<(), io::error::Error>;\n    let mut _35: &fs::File;\n    let mut _36: isize;\n    let  _37: core::result::Result<core::convert::Infallible, io::error::Error>;\n    debug from => _1;\n    debug to => _2;\n    debug reader => _3;\n    debug residual => _7;\n    debug val => _8;\n    debug metadata => _9;\n    debug residual => _14;\n    debug val => _15;\n    debug writer => _18;\n    debug residual => _22;\n    debug val => _23;\n    debug perm => _24;\n    debug ret => _32;\n    debug residual => _31;\n    debug val => _32;\n    debug residual => _37;\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = fs::File::open::<&path::Path>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = move ((_4 as variant#0).0: fs::File);\n        _3 = move _8;\n        StorageDead(_8);\n        StorageDead(_4);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_3;\n        _11 = fs::File::metadata(move _12) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _7 = move ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_4);\n        goto -> bb36;\n    }\n    bb7: {\n        StorageDead(_12);\n        _10 = <core::result::Result<fs::Metadata, io::error::Error> as core::ops::Try>::branch(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        _13 = discriminant(_10);\n        switchInt(move _13) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        StorageLive(_15);\n        _15 = move ((_10 as variant#0).0: fs::Metadata);\n        _9 = move _15;\n        StorageDead(_15);\n        StorageDead(_10);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &_9;\n        _16 = fs::Metadata::is_file(move _17) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _14 = move ((_10 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_10);\n        goto -> bb35;\n    }\n    bb12: {\n        switchInt(move _16) -> [0: bb14, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = fs::File::create::<&path::Path>(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        _0 = core::result::Result::Err(sys::fs::common::NOT_FILE_ERROR);\n        StorageDead(_16);\n        goto -> bb35;\n    }\n    bb15: {\n        _19 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_20);\n        _21 = discriminant(_19);\n        switchInt(move _21) -> [0: bb17, 1: bb18, otherwise: bb3];\n    }\n    bb17: {\n        StorageLive(_23);\n        _23 = move ((_19 as variant#0).0: fs::File);\n        _18 = move _23;\n        StorageDead(_23);\n        StorageDead(_19);\n        StorageLive(_25);\n        _25 = &_9;\n        _24 = fs::Metadata::permissions(move _25) -> [return: bb20, unwind unreachable];\n    }\n    bb18: {\n        _22 = move ((_19 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_22) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_19);\n        goto -> bb34;\n    }\n    bb20: {\n        StorageDead(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _28 = &mut _3;\n        _29 = &mut _18;\n        _27 = io::copy::copy::<fs::File, fs::File>(_28, _29) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _26 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _27) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        _30 = discriminant(_26);\n        switchInt(move _30) -> [0: bb23, 1: bb24, otherwise: bb3];\n    }\n    bb23: {\n        _32 = ((_26 as variant#0).0: u64);\n        StorageDead(_26);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_18;\n        _34 = fs::File::set_permissions(move _35, _24) -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _31 = move ((_26 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_31) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_26);\n        goto -> bb33;\n    }\n    bb26: {\n        StorageDead(_35);\n        _33 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _34) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_34);\n        _36 = discriminant(_33);\n        switchInt(move _36) -> [0: bb28, 1: bb29, otherwise: bb3];\n    }\n    bb28: {\n        StorageDead(_33);\n        _0 = core::result::Result::Ok(_32);\n        drop(_18) -> [return: bb31, unwind unreachable];\n    }\n    bb29: {\n        _37 = move ((_33 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_37) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_33);\n        goto -> bb33;\n    }\n    bb31: {\n        StorageDead(_18);\n        StorageDead(_9);\n        drop(_3) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb33: {\n        drop(_18) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_18);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_9);\n        drop(_3) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_3);\n        goto -> bb37;\n    }\n    bb37: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}