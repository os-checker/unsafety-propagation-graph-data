{
  "name": "fs::File::create_buffered",
  "safe": true,
  "callees": {
    "io::buffered::bufwriter::BufWriter::<W>::try_new_buffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "alloc_crate::vec::Vec": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fs::File::create": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Opens a file in write-only mode.\n\n This function will create a file if it does not exist,\n and will truncate it if it does.\n\n Depending on the platform, this function may fail if the\n full directory path does not exist.\n See the [`OpenOptions::open`] function for more details.\n\n See also [`std::fs::write()`][self::write] for a simple function to\n create a file with some given data.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Write;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::create(\"foo.txt\")?;\n     f.write_all(&1234_u32.to_be_bytes())?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::with_buffer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "Constructor"
      }
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])"
    ],
    "alloc_crate::vec::Vec": [
      "Plain"
    ],
    "fs::File": [
      "Plain"
    ],
    "io::buffered::bufwriter::BufWriter": [
      "Plain"
    ]
  },
  "path": 1128,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:637:5: 642:6",
  "src": "pub fn create_buffered<P: AsRef<Path>>(path: P) -> io::Result<io::BufWriter<File>> {\n        // Allocate the buffer *first* so we don't affect the filesystem otherwise.\n        let buffer = io::BufWriter::<Self>::try_new_buffer()?;\n        let file = File::create(path)?;\n        Ok(io::BufWriter::with_buffer(file, buffer))\n    }",
  "mir": "fn fs::File::create_buffered(_1: P) -> core::result::Result<io::buffered::bufwriter::BufWriter<fs::File>, io::error::Error> {\n    let mut _0: core::result::Result<io::buffered::bufwriter::BufWriter<fs::File>, io::error::Error>;\n    let  _2: alloc_crate::vec::Vec<u8>;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, alloc_crate::vec::Vec<u8>>;\n    let mut _4: core::result::Result<alloc_crate::vec::Vec<u8>, io::error::Error>;\n    let mut _5: isize;\n    let  _6: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _7: alloc_crate::vec::Vec<u8>;\n    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _9: core::result::Result<fs::File, io::error::Error>;\n    let mut _10: P;\n    let mut _11: isize;\n    let  _12: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _13: fs::File;\n    let mut _14: io::buffered::bufwriter::BufWriter<fs::File>;\n    let mut _15: alloc_crate::vec::Vec<u8>;\n    let mut _16: bool;\n    debug path => _1;\n    debug buffer => _2;\n    debug residual => _6;\n    debug val => _7;\n    debug file => _13;\n    debug residual => _12;\n    debug val => _13;\n    bb0: {\n        _16 = false;\n        _16 = true;\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = io::buffered::bufwriter::BufWriter::<fs::File>::try_new_buffer() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <core::result::Result<alloc_crate::vec::Vec<u8>, io::error::Error> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = move ((_3 as variant#0).0: alloc_crate::vec::Vec<u8>);\n        _2 = move _7;\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _16 = false;\n        _10 = move _1;\n        _9 = fs::File::create::<P>(move _10) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _6 = move ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<io::buffered::bufwriter::BufWriter<fs::File>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        goto -> bb13;\n    }\n    bb7: {\n        StorageDead(_10);\n        _8 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _9) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        _11 = discriminant(_8);\n        switchInt(move _11) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        _13 = move ((_8 as variant#0).0: fs::File);\n        StorageDead(_8);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = move _2;\n        _14 = io::buffered::bufwriter::BufWriter::<fs::File>::with_buffer(_13, move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _12 = move ((_8 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<io::buffered::bufwriter::BufWriter<fs::File>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_12) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_8);\n        drop(_2) -> [return: bb13, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        _0 = core::result::Result::Ok(move _14);\n        StorageDead(_14);\n        StorageDead(_2);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_2);\n        switchInt(_16) -> [0: bb14, otherwise: bb15];\n    }\n    bb14: {\n        return;\n    }\n    bb15: {\n        drop(_1) -> [return: bb14, unwind unreachable];\n    }\n}\n",
  "doc": " Opens a file in write-only mode with buffering.\n\n This function will create a file if it does not exist,\n and will truncate it if it does.\n\n Depending on the platform, this function may fail if the\n full directory path does not exist.\n\n See the [`OpenOptions::open`] method and the\n [`BufWriter`][io::BufWriter] type for more details.\n\n See also [`std::fs::write()`][self::write] for a simple function to\n create a file with some given data.\n\n # Examples\n\n ```no_run\n #![feature(file_buffered)]\n use std::fs::File;\n use std::io::Write;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::create_buffered(\"foo.txt\")?;\n     assert!(f.capacity() > 0);\n     for i in 0..100 {\n         writeln!(&mut f, \"{i}\")?;\n     }\n     f.flush()?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}