{
  "name": "os::unix::net::stream::UnixStream::try_clone",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::unix::Socket::duplicate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::unix::Socket": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "os::unix::net::stream::UnixStream": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A Unix stream socket.\n\n # Examples\n\n ```no_run\n use std::os::unix::net::UnixStream;\n use std::io::prelude::*;\n\n fn main() -> std::io::Result<()> {\n     let mut stream = UnixStream::connect(\"/path/to/my/socket\")?;\n     stream.write_all(b\"hello world\")?;\n     let mut response = String::new();\n     stream.read_to_string(&mut response)?;\n     println!(\"{response}\");\n     Ok(())\n }\n ```\n\n # `SIGPIPE`\n\n Writes to the underlying socket in `SOCK_STREAM` mode are made with `MSG_NOSIGNAL` flag.\n This suppresses the emission of the  `SIGPIPE` signal when writing to disconnected socket.\n In some cases getting a `SIGPIPE` would trigger process termination.\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ],
    "os::unix::net::stream::UnixStream": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2247,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/stream.rs:194:5: 196:6",
  "src": "pub fn try_clone(&self) -> io::Result<UnixStream> {\n        self.0.duplicate().map(UnixStream)\n    }",
  "mir": "fn os::unix::net::stream::UnixStream::try_clone(_1: &os::unix::net::stream::UnixStream) -> core::result::Result<os::unix::net::stream::UnixStream, io::error::Error> {\n    let mut _0: core::result::Result<os::unix::net::stream::UnixStream, io::error::Error>;\n    let mut _2: core::result::Result<sys::net::connection::socket::unix::Socket, io::error::Error>;\n    let mut _3: &sys::net::connection::socket::unix::Socket;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::net::connection::socket::unix::Socket);\n        _2 = sys::net::connection::socket::unix::Socket::duplicate(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        _0 = core::result::Result::<sys::net::connection::socket::unix::Socket, io::error::Error>::map::<os::unix::net::stream::UnixStream, fn(sys::net::connection::socket::unix::Socket) -> os::unix::net::stream::UnixStream {os::unix::net::stream::UnixStream}>(move _2, os::unix::net::stream::UnixStream) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates a new independently owned handle to the underlying socket.\n\n The returned `UnixStream` is a reference to the same stream that this\n object references. Both handles will read and write the same stream of\n data, and options set on one stream will be propagated to the other\n stream.\n\n # Examples\n\n ```no_run\n use std::os::unix::net::UnixStream;\n\n fn main() -> std::io::Result<()> {\n     let socket = UnixStream::connect(\"/tmp/sock\")?;\n     let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}