{
  "name": "io::stdio::_print",
  "safe": true,
  "callees": {
    "io::stdio::stdout": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new handle to the standard output of the current process.\n\n Each handle returned is a reference to a shared global buffer whose access\n is synchronized via a mutex. If you need more explicit control over\n locking, see the [`Stdout::lock`] method.\n\n By default, the handle is line-buffered when connected to a terminal, meaning\n it flushes automatically when a newline (`\\n`) is encountered. For immediate\n output, you can manually call the [`flush`] method. When the handle goes out\n of scope, the buffer is automatically flushed.\n\n ### Note: Windows Portability Considerations\n\n When operating in a console, the Windows implementation of this stream does not support\n non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n an error.\n\n In a process with a detached console, such as one using\n `#![windows_subsystem = \"windows\"]`, or in a child process spawned from such a process,\n the contained handle will be null. In such cases, the standard library's `Read` and\n `Write` will do nothing and silently succeed. All other I/O operations, via the\n standard library or via raw Windows API calls, will fail.\n\n # Examples\n\n Using implicit synchronization:\n\n ```no_run\n use std::io::{self, Write};\n\n fn main() -> io::Result<()> {\n     io::stdout().write_all(b\"hello world\")?;\n\n     Ok(())\n }\n ```\n\n Using explicit synchronization:\n\n ```no_run\n use std::io::{self, Write};\n\n fn main() -> io::Result<()> {\n     let stdout = io::stdout();\n     let mut handle = stdout.lock();\n\n     handle.write_all(b\"hello world\")?;\n\n     Ok(())\n }\n ```\n\n Ensuring output is flushed immediately:\n\n ```no_run\n use std::io::{self, Write};\n\n fn main() -> io::Result<()> {\n     let mut stdout = io::stdout();\n     stdout.write_all(b\"hello, \")?;\n     stdout.flush()?;                // Manual flush\n     stdout.write_all(b\"world!\\n\")?; // Automatically flushed\n     Ok(())\n }\n ```\n\n [`flush`]: Write::flush\n",
      "adt": {}
    },
    "io::stdio::print_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes `args` to the capture buffer if enabled and possible, or `global_s`\n otherwise. `label` identifies the stream in a panic message.\n\n This function is used to print error messages, so it takes extra\n care to avoid causing a panic when `OUTPUT_CAPTURE` is unusable.\n For instance, if the TLS key for output capturing is already destroyed, or\n if the local stream is in use by another thread, it will just fall back to\n the global stream.\n\n However, if the actual I/O causes an error, this function does panic.\n\n Writing to non-blocking stdout/stderr can cause an error, which will lead\n this function to panic.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::stdio::_print"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:1274:1: 1276:2",
  "src": "pub fn _print(args: fmt::Arguments<'_>) {\n    print_to(args, stdout, \"stdout\");\n}",
  "mir": "fn io::stdio::_print(_1: core::fmt::Arguments<'_>) -> () {\n    let mut _0: ();\n    let  _2: ();\n    let mut _3: fn() -> io::stdio::Stdout;\n    let mut _4: &str;\n    debug args => _1;\n    bb0: {\n        StorageLive(_3);\n        _3 = io::stdio::stdout as fn() -> io::stdio::Stdout;\n        StorageLive(_4);\n        _4 = \"stdout\";\n        _2 = io::stdio::print_to::<io::stdio::Stdout>(_1, move _3, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "hidden"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* hidden\n"
    ]
  }
}