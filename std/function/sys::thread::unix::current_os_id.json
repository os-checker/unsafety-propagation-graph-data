{
  "name": "sys::thread::unix::current_os_id",
  "safe": true,
  "callees": {
    "sys::thread::unix::current_os_id::gettid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 4347,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:323:1: 382:2",
  "src": "pub fn current_os_id() -> Option<u64> {\n    // Most Unix platforms have a way to query an integer ID of the current thread, all with\n    // slightly different spellings.\n    //\n    // The OS thread ID is used rather than `pthread_self` so as to match what will be displayed\n    // for process inspection (debuggers, trace, `top`, etc.).\n    cfg_select! {\n        // Most platforms have a function returning a `pid_t` or int, which is an `i32`.\n        any(target_os = \"android\", target_os = \"linux\") => {\n            use crate::sys::pal::weak::syscall;\n\n            // `libc::gettid` is only available on glibc 2.30+, but the syscall is available\n            // since Linux 2.4.11.\n            syscall!(fn gettid() -> libc::pid_t;);\n\n            // SAFETY: FFI call with no preconditions.\n            let id: libc::pid_t = unsafe { gettid() };\n            Some(id as u64)\n        }\n        target_os = \"nto\" => {\n            // SAFETY: FFI call with no preconditions.\n            let id: libc::pid_t = unsafe { libc::gettid() };\n            Some(id as u64)\n        }\n        target_os = \"openbsd\" => {\n            // SAFETY: FFI call with no preconditions.\n            let id: libc::pid_t = unsafe { libc::getthrid() };\n            Some(id as u64)\n        }\n        target_os = \"freebsd\" => {\n            // SAFETY: FFI call with no preconditions.\n            let id: libc::c_int = unsafe { libc::pthread_getthreadid_np() };\n            Some(id as u64)\n        }\n        target_os = \"netbsd\" => {\n            // SAFETY: FFI call with no preconditions.\n            let id: libc::lwpid_t = unsafe { libc::_lwp_self() };\n            Some(id as u64)\n        }\n        any(target_os = \"illumos\", target_os = \"solaris\") => {\n            // On Illumos and Solaris, the `pthread_t` is the same as the OS thread ID.\n            // SAFETY: FFI call with no preconditions.\n            let id: libc::pthread_t = unsafe { libc::pthread_self() };\n            Some(id as u64)\n        }\n        target_vendor = \"apple\" => {\n            // Apple allows querying arbitrary thread IDs, `thread=NULL` queries the current thread.\n            let mut id = 0u64;\n            // SAFETY: `thread_id` is a valid pointer, no other preconditions.\n            let status: libc::c_int = unsafe { libc::pthread_threadid_np(0, &mut id) };\n            if status == 0 {\n                Some(id)\n            } else {\n                None\n            }\n        }\n        // Other platforms don't have an OS thread ID or don't have a way to access it.\n        _ => None,\n    }\n}",
  "mir": "fn sys::thread::unix::current_os_id() -> core::option::Option<u64> {\n    let mut _0: core::option::Option<u64>;\n    let  _1: i32;\n    let mut _2: u64;\n    debug id => _1;\n    bb0: {\n        _1 = sys::thread::unix::current_os_id::gettid() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_2);\n        _2 = _1 as u64;\n        _0 = core::option::Option::Some(move _2);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}