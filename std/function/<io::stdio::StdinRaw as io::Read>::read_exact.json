{
  "name": "<io::stdio::StdinRaw as io::Read>::read_exact",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "io::Read::read_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads the exact number of bytes required to fill `buf`.\n\n This function reads as many bytes as necessary to completely fill the\n specified buffer `buf`.\n\n *Implementations* of this method can make no assumptions about the contents of `buf` when\n this function is called. It is recommended that implementations only write data to `buf`\n instead of reading its contents. The documentation on [`read`] has a more detailed\n explanation of this subject.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If this function encounters an \"end of file\" before completely filling\n the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n The contents of `buf` are unspecified in this case.\n\n If any other read error is encountered then this function immediately\n returns. The contents of `buf` are unspecified in this case.\n\n If this function returns an error, it is unspecified how many bytes it\n has read, but it will never read more than would be necessary to\n completely fill the buffer.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read`]: Read::read\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = [0; 10];\n\n     // read exactly 10 bytes\n     f.read_exact(&mut buffer)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "io::stdio::handle_ebadf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "sys::stdio::unix::Stdin": [
      "MutRef"
    ],
    "io::stdio::StdinRaw": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::stdio::StdinRaw as io::Read>::read_exact"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:116:5: 121:6",
  "src": "fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n        if buf.is_empty() {\n            return Ok(());\n        }\n        handle_ebadf(self.0.read_exact(buf), || Err(io::Error::READ_EXACT_EOF))\n    }",
  "mir": "fn <io::stdio::StdinRaw as io::Read>::read_exact(_1: &mut io::stdio::StdinRaw, _2: &mut [u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: bool;\n    let mut _4: &[u8];\n    let mut _5: core::result::Result<(), io::error::Error>;\n    let mut _6: &mut sys::stdio::unix::Stdin;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &(*_2);\n        _3 = core::slice::<impl [u8]>::is_empty(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        _0 = core::result::Result::Ok(());\n        StorageDead(_3);\n        goto -> bb6;\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &mut ((*_1).0: sys::stdio::unix::Stdin);\n        _5 = <sys::stdio::unix::Stdin as io::Read>::read_exact(move _6, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        _0 = io::stdio::handle_ebadf::<(), {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:120:46: 120:48}>(move _5, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:120:46: 120:48}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        goto -> bb6;\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}