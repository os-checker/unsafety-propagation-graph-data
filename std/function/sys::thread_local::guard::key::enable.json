{
  "name": "sys::thread_local::guard::key::enable",
  "safe": true,
  "callees": {
    "sys::thread_local::key::racy::LazyKey::force": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::thread_local::key::racy::LazyKey": "ImmutableAsArgument"
      }
    },
    "core::ptr::without_provenance_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a pointer with the given address and no [provenance][crate::ptr#provenance].\n\n This is equivalent to `ptr::null_mut().with_addr(addr)`.\n\n Without provenance, this pointer is not associated with any actual allocation. Such a\n no-provenance pointer may be used for zero-sized memory accesses (if suitably aligned), but\n non-zero-sized memory accesses with a no-provenance pointer are UB. No-provenance pointers are\n little more than a `usize` address in disguise.\n\n This is different from `addr as *mut T`, which creates a pointer that picks up a previously\n exposed provenance. See [`with_exposed_provenance_mut`] for more details on that operation.\n\n This is a [Strict Provenance][crate::ptr#strict-provenance] API.\n",
      "adt": {}
    },
    "sys::thread_local::key::unix::set": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "sys::thread_local::key::racy::LazyKey": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::thread_local::guard::key::enable"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/guard/key.rs:9:1: 31:2",
  "src": "pub fn enable() {\n    use crate::sys::thread_local::destructors;\n\n    static DTORS: LazyKey = LazyKey::new(Some(run));\n\n    // Setting the key value to something other than NULL will result in the\n    // destructor being run at thread exit.\n    unsafe {\n        set(DTORS.force(), ptr::without_provenance_mut(1));\n    }\n\n    unsafe extern \"C\" fn run(_: *mut u8) {\n        unsafe {\n            destructors::run();\n            // On platforms with `__cxa_thread_atexit_impl`, `destructors::run`\n            // does nothing on newer systems as the TLS destructors are\n            // registered with the system. But because all of those platforms\n            // call the destructors of TLS keys after the registered ones, this\n            // function will still be run last (at the time of writing).\n            crate::rt::thread_cleanup();\n        }\n    }\n}",
  "mir": "fn sys::thread_local::guard::key::enable() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let mut _2: u32;\n    let mut _3: &sys::thread_local::key::racy::LazyKey;\n    let mut _4: *mut u8;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = {alloc613: &sys::thread_local::key::racy::LazyKey};\n        _2 = sys::thread_local::key::racy::LazyKey::force(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = core::ptr::without_provenance_mut::<u8>(1_usize) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _1 = sys::thread_local::key::unix::set(move _2, move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}