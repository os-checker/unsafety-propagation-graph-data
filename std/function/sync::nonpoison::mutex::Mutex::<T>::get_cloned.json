{
  "name": "sync::nonpoison::mutex::Mutex::<T>::get_cloned",
  "safe": true,
  "callees": {
    "sync::nonpoison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n\n use std::sync::{Arc, nonpoison::Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock(), 10);\n ```\n",
      "adt": {
        "sync::nonpoison::mutex::Mutex": "ImmutableAsArgument",
        "sync::nonpoison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::nonpoison::mutex::Mutex": [
      "Ref"
    ],
    "sync::nonpoison::mutex::MutexGuard": [
      "Plain",
      "Ref"
    ]
  },
  "path": 3075,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/nonpoison/mutex.rs:192:5: 197:6",
  "src": "pub fn get_cloned(&self) -> T\n    where\n        T: Clone,\n    {\n        self.lock().clone()\n    }",
  "mir": "fn sync::nonpoison::mutex::Mutex::<T>::get_cloned(_1: &sync::nonpoison::mutex::Mutex<T>) -> T {\n    let mut _0: T;\n    let  _2: &T;\n    let mut _3: &sync::nonpoison::mutex::MutexGuard<'_, T>;\n    let  _4: sync::nonpoison::mutex::MutexGuard<'_, T>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = sync::nonpoison::mutex::Mutex::<T>::lock(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = &_4;\n        _2 = <sync::nonpoison::mutex::MutexGuard<'_, T> as core::ops::Deref>::deref(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = <T as core::clone::Clone>::clone(_2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        drop(_4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": " Returns the contained value by cloning it.\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n #![feature(lock_value_accessors)]\n\n use std::sync::nonpoison::Mutex;\n\n let mut mutex = Mutex::new(7);\n\n assert_eq!(mutex.get_cloned(), 7);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}