{
  "name": "net::udp::UdpSocket::peek",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::UdpSocket::peek": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::UdpSocket": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::net::connection::socket::UdpSocket": [
      "Ref"
    ],
    "net::udp::UdpSocket": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::net::udp::UdpSocket::peek"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/net/udp.rs:769:5: 771:6",
  "src": "pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.peek(buf)\n    }",
  "mir": "fn net::udp::UdpSocket::peek(_1: &net::udp::UdpSocket, _2: &mut [u8]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: &sys::net::connection::socket::UdpSocket;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::net::connection::socket::UdpSocket);\n        _0 = sys::net::connection::socket::UdpSocket::peek(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Receives single datagram on the socket from the remote address to which it is\n connected, without removing the message from input queue. On success, returns\n the number of bytes peeked.\n\n The function must be called with valid byte array `buf` of sufficient size to\n hold the message bytes. If a message is too long to fit in the supplied buffer,\n excess bytes may be discarded.\n\n Successive calls return the same data. This is accomplished by passing\n `MSG_PEEK` as a flag to the underlying `recv` system call.\n\n Do not use this function to implement busy waiting, instead use `libc::poll` to\n synchronize IO events on one or more sockets.\n\n [`UdpSocket::connect`] will connect this socket to a remote address. This\n method will fail if the socket is not connected.\n\n # Errors\n\n This method will fail if the socket is not connected. The `connect` method\n will connect this socket to a remote address.\n\n # Examples\n\n ```no_run\n use std::net::UdpSocket;\n\n let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n let mut buf = [0; 10];\n match socket.peek(&mut buf) {\n     Ok(received) => println!(\"received {received} bytes\"),\n     Err(e) => println!(\"peek function failed: {e:?}\"),\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}