{
  "name": "sys::pal::unix::os::getcwd",
  "safe": true,
  "callees": {
    "alloc_crate::vec::Vec::<T>::with_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>` with at least the specified capacity.\n\n The vector will be able to hold at least `capacity` elements without\n reallocating. This method is allowed to allocate for more elements than\n `capacity`. If `capacity` is zero, the vector will not allocate.\n\n It is important to note that although the returned vector has the\n minimum *capacity* specified, the vector will have a zero *length*. For\n an explanation of the difference between length and capacity, see\n *[Capacity and reallocation]*.\n\n If it is important to know the exact allocated capacity of a `Vec`,\n always use the [`capacity`] method after construction.\n\n For `Vec<T>` where `T` is a zero-sized type, there will be no allocation\n and the capacity will always be `usize::MAX`.\n\n [Capacity and reallocation]: #capacity-and-reallocation\n [`capacity`]: Vec::capacity\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n\n // The vector contains no items, even though it has capacity for more\n assert_eq!(vec.len(), 0);\n assert!(vec.capacity() >= 10);\n\n // These are all done without reallocating...\n for i in 0..10 {\n     vec.push(i);\n }\n assert_eq!(vec.len(), 10);\n assert!(vec.capacity() >= 10);\n\n // ...but this may make the vector reallocate\n vec.push(11);\n assert_eq!(vec.len(), 11);\n assert!(vec.capacity() >= 11);\n\n // A vector of a zero-sized type will always over-allocate, since no\n // allocation is necessary\n let vec_units = Vec::<()>::with_capacity(10);\n assert_eq!(vec_units.capacity(), usize::MAX);\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw mutable pointer to the vector's buffer, or a dangling\n raw pointer valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize references to the slice,\n or references to specific elements you are planning on accessing through this pointer,\n may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n The method also guarantees that, as long as `T` is not zero-sized and the capacity is\n nonzero, the pointer may be passed into [`dealloc`] with a layout of\n `Layout::array::<T>(capacity)` in order to deallocate the backing memory. If this is done,\n be careful not to run the destructor of the `Vec`, as dropping it will result in\n double-frees. Wrapping the `Vec` in a [`ManuallyDrop`] is the typical way to achieve this.\n\n # Examples\n\n ```\n // Allocate vector big enough for 4 elements.\n let size = 4;\n let mut x: Vec<i32> = Vec::with_capacity(size);\n let x_ptr = x.as_mut_ptr();\n\n // Initialize elements via raw pointer writes, then set length.\n unsafe {\n     for i in 0..size {\n         *x_ptr.add(i) = i as i32;\n     }\n     x.set_len(size);\n }\n assert_eq!(&*x, &[0, 1, 2, 3]);\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0];\n     let ptr1 = v.as_mut_ptr();\n     ptr1.write(1);\n     let ptr2 = v.as_mut_ptr();\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`:\n     ptr1.write(3);\n }\n ```\n\n Deallocating a vector using [`Box`] (which uses [`dealloc`] internally):\n\n ```\n use std::mem::{ManuallyDrop, MaybeUninit};\n\n let mut v = ManuallyDrop::new(vec![0, 1, 2]);\n let ptr = v.as_mut_ptr();\n let capacity = v.capacity();\n let slice_ptr: *mut [MaybeUninit<i32>] =\n     std::ptr::slice_from_raw_parts_mut(ptr.cast(), capacity);\n drop(unsafe { Box::from_raw(slice_ptr) });\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n [`dealloc`]: crate::alloc::GlobalAlloc::dealloc\n [`ManuallyDrop`]: core::mem::ManuallyDrop\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {}
    },
    "libc::getcwd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the vector's buffer, or a dangling raw pointer\n valid for zero sized reads if the vector didn't allocate.\n\n The caller must ensure that the vector outlives the pointer this\n function returns, or else it will end up dangling.\n Modifying the vector may cause its buffer to be reallocated,\n which would also make any pointers to it invalid.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n This method guarantees that for the purpose of the aliasing model, this method\n does not materialize a reference to the underlying slice, and thus the returned pointer\n will remain valid when mixed with other calls to [`as_ptr`], [`as_mut_ptr`],\n and [`as_non_null`].\n Note that calling other methods that materialize mutable references to the slice,\n or mutable references to specific elements you are planning on accessing through this pointer,\n as well as writing to those elements, may still invalidate this pointer.\n See the second example below for how this guarantee can be used.\n\n\n # Examples\n\n ```\n let x = vec![1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(*x_ptr.add(i), 1 << i);\n     }\n }\n ```\n\n Due to the aliasing guarantee, the following code is legal:\n\n ```rust\n unsafe {\n     let mut v = vec![0, 1, 2];\n     let ptr1 = v.as_ptr();\n     let _ = ptr1.read();\n     let ptr2 = v.as_mut_ptr().offset(2);\n     ptr2.write(2);\n     // Notably, the write to `ptr2` did *not* invalidate `ptr1`\n     // because it mutated a different element:\n     let _ = ptr1.read();\n }\n ```\n\n [`as_mut_ptr`]: Vec::as_mut_ptr\n [`as_ptr`]: Vec::as_ptr\n [`as_non_null`]: Vec::as_non_null\n",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    },
    "core::ffi::CStr::to_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice.\n\n The returned slice will **not** contain the trailing nul terminator that this C\n string has.\n\n > **Note**: This method is currently implemented as a constant-time\n > cast, but it is planned to alter its definition in the future to\n > perform the length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes(), b\"foo\");\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::set_len": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Forces the length of the vector to `new_len`.\n\n This is a low-level operation that maintains none of the normal\n invariants of the type. Normally changing the length of a vector\n is done using one of the safe operations instead, such as\n [`truncate`], [`resize`], [`extend`], or [`clear`].\n\n [`truncate`]: Vec::truncate\n [`resize`]: Vec::resize\n [`extend`]: Extend::extend\n [`clear`]: Vec::clear\n\n # Safety\n\n - `new_len` must be less than or equal to [`capacity()`].\n - The elements at `old_len..new_len` must be initialized.\n\n [`capacity()`]: Vec::capacity\n\n # Examples\n\n See [`spare_capacity_mut()`] for an example with safe\n initialization of capacity elements and use of this method.\n\n `set_len()` can be useful for situations in which the vector\n is serving as a buffer for other code, particularly over FFI:\n\n ```no_run\n # #![allow(dead_code)]\n # // This is just a minimal skeleton for the doc example;\n # // don't use this as a starting point for a real library.\n # pub struct StreamWrapper { strm: *mut std::ffi::c_void }\n # const Z_OK: i32 = 0;\n # unsafe extern \"C\" {\n #     fn deflateGetDictionary(\n #         strm: *mut std::ffi::c_void,\n #         dictionary: *mut u8,\n #         dictLength: *mut usize,\n #     ) -> i32;\n # }\n # impl StreamWrapper {\n pub fn get_dictionary(&self) -> Option<Vec<u8>> {\n     // Per the FFI method's docs, \"32768 bytes is always enough\".\n     let mut dict = Vec::with_capacity(32_768);\n     let mut dict_length = 0;\n     // SAFETY: When `deflateGetDictionary` returns `Z_OK`, it holds that:\n     // 1. `dict_length` elements were initialized.\n     // 2. `dict_length` <= the capacity (32_768)\n     // which makes `set_len` safe to call.\n     unsafe {\n         // Make the FFI call...\n         let r = deflateGetDictionary(self.strm, dict.as_mut_ptr(), &mut dict_length);\n         if r == Z_OK {\n             // ...and update the length to what was initialized.\n             dict.set_len(dict_length);\n             Some(dict)\n         } else {\n             None\n         }\n     }\n }\n # }\n ```\n\n While the following example is sound, there is a memory leak since\n the inner vectors were not freed prior to the `set_len` call:\n\n ```\n let mut vec = vec![vec![1, 0, 0],\n                    vec![0, 1, 0],\n                    vec![0, 0, 1]];\n // SAFETY:\n // 1. `old_len..0` is empty so no elements need to be initialized.\n // 2. `0 <= capacity` always holds whatever `capacity` is.\n unsafe {\n     vec.set_len(0);\n #   // FIXME(https://github.com/rust-lang/miri/issues/3670):\n #   // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n #   vec.set_len(3);\n }\n ```\n\n Normally, here, one would use [`clear`] instead to correctly drop\n the contents and thus not leak memory.\n\n [`spare_capacity_mut()`]: Vec::spare_capacity_mut\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::shrink_to_fit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Shrinks the capacity of the vector as much as possible.\n\n The behavior of this method depends on the allocator, which may either shrink the vector\n in-place or reallocate. The resulting vector might still have some excess capacity, just as\n is the case for [`with_capacity`]. See [`Allocator::shrink`] for more details.\n\n [`with_capacity`]: Vec::with_capacity\n\n # Examples\n\n ```\n let mut vec = Vec::with_capacity(10);\n vec.extend([1, 2, 3]);\n assert!(vec.capacity() >= 10);\n vec.shrink_to_fit();\n assert!(vec.capacity() >= 3);\n ```\n",
      "adt": {}
    },
    "os::unix::ffi::os_str::OsStringExt::from_vec": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an [`OsString`] from a byte vector.\n\n See the module documentation for an example.\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "io::error::Error::raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS error that this error represents (if any).\n\n If this [`Error`] was constructed via [`last_os_error`] or\n [`from_raw_os_error`], then this function will return [`Some`], otherwise\n it will return [`None`].\n\n [`last_os_error`]: Error::last_os_error\n [`from_raw_os_error`]: Error::from_raw_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_os_error(err: &Error) {\n     if let Some(raw_os_err) = err.raw_os_error() {\n         println!(\"raw OS error: {raw_os_err:?}\");\n     } else {\n         println!(\"Not an OS error\");\n     }\n }\n\n fn main() {\n     // Will print \"raw OS error: ...\".\n     print_os_error(&Error::last_os_error());\n     // Will print \"Not an OS error\".\n     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "io::error::Error": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::reserve": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves capacity for at least `additional` more elements to be inserted\n in the given `Vec<T>`. The collection may reserve more space to\n speculatively avoid frequent reallocations. After calling `reserve`,\n capacity will be greater than or equal to `self.len() + additional`.\n Does nothing if capacity is already sufficient.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.reserve(10);\n assert!(vec.capacity() >= 11);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "io::error::Error": [
      "Plain",
      "Ref"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ],
    "path::PathBuf": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::pal::unix::os::getcwd"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/os.rs:152:1: 176:2",
  "src": "pub fn getcwd() -> io::Result<PathBuf> {\n    let mut buf = Vec::with_capacity(512);\n    loop {\n        unsafe {\n            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n                buf.set_len(len);\n                buf.shrink_to_fit();\n                return Ok(PathBuf::from(OsString::from_vec(buf)));\n            } else {\n                let error = io::Error::last_os_error();\n                if error.raw_os_error() != Some(libc::ERANGE) {\n                    return Err(error);\n                }\n            }\n\n            // Trigger the internal buffer resizing logic of `Vec` by requiring\n            // more space than the current capacity.\n            let cap = buf.capacity();\n            buf.set_len(cap);\n            buf.reserve(1);\n        }\n    }\n}",
  "mir": "fn sys::pal::unix::os::getcwd() -> core::result::Result<path::PathBuf, io::error::Error> {\n    let mut _0: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _1: alloc_crate::vec::Vec<u8>;\n    let mut _2: *mut u8;\n    let mut _3: &mut alloc_crate::vec::Vec<u8>;\n    let mut _4: bool;\n    let mut _5: *mut u8;\n    let mut _6: usize;\n    let mut _7: &alloc_crate::vec::Vec<u8>;\n    let  _8: usize;\n    let  _9: &[u8];\n    let  _10: &core::ffi::CStr;\n    let mut _11: *const u8;\n    let mut _12: &alloc_crate::vec::Vec<u8>;\n    let  _13: ();\n    let mut _14: &mut alloc_crate::vec::Vec<u8>;\n    let  _15: ();\n    let mut _16: &mut alloc_crate::vec::Vec<u8>;\n    let mut _17: path::PathBuf;\n    let mut _18: ffi::os_str::OsString;\n    let mut _19: alloc_crate::vec::Vec<u8>;\n    let  _20: io::error::Error;\n    let mut _21: bool;\n    let mut _22: &core::option::Option<i32>;\n    let  _23: core::option::Option<i32>;\n    let mut _24: &io::error::Error;\n    let mut _25: &core::option::Option<i32>;\n    let mut _26: io::error::Error;\n    let  _27: usize;\n    let mut _28: &alloc_crate::vec::Vec<u8>;\n    let  _29: ();\n    let mut _30: &mut alloc_crate::vec::Vec<u8>;\n    let  _31: ();\n    let mut _32: &mut alloc_crate::vec::Vec<u8>;\n    let mut _33: bool;\n    debug buf => _1;\n    debug ptr => _2;\n    debug len => _8;\n    debug error => _20;\n    debug cap => _27;\n    bb0: {\n        _33 = false;\n        StorageLive(_1);\n        _1 = alloc_crate::vec::Vec::<u8>::with_capacity(512_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _33 = true;\n        goto -> bb2;\n    }\n    bb2: {\n        StorageLive(_3);\n        _3 = &mut _1;\n        _2 = alloc_crate::vec::Vec::<u8>::as_mut_ptr(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_1;\n        _6 = alloc_crate::vec::Vec::<u8>::capacity(move _7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_7);\n        _5 = libc::getcwd(_2, move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        _4 = core::ptr::mut_ptr::<impl *mut u8>::is_null(move _5) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _4) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_5);\n        StorageLive(_20);\n        _20 = io::error::Error::last_os_error() -> [return: bb16, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_5);\n        StorageLive(_12);\n        _12 = &_1;\n        _11 = alloc_crate::vec::Vec::<u8>::as_ptr(move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        _10 = core::ffi::CStr::from_ptr::<'_>(_11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _9 = core::ffi::CStr::to_bytes(_10) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _8 = PtrMetadata(_9);\n        StorageLive(_14);\n        _14 = &mut _1;\n        _13 = alloc_crate::vec::Vec::<u8>::set_len(move _14, _8) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = &mut _1;\n        _15 = alloc_crate::vec::Vec::<u8>::shrink_to_fit(move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _33 = false;\n        _19 = move _1;\n        _18 = <ffi::os_str::OsString as os::unix::ffi::os_str::OsStringExt>::from_vec(move _19) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_19);\n        _17 = <path::PathBuf as core::convert::From<ffi::os_str::OsString>>::from(move _18) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_18);\n        _0 = core::result::Result::Ok(move _17);\n        StorageDead(_17);\n        goto -> bb25;\n    }\n    bb16: {\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = &_20;\n        _23 = io::error::Error::raw_os_error(move _24) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _22 = &_23;\n        StorageDead(_24);\n        StorageLive(_25);\n        _25 = sys::pal::unix::os::getcwd::promoted[0];\n        _21 = <core::option::Option<i32> as core::cmp::PartialEq>::ne(move _22, move _25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        switchInt(move _21) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageLive(_26);\n        _26 = move _20;\n        _0 = core::result::Result::Err(move _26);\n        StorageDead(_26);\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb25;\n    }\n    bb20: {\n        StorageDead(_25);\n        StorageDead(_23);\n        StorageDead(_22);\n        StorageDead(_21);\n        drop(_20) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_20);\n        StorageDead(_4);\n        StorageLive(_28);\n        _28 = &_1;\n        _27 = alloc_crate::vec::Vec::<u8>::capacity(move _28) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_28);\n        StorageLive(_30);\n        _30 = &mut _1;\n        _29 = alloc_crate::vec::Vec::<u8>::set_len(move _30, _27) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_30);\n        StorageLive(_32);\n        _32 = &mut _1;\n        _31 = alloc_crate::vec::Vec::<u8>::reserve(move _32, 1_usize) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_32);\n        goto -> bb2;\n    }\n    bb25: {\n        StorageDead(_4);\n        switchInt(_33) -> [0: bb26, otherwise: bb27];\n    }\n    bb26: {\n        _33 = false;\n        StorageDead(_1);\n        return;\n    }\n    bb27: {\n        drop(_1) -> [return: bb26, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}