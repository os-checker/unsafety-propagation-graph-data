{
  "name": "time::Instant::checked_sub",
  "safe": true,
  "callees": {
    "sys::pal::unix::time::Instant::checked_sub_duration": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::pal::unix::time::Instant": "Constructor",
        "core::time::Duration": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "time::Instant": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " A measurement of a monotonically nondecreasing clock.\n Opaque and useful only with [`Duration`].\n\n Instants are always guaranteed, barring [platform bugs], to be no less than any previously\n measured instant when created, and are often useful for tasks such as measuring\n benchmarks or timing how long an operation takes.\n\n Note, however, that instants are **not** guaranteed to be **steady**. In other\n words, each tick of the underlying clock might not be the same length (e.g.\n some seconds may be longer than others). An instant may jump forwards or\n experience time dilation (slow down or speed up), but it will never go\n backwards.\n As part of this non-guarantee it is also not specified whether system suspends count as\n elapsed time or not. The behavior varies across platforms and Rust versions.\n\n Instants are opaque types that can only be compared to one another. There is\n no method to get \"the number of seconds\" from an instant. Instead, it only\n allows measuring the duration between two instants (or comparing two\n instants).\n\n The size of an `Instant` struct may vary depending on the target operating\n system.\n\n Example:\n\n ```no_run\n use std::time::{Duration, Instant};\n use std::thread::sleep;\n\n fn main() {\n    let now = Instant::now();\n\n    // we sleep for 2 seconds\n    sleep(Duration::new(2, 0));\n    // it prints '2'\n    println!(\"{}\", now.elapsed().as_secs());\n }\n ```\n\n [platform bugs]: Instant#monotonicity\n\n # OS-specific behaviors\n\n An `Instant` is a wrapper around system-specific types and it may behave\n differently depending on the underlying operating system. For example,\n the following snippet is fine on Linux but panics on macOS:\n\n ```no_run\n use std::time::{Instant, Duration};\n\n let now = Instant::now();\n let days_per_10_millennia = 365_2425;\n let solar_seconds_per_day = 60 * 60 * 24;\n let millennium_in_solar_seconds = 31_556_952_000;\n assert_eq!(millennium_in_solar_seconds, days_per_10_millennia * solar_seconds_per_day / 10);\n\n let duration = Duration::new(millennium_in_solar_seconds, 0);\n println!(\"{:?}\", now + duration);\n ```\n\n For cross-platform code, you can comfortably use durations of up to around one hundred years.\n\n # Underlying System calls\n\n The following system calls are [currently] being used by `now()` to find out\n the current time:\n\n |  Platform |               System call                                            |\n |-----------|----------------------------------------------------------------------|\n | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n | UNIX      | [clock_gettime] with `CLOCK_MONOTONIC`                               |\n | Darwin    | [clock_gettime] with `CLOCK_UPTIME_RAW`                              |\n | VXWorks   | [clock_gettime] with `CLOCK_MONOTONIC`                               |\n | SOLID     | `get_tim`                                                            |\n | WASI      | [__wasi_clock_time_get] with `monotonic`                             |\n | Windows   | [QueryPerformanceCounter]                                            |\n\n [currently]: crate::io#platform-specific-behavior\n [QueryPerformanceCounter]: https://docs.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter\n [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time\n [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode\n [__wasi_clock_time_get]: https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#clock_time_get\n [clock_gettime]: https://linux.die.net/man/3/clock_gettime\n\n **Disclaimer:** These system calls might change over time.\n\n > Note: mathematical operations like [`add`] may panic if the underlying\n > structure cannot represent the new point in time.\n\n [`add`]: Instant::add\n\n ## Monotonicity\n\n On all platforms `Instant` will try to use an OS API that guarantees monotonic behavior\n if available, which is the case for all [tier 1] platforms.\n In practice such guarantees are – under rare circumstances – broken by hardware, virtualization\n or operating system bugs. To work around these bugs and platforms not offering monotonic clocks\n [`duration_since`], [`elapsed`] and [`sub`] saturate to zero. In older Rust versions this\n lead to a panic instead. [`checked_duration_since`] can be used to detect and handle situations\n where monotonicity is violated, or `Instant`s are subtracted in the wrong order.\n\n This workaround obscures programming errors where earlier and later instants are accidentally\n swapped. For this reason future Rust versions may reintroduce panics.\n\n [tier 1]: https://doc.rust-lang.org/rustc/platform-support.html\n [`duration_since`]: Instant::duration_since\n [`elapsed`]: Instant::elapsed\n [`sub`]: Instant::sub\n [`checked_duration_since`]: Instant::checked_duration_since\n\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::pal::unix::time::Instant": [
      "Ref"
    ],
    "time::Instant": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::time::Duration": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::time::Instant::checked_sub"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/time.rs:407:5: 409:6",
  "src": "pub fn checked_sub(&self, duration: Duration) -> Option<Instant> {\n        self.0.checked_sub_duration(&duration).map(Instant)\n    }",
  "mir": "fn time::Instant::checked_sub(_1: &time::Instant, _2: core::time::Duration) -> core::option::Option<time::Instant> {\n    let mut _0: core::option::Option<time::Instant>;\n    let mut _3: core::option::Option<sys::pal::unix::time::Instant>;\n    let mut _4: &sys::pal::unix::time::Instant;\n    let  _5: &core::time::Duration;\n    debug self => _1;\n    debug duration => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: sys::pal::unix::time::Instant);\n        _5 = &_2;\n        _3 = sys::pal::unix::time::Instant::checked_sub_duration(move _4, _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _0 = core::option::Option::<sys::pal::unix::time::Instant>::map::<time::Instant, fn(sys::pal::unix::time::Instant) -> time::Instant {time::Instant}>(move _3, time::Instant) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns `Some(t)` where `t` is the time `self - duration` if `t` can be represented as\n `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n otherwise.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}