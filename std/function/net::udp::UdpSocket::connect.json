{
  "name": "net::udp::UdpSocket::connect",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::UdpSocket::connect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::UdpSocket": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::net::connection::socket::UdpSocket": [
      "Ref"
    ],
    "net::udp::UdpSocket": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::net::udp::UdpSocket::connect"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/net/udp.rs:679:5: 681:6",
  "src": "pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n        self.0.connect(addr)\n    }",
  "mir": "fn net::udp::UdpSocket::connect(_1: &net::udp::UdpSocket, _2: A) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: &sys::net::connection::socket::UdpSocket;\n    debug self => _1;\n    debug addr => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::net::connection::socket::UdpSocket);\n        _0 = sys::net::connection::socket::UdpSocket::connect::<A>(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Connects this UDP socket to a remote address, allowing the `send` and\n `recv` syscalls to be used to send data and also applies filters to only\n receive data from the specified address.\n\n If `addr` yields multiple addresses, `connect` will be attempted with\n each of the addresses until the underlying OS function returns no\n error. Note that usually, a successful `connect` call does not specify\n that there is a remote server listening on the port, rather, such an\n error would only be detected after the first send. If the OS returns an\n error for each of the specified addresses, the error returned from the\n last connection attempt (the last address) is returned.\n\n # Examples\n\n Creates a UDP socket bound to `127.0.0.1:3400` and connect the socket to\n `127.0.0.1:8080`:\n\n ```no_run\n use std::net::UdpSocket;\n\n let socket = UdpSocket::bind(\"127.0.0.1:3400\").expect(\"couldn't bind to address\");\n socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n ```\n\n Unlike in the TCP case, passing an array of addresses to the `connect`\n function of a UDP socket is not a useful thing to do: The OS will be\n unable to determine whether something is listening on the remote\n address without the application sending data.\n\n If your first `connect` is to a loopback address, subsequent\n `connect`s to non-loopback addresses might fail, depending\n on the platform.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}