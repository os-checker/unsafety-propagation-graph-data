{
  "name": "sys::process::env::CommandEnv::capture",
  "safe": true,
  "callees": {
    "alloc_crate::collections::BTreeMap::<K, V>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes a new, empty `BTreeMap`.\n\n Does not allocate anything on its own.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n\n // entries can now be inserted into the empty map\n map.insert(1, \"a\");\n ```\n",
      "adt": {}
    },
    "env::vars_os": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator of (variable, value) pairs of OS strings, for all the\n environment variables of the current process.\n\n The returned iterator contains a snapshot of the process's environment\n variables at the time of this invocation. Modifications to environment\n variables afterwards will not be reflected in the returned iterator.\n\n Note that the returned iterator will not check if the environment variables\n are valid Unicode. If you want to panic on invalid UTF-8,\n use the [`vars`] function instead.\n\n # Examples\n\n ```\n // Print all environment variables.\n for (key, value) in std::env::vars_os() {\n     println!(\"{key:?}: {value:?}\");\n }\n ```\n",
      "adt": {
        "env::VarsOs": "Constructor"
      }
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "alloc_crate::collections::BTreeMap::<K, V, A>::insert": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Inserts a key-value pair into the map.\n\n If the map did not have this key present, `None` is returned.\n\n If the map did have this key present, the value is updated, and the old\n value is returned. The key is not updated, though; this matters for\n types that can be `==` without being identical. See the [module-level\n documentation] for more.\n\n [module-level documentation]: index.html#insert-and-complex-keys\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n assert_eq!(map.insert(37, \"a\"), None);\n assert_eq!(map.is_empty(), false);\n\n map.insert(37, \"b\");\n assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n assert_eq!(map[&37], \"c\");\n ```\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "alloc_crate::collections::BTreeMap::<K, V, A>::remove": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the value at the key if the key\n was previously in the map.\n\n The key may be any borrowed form of the map's key type, but the ordering\n on the borrowed form *must* match the ordering on the key type.\n\n # Examples\n\n ```\n use std::collections::BTreeMap;\n\n let mut map = BTreeMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove(&1), Some(\"a\"));\n assert_eq!(map.remove(&1), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::collections::BTreeMap": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "sys::process::env::CommandEnv": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Ref"
    ],
    "env::VarsOs": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2775, kind: RigidTy(Tuple([Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }])) }), Field(0, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2775, kind: RigidTy(Tuple([Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }])) }), Field(1, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12915, kind: RigidTy(Tuple([Ty { id: 2821, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Not)) }, Ty { id: 12916, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2809, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })]))) }, Not)) }])) }), Field(0, Ty { id: 2821, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Not)) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12915, kind: RigidTy(Tuple([Ty { id: 2821, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) }, Not)) }, Ty { id: 12916, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2809, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })]))) }, Not)) }])) }), Field(1, Ty { id: 12916, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2809, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })]))) }, Not)) })])",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])"
    ],
    "ffi::os_str::OsString": [
      "Plain",
      "Ref"
    ],
    "alloc_crate::collections::btree_map::Iter": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 4081,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/env.rs:24:5: 39:6",
  "src": "pub fn capture(&self) -> BTreeMap<EnvKey, OsString> {\n        let mut result = BTreeMap::<EnvKey, OsString>::new();\n        if !self.clear {\n            for (k, v) in env::vars_os() {\n                result.insert(k.into(), v);\n            }\n        }\n        for (k, maybe_v) in &self.vars {\n            if let &Some(ref v) = maybe_v {\n                result.insert(k.clone(), v.clone());\n            } else {\n                result.remove(k);\n            }\n        }\n        result\n    }",
  "mir": "fn sys::process::env::CommandEnv::capture(_1: &sys::process::env::CommandEnv) -> alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString> {\n    let mut _0: alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _2: alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _3: bool;\n    let mut _4: env::VarsOs;\n    let mut _5: env::VarsOs;\n    let mut _6: env::VarsOs;\n    let mut _7: core::option::Option<(ffi::os_str::OsString, ffi::os_str::OsString)>;\n    let mut _8: &mut env::VarsOs;\n    let mut _9: isize;\n    let  _10: ffi::os_str::OsString;\n    let  _11: ffi::os_str::OsString;\n    let  _12: core::option::Option<ffi::os_str::OsString>;\n    let mut _13: &mut alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _14: ffi::os_str::OsString;\n    let mut _15: alloc_crate::collections::btree_map::Iter<'_, ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>;\n    let mut _16: &alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>;\n    let mut _17: alloc_crate::collections::btree_map::Iter<'_, ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>;\n    let mut _18: core::option::Option<(&ffi::os_str::OsString, &core::option::Option<ffi::os_str::OsString>)>;\n    let mut _19: &mut alloc_crate::collections::btree_map::Iter<'_, ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>;\n    let mut _20: isize;\n    let  _21: &ffi::os_str::OsString;\n    let  _22: &core::option::Option<ffi::os_str::OsString>;\n    let mut _23: isize;\n    let  _24: &ffi::os_str::OsString;\n    let  _25: core::option::Option<ffi::os_str::OsString>;\n    let mut _26: &mut alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>;\n    let mut _27: ffi::os_str::OsString;\n    let mut _28: ffi::os_str::OsString;\n    let  _29: core::option::Option<ffi::os_str::OsString>;\n    let mut _30: &mut alloc_crate::collections::BTreeMap<ffi::os_str::OsString, ffi::os_str::OsString>;\n    debug self => _1;\n    debug result => _2;\n    debug iter => _6;\n    debug k => _10;\n    debug v => _11;\n    debug iter => _17;\n    debug k => _21;\n    debug maybe_v => _22;\n    debug v => _24;\n    bb0: {\n        StorageLive(_2);\n        _2 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, ffi::os_str::OsString>::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = ((*_1).0: bool);\n        switchInt(move _3) -> [0: bb2, otherwise: bb14];\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = env::vars_os() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = <env::VarsOs as core::iter::IntoIterator>::into_iter(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageLive(_6);\n        _6 = move _4;\n        goto -> bb5;\n    }\n    bb5: {\n        StorageLive(_7);\n        _8 = &mut _6;\n        _7 = <env::VarsOs as core::iter::Iterator>::next(_8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _10 = move (((_7 as variant#1).0: (ffi::os_str::OsString, ffi::os_str::OsString)).0: ffi::os_str::OsString);\n        _11 = move (((_7 as variant#1).0: (ffi::os_str::OsString, ffi::os_str::OsString)).1: ffi::os_str::OsString);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut _2;\n        StorageLive(_14);\n        _14 = <ffi::os_str::OsString as core::convert::Into<ffi::os_str::OsString>>::into(_10) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_7);\n        drop(_6) -> [return: bb13, unwind unreachable];\n    }\n    bb10: {\n        _12 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, ffi::os_str::OsString>::insert(move _13, move _14, _11) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        StorageDead(_13);\n        drop(_12) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_12);\n        StorageDead(_7);\n        goto -> bb5;\n    }\n    bb13: {\n        StorageDead(_6);\n        StorageDead(_4);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_3);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &((*_1).2: alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>>);\n        _15 = <&alloc_crate::collections::BTreeMap<ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>> as core::iter::IntoIterator>::into_iter(move _16) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_16);\n        StorageLive(_17);\n        _17 = move _15;\n        goto -> bb16;\n    }\n    bb16: {\n        StorageLive(_18);\n        _19 = &mut _17;\n        _18 = <alloc_crate::collections::btree_map::Iter<'_, ffi::os_str::OsString, core::option::Option<ffi::os_str::OsString>> as core::iter::Iterator>::next(_19) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _20 = discriminant(_18);\n        switchInt(move _20) -> [0: bb19, 1: bb18, otherwise: bb7];\n    }\n    bb18: {\n        _21 = (((_18 as variant#1).0: (&ffi::os_str::OsString, &core::option::Option<ffi::os_str::OsString>)).0: &ffi::os_str::OsString);\n        StorageLive(_22);\n        _22 = (((_18 as variant#1).0: (&ffi::os_str::OsString, &core::option::Option<ffi::os_str::OsString>)).1: &core::option::Option<ffi::os_str::OsString>);\n        _23 = discriminant((*_22));\n        switchInt(move _23) -> [1: bb20, 0: bb25, otherwise: bb7];\n    }\n    bb19: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageDead(_15);\n        _0 = move _2;\n        StorageDead(_2);\n        return;\n    }\n    bb20: {\n        _24 = &(((*_22) as variant#1).0: ffi::os_str::OsString);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &mut _2;\n        StorageLive(_27);\n        _27 = <ffi::os_str::OsString as core::clone::Clone>::clone(_21) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageLive(_28);\n        _28 = <ffi::os_str::OsString as core::clone::Clone>::clone(_24) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _25 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, ffi::os_str::OsString>::insert(move _26, move _27, move _28) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_28);\n        StorageDead(_27);\n        StorageDead(_26);\n        drop(_25) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_25);\n        goto -> bb28;\n    }\n    bb25: {\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &mut _2;\n        _29 = alloc_crate::collections::BTreeMap::<ffi::os_str::OsString, ffi::os_str::OsString>::remove::<ffi::os_str::OsString>(move _30, _21) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_30);\n        drop(_29) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_29);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_22);\n        StorageDead(_18);\n        goto -> bb16;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}