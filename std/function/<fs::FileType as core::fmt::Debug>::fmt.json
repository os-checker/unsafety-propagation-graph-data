{
  "name": "<fs::FileType as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "fs::FileType::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests whether this file type represents a regular file.\n The result is mutually exclusive to the results of\n [`is_dir`] and [`is_symlink`]; only zero or one of these\n tests may pass.\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`File::open`] or\n [`OpenOptions::open`] for more information.\n\n [`is_dir`]: FileType::is_dir\n [`is_symlink`]: FileType::is_symlink\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs;\n\n     let metadata = fs::metadata(\"foo.txt\")?;\n     let file_type = metadata.file_type();\n\n     assert_eq!(file_type.is_file(), true);\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::FileType": "ImmutableAsArgument"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "fs::FileType::is_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests whether this file type represents a directory. The\n result is mutually exclusive to the results of\n [`is_file`] and [`is_symlink`]; only zero or one of these\n tests may pass.\n\n [`is_file`]: FileType::is_file\n [`is_symlink`]: FileType::is_symlink\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs;\n\n     let metadata = fs::metadata(\"foo.txt\")?;\n     let file_type = metadata.file_type();\n\n     assert_eq!(file_type.is_dir(), false);\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::FileType": "ImmutableAsArgument"
      }
    },
    "fs::FileType::is_symlink": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests whether this file type represents a symbolic link.\n The result is mutually exclusive to the results of\n [`is_dir`] and [`is_file`]; only zero or one of these\n tests may pass.\n\n The underlying [`Metadata`] struct needs to be retrieved\n with the [`fs::symlink_metadata`] function and not the\n [`fs::metadata`] function. The [`fs::metadata`] function\n follows symbolic links, so [`is_symlink`] would always\n return `false` for the target file.\n\n [`fs::metadata`]: metadata\n [`fs::symlink_metadata`]: symlink_metadata\n [`is_dir`]: FileType::is_dir\n [`is_file`]: FileType::is_file\n [`is_symlink`]: FileType::is_symlink\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::symlink_metadata(\"foo.txt\")?;\n     let file_type = metadata.file_type();\n\n     assert_eq!(file_type.is_symlink(), false);\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::FileType": "ImmutableAsArgument"
      }
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish_non_exhaustive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marks the struct as non-exhaustive, indicating to the reader that there are some other\n fields that are not shown in the debug representation.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     hidden: f32,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .finish_non_exhaustive() // Show that some other field(s) exist.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n     \"Bar { bar: 10, .. }\",\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "fs::FileType": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1158,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:2350:5: 2356:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"FileType\")\n            .field(\"is_file\", &self.is_file())\n            .field(\"is_dir\", &self.is_dir())\n            .field(\"is_symlink\", &self.is_symlink())\n            .finish_non_exhaustive()\n    }",
  "mir": "fn <fs::FileType as core::fmt::Debug>::fmt(_1: &fs::FileType, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _4: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _5: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _6: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _7: core::fmt::DebugStruct<'_, '_>;\n    let mut _8: &str;\n    let mut _9: &str;\n    let mut _10: &dyn core::fmt::Debug;\n    let  _11: &bool;\n    let  _12: bool;\n    let mut _13: &str;\n    let mut _14: &dyn core::fmt::Debug;\n    let  _15: &bool;\n    let  _16: bool;\n    let mut _17: &str;\n    let mut _18: &dyn core::fmt::Debug;\n    let  _19: &bool;\n    let  _20: bool;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = \"FileType\";\n        _7 = core::fmt::Formatter::<'_>::debug_struct(_2, move _8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = &mut _7;\n        StorageDead(_8);\n        StorageLive(_9);\n        _9 = \"is_file\";\n        StorageLive(_10);\n        StorageLive(_12);\n        _12 = fs::FileType::is_file(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _11 = &_12;\n        _10 = _11 as &dyn core::fmt::Debug;\n        _5 = core::fmt::DebugStruct::<'_, '_>::field(move _6, move _9, move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_6);\n        StorageLive(_13);\n        _13 = \"is_dir\";\n        StorageLive(_14);\n        StorageLive(_16);\n        _16 = fs::FileType::is_dir(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _15 = &_16;\n        _14 = _15 as &dyn core::fmt::Debug;\n        _4 = core::fmt::DebugStruct::<'_, '_>::field(_5, move _13, move _14) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_17);\n        _17 = \"is_symlink\";\n        StorageLive(_18);\n        StorageLive(_20);\n        _20 = fs::FileType::is_symlink(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _19 = &_20;\n        _18 = _19 as &dyn core::fmt::Debug;\n        _3 = core::fmt::DebugStruct::<'_, '_>::field(_4, move _17, move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        StorageDead(_17);\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish_non_exhaustive(_3) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_20);\n        StorageDead(_16);\n        StorageDead(_12);\n        StorageDead(_7);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}