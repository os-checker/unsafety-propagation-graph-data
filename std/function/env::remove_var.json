{
  "name": "env::remove_var",
  "safe": false,
  "callees": {
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "sys::env::unix::unsetenv": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or computes it from a closure.\n\n\n # Examples\n\n ```\n fn count(x: &str) -> usize { x.len() }\n\n assert_eq!(Ok(2).unwrap_or_else(count), 2);\n assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::env::remove_var"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:429:1: 433:2",
  "src": "pub unsafe fn remove_var<K: AsRef<OsStr>>(key: K) {\n    let key = key.as_ref();\n    unsafe { env_imp::unsetenv(key) }\n        .unwrap_or_else(|e| panic!(\"failed to remove environment variable `{key:?}`: {e}\"))\n}",
  "mir": "fn env::remove_var(_1: K) -> () {\n    let mut _0: ();\n    let  _2: &ffi::os_str::OsStr;\n    let mut _3: &K;\n    let mut _4: core::result::Result<(), io::error::Error>;\n    let mut _5: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:432:25: 432:28};\n    let mut _6: &&ffi::os_str::OsStr;\n    debug key => _1;\n    debug key => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &_1;\n        _2 = <K as core::convert::AsRef<ffi::os_str::OsStr>>::as_ref(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = sys::env::unix::unsetenv(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:432:25: 432:28}(move _6);\n        StorageDead(_6);\n        _0 = core::result::Result::<(), io::error::Error>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:432:25: 432:28}>(move _4, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        drop(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        return;\n    }\n}\n",
  "doc": " Removes an environment variable from the environment of the currently running process.\n\n # Safety\n\n This function is safe to call in a single-threaded program.\n\n This function is also always safe to call on Windows, in single-threaded\n and multi-threaded programs.\n\n In multi-threaded programs on other operating systems, the only safe option is\n to not use `set_var` or `remove_var` at all.\n\n The exact requirement is: you\n must ensure that there are no other threads concurrently writing or\n *reading*(!) the environment through functions or global variables other\n than the ones in this module. The problem is that these operating systems\n do not provide a thread-safe way to read the environment, and most C\n libraries, including libc itself, do not advertise which functions read\n from the environment. Even functions from the Rust standard library may\n read the environment without going through this module, e.g. for DNS\n lookups from [`std::net::ToSocketAddrs`]. No stable guarantee is made about\n which functions may read from the environment in future versions of a\n library. All this makes it not practically possible for you to guarantee\n that no other thread will read the environment, so the only safe option is\n to not use `set_var` or `remove_var` in multi-threaded programs at all.\n\n Discussion of this unsafety on Unix may be found in:\n\n  - [Austin Group Bugzilla](https://austingroupbugs.net/view.php?id=188)\n  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n\n To prevent a child process from inheriting an environment variable, you can\n instead use [`Command::env_remove`] or [`Command::env_clear`].\n\n [`std::net::ToSocketAddrs`]: crate::net::ToSocketAddrs\n [`Command::env_remove`]: crate::process::Command::env_remove\n [`Command::env_clear`]: crate::process::Command::env_clear\n\n # Panics\n\n This function may panic if `key` is empty, contains an ASCII equals sign\n `'='` or the NUL character `'\\0'`, or when the value contains the NUL\n character.\n\n # Examples\n\n ```no_run\n use std::env;\n\n let key = \"KEY\";\n unsafe {\n     env::set_var(key, \"VALUE\");\n }\n assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n\n unsafe {\n     env::remove_var(key);\n }\n assert!(env::var(key).is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}