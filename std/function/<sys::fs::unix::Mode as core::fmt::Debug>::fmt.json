{
  "name": "<sys::fs::unix::Mode as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "core::fmt::rt::Argument::<'_>::new_octal": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Glue for usage of the [`write!`] macro with implementors of this trait.\n\n This method should generally not be invoked manually, but rather through\n the [`write!`] macro itself.\n\n Writes some formatted information into this instance.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo(i32);\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_fmt(format_args!(\"Foo {}\", self.0))\n     }\n }\n\n assert_eq!(format!(\"{}\", Foo(-1)), \"Foo -1\");\n assert_eq!(format!(\"{:0>8}\", Foo(2)), \"Foo 2\");\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data to the underlying buffer contained within this\n formatter.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_str(\"Foo\")\n         // This is equivalent to:\n         // write!(formatter, \"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo}\"), \"Foo\");\n assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n ```\n",
      "adt": {}
    },
    "core::fmt::Write::write_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::fs::unix::Mode": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<sys::fs::unix::Mode as core::fmt::Debug>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1948:5: 2002:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let Self(mode) = *self;\n        write!(f, \"0o{mode:06o}\")?;\n\n        let entry_type = match mode & libc::S_IFMT {\n            libc::S_IFDIR => 'd',\n            libc::S_IFBLK => 'b',\n            libc::S_IFCHR => 'c',\n            libc::S_IFLNK => 'l',\n            libc::S_IFIFO => 'p',\n            libc::S_IFREG => '-',\n            _ => return Ok(()),\n        };\n\n        f.write_str(\" (\")?;\n        f.write_char(entry_type)?;\n\n        // Owner permissions\n        f.write_char(if mode & libc::S_IRUSR != 0 { 'r' } else { '-' })?;\n        f.write_char(if mode & libc::S_IWUSR != 0 { 'w' } else { '-' })?;\n        let owner_executable = mode & libc::S_IXUSR != 0;\n        let setuid = mode as c_int & libc::S_ISUID as c_int != 0;\n        f.write_char(match (owner_executable, setuid) {\n            (true, true) => 's',  // executable and setuid\n            (false, true) => 'S', // setuid\n            (true, false) => 'x', // executable\n            (false, false) => '-',\n        })?;\n\n        // Group permissions\n        f.write_char(if mode & libc::S_IRGRP != 0 { 'r' } else { '-' })?;\n        f.write_char(if mode & libc::S_IWGRP != 0 { 'w' } else { '-' })?;\n        let group_executable = mode & libc::S_IXGRP != 0;\n        let setgid = mode as c_int & libc::S_ISGID as c_int != 0;\n        f.write_char(match (group_executable, setgid) {\n            (true, true) => 's',  // executable and setgid\n            (false, true) => 'S', // setgid\n            (true, false) => 'x', // executable\n            (false, false) => '-',\n        })?;\n\n        // Other permissions\n        f.write_char(if mode & libc::S_IROTH != 0 { 'r' } else { '-' })?;\n        f.write_char(if mode & libc::S_IWOTH != 0 { 'w' } else { '-' })?;\n        let other_executable = mode & libc::S_IXOTH != 0;\n        let sticky = mode as c_int & libc::S_ISVTX as c_int != 0;\n        f.write_char(match (entry_type, other_executable, sticky) {\n            ('d', true, true) => 't',  // searchable and restricted deletion\n            ('d', false, true) => 'T', // restricted deletion\n            (_, true, _) => 'x',       // executable\n            (_, false, _) => '-',\n        })?;\n\n        f.write_char(')')\n    }",
  "mir": "fn <sys::fs::unix::Mode as core::fmt::Debug>::fmt(_1: &sys::fs::unix::Mode, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let  _3: u32;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _5: core::result::Result<(), core::fmt::Error>;\n    let mut _6: core::fmt::Arguments<'_>;\n    let  _7: (&u32,);\n    let mut _8: &u32;\n    let  _9: [core::fmt::rt::Argument<'_>; 1];\n    let mut _10: core::fmt::rt::Argument<'_>;\n    let mut _11: &[u8; 11];\n    let  _12: &[core::fmt::rt::Argument<'_>; 1];\n    let mut _13: isize;\n    let  _14: char;\n    let mut _15: u32;\n    let mut _16: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _17: core::result::Result<(), core::fmt::Error>;\n    let mut _18: &str;\n    let mut _19: isize;\n    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _21: core::result::Result<(), core::fmt::Error>;\n    let mut _22: char;\n    let mut _23: isize;\n    let mut _24: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _25: core::result::Result<(), core::fmt::Error>;\n    let mut _26: char;\n    let mut _27: u32;\n    let mut _28: isize;\n    let mut _29: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _30: core::result::Result<(), core::fmt::Error>;\n    let mut _31: char;\n    let mut _32: u32;\n    let mut _33: isize;\n    let  _34: bool;\n    let mut _35: u32;\n    let  _36: bool;\n    let mut _37: i32;\n    let mut _38: i32;\n    let mut _39: i32;\n    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _41: core::result::Result<(), core::fmt::Error>;\n    let mut _42: char;\n    let mut _43: (bool, bool);\n    let mut _44: isize;\n    let mut _45: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _46: core::result::Result<(), core::fmt::Error>;\n    let mut _47: char;\n    let mut _48: u32;\n    let mut _49: isize;\n    let mut _50: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _51: core::result::Result<(), core::fmt::Error>;\n    let mut _52: char;\n    let mut _53: u32;\n    let mut _54: isize;\n    let  _55: bool;\n    let mut _56: u32;\n    let  _57: bool;\n    let mut _58: i32;\n    let mut _59: i32;\n    let mut _60: i32;\n    let mut _61: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _62: core::result::Result<(), core::fmt::Error>;\n    let mut _63: char;\n    let mut _64: (bool, bool);\n    let mut _65: isize;\n    let mut _66: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _67: core::result::Result<(), core::fmt::Error>;\n    let mut _68: char;\n    let mut _69: u32;\n    let mut _70: isize;\n    let mut _71: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _72: core::result::Result<(), core::fmt::Error>;\n    let mut _73: char;\n    let mut _74: u32;\n    let mut _75: isize;\n    let  _76: bool;\n    let mut _77: u32;\n    let  _78: bool;\n    let mut _79: i32;\n    let mut _80: i32;\n    let mut _81: i32;\n    let mut _82: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _83: core::result::Result<(), core::fmt::Error>;\n    let mut _84: char;\n    let mut _85: (char, bool, bool);\n    let mut _86: char;\n    let mut _87: isize;\n    let mut _88: &u32;\n    debug self => _1;\n    debug f => _2;\n    debug mode => _3;\n    debug args => _7;\n    debug args => _9;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug entry_type => _14;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug owner_executable => _34;\n    debug setuid => _36;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug group_executable => _55;\n    debug setgid => _57;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug other_executable => _76;\n    debug sticky => _78;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    bb0: {\n        _3 = ((*_1).0: u32);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &_3;\n        _7 = (move _8);\n        StorageDead(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _88 = (_7.0: &u32);\n        _10 = core::fmt::rt::Argument::<'_>::new_octal::<u32>(_88) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _9 = [move _10];\n        StorageDead(_10);\n        StorageLive(_11);\n        _11 = b\"\\x020o\\xc3 \\x00\\x00i\\x06\\x00\\x00\";\n        _12 = &_9;\n        _6 = core::fmt::Arguments::<'_>::new::<11, 1>(move _11, _12) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_11);\n        _5 = core::fmt::Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        _4 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        _13 = discriminant(_4);\n        switchInt(move _13) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageDead(_4);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = BitAnd(_3, libc::S_IFMT);\n        switchInt(_15) -> [16384: bb15, 24576: bb14, 8192: bb13, 40960: bb12, 4096: bb11, 32768: bb10, otherwise: bb9];\n    }\n    bb7: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb117;\n    }\n    bb9: {\n        _0 = core::result::Result::Ok(());\n        StorageDead(_15);\n        goto -> bb116;\n    }\n    bb10: {\n        _14 = '-';\n        goto -> bb16;\n    }\n    bb11: {\n        _14 = 'p';\n        goto -> bb16;\n    }\n    bb12: {\n        _14 = 'l';\n        goto -> bb16;\n    }\n    bb13: {\n        _14 = 'c';\n        goto -> bb16;\n    }\n    bb14: {\n        _14 = 'b';\n        goto -> bb16;\n    }\n    bb15: {\n        _14 = 'd';\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = \" (\";\n        _17 = core::fmt::Formatter::<'_>::write_str(_2, move _18) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_18);\n        _16 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _17) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_17);\n        _19 = discriminant(_16);\n        switchInt(move _19) -> [0: bb19, 1: bb20, otherwise: bb5];\n    }\n    bb19: {\n        StorageDead(_16);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = _14;\n        _21 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _22) -> [return: bb22, unwind unreachable];\n    }\n    bb20: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_16);\n        goto -> bb116;\n    }\n    bb22: {\n        StorageDead(_22);\n        _20 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _21) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_21);\n        _23 = discriminant(_20);\n        switchInt(move _23) -> [0: bb24, 1: bb25, otherwise: bb5];\n    }\n    bb24: {\n        StorageDead(_20);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = BitAnd(_3, libc::S_IRUSR);\n        switchInt(move _27) -> [0: bb28, otherwise: bb27];\n    }\n    bb25: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_20);\n        goto -> bb116;\n    }\n    bb27: {\n        StorageDead(_27);\n        _26 = 'r';\n        goto -> bb29;\n    }\n    bb28: {\n        StorageDead(_27);\n        _26 = '-';\n        goto -> bb29;\n    }\n    bb29: {\n        _25 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _26) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_26);\n        _24 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _25) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_25);\n        _28 = discriminant(_24);\n        switchInt(move _28) -> [0: bb32, 1: bb33, otherwise: bb5];\n    }\n    bb32: {\n        StorageDead(_24);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = BitAnd(_3, libc::S_IWUSR);\n        switchInt(move _32) -> [0: bb36, otherwise: bb35];\n    }\n    bb33: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_24);\n        goto -> bb116;\n    }\n    bb35: {\n        StorageDead(_32);\n        _31 = 'w';\n        goto -> bb37;\n    }\n    bb36: {\n        StorageDead(_32);\n        _31 = '-';\n        goto -> bb37;\n    }\n    bb37: {\n        _30 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _31) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_31);\n        _29 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _30) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_30);\n        _33 = discriminant(_29);\n        switchInt(move _33) -> [0: bb40, 1: bb41, otherwise: bb5];\n    }\n    bb40: {\n        StorageDead(_29);\n        StorageLive(_35);\n        _35 = BitAnd(_3, libc::S_IXUSR);\n        _34 = Ne(move _35, 0_u32);\n        StorageDead(_35);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = _3 as i32;\n        StorageLive(_39);\n        _39 = libc::S_ISUID as i32;\n        _37 = BitAnd(move _38, move _39);\n        StorageDead(_39);\n        StorageDead(_38);\n        _36 = Ne(move _37, 0_i32);\n        StorageDead(_37);\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = (_34, _36);\n        switchInt((_43.0: bool)) -> [0: bb44, otherwise: bb43];\n    }\n    bb41: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_29);\n        goto -> bb116;\n    }\n    bb43: {\n        switchInt((_43.1: bool)) -> [0: bb46, otherwise: bb48];\n    }\n    bb44: {\n        switchInt((_43.1: bool)) -> [0: bb45, otherwise: bb47];\n    }\n    bb45: {\n        _42 = '-';\n        goto -> bb49;\n    }\n    bb46: {\n        _42 = 'x';\n        goto -> bb49;\n    }\n    bb47: {\n        _42 = 'S';\n        goto -> bb49;\n    }\n    bb48: {\n        _42 = 's';\n        goto -> bb49;\n    }\n    bb49: {\n        _41 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _42) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_42);\n        _40 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _41) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_41);\n        _44 = discriminant(_40);\n        switchInt(move _44) -> [0: bb52, 1: bb53, otherwise: bb5];\n    }\n    bb52: {\n        StorageDead(_43);\n        StorageDead(_40);\n        StorageLive(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = BitAnd(_3, libc::S_IRGRP);\n        switchInt(move _48) -> [0: bb56, otherwise: bb55];\n    }\n    bb53: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_43);\n        StorageDead(_40);\n        goto -> bb115;\n    }\n    bb55: {\n        StorageDead(_48);\n        _47 = 'r';\n        goto -> bb57;\n    }\n    bb56: {\n        StorageDead(_48);\n        _47 = '-';\n        goto -> bb57;\n    }\n    bb57: {\n        _46 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _47) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_47);\n        _45 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _46) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_46);\n        _49 = discriminant(_45);\n        switchInt(move _49) -> [0: bb60, 1: bb61, otherwise: bb5];\n    }\n    bb60: {\n        StorageDead(_45);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = BitAnd(_3, libc::S_IWGRP);\n        switchInt(move _53) -> [0: bb64, otherwise: bb63];\n    }\n    bb61: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_45);\n        goto -> bb115;\n    }\n    bb63: {\n        StorageDead(_53);\n        _52 = 'w';\n        goto -> bb65;\n    }\n    bb64: {\n        StorageDead(_53);\n        _52 = '-';\n        goto -> bb65;\n    }\n    bb65: {\n        _51 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _52) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_52);\n        _50 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _51) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_51);\n        _54 = discriminant(_50);\n        switchInt(move _54) -> [0: bb68, 1: bb69, otherwise: bb5];\n    }\n    bb68: {\n        StorageDead(_50);\n        StorageLive(_56);\n        _56 = BitAnd(_3, libc::S_IXGRP);\n        _55 = Ne(move _56, 0_u32);\n        StorageDead(_56);\n        StorageLive(_58);\n        StorageLive(_59);\n        _59 = _3 as i32;\n        StorageLive(_60);\n        _60 = libc::S_ISGID as i32;\n        _58 = BitAnd(move _59, move _60);\n        StorageDead(_60);\n        StorageDead(_59);\n        _57 = Ne(move _58, 0_i32);\n        StorageDead(_58);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = (_55, _57);\n        switchInt((_64.0: bool)) -> [0: bb72, otherwise: bb71];\n    }\n    bb69: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_50);\n        goto -> bb115;\n    }\n    bb71: {\n        switchInt((_64.1: bool)) -> [0: bb74, otherwise: bb76];\n    }\n    bb72: {\n        switchInt((_64.1: bool)) -> [0: bb73, otherwise: bb75];\n    }\n    bb73: {\n        _63 = '-';\n        goto -> bb77;\n    }\n    bb74: {\n        _63 = 'x';\n        goto -> bb77;\n    }\n    bb75: {\n        _63 = 'S';\n        goto -> bb77;\n    }\n    bb76: {\n        _63 = 's';\n        goto -> bb77;\n    }\n    bb77: {\n        _62 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _63) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        StorageDead(_63);\n        _61 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _62) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_62);\n        _65 = discriminant(_61);\n        switchInt(move _65) -> [0: bb80, 1: bb81, otherwise: bb5];\n    }\n    bb80: {\n        StorageDead(_64);\n        StorageDead(_61);\n        StorageLive(_66);\n        StorageLive(_67);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = BitAnd(_3, libc::S_IROTH);\n        switchInt(move _69) -> [0: bb84, otherwise: bb83];\n    }\n    bb81: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        StorageDead(_64);\n        StorageDead(_61);\n        goto -> bb114;\n    }\n    bb83: {\n        StorageDead(_69);\n        _68 = 'r';\n        goto -> bb85;\n    }\n    bb84: {\n        StorageDead(_69);\n        _68 = '-';\n        goto -> bb85;\n    }\n    bb85: {\n        _67 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _68) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        StorageDead(_68);\n        _66 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _67) -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        StorageDead(_67);\n        _70 = discriminant(_66);\n        switchInt(move _70) -> [0: bb88, 1: bb89, otherwise: bb5];\n    }\n    bb88: {\n        StorageDead(_66);\n        StorageLive(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = BitAnd(_3, libc::S_IWOTH);\n        switchInt(move _74) -> [0: bb92, otherwise: bb91];\n    }\n    bb89: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        StorageDead(_66);\n        goto -> bb114;\n    }\n    bb91: {\n        StorageDead(_74);\n        _73 = 'w';\n        goto -> bb93;\n    }\n    bb92: {\n        StorageDead(_74);\n        _73 = '-';\n        goto -> bb93;\n    }\n    bb93: {\n        _72 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _73) -> [return: bb94, unwind unreachable];\n    }\n    bb94: {\n        StorageDead(_73);\n        _71 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _72) -> [return: bb95, unwind unreachable];\n    }\n    bb95: {\n        StorageDead(_72);\n        _75 = discriminant(_71);\n        switchInt(move _75) -> [0: bb96, 1: bb97, otherwise: bb5];\n    }\n    bb96: {\n        StorageDead(_71);\n        StorageLive(_77);\n        _77 = BitAnd(_3, libc::S_IXOTH);\n        _76 = Ne(move _77, 0_u32);\n        StorageDead(_77);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = _3 as i32;\n        StorageLive(_81);\n        _81 = libc::S_ISVTX as i32;\n        _79 = BitAnd(move _80, move _81);\n        StorageDead(_81);\n        StorageDead(_80);\n        _78 = Ne(move _79, 0_i32);\n        StorageDead(_79);\n        StorageLive(_82);\n        StorageLive(_83);\n        StorageLive(_84);\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = _14;\n        _85 = (move _86, _76, _78);\n        StorageDead(_86);\n        switchInt((_85.0: char)) -> [100: bb100, otherwise: bb99];\n    }\n    bb97: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb98, unwind unreachable];\n    }\n    bb98: {\n        StorageDead(_71);\n        goto -> bb114;\n    }\n    bb99: {\n        switchInt((_85.1: bool)) -> [0: bb103, otherwise: bb104];\n    }\n    bb100: {\n        switchInt((_85.1: bool)) -> [0: bb102, otherwise: bb101];\n    }\n    bb101: {\n        switchInt((_85.2: bool)) -> [0: bb99, otherwise: bb106];\n    }\n    bb102: {\n        switchInt((_85.2: bool)) -> [0: bb99, otherwise: bb105];\n    }\n    bb103: {\n        _84 = '-';\n        goto -> bb107;\n    }\n    bb104: {\n        _84 = 'x';\n        goto -> bb107;\n    }\n    bb105: {\n        _84 = 'T';\n        goto -> bb107;\n    }\n    bb106: {\n        _84 = 't';\n        goto -> bb107;\n    }\n    bb107: {\n        _83 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, move _84) -> [return: bb108, unwind unreachable];\n    }\n    bb108: {\n        StorageDead(_84);\n        _82 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _83) -> [return: bb109, unwind unreachable];\n    }\n    bb109: {\n        StorageDead(_83);\n        _87 = discriminant(_82);\n        switchInt(move _87) -> [0: bb110, 1: bb111, otherwise: bb5];\n    }\n    bb110: {\n        StorageDead(_85);\n        StorageDead(_82);\n        _0 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, ')') -> [return: bb113, unwind unreachable];\n    }\n    bb111: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb112, unwind unreachable];\n    }\n    bb112: {\n        StorageDead(_85);\n        StorageDead(_82);\n        goto -> bb114;\n    }\n    bb113: {\n        StorageDead(_14);\n        goto -> bb118;\n    }\n    bb114: {\n        goto -> bb115;\n    }\n    bb115: {\n        goto -> bb116;\n    }\n    bb116: {\n        StorageDead(_14);\n        goto -> bb117;\n    }\n    bb117: {\n        goto -> bb118;\n    }\n    bb118: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}