{
  "name": "<io::Split<B> as core::iter::Iterator>::next",
  "safe": true,
  "callees": {
    "alloc_crate::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    },
    "io::BufRead::read_until": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes into `buf` until the delimiter `byte` or EOF is reached.\n\n This function will read bytes from the underlying stream until the\n delimiter or EOF is found. Once found, all bytes up to, and including,\n the delimiter (if found) will be appended to `buf`.\n\n If successful, this function will return the total number of bytes read.\n\n This function is blocking and should be used carefully: it is possible for\n an attacker to continuously send bytes without ever sending the delimiter\n or EOF.\n\n # Errors\n\n This function will ignore all instances of [`ErrorKind::Interrupted`] and\n will otherwise return any errors returned by [`fill_buf`].\n\n If an I/O error is encountered then all bytes read so far will be\n present in `buf` and its length will have been adjusted appropriately.\n\n [`fill_buf`]: BufRead::fill_buf\n\n # Examples\n\n [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n this example, we use [`Cursor`] to read all the bytes in a byte slice\n in hyphen delimited segments:\n\n ```\n use std::io::{self, BufRead};\n\n let mut cursor = io::Cursor::new(b\"lorem-ipsum\");\n let mut buf = vec![];\n\n // cursor is at 'l'\n let num_bytes = cursor.read_until(b'-', &mut buf)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 6);\n assert_eq!(buf, b\"lorem-\");\n buf.clear();\n\n // cursor is at 'i'\n let num_bytes = cursor.read_until(b'-', &mut buf)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 5);\n assert_eq!(buf, b\"ipsum\");\n buf.clear();\n\n // cursor is at EOF\n let num_bytes = cursor.read_until(b'-', &mut buf)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 0);\n assert_eq!(buf, b\"\");\n ```\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of elements in the vector, also referred to\n as its 'length'.\n\n # Examples\n\n ```\n let a = vec![1, 2, 3];\n assert_eq!(a.len(), 3);\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::pop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes the last element from a vector and returns it, or [`None`] if it\n is empty.\n\n If you'd like to pop the first element, consider using\n [`VecDeque::pop_front`] instead.\n\n [`VecDeque::pop_front`]: crate::collections::VecDeque::pop_front\n\n # Examples\n\n ```\n let mut vec = vec![1, 2, 3];\n assert_eq!(vec.pop(), Some(3));\n assert_eq!(vec, [1, 2]);\n ```\n\n # Time complexity\n\n Takes *O*(1) time.\n",
      "adt": {}
    }
  },
  "adts": {
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "io::Split": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 1781,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/mod.rs:3325:5: 3337:6",
  "src": "fn next(&mut self) -> Option<Result<Vec<u8>>> {\n        let mut buf = Vec::new();\n        match self.buf.read_until(self.delim, &mut buf) {\n            Ok(0) => None,\n            Ok(_n) => {\n                if buf[buf.len() - 1] == self.delim {\n                    buf.pop();\n                }\n                Some(Ok(buf))\n            }\n            Err(e) => Some(Err(e)),\n        }\n    }",
  "mir": "fn <io::Split<B> as core::iter::Iterator>::next(_1: &mut io::Split<B>) -> core::option::Option<core::result::Result<alloc_crate::vec::Vec<u8>, io::error::Error>> {\n    let mut _0: core::option::Option<core::result::Result<alloc_crate::vec::Vec<u8>, io::error::Error>>;\n    let mut _2: alloc_crate::vec::Vec<u8>;\n    let mut _3: core::result::Result<usize, io::error::Error>;\n    let mut _4: &mut B;\n    let mut _5: u8;\n    let mut _6: &mut alloc_crate::vec::Vec<u8>;\n    let mut _7: isize;\n    let  _8: usize;\n    let mut _9: bool;\n    let mut _10: u8;\n    let mut _11: &u8;\n    let mut _12: &alloc_crate::vec::Vec<u8>;\n    let mut _13: usize;\n    let mut _14: usize;\n    let mut _15: &alloc_crate::vec::Vec<u8>;\n    let mut _16: (usize, bool);\n    let mut _17: u8;\n    let  _18: core::option::Option<u8>;\n    let mut _19: &mut alloc_crate::vec::Vec<u8>;\n    let mut _20: core::result::Result<alloc_crate::vec::Vec<u8>, io::error::Error>;\n    let mut _21: alloc_crate::vec::Vec<u8>;\n    let  _22: io::error::Error;\n    let mut _23: core::result::Result<alloc_crate::vec::Vec<u8>, io::error::Error>;\n    let mut _24: bool;\n    debug self => _1;\n    debug buf => _2;\n    debug _n => _8;\n    debug e => _22;\n    bb0: {\n        _24 = false;\n        StorageLive(_2);\n        _2 = alloc_crate::vec::Vec::<u8>::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _24 = true;\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: B);\n        StorageLive(_5);\n        _5 = ((*_1).1: u8);\n        _6 = &mut _2;\n        _3 = <B as io::BufRead>::read_until(move _4, move _5, _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _7 = discriminant(_3);\n        switchInt(move _7) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        switchInt(((_3 as variant#0).0: usize)) -> [0: bb7, otherwise: bb6];\n    }\n    bb5: {\n        _22 = move ((_3 as variant#1).0: io::error::Error);\n        StorageLive(_23);\n        _23 = core::result::Result::Err(_22);\n        _0 = core::option::Option::Some(move _23);\n        StorageDead(_23);\n        goto -> bb16;\n    }\n    bb6: {\n        StorageLive(_8);\n        _8 = ((_3 as variant#0).0: usize);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_2;\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_2;\n        _14 = alloc_crate::vec::Vec::<u8>::len(move _15) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        _0 = core::option::Option::None;\n        goto -> bb16;\n    }\n    bb8: {\n        StorageDead(_15);\n        _16 = CheckedSub(_14, 1_usize);\n        assert(!move (_16.1: bool), \"attempt to compute `{} - {}`, which would overflow\", move _14, 1_usize) -> [success: bb9, unwind unreachable];\n    }\n    bb9: {\n        _13 = move (_16.0: usize);\n        StorageDead(_14);\n        _11 = <alloc_crate::vec::Vec<u8> as core::ops::Index<usize>>::index(move _12, move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _10 = (*_11);\n        StorageDead(_13);\n        StorageDead(_12);\n        StorageLive(_17);\n        _17 = ((*_1).1: u8);\n        _9 = Eq(move _10, move _17);\n        switchInt(move _9) -> [0: bb13, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_17);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _2;\n        _18 = alloc_crate::vec::Vec::<u8>::pop(move _19) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb14;\n    }\n    bb13: {\n        StorageDead(_17);\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_9);\n        StorageLive(_20);\n        StorageLive(_21);\n        _24 = false;\n        _21 = move _2;\n        _20 = core::result::Result::Ok(move _21);\n        StorageDead(_21);\n        _0 = core::option::Option::Some(move _20);\n        StorageDead(_20);\n        StorageDead(_8);\n        goto -> bb16;\n    }\n    bb15: {\n        _24 = false;\n        StorageDead(_2);\n        return;\n    }\n    bb16: {\n        StorageDead(_3);\n        switchInt(_24) -> [0: bb15, otherwise: bb17];\n    }\n    bb17: {\n        drop(_2) -> [return: bb15, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}