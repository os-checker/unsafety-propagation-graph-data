{
  "name": "backtrace_rs::symbolize::gimli::elf::Object::<'a>::parse",
  "safe": true,
  "callees": {
    "object::read::elf::FileHeader::parse": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Read the file header.\n\n Also checks that the ident field in the file header is a supported format.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "object::read::elf::FileHeader::endian": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "object::read::elf::FileHeader::sections": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the section table.\n",
      "adt": {}
    },
    "object::read::elf::SectionTable::<'data, Elf, R>::symbols": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the symbol table of the given section type.\n\n Returns an empty symbol table if the symbol table does not exist.\n",
      "adt": {}
    },
    "object::read::elf::SymbolTable::<'data, Elf, R>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return true if the symbol table is empty.\n",
      "adt": {}
    },
    "object::read::elf::SymbolTable::<'data, Elf, R>::strings": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the string table used for the symbol names.\n",
      "adt": {}
    },
    "object::read::elf::SymbolTable::<'data, Elf, R>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Iterate over the symbols.\n\n This includes the null symbol at index 0, which you will usually need to skip.\n",
      "adt": {}
    },
    "core::iter::Iterator::filter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator which uses a closure to determine if an element\n should be yielded.\n\n Given an element the closure must return `true` or `false`. The returned\n iterator will yield only the elements for which the closure returns\n `true`.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [0i32, 1, 2];\n\n let mut iter = a.into_iter().filter(|x| x.is_positive());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), None);\n ```\n\n Because the closure passed to `filter()` takes a reference, and many\n iterators iterate over references, this leads to a possibly confusing\n situation, where the type of the closure is a double reference:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|x| **x > 1); // needs two *s!\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n It's common to instead use destructuring on the argument to strip away one:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&x| *x > 1); // both & and *\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n or both:\n\n ```\n let s = &[0, 1, 2];\n\n let mut iter = s.iter().filter(|&&x| x > 1); // two &s\n\n assert_eq!(iter.next(), Some(&2));\n assert_eq!(iter.next(), None);\n ```\n\n of these layers.\n\n Note that `iter.filter(f).next()` is equivalent to `iter.find(f)`.\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::sort_unstable_by_key": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sorts the slice in ascending order with a key extraction function, **without** preserving\n the initial order of equal elements.\n\n This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\n allocate), and *O*(*n* \\* log(*n*)) worst-case.\n\n If the implementation of [`Ord`] for `K` does not implement a [total order], the function\n may panic; even if the function exits normally, the resulting order of elements in the slice\n is unspecified. See also the note on panicking below.\n\n For example `|a, b| (a - b).cmp(a)` is a comparison function that is neither transitive nor\n reflexive nor total, `a < b < c < a` with `a = 1, b = 2, c = 3`. For more information and\n examples see the [`Ord`] documentation.\n\n All original elements will remain in the slice and any possible modifications via interior\n mutability are observed in the input. Same is true if the implementation of [`Ord`] for `K` panics.\n\n # Current implementation\n\n The current implementation is based on [ipnsort] by Lukas Bergdoll and Orson Peters, which\n combines the fast average case of quicksort with the fast worst case of heapsort, achieving\n linear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\n expected time to sort the data is *O*(*n* \\* log(*k*)).\n\n It is typically faster than stable sorting, except in a few special cases, e.g., when the\n slice is partially sorted.\n\n # Panics\n\n May panic if the implementation of [`Ord`] for `K` does not implement a [total order], or if\n the [`Ord`] implementation panics.\n\n # Examples\n\n ```\n let mut v = [4i32, -5, 1, -3, 2];\n\n v.sort_unstable_by_key(|k| k.abs());\n assert_eq!(v, [1, 2, -3, 4, -5]);\n ```\n\n [ipnsort]: https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\n [total order]: https://en.wikipedia.org/wiki/Total_order\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18136, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 18188, kind: RigidTy(Adt(AdtDef(DefId { id: 12746, name: \"object::elf::FileHeader64\" }), GenericArgs([Type(Ty { id: 18141, kind: RigidTy(Adt(AdtDef(DefId { id: 12735, name: \"object::LittleEndian\" }), GenericArgs([]))) })]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18145, kind: RigidTy(Adt(AdtDef(DefId { id: 12736, name: \"object::read::elf::SectionTable\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 18188, kind: RigidTy(Adt(AdtDef(DefId { id: 12746, name: \"object::elf::FileHeader64\" }), GenericArgs([Type(Ty { id: 18141, kind: RigidTy(Adt(AdtDef(DefId { id: 12735, name: \"object::LittleEndian\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18149, kind: RigidTy(Adt(AdtDef(DefId { id: 12738, name: \"object::read::elf::SymbolTable\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 18188, kind: RigidTy(Adt(AdtDef(DefId { id: 12746, name: \"object::elf::FileHeader64\" }), GenericArgs([Type(Ty { id: 18141, kind: RigidTy(Adt(AdtDef(DefId { id: 12735, name: \"object::LittleEndian\" }), GenericArgs([]))) })]))) }), Type(Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })]))) })])"
    ],
    "object::elf::FileHeader64": [
      "Ref"
    ],
    "object::read::elf::SectionTable": [
      "Plain",
      "Ref"
    ],
    "object::read::elf::SymbolTable": [
      "Plain",
      "Ref"
    ],
    "object::StringTable": [
      "Plain"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::Filter": [
      "Plain"
    ],
    "object::LittleEndian": [
      "Ref",
      "Plain"
    ],
    "core::iter::Map": [
      "Plain"
    ],
    "alloc_crate::vec::Vec": [
      "Plain",
      "MutRef"
    ],
    "backtrace_rs::symbolize::gimli::elf::Object": [
      "Plain"
    ]
  },
  "path": 501,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:165:5: 213:6",
  "src": "fn parse(data: &'a [u8]) -> Option<Object<'a>> {\n        let elf = Elf::parse(data).ok()?;\n        let endian = elf.endian().ok()?;\n        let sections = elf.sections(endian, data).ok()?;\n        let mut syms = sections\n            .symbols(endian, data, object::elf::SHT_SYMTAB)\n            .ok()?;\n        if syms.is_empty() {\n            syms = sections\n                .symbols(endian, data, object::elf::SHT_DYNSYM)\n                .ok()?;\n        }\n        let strings = syms.strings();\n\n        let mut syms = syms\n            .iter()\n            // Only look at function/object symbols. This mirrors what\n            // libbacktrace does and in general we're only symbolicating\n            // function addresses in theory. Object symbols correspond\n            // to data, and maybe someone's crazy enough to have a\n            // function go into static data?\n            .filter(|sym| {\n                let st_type = sym.st_type();\n                st_type == object::elf::STT_FUNC || st_type == object::elf::STT_OBJECT\n            })\n            // skip anything that's in an undefined section header,\n            // since it means it's an imported function and we're only\n            // symbolicating with locally defined functions.\n            .filter(|sym| sym.st_shndx(endian) != object::elf::SHN_UNDEF)\n            .map(|sym| {\n                let address = sym.st_value(endian).into();\n                let size = sym.st_size(endian).into();\n                let name = sym.st_name(endian);\n                ParsedSym {\n                    address,\n                    size,\n                    name,\n                }\n            })\n            .collect::<Vec<_>>();\n        syms.sort_unstable_by_key(|s| s.address);\n        Some(Object {\n            endian,\n            data,\n            sections,\n            strings,\n            syms,\n        })\n    }",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::Object::<'a>::parse(_1: &[u8]) -> core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>> {\n    let mut _0: core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>>;\n    let mut _2: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _3: core::option::Option<&object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _4: core::result::Result<&object::elf::FileHeader64<object::LittleEndian>, object::Error>;\n    let mut _5: isize;\n    let  _6: &object::elf::FileHeader64<object::LittleEndian>;\n    let  _7: object::LittleEndian;\n    let mut _8: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, object::LittleEndian>;\n    let mut _9: core::option::Option<object::LittleEndian>;\n    let mut _10: core::result::Result<object::LittleEndian, object::Error>;\n    let mut _11: isize;\n    let  _12: object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _13: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>>;\n    let mut _14: core::option::Option<object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>>;\n    let mut _15: core::result::Result<object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>, object::Error>;\n    let mut _16: isize;\n    let  _17: object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _18: object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _19: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>>;\n    let mut _20: core::option::Option<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>>;\n    let mut _21: core::result::Result<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>, object::Error>;\n    let mut _22: &object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _23: isize;\n    let  _24: object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _25: bool;\n    let mut _26: &object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _27: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>>;\n    let mut _28: core::option::Option<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>>;\n    let mut _29: core::result::Result<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>, object::Error>;\n    let mut _30: &object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _31: isize;\n    let  _32: object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let  _33: object::StringTable<'_>;\n    let mut _34: &object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _35: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    let mut _36: core::iter::Map<core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:194:18: 194:23}>;\n    let mut _37: core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26}>;\n    let mut _38: core::iter::Filter<core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}>;\n    let mut _39: core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>;\n    let mut _40: &object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _41: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26};\n    let mut _42: &object::LittleEndian;\n    let mut _43: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:194:18: 194:23};\n    let mut _44: &object::LittleEndian;\n    let  _45: ();\n    let mut _46: &mut [backtrace_rs::symbolize::gimli::elf::ParsedSym];\n    let mut _47: &mut alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    let mut _48: backtrace_rs::symbolize::gimli::elf::Object<'_>;\n    let mut _49: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>;\n    debug data => _1;\n    debug elf => _6;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _6;\n    debug endian => object::LittleEndian;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => object::LittleEndian;\n    debug sections => _12;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _17;\n    debug syms => _18;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _24;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _32;\n    debug strings => _33;\n    debug syms => _35;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <object::elf::FileHeader64<object::LittleEndian> as object::read::elf::FileHeader>::parse::<'_, &[u8]>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = core::result::Result::<&object::elf::FileHeader64<object::LittleEndian>, object::Error>::ok(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _2 = <core::option::Option<&object::elf::FileHeader64<object::LittleEndian>> as core::ops::Try>::branch(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        _5 = discriminant(_2);\n        switchInt(move _5) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _6 = ((_2 as variant#0).0: &object::elf::FileHeader64<object::LittleEndian>);\n        StorageDead(_2);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = <object::elf::FileHeader64<object::LittleEndian> as object::read::elf::FileHeader>::endian(_6) -> [return: bb8, unwind unreachable];\n    }\n    bb6: {\n        _0 = <core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_2);\n        goto -> bb46;\n    }\n    bb8: {\n        _9 = core::result::Result::<object::LittleEndian, object::Error>::ok(move _10) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_10);\n        _8 = <core::option::Option<object::LittleEndian> as core::ops::Try>::branch(move _9) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_9);\n        _11 = discriminant(_8);\n        switchInt(move _11) -> [0: bb11, 1: bb12, otherwise: bb4];\n    }\n    bb11: {\n        StorageDead(_8);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = <object::elf::FileHeader64<object::LittleEndian> as object::read::elf::FileHeader>::sections::<'_, &[u8]>(_6, object::LittleEndian, _1) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _0 = <core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_8);\n        goto -> bb46;\n    }\n    bb14: {\n        _14 = core::result::Result::<object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>, object::Error>::ok(move _15) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_15);\n        _13 = <core::option::Option<object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>> as core::ops::Try>::branch(move _14) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_14);\n        _16 = discriminant(_13);\n        switchInt(move _16) -> [0: bb17, 1: bb18, otherwise: bb4];\n    }\n    bb17: {\n        StorageLive(_17);\n        _17 = ((_13 as variant#0).0: object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>);\n        _12 = _17;\n        StorageDead(_17);\n        StorageDead(_13);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_12;\n        _21 = object::read::elf::SectionTable::<'_, object::elf::FileHeader64<object::LittleEndian>>::symbols(move _22, object::LittleEndian, _1, object::elf::SHT_SYMTAB) -> [return: bb20, unwind unreachable];\n    }\n    bb18: {\n        _0 = <core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_13);\n        goto -> bb45;\n    }\n    bb20: {\n        StorageDead(_22);\n        _20 = core::result::Result::<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>, object::Error>::ok(move _21) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_21);\n        _19 = <core::option::Option<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>> as core::ops::Try>::branch(move _20) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_20);\n        _23 = discriminant(_19);\n        switchInt(move _23) -> [0: bb23, 1: bb24, otherwise: bb4];\n    }\n    bb23: {\n        StorageLive(_24);\n        _24 = ((_19 as variant#0).0: object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>);\n        _18 = _24;\n        StorageDead(_24);\n        StorageDead(_19);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &_18;\n        _25 = object::read::elf::SymbolTable::<'_, object::elf::FileHeader64<object::LittleEndian>>::is_empty(move _26) -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _0 = <core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_19);\n        goto -> bb44;\n    }\n    bb26: {\n        switchInt(move _25) -> [0: bb34, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_12;\n        _29 = object::read::elf::SectionTable::<'_, object::elf::FileHeader64<object::LittleEndian>>::symbols(move _30, object::LittleEndian, _1, object::elf::SHT_DYNSYM) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_30);\n        _28 = core::result::Result::<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>, object::Error>::ok(move _29) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_29);\n        _27 = <core::option::Option<object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>> as core::ops::Try>::branch(move _28) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_28);\n        _31 = discriminant(_27);\n        switchInt(move _31) -> [0: bb31, 1: bb32, otherwise: bb4];\n    }\n    bb31: {\n        _32 = ((_27 as variant#0).0: object::read::elf::SymbolTable<'_, object::elf::FileHeader64<object::LittleEndian>>);\n        _18 = _32;\n        StorageDead(_27);\n        goto -> bb35;\n    }\n    bb32: {\n        _0 = <core::option::Option<backtrace_rs::symbolize::gimli::elf::Object<'_>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_27);\n        StorageDead(_25);\n        goto -> bb44;\n    }\n    bb34: {\n        StorageDead(_26);\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_25);\n        StorageLive(_34);\n        _34 = &_18;\n        _33 = object::read::elf::SymbolTable::<'_, object::elf::FileHeader64<object::LittleEndian>>::strings(move _34) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_34);\n        StorageLive(_35);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        StorageLive(_40);\n        _40 = &_18;\n        _39 = object::read::elf::SymbolTable::<'_, object::elf::FileHeader64<object::LittleEndian>>::iter(move _40) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_40);\n        _38 = <core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>> as core::iter::Iterator>::filter::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}>(move _39, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_39);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = &_7;\n        _41 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26}(move _42);\n        StorageDead(_42);\n        _37 = <core::iter::Filter<core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}> as core::iter::Iterator>::filter::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26}>(move _38, move _41) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_41);\n        StorageDead(_38);\n        StorageLive(_43);\n        StorageLive(_44);\n        _44 = &_7;\n        _43 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:194:18: 194:23}(move _44);\n        StorageDead(_44);\n        _36 = <core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26}> as core::iter::Iterator>::map::<backtrace_rs::symbolize::gimli::elf::ParsedSym, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:194:18: 194:23}>(move _37, move _43) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_43);\n        StorageDead(_37);\n        _35 = <core::iter::Map<core::iter::Filter<core::iter::Filter<core::slice::Iter<'_, object::elf::Sym64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:186:21: 186:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:193:21: 193:26}>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:194:18: 194:23}> as core::iter::Iterator>::collect::<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym>>(move _36) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_36);\n        StorageLive(_47);\n        _47 = &mut _35;\n        _46 = <alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::elf::ParsedSym> as core::ops::DerefMut>::deref_mut(move _47) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_47);\n        _45 = core::slice::<impl [backtrace_rs::symbolize::gimli::elf::ParsedSym]>::sort_unstable_by_key::<u64, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:205:35: 205:38}>(_46, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:205:35: 205:38}) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = move _35;\n        _48 = Object(object::LittleEndian, _1, _12, _33, move _49);\n        StorageDead(_49);\n        _0 = core::option::Option::Some(move _48);\n        StorageDead(_48);\n        StorageDead(_35);\n        StorageDead(_18);\n        goto -> bb47;\n    }\n    bb44: {\n        StorageDead(_18);\n        goto -> bb45;\n    }\n    bb45: {\n        goto -> bb46;\n    }\n    bb46: {\n        goto -> bb47;\n    }\n    bb47: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}