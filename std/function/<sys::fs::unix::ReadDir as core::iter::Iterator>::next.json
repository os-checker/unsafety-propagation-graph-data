{
  "name": "<sys::fs::unix::ReadDir as core::iter::Iterator>::next",
  "safe": true,
  "callees": {
    "sys::pal::unix::os::set_errno": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": " Sets the platform-specific value of errno\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "libc::readdir64": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let s: &str = \"Follow the rabbit\";\n let ptr: *const u8 = s.as_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::os::errno": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the platform-specific value of errno\n",
      "adt": {}
    },
    "io::error::Error::from_raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of an [`Error`] from a particular OS error code.\n\n # Examples\n\n On Linux:\n\n ```\n # if cfg!(target_os = \"linux\") {\n use std::io;\n\n let error = io::Error::from_raw_os_error(22);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n\n On Windows:\n\n ```\n # if cfg!(windows) {\n use std::io;\n\n let error = io::Error::from_raw_os_error(10022);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    },
    "core::ffi::CStr::to_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this C string to a byte slice.\n\n The returned slice will **not** contain the trailing nul terminator that this C\n string has.\n\n > **Note**: This method is currently implemented as a constant-time\n > cast, but it is planned to alter its definition in the future to\n > perform the length calculation whenever this method is called.\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_bytes(), b\"foo\");\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    },
    "alloc_crate::borrow::ToOwned::to_owned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates owned data from borrowed data, usually by cloning.\n\n # Examples\n\n Basic usage:\n\n ```\n let s: &str = \"a\";\n let ss: String = s.to_owned();\n\n let v: &[i32] = &[1, 2];\n let vv: Vec<i32> = v.to_owned();\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::fs::unix::ReadDir": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc_crate::sync::Arc": [
      "Ref",
      "Plain"
    ],
    "sys::fs::unix::InnerReadDir": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "sys::fs::unix::DirEntry": [
      "Plain"
    ],
    "sys::fs::unix::dirent64_min": [
      "Plain"
    ],
    "alloc_crate::ffi::CString": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<sys::fs::unix::ReadDir as core::iter::Iterator>::next"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:719:5: 801:6",
  "src": "fn next(&mut self) -> Option<io::Result<DirEntry>> {\n        use crate::sys::os::{errno, set_errno};\n\n        if self.end_of_stream {\n            return None;\n        }\n\n        unsafe {\n            loop {\n                // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n                // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n                // with unlimited or variable NAME_MAX. Many modern platforms guarantee\n                // thread safety for readdir() as long an individual DIR* is not accessed\n                // concurrently, which is sufficient for Rust.\n                set_errno(0);\n                let entry_ptr: *const dirent64 = readdir64(self.inner.dirp.0);\n                if entry_ptr.is_null() {\n                    // We either encountered an error, or reached the end. Either way,\n                    // the next call to next() should return None.\n                    self.end_of_stream = true;\n\n                    // To distinguish between errors and end-of-directory, we had to clear\n                    // errno beforehand to check for an error now.\n                    return match errno() {\n                        0 => None,\n                        e => Some(Err(Error::from_raw_os_error(e))),\n                    };\n                }\n\n                // The dirent64 struct is a weird imaginary thing that isn't ever supposed\n                // to be worked with by value. Its trailing d_name field is declared\n                // variously as [c_char; 256] or [c_char; 1] on different systems but\n                // either way that size is meaningless; only the offset of d_name is\n                // meaningful. The dirent64 pointers that libc returns from readdir64 are\n                // allowed to point to allocations smaller _or_ LARGER than implied by the\n                // definition of the struct.\n                //\n                // As such, we need to be even more careful with dirent64 than if its\n                // contents were \"simply\" partially initialized data.\n                //\n                // Like for uninitialized contents, converting entry_ptr to `&dirent64`\n                // would not be legal. However, we can use `&raw const (*entry_ptr).d_name`\n                // to refer the fields individually, because that operation is equivalent\n                // to `byte_offset` and thus does not require the full extent of `*entry_ptr`\n                // to be in bounds of the same allocation, only the offset of the field\n                // being referenced.\n\n                // d_name is guaranteed to be null-terminated.\n                let name = CStr::from_ptr((&raw const (*entry_ptr).d_name).cast());\n                let name_bytes = name.to_bytes();\n                if name_bytes == b\".\" || name_bytes == b\"..\" {\n                    continue;\n                }\n\n                // When loading from a field, we can skip the `&raw const`; `(*entry_ptr).d_ino` as\n                // a value expression will do the right thing: `byte_offset` to the field and then\n                // only access those bytes.\n                #[cfg(not(target_os = \"vita\"))]\n                let entry = dirent64_min {\n                    #[cfg(target_os = \"freebsd\")]\n                    d_ino: (*entry_ptr).d_fileno,\n                    #[cfg(not(target_os = \"freebsd\"))]\n                    d_ino: (*entry_ptr).d_ino as u64,\n                    #[cfg(not(any(\n                        target_os = \"solaris\",\n                        target_os = \"illumos\",\n                        target_os = \"aix\",\n                        target_os = \"nto\",\n                    )))]\n                    d_type: (*entry_ptr).d_type as u8,\n                };\n\n                #[cfg(target_os = \"vita\")]\n                let entry = dirent64_min { d_ino: 0u64 };\n\n                return Some(Ok(DirEntry {\n                    entry,\n                    name: name.to_owned(),\n                    dir: Arc::clone(&self.inner),\n                }));\n            }\n        }\n    }",
  "mir": "fn <sys::fs::unix::ReadDir as core::iter::Iterator>::next(_1: &mut sys::fs::unix::ReadDir) -> core::option::Option<core::result::Result<sys::fs::unix::DirEntry, io::error::Error>> {\n    let mut _0: core::option::Option<core::result::Result<sys::fs::unix::DirEntry, io::error::Error>>;\n    let mut _2: bool;\n    let  _3: ();\n    let  _4: *const libc::dirent64;\n    let mut _5: *mut libc::dirent64;\n    let mut _6: *mut libc::DIR;\n    let mut _7: &sys::fs::unix::InnerReadDir;\n    let mut _8: &alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir>;\n    let mut _9: bool;\n    let mut _10: i32;\n    let mut _11: core::result::Result<sys::fs::unix::DirEntry, io::error::Error>;\n    let mut _12: io::error::Error;\n    let  _13: &core::ffi::CStr;\n    let mut _14: *const u8;\n    let mut _15: *const [u8; 256];\n    let  _16: &[u8];\n    let mut _17: bool;\n    let mut _18: &&[u8];\n    let mut _19: &&[u8; 1];\n    let mut _20: bool;\n    let mut _21: &&[u8];\n    let mut _22: &&[u8; 2];\n    let  _23: sys::fs::unix::dirent64_min;\n    let mut _24: u64;\n    let mut _25: u8;\n    let mut _26: core::result::Result<sys::fs::unix::DirEntry, io::error::Error>;\n    let mut _27: sys::fs::unix::DirEntry;\n    let mut _28: alloc_crate::ffi::CString;\n    let mut _29: alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir>;\n    let  _30: &alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir>;\n    let mut _31: *const ();\n    let mut _32: usize;\n    let mut _33: usize;\n    let mut _34: usize;\n    let mut _35: bool;\n    let mut _36: *const ();\n    let mut _37: usize;\n    let mut _38: usize;\n    let mut _39: usize;\n    let mut _40: bool;\n    let mut _41: *const ();\n    let mut _42: usize;\n    let mut _43: bool;\n    let mut _44: bool;\n    let mut _45: bool;\n    let mut _46: bool;\n    let mut _47: *const ();\n    let mut _48: usize;\n    let mut _49: bool;\n    let mut _50: bool;\n    let mut _51: bool;\n    let mut _52: bool;\n    debug self => _1;\n    debug entry_ptr => _4;\n    debug e => _10;\n    debug name => _13;\n    debug name_bytes => _16;\n    debug entry => _23;\n    bb0: {\n        StorageLive(_2);\n        _2 = ((*_1).1: bool);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = core::option::Option::None;\n        StorageDead(_2);\n        goto -> bb28;\n    }\n    bb2: {\n        StorageDead(_2);\n        goto -> bb3;\n    }\n    bb3: {\n        _3 = sys::pal::unix::os::set_errno(0_i32) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &((*_1).0: alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir>);\n        _7 = <alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir> as core::ops::Deref>::deref(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _6 = (((*_7).0: sys::fs::unix::Dir).0: *mut libc::DIR);\n        _5 = libc::readdir64(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _4 = move _5 as *const libc::dirent64;\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = core::ptr::const_ptr::<impl *const libc::dirent64>::is_null(_4) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _9) -> [0: bb13, otherwise: bb8];\n    }\n    bb8: {\n        ((*_1).1: bool) = true;\n        _10 = sys::pal::unix::os::errno() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(_10) -> [0: bb11, otherwise: bb10];\n    }\n    bb10: {\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = io::error::Error::from_raw_os_error(_10) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        _0 = core::option::Option::None;\n        goto -> bb26;\n    }\n    bb12: {\n        _11 = core::result::Result::Err(move _12);\n        StorageDead(_12);\n        _0 = core::option::Option::Some(move _11);\n        StorageDead(_11);\n        goto -> bb26;\n    }\n    bb13: {\n        StorageDead(_9);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &raw const ((*_4).4: [u8; 256]);\n        _14 = core::ptr::const_ptr::<impl *const [u8; 256]>::cast::<u8>(move _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_15);\n        _13 = core::ffi::CStr::from_ptr::<'_>(move _14) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_14);\n        StorageLive(_16);\n        _16 = core::ffi::CStr::to_bytes(_13) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = &_16;\n        StorageLive(_19);\n        _19 = <sys::fs::unix::ReadDir as core::iter::Iterator>::next::promoted[1];\n        _17 = <&[u8] as core::cmp::PartialEq<&[u8; 1]>>::eq(move _18, move _19) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        switchInt(move _17) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb25;\n    }\n    bb19: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &_16;\n        StorageLive(_22);\n        _22 = <sys::fs::unix::ReadDir as core::iter::Iterator>::next::promoted[0];\n        _20 = <&[u8] as core::cmp::PartialEq<&[u8; 2]>>::eq(move _21, move _22) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        switchInt(move _20) -> [0: bb22, otherwise: bb21];\n    }\n    bb21: {\n        StorageDead(_22);\n        StorageDead(_21);\n        goto -> bb25;\n    }\n    bb22: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_17);\n        StorageLive(_24);\n        _36 = _4 as *const ();\n        _37 = _36 as usize;\n        _38 = Sub(<libc::dirent64 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _39 = BitAnd(_37, _38);\n        _40 = Eq(_39, 0_usize);\n        assert(_40, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::dirent64 as core::mem::SizedTypeProperties>::ALIGN, _37) -> [success: bb30, unwind unreachable];\n    }\n    bb23: {\n        StorageLive(_29);\n        _30 = &((*_1).0: alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir>);\n        _29 = <alloc_crate::sync::Arc<sys::fs::unix::InnerReadDir> as core::clone::Clone>::clone(_30) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _27 = DirEntry(move _29, _23, move _28);\n        StorageDead(_29);\n        StorageDead(_28);\n        _26 = core::result::Result::Ok(move _27);\n        StorageDead(_27);\n        _0 = core::option::Option::Some(move _26);\n        StorageDead(_26);\n        StorageDead(_16);\n        goto -> bb27;\n    }\n    bb25: {\n        StorageDead(_20);\n        StorageDead(_17);\n        StorageDead(_16);\n        goto -> bb3;\n    }\n    bb26: {\n        StorageDead(_9);\n        goto -> bb27;\n    }\n    bb27: {\n        goto -> bb28;\n    }\n    bb28: {\n        return;\n    }\n    bb29: {\n        _47 = _4 as *const ();\n        _48 = _47 as usize;\n        _49 = Ne(<libc::dirent64 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _50 = Eq(_48, 0_usize);\n        _51 = BitAnd(_50, _49);\n        _52 = Not(_51);\n        assert(_52, \"null pointer dereference occurred\") -> [success: bb32, unwind unreachable];\n    }\n    bb30: {\n        _41 = _4 as *const ();\n        _42 = _41 as usize;\n        _43 = Ne(<libc::dirent64 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _44 = Eq(_42, 0_usize);\n        _45 = BitAnd(_44, _43);\n        _46 = Not(_45);\n        assert(_46, \"null pointer dereference occurred\") -> [success: bb31, unwind unreachable];\n    }\n    bb31: {\n        _24 = ((*_4).0: u64);\n        StorageLive(_25);\n        _31 = _4 as *const ();\n        _32 = _31 as usize;\n        _33 = Sub(<libc::dirent64 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _34 = BitAnd(_32, _33);\n        _35 = Eq(_34, 0_usize);\n        assert(_35, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::dirent64 as core::mem::SizedTypeProperties>::ALIGN, _32) -> [success: bb29, unwind unreachable];\n    }\n    bb32: {\n        _25 = ((*_4).3: u8);\n        _23 = dirent64_min(move _24, move _25);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = <core::ffi::CStr as alloc_crate::borrow::ToOwned>::to_owned(_13) -> [return: bb23, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}