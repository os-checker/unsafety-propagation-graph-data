{
  "name": "sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd",
  "safe": true,
  "callees": {
    "libc::getpid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::syscall": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "io::IoSlice::<'a>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `IoSlice` wrapping a byte slice.\n\n # Panics\n\n Panics on Windows if the slice is larger than 4GB.\n",
      "adt": {
        "io::IoSlice": "Constructor"
      }
    },
    "core::mem::size_of_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the pointed-to value in bytes.\n\n This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\n statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n then `size_of_val` can be used to get the dynamically-known size.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n\n # Examples\n\n ```\n assert_eq!(4, size_of_val(&5i32));\n\n let x: [u8; 13] = [0; 13];\n let y: &[u8] = &x;\n assert_eq!(13, size_of_val(y));\n ```\n\n [`size_of::<T>()`]: size_of\n",
      "adt": {}
    },
    "libc::CMSG_FIRSTHDR": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "sys::pal::unix::cvt_r": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " `-1` → look at `errno` → retry on `EINTR`. Otherwise `Ok()`-wrap the closure return value.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "sys::stdio::unix::panic_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::stdio::unix::Stderr": "Constructor"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::Write::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a formatted string into this writer, returning any error\n encountered.\n\n This method is primarily used to interface with the\n [`format_args!()`] macro, and it is rare that this should\n explicitly be called. The [`write!()`] macro should be favored to\n invoke this method instead.\n\n This function internally uses the [`write_all`] method on\n this trait and hence will continuously write data so long as no errors\n are received. This also means that partial writes are not indicated in\n this signature.\n\n [`write_all`]: Write::write_all\n\n # Errors\n\n This function will return any I/O error reported while formatting.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // this call\n     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n     // turns into this:\n     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "core::fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "process::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Terminates the process in an abnormal fashion.\n\n The function will never return and will immediately terminate the current\n process in a platform specific \"abnormal\" manner. As a consequence,\n no destructors on the current stack or any other thread's stack\n will be run, Rust IO buffers (eg, from `BufWriter`) will not be flushed,\n and C stdio buffers will (on most platforms) not be flushed.\n\n This is in contrast to the default behavior of [`panic!`] which unwinds\n the current thread's stack and calls all destructors.\n When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n [`panic!`] will still call the [panic hook] while `abort` will not.\n\n If a clean shutdown is needed it is recommended to only call\n this function at a known point where there are no more destructors left\n to run.\n\n The process's termination will be similar to that from the C `abort()`\n function.  On Unix, the process will terminate with signal `SIGABRT`, which\n typically means that the shell prints \"Aborted\".\n\n # Examples\n\n ```no_run\n use std::process;\n\n fn main() {\n     println!(\"aborting\");\n\n     process::abort();\n\n     // execution never gets here\n }\n ```\n\n The `abort` function terminates the process, so the destructor will not\n get run on the example below:\n\n ```no_run\n use std::process;\n\n struct HasDrop;\n\n impl Drop for HasDrop {\n     fn drop(&mut self) {\n         println!(\"This will never be printed!\");\n     }\n }\n\n fn main() {\n     let _x = HasDrop;\n     process::abort();\n     // the destructor implemented for HasDrop will never get run\n }\n ```\n\n [panic hook]: crate::panic::set_hook\n",
      "adt": {}
    },
    "libc::CMSG_LEN": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::CMSG_DATA": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd::Cmsg": [
      "Plain",
      "Unknown([Field(0, Ty { id: 17091, kind: RigidTy(Array(Ty { id: 35, kind: RigidTy(Uint(U8)) }, TyConst { kind: Value(Ty { id: 393, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(24), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(47, ThreadLocalIndex) })) })])"
    ],
    "io::IoSlice": [
      "Plain"
    ],
    "libc::msghdr": [
      "Plain",
      "Unknown([Field(2, Ty { id: 8190, kind: RigidTy(RawPtr(Ty { id: 8201, kind: RigidTy(Adt(AdtDef(DefId { id: 8157, name: \"libc::iovec\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(3, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(5, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(4, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "Ref"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12, kind: RigidTy(Int(Isize)) })])",
      "Ref",
      "Unknown([Field(0, Ty { id: 16188, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 8447, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 12, kind: RigidTy(Int(Isize)) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) }, Not)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "sys::stdio::unix::Stderr": [
      "MutRef",
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "sys::process::unix::common::Command": [
      "Ref"
    ]
  },
  "path": 4156,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:832:5: 887:6",
  "src": "fn send_pidfd(&self, sock: &crate::sys::net::Socket) {\n        use libc::{CMSG_DATA, CMSG_FIRSTHDR, CMSG_LEN, CMSG_SPACE, SCM_RIGHTS, SOL_SOCKET};\n\n        use crate::io::IoSlice;\n        use crate::os::fd::RawFd;\n        use crate::sys::cvt_r;\n\n        unsafe {\n            let child_pid = libc::getpid();\n            // pidfd_open sets CLOEXEC by default\n            let pidfd = libc::syscall(libc::SYS_pidfd_open, child_pid, 0);\n\n            let fds: [c_int; 1] = [pidfd as RawFd];\n\n            const SCM_MSG_LEN: usize = size_of::<[c_int; 1]>();\n\n            #[repr(C)]\n            union Cmsg {\n                buf: [u8; unsafe { CMSG_SPACE(SCM_MSG_LEN as u32) as usize }],\n                _align: libc::cmsghdr,\n            }\n\n            let mut cmsg: Cmsg = mem::zeroed();\n\n            // 0-length message to send through the socket so we can pass along the fd\n            let mut iov = [IoSlice::new(b\"\")];\n            let mut msg: libc::msghdr = mem::zeroed();\n\n            msg.msg_iov = (&raw mut iov) as *mut _;\n            msg.msg_iovlen = 1;\n\n            // only attach cmsg if we successfully acquired the pidfd\n            if pidfd >= 0 {\n                msg.msg_controllen = size_of_val(&cmsg.buf) as _;\n                msg.msg_control = (&raw mut cmsg.buf) as *mut _;\n\n                let hdr = CMSG_FIRSTHDR((&raw mut msg) as *mut _);\n                (*hdr).cmsg_level = SOL_SOCKET;\n                (*hdr).cmsg_type = SCM_RIGHTS;\n                (*hdr).cmsg_len = CMSG_LEN(SCM_MSG_LEN as _) as _;\n                let data = CMSG_DATA(hdr);\n                crate::ptr::copy_nonoverlapping(\n                    fds.as_ptr().cast::<u8>(),\n                    data as *mut _,\n                    SCM_MSG_LEN,\n                );\n            }\n\n            // we send the 0-length message even if we failed to acquire the pidfd\n            // so we get a consistent SEQPACKET order\n            match cvt_r(|| libc::sendmsg(sock.as_raw(), &msg, 0)) {\n                Ok(0) => {}\n                other => rtabort!(\"failed to communicate with parent process. {:?}\", other),\n            }\n        }\n    }",
  "mir": "fn sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd(_1: &sys::process::unix::common::Command, _2: &sys::net::connection::socket::unix::Socket) -> () {\n    let mut _0: ();\n    let  _3: i32;\n    let  _4: i64;\n    let  _5: [i32; 1];\n    let mut _6: i32;\n    let mut _7: sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd::Cmsg;\n    let mut _8: [io::IoSlice<'_>; 1];\n    let mut _9: io::IoSlice<'_>;\n    let mut _10: &[u8];\n    let mut _11: &[u8; 0];\n    let mut _12: libc::msghdr;\n    let mut _13: *mut libc::iovec;\n    let mut _14: *mut [io::IoSlice<'_>; 1];\n    let mut _15: bool;\n    let mut _16: usize;\n    let  _17: &[u8; 24];\n    let mut _18: *mut libc::c_void;\n    let mut _19: *mut [u8; 24];\n    let  _20: *mut libc::cmsghdr;\n    let mut _21: *const libc::msghdr;\n    let mut _22: *mut libc::msghdr;\n    let mut _23: usize;\n    let mut _24: u32;\n    let mut _25: u32;\n    let  _26: *mut u8;\n    let mut _27: *const libc::cmsghdr;\n    let  _28: ();\n    let mut _29: *const u8;\n    let mut _30: *const i32;\n    let mut _31: &[i32];\n    let mut _32: &[i32; 1];\n    let mut _33: core::result::Result<isize, io::error::Error>;\n    let mut _34: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:882:25: 882:27};\n    let mut _35: &libc::msghdr;\n    let mut _36: isize;\n    let  _37: core::result::Result<isize, io::error::Error>;\n    let mut _38: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _39: isize;\n    let mut _40: sys::stdio::unix::Stderr;\n    let mut _41: core::result::Result<(), io::error::Error>;\n    let mut _42: &mut sys::stdio::unix::Stderr;\n    let mut _43: core::fmt::Arguments<'_>;\n    let  _44: (&core::result::Result<isize, io::error::Error>,);\n    let mut _45: &core::result::Result<isize, io::error::Error>;\n    let  _46: [core::fmt::rt::Argument<'_>; 1];\n    let mut _47: core::fmt::rt::Argument<'_>;\n    let mut _48: &[u8; 79];\n    let  _49: &[core::fmt::rt::Argument<'_>; 1];\n    let  _50: !;\n    let mut _51: &core::result::Result<isize, io::error::Error>;\n    let mut _52: *const ();\n    let mut _53: usize;\n    let mut _54: usize;\n    let mut _55: usize;\n    let mut _56: bool;\n    let mut _57: *const ();\n    let mut _58: usize;\n    let mut _59: usize;\n    let mut _60: usize;\n    let mut _61: bool;\n    let mut _62: *const ();\n    let mut _63: usize;\n    let mut _64: usize;\n    let mut _65: usize;\n    let mut _66: bool;\n    let mut _67: *const ();\n    let mut _68: usize;\n    let mut _69: bool;\n    let mut _70: bool;\n    let mut _71: bool;\n    let mut _72: bool;\n    let mut _73: *const ();\n    let mut _74: usize;\n    let mut _75: bool;\n    let mut _76: bool;\n    let mut _77: bool;\n    let mut _78: bool;\n    let mut _79: *const ();\n    let mut _80: usize;\n    let mut _81: bool;\n    let mut _82: bool;\n    let mut _83: bool;\n    let mut _84: bool;\n    debug self => _1;\n    debug sock => _2;\n    debug child_pid => _3;\n    debug pidfd => _4;\n    debug fds => _5;\n    debug cmsg => _7;\n    debug iov => _8;\n    debug msg => _12;\n    debug hdr => _20;\n    debug data => _26;\n    debug other => _37;\n    debug out => sys::stdio::unix::Stderr;\n    debug args => _44;\n    debug args => _46;\n    bb0: {\n        _3 = libc::getpid() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = libc::syscall(libc::SYS_pidfd_open, _3, 0_i32) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = _4 as i32;\n        _5 = [move _6];\n        StorageDead(_6);\n        StorageLive(_7);\n        _7 = core::mem::zeroed::<sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd::Cmsg>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = b\"\";\n        _10 = move _11 as &[u8];\n        StorageDead(_11);\n        _9 = io::IoSlice::<'_>::new(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = [move _9];\n        StorageDead(_9);\n        StorageLive(_12);\n        _12 = core::mem::zeroed::<libc::msghdr>() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_14);\n        _14 = &raw mut _8;\n        _13 = move _14 as *mut libc::iovec;\n        StorageDead(_14);\n        (_12.2: *mut libc::iovec) = _13;\n        (_12.3: usize) = 1_usize;\n        StorageLive(_15);\n        _15 = Ge(_4, 0_i64);\n        switchInt(move _15) -> [0: bb14, otherwise: bb6];\n    }\n    bb6: {\n        _17 = &(_7.0: [u8; 24]);\n        _16 = core::mem::size_of_val::<[u8; 24]>(_17) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        (_12.5: usize) = _16;\n        StorageLive(_19);\n        _19 = &raw mut (_7.0: [u8; 24]);\n        _18 = move _19 as *mut libc::c_void;\n        StorageDead(_19);\n        (_12.4: *mut libc::c_void) = _18;\n        StorageLive(_21);\n        _22 = &raw mut _12;\n        _21 = _22 as *const libc::msghdr;\n        _20 = libc::CMSG_FIRSTHDR(move _21) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_21);\n        _62 = _20 as *const ();\n        _63 = _62 as usize;\n        _64 = Sub(<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _65 = BitAnd(_63, _64);\n        _66 = Eq(_65, 0_usize);\n        assert(_66, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, _63) -> [success: bb31, unwind unreachable];\n    }\n    bb9: {\n        _23 = move _24 as usize;\n        StorageDead(_24);\n        _52 = _20 as *const ();\n        _53 = _52 as usize;\n        _54 = Sub(<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _55 = BitAnd(_53, _54);\n        _56 = Eq(_55, 0_usize);\n        assert(_56, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, _53) -> [success: bb29, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_27);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        _32 = &_5;\n        _31 = move _32 as &[i32];\n        StorageDead(_32);\n        _30 = core::slice::<impl [i32]>::as_ptr(move _31) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_31);\n        _29 = core::ptr::const_ptr::<impl *const i32>::cast::<u8>(move _30) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_30);\n        _28 = core::ptr::copy_nonoverlapping::<u8>(move _29, _26, sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd::SCM_MSG_LEN) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_29);\n        goto -> bb15;\n    }\n    bb14: {\n        goto -> bb15;\n    }\n    bb15: {\n        StorageDead(_15);\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = &_12;\n        _34 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:882:25: 882:27}(_2, move _35);\n        StorageDead(_35);\n        _33 = sys::pal::unix::cvt_r::<isize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:882:25: 882:27}>(move _34) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_34);\n        _36 = discriminant(_33);\n        switchInt(move _36) -> [0: bb18, 1: bb17, otherwise: bb35];\n    }\n    bb17: {\n        StorageLive(_37);\n        _37 = move _33;\n        StorageLive(_38);\n        _38 = sys::stdio::unix::panic_output() -> [return: bb20, unwind unreachable];\n    }\n    bb18: {\n        switchInt(((_33 as variant#0).0: isize)) -> [0: bb19, otherwise: bb17];\n    }\n    bb19: {\n        drop(_33) -> [return: bb28, unwind unreachable];\n    }\n    bb20: {\n        _39 = discriminant(_38);\n        switchInt(move _39) -> [1: bb21, 0: bb26, otherwise: bb35];\n    }\n    bb21: {\n        StorageLive(_41);\n        _42 = &mut _40;\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &_37;\n        _44 = (move _45);\n        StorageDead(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _51 = (_44.0: &core::result::Result<isize, io::error::Error>);\n        _47 = core::fmt::rt::Argument::<'_>::new_debug::<core::result::Result<isize, io::error::Error>>(_51) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        _46 = [move _47];\n        StorageDead(_47);\n        StorageLive(_48);\n        _48 = b\"@fatal runtime error: failed to communicate with parent process. \\xc0\\x0b, aborting\\n\\x00\";\n        _49 = &_46;\n        _43 = core::fmt::Arguments::<'_>::new::<79, 1>(move _48, _49) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_48);\n        _41 = <sys::stdio::unix::Stderr as io::Write>::write_fmt(_42, move _43) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_43);\n        drop(_41) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_46);\n        StorageDead(_44);\n        StorageDead(_41);\n        StorageDead(_38);\n        goto -> bb27;\n    }\n    bb26: {\n        StorageDead(_38);\n        goto -> bb27;\n    }\n    bb27: {\n        _50 = process::abort() -> unwind unreachable;\n    }\n    bb28: {\n        StorageDead(_33);\n        StorageDead(_12);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_5);\n        return;\n    }\n    bb29: {\n        _79 = _20 as *const ();\n        _80 = _79 as usize;\n        _81 = Ne(<libc::cmsghdr as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _82 = Eq(_80, 0_usize);\n        _83 = BitAnd(_82, _81);\n        _84 = Not(_83);\n        assert(_84, \"null pointer dereference occurred\") -> [success: bb34, unwind unreachable];\n    }\n    bb30: {\n        _73 = _20 as *const ();\n        _74 = _73 as usize;\n        _75 = Ne(<libc::cmsghdr as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _76 = Eq(_74, 0_usize);\n        _77 = BitAnd(_76, _75);\n        _78 = Not(_77);\n        assert(_78, \"null pointer dereference occurred\") -> [success: bb33, unwind unreachable];\n    }\n    bb31: {\n        _67 = _20 as *const ();\n        _68 = _67 as usize;\n        _69 = Ne(<libc::cmsghdr as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _70 = Eq(_68, 0_usize);\n        _71 = BitAnd(_70, _69);\n        _72 = Not(_71);\n        assert(_72, \"null pointer dereference occurred\") -> [success: bb32, unwind unreachable];\n    }\n    bb32: {\n        ((*_20).1: i32) = libc::SOL_SOCKET;\n        _57 = _20 as *const ();\n        _58 = _57 as usize;\n        _59 = Sub(<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _60 = BitAnd(_58, _59);\n        _61 = Eq(_60, 0_usize);\n        assert(_61, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<libc::cmsghdr as core::mem::SizedTypeProperties>::ALIGN, _58) -> [success: bb30, unwind unreachable];\n    }\n    bb33: {\n        ((*_20).2: i32) = libc::SCM_RIGHTS;\n        StorageLive(_24);\n        _25 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd::SCM_MSG_LEN as u32;\n        _24 = libc::CMSG_LEN(_25) -> [return: bb9, unwind unreachable];\n    }\n    bb34: {\n        ((*_20).0: usize) = _23;\n        StorageLive(_27);\n        _27 = _20 as *const libc::cmsghdr;\n        _26 = libc::CMSG_DATA(move _27) -> [return: bb10, unwind unreachable];\n    }\n    bb35: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}