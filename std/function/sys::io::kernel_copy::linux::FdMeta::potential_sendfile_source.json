{
  "name": "sys::io::kernel_copy::linux::FdMeta::potential_sendfile_source",
  "safe": true,
  "callees": {
    "fs::Metadata::file_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the file type for this metadata.\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs;\n\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     println!(\"{:?}\", metadata.file_type());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument",
        "fs::FileType": "Constructor"
      }
    },
    "fs::FileType::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests whether this file type represents a regular file.\n The result is mutually exclusive to the results of\n [`is_dir`] and [`is_symlink`]; only zero or one of these\n tests may pass.\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`File::open`] or\n [`OpenOptions::open`] for more information.\n\n [`is_dir`]: FileType::is_dir\n [`is_symlink`]: FileType::is_symlink\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs;\n\n     let metadata = fs::metadata(\"foo.txt\")?;\n     let file_type = metadata.file_type();\n\n     assert_eq!(file_type.is_file(), true);\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::FileType": "ImmutableAsArgument"
      }
    },
    "fs::Metadata::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the file, in bytes, this metadata is for.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert_eq!(0, metadata.len());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument"
      }
    },
    "os::unix::fs::FileTypeExt::is_block_device": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this file type is a block device.\n\n # Examples\n\n ```no_run\n use std::fs;\n use std::os::unix::fs::FileTypeExt;\n use std::io;\n\n fn main() -> io::Result<()> {\n     let meta = fs::metadata(\"block_device_file\")?;\n     let file_type = meta.file_type();\n     assert!(file_type.is_block_device());\n     Ok(())\n }\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::io::kernel_copy::linux::FdMeta": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3692, kind: RigidTy(Adt(AdtDef(DefId { id: 6032, name: \"fs::Metadata\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "fs::Metadata": [
      "Ref"
    ],
    "fs::FileType": [
      "Plain",
      "Ref"
    ]
  },
  "path": 3659,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/io/kernel_copy/linux.rs:110:5: 123:6",
  "src": "fn potential_sendfile_source(&self) -> bool {\n        match self {\n            // procfs erroneously shows 0 length on non-empty readable files.\n            // and if a file is truly empty then a `read` syscall will determine that and skip the write syscall\n            // thus there would be benefit from attempting sendfile\n            FdMeta::Metadata(meta)\n                if meta.file_type().is_file() && meta.len() > 0\n                    || meta.file_type().is_block_device() =>\n            {\n                true\n            }\n            _ => false,\n        }\n    }",
  "mir": "fn sys::io::kernel_copy::linux::FdMeta::potential_sendfile_source(_1: &sys::io::kernel_copy::linux::FdMeta) -> bool {\n    let mut _0: bool;\n    let mut _2: isize;\n    let  _3: &fs::Metadata;\n    let  _4: &&fs::Metadata;\n    let mut _5: bool;\n    let mut _6: &fs::FileType;\n    let  _7: fs::FileType;\n    let mut _8: bool;\n    let mut _9: u64;\n    let mut _10: bool;\n    let mut _11: &fs::FileType;\n    let  _12: fs::FileType;\n    let mut _13: &fs::Metadata;\n    let mut _14: &fs::Metadata;\n    let mut _15: &fs::Metadata;\n    debug self => _1;\n    debug meta => _3;\n    debug meta => _4;\n    bb0: {\n        _2 = discriminant((*_1));\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = false;\n        goto -> bb16;\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_3);\n        _3 = &(((*_1) as variant#0).0: fs::Metadata);\n        _4 = &_3;\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _13 = (*_4);\n        _7 = fs::Metadata::file_type(_13) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = &_7;\n        _5 = fs::FileType::is_file(move _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _5) -> [0: bb9, otherwise: bb5];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_8);\n        StorageLive(_9);\n        _14 = (*_4);\n        _9 = fs::Metadata::len(_14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _8 = Gt(move _9, 0_u64);\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb14;\n    }\n    bb8: {\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _15 = (*_4);\n        _12 = fs::Metadata::file_type(_15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _11 = &_12;\n        _10 = <fs::FileType as os::unix::fs::FileTypeExt>::is_block_device(move _11) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        switchInt(move _10) -> [0: bb15, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb14;\n    }\n    bb14: {\n        _0 = true;\n        StorageDead(_3);\n        StorageDead(_4);\n        goto -> bb16;\n    }\n    bb15: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_3);\n        StorageDead(_4);\n        goto -> bb1;\n    }\n    bb16: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}