{
  "name": "sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec",
  "safe": false,
  "callees": {
    "sys::process::unix::common::ChildStdio::fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::ChildStdio": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::pal::unix::cvt_r": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " `-1` ‚Üí look at `errno` ‚Üí retry on `EINTR`. Otherwise `Ok()`-wrap the closure return value.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_groups": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "libc::setgroups": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "sys::process::unix::common::Command::get_gid": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "libc::setgid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_uid": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "core::option::Option::<T>::is_none": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`None`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_none(), false);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_none(), true);\n ```\n",
      "adt": {}
    },
    "core::ptr::null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a null raw pointer.\n\n This function is equivalent to zero-initializing the pointer:\n `MaybeUninit::<*const T>::zeroed().assume_init()`.\n The resulting pointer has the address 0.\n\n # Examples\n\n ```\n use std::ptr;\n\n let p: *const i32 = ptr::null();\n assert!(p.is_null());\n assert_eq!(p as usize, 0); // this pointer has the address 0\n ```\n",
      "adt": {}
    },
    "io::error::Error::raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS error that this error represents (if any).\n\n If this [`Error`] was constructed via [`last_os_error`] or\n [`from_raw_os_error`], then this function will return [`Some`], otherwise\n it will return [`None`].\n\n [`last_os_error`]: Error::last_os_error\n [`from_raw_os_error`]: Error::from_raw_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_os_error(err: &Error) {\n     if let Some(raw_os_err) = err.raw_os_error() {\n         println!(\"raw OS error: {raw_os_err:?}\");\n     } else {\n         println!(\"Not an OS error\");\n     }\n }\n\n fn main() {\n     // Will print \"raw OS error: ...\".\n     print_os_error(&Error::last_os_error());\n     // Will print \"Not an OS error\".\n     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "core::option::Option": "Constructor",
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "libc::setuid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_chroot": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "core::ffi::CStr::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the inner pointer to this C string.\n\n The returned pointer will be valid for as long as `self` is, and points\n to a contiguous region of memory terminated with a 0 byte to represent\n the end of the string.\n\n The type of the returned pointer is\n [`*const c_char`][crate::ffi::c_char], and whether it's\n an alias for `*const i8` or `*const u8` is platform-specific.\n\n **WARNING**\n\n The returned pointer is read-only; writing to it (including passing it\n to C code that writes to it) causes undefined behavior.\n\n It is your responsibility to make sure that the underlying memory is not\n freed too early. For example, the following code will cause undefined\n behavior when `ptr` is used inside the `unsafe` block:\n\n ```no_run\n # #![expect(dangling_pointers_from_temporaries)]\n use std::ffi::{CStr, CString};\n\n // üíÄ The meaning of this entire program is undefined,\n // üíÄ and nothing about its behavior is guaranteed,\n // üíÄ not even that its behavior resembles the code as written,\n // üíÄ just because it contains a single instance of undefined behavior!\n\n // üö® creates a dangling pointer to a temporary `CString`\n // üö® that is deallocated at the end of the statement\n let ptr = CString::new(\"Hi!\".to_uppercase()).unwrap().as_ptr();\n\n // without undefined behavior, you would expect that `ptr` equals:\n dbg!(CStr::from_bytes_with_nul(b\"HI!\\0\").unwrap());\n\n // üôè Possibly the program behaved as expected so far,\n // üôè and this just shows `ptr` is now garbage..., but\n // üíÄ this violates `CStr::from_ptr`'s safety contract\n // üíÄ leading to a dereference of a dangling pointer,\n // üíÄ which is immediate undefined behavior.\n // üíÄ *BOOM*, you're dead, your entire program has no meaning.\n dbg!(unsafe { CStr::from_ptr(ptr) });\n ```\n\n This happens because, the pointer returned by `as_ptr` does not carry any\n lifetime information, and the `CString` is deallocated immediately after\n the expression that it is part of has been evaluated.\n To fix the problem, bind the `CString` to a local variable:\n\n ```\n use std::ffi::{CStr, CString};\n\n let c_str = CString::new(\"Hi!\".to_uppercase()).unwrap();\n let ptr = c_str.as_ptr();\n\n assert_eq!(unsafe { CStr::from_ptr(ptr) }, c\"HI!\");\n ```\n",
      "adt": {}
    },
    "libc::chroot": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_cwd": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "libc::chdir": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_pgroup": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "libc::setpgid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_setsid": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "libc::setsid": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::on_broken_pipe_flag_used": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::signal": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "sys::process::unix::common::Command::get_closures": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "sys::env::unix::environ": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::cstring_array::CStringArray::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pointer to the C-string array managed by this type.\n",
      "adt": {
        "sys::process::unix::common::cstring_array::CStringArray": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::common::Command::get_program_cstr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::common::Command::get_argv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "libc::execvp": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "sys::process::unix::common::ChildStdio": [
      "Ref"
    ],
    "sys::process::unix::common::ChildPipes": [
      "Unknown([Field(0, Ty { id: 16777, kind: RigidTy(Adt(AdtDef(DefId { id: 12177, name: \"sys::process::unix::common::ChildStdio\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 16777, kind: RigidTy(Adt(AdtDef(DefId { id: 12177, name: \"sys::process::unix::common::ChildStdio\" }), GenericArgs([]))) })])",
      "Unknown([Field(2, Ty { id: 16777, kind: RigidTy(Adt(AdtDef(DefId { id: 12177, name: \"sys::process::unix::common::ChildStdio\" }), GenericArgs([]))) })])",
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8762, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 8763, kind: RigidTy(Slice(Ty { id: 608, kind: RigidTy(Uint(U32)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 774, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 779, kind: RigidTy(Adt(AdtDef(DefId { id: 4692, name: \"core::ffi::CStr\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 16971, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 8771, kind: RigidTy(Adt(AdtDef(DefId { id: 4386, name: \"alloc_crate::boxed::Box\" }), GenericArgs([Type(Ty { id: 8773, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 4936, name: \"core::ops::FnMut\" }), generic_args: GenericArgs([Type(Ty { id: 1, kind: RigidTy(Tuple([])) })]) }), bound_vars: [] }, Binder { value: Projection(ExistentialProjection { def_id: TraitDef(DefId { id: 4410, name: \"core::ops::FnOnce::Output\" }), generic_args: GenericArgs([Type(Ty { id: 1, kind: RigidTy(Tuple([])) })]), term: Type(Ty { id: 14, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 1, kind: RigidTy(Tuple([])) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) }) }), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4411, name: \"core::marker::Sync\" })), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4634, name: \"core::marker::Send\" })), bound_vars: [] }], Region { kind: ReErased })) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 16654, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 16632, kind: RigidTy(Adt(AdtDef(DefId { id: 12131, name: \"sys::process::unix::common::cstring_array::CStringArray\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "sys::process::unix::common::Command": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "io::error::Error": [
      "Plain",
      "Ref"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ],
    "core::slice::IterMut": [
      "Plain",
      "MutRef"
    ],
    "alloc_crate::boxed::Box": [
      "MutRef"
    ],
    "sys::process::unix::common::cstring_array::CStringArray": [
      "Ref"
    ],
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec::Reset": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:278:5: 410:6",
  "src": "unsafe fn do_exec(\n        &mut self,\n        stdio: ChildPipes,\n        maybe_envp: Option<&CStringArray>,\n    ) -> Result<!, io::Error> {\n        use crate::sys::{self, cvt_r};\n\n        if let Some(fd) = stdio.stdin.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO))?;\n        }\n        if let Some(fd) = stdio.stdout.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO))?;\n        }\n        if let Some(fd) = stdio.stderr.fd() {\n            cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO))?;\n        }\n\n        #[cfg(not(target_os = \"l4re\"))]\n        {\n            if let Some(_g) = self.get_groups() {\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                cvt(libc::setgroups(_g.len().try_into().unwrap(), _g.as_ptr()))?;\n            }\n            if let Some(u) = self.get_gid() {\n                cvt(libc::setgid(u as gid_t))?;\n            }\n            if let Some(u) = self.get_uid() {\n                // When dropping privileges from root, the `setgroups` call\n                // will remove any extraneous groups. We only drop groups\n                // if we have CAP_SETGID and we weren't given an explicit\n                // set of groups. If we don't call this, then even though our\n                // uid has dropped, we may still have groups that enable us to\n                // do super-user things.\n                //FIXME: Redox kernel does not support setgroups yet\n                #[cfg(not(target_os = \"redox\"))]\n                if self.get_groups().is_none() {\n                    let res = cvt(libc::setgroups(0, crate::ptr::null()));\n                    if let Err(e) = res {\n                        // Here we ignore the case of not having CAP_SETGID.\n                        // An alternative would be to require CAP_SETGID (in\n                        // addition to CAP_SETUID) for setting the UID.\n                        if e.raw_os_error() != Some(libc::EPERM) {\n                            return Err(e.into());\n                        }\n                    }\n                }\n                cvt(libc::setuid(u as uid_t))?;\n            }\n        }\n        if let Some(chroot) = self.get_chroot() {\n            #[cfg(not(target_os = \"fuchsia\"))]\n            cvt(libc::chroot(chroot.as_ptr()))?;\n            #[cfg(target_os = \"fuchsia\")]\n            return Err(io::const_error!(\n                io::ErrorKind::Unsupported,\n                \"chroot not supported by fuchsia\"\n            ));\n        }\n        if let Some(cwd) = self.get_cwd() {\n            cvt(libc::chdir(cwd.as_ptr()))?;\n        }\n\n        if let Some(pgroup) = self.get_pgroup() {\n            cvt(libc::setpgid(0, pgroup))?;\n        }\n\n        if self.get_setsid() {\n            cvt(libc::setsid())?;\n        }\n\n        // emscripten has no signal support.\n        #[cfg(not(target_os = \"emscripten\"))]\n        {\n            // Inherit the signal mask from the parent rather than resetting it (i.e. do not call\n            // pthread_sigmask).\n\n            // If -Zon-broken-pipe is used, don't reset SIGPIPE to SIG_DFL.\n            // If -Zon-broken-pipe is not used, reset SIGPIPE to SIG_DFL for backward compatibility.\n            //\n            // -Zon-broken-pipe is an opportunity to change the default here.\n            if !crate::sys::pal::on_broken_pipe_flag_used() {\n                #[cfg(target_os = \"android\")] // see issue #88585\n                {\n                    let mut action: libc::sigaction = mem::zeroed();\n                    action.sa_sigaction = libc::SIG_DFL;\n                    cvt(libc::sigaction(libc::SIGPIPE, &action, crate::ptr::null_mut()))?;\n                }\n                #[cfg(not(target_os = \"android\"))]\n                {\n                    let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n                    if ret == libc::SIG_ERR {\n                        return Err(io::Error::last_os_error());\n                    }\n                }\n                #[cfg(target_os = \"hurd\")]\n                {\n                    let ret = sys::signal(libc::SIGLOST, libc::SIG_DFL);\n                    if ret == libc::SIG_ERR {\n                        return Err(io::Error::last_os_error());\n                    }\n                }\n            }\n        }\n\n        for callback in self.get_closures().iter_mut() {\n            callback()?;\n        }\n\n        // Although we're performing an exec here we may also return with an\n        // error from this function (without actually exec'ing) in which case we\n        // want to be sure to restore the global environment back to what it\n        // once was, ensuring that our temporary override, when free'd, doesn't\n        // corrupt our process's environment.\n        let mut _reset = None;\n        if let Some(envp) = maybe_envp {\n            struct Reset(*const *const libc::c_char);\n\n            impl Drop for Reset {\n                fn drop(&mut self) {\n                    unsafe {\n                        *sys::env::environ() = self.0;\n                    }\n                }\n            }\n\n            _reset = Some(Reset(*sys::env::environ()));\n            *sys::env::environ() = envp.as_ptr();\n        }\n\n        libc::execvp(self.get_program_cstr().as_ptr(), self.get_argv().as_ptr());\n        Err(io::Error::last_os_error())\n    }",
  "mir": "fn sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec(_1: &mut sys::process::unix::common::Command, _2: sys::process::unix::common::ChildPipes, _3: core::option::Option<&sys::process::unix::common::cstring_array::CStringArray>) -> core::result::Result<!, io::error::Error> {\n    let mut _0: core::result::Result<!, io::error::Error>;\n    let mut _4: core::option::Option<i32>;\n    let mut _5: &sys::process::unix::common::ChildStdio;\n    let mut _6: isize;\n    let  _7: i32;\n    let mut _8: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _9: core::result::Result<i32, io::error::Error>;\n    let mut _10: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:286:19: 286:21};\n    let mut _11: &i32;\n    let mut _12: isize;\n    let  _13: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _14: i32;\n    let mut _15: core::option::Option<i32>;\n    let mut _16: &sys::process::unix::common::ChildStdio;\n    let mut _17: isize;\n    let  _18: i32;\n    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _20: core::result::Result<i32, io::error::Error>;\n    let mut _21: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:289:19: 289:21};\n    let mut _22: &i32;\n    let mut _23: isize;\n    let  _24: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _25: i32;\n    let mut _26: core::option::Option<i32>;\n    let mut _27: &sys::process::unix::common::ChildStdio;\n    let mut _28: isize;\n    let  _29: i32;\n    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _31: core::result::Result<i32, io::error::Error>;\n    let mut _32: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:292:19: 292:21};\n    let mut _33: &i32;\n    let mut _34: isize;\n    let  _35: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _36: i32;\n    let mut _37: core::option::Option<&[u32]>;\n    let mut _38: &sys::process::unix::common::Command;\n    let mut _39: isize;\n    let  _40: &[u32];\n    let mut _41: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _42: core::result::Result<i32, io::error::Error>;\n    let mut _43: i32;\n    let mut _44: usize;\n    let mut _45: core::result::Result<usize, core::convert::Infallible>;\n    let mut _46: usize;\n    let mut _47: *const u32;\n    let mut _48: isize;\n    let  _49: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _50: i32;\n    let mut _51: core::option::Option<u32>;\n    let mut _52: &sys::process::unix::common::Command;\n    let mut _53: isize;\n    let  _54: u32;\n    let mut _55: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _56: core::result::Result<i32, io::error::Error>;\n    let mut _57: i32;\n    let mut _58: isize;\n    let  _59: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _60: i32;\n    let mut _61: core::option::Option<u32>;\n    let mut _62: &sys::process::unix::common::Command;\n    let mut _63: isize;\n    let  _64: u32;\n    let mut _65: bool;\n    let mut _66: &core::option::Option<&[u32]>;\n    let  _67: core::option::Option<&[u32]>;\n    let mut _68: &sys::process::unix::common::Command;\n    let  _69: core::result::Result<i32, io::error::Error>;\n    let mut _70: i32;\n    let mut _71: *const u32;\n    let mut _72: isize;\n    let  _73: io::error::Error;\n    let mut _74: bool;\n    let mut _75: &core::option::Option<i32>;\n    let  _76: core::option::Option<i32>;\n    let mut _77: &io::error::Error;\n    let mut _78: &core::option::Option<i32>;\n    let mut _79: io::error::Error;\n    let mut _80: io::error::Error;\n    let mut _81: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _82: core::result::Result<i32, io::error::Error>;\n    let mut _83: i32;\n    let mut _84: isize;\n    let  _85: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _86: i32;\n    let mut _87: core::option::Option<&core::ffi::CStr>;\n    let mut _88: &sys::process::unix::common::Command;\n    let mut _89: isize;\n    let  _90: &core::ffi::CStr;\n    let mut _91: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _92: core::result::Result<i32, io::error::Error>;\n    let mut _93: i32;\n    let mut _94: *const u8;\n    let mut _95: isize;\n    let  _96: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _97: i32;\n    let mut _98: core::option::Option<&core::ffi::CStr>;\n    let mut _99: &sys::process::unix::common::Command;\n    let mut _100: isize;\n    let  _101: &core::ffi::CStr;\n    let mut _102: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _103: core::result::Result<i32, io::error::Error>;\n    let mut _104: i32;\n    let mut _105: *const u8;\n    let mut _106: isize;\n    let  _107: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _108: i32;\n    let mut _109: core::option::Option<i32>;\n    let mut _110: &sys::process::unix::common::Command;\n    let mut _111: isize;\n    let  _112: i32;\n    let mut _113: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _114: core::result::Result<i32, io::error::Error>;\n    let mut _115: i32;\n    let mut _116: isize;\n    let  _117: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _118: i32;\n    let mut _119: bool;\n    let mut _120: &sys::process::unix::common::Command;\n    let mut _121: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _122: core::result::Result<i32, io::error::Error>;\n    let mut _123: i32;\n    let mut _124: isize;\n    let  _125: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _126: i32;\n    let mut _127: bool;\n    let  _128: usize;\n    let mut _129: bool;\n    let mut _130: io::error::Error;\n    let mut _131: core::slice::IterMut<'_, alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _132: core::slice::IterMut<'_, alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _133: &mut [alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>];\n    let mut _134: &mut alloc_crate::vec::Vec<alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _135: core::slice::IterMut<'_, alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _136: core::option::Option<&mut alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _137: &mut core::slice::IterMut<'_, alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _138: isize;\n    let  _139: &mut alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>;\n    let mut _140: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _141: core::result::Result<(), io::error::Error>;\n    let mut _142: isize;\n    let  _143: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _144: core::option::Option<sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec::Reset>;\n    let mut _145: isize;\n    let  _146: &sys::process::unix::common::cstring_array::CStringArray;\n    let mut _147: core::option::Option<sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec::Reset>;\n    let mut _148: sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec::Reset;\n    let mut _149: *const *const u8;\n    let mut _150: *mut *const *const u8;\n    let mut _151: *const *const u8;\n    let mut _152: *mut *const *const u8;\n    let  _153: i32;\n    let mut _154: *const u8;\n    let  _155: &core::ffi::CStr;\n    let mut _156: &sys::process::unix::common::Command;\n    let mut _157: *const *const u8;\n    let  _158: &sys::process::unix::common::cstring_array::CStringArray;\n    let mut _159: &sys::process::unix::common::Command;\n    let mut _160: io::error::Error;\n    let mut _161: *const ();\n    let mut _162: usize;\n    let mut _163: usize;\n    let mut _164: usize;\n    let mut _165: bool;\n    let mut _166: *const ();\n    let mut _167: usize;\n    let mut _168: usize;\n    let mut _169: usize;\n    let mut _170: bool;\n    let mut _171: *const ();\n    let mut _172: usize;\n    let mut _173: bool;\n    let mut _174: bool;\n    let mut _175: bool;\n    let mut _176: bool;\n    let mut _177: *const ();\n    let mut _178: usize;\n    let mut _179: bool;\n    let mut _180: bool;\n    let mut _181: bool;\n    let mut _182: bool;\n    debug self => _1;\n    debug stdio => _2;\n    debug maybe_envp => _3;\n    debug fd => _7;\n    debug residual => _13;\n    debug val => _14;\n    debug fd => _18;\n    debug residual => _24;\n    debug val => _25;\n    debug fd => _29;\n    debug residual => _35;\n    debug val => _36;\n    debug _g => _40;\n    debug residual => _49;\n    debug val => _50;\n    debug u => _54;\n    debug residual => _59;\n    debug val => _60;\n    debug u => _64;\n    debug res => _69;\n    debug e => _73;\n    debug residual => _85;\n    debug val => _86;\n    debug chroot => _90;\n    debug residual => _96;\n    debug val => _97;\n    debug cwd => _101;\n    debug residual => _107;\n    debug val => _108;\n    debug pgroup => _112;\n    debug residual => _117;\n    debug val => _118;\n    debug residual => _125;\n    debug val => _126;\n    debug ret => _128;\n    debug iter => _135;\n    debug callback => _139;\n    debug residual => _143;\n    debug val => ();\n    debug _reset => _144;\n    debug envp => _146;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &(_2.0: sys::process::unix::common::ChildStdio);\n        _4 = sys::process::unix::common::ChildStdio::fd(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [1: bb2, 0: bb9, otherwise: bb5];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = ((_4 as variant#1).0: i32);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_7;\n        _10 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:286:19: 286:21}(move _11);\n        StorageDead(_11);\n        _9 = sys::pal::unix::cvt_r::<i32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:286:19: 286:21}>(move _10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_10);\n        _8 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        _12 = discriminant(_8);\n        switchInt(move _12) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_14);\n        _14 = ((_8 as variant#0).0: i32);\n        StorageDead(_14);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb7: {\n        _13 = move ((_8 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb153;\n    }\n    bb9: {\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &(_2.1: sys::process::unix::common::ChildStdio);\n        _15 = sys::process::unix::common::ChildStdio::fd(move _16) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        _17 = discriminant(_15);\n        switchInt(move _17) -> [1: bb12, 0: bb18, otherwise: bb5];\n    }\n    bb12: {\n        StorageLive(_18);\n        _18 = ((_15 as variant#1).0: i32);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_18;\n        _21 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:289:19: 289:21}(move _22);\n        StorageDead(_22);\n        _20 = sys::pal::unix::cvt_r::<i32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:289:19: 289:21}>(move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        _19 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_20);\n        _23 = discriminant(_19);\n        switchInt(move _23) -> [0: bb15, 1: bb16, otherwise: bb5];\n    }\n    bb15: {\n        StorageLive(_25);\n        _25 = ((_19 as variant#0).0: i32);\n        StorageDead(_25);\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_15);\n        goto -> bb19;\n    }\n    bb16: {\n        _24 = move ((_19 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_24) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_19);\n        StorageDead(_18);\n        StorageDead(_15);\n        goto -> bb153;\n    }\n    bb18: {\n        StorageDead(_15);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &(_2.2: sys::process::unix::common::ChildStdio);\n        _26 = sys::process::unix::common::ChildStdio::fd(move _27) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_27);\n        _28 = discriminant(_26);\n        switchInt(move _28) -> [1: bb21, 0: bb27, otherwise: bb5];\n    }\n    bb21: {\n        StorageLive(_29);\n        _29 = ((_26 as variant#1).0: i32);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &_29;\n        _32 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:292:19: 292:21}(move _33);\n        StorageDead(_33);\n        _31 = sys::pal::unix::cvt_r::<i32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:292:19: 292:21}>(move _32) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_32);\n        _30 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _31) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_31);\n        _34 = discriminant(_30);\n        switchInt(move _34) -> [0: bb24, 1: bb25, otherwise: bb5];\n    }\n    bb24: {\n        StorageLive(_36);\n        _36 = ((_30 as variant#0).0: i32);\n        StorageDead(_36);\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_26);\n        goto -> bb28;\n    }\n    bb25: {\n        _35 = move ((_30 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_26);\n        goto -> bb153;\n    }\n    bb27: {\n        StorageDead(_26);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &(*_1);\n        _37 = sys::process::unix::common::Command::get_groups(move _38) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_38);\n        _39 = discriminant(_37);\n        switchInt(move _39) -> [1: bb30, 0: bb40, otherwise: bb5];\n    }\n    bb30: {\n        _40 = ((_37 as variant#1).0: &[u32]);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        StorageLive(_46);\n        _46 = PtrMetadata(_40);\n        _45 = <usize as core::convert::TryInto<usize>>::try_into(move _46) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_46);\n        _44 = core::result::Result::<usize, core::convert::Infallible>::unwrap(move _45) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_45);\n        StorageLive(_47);\n        _47 = core::slice::<impl [u32]>::as_ptr(_40) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        _43 = libc::setgroups(move _44, move _47) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_47);\n        StorageDead(_44);\n        _42 = sys::pal::unix::cvt::<i32>(move _43) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_43);\n        _41 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _42) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_42);\n        _48 = discriminant(_41);\n        switchInt(move _48) -> [0: bb37, 1: bb38, otherwise: bb5];\n    }\n    bb37: {\n        StorageLive(_50);\n        _50 = ((_41 as variant#0).0: i32);\n        StorageDead(_50);\n        StorageDead(_41);\n        StorageDead(_37);\n        goto -> bb41;\n    }\n    bb38: {\n        _49 = move ((_41 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_49) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        StorageDead(_41);\n        StorageDead(_37);\n        goto -> bb153;\n    }\n    bb40: {\n        StorageDead(_37);\n        goto -> bb41;\n    }\n    bb41: {\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &(*_1);\n        _51 = sys::process::unix::common::Command::get_gid(move _52) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_52);\n        _53 = discriminant(_51);\n        switchInt(move _53) -> [1: bb43, 0: bb50, otherwise: bb5];\n    }\n    bb43: {\n        _54 = ((_51 as variant#1).0: u32);\n        StorageLive(_55);\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = libc::setgid(_54) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _56 = sys::pal::unix::cvt::<i32>(move _57) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_57);\n        _55 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _56) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_56);\n        _58 = discriminant(_55);\n        switchInt(move _58) -> [0: bb47, 1: bb48, otherwise: bb5];\n    }\n    bb47: {\n        StorageLive(_60);\n        _60 = ((_55 as variant#0).0: i32);\n        StorageDead(_60);\n        StorageDead(_55);\n        StorageDead(_51);\n        goto -> bb51;\n    }\n    bb48: {\n        _59 = move ((_55 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_59) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_55);\n        StorageDead(_51);\n        goto -> bb153;\n    }\n    bb50: {\n        StorageDead(_51);\n        goto -> bb51;\n    }\n    bb51: {\n        StorageLive(_61);\n        StorageLive(_62);\n        _62 = &(*_1);\n        _61 = sys::process::unix::common::Command::get_uid(move _62) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_62);\n        _63 = discriminant(_61);\n        switchInt(move _63) -> [1: bb53, 0: bb75, otherwise: bb5];\n    }\n    bb53: {\n        _64 = ((_61 as variant#1).0: u32);\n        StorageLive(_65);\n        StorageLive(_66);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = &(*_1);\n        _67 = sys::process::unix::common::Command::get_groups(move _68) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        _66 = &_67;\n        StorageDead(_68);\n        _65 = core::option::Option::<&[u32]>::is_none(move _66) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        switchInt(move _65) -> [0: bb67, otherwise: bb56];\n    }\n    bb56: {\n        StorageDead(_67);\n        StorageDead(_66);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = core::ptr::null::<u32>() -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        _70 = libc::setgroups(0_usize, move _71) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_71);\n        _69 = sys::pal::unix::cvt::<i32>(move _70) -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        StorageDead(_70);\n        _72 = discriminant(_69);\n        switchInt(move _72) -> [1: bb60, 0: bb155, otherwise: bb5];\n    }\n    bb60: {\n        StorageLive(_73);\n        _73 = move ((_69 as variant#1).0: io::error::Error);\n        StorageLive(_74);\n        StorageLive(_75);\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = &_73;\n        _76 = io::error::Error::raw_os_error(move _77) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        _75 = &_76;\n        StorageDead(_77);\n        StorageLive(_78);\n        _78 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec::promoted[0];\n        _74 = <core::option::Option<i32> as core::cmp::PartialEq>::ne(move _75, move _78) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        switchInt(move _74) -> [0: bb65, otherwise: bb63];\n    }\n    bb63: {\n        StorageDead(_78);\n        StorageDead(_76);\n        StorageDead(_75);\n        StorageLive(_79);\n        StorageLive(_80);\n        _80 = move _73;\n        _79 = <io::error::Error as core::convert::Into<io::error::Error>>::into(move _80) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_80);\n        _0 = core::result::Result::Err(move _79);\n        StorageDead(_79);\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageDead(_69);\n        StorageDead(_65);\n        goto -> bb152;\n    }\n    bb65: {\n        StorageDead(_78);\n        StorageDead(_76);\n        StorageDead(_75);\n        StorageDead(_74);\n        drop(_73) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_73);\n        goto -> bb155;\n    }\n    bb67: {\n        StorageDead(_67);\n        StorageDead(_66);\n        goto -> bb68;\n    }\n    bb68: {\n        StorageDead(_65);\n        StorageLive(_81);\n        StorageLive(_82);\n        StorageLive(_83);\n        _83 = libc::setuid(_64) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        _82 = sys::pal::unix::cvt::<i32>(move _83) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_83);\n        _81 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _82) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        StorageDead(_82);\n        _84 = discriminant(_81);\n        switchInt(move _84) -> [0: bb72, 1: bb73, otherwise: bb5];\n    }\n    bb72: {\n        StorageLive(_86);\n        _86 = ((_81 as variant#0).0: i32);\n        StorageDead(_86);\n        StorageDead(_81);\n        StorageDead(_61);\n        goto -> bb76;\n    }\n    bb73: {\n        _85 = move ((_81 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_85) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_81);\n        goto -> bb152;\n    }\n    bb75: {\n        StorageDead(_61);\n        goto -> bb76;\n    }\n    bb76: {\n        StorageLive(_87);\n        StorageLive(_88);\n        _88 = &(*_1);\n        _87 = sys::process::unix::common::Command::get_chroot(move _88) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_88);\n        _89 = discriminant(_87);\n        switchInt(move _89) -> [1: bb78, 0: bb86, otherwise: bb5];\n    }\n    bb78: {\n        _90 = ((_87 as variant#1).0: &core::ffi::CStr);\n        StorageLive(_91);\n        StorageLive(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        _94 = core::ffi::CStr::as_ptr(_90) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        _93 = libc::chroot(move _94) -> [return: bb80, unwind unreachable];\n    }\n    bb80: {\n        StorageDead(_94);\n        _92 = sys::pal::unix::cvt::<i32>(move _93) -> [return: bb81, unwind unreachable];\n    }\n    bb81: {\n        StorageDead(_93);\n        _91 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _92) -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        StorageDead(_92);\n        _95 = discriminant(_91);\n        switchInt(move _95) -> [0: bb83, 1: bb84, otherwise: bb5];\n    }\n    bb83: {\n        StorageLive(_97);\n        _97 = ((_91 as variant#0).0: i32);\n        StorageDead(_97);\n        StorageDead(_91);\n        StorageDead(_87);\n        goto -> bb87;\n    }\n    bb84: {\n        _96 = move ((_91 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_96) -> [return: bb85, unwind unreachable];\n    }\n    bb85: {\n        StorageDead(_91);\n        StorageDead(_87);\n        goto -> bb153;\n    }\n    bb86: {\n        StorageDead(_87);\n        goto -> bb87;\n    }\n    bb87: {\n        StorageLive(_98);\n        StorageLive(_99);\n        _99 = &(*_1);\n        _98 = sys::process::unix::common::Command::get_cwd(move _99) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        StorageDead(_99);\n        _100 = discriminant(_98);\n        switchInt(move _100) -> [1: bb89, 0: bb97, otherwise: bb5];\n    }\n    bb89: {\n        _101 = ((_98 as variant#1).0: &core::ffi::CStr);\n        StorageLive(_102);\n        StorageLive(_103);\n        StorageLive(_104);\n        StorageLive(_105);\n        _105 = core::ffi::CStr::as_ptr(_101) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        _104 = libc::chdir(move _105) -> [return: bb91, unwind unreachable];\n    }\n    bb91: {\n        StorageDead(_105);\n        _103 = sys::pal::unix::cvt::<i32>(move _104) -> [return: bb92, unwind unreachable];\n    }\n    bb92: {\n        StorageDead(_104);\n        _102 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _103) -> [return: bb93, unwind unreachable];\n    }\n    bb93: {\n        StorageDead(_103);\n        _106 = discriminant(_102);\n        switchInt(move _106) -> [0: bb94, 1: bb95, otherwise: bb5];\n    }\n    bb94: {\n        StorageLive(_108);\n        _108 = ((_102 as variant#0).0: i32);\n        StorageDead(_108);\n        StorageDead(_102);\n        StorageDead(_98);\n        goto -> bb98;\n    }\n    bb95: {\n        _107 = move ((_102 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_107) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        StorageDead(_102);\n        StorageDead(_98);\n        goto -> bb153;\n    }\n    bb97: {\n        StorageDead(_98);\n        goto -> bb98;\n    }\n    bb98: {\n        StorageLive(_109);\n        StorageLive(_110);\n        _110 = &(*_1);\n        _109 = sys::process::unix::common::Command::get_pgroup(move _110) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        StorageDead(_110);\n        _111 = discriminant(_109);\n        switchInt(move _111) -> [1: bb100, 0: bb107, otherwise: bb5];\n    }\n    bb100: {\n        _112 = ((_109 as variant#1).0: i32);\n        StorageLive(_113);\n        StorageLive(_114);\n        StorageLive(_115);\n        _115 = libc::setpgid(0_i32, _112) -> [return: bb101, unwind unreachable];\n    }\n    bb101: {\n        _114 = sys::pal::unix::cvt::<i32>(move _115) -> [return: bb102, unwind unreachable];\n    }\n    bb102: {\n        StorageDead(_115);\n        _113 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _114) -> [return: bb103, unwind unreachable];\n    }\n    bb103: {\n        StorageDead(_114);\n        _116 = discriminant(_113);\n        switchInt(move _116) -> [0: bb104, 1: bb105, otherwise: bb5];\n    }\n    bb104: {\n        StorageLive(_118);\n        _118 = ((_113 as variant#0).0: i32);\n        StorageDead(_118);\n        StorageDead(_113);\n        StorageDead(_109);\n        goto -> bb108;\n    }\n    bb105: {\n        _117 = move ((_113 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_117) -> [return: bb106, unwind unreachable];\n    }\n    bb106: {\n        StorageDead(_113);\n        StorageDead(_109);\n        goto -> bb153;\n    }\n    bb107: {\n        StorageDead(_109);\n        goto -> bb108;\n    }\n    bb108: {\n        StorageLive(_119);\n        StorageLive(_120);\n        _120 = &(*_1);\n        _119 = sys::process::unix::common::Command::get_setsid(move _120) -> [return: bb109, unwind unreachable];\n    }\n    bb109: {\n        switchInt(move _119) -> [0: bb117, otherwise: bb110];\n    }\n    bb110: {\n        StorageDead(_120);\n        StorageLive(_121);\n        StorageLive(_122);\n        StorageLive(_123);\n        _123 = libc::setsid() -> [return: bb111, unwind unreachable];\n    }\n    bb111: {\n        _122 = sys::pal::unix::cvt::<i32>(move _123) -> [return: bb112, unwind unreachable];\n    }\n    bb112: {\n        StorageDead(_123);\n        _121 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _122) -> [return: bb113, unwind unreachable];\n    }\n    bb113: {\n        StorageDead(_122);\n        _124 = discriminant(_121);\n        switchInt(move _124) -> [0: bb114, 1: bb115, otherwise: bb5];\n    }\n    bb114: {\n        StorageLive(_126);\n        _126 = ((_121 as variant#0).0: i32);\n        StorageDead(_126);\n        StorageDead(_121);\n        goto -> bb118;\n    }\n    bb115: {\n        _125 = move ((_121 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_125) -> [return: bb116, unwind unreachable];\n    }\n    bb116: {\n        StorageDead(_121);\n        StorageDead(_119);\n        goto -> bb153;\n    }\n    bb117: {\n        StorageDead(_120);\n        goto -> bb118;\n    }\n    bb118: {\n        StorageDead(_119);\n        StorageLive(_127);\n        _127 = sys::pal::unix::on_broken_pipe_flag_used() -> [return: bb119, unwind unreachable];\n    }\n    bb119: {\n        switchInt(move _127) -> [0: bb120, otherwise: bb125];\n    }\n    bb120: {\n        _128 = libc::signal(libc::SIGPIPE, libc::SIG_DFL) -> [return: bb121, unwind unreachable];\n    }\n    bb121: {\n        StorageLive(_129);\n        _129 = Eq(_128, libc::SIG_ERR);\n        switchInt(move _129) -> [0: bb124, otherwise: bb122];\n    }\n    bb122: {\n        StorageLive(_130);\n        _130 = io::error::Error::last_os_error() -> [return: bb123, unwind unreachable];\n    }\n    bb123: {\n        _0 = core::result::Result::Err(move _130);\n        StorageDead(_130);\n        StorageDead(_129);\n        StorageDead(_127);\n        goto -> bb153;\n    }\n    bb124: {\n        StorageDead(_129);\n        goto -> bb125;\n    }\n    bb125: {\n        StorageDead(_127);\n        StorageLive(_131);\n        StorageLive(_132);\n        _134 = sys::process::unix::common::Command::get_closures(_1) -> [return: bb126, unwind unreachable];\n    }\n    bb126: {\n        _133 = <alloc_crate::vec::Vec<alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>> as core::ops::DerefMut>::deref_mut(_134) -> [return: bb127, unwind unreachable];\n    }\n    bb127: {\n        _132 = core::slice::<impl [alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>]>::iter_mut(_133) -> [return: bb128, unwind unreachable];\n    }\n    bb128: {\n        _131 = <core::slice::IterMut<'_, alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>> as core::iter::IntoIterator>::into_iter(move _132) -> [return: bb129, unwind unreachable];\n    }\n    bb129: {\n        StorageDead(_132);\n        StorageLive(_135);\n        _135 = move _131;\n        goto -> bb130;\n    }\n    bb130: {\n        StorageLive(_136);\n        _137 = &mut _135;\n        _136 = <core::slice::IterMut<'_, alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>> as core::iter::Iterator>::next(_137) -> [return: bb131, unwind unreachable];\n    }\n    bb131: {\n        _138 = discriminant(_136);\n        switchInt(move _138) -> [0: bb133, 1: bb132, otherwise: bb5];\n    }\n    bb132: {\n        _139 = move ((_136 as variant#1).0: &mut alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>);\n        StorageLive(_140);\n        StorageLive(_141);\n        _141 = <alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync> as core::ops::FnMut<()>>::call_mut(_139, ()) -> [return: bb134, unwind unreachable];\n    }\n    bb133: {\n        StorageDead(_136);\n        StorageDead(_135);\n        StorageDead(_131);\n        StorageLive(_144);\n        _144 = core::option::Option::None;\n        _145 = discriminant(_3);\n        switchInt(move _145) -> [1: bb139, 0: bb144, otherwise: bb5];\n    }\n    bb134: {\n        _140 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _141) -> [return: bb135, unwind unreachable];\n    }\n    bb135: {\n        StorageDead(_141);\n        _142 = discriminant(_140);\n        switchInt(move _142) -> [0: bb136, 1: bb137, otherwise: bb5];\n    }\n    bb136: {\n        StorageDead(_140);\n        StorageDead(_136);\n        goto -> bb130;\n    }\n    bb137: {\n        _143 = move ((_140 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<!, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_143) -> [return: bb138, unwind unreachable];\n    }\n    bb138: {\n        StorageDead(_140);\n        StorageDead(_136);\n        StorageDead(_135);\n        StorageDead(_131);\n        goto -> bb153;\n    }\n    bb139: {\n        _146 = ((_3 as variant#1).0: &sys::process::unix::common::cstring_array::CStringArray);\n        StorageLive(_147);\n        StorageLive(_148);\n        StorageLive(_149);\n        StorageLive(_150);\n        _150 = sys::env::unix::environ() -> [return: bb140, unwind unreachable];\n    }\n    bb140: {\n        _166 = _150 as *const ();\n        _167 = _166 as usize;\n        _168 = Sub(<*const *const u8 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _169 = BitAnd(_167, _168);\n        _170 = Eq(_169, 0_usize);\n        assert(_170, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<*const *const u8 as core::mem::SizedTypeProperties>::ALIGN, _167) -> [success: bb157, unwind unreachable];\n    }\n    bb141: {\n        _144 = move _147;\n        StorageDead(_147);\n        StorageDead(_150);\n        StorageLive(_151);\n        _151 = sys::process::unix::common::cstring_array::CStringArray::as_ptr(_146) -> [return: bb142, unwind unreachable];\n    }\n    bb142: {\n        StorageLive(_152);\n        _152 = sys::env::unix::environ() -> [return: bb143, unwind unreachable];\n    }\n    bb143: {\n        _161 = _152 as *const ();\n        _162 = _161 as usize;\n        _163 = Sub(<*const *const u8 as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _164 = BitAnd(_162, _163);\n        _165 = Eq(_164, 0_usize);\n        assert(_165, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<*const *const u8 as core::mem::SizedTypeProperties>::ALIGN, _162) -> [success: bb156, unwind unreachable];\n    }\n    bb144: {\n        StorageLive(_153);\n        StorageLive(_154);\n        StorageLive(_156);\n        _156 = &(*_1);\n        _155 = sys::process::unix::common::Command::get_program_cstr(move _156) -> [return: bb145, unwind unreachable];\n    }\n    bb145: {\n        StorageDead(_156);\n        _154 = core::ffi::CStr::as_ptr(_155) -> [return: bb146, unwind unreachable];\n    }\n    bb146: {\n        StorageLive(_157);\n        StorageLive(_159);\n        _159 = &(*_1);\n        _158 = sys::process::unix::common::Command::get_argv(move _159) -> [return: bb147, unwind unreachable];\n    }\n    bb147: {\n        StorageDead(_159);\n        _157 = sys::process::unix::common::cstring_array::CStringArray::as_ptr(_158) -> [return: bb148, unwind unreachable];\n    }\n    bb148: {\n        _153 = libc::execvp(move _154, move _157) -> [return: bb149, unwind unreachable];\n    }\n    bb149: {\n        StorageDead(_157);\n        StorageDead(_154);\n        StorageDead(_153);\n        StorageLive(_160);\n        _160 = io::error::Error::last_os_error() -> [return: bb150, unwind unreachable];\n    }\n    bb150: {\n        _0 = core::result::Result::Err(move _160);\n        StorageDead(_160);\n        drop(_144) -> [return: bb151, unwind unreachable];\n    }\n    bb151: {\n        StorageDead(_144);\n        drop(_2) -> [return: bb154, unwind unreachable];\n    }\n    bb152: {\n        StorageDead(_61);\n        goto -> bb153;\n    }\n    bb153: {\n        drop(_2) -> [return: bb154, unwind unreachable];\n    }\n    bb154: {\n        return;\n    }\n    bb155: {\n        StorageDead(_69);\n        goto -> bb68;\n    }\n    bb156: {\n        _177 = _152 as *const ();\n        _178 = _177 as usize;\n        _179 = Ne(<*const *const u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _180 = Eq(_178, 0_usize);\n        _181 = BitAnd(_180, _179);\n        _182 = Not(_181);\n        assert(_182, \"null pointer dereference occurred\") -> [success: bb159, unwind unreachable];\n    }\n    bb157: {\n        _171 = _150 as *const ();\n        _172 = _171 as usize;\n        _173 = Ne(<*const *const u8 as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _174 = Eq(_172, 0_usize);\n        _175 = BitAnd(_174, _173);\n        _176 = Not(_175);\n        assert(_176, \"null pointer dereference occurred\") -> [success: bb158, unwind unreachable];\n    }\n    bb158: {\n        _149 = (*_150);\n        _148 = Reset(move _149);\n        StorageDead(_149);\n        _147 = core::option::Option::Some(move _148);\n        StorageDead(_148);\n        drop(_144) -> [return: bb141, unwind unreachable];\n    }\n    bb159: {\n        (*_152) = move _151;\n        StorageDead(_151);\n        StorageDead(_152);\n        goto -> bb144;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}