{
  "name": "path::PathBuf::_set_extension",
  "safe": true,
  "callees": {
    "path::validate_extension": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the string is valid as a file extension, or panics otherwise.\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "path::Path::file_stem": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the stem (non-extension) portion of [`self.file_name`].\n\n [`self.file_name`]: Path::file_name\n\n The stem is:\n\n * [`None`], if there is no file name;\n * The entire file name if there is no embedded `.`;\n * The entire file name if the file name begins with `.` and has no other `.`s within;\n * Otherwise, the portion of the file name before the final `.`\n\n # Examples\n\n ```\n use std::path::Path;\n\n assert_eq!(\"foo\", Path::new(\"foo.rs\").file_stem().unwrap());\n assert_eq!(\"foo.tar\", Path::new(\"foo.tar.gz\").file_stem().unwrap());\n ```\n\n # See Also\n This method is similar to [`Path::file_prefix`], which extracts the portion of the file name\n before the *first* `.`\n\n [`Path::file_prefix`]: Path::file_prefix\n\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "ffi::os_str::OsStr::as_encoded_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n string slice, use the [`OsStr::from_encoded_bytes_unchecked`] function.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n be treated as opaque and only comparable within the same Rust version built for the same\n target platform.  For example, sending the slice over the network or storing it in a file\n will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n and [`std::ffi`] for platform-specific, specified conversions.\n\n [`std::ffi`]: crate::ffi\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::ptr::const_ptr::<impl *const T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::num::<impl usize>::wrapping_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) subtraction. Computes `self - rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "ffi::os_str::OsString::truncate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Truncate the `OsString` to the specified length.\n\n # Panics\n Panics if `len` does not lie on a valid `OsStr` boundary\n (as described in [`OsStr::slice_encoded_bytes`]).\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "ffi::os_str::OsString::reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reserves the minimum capacity for at least `additional` more capacity to\n be inserted in the given `OsString`. Does nothing if the capacity is\n already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`reserve`] if future insertions are expected.\n\n [`reserve`]: OsString::reserve\n\n See the main `OsString` documentation information about encoding and capacity units.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut s = OsString::new();\n s.reserve_exact(10);\n assert!(s.capacity() >= 10);\n ```\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "ffi::os_str::OsString::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends the string with the given <code>&[OsStr]</code> slice.\n\n # Examples\n\n ```\n use std::ffi::OsString;\n\n let mut os_string = OsString::from(\"foo\");\n os_string.push(\"bar\");\n assert_eq!(&os_string, \"foobar\");\n ```\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    },
    "ffi::os_str::OsString::extend_from_slice_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Provides plumbing to `Vec::extend_from_slice` without giving full\n mutable access to the `Vec`.\n\n # Safety\n\n The slice must be valid for the platform encoding (as described in\n [`OsStr::from_encoded_bytes_unchecked`]).\n\n This bypasses the encoding-dependent surrogate joining, so either\n `self` must not end with a leading surrogate half, or `other` must not\n start with a trailing surrogate half.\n",
      "adt": {
        "ffi::os_str::OsString": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "path::PathBuf": [
      "Ref",
      "Deref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2802, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2803, kind: RigidTy(Adt(AdtDef(DefId { id: 5587, name: \"ffi::os_str::OsStr\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "ffi::os_str::OsString": [
      "Ref",
      "MutRef"
    ]
  },
  "path": 2481,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:1633:5: 1657:6",
  "src": "fn _set_extension(&mut self, extension: &OsStr) -> bool {\n        validate_extension(extension);\n\n        let file_stem = match self.file_stem() {\n            None => return false,\n            Some(f) => f.as_encoded_bytes(),\n        };\n\n        // truncate until right after the file stem\n        let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n        let start = self.inner.as_encoded_bytes().as_ptr().addr();\n        self.inner.truncate(end_file_stem.wrapping_sub(start));\n\n        // add the new extension, if any\n        let new = extension.as_encoded_bytes();\n        if !new.is_empty() {\n            self.inner.reserve_exact(new.len() + 1);\n            self.inner.push(\".\");\n            // SAFETY: Since a UTF-8 string was just pushed, it is not possible\n            // for the buffer to end with a surrogate half.\n            unsafe { self.inner.extend_from_slice_unchecked(new) };\n        }\n\n        true\n    }",
  "mir": "fn path::PathBuf::_set_extension(_1: &mut path::PathBuf, _2: &ffi::os_str::OsStr) -> bool {\n    let mut _0: bool;\n    let  _3: ();\n    let  _4: &[u8];\n    let mut _5: core::option::Option<&ffi::os_str::OsStr>;\n    let  _6: &path::Path;\n    let mut _7: &path::PathBuf;\n    let mut _8: isize;\n    let  _9: &ffi::os_str::OsStr;\n    let  _10: usize;\n    let mut _11: *const u8;\n    let  _12: &[u8];\n    let mut _13: core::ops::RangeFrom<usize>;\n    let mut _14: usize;\n    let  _15: usize;\n    let mut _16: *const u8;\n    let  _17: &[u8];\n    let  _18: &ffi::os_str::OsStr;\n    let mut _19: &ffi::os_str::OsString;\n    let  _20: ();\n    let mut _21: &mut ffi::os_str::OsString;\n    let mut _22: usize;\n    let  _23: &[u8];\n    let mut _24: bool;\n    let  _25: ();\n    let mut _26: &mut ffi::os_str::OsString;\n    let mut _27: usize;\n    let mut _28: usize;\n    let mut _29: (usize, bool);\n    let  _30: ();\n    let mut _31: &mut ffi::os_str::OsString;\n    let  _32: ();\n    let mut _33: &mut ffi::os_str::OsString;\n    debug self => _1;\n    debug extension => _2;\n    debug file_stem => _4;\n    debug f => _9;\n    debug end_file_stem => _10;\n    debug start => _15;\n    debug new => _23;\n    bb0: {\n        _3 = path::validate_extension(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = <path::PathBuf as core::ops::Deref>::deref(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = path::Path::file_stem(_6) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [0: bb6, 1: bb5, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        _9 = ((_5 as variant#1).0: &ffi::os_str::OsStr);\n        _4 = ffi::os_str::OsStr::as_encoded_bytes(_9) -> [return: bb7, unwind unreachable];\n    }\n    bb6: {\n        _0 = false;\n        StorageDead(_5);\n        goto -> bb26;\n    }\n    bb7: {\n        StorageDead(_5);\n        StorageLive(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = PtrMetadata(_4);\n        _13 = RangeFrom(move _14);\n        StorageDead(_14);\n        _12 = <[u8] as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_4, move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        _11 = core::slice::<impl [u8]>::as_ptr(_12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _10 = core::ptr::const_ptr::<impl *const u8>::addr(move _11) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_11);\n        StorageLive(_16);\n        StorageLive(_19);\n        _19 = &((*_1).0: ffi::os_str::OsString);\n        _18 = <ffi::os_str::OsString as core::ops::Deref>::deref(move _19) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        _17 = ffi::os_str::OsStr::as_encoded_bytes(_18) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _16 = core::slice::<impl [u8]>::as_ptr(_17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _15 = core::ptr::const_ptr::<impl *const u8>::addr(move _16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_16);\n        StorageLive(_21);\n        _21 = &mut ((*_1).0: ffi::os_str::OsString);\n        StorageLive(_22);\n        _22 = core::num::<impl usize>::wrapping_sub(_10, _15) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20 = ffi::os_str::OsString::truncate(move _21, move _22) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        _23 = ffi::os_str::OsStr::as_encoded_bytes(_2) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageLive(_24);\n        _24 = core::slice::<impl [u8]>::is_empty(_23) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        switchInt(move _24) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        goto -> bb25;\n    }\n    bb20: {\n        StorageLive(_26);\n        _26 = &mut ((*_1).0: ffi::os_str::OsString);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = PtrMetadata(_23);\n        _29 = CheckedAdd(_28, 1_usize);\n        assert(!move (_29.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _28, 1_usize) -> [success: bb21, unwind unreachable];\n    }\n    bb21: {\n        _27 = move (_29.0: usize);\n        StorageDead(_28);\n        _25 = ffi::os_str::OsString::reserve_exact(move _26, move _27) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageLive(_31);\n        _31 = &mut ((*_1).0: ffi::os_str::OsString);\n        _30 = ffi::os_str::OsString::push::<&str>(move _31, \".\") -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_31);\n        StorageLive(_33);\n        _33 = &mut ((*_1).0: ffi::os_str::OsString);\n        _32 = ffi::os_str::OsString::extend_from_slice_unchecked(move _33, _23) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_33);\n        goto -> bb25;\n    }\n    bb25: {\n        StorageDead(_24);\n        _0 = true;\n        goto -> bb26;\n    }\n    bb26: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}