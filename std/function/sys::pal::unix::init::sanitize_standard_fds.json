{
  "name": "sys::pal::unix::init::sanitize_standard_fds",
  "safe": false,
  "callees": {
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "libc::poll": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::os::errno": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the platform-specific value of errno\n",
      "adt": {}
    },
    "libc::abort": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "libc::fcntl": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "libc::pollfd": [
      "Plain",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::ops::Range": [
      "Plain",
      "MutRef"
    ],
    "core::slice::IterMut": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 15287, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 15025, kind: RigidTy(Adt(AdtDef(DefId { id: 11401, name: \"libc::pollfd\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::pal::unix::init::sanitize_standard_fds"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:55:5: 146:6",
  "src": "unsafe fn sanitize_standard_fds() {\n        #[allow(dead_code, unused_variables, unused_mut)]\n        let mut opened_devnull = -1;\n        #[allow(dead_code, unused_variables, unused_mut)]\n        let mut open_devnull = || {\n            #[cfg(not(all(target_os = \"linux\", target_env = \"gnu\")))]\n            use libc::open;\n            #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n            use libc::open64 as open;\n\n            if opened_devnull != -1 {\n                if libc::dup(opened_devnull) != -1 {\n                    return;\n                }\n            }\n            opened_devnull = open(c\"/dev/null\".as_ptr(), libc::O_RDWR, 0);\n            if opened_devnull == -1 {\n                // If the stream is closed but we failed to reopen it, abort the\n                // process. Otherwise we wouldn't preserve the safety of\n                // operations on the corresponding Rust object Stdin, Stdout, or\n                // Stderr.\n                libc::abort();\n            }\n        };\n\n        // fast path with a single syscall for systems with poll()\n        #[cfg(not(any(\n            miri,\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"vxworks\",\n            target_os = \"redox\",\n            target_os = \"l4re\",\n            target_os = \"horizon\",\n            target_os = \"vita\",\n            target_os = \"rtems\",\n            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n            target_vendor = \"apple\",\n        )))]\n        'poll: {\n            use crate::sys::os::errno;\n            let pfds: &mut [_] = &mut [\n                libc::pollfd { fd: 0, events: 0, revents: 0 },\n                libc::pollfd { fd: 1, events: 0, revents: 0 },\n                libc::pollfd { fd: 2, events: 0, revents: 0 },\n            ];\n\n            while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n                match errno() {\n                    libc::EINTR => continue,\n                    #[cfg(target_vendor = \"unikraft\")]\n                    libc::ENOSYS => {\n                        // Not all configurations of Unikraft enable `LIBPOSIX_EVENT`.\n                        break 'poll;\n                    }\n                    libc::EINVAL | libc::EAGAIN | libc::ENOMEM => {\n                        // RLIMIT_NOFILE or temporary allocation failures\n                        // may be preventing use of poll(), fall back to fcntl\n                        break 'poll;\n                    }\n                    _ => libc::abort(),\n                }\n            }\n            for pfd in pfds {\n                if pfd.revents & libc::POLLNVAL == 0 {\n                    continue;\n                }\n                open_devnull();\n            }\n            return;\n        }\n\n        // fallback in case poll isn't available or limited by RLIMIT_NOFILE\n        #[cfg(not(any(\n            // The standard fds are always available in Miri.\n            miri,\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"vxworks\",\n            target_os = \"l4re\",\n            target_os = \"horizon\",\n            target_os = \"vita\",\n        )))]\n        {\n            use crate::sys::os::errno;\n            for fd in 0..3 {\n                if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n                    open_devnull();\n                }\n            }\n        }\n    }",
  "mir": "fn sys::pal::unix::init::sanitize_standard_fds() -> () {\n    let mut _0: ();\n    let mut _1: i32;\n    let mut _2: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:59:32: 59:34};\n    let mut _3: &mut i32;\n    let  _4: &mut [libc::pollfd];\n    let mut _5: &mut [libc::pollfd; 3];\n    let mut _6: [libc::pollfd; 3];\n    let mut _7: libc::pollfd;\n    let mut _8: libc::pollfd;\n    let mut _9: libc::pollfd;\n    let mut _10: i32;\n    let mut _11: *mut libc::pollfd;\n    let mut _12: i32;\n    let mut _13: !;\n    let mut _14: core::slice::IterMut<'_, libc::pollfd>;\n    let mut _15: core::slice::IterMut<'_, libc::pollfd>;\n    let mut _16: core::option::Option<&mut libc::pollfd>;\n    let mut _17: &mut core::slice::IterMut<'_, libc::pollfd>;\n    let mut _18: isize;\n    let  _19: &mut libc::pollfd;\n    let mut _20: i16;\n    let mut _21: i16;\n    let  _22: ();\n    let mut _23: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:59:32: 59:34};\n    let mut _24: core::ops::Range<i32>;\n    let mut _25: core::ops::Range<i32>;\n    let mut _26: core::ops::Range<i32>;\n    let mut _27: core::option::Option<i32>;\n    let mut _28: &mut core::ops::Range<i32>;\n    let mut _29: isize;\n    let  _30: i32;\n    let mut _31: i32;\n    let mut _32: bool;\n    let mut _33: i32;\n    let  _34: ();\n    let mut _35: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:59:32: 59:34};\n    debug opened_devnull => _1;\n    debug open_devnull => _2;\n    debug pfds => _4;\n    debug iter => _15;\n    debug pfd => _19;\n    debug iter => _26;\n    debug fd => _30;\n    bb0: {\n        StorageLive(_1);\n        _1 = -1_i32;\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &mut _1;\n        _2 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:59:32: 59:34}(move _3);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = pollfd(0_i32, 0_i16, 0_i16);\n        StorageLive(_8);\n        _8 = pollfd(1_i32, 0_i16, 0_i16);\n        StorageLive(_9);\n        _9 = pollfd(2_i32, 0_i16, 0_i16);\n        _6 = [move _7, move _8, move _9];\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_7);\n        _5 = &mut _6;\n        _4 = _5 as &mut [libc::pollfd];\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = core::slice::<impl [libc::pollfd]>::as_mut_ptr(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _10 = libc::poll(move _11, 3_u64, 0_i32) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        switchInt(move _10) -> [4294967295: bb4, otherwise: bb8];\n    }\n    bb4: {\n        StorageDead(_10);\n        StorageLive(_12);\n        _12 = sys::pal::unix::os::errno() -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(_12) -> [4: bb9, 22: bb7, 11: bb7, 12: bb7, otherwise: bb6];\n    }\n    bb6: {\n        _13 = libc::abort() -> unwind unreachable;\n    }\n    bb7: {\n        StorageDead(_12);\n        StorageDead(_6);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = Range(0_i32, 3_i32);\n        _24 = <core::ops::Range<i32> as core::iter::IntoIterator>::into_iter(move _25) -> [return: bb19, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageLive(_14);\n        _14 = <&mut [libc::pollfd] as core::iter::IntoIterator>::into_iter(_4) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        goto -> bb1;\n    }\n    bb10: {\n        StorageLive(_15);\n        _15 = move _14;\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_16);\n        _17 = &mut _15;\n        _16 = <core::slice::IterMut<'_, libc::pollfd> as core::iter::Iterator>::next(_17) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = discriminant(_16);\n        switchInt(move _18) -> [0: bb15, 1: bb14, otherwise: bb13];\n    }\n    bb13: {\n        unreachable;\n    }\n    bb14: {\n        StorageLive(_19);\n        _19 = move ((_16 as variant#1).0: &mut libc::pollfd);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = ((*_19).2: i16);\n        _20 = BitAnd(move _21, libc::POLLNVAL);\n        StorageDead(_21);\n        switchInt(move _20) -> [0: bb16, otherwise: bb17];\n    }\n    bb15: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_6);\n        StorageDead(_2);\n        StorageDead(_1);\n        goto -> bb32;\n    }\n    bb16: {\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_16);\n        goto -> bb11;\n    }\n    bb17: {\n        StorageDead(_20);\n        StorageLive(_23);\n        _23 = &mut _2;\n        _22 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:59:32: 59:34} as core::ops::FnMut<()>>::call_mut(move _23, ()) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_23);\n        StorageDead(_19);\n        StorageDead(_16);\n        goto -> bb11;\n    }\n    bb19: {\n        StorageDead(_25);\n        StorageLive(_26);\n        _26 = move _24;\n        goto -> bb20;\n    }\n    bb20: {\n        StorageLive(_27);\n        _28 = &mut _26;\n        _27 = <core::ops::Range<i32> as core::iter::Iterator>::next(_28) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        _29 = discriminant(_27);\n        switchInt(move _29) -> [0: bb23, 1: bb22, otherwise: bb13];\n    }\n    bb22: {\n        _30 = ((_27 as variant#1).0: i32);\n        StorageLive(_31);\n        _31 = libc::fcntl(_30, libc::F_GETFD) -> [return: bb24, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_27);\n        StorageDead(_26);\n        StorageDead(_24);\n        StorageDead(_2);\n        StorageDead(_1);\n        goto -> bb32;\n    }\n    bb24: {\n        switchInt(move _31) -> [4294967295: bb25, otherwise: bb30];\n    }\n    bb25: {\n        StorageDead(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = sys::pal::unix::os::errno() -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        _32 = Eq(move _33, libc::EBADF);\n        switchInt(move _32) -> [0: bb29, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_33);\n        StorageLive(_35);\n        _35 = &mut _2;\n        _34 = <{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/mod.rs:59:32: 59:34} as core::ops::FnMut<()>>::call_mut(move _35, ()) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_35);\n        goto -> bb31;\n    }\n    bb29: {\n        StorageDead(_33);\n        goto -> bb31;\n    }\n    bb30: {\n        StorageDead(_31);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_32);\n        StorageDead(_27);\n        goto -> bb20;\n    }\n    bb32: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}