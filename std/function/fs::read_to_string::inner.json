{
  "name": "fs::read_to_string::inner",
  "safe": true,
  "callees": {
    "fs::File::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to open a file in read-only mode.\n\n See the [`OpenOptions::open`] method for more details.\n\n If you only need to read the entire file contents,\n consider [`std::fs::read()`][self::read] or\n [`std::fs::read_to_string()`][self::read_to_string] instead.\n\n # Errors\n\n This function will return an error if `path` does not already exist.\n Other errors may also be returned according to [`OpenOptions::open`].\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Read;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut data = vec![];\n     f.read_to_end(&mut data)?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fs::File::metadata": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Queries metadata about the underlying file.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let metadata = f.metadata()?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new empty `String`.\n\n Given that the `String` is empty, this will not allocate any initial\n buffer. While that means that this initial operation is very\n inexpensive, it may cause excessive allocation later when you add\n data. If you have an idea of how much data the `String` will hold,\n consider the [`with_capacity`] method to prevent excessive\n re-allocation.\n\n [`with_capacity`]: String::with_capacity\n\n # Examples\n\n ```\n let s = String::new();\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "alloc_crate::string::String::try_reserve_exact": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tries to reserve the minimum capacity for at least `additional` bytes\n more than the current length. Unlike [`try_reserve`], this will not\n deliberately over-allocate to speculatively avoid frequent allocations.\n After calling `try_reserve_exact`, capacity will be greater than or\n equal to `self.len() + additional` if it returns `Ok(())`.\n Does nothing if the capacity is already sufficient.\n\n Note that the allocator may give the collection more space than it\n requests. Therefore, capacity can not be relied upon to be precisely\n minimal. Prefer [`try_reserve`] if future insertions are expected.\n\n [`try_reserve`]: String::try_reserve\n\n # Errors\n\n If the capacity overflows, or the allocator reports a failure, then an error\n is returned.\n\n # Examples\n\n ```\n use std::collections::TryReserveError;\n\n fn process_data(data: &str) -> Result<String, TryReserveError> {\n     let mut output = String::new();\n\n     // Pre-reserve the memory, exiting if we can't\n     output.try_reserve_exact(data.len())?;\n\n     // Now we know this can't OOM in the middle of our complex work\n     output.push_str(data);\n\n     Ok(output)\n }\n # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n ```\n",
      "adt": {}
    },
    "io::default_read_to_string": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "core::option::Option": "ImmutableAsArgument",
        "alloc_crate::string::String": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 3680, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 1482, kind: RigidTy(Adt(AdtDef(DefId { id: 5039, name: \"alloc_crate::collections::TryReserveError\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "fs::File": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "alloc_crate::string::String": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 1061,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:347:5: 354:6",
  "src": "fn inner(path: &Path) -> io::Result<String> {\n        let mut file = File::open(path)?;\n        let size = file.metadata().map(|m| usize::try_from(m.len()).unwrap_or(usize::MAX)).ok();\n        let mut string = String::new();\n        string.try_reserve_exact(size.unwrap_or(0))?;\n        io::default_read_to_string(&mut file, &mut string, size)?;\n        Ok(string)\n    }",
  "mir": "fn fs::read_to_string::inner(_1: &path::Path) -> core::result::Result<alloc_crate::string::String, io::error::Error> {\n    let mut _0: core::result::Result<alloc_crate::string::String, io::error::Error>;\n    let mut _2: fs::File;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _4: core::result::Result<fs::File, io::error::Error>;\n    let mut _5: isize;\n    let  _6: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _7: fs::File;\n    let  _8: core::option::Option<usize>;\n    let mut _9: core::result::Result<usize, io::error::Error>;\n    let mut _10: core::result::Result<fs::Metadata, io::error::Error>;\n    let mut _11: &fs::File;\n    let mut _12: alloc_crate::string::String;\n    let mut _13: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>;\n    let mut _14: core::result::Result<(), alloc_crate::collections::TryReserveError>;\n    let mut _15: &mut alloc_crate::string::String;\n    let mut _16: usize;\n    let mut _17: isize;\n    let  _18: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>;\n    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, usize>;\n    let mut _20: core::result::Result<usize, io::error::Error>;\n    let mut _21: &mut fs::File;\n    let mut _22: &mut alloc_crate::string::String;\n    let mut _23: isize;\n    let  _24: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _25: usize;\n    let mut _26: alloc_crate::string::String;\n    debug path => _1;\n    debug file => _2;\n    debug residual => _6;\n    debug val => _7;\n    debug size => _8;\n    debug string => _12;\n    debug residual => _18;\n    debug val => ();\n    debug residual => _24;\n    debug val => _25;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = fs::File::open::<&path::Path>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_7);\n        _7 = move ((_3 as variant#0).0: fs::File);\n        _2 = move _7;\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_2;\n        _10 = fs::File::metadata(move _11) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _6 = move ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<alloc_crate::string::String, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        goto -> bb25;\n    }\n    bb7: {\n        StorageDead(_11);\n        _9 = core::result::Result::<fs::Metadata, io::error::Error>::map::<usize, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:349:40: 349:43}>(move _10, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:349:40: 349:43}) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        _8 = core::result::Result::<usize, io::error::Error>::ok(move _9) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageLive(_12);\n        _12 = alloc_crate::string::String::new() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &mut _12;\n        StorageLive(_16);\n        _16 = core::option::Option::<usize>::unwrap_or(_8, 0_usize) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _14 = alloc_crate::string::String::try_reserve_exact(move _15, move _16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_16);\n        StorageDead(_15);\n        _13 = <core::result::Result<(), alloc_crate::collections::TryReserveError> as core::ops::Try>::branch(move _14) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_14);\n        _17 = discriminant(_13);\n        switchInt(move _17) -> [0: bb14, 1: bb15, otherwise: bb3];\n    }\n    bb14: {\n        StorageDead(_13);\n        StorageLive(_19);\n        StorageLive(_20);\n        _21 = &mut _2;\n        _22 = &mut _12;\n        _20 = io::default_read_to_string::<fs::File>(_21, _22, _8) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _18 = move ((_13 as variant#1).0: core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>);\n        _0 = <core::result::Result<alloc_crate::string::String, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, alloc_crate::collections::TryReserveError>>>::from_residual(_18) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_13);\n        goto -> bb23;\n    }\n    bb17: {\n        _19 = <core::result::Result<usize, io::error::Error> as core::ops::Try>::branch(move _20) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_20);\n        _23 = discriminant(_19);\n        switchInt(move _23) -> [0: bb19, 1: bb20, otherwise: bb3];\n    }\n    bb19: {\n        StorageLive(_25);\n        _25 = ((_19 as variant#0).0: usize);\n        StorageDead(_25);\n        StorageDead(_19);\n        StorageLive(_26);\n        _26 = move _12;\n        _0 = core::result::Result::Ok(move _26);\n        StorageDead(_26);\n        StorageDead(_12);\n        drop(_2) -> [return: bb22, unwind unreachable];\n    }\n    bb20: {\n        _24 = move ((_19 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<alloc_crate::string::String, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_24) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_19);\n        goto -> bb23;\n    }\n    bb22: {\n        StorageDead(_2);\n        goto -> bb26;\n    }\n    bb23: {\n        drop(_12) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_12);\n        drop(_2) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_2);\n        goto -> bb26;\n    }\n    bb26: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}