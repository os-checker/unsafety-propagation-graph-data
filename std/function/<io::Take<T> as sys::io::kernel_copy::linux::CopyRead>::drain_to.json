{
  "name": "<io::Take<T> as sys::io::kernel_copy::linux::CopyRead>::drain_to",
  "safe": true,
  "callees": {
    "io::Take::<T>::limit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the number of bytes that can be read before this instance will\n return EOF.\n\n # Note\n\n This instance may reach `EOF` after reading fewer bytes than indicated by\n this method if the underlying [`Read`] instance reaches EOF.\n\n # Examples\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let f = File::open(\"foo.txt\")?;\n\n     // read at most five bytes\n     let handle = f.take(5);\n\n     println!(\"limit: {}\", handle.limit());\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::Take": "ImmutableAsArgument"
      }
    },
    "core::cmp::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n Internally uses an alias to [`Ord::min`].\n\n # Examples\n\n ```\n use std::cmp;\n\n assert_eq!(cmp::min(1, 2), 1);\n assert_eq!(cmp::min(2, 2), 2);\n ```\n ```\n use std::cmp::{self, Ordering};\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(cmp::min(Equal(\"v1\"), Equal(\"v2\")).0, \"v1\");\n ```\n",
      "adt": {}
    },
    "io::Take::<T>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the underlying reader.\n\n Care should be taken to avoid modifying the internal I/O state of the\n underlying reader as doing so may corrupt the internal limit of this\n `Take`.\n\n # Examples\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut file = File::open(\"foo.txt\")?;\n\n     let mut buffer = [0; 5];\n     let mut handle = file.take(5);\n     handle.read(&mut buffer)?;\n\n     let file = handle.get_mut();\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::Take": "MutableAsArgument"
      }
    },
    "sys::io::kernel_copy::linux::CopyRead::drain_to": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n transferred, whichever occurs sooner.\n If nested buffers are present the outer buffers must be drained first.\n\n This is necessary to directly bypass the wrapper types while preserving the data order\n when operating directly on the underlying file descriptors.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::Take::<T>::set_limit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the number of bytes that can be read before this instance will\n return EOF. This is the same as constructing a new `Take` instance, so\n the amount of bytes read and the previous limit value don't matter when\n calling this method.\n\n # Examples\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let f = File::open(\"foo.txt\")?;\n\n     // read at most five bytes\n     let mut handle = f.take(5);\n     handle.set_limit(10);\n\n     assert_eq!(handle.limit(), 10);\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::Take": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "io::Take": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 553, kind: RigidTy(Uint(U64)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<io::Take<T> as sys::io::kernel_copy::linux::CopyRead>::drain_to"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/io/kernel_copy/linux.rs:484:5: 492:6",
  "src": "fn drain_to<W: Write>(&mut self, writer: &mut W, outer_limit: u64) -> Result<u64> {\n        let local_limit = self.limit();\n        let combined_limit = min(outer_limit, local_limit);\n        let bytes_drained = self.get_mut().drain_to(writer, combined_limit)?;\n        // update limit since read() was bypassed\n        self.set_limit(local_limit - bytes_drained);\n\n        Ok(bytes_drained)\n    }",
  "mir": "fn <io::Take<T> as sys::io::kernel_copy::linux::CopyRead>::drain_to(_1: &mut io::Take<T>, _2: &mut W, _3: u64) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    let  _4: u64;\n    let mut _5: &io::Take<T>;\n    let  _6: u64;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, u64>;\n    let mut _8: core::result::Result<u64, io::error::Error>;\n    let mut _9: &mut T;\n    let mut _10: isize;\n    let  _11: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _12: u64;\n    let  _13: ();\n    let mut _14: u64;\n    let mut _15: (u64, bool);\n    debug self => _1;\n    debug writer => _2;\n    debug outer_limit => _3;\n    debug local_limit => _4;\n    debug combined_limit => _6;\n    debug bytes_drained => _12;\n    debug residual => _11;\n    debug val => _12;\n    bb0: {\n        StorageLive(_5);\n        _5 = &(*_1);\n        _4 = io::Take::<T>::limit(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _6 = core::cmp::min::<u64>(_3, _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _9 = io::Take::<T>::get_mut(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = <T as sys::io::kernel_copy::linux::CopyRead>::drain_to::<W>(_9, _2, _6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = <core::result::Result<u64, io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _10 = discriminant(_7);\n        switchInt(move _10) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _12 = ((_7 as variant#0).0: u64);\n        StorageDead(_7);\n        StorageLive(_14);\n        _15 = CheckedSub(_4, _12);\n        assert(!move (_15.1: bool), \"attempt to compute `{} - {}`, which would overflow\", _4, _12) -> [success: bb10, unwind unreachable];\n    }\n    bb8: {\n        _11 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<u64, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_11) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_7);\n        goto -> bb12;\n    }\n    bb10: {\n        _14 = move (_15.0: u64);\n        _13 = io::Take::<T>::set_limit(_1, move _14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        _0 = core::result::Result::Ok(_12);\n        goto -> bb12;\n    }\n    bb12: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}