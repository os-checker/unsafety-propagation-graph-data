{
  "name": "<sys::os_str::bytes::Slice as core::fmt::Display>::fmt",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "core::fmt::Display::fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n use std::fmt;\n\n struct Position {\n     longitude: f32,\n     latitude: f32,\n }\n\n impl fmt::Display for Position {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"({}, {})\", self.longitude, self.latitude)\n     }\n }\n\n assert_eq!(\n     \"(1.987, 2.983)\",\n     format!(\"{}\", Position { longitude: 1.987, latitude: 2.983, }),\n );\n ```\n",
      "adt": {}
    },
    "core::str::lossy::<impl [u8]>::utf8_chunks": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator over the contiguous valid UTF-8 ranges of this\n slice, and the non-UTF-8 fragments in between.\n\n See the [`Utf8Chunk`] type for documentation of the items yielded by this iterator.\n\n # Examples\n\n This function formats arbitrary but mostly-UTF-8 bytes into Rust source\n code in the form of a C-string literal (`c\"...\"`).\n\n ```\n use std::fmt::Write as _;\n\n pub fn cstr_literal(bytes: &[u8]) -> String {\n     let mut repr = String::new();\n     repr.push_str(\"c\\\"\");\n     for chunk in bytes.utf8_chunks() {\n         for ch in chunk.valid().chars() {\n             // Escapes \\0, \\t, \\r, \\n, \\\\, \\', \\\", and uses \\u{...} for non-printable characters.\n             write!(repr, \"{}\", ch.escape_debug()).unwrap();\n         }\n         for byte in chunk.invalid() {\n             write!(repr, \"\\\\x{:02X}\", byte).unwrap();\n         }\n     }\n     repr.push('\"');\n     repr\n }\n\n fn main() {\n     let lit = cstr_literal(b\"\\xferris the \\xf0\\x9f\\xa6\\x80\\x07\");\n     let expected = stringify!(c\"\\xFErris the ðŸ¦€\\u{7}\");\n     assert_eq!(lit, expected);\n }\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::str::Utf8Chunk::<'a>::valid": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the next validated UTF-8 substring.\n\n This substring can be empty at the start of the string or between\n broken UTF-8 characters.\n",
      "adt": {}
    },
    "core::str::Utf8Chunk::<'a>::invalid": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the invalid sequence that caused a failure.\n\n The returned slice will have a maximum length of 3 and starts after the\n substring given by [`valid`]. Decoding will resume after this sequence.\n\n If empty, this is the last chunk in the string. If non-empty, an\n unexpected byte was encountered or the end of the input was reached\n unexpectedly.\n\n Lossy decoding would replace this sequence with [`U+FFFD REPLACEMENT\n CHARACTER`].\n\n [`valid`]: Self::valid\n [`U+FFFD REPLACEMENT CHARACTER`]: crate::char::REPLACEMENT_CHARACTER\n",
      "adt": {}
    },
    "core::fmt::Formatter::<'a>::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes some data to the underlying buffer contained within this\n formatter.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Foo;\n\n impl fmt::Display for Foo {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         formatter.write_str(\"Foo\")\n         // This is equivalent to:\n         // write!(formatter, \"Foo\")\n     }\n }\n\n assert_eq!(format!(\"{Foo}\"), \"Foo\");\n assert_eq!(format!(\"{Foo:0>8}\"), \"Foo\");\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::Write::write_char": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a [`char`] into this writer, returning whether the write succeeded.\n\n A single [`char`] may be encoded as more than one byte.\n This method can only succeed if the entire byte sequence was successfully\n written, and this method will not return until all data has been\n written or an error occurs.\n\n # Errors\n\n This function will return an instance of [`Error`] on error.\n\n # Examples\n\n ```\n use std::fmt::{Error, Write};\n\n fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n     f.write_char(c)\n }\n\n let mut buf = String::new();\n writer(&mut buf, 'a')?;\n writer(&mut buf, 'b')?;\n assert_eq!(&buf, \"ab\");\n # std::fmt::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::os_str::bytes::Slice": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::str::Utf8Chunks": [
      "Plain",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 16529, kind: RigidTy(Adt(AdtDef(DefId { id: 12086, name: \"core::str::Utf8Chunk\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])"
    ],
    "core::str::Utf8Chunk": [
      "Plain",
      "Ref"
    ],
    "core::ops::ControlFlow": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<sys::os_str::bytes::Slice as core::fmt::Display>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/os_str/bytes.rs:66:5: 86:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // If we're the empty string then our iterator won't actually yield\n        // anything, so perform the formatting manually\n        if self.inner.is_empty() {\n            return \"\".fmt(f);\n        }\n\n        for chunk in self.inner.utf8_chunks() {\n            let valid = chunk.valid();\n            // If we successfully decoded the whole chunk as a valid string then\n            // we can return a direct formatting of the string which will also\n            // respect various formatting flags if possible.\n            if chunk.invalid().is_empty() {\n                return valid.fmt(f);\n            }\n\n            f.write_str(valid)?;\n            f.write_char(char::REPLACEMENT_CHARACTER)?;\n        }\n        Ok(())\n    }",
  "mir": "fn <sys::os_str::bytes::Slice as core::fmt::Display>::fmt(_1: &sys::os_str::bytes::Slice, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: bool;\n    let mut _4: &[u8];\n    let mut _5: &str;\n    let mut _6: core::str::Utf8Chunks<'_>;\n    let mut _7: core::str::Utf8Chunks<'_>;\n    let mut _8: &[u8];\n    let mut _9: core::str::Utf8Chunks<'_>;\n    let mut _10: core::option::Option<core::str::Utf8Chunk<'_>>;\n    let mut _11: &mut core::str::Utf8Chunks<'_>;\n    let mut _12: isize;\n    let  _13: core::str::Utf8Chunk<'_>;\n    let  _14: &str;\n    let mut _15: &core::str::Utf8Chunk<'_>;\n    let mut _16: bool;\n    let  _17: &[u8];\n    let mut _18: &core::str::Utf8Chunk<'_>;\n    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _20: core::result::Result<(), core::fmt::Error>;\n    let mut _21: isize;\n    let mut _22: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, core::fmt::Error>>;\n    let mut _23: core::result::Result<(), core::fmt::Error>;\n    let mut _24: isize;\n    debug self => _1;\n    debug f => _2;\n    debug iter => _9;\n    debug chunk => _13;\n    debug valid => _14;\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    debug residual => core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error);\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: [u8]);\n        _3 = core::slice::<impl [u8]>::is_empty(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb4, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = \"\";\n        _0 = <str as core::fmt::Display>::fmt(move _5, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_3);\n        goto -> bb29;\n    }\n    bb4: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &((*_1).0: [u8]);\n        _7 = core::str::lossy::<impl [u8]>::utf8_chunks(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _6 = <core::str::Utf8Chunks<'_> as core::iter::IntoIterator>::into_iter(move _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageLive(_9);\n        _9 = move _6;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageLive(_10);\n        _11 = &mut _9;\n        _10 = <core::str::Utf8Chunks<'_> as core::iter::Iterator>::next(_11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb11, 1: bb10, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        StorageLive(_13);\n        _13 = move ((_10 as variant#1).0: core::str::Utf8Chunk<'_>);\n        StorageLive(_15);\n        _15 = &_13;\n        _14 = core::str::Utf8Chunk::<'_>::valid(move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_6);\n        _0 = core::result::Result::Ok(());\n        goto -> bb29;\n    }\n    bb12: {\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = &_13;\n        _17 = core::str::Utf8Chunk::<'_>::invalid(move _18) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_18);\n        _16 = core::slice::<impl [u8]>::is_empty(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _16) -> [0: bb17, otherwise: bb15];\n    }\n    bb15: {\n        _0 = <str as core::fmt::Display>::fmt(_14, _2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_16);\n        goto -> bb28;\n    }\n    bb17: {\n        StorageDead(_16);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = core::fmt::Formatter::<'_>::write_str(_2, _14) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _19 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _20) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_20);\n        _21 = discriminant(_19);\n        switchInt(move _21) -> [0: bb20, 1: bb21, otherwise: bb9];\n    }\n    bb20: {\n        StorageDead(_19);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = <core::fmt::Formatter<'_> as core::fmt::Write>::write_char(_2, core::char::methods::<impl char>::REPLACEMENT_CHARACTER) -> [return: bb23, unwind unreachable];\n    }\n    bb21: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_19);\n        goto -> bb28;\n    }\n    bb23: {\n        _22 = <core::result::Result<(), core::fmt::Error> as core::ops::Try>::branch(move _23) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_23);\n        _24 = discriminant(_22);\n        switchInt(move _24) -> [0: bb25, 1: bb26, otherwise: bb9];\n    }\n    bb25: {\n        StorageDead(_22);\n        StorageDead(_13);\n        StorageDead(_10);\n        goto -> bb7;\n    }\n    bb26: {\n        _0 = <core::result::Result<(), core::fmt::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, core::fmt::Error>>>::from_residual(core::result::Result::<core::convert::Infallible, core::fmt::Error>::Err(core::fmt::Error)) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_22);\n        goto -> bb28;\n    }\n    bb28: {\n        StorageDead(_13);\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageDead(_6);\n        goto -> bb29;\n    }\n    bb29: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}