{
  "name": "<sys::stdio::unix::Stderr as io::Write>::write",
  "safe": true,
  "callees": {
    "os::fd::raw::FromRawFd::from_raw_fd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new instance of `Self` from the given raw file\n descriptor.\n\n This function is typically used to **consume ownership** of the\n specified file descriptor. When used in this way, the returned object\n will take responsibility for closing it when the object goes out of\n scope.\n\n However, consuming ownership is not strictly required. Use a\n [`From<OwnedFd>::from`] implementation for an API which strictly\n consumes ownership.\n\n # Safety\n\n The `fd` passed in must be an [owned file descriptor][io-safety];\n in particular, it must be open.\n\n [io-safety]: io#io-safety\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{FromRawFd, IntoRawFd, RawFd};\n\n let f = File::open(\"foo.txt\")?;\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.into_raw_fd();\n // SAFETY: no other functions should call `from_raw_fd`, so there\n // is only one owner for the file descriptor.\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let f = unsafe { File::from_raw_fd(raw_fd) };\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "core::mem::ManuallyDrop::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrap a value to be manually dropped.\n\n # Examples\n\n ```rust\n use std::mem::ManuallyDrop;\n let mut x = ManuallyDrop::new(String::from(\"Hello World!\"));\n x.truncate(5); // You can still safely operate on the value\n assert_eq!(*x, \"Hello\");\n // But `Drop` will not be run here\n # // FIXME(https://github.com/rust-lang/miri/issues/3670):\n # // use -Zmiri-disable-leak-check instead of unleaking in tests meant to leak.\n # let _ = ManuallyDrop::into_inner(x);\n ```\n",
      "adt": {}
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sys::fd::unix::FileDesc::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fd::unix::FileDesc": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::fd::unix::FileDesc": [
      "Plain",
      "Ref"
    ],
    "core::mem::ManuallyDrop": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "sys::stdio::unix::Stderr": [
      "MutRef"
    ]
  },
  "path": 4248,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/stdio/unix.rs:76:5: 78:6",
  "src": "fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n        unsafe { ManuallyDrop::new(FileDesc::from_raw_fd(STDERR_FILENO)).write(buf) }\n    }",
  "mir": "fn <sys::stdio::unix::Stderr as io::Write>::write(_1: &mut sys::stdio::unix::Stderr, _2: &[u8]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let  _3: &sys::fd::unix::FileDesc;\n    let mut _4: &core::mem::ManuallyDrop<sys::fd::unix::FileDesc>;\n    let  _5: core::mem::ManuallyDrop<sys::fd::unix::FileDesc>;\n    let mut _6: sys::fd::unix::FileDesc;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = <sys::fd::unix::FileDesc as os::fd::raw::FromRawFd>::from_raw_fd(libc::STDERR_FILENO) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = core::mem::ManuallyDrop::<sys::fd::unix::FileDesc>::new(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _4 = &_5;\n        _3 = <core::mem::ManuallyDrop<sys::fd::unix::FileDesc> as core::ops::Deref>::deref(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_4);\n        _0 = sys::fd::unix::FileDesc::write(_3, _2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}