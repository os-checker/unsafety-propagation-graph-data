{
  "name": "fs::File::create_new",
  "safe": true,
  "callees": {
    "fs::OpenOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a blank new set of options ready for configuration.\n\n All options are initially set to `false`.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let mut options = OpenOptions::new();\n let file = options.read(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "Constructor"
      }
    },
    "fs::OpenOptions::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option for read access.\n\n This option, when true, will indicate that the file should be\n `read`-able if opened.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().read(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option for write access.\n\n This option, when true, will indicate that the file should be\n `write`-able if opened.\n\n If the file already exists, any write calls on it will overwrite its\n contents, without truncating it.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::create_new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option to create a new file, failing if it already exists.\n\n No file is allowed to exist at the target location, also no (dangling) symlink. In this\n way, if the call succeeds, the file returned is guaranteed to be new.\n If a file exists at the target location, creating a new file will fail with [`AlreadyExists`]\n or another error based on the situation. See [`OpenOptions::open`] for a\n non-exhaustive list of likely errors.\n\n This option is useful because it is atomic. Otherwise between checking\n whether a file exists and creating a new one, the file may have been\n created by another process (a [TOCTOU] race condition / attack).\n\n If `.create_new(true)` is set, [`.create()`] and [`.truncate()`] are\n ignored.\n\n The file must be opened with write or append access in order to create\n a new file.\n\n [`.create()`]: OpenOptions::create\n [`.truncate()`]: OpenOptions::truncate\n [`AlreadyExists`]: io::ErrorKind::AlreadyExists\n [TOCTOU]: self#time-of-check-to-time-of-use-toctou\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true)\n                              .create_new(true)\n                              .open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "fs::OpenOptions::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Opens a file at `path` with the options specified by `self`.\n\n # Errors\n\n This function will return an error under a number of different\n circumstances. Some of these error conditions are listed here, together\n with their [`io::ErrorKind`]. The mapping to [`io::ErrorKind`]s is not\n part of the compatibility contract of the function.\n\n * [`NotFound`]: The specified file does not exist and neither `create`\n   or `create_new` is set.\n * [`NotFound`]: One of the directory components of the file path does\n   not exist.\n * [`PermissionDenied`]: The user lacks permission to get the specified\n   access rights for the file.\n * [`PermissionDenied`]: The user lacks permission to open one of the\n   directory components of the specified path.\n * [`AlreadyExists`]: `create_new` was specified and the file already\n   exists.\n * [`InvalidInput`]: Invalid combinations of open options (truncate\n   without write access, create without write or append access,\n   no access mode set, etc.).\n\n The following errors don't match any existing [`io::ErrorKind`] at the moment:\n * One of the directory components of the specified file path\n   was not, in fact, a directory.\n * Filesystem-level errors: full disk, write permission\n   requested on a read-only file system, exceeded disk quota, too many\n   open files, too long filename, too many symbolic links in the\n   specified path (Unix-like systems only), etc.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().read(true).open(\"foo.txt\");\n ```\n\n [`AlreadyExists`]: io::ErrorKind::AlreadyExists\n [`InvalidInput`]: io::ErrorKind::InvalidInput\n [`NotFound`]: io::ErrorKind::NotFound\n [`PermissionDenied`]: io::ErrorKind::PermissionDenied\n",
      "adt": {
        "fs::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "fs::OpenOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1129,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:675:5: 677:6",
  "src": "pub fn create_new<P: AsRef<Path>>(path: P) -> io::Result<File> {\n        OpenOptions::new().read(true).write(true).create_new(true).open(path.as_ref())\n    }",
  "mir": "fn fs::File::create_new(_1: P) -> core::result::Result<fs::File, io::error::Error> {\n    let mut _0: core::result::Result<fs::File, io::error::Error>;\n    let mut _2: &fs::OpenOptions;\n    let  _3: &mut fs::OpenOptions;\n    let mut _4: &mut fs::OpenOptions;\n    let mut _5: &mut fs::OpenOptions;\n    let mut _6: &mut fs::OpenOptions;\n    let mut _7: fs::OpenOptions;\n    let mut _8: &path::Path;\n    let mut _9: &P;\n    debug path => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = fs::OpenOptions::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = &mut _7;\n        _5 = fs::OpenOptions::read(move _6, true) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = fs::OpenOptions::write(_5, true) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _3 = fs::OpenOptions::create_new(_4, true) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _2 = &(*_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_1;\n        _8 = <P as core::convert::AsRef<path::Path>>::as_ref(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _0 = fs::OpenOptions::open::<&path::Path>(move _2, move _8) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_3);\n        StorageDead(_2);\n        drop(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": " Creates a new file in read-write mode; error if the file exists.\n\n This function will create a file if it does not exist, or return an error if it does. This\n way, if the call succeeds, the file returned is guaranteed to be new.\n If a file exists at the target location, creating a new file will fail with [`AlreadyExists`]\n or another error based on the situation. See [`OpenOptions::open`] for a\n non-exhaustive list of likely errors.\n\n This option is useful because it is atomic. Otherwise between checking whether a file\n exists and creating a new one, the file may have been created by another process (a [TOCTOU]\n race condition / attack).\n\n This can also be written using\n `File::options().read(true).write(true).create_new(true).open(...)`.\n\n [`AlreadyExists`]: crate::io::ErrorKind::AlreadyExists\n [TOCTOU]: self#time-of-check-to-time-of-use-toctou\n\n # Examples\n\n ```no_run\n use std::fs::File;\n use std::io::Write;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::create_new(\"foo.txt\")?;\n     f.write_all(\"Hello, world!\".as_bytes())?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}