{
  "name": "backtrace_rs::symbolize::gimli::lru::Lru::<T, N>::push_front",
  "safe": true,
  "callees": {
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::drop_in_place": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Executes the destructor (if any) of the pointed-to value.\n\n This is almost the same as calling [`ptr::read`] and discarding\n the result, but has the following advantages:\n\n * It is *required* to use `drop_in_place` to drop unsized types like\n   trait objects, because they can't be read out onto the stack and\n   dropped normally.\n\n * It is friendlier to the optimizer to do this over [`ptr::read`] when\n   dropping manually allocated memory (e.g., in the implementations of\n   `Box`/`Rc`/`Vec`), as the compiler doesn't need to prove that it's\n   sound to elide the copy.\n\n * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n   (pinned data must not be moved before it is dropped).\n\n Unaligned values cannot be dropped in place, they must be copied to an aligned\n location first using [`ptr::read_unaligned`]. For packed structs, this move is\n done automatically by the compiler. This means the fields of packed structs\n are not dropped in-place.\n\n [`ptr::read`]: self::read\n [`ptr::read_unaligned`]: self::read_unaligned\n [pinned]: crate::pin\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `to_drop` must be [valid] for both reads and writes.\n\n * `to_drop` must be properly aligned, even if `T` has size 0.\n\n * `to_drop` must be nonnull, even if `T` has size 0.\n\n * The value `to_drop` points to must be valid for dropping, which may mean\n   it must uphold additional invariants. These invariants depend on the type\n   of the value being dropped. For instance, when dropping a Box, the box's\n   pointer to the heap must be valid.\n\n * While `drop_in_place` is executing, the only way to access parts of\n   `to_drop` is through the `&mut self` references supplied to the\n   `Drop::drop` methods that `drop_in_place` invokes.\n\n Additionally, if `T` is not [`Copy`], using the pointed-to value after\n calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n foo` counts as a use because it will cause the value to be dropped\n again. [`write()`] can be used to overwrite data without causing it to be\n dropped.\n\n [valid]: self#safety\n\n # Examples\n\n Manually remove the last item from a vector:\n\n ```\n use std::ptr;\n use std::rc::Rc;\n\n let last = Rc::new(1);\n let weak = Rc::downgrade(&last);\n\n let mut v = vec![Rc::new(0), last];\n\n unsafe {\n     // Get a raw pointer to the last element in `v`.\n     let ptr = &mut v[1] as *mut _;\n     // Shorten `v` to prevent the last item from being dropped. We do that first,\n     // to prevent issues if the `drop_in_place` below panics.\n     v.set_len(1);\n     // Without a call `drop_in_place`, the last item would never be dropped,\n     // and the memory it manages would be leaked.\n     ptr::drop_in_place(ptr);\n }\n\n assert_eq!(v, &[0.into()]);\n\n // Ensure that the last item was dropped.\n assert!(weak.upgrade().is_none());\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` initialized with the given value.\n It is safe to call [`assume_init`] on the return value of this function.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<Vec<u8>> = MaybeUninit::new(vec![42]);\n # // Prevent leaks for Miri\n # unsafe { let _ = MaybeUninit::assume_init(v); }\n ```\n\n [`assume_init`]: MaybeUninit::assume_init\n",
      "adt": {}
    },
    "core::ops::IndexMut::index_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the mutable indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator that allows modifying each value.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n for elem in x.iter_mut() {\n     *elem += 2;\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::mem::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves `src` into the referenced `dest`, returning the previous `dest` value.\n\n Neither value is dropped.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a default value, see [`take`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n assert_eq!(vec![1, 2], old_v);\n assert_eq!(vec![3, 4, 5], v);\n ```\n\n `replace` allows consumption of a struct field by replacing it with another value.\n Without `replace` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let t = self.buf[i];\n         self.buf[i] = v;\n         t\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n avoid the move. But `replace` can be used to disassociate the original value at that index from\n `self`, allowing it to be returned:\n\n ```\n # #![allow(dead_code)]\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         mem::replace(&mut self.buf[i], v)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf[0], 0);\n\n assert_eq!(buffer.replace_index(0, 2), 0);\n assert_eq!(buffer.buf[0], 2);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::first_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a mutable reference to the first element of the slice, or `None` if it is empty.\n\n # Examples\n\n ```\n let x = &mut [0, 1, 2];\n\n if let Some(first) = x.first_mut() {\n     *first = 5;\n }\n assert_eq!(x, &[5, 1, 2]);\n\n let y: &mut [i32] = &mut [];\n assert_eq!(None, y.first_mut());\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 766, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 754, kind: RigidTy(Adt(AdtDef(DefId { id: 4679, name: \"core::mem::MaybeUninit\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) }, Mut)) })])"
    ],
    "backtrace_rs::symbolize::gimli::lru::Lru": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef"
    ],
    "core::mem::MaybeUninit": [
      "Plain",
      "MutRef"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::slice::IterMut": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::lru::Lru::<T, N>::push_front"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/lru.rs:38:5: 58:6",
  "src": "pub fn push_front(&mut self, value: T) -> Option<&mut T> {\n        if N == 0 {\n            return None;\n        } else if self.len == N {\n            self.len = N - 1;\n            // SAFETY: we maintain len invariant and bail on N == 0\n            unsafe { ptr::drop_in_place(self.arr.as_mut_ptr().cast::<T>().add(N - 1)) };\n        };\n        let len_to_init = self.len + 1;\n        let mut last = MaybeUninit::new(value);\n        for elem in self.arr[0..len_to_init].iter_mut() {\n            // OPT(size): using `mem::swap` allows surprising size regressions\n            last = mem::replace(elem, last);\n        }\n        self.len = len_to_init;\n\n        self.arr\n            .first_mut()\n            // SAFETY: we just pushed it\n            .map(|elem| unsafe { elem.assume_init_mut() })\n    }",
  "mir": "fn backtrace_rs::symbolize::gimli::lru::Lru::<T, N>::push_front(_1: &mut backtrace_rs::symbolize::gimli::lru::Lru<T, N>, _2: T) -> core::option::Option<&mut T> {\n    let mut _0: core::option::Option<&mut T>;\n    let mut _3: bool;\n    let mut _4: bool;\n    let mut _5: usize;\n    let mut _6: (usize, bool);\n    let  _7: ();\n    let mut _8: *mut T;\n    let mut _9: *mut T;\n    let mut _10: *mut core::mem::MaybeUninit<T>;\n    let mut _11: &mut [core::mem::MaybeUninit<T>];\n    let mut _12: &mut [core::mem::MaybeUninit<T>; N];\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let  _15: usize;\n    let mut _16: usize;\n    let mut _17: (usize, bool);\n    let mut _18: core::mem::MaybeUninit<T>;\n    let mut _19: T;\n    let mut _20: core::slice::IterMut<'_, core::mem::MaybeUninit<T>>;\n    let mut _21: core::slice::IterMut<'_, core::mem::MaybeUninit<T>>;\n    let mut _22: &mut [core::mem::MaybeUninit<T>];\n    let mut _23: &mut [core::mem::MaybeUninit<T>; N];\n    let mut _24: core::ops::Range<usize>;\n    let mut _25: core::slice::IterMut<'_, core::mem::MaybeUninit<T>>;\n    let mut _26: core::option::Option<&mut core::mem::MaybeUninit<T>>;\n    let mut _27: &mut core::slice::IterMut<'_, core::mem::MaybeUninit<T>>;\n    let mut _28: isize;\n    let  _29: &mut core::mem::MaybeUninit<T>;\n    let mut _30: core::mem::MaybeUninit<T>;\n    let mut _31: core::mem::MaybeUninit<T>;\n    let mut _32: core::option::Option<&mut core::mem::MaybeUninit<T>>;\n    let mut _33: &mut [core::mem::MaybeUninit<T>];\n    let mut _34: &mut [core::mem::MaybeUninit<T>; N];\n    debug self => _1;\n    debug value => _2;\n    debug len_to_init => _15;\n    debug last => _18;\n    debug iter => _25;\n    debug elem => _29;\n    bb0: {\n        StorageLive(_3);\n        _3 = Eq(N, 0_usize);\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = core::option::Option::None;\n        StorageDead(_3);\n        drop(_2) -> [return: bb25, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = ((*_1).0: usize);\n        _4 = Eq(move _5, N);\n        switchInt(move _4) -> [0: bb10, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_5);\n        _6 = CheckedSub(N, 1_usize);\n        assert(!move (_6.1: bool), \"attempt to compute `{} - {}`, which would overflow\", N, 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        ((*_1).0: usize) = move (_6.0: usize);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut ((*_1).1: [core::mem::MaybeUninit<T>; N]);\n        _11 = move _12 as &mut [core::mem::MaybeUninit<T>];\n        StorageDead(_12);\n        _10 = core::slice::<impl [core::mem::MaybeUninit<T>]>::as_mut_ptr(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_11);\n        _9 = core::ptr::mut_ptr::<impl *mut core::mem::MaybeUninit<T>>::cast::<T>(move _10) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_10);\n        StorageLive(_13);\n        _14 = CheckedSub(N, 1_usize);\n        assert(!move (_14.1: bool), \"attempt to compute `{} - {}`, which would overflow\", N, 1_usize) -> [success: bb7, unwind unreachable];\n    }\n    bb7: {\n        _13 = move (_14.0: usize);\n        _8 = core::ptr::mut_ptr::<impl *mut T>::add(move _9, move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageDead(_9);\n        _7 = core::ptr::drop_in_place::<T>(move _8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb10: {\n        StorageDead(_5);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_16);\n        _16 = ((*_1).0: usize);\n        _17 = CheckedAdd(_16, 1_usize);\n        assert(!move (_17.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _16, 1_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _15 = move (_17.0: usize);\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = move _2;\n        _18 = core::mem::MaybeUninit::<T>::new(move _19) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_23);\n        _23 = &mut ((*_1).1: [core::mem::MaybeUninit<T>; N]);\n        StorageLive(_24);\n        _24 = Range(0_usize, _15);\n        _22 = <[core::mem::MaybeUninit<T>; N] as core::ops::IndexMut<core::ops::Range<usize>>>::index_mut(move _23, move _24) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_24);\n        StorageDead(_23);\n        _21 = core::slice::<impl [core::mem::MaybeUninit<T>]>::iter_mut(_22) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        _20 = <core::slice::IterMut<'_, core::mem::MaybeUninit<T>> as core::iter::IntoIterator>::into_iter(move _21) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_21);\n        StorageLive(_25);\n        _25 = move _20;\n        goto -> bb17;\n    }\n    bb17: {\n        StorageLive(_26);\n        _27 = &mut _25;\n        _26 = <core::slice::IterMut<'_, core::mem::MaybeUninit<T>> as core::iter::Iterator>::next(_27) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _28 = discriminant(_26);\n        switchInt(move _28) -> [0: bb21, 1: bb20, otherwise: bb19];\n    }\n    bb19: {\n        unreachable;\n    }\n    bb20: {\n        _29 = move ((_26 as variant#1).0: &mut core::mem::MaybeUninit<T>);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = move _18;\n        _30 = core::mem::replace::<core::mem::MaybeUninit<T>>(_29, move _31) -> [return: bb22, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_20);\n        ((*_1).0: usize) = _15;\n        StorageLive(_32);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut ((*_1).1: [core::mem::MaybeUninit<T>; N]);\n        _33 = move _34 as &mut [core::mem::MaybeUninit<T>];\n        StorageDead(_34);\n        _32 = core::slice::<impl [core::mem::MaybeUninit<T>]>::first_mut(move _33) -> [return: bb23, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_31);\n        _18 = move _30;\n        StorageDead(_30);\n        StorageDead(_26);\n        goto -> bb17;\n    }\n    bb23: {\n        StorageDead(_33);\n        _0 = core::option::Option::<&mut core::mem::MaybeUninit<T>>::map::<&mut T, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/lru.rs:57:18: 57:24}>(move _32, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/lru.rs:57:18: 57:24}) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_32);\n        StorageDead(_18);\n        goto -> bb25;\n    }\n    bb25: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}