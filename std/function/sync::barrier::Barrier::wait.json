{
  "name": "sync::barrier::Barrier::wait",
  "safe": true,
  "callees": {
    "sync::nonpoison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n\n use std::sync::{Arc, nonpoison::Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock(), 10);\n ```\n",
      "adt": {
        "sync::nonpoison::mutex::Mutex": "ImmutableAsArgument",
        "sync::nonpoison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "sync::nonpoison::condvar::Condvar::wait_while": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Blocks the current thread until the provided condition becomes false.\n\n `condition` is checked immediately; if not met (returns `true`), this\n will [`wait`] for the next notification then check again. This repeats\n until `condition` returns `false`, in which case this function returns.\n\n This function will atomically unlock the mutex specified (represented by\n `guard`) and block the current thread. This means that any calls\n to [`notify_one`] or [`notify_all`] which happen logically after the\n mutex is unlocked are candidates to wake this thread up. When this\n function call returns, the lock specified will have been re-acquired.\n\n [`wait`]: Self::wait\n [`notify_one`]: Self::notify_one\n [`notify_all`]: Self::notify_all\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n #![feature(nonpoison_condvar)]\n\n use std::sync::nonpoison::{Mutex, Condvar};\n use std::sync::Arc;\n use std::thread;\n\n let pair = Arc::new((Mutex::new(true), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut pending = lock.lock();\n     *pending = false;\n     // We notify the condvar that the value has changed.\n     cvar.notify_one();\n });\n\n // Wait for the thread to start up.\n let (lock, cvar) = &*pair;\n // As long as the value inside the `Mutex<bool>` is `true`, we wait.\n let mut guard = lock.lock();\n cvar.wait_while(&mut guard, |pending| { *pending });\n ```\n",
      "adt": {
        "sync::nonpoison::mutex::MutexGuard": "MutableAsArgument",
        "sync::nonpoison::condvar::Condvar": "ImmutableAsArgument"
      }
    },
    "core::num::<impl usize>::wrapping_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "sync::nonpoison::condvar::Condvar::notify_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wakes up all blocked threads on this condvar.\n\n This method will ensure that any current waiters on the condition\n variable are awoken. Calls to `notify_all()` are not buffered in any\n way.\n\n To wake up only one thread, see [`notify_one`].\n\n [`notify_one`]: Self::notify_one\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n #![feature(nonpoison_condvar)]\n\n use std::sync::nonpoison::{Mutex, Condvar};\n use std::sync::Arc;\n use std::thread;\n\n let pair = Arc::new((Mutex::new(false), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut started = lock.lock();\n     *started = true;\n     // We notify the condvar that the value has changed.\n     cvar.notify_all();\n });\n\n // Wait for the thread to start up.\n let (lock, cvar) = &*pair;\n let mut started = lock.lock();\n // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n while !*started {\n     cvar.wait(&mut started);\n }\n ```\n",
      "adt": {
        "sync::nonpoison::condvar::Condvar": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sync::nonpoison::mutex::Mutex": [
      "Ref"
    ],
    "sync::barrier::Barrier": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ],
    "sync::nonpoison::mutex::MutexGuard": [
      "Plain",
      "Ref",
      "MutRef"
    ],
    "sync::barrier::BarrierState": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "sync::nonpoison::condvar::Condvar": [
      "Ref"
    ],
    "sync::barrier::BarrierWaitResult": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::barrier::Barrier::wait"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/barrier.rs:123:5: 136:6",
  "src": "pub fn wait(&self) -> BarrierWaitResult {\n        let mut lock = self.lock.lock();\n        let local_gen = lock.generation_id;\n        lock.count += 1;\n        if lock.count < self.num_threads {\n            self.cvar.wait_while(&mut lock, |state| local_gen == state.generation_id);\n            BarrierWaitResult(false)\n        } else {\n            lock.count = 0;\n            lock.generation_id = lock.generation_id.wrapping_add(1);\n            self.cvar.notify_all();\n            BarrierWaitResult(true)\n        }\n    }",
  "mir": "fn sync::barrier::Barrier::wait(_1: &sync::barrier::Barrier) -> sync::barrier::BarrierWaitResult {\n    let mut _0: sync::barrier::BarrierWaitResult;\n    let mut _2: sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _3: &sync::nonpoison::mutex::Mutex<sync::barrier::BarrierState>;\n    let  _4: usize;\n    let mut _5: &sync::barrier::BarrierState;\n    let mut _6: &sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _7: &mut sync::barrier::BarrierState;\n    let mut _8: &mut sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _9: (usize, bool);\n    let mut _10: bool;\n    let mut _11: usize;\n    let mut _12: &sync::barrier::BarrierState;\n    let mut _13: &sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _14: usize;\n    let  _15: ();\n    let mut _16: &sync::nonpoison::condvar::Condvar;\n    let mut _17: &mut sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _18: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/barrier.rs:128:45: 128:52};\n    let mut _19: &usize;\n    let mut _20: &mut sync::barrier::BarrierState;\n    let mut _21: &mut sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: &sync::barrier::BarrierState;\n    let mut _25: &sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let mut _26: &mut sync::barrier::BarrierState;\n    let mut _27: &mut sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState>;\n    let  _28: ();\n    let mut _29: &sync::nonpoison::condvar::Condvar;\n    debug self => _1;\n    debug lock => _2;\n    debug local_gen => _4;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).0: sync::nonpoison::mutex::Mutex<sync::barrier::BarrierState>);\n        _2 = sync::nonpoison::mutex::Mutex::<sync::barrier::BarrierState>::lock(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = <sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState> as core::ops::Deref>::deref(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = ((*_5).1: usize);\n        StorageDead(_5);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &mut _2;\n        _7 = <sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState> as core::ops::DerefMut>::deref_mut(move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        _9 = CheckedAdd(((*_7).0: usize), 1_usize);\n        assert(!move (_9.1: bool), \"attempt to compute `{} + {}`, which would overflow\", ((*_7).0: usize), 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb4: {\n        ((*_7).0: usize) = move (_9.0: usize);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_2;\n        _12 = <sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState> as core::ops::Deref>::deref(move _13) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_13);\n        _11 = ((*_12).0: usize);\n        StorageLive(_14);\n        _14 = ((*_1).2: usize);\n        _10 = Lt(move _11, move _14);\n        switchInt(move _10) -> [0: bb8, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_16);\n        _16 = &((*_1).1: sync::nonpoison::condvar::Condvar);\n        _17 = &mut _2;\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_4;\n        _18 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/barrier.rs:128:45: 128:52}(move _19);\n        StorageDead(_19);\n        _15 = sync::nonpoison::condvar::Condvar::wait_while::<sync::barrier::BarrierState, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/barrier.rs:128:45: 128:52}>(move _16, _17, move _18) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_18);\n        StorageDead(_16);\n        _0 = BarrierWaitResult(false);\n        goto -> bb14;\n    }\n    bb8: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &mut _2;\n        _20 = <sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState> as core::ops::DerefMut>::deref_mut(move _21) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_21);\n        ((*_20).0: usize) = 0_usize;\n        StorageDead(_20);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &_2;\n        _24 = <sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState> as core::ops::Deref>::deref(move _25) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_25);\n        _23 = ((*_24).1: usize);\n        _22 = core::num::<impl usize>::wrapping_add(move _23, 1_usize) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_23);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &mut _2;\n        _26 = <sync::nonpoison::mutex::MutexGuard<'_, sync::barrier::BarrierState> as core::ops::DerefMut>::deref_mut(move _27) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_27);\n        ((*_26).1: usize) = move _22;\n        StorageDead(_22);\n        StorageDead(_26);\n        StorageDead(_24);\n        StorageLive(_29);\n        _29 = &((*_1).1: sync::nonpoison::condvar::Condvar);\n        _28 = sync::nonpoison::condvar::Condvar::notify_all(move _29) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_29);\n        _0 = BarrierWaitResult(true);\n        goto -> bb14;\n    }\n    bb14: {\n        StorageDead(_10);\n        StorageDead(_4);\n        drop(_2) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Blocks the current thread until all threads have rendezvoused here.\n\n Barriers are re-usable after all threads have rendezvoused once, and can\n be used continuously.\n\n A single (arbitrary) thread will receive a [`BarrierWaitResult`] that\n returns `true` from [`BarrierWaitResult::is_leader()`] when returning\n from this function, and all other threads will receive a result that\n will return `false` from [`BarrierWaitResult::is_leader()`].\n\n # Examples\n\n ```\n use std::sync::Barrier;\n use std::thread;\n\n let n = 10;\n let barrier = Barrier::new(n);\n thread::scope(|s| {\n     for _ in 0..n {\n         // The same messages will be printed together.\n         // You will NOT see any interleaving.\n         s.spawn(|| {\n             println!(\"before wait\");\n             barrier.wait();\n             println!(\"after wait\");\n         });\n     }\n });\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}