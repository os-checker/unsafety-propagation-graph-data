{
  "name": "env::current_exe",
  "safe": true,
  "callees": {
    "sys::pal::unix::os::current_exe": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::env::current_exe"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/env.rs:750:1: 752:2",
  "src": "pub fn current_exe() -> io::Result<PathBuf> {\n    os_imp::current_exe()\n}",
  "mir": "fn env::current_exe() -> core::result::Result<path::PathBuf, io::error::Error> {\n    let mut _0: core::result::Result<path::PathBuf, io::error::Error>;\n    bb0: {\n        _0 = sys::pal::unix::os::current_exe() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Returns the full filesystem path of the current running executable.\n\n # Platform-specific behavior\n\n If the executable was invoked through a symbolic link, some platforms will\n return the path of the symbolic link and other platforms will return the\n path of the symbolic linkâ€™s target.\n\n If the executable is renamed while it is running, platforms may return the\n path at the time it was loaded instead of the new path.\n\n # Errors\n\n Acquiring the path of the current executable is a platform-specific operation\n that can fail for a good number of reasons. Some errors can include, but not\n be limited to, filesystem operations failing or general syscall failures.\n\n # Security\n\n The output of this function should not be trusted for anything\n that might have security implications. Basically, if users can run\n the executable, they can change the output arbitrarily.\n\n As an example, you can easily introduce a race condition. It goes\n like this:\n\n 1. You get the path to the current executable using `current_exe()`, and\n    store it in a variable.\n 2. Time passes. A malicious actor removes the current executable, and\n    replaces it with a malicious one.\n 3. You then use the stored path to re-execute the current\n    executable.\n\n You expected to safely execute the current executable, but you're\n instead executing something completely different. The code you\n just executed run with your privileges.\n\n This sort of behavior has been known to [lead to privilege escalation] when\n used incorrectly.\n\n [lead to privilege escalation]: https://securityvulns.com/Wdocument183.html\n\n # Examples\n\n ```\n use std::env;\n\n match env::current_exe() {\n     Ok(exe_path) => println!(\"Path of this executable is: {}\",\n                              exe_path.display()),\n     Err(e) => println!(\"failed to get current exe path: {e}\"),\n };\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}