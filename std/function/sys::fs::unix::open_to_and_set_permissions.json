{
  "name": "sys::fs::unix::open_to_and_set_permissions",
  "safe": true,
  "callees": {
    "fs::Metadata::permissions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the permissions of the file this metadata is for.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert!(!metadata.permissions().readonly());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument",
        "fs::Permissions": "Constructor"
      }
    },
    "fs::OpenOptions::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a blank new set of options ready for configuration.\n\n All options are initially set to `false`.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let mut options = OpenOptions::new();\n let file = options.read(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "Constructor"
      }
    },
    "os::unix::fs::PermissionsExt::mode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the mode permission bits\n",
      "adt": {}
    },
    "os::unix::fs::OpenOptionsExt::mode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the mode bits that a new file will be created with.\n\n If a new file is created as part of an `OpenOptions::open` call then this\n specified `mode` will be used as the permission bits for the new file.\n If no `mode` is set, the default of `0o666` will be used.\n The operating system masks out bits with the system's `umask`, to produce\n the final permissions.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n use std::os::unix::fs::OpenOptionsExt;\n\n # fn main() {\n let mut options = OpenOptions::new();\n options.mode(0o644); // Give read/write for owner and read for others.\n let file = options.open(\"foo.txt\");\n # }\n ```\n",
      "adt": {}
    },
    "fs::OpenOptions::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option for write access.\n\n This option, when true, will indicate that the file should be\n `write`-able if opened.\n\n If the file already exists, any write calls on it will overwrite its\n contents, without truncating it.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::create": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option to create a new file, or open it if it already exists.\n\n In order for the file to be created, [`OpenOptions::write`] or\n [`OpenOptions::append`] access must be used.\n\n See also [`std::fs::write()`][self::write] for a simple function to\n create a file with some given data.\n\n # Errors\n\n If `.create(true)` is set without `.write(true)` or `.append(true)`,\n calling [`open`](Self::open) will fail with [`InvalidInput`](io::ErrorKind::InvalidInput) error.\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).create(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::truncate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Sets the option for truncating a previous file.\n\n If a file is successfully opened with this option set to true, it will truncate\n the file to 0 length if it already exists.\n\n The file must be opened with write access for truncate to work.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().write(true).truncate(true).open(\"foo.txt\");\n ```\n",
      "adt": {
        "fs::OpenOptions": "MutableAsArgument"
      }
    },
    "fs::OpenOptions::open": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Opens a file at `path` with the options specified by `self`.\n\n # Errors\n\n This function will return an error under a number of different\n circumstances. Some of these error conditions are listed here, together\n with their [`io::ErrorKind`]. The mapping to [`io::ErrorKind`]s is not\n part of the compatibility contract of the function.\n\n * [`NotFound`]: The specified file does not exist and neither `create`\n   or `create_new` is set.\n * [`NotFound`]: One of the directory components of the file path does\n   not exist.\n * [`PermissionDenied`]: The user lacks permission to get the specified\n   access rights for the file.\n * [`PermissionDenied`]: The user lacks permission to open one of the\n   directory components of the specified path.\n * [`AlreadyExists`]: `create_new` was specified and the file already\n   exists.\n * [`InvalidInput`]: Invalid combinations of open options (truncate\n   without write access, create without write or append access,\n   no access mode set, etc.).\n\n The following errors don't match any existing [`io::ErrorKind`] at the moment:\n * One of the directory components of the specified file path\n   was not, in fact, a directory.\n * Filesystem-level errors: full disk, write permission\n   requested on a read-only file system, exceeded disk quota, too many\n   open files, too long filename, too many symbolic links in the\n   specified path (Unix-like systems only), etc.\n\n # Examples\n\n ```no_run\n use std::fs::OpenOptions;\n\n let file = OpenOptions::new().read(true).open(\"foo.txt\");\n ```\n\n [`AlreadyExists`]: io::ErrorKind::AlreadyExists\n [`InvalidInput`]: io::ErrorKind::InvalidInput\n [`NotFound`]: io::ErrorKind::NotFound\n [`PermissionDenied`]: io::ErrorKind::PermissionDenied\n",
      "adt": {
        "fs::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "fs::File": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "fs::File::metadata": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Queries metadata about the underlying file.\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let metadata = f.metadata()?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "Constructor",
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "fs::Metadata::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this metadata is for a regular file. The\n result is mutually exclusive to the result of\n [`Metadata::is_dir`], and will be false for symlink metadata\n obtained from [`symlink_metadata`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`File::open`] or\n [`OpenOptions::open`] for more information.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert!(metadata.is_file());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument"
      }
    },
    "fs::File::set_permissions": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Changes the permissions on the underlying file.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `fchmod` function on Unix and\n the `SetFileInformationByHandle` function on Windows. Note that, this\n [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n # Errors\n\n This function will return an error if the user lacks permission change\n attributes on the underlying file. It may also return an error in other\n os-specific unspecified cases.\n\n # Examples\n\n ```no_run\n fn main() -> std::io::Result<()> {\n     use std::fs::File;\n\n     let file = File::open(\"foo.txt\")?;\n     let mut perms = file.metadata()?.permissions();\n     perms.set_readonly(true);\n     file.set_permissions(perms)?;\n     Ok(())\n }\n ```\n\n Note that this method alters the permissions of the underlying file,\n even though it takes `&self` rather than `&mut self`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "fs::File": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "fs::Metadata": [
      "Ref",
      "Plain"
    ],
    "fs::Permissions": [
      "Plain",
      "Ref"
    ],
    "fs::OpenOptions": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3671, kind: RigidTy(Adt(AdtDef(DefId { id: 5960, name: \"fs::File\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3692, kind: RigidTy(Adt(AdtDef(DefId { id: 6032, name: \"fs::Metadata\" }), GenericArgs([]))) })])"
    ],
    "fs::File": [
      "Plain",
      "Ref"
    ]
  },
  "path": 3472,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:2232:1: 2257:2",
  "src": "fn open_to_and_set_permissions(\n    to: &Path,\n    reader_metadata: &crate::fs::Metadata,\n) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n    use crate::fs::OpenOptions;\n    use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n\n    let perm = reader_metadata.permissions();\n    let writer = OpenOptions::new()\n        // create the file with the correct mode right away\n        .mode(perm.mode())\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(to)?;\n    let writer_metadata = writer.metadata()?;\n    // fchmod is broken on vita\n    #[cfg(not(target_os = \"vita\"))]\n    if writer_metadata.is_file() {\n        // Set the correct file permissions, in case the file already existed.\n        // Don't set the permissions on already existing non-files like\n        // pipes/FIFOs or device nodes.\n        writer.set_permissions(perm)?;\n    }\n    Ok((writer, writer_metadata))\n}",
  "mir": "fn sys::fs::unix::open_to_and_set_permissions(_1: &path::Path, _2: &fs::Metadata) -> core::result::Result<(fs::File, fs::Metadata), io::error::Error> {\n    let mut _0: core::result::Result<(fs::File, fs::Metadata), io::error::Error>;\n    let  _3: fs::Permissions;\n    let  _4: fs::File;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::File>;\n    let mut _6: core::result::Result<fs::File, io::error::Error>;\n    let mut _7: &fs::OpenOptions;\n    let  _8: &mut fs::OpenOptions;\n    let mut _9: &mut fs::OpenOptions;\n    let mut _10: &mut fs::OpenOptions;\n    let mut _11: &mut fs::OpenOptions;\n    let mut _12: &mut fs::OpenOptions;\n    let mut _13: fs::OpenOptions;\n    let mut _14: u32;\n    let mut _15: &fs::Permissions;\n    let mut _16: isize;\n    let  _17: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _18: fs::File;\n    let  _19: fs::Metadata;\n    let mut _20: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, fs::Metadata>;\n    let mut _21: core::result::Result<fs::Metadata, io::error::Error>;\n    let mut _22: &fs::File;\n    let mut _23: isize;\n    let  _24: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _25: fs::Metadata;\n    let mut _26: bool;\n    let mut _27: &fs::Metadata;\n    let mut _28: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _29: core::result::Result<(), io::error::Error>;\n    let mut _30: &fs::File;\n    let mut _31: isize;\n    let  _32: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _33: (fs::File, fs::Metadata);\n    let mut _34: fs::File;\n    debug to => _1;\n    debug reader_metadata => _2;\n    debug perm => _3;\n    debug writer => _4;\n    debug residual => _17;\n    debug val => _18;\n    debug writer_metadata => _19;\n    debug residual => _24;\n    debug val => _25;\n    debug residual => _32;\n    debug val => ();\n    bb0: {\n        _3 = fs::Metadata::permissions(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = fs::OpenOptions::new() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _12 = &mut _13;\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_3;\n        _14 = <fs::Permissions as os::unix::fs::PermissionsExt>::mode(move _15) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_15);\n        _11 = <fs::OpenOptions as os::unix::fs::OpenOptionsExt>::mode(move _12, move _14) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_14);\n        StorageDead(_12);\n        _10 = fs::OpenOptions::write(_11, true) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = fs::OpenOptions::create(_10, true) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        _8 = fs::OpenOptions::truncate(_9, true) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _7 = &(*_8);\n        _6 = fs::OpenOptions::open::<&path::Path>(move _7, _1) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        _5 = <core::result::Result<fs::File, io::error::Error> as core::ops::Try>::branch(move _6) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_6);\n        _16 = discriminant(_5);\n        switchInt(move _16) -> [0: bb11, 1: bb12, otherwise: bb10];\n    }\n    bb10: {\n        unreachable;\n    }\n    bb11: {\n        StorageLive(_18);\n        _18 = move ((_5 as variant#0).0: fs::File);\n        _4 = move _18;\n        StorageDead(_18);\n        StorageDead(_13);\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_4;\n        _21 = fs::File::metadata(move _22) -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _17 = move ((_5 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(fs::File, fs::Metadata), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_13);\n        StorageDead(_8);\n        StorageDead(_5);\n        goto -> bb29;\n    }\n    bb14: {\n        StorageDead(_22);\n        _20 = <core::result::Result<fs::Metadata, io::error::Error> as core::ops::Try>::branch(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        _23 = discriminant(_20);\n        switchInt(move _23) -> [0: bb16, 1: bb17, otherwise: bb10];\n    }\n    bb16: {\n        StorageLive(_25);\n        _25 = move ((_20 as variant#0).0: fs::Metadata);\n        _19 = move _25;\n        StorageDead(_25);\n        StorageDead(_20);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &_19;\n        _26 = fs::Metadata::is_file(move _27) -> [return: bb19, unwind unreachable];\n    }\n    bb17: {\n        _24 = move ((_20 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(fs::File, fs::Metadata), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_24) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_20);\n        goto -> bb28;\n    }\n    bb19: {\n        switchInt(move _26) -> [0: bb26, otherwise: bb20];\n    }\n    bb20: {\n        StorageDead(_27);\n        StorageLive(_28);\n        StorageLive(_29);\n        StorageLive(_30);\n        _30 = &_4;\n        _29 = fs::File::set_permissions(move _30, _3) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_30);\n        _28 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _29) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_29);\n        _31 = discriminant(_28);\n        switchInt(move _31) -> [0: bb23, 1: bb24, otherwise: bb10];\n    }\n    bb23: {\n        StorageDead(_28);\n        goto -> bb27;\n    }\n    bb24: {\n        _32 = move ((_28 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(fs::File, fs::Metadata), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_32) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_28);\n        StorageDead(_26);\n        goto -> bb28;\n    }\n    bb26: {\n        StorageDead(_27);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageDead(_26);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = move _4;\n        _33 = (move _34, _19);\n        StorageDead(_34);\n        _0 = core::result::Result::Ok(move _33);\n        StorageDead(_33);\n        StorageDead(_4);\n        goto -> bb30;\n    }\n    bb28: {\n        drop(_4) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_4);\n        goto -> bb30;\n    }\n    bb30: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}