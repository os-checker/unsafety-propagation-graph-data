{
  "name": "rt::cleanup",
  "safe": true,
  "callees": {
    "sync::once::Once::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it might not be the closure specified). It is also\n guaranteed that any memory writes performed by the executed closure can\n be reliably observed by other threads at this point (there is a\n happens-before relation between the closure and code executing after the\n return).\n\n If the given closure recursively invokes `call_once` on the same [`Once`]\n instance, the exact behavior is not specified: allowed outcomes are\n a panic or a deadlock.\n\n # Examples\n\n ```\n use std::sync::Once;\n\n static mut VAL: usize = 0;\n static INIT: Once = Once::new();\n\n // Accessing a `static mut` is unsafe much of the time, but if we do so\n // in a synchronized fashion (e.g., write once or read all) then we're\n // good to go!\n //\n // This function will only call `expensive_computation` once, and will\n // otherwise always return the value returned from the first invocation.\n fn get_cached_val() -> usize {\n     unsafe {\n         INIT.call_once(|| {\n             VAL = expensive_computation();\n         });\n         VAL\n     }\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n\n # Panics\n\n The closure `f` will only be executed once even if this is called\n concurrently amongst many threads. If that closure panics, however, then\n it will *poison* this [`Once`] instance, causing all future invocations of\n `call_once` to also panic.\n\n This is similar to [poisoning with mutexes][poison], but this mechanism\n is guaranteed to never skip panics within `f`.\n\n [poison]: struct.Mutex.html#poisoning\n",
      "adt": {
        "sync::once::Once": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sync::once::Once": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::rt::cleanup"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:139:1: 147:2",
  "src": "pub(crate) fn cleanup() {\n    static CLEANUP: Once = Once::new();\n    CLEANUP.call_once(|| unsafe {\n        // Flush stdout and disable buffering.\n        crate::io::cleanup();\n        // SAFETY: Only called once during runtime cleanup.\n        sys::cleanup();\n    });\n}",
  "mir": "fn rt::cleanup() -> () {\n    let mut _0: ();\n    let  _1: ();\n    let mut _2: &sync::once::Once;\n    bb0: {\n        StorageLive(_2);\n        _2 = {alloc33: &sync::once::Once};\n        _1 = sync::once::Once::call_once::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:141:23: 141:25}>(move _2, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/rt.rs:141:23: 141:25}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}