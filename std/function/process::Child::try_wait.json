{
  "name": "process::Child::try_wait",
  "safe": true,
  "callees": {
    "sys::process::unix::unix::Process::try_wait": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::unix::Process": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "process::ExitStatus": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Describes the result of a process after it has terminated.\n\n This `struct` is used to represent the exit status or other termination of a child process.\n Child processes are created via the [`Command`] struct and their exit\n status is exposed through the [`status`] method, or the [`wait`] method\n of a [`Child`] process.\n\n An `ExitStatus` represents every possible disposition of a process.  On Unix this\n is the **wait status**.  It is *not* simply an *exit status* (a value passed to `exit`).\n\n For proper error reporting of failed processes, print the value of `ExitStatus` or\n `ExitStatusError` using their implementations of [`Display`](crate::fmt::Display).\n\n # Differences from `ExitCode`\n\n [`ExitCode`] is intended for terminating the currently running process, via\n the `Termination` trait, in contrast to `ExitStatus`, which represents the\n termination of a child process. These APIs are separate due to platform\n compatibility differences and their expected usage; it is not generally\n possible to exactly reproduce an `ExitStatus` from a child for the current\n process after the fact.\n\n [`status`]: Command::status\n [`wait`]: Child::wait\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::process::unix::unix::Process": [
      "MutRef"
    ],
    "process::Child": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8995, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8804, kind: RigidTy(Adt(AdtDef(DefId { id: 8479, name: \"sys::process::unix::unix::ExitStatus\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::process::Child::try_wait"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/process.rs:2331:5: 2333:6",
  "src": "pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n        Ok(self.handle.try_wait()?.map(ExitStatus))\n    }",
  "mir": "fn process::Child::try_wait(_1: &mut process::Child) -> core::result::Result<core::option::Option<process::ExitStatus>, io::error::Error> {\n    let mut _0: core::result::Result<core::option::Option<process::ExitStatus>, io::error::Error>;\n    let mut _2: core::option::Option<process::ExitStatus>;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, core::option::Option<sys::process::unix::unix::ExitStatus>>;\n    let mut _4: core::result::Result<core::option::Option<sys::process::unix::unix::ExitStatus>, io::error::Error>;\n    let mut _5: &mut sys::process::unix::unix::Process;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _8: core::option::Option<sys::process::unix::unix::ExitStatus>;\n    debug self => _1;\n    debug residual => _7;\n    debug val => _8;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = &mut ((*_1).0: sys::process::unix::unix::Process);\n        _4 = sys::process::unix::unix::Process::try_wait(move _5) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_5);\n        _3 = <core::result::Result<core::option::Option<sys::process::unix::unix::ExitStatus>, io::error::Error> as core::ops::Try>::branch(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _8 = ((_3 as variant#0).0: core::option::Option<sys::process::unix::unix::ExitStatus>);\n        _2 = core::option::Option::<sys::process::unix::unix::ExitStatus>::map::<process::ExitStatus, fn(sys::process::unix::unix::ExitStatus) -> process::ExitStatus {process::ExitStatus}>(_8, process::ExitStatus) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _7 = move ((_3 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<process::ExitStatus>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb8;\n    }\n    bb7: {\n        _0 = core::result::Result::Ok(move _2);\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb8;\n    }\n    bb8: {\n        return;\n    }\n}\n",
  "doc": " Attempts to collect the exit status of the child if it has already\n exited.\n\n This function will not block the calling thread and will only\n check to see if the child process has exited or not. If the child has\n exited then on Unix the process ID is reaped. This function is\n guaranteed to repeatedly return a successful exit status so long as the\n child has already exited.\n\n If the child has exited, then `Ok(Some(status))` is returned. If the\n exit status is not available at this time then `Ok(None)` is returned.\n If an error occurs, then that error is returned.\n\n Note that unlike `wait`, this function will not attempt to drop stdin.\n\n # Examples\n\n ```no_run\n use std::process::Command;\n\n let mut child = Command::new(\"ls\").spawn()?;\n\n match child.try_wait() {\n     Ok(Some(status)) => println!(\"exited with: {status}\"),\n     Ok(None) => {\n         println!(\"status not ready yet, let's really wait\");\n         let res = child.wait();\n         println!(\"result: {res:?}\");\n     }\n     Err(e) => println!(\"error attempting to wait: {e}\"),\n }\n # std::io::Result::Ok(())\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}