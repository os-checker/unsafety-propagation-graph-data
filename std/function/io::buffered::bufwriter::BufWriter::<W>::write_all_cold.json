{
  "name": "io::buffered::bufwriter::BufWriter::<W>::write_all_cold",
  "safe": true,
  "callees": {
    "io::buffered::bufwriter::BufWriter::<W>::spare_capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "ImmutableAsArgument"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::capacity": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the total number of elements the vector can hold without\n reallocating.\n\n # Examples\n\n ```\n let mut vec: Vec<i32> = Vec::with_capacity(10);\n vec.push(42);\n assert!(vec.capacity() >= 10);\n ```\n\n A vector with zero-sized elements will always have a capacity of usize::MAX:\n\n ```\n #[derive(Clone)]\n struct ZeroSized;\n\n fn main() {\n     assert_eq!(std::mem::size_of::<ZeroSized>(), 0);\n     let v = vec![ZeroSized; 0];\n     assert_eq!(v.capacity(), usize::MAX);\n }\n ```\n",
      "adt": {}
    },
    "io::buffered::bufwriter::BufWriter::<W>::get_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the underlying writer.\n\n It is inadvisable to directly write to the underlying writer.\n\n # Examples\n\n ```no_run\n use std::io::BufWriter;\n use std::net::TcpStream;\n\n let mut buffer = BufWriter::new(TcpStream::connect(\"127.0.0.1:34254\").unwrap());\n\n // we can use reference just like buffer\n let reference = buffer.get_mut();\n ```\n",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    },
    "io::Write::write_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to write an entire buffer into this writer.\n\n This method will continuously call [`write`] until there is no more data\n to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n returned. This method will not return until the entire buffer has been\n successfully written or such an error occurs. The first error that is\n not of [`ErrorKind::Interrupted`] kind generated from this method will be\n returned.\n\n If the buffer contains no data, this will never call [`write`].\n\n # Errors\n\n This function will return the first error of\n non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n\n [`write`]: Write::write\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     buffer.write_all(b\"some bytes\")?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::write_to_buffer_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "io::buffered::bufwriter::BufWriter": [
      "Ref",
      "Deref",
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "alloc_crate::vec::Vec": [
      "Ref"
    ]
  },
  "path": 1354,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/bufwriter.rs:401:5: 434:6",
  "src": "fn write_all_cold(&mut self, buf: &[u8]) -> io::Result<()> {\n        // Normally, `write_all` just calls `write` in a loop. We can do better\n        // by calling `self.get_mut().write_all()` directly, which avoids\n        // round trips through the buffer in the event of a series of partial\n        // writes in some circumstances.\n\n        if buf.len() > self.spare_capacity() {\n            self.flush_buf()?;\n        }\n\n        // Why not len > capacity? To avoid a needless trip through the buffer when the input\n        // exactly fills it. We'd just need to flush it to the underlying writer anyway.\n        if buf.len() >= self.buf.capacity() {\n            self.panicked = true;\n            let r = self.get_mut().write_all(buf);\n            self.panicked = false;\n            r\n        } else {\n            // Write to the buffer. In this case, we write to the buffer even if it fills it\n            // exactly. Doing otherwise would mean flushing the buffer, then writing this\n            // input to the inner writer, which in many cases would be a worse strategy.\n\n            // SAFETY: There was either enough spare capacity already, or there wasn't and we\n            // flushed the buffer to ensure that there is. In the latter case, we know that there\n            // is because flushing ensured that our entire buffer is spare capacity, and we entered\n            // this block because the input buffer length is less than that capacity. In either\n            // case, it's safe to write the input buffer to our buffer.\n            unsafe {\n                self.write_to_buffer_unchecked(buf);\n            }\n\n            Ok(())\n        }\n    }",
  "mir": "fn io::buffered::bufwriter::BufWriter::<W>::write_all_cold(_1: &mut io::buffered::bufwriter::BufWriter<W>, _2: &[u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: &io::buffered::bufwriter::BufWriter<W>;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _8: core::result::Result<(), io::error::Error>;\n    let mut _9: isize;\n    let  _10: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _11: bool;\n    let mut _12: usize;\n    let mut _13: usize;\n    let mut _14: &alloc_crate::vec::Vec<u8>;\n    let  _15: core::result::Result<(), io::error::Error>;\n    let mut _16: &mut W;\n    let  _17: ();\n    debug self => _1;\n    debug buf => _2;\n    debug residual => _10;\n    debug val => ();\n    debug r => _15;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = PtrMetadata(_2);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = io::buffered::bufwriter::BufWriter::<W>::spare_capacity(move _6) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_6);\n        _3 = Gt(move _4, move _5);\n        switchInt(move _3) -> [0: bb9, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _7 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _9 = discriminant(_7);\n        switchInt(move _9) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageDead(_7);\n        goto -> bb10;\n    }\n    bb7: {\n        _10 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        StorageDead(_3);\n        goto -> bb18;\n    }\n    bb9: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageDead(_3);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = PtrMetadata(_2);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &((*_1).0: alloc_crate::vec::Vec<u8>);\n        _13 = alloc_crate::vec::Vec::<u8>::capacity(move _14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_14);\n        _11 = Ge(move _12, move _13);\n        switchInt(move _11) -> [0: bb15, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_13);\n        StorageDead(_12);\n        ((*_1).1: bool) = true;\n        StorageLive(_15);\n        _16 = io::buffered::bufwriter::BufWriter::<W>::get_mut(_1) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _15 = <W as io::Write>::write_all(_16, _2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        ((*_1).1: bool) = false;\n        _0 = move _15;\n        StorageDead(_15);\n        goto -> bb17;\n    }\n    bb15: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _17 = io::buffered::bufwriter::BufWriter::<W>::write_to_buffer_unchecked(_1, _2) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _0 = core::result::Result::Ok(());\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_11);\n        goto -> bb18;\n    }\n    bb18: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}