{
  "name": "sys::fs::unix::readdir",
  "safe": true,
  "callees": {
    "sys::pal::common::small_c_string::run_path_with_cstr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::is_null": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s = [1, 2, 3];\n let ptr: *mut u32 = s.as_mut_ptr();\n assert!(!ptr.is_null());\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "path::Path::to_path_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a `Path` to an owned [`PathBuf`].\n\n # Examples\n\n ```\n use std::path::{Path, PathBuf};\n\n let path_buf = Path::new(\"foo.txt\").to_path_buf();\n assert_eq!(path_buf, PathBuf::from(\"foo.txt\"));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "path::PathBuf": "Constructor"
      }
    },
    "sys::fs::unix::ReadDir::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::ReadDir": "Constructor"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 15635, kind: RigidTy(RawPtr(Ty { id: 15648, kind: RigidTy(Adt(AdtDef(DefId { id: 11676, name: \"libc::DIR\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "path::PathBuf": [
      "Plain"
    ],
    "sys::fs::unix::Dir": [
      "Plain"
    ],
    "sys::fs::unix::InnerReadDir": [
      "Plain"
    ],
    "sys::fs::unix::ReadDir": [
      "Plain"
    ]
  },
  "path": 3475,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:2005:1: 2014:2",
  "src": "pub fn readdir(path: &Path) -> io::Result<ReadDir> {\n    let ptr = run_path_with_cstr(path, &|p| unsafe { Ok(libc::opendir(p.as_ptr())) })?;\n    if ptr.is_null() {\n        Err(Error::last_os_error())\n    } else {\n        let root = path.to_path_buf();\n        let inner = InnerReadDir { dirp: Dir(ptr), root };\n        Ok(ReadDir::new(inner))\n    }\n}",
  "mir": "fn sys::fs::unix::readdir(_1: &path::Path) -> core::result::Result<sys::fs::unix::ReadDir, io::error::Error> {\n    let mut _0: core::result::Result<sys::fs::unix::ReadDir, io::error::Error>;\n    let mut _2: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, *mut libc::DIR>;\n    let mut _3: core::result::Result<*mut libc::DIR, io::error::Error>;\n    let mut _4: &dyn for<'a> core::ops::Fn(&'a core::ffi::CStr) -> core::result::Result<*mut libc::DIR, io::error::Error>;\n    let  _5: &{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:2006:41: 2006:44};\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _8: *mut libc::DIR;\n    let mut _9: bool;\n    let mut _10: io::error::Error;\n    let  _11: path::PathBuf;\n    let  _12: sys::fs::unix::InnerReadDir;\n    let mut _13: sys::fs::unix::Dir;\n    let mut _14: sys::fs::unix::ReadDir;\n    debug path => _1;\n    debug ptr => _8;\n    debug residual => _7;\n    debug val => _8;\n    debug root => _11;\n    debug inner => _12;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = sys::fs::unix::readdir::promoted[0];\n        _4 = _5 as &dyn for<'a> core::ops::Fn(&'a core::ffi::CStr) -> core::result::Result<*mut libc::DIR, io::error::Error>;\n        _3 = sys::pal::common::small_c_string::run_path_with_cstr::<*mut libc::DIR>(_1, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = <core::result::Result<*mut libc::DIR, io::error::Error> as core::ops::Try>::branch(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _6 = discriminant(_2);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _8 = ((_2 as variant#0).0: *mut libc::DIR);\n        StorageDead(_2);\n        StorageLive(_9);\n        _9 = core::ptr::mut_ptr::<impl *mut libc::DIR>::is_null(_8) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _7 = move ((_2 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<sys::fs::unix::ReadDir, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_2);\n        goto -> bb14;\n    }\n    bb7: {\n        switchInt(move _9) -> [0: bb10, otherwise: bb8];\n    }\n    bb8: {\n        StorageLive(_10);\n        _10 = io::error::Error::last_os_error() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _0 = core::result::Result::Err(move _10);\n        StorageDead(_10);\n        goto -> bb13;\n    }\n    bb10: {\n        _11 = path::Path::to_path_buf(_1) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_13);\n        _13 = Dir(_8);\n        _12 = InnerReadDir(move _13, _11);\n        StorageDead(_13);\n        StorageLive(_14);\n        _14 = sys::fs::unix::ReadDir::new(_12) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _0 = core::result::Result::Ok(move _14);\n        StorageDead(_14);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_9);\n        goto -> bb14;\n    }\n    bb14: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}