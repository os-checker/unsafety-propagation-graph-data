{
  "name": "sync::mpmc::Receiver::<T>::recv",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sync::mpmc::array::Channel::<T>::recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Receives a message from the channel.\n",
      "adt": {
        "sync::mpmc::array::Channel": "ImmutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::list::Channel::<T>::recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Receives a message from the channel.\n",
      "adt": {
        "sync::mpmc::list::Channel": "ImmutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::zero::Channel::<T>::recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Receives a message from the channel.\n",
      "adt": {
        "sync::mpmc::zero::Channel": "ImmutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::mpmc::ReceiverFlavor": [
      "Ref",
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(2, ThreadLocalIndex)), Field(0, Ty { id: 11136, kind: RigidTy(Adt(AdtDef(DefId { id: 9340, name: \"sync::mpmc::counter::Receiver\" }), GenericArgs([Type(Ty { id: 11057, kind: RigidTy(Adt(AdtDef(DefId { id: 9477, name: \"sync::mpmc::zero::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 11126, kind: RigidTy(Adt(AdtDef(DefId { id: 9340, name: \"sync::mpmc::counter::Receiver\" }), GenericArgs([Type(Ty { id: 10845, kind: RigidTy(Adt(AdtDef(DefId { id: 9390, name: \"sync::mpmc::list::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 11139, kind: RigidTy(Adt(AdtDef(DefId { id: 9340, name: \"sync::mpmc::counter::Receiver\" }), GenericArgs([Type(Ty { id: 10556, kind: RigidTy(Adt(AdtDef(DefId { id: 9234, name: \"sync::mpmc::array::Channel\" }), GenericArgs([Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])"
    ],
    "sync::mpmc::Receiver": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "sync::mpmc::counter::Receiver": [
      "Ref"
    ],
    "sync::mpmc::zero::Channel": [
      "Ref"
    ],
    "sync::mpmc::list::Channel": [
      "Ref"
    ],
    "sync::mpmc::array::Channel": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpmc::Receiver::<T>::recv"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:981:5: 988:6",
  "src": "pub fn recv(&self) -> Result<T, RecvError> {\n        match &self.flavor {\n            ReceiverFlavor::Array(chan) => chan.recv(None),\n            ReceiverFlavor::List(chan) => chan.recv(None),\n            ReceiverFlavor::Zero(chan) => chan.recv(None),\n        }\n        .map_err(|_| RecvError)\n    }",
  "mir": "fn sync::mpmc::Receiver::<T>::recv(_1: &sync::mpmc::Receiver<T>) -> core::result::Result<T, sync::mpsc::RecvError> {\n    let mut _0: core::result::Result<T, sync::mpsc::RecvError>;\n    let mut _2: core::result::Result<T, sync::mpsc::RecvTimeoutError>;\n    let mut _3: &sync::mpmc::ReceiverFlavor<T>;\n    let mut _4: isize;\n    let  _5: &sync::mpmc::counter::Receiver<sync::mpmc::array::Channel<T>>;\n    let  _6: &sync::mpmc::array::Channel<T>;\n    let mut _7: core::option::Option<time::Instant>;\n    let  _8: &sync::mpmc::counter::Receiver<sync::mpmc::list::Channel<T>>;\n    let  _9: &sync::mpmc::list::Channel<T>;\n    let mut _10: core::option::Option<time::Instant>;\n    let  _11: &sync::mpmc::counter::Receiver<sync::mpmc::zero::Channel<T>>;\n    let  _12: &sync::mpmc::zero::Channel<T>;\n    let mut _13: core::option::Option<time::Instant>;\n    debug self => _1;\n    debug chan => _5;\n    debug chan => _8;\n    debug chan => _11;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).0: sync::mpmc::ReceiverFlavor<T>);\n        _4 = discriminant((*_3));\n        switchInt(move _4) -> [0: bb4, 1: bb3, 2: bb2, otherwise: bb1];\n    }\n    bb1: {\n        unreachable;\n    }\n    bb2: {\n        _11 = &(((*_3) as variant#2).0: sync::mpmc::counter::Receiver<sync::mpmc::zero::Channel<T>>);\n        _12 = <sync::mpmc::counter::Receiver<sync::mpmc::zero::Channel<T>> as core::ops::Deref>::deref(_11) -> [return: bb9, unwind unreachable];\n    }\n    bb3: {\n        _8 = &(((*_3) as variant#1).0: sync::mpmc::counter::Receiver<sync::mpmc::list::Channel<T>>);\n        _9 = <sync::mpmc::counter::Receiver<sync::mpmc::list::Channel<T>> as core::ops::Deref>::deref(_8) -> [return: bb7, unwind unreachable];\n    }\n    bb4: {\n        _5 = &(((*_3) as variant#0).0: sync::mpmc::counter::Receiver<sync::mpmc::array::Channel<T>>);\n        _6 = <sync::mpmc::counter::Receiver<sync::mpmc::array::Channel<T>> as core::ops::Deref>::deref(_5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_7);\n        _7 = core::option::Option::None;\n        _2 = sync::mpmc::array::Channel::<T>::recv(_6, move _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        goto -> bb11;\n    }\n    bb7: {\n        StorageLive(_10);\n        _10 = core::option::Option::None;\n        _2 = sync::mpmc::list::Channel::<T>::recv(_9, move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_10);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageLive(_13);\n        _13 = core::option::Option::None;\n        _2 = sync::mpmc::zero::Channel::<T>::recv(_12, move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        goto -> bb11;\n    }\n    bb11: {\n        _0 = core::result::Result::<T, sync::mpsc::RecvTimeoutError>::map_err::<sync::mpsc::RecvError, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:987:18: 987:21}>(move _2, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:987:18: 987:21}) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Attempts to wait for a value on this receiver, returning an error if the\n corresponding channel has hung up.\n\n This function will always block the current thread if there is no data\n available and it's possible for more data to be sent (at least one sender\n still exists). Once a message is sent to the corresponding [`Sender`],\n this receiver will wake up and return that message.\n\n If the corresponding [`Sender`] has disconnected, or it disconnects while\n this call is blocking, this call will wake up and return [`Err`] to\n indicate that no more messages can ever be received on this channel.\n However, since channels are buffered, messages sent before the disconnect\n will still be properly received.\n\n # Examples\n\n ```\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc;\n use std::thread;\n\n let (send, recv) = mpmc::channel();\n let handle = thread::spawn(move || {\n     send.send(1u8).unwrap();\n });\n\n handle.join().unwrap();\n\n assert_eq!(Ok(1), recv.recv());\n ```\n\n Buffering behavior:\n\n ```\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc;\n use std::thread;\n use std::sync::mpmc::RecvError;\n\n let (send, recv) = mpmc::channel();\n let handle = thread::spawn(move || {\n     send.send(1u8).unwrap();\n     send.send(2).unwrap();\n     send.send(3).unwrap();\n     drop(send);\n });\n\n // wait for the thread to join so we ensure the sender is dropped\n handle.join().unwrap();\n\n assert_eq!(Ok(1), recv.recv());\n assert_eq!(Ok(2), recv.recv());\n assert_eq!(Ok(3), recv.recv());\n assert_eq!(Err(RecvError), recv.recv());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}