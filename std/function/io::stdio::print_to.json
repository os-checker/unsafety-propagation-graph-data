{
  "name": "io::stdio::print_to",
  "safe": true,
  "callees": {
    "io::stdio::print_to_buffer_if_capture_used": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "io::Write::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a formatted string into this writer, returning any error\n encountered.\n\n This method is primarily used to interface with the\n [`format_args!()`] macro, and it is rare that this should\n explicitly be called. The [`write!()`] macro should be favored to\n invoke this method instead.\n\n This function internally uses the [`write_all`] method on\n this trait and hence will continuously write data so long as no errors\n are received. This also means that partial writes are not indicated in\n this signature.\n\n [`write_all`]: Write::write_all\n\n # Errors\n\n This function will return any I/O error reported while formatting.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // this call\n     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n     // turns into this:\n     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::fmt::Arguments": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])"
    ],
    "io::error::Error": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ]
  },
  "path": 1543,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/stdio.rs:1155:1: 1167:2",
  "src": "fn print_to<T>(args: fmt::Arguments<'_>, global_s: fn() -> T, label: &str)\nwhere\n    T: Write,\n{\n    if print_to_buffer_if_capture_used(args) {\n        // Successfully wrote to capture buffer.\n        return;\n    }\n\n    if let Err(e) = global_s().write_fmt(args) {\n        panic!(\"failed printing to {label}: {e}\");\n    }\n}",
  "mir": "fn io::stdio::print_to(_1: core::fmt::Arguments<'_>, _2: fn() -> T, _3: &str) -> () {\n    let mut _0: ();\n    let mut _4: bool;\n    let mut _5: core::result::Result<(), io::error::Error>;\n    let mut _6: &mut T;\n    let mut _7: T;\n    let mut _8: isize;\n    let  _9: io::error::Error;\n    let  _10: !;\n    let mut _11: core::fmt::Arguments<'_>;\n    let  _12: (&&str, &io::error::Error);\n    let mut _13: &&str;\n    let mut _14: &io::error::Error;\n    let  _15: [core::fmt::rt::Argument<'_>; 2];\n    let mut _16: core::fmt::rt::Argument<'_>;\n    let mut _17: core::fmt::rt::Argument<'_>;\n    let mut _18: &[u8; 26];\n    let  _19: &[core::fmt::rt::Argument<'_>; 2];\n    let mut _20: &&str;\n    let mut _21: &io::error::Error;\n    debug args => _1;\n    debug global_s => _2;\n    debug label => _3;\n    debug e => _9;\n    debug args => _12;\n    debug args => _15;\n    bb0: {\n        StorageLive(_4);\n        _4 = io::stdio::print_to_buffer_if_capture_used(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _4) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        goto -> bb11;\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _2() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _6 = &mut _7;\n        _5 = <T as io::Write>::write_fmt(move _6, _1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        _8 = discriminant(_5);\n        switchInt(move _8) -> [1: bb6, 0: bb12, otherwise: bb13];\n    }\n    bb6: {\n        StorageLive(_9);\n        _9 = move ((_5 as variant#1).0: io::error::Error);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &_3;\n        StorageLive(_14);\n        _14 = &_9;\n        _12 = (move _13, move _14);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _20 = (_12.0: &&str);\n        _16 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_20) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_17);\n        _21 = (_12.1: &io::error::Error);\n        _17 = core::fmt::rt::Argument::<'_>::new_display::<io::error::Error>(_21) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        _15 = [move _16, move _17];\n        StorageDead(_17);\n        StorageDead(_16);\n        StorageLive(_18);\n        _18 = b\"\\x13failed printing to \\xc0\\x02: \\xc0\\x00\";\n        _19 = &_15;\n        _11 = core::fmt::Arguments::<'_>::new::<26, 2>(move _18, _19) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        _10 = core::panicking::panic_fmt(move _11) -> unwind unreachable;\n    }\n    bb10: {\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb11;\n    }\n    bb11: {\n        return;\n    }\n    bb12: {\n        drop(_7) -> [return: bb10, unwind unreachable];\n    }\n    bb13: {\n        unreachable;\n    }\n}\n",
  "doc": " Writes `args` to the capture buffer if enabled and possible, or `global_s`\n otherwise. `label` identifies the stream in a panic message.\n\n This function is used to print error messages, so it takes extra\n care to avoid causing a panic when `OUTPUT_CAPTURE` is unusable.\n For instance, if the TLS key for output capturing is already destroyed, or\n if the local stream is in use by another thread, it will just fall back to\n the global stream.\n\n However, if the actual I/O causes an error, this function does panic.\n\n Writing to non-blocking stdout/stderr can cause an error, which will lead\n this function to panic.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}