{
  "name": "sys::sync::rwlock::futex::RwLock::wake_writer_or_readers",
  "safe": true,
  "callees": {
    "sys::sync::rwlock::futex::is_unlocked": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU32::compare_exchange": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer if the current value is the same as\n the `current` value.\n\n The return value is a result indicating whether the new value was written and\n containing the previous value. On success this value is guaranteed to be equal to\n `current`.\n\n `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n ordering of this operation. `success` describes the required ordering for the\n read-modify-write operation that takes place if the comparison with `current` succeeds.\n `failure` describes the required ordering for the load operation that takes place when\n the comparison fails. Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.compare_exchange(5, 10,\n                                      Ordering::Acquire,\n                                      Ordering::Relaxed),\n            Ok(5));\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n\n assert_eq!(some_var.compare_exchange(6, 12,\n                                      Ordering::SeqCst,\n                                      Ordering::Acquire),\n            Err(10));\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n\n # Considerations\n\n `compare_exchange` is a [compare-and-swap operation] and thus exhibits the usual downsides\n of CAS operations. In particular, a load of the value followed by a successful\n `compare_exchange` with the previous load *does not ensure* that other threads have not\n changed the value in the interim! This is usually important when the *equality* check in\n the `compare_exchange` is being used to check the *identity* of a value, but equality\n does not necessarily imply identity. This is a particularly common case for pointers, as\n a pointer holding the same address does not imply that the same object exists at that\n address! In this case, `compare_exchange` can lead to the [ABA problem].\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n",
      "adt": {}
    },
    "sys::sync::rwlock::futex::RwLock::wake_writer": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " This wakes one writer and returns true if we woke up a writer that was\n blocked on futex_wait.\n\n If this returns false, it might still be the case that we notified a\n writer that was about to go to sleep.\n",
      "adt": {
        "sys::sync::rwlock::futex::RwLock": "ImmutableAsArgument"
      }
    },
    "core::result::Result::<T, E>::is_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Err`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_err(), false);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_err(), true);\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::is_ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Ok`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_ok(), true);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_ok(), false);\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::futex::futex_wake_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wakes up all threads that are waiting on `futex_wait` on this futex.\n",
      "adt": {
        "core::sync::atomic::AtomicU32": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "core::sync::atomic::AtomicU32": [
      "Ref"
    ],
    "sys::sync::rwlock::futex::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::sync::rwlock::futex::RwLock::wake_writer_or_readers"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/rwlock/futex.rs:269:5: 316:6",
  "src": "fn wake_writer_or_readers(&self, mut state: Primitive) {\n        assert!(is_unlocked(state));\n\n        // The readers waiting bit might be turned on at any point now,\n        // since readers will block when there's anything waiting.\n        // Writers will just lock the lock though, regardless of the waiting bits,\n        // so we don't have to worry about the writer waiting bit.\n        //\n        // If the lock gets locked in the meantime, we don't have to do\n        // anything, because then the thread that locked the lock will take\n        // care of waking up waiters when it unlocks.\n\n        // If only writers are waiting, wake one of them up.\n        if state == WRITERS_WAITING {\n            match self.state.compare_exchange(state, 0, Relaxed, Relaxed) {\n                Ok(_) => {\n                    self.wake_writer();\n                    return;\n                }\n                Err(s) => {\n                    // Maybe some readers are now waiting too. So, continue to the next `if`.\n                    state = s;\n                }\n            }\n        }\n\n        // If both writers and readers are waiting, leave the readers waiting\n        // and only wake up one writer.\n        if state == READERS_WAITING + WRITERS_WAITING {\n            if self.state.compare_exchange(state, READERS_WAITING, Relaxed, Relaxed).is_err() {\n                // The lock got locked. Not our problem anymore.\n                return;\n            }\n            if self.wake_writer() {\n                return;\n            }\n            // No writers were actually blocked on futex_wait, so we continue\n            // to wake up readers instead, since we can't be sure if we notified a writer.\n            state = READERS_WAITING;\n        }\n\n        // If readers are waiting, wake them all up.\n        if state == READERS_WAITING {\n            if self.state.compare_exchange(state, 0, Relaxed, Relaxed).is_ok() {\n                futex_wake_all(&self.state);\n            }\n        }\n    }",
  "mir": "fn sys::sync::rwlock::futex::RwLock::wake_writer_or_readers(_1: &sys::sync::rwlock::futex::RwLock, _2: u32) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: u32;\n    let mut _5: !;\n    let mut _6: bool;\n    let mut _7: u32;\n    let mut _8: core::result::Result<u32, u32>;\n    let mut _9: &core::sync::atomic::AtomicU32;\n    let mut _10: u32;\n    let mut _11: core::sync::atomic::Ordering;\n    let mut _12: core::sync::atomic::Ordering;\n    let mut _13: isize;\n    let  _14: bool;\n    let  _15: u32;\n    let mut _16: bool;\n    let mut _17: u32;\n    let mut _18: u32;\n    let mut _19: (u32, bool);\n    let mut _20: bool;\n    let mut _21: &core::result::Result<u32, u32>;\n    let  _22: core::result::Result<u32, u32>;\n    let mut _23: &core::sync::atomic::AtomicU32;\n    let mut _24: u32;\n    let mut _25: core::sync::atomic::Ordering;\n    let mut _26: core::sync::atomic::Ordering;\n    let mut _27: bool;\n    let mut _28: bool;\n    let mut _29: u32;\n    let mut _30: bool;\n    let mut _31: &core::result::Result<u32, u32>;\n    let  _32: core::result::Result<u32, u32>;\n    let mut _33: &core::sync::atomic::AtomicU32;\n    let mut _34: u32;\n    let mut _35: core::sync::atomic::Ordering;\n    let mut _36: core::sync::atomic::Ordering;\n    let  _37: ();\n    let  _38: &core::sync::atomic::AtomicU32;\n    debug self => _1;\n    debug state => _2;\n    debug s => _15;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = _2;\n        _3 = sys::sync::rwlock::futex::is_unlocked(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = _2;\n        _6 = Eq(move _7, sys::sync::rwlock::futex::WRITERS_WAITING);\n        switchInt(move _6) -> [0: bb5, otherwise: bb4];\n    }\n    bb3: {\n        StorageDead(_4);\n        _5 = core::panicking::panic(\"assertion failed: is_unlocked(state)\") -> unwind unreachable;\n    }\n    bb4: {\n        StorageDead(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &((*_1).0: core::sync::atomic::AtomicU32);\n        StorageLive(_10);\n        _10 = _2;\n        StorageLive(_11);\n        _11 = core::sync::atomic::Ordering::Relaxed;\n        StorageLive(_12);\n        _12 = core::sync::atomic::Ordering::Relaxed;\n        _8 = core::sync::atomic::AtomicU32::compare_exchange(move _9, move _10, 0_u32, move _11, move _12) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        goto -> bb11;\n    }\n    bb6: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_9);\n        _13 = discriminant(_8);\n        switchInt(move _13) -> [0: bb9, 1: bb8, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _15 = ((_8 as variant#1).0: u32);\n        _2 = _15;\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb9: {\n        StorageLive(_14);\n        _14 = sys::sync::rwlock::futex::RwLock::wake_writer(_1) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageDead(_8);\n        StorageDead(_6);\n        goto -> bb33;\n    }\n    bb11: {\n        StorageDead(_6);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = _2;\n        StorageLive(_18);\n        _19 = CheckedAdd(sys::sync::rwlock::futex::READERS_WAITING, sys::sync::rwlock::futex::WRITERS_WAITING);\n        assert(!move (_19.1: bool), \"attempt to compute `{} + {}`, which would overflow\", sys::sync::rwlock::futex::READERS_WAITING, sys::sync::rwlock::futex::WRITERS_WAITING) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _18 = move (_19.0: u32);\n        _16 = Eq(move _17, move _18);\n        switchInt(move _16) -> [0: bb21, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_18);\n        StorageDead(_17);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = &((*_1).0: core::sync::atomic::AtomicU32);\n        StorageLive(_24);\n        _24 = _2;\n        StorageLive(_25);\n        _25 = core::sync::atomic::Ordering::Relaxed;\n        StorageLive(_26);\n        _26 = core::sync::atomic::Ordering::Relaxed;\n        _22 = core::sync::atomic::AtomicU32::compare_exchange(move _23, move _24, sys::sync::rwlock::futex::READERS_WAITING, move _25, move _26) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _21 = &_22;\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        _20 = core::result::Result::<u32, u32>::is_err(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _20) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb32;\n    }\n    bb17: {\n        StorageDead(_22);\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_27);\n        _27 = sys::sync::rwlock::futex::RwLock::wake_writer(_1) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        switchInt(move _27) -> [0: bb20, otherwise: bb19];\n    }\n    bb19: {\n        StorageDead(_27);\n        goto -> bb32;\n    }\n    bb20: {\n        StorageDead(_27);\n        _2 = sys::sync::rwlock::futex::READERS_WAITING;\n        goto -> bb22;\n    }\n    bb21: {\n        StorageDead(_18);\n        StorageDead(_17);\n        goto -> bb22;\n    }\n    bb22: {\n        StorageDead(_16);\n        StorageLive(_28);\n        StorageLive(_29);\n        _29 = _2;\n        _28 = Eq(move _29, sys::sync::rwlock::futex::READERS_WAITING);\n        switchInt(move _28) -> [0: bb30, otherwise: bb23];\n    }\n    bb23: {\n        StorageDead(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &((*_1).0: core::sync::atomic::AtomicU32);\n        StorageLive(_34);\n        _34 = _2;\n        StorageLive(_35);\n        _35 = core::sync::atomic::Ordering::Relaxed;\n        StorageLive(_36);\n        _36 = core::sync::atomic::Ordering::Relaxed;\n        _32 = core::sync::atomic::AtomicU32::compare_exchange(move _33, move _34, 0_u32, move _35, move _36) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _31 = &_32;\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_33);\n        _30 = core::result::Result::<u32, u32>::is_ok(move _31) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _30) -> [0: bb28, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_32);\n        StorageDead(_31);\n        _38 = &((*_1).0: core::sync::atomic::AtomicU32);\n        _37 = sys::pal::unix::futex::futex_wake_all(_38) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        goto -> bb29;\n    }\n    bb28: {\n        StorageDead(_32);\n        StorageDead(_31);\n        goto -> bb29;\n    }\n    bb29: {\n        StorageDead(_30);\n        goto -> bb31;\n    }\n    bb30: {\n        StorageDead(_29);\n        goto -> bb31;\n    }\n    bb31: {\n        StorageDead(_28);\n        goto -> bb33;\n    }\n    bb32: {\n        StorageDead(_16);\n        goto -> bb33;\n    }\n    bb33: {\n        return;\n    }\n}\n",
  "doc": " Wakes up waiting threads after unlocking.\n\n If both are waiting, this will wake up only one writer, but will fall\n back to waking up readers if there was no writer to wake up.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}