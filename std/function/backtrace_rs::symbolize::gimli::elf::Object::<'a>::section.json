{
  "name": "backtrace_rs::symbolize::gimli::elf::Object::<'a>::section",
  "safe": true,
  "callees": {
    "backtrace_rs::symbolize::gimli::elf::Object::<'a>::section_header": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "backtrace_rs::symbolize::gimli::elf::Object": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "object::read::elf::SectionHeader::data": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the section data.\n\n Returns `Ok(&[])` if the section has no data.\n Returns `Err` for invalid values.\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "object::read::elf::SectionHeader::sh_flags": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::convert::Into::into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into the (usually inferred) input type.\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "object::Bytes::<'data>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return a reference to a `Pod` struct at the start of the byte slice.\n\n Modifies the byte slice to start after the bytes.\n\n Returns an error if there are too few bytes or the slice is incorrectly aligned.\n",
      "adt": {}
    },
    "object::read::elf::CompressionHeader::ch_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "object::read::elf::CompressionHeader::ch_size": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::convert::TryFrom::try_from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "backtrace_rs::symbolize::gimli::stash::Stash::allocate": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates a buffer of the specified size and returns a mutable reference\n to it.\n",
      "adt": {
        "backtrace_rs::symbolize::gimli::stash::Stash": "ImmutableAsArgument"
      }
    },
    "backtrace_rs::symbolize::gimli::elf::decompress_zlib": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::str::<impl str>::starts_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the given pattern matches a prefix of this\n string slice.\n\n Returns `false` if it does not.\n\n The [pattern] can be a `&str`, in which case this function will return true if\n the `&str` is a prefix of this string slice.\n\n The [pattern] can also be a [`char`], a slice of [`char`]s, or a\n function or closure that determines if a character matches.\n These will only be checked against the first character of this string slice.\n Look at the second example below regarding behavior for slices of [`char`]s.\n\n [`char`]: prim@char\n [pattern]: self::pattern\n\n # Examples\n\n ```\n let bananas = \"bananas\";\n\n assert!(bananas.starts_with(\"bana\"));\n assert!(!bananas.starts_with(\"nana\"));\n ```\n\n ```\n let bananas = \"bananas\";\n\n // Note that both of these assert successfully.\n assert!(bananas.starts_with(&['b', 'a', 'n', 'a']));\n assert!(bananas.starts_with(&['a', 'b', 'c', 'd']));\n ```\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "core::str::<impl str>::as_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a string slice to a byte slice. To convert the byte slice back\n into a string slice, use the [`from_utf8`] function.\n\n # Examples\n\n ```\n let bytes = \"bors\".as_bytes();\n assert_eq!(b\"bors\", bytes);\n ```\n",
      "adt": {}
    },
    "object::read::elf::SectionTable::<'data, Elf, R>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Iterate over the section headers.\n\n This includes the null section at index 0, which you will usually need to skip.\n",
      "adt": {}
    },
    "core::iter::Iterator::filter_map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator that both filters and maps.\n\n The returned iterator yields only the `value`s for which the supplied\n closure returns `Some(value)`.\n\n `filter_map` can be used to make chains of [`filter`] and [`map`] more\n concise. The example below shows how a `map().filter().map()` can be\n shortened to a single call to `filter_map`.\n\n [`filter`]: Iterator::filter\n [`map`]: Iterator::map\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];\n\n let mut iter = a.iter().filter_map(|s| s.parse().ok());\n\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(5));\n assert_eq!(iter.next(), None);\n ```\n\n Here's the same example, but with [`filter`] and [`map`]:\n\n ```\n let a = [\"1\", \"two\", \"NaN\", \"four\", \"5\"];\n let mut iter = a.iter().map(|s| s.parse()).filter(|s| s.is_ok()).map(|s| s.unwrap());\n assert_eq!(iter.next(), Some(1));\n assert_eq!(iter.next(), Some(5));\n assert_eq!(iter.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "object::Bytes::<'data>::read_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return a reference to the given number of bytes at the start of the byte slice.\n\n Modifies the byte slice to start after the bytes.\n\n Returns an error if there are too few bytes.\n",
      "adt": {}
    },
    "core::cmp::PartialEq::ne": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `!=`. The default implementation is almost always sufficient,\n and should not be overridden without very good reason.\n",
      "adt": {}
    },
    "object::U32Bytes::<E>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Return the value as a native endian value.\n",
      "adt": {}
    }
  },
  "adts": {
    "backtrace_rs::symbolize::gimli::elf::Object": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 18220, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 18275, kind: RigidTy(Adt(AdtDef(DefId { id: 12794, name: \"object::elf::SectionHeader64\" }), GenericArgs([Type(Ty { id: 18141, kind: RigidTy(Adt(AdtDef(DefId { id: 12735, name: \"object::LittleEndian\" }), GenericArgs([]))) })]))) }, Not)) })])"
    ],
    "object::elf::SectionHeader64": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18231, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 18276, kind: RigidTy(Adt(AdtDef(DefId { id: 12806, name: \"object::elf::CompressionHeader64\" }), GenericArgs([Type(Ty { id: 18141, kind: RigidTy(Adt(AdtDef(DefId { id: 12735, name: \"object::LittleEndian\" }), GenericArgs([]))) })]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18220, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 18275, kind: RigidTy(Adt(AdtDef(DefId { id: 12794, name: \"object::elf::SectionHeader64\" }), GenericArgs([Type(Ty { id: 18141, kind: RigidTy(Adt(AdtDef(DefId { id: 12735, name: \"object::LittleEndian\" }), GenericArgs([]))) })]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18247, kind: RigidTy(Adt(AdtDef(DefId { id: 12780, name: \"object::Bytes\" }), GenericArgs([Lifetime(Region { kind: ReErased })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 18254, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 18271, kind: RigidTy(Adt(AdtDef(DefId { id: 12793, name: \"object::U32Bytes\" }), GenericArgs([Type(Ty { id: 18253, kind: RigidTy(Adt(AdtDef(DefId { id: 12792, name: \"object::BigEndian\" }), GenericArgs([]))) })]))) }, Not)) })])"
    ],
    "object::Bytes": [
      "Plain",
      "Unknown([Field(0, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })])",
      "MutRef"
    ],
    "object::elf::CompressionHeader64": [
      "Ref"
    ],
    "backtrace_rs::symbolize::gimli::stash::Stash": [
      "Ref"
    ],
    "core::ops::RangeFrom": [
      "Plain"
    ],
    "object::read::elf::SectionTable": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain"
    ],
    "core::iter::FilterMap": [
      "Plain",
      "MutRef"
    ],
    "object::U32Bytes": [
      "Ref",
      "Plain",
      "Deref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::elf::Object::<'a>::section"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:215:5: 275:6",
  "src": "pub fn section(&self, stash: &'a Stash, name: &str) -> Option<&'a [u8]> {\n        if let Some(section) = self.section_header(name) {\n            let mut data = Bytes(section.data(self.endian, self.data).ok()?);\n\n            // Check for DWARF-standard (gABI) compression, i.e., as generated\n            // by ld's `--compress-debug-sections=zlib-gabi` and\n            // `--compress-debug-sections=zstd` flags.\n            let flags: u64 = section.sh_flags(self.endian).into();\n            if (flags & u64::from(SHF_COMPRESSED)) == 0 {\n                // Not compressed.\n                return Some(data.0);\n            }\n\n            let header = data.read::<<Elf as FileHeader>::CompressionHeader>().ok()?;\n            match header.ch_type(self.endian) {\n                ELFCOMPRESS_ZLIB => {\n                    let size = usize::try_from(header.ch_size(self.endian)).ok()?;\n                    let buf = stash.allocate(size);\n                    decompress_zlib(data.0, buf)?;\n                    return Some(buf);\n                }\n                #[cfg(feature = \"ruzstd\")]\n                ELFCOMPRESS_ZSTD => {\n                    let size = usize::try_from(header.ch_size(self.endian)).ok()?;\n                    let buf = stash.allocate(size);\n                    decompress_zstd(data.0, buf)?;\n                    return Some(buf);\n                }\n                _ => return None, // Unknown compression type.\n            }\n        }\n\n        // Check for the nonstandard GNU compression format, i.e., as generated\n        // by ld's `--compress-debug-sections=zlib-gnu` flag. This means that if\n        // we're actually asking for `.debug_info` then we need to look up a\n        // section named `.zdebug_info`.\n        if !name.starts_with(\".debug_\") {\n            return None;\n        }\n        let debug_name = name[7..].as_bytes();\n        let compressed_section = self\n            .sections\n            .iter()\n            .filter_map(|header| {\n                let name = self.sections.section_name(self.endian, header).ok()?;\n                if name.starts_with(b\".zdebug_\") && &name[8..] == debug_name {\n                    Some(header)\n                } else {\n                    None\n                }\n            })\n            .next()?;\n        let mut data = Bytes(compressed_section.data(self.endian, self.data).ok()?);\n        if data.read_bytes(8).ok()?.0 != b\"ZLIB\\0\\0\\0\\0\" {\n            return None;\n        }\n        let size = usize::try_from(data.read::<object::U32Bytes<_>>().ok()?.get(BigEndian)).ok()?;\n        let buf = stash.allocate(size);\n        decompress_zlib(data.0, buf)?;\n        Some(buf)\n    }",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::Object::<'a>::section(_1: &backtrace_rs::symbolize::gimli::elf::Object<'_>, _2: &backtrace_rs::symbolize::gimli::stash::Stash, _3: &str) -> core::option::Option<&[u8]> {\n    let mut _0: core::option::Option<&[u8]>;\n    let mut _4: core::option::Option<&object::elf::SectionHeader64<object::LittleEndian>>;\n    let mut _5: isize;\n    let  _6: &object::elf::SectionHeader64<object::LittleEndian>;\n    let mut _7: object::Bytes<'_>;\n    let mut _8: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &[u8]>;\n    let mut _9: core::option::Option<&[u8]>;\n    let mut _10: core::result::Result<&[u8], object::Error>;\n    let mut _11: &[u8];\n    let mut _12: isize;\n    let  _13: &[u8];\n    let  _14: u64;\n    let mut _15: u64;\n    let mut _16: u64;\n    let mut _17: u64;\n    let mut _18: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &object::elf::CompressionHeader64<object::LittleEndian>>;\n    let mut _19: core::option::Option<&object::elf::CompressionHeader64<object::LittleEndian>>;\n    let mut _20: core::result::Result<&object::elf::CompressionHeader64<object::LittleEndian>, ()>;\n    let mut _21: &mut object::Bytes<'_>;\n    let mut _22: isize;\n    let  _23: &object::elf::CompressionHeader64<object::LittleEndian>;\n    let mut _24: u32;\n    let mut _25: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;\n    let mut _26: core::option::Option<usize>;\n    let mut _27: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _28: u64;\n    let mut _29: isize;\n    let  _30: usize;\n    let  _31: &mut [u8];\n    let mut _32: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>>;\n    let mut _33: core::option::Option<()>;\n    let mut _34: isize;\n    let mut _35: &[u8];\n    let mut _36: bool;\n    let  _37: &[u8];\n    let  _38: &str;\n    let mut _39: core::ops::RangeFrom<usize>;\n    let mut _40: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &object::elf::SectionHeader64<object::LittleEndian>>;\n    let mut _41: core::option::Option<&object::elf::SectionHeader64<object::LittleEndian>>;\n    let mut _42: &mut core::iter::FilterMap<core::slice::Iter<'_, object::elf::SectionHeader64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:258:25: 258:33}>;\n    let mut _43: core::iter::FilterMap<core::slice::Iter<'_, object::elf::SectionHeader64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:258:25: 258:33}>;\n    let mut _44: core::slice::Iter<'_, object::elf::SectionHeader64<object::LittleEndian>>;\n    let mut _45: &object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>;\n    let mut _46: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:258:25: 258:33};\n    let mut _47: &&[u8];\n    let mut _48: isize;\n    let  _49: &object::elf::SectionHeader64<object::LittleEndian>;\n    let mut _50: object::Bytes<'_>;\n    let mut _51: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &[u8]>;\n    let mut _52: core::option::Option<&[u8]>;\n    let mut _53: core::result::Result<&[u8], object::Error>;\n    let mut _54: &[u8];\n    let mut _55: isize;\n    let  _56: &[u8];\n    let mut _57: bool;\n    let mut _58: &&[u8];\n    let  _59: object::Bytes<'_>;\n    let mut _60: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, object::Bytes<'_>>;\n    let mut _61: core::option::Option<object::Bytes<'_>>;\n    let mut _62: core::result::Result<object::Bytes<'_>, ()>;\n    let mut _63: &mut object::Bytes<'_>;\n    let mut _64: isize;\n    let  _65: object::Bytes<'_>;\n    let mut _66: &&[u8; 8];\n    let mut _67: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, usize>;\n    let mut _68: core::option::Option<usize>;\n    let mut _69: core::result::Result<usize, core::num::TryFromIntError>;\n    let mut _70: u32;\n    let mut _71: object::U32Bytes<object::BigEndian>;\n    let mut _72: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, &object::U32Bytes<object::BigEndian>>;\n    let mut _73: core::option::Option<&object::U32Bytes<object::BigEndian>>;\n    let mut _74: core::result::Result<&object::U32Bytes<object::BigEndian>, ()>;\n    let mut _75: &mut object::Bytes<'_>;\n    let mut _76: isize;\n    let  _77: &object::U32Bytes<object::BigEndian>;\n    let mut _78: isize;\n    let  _79: usize;\n    let  _80: &mut [u8];\n    let mut _81: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>>;\n    let mut _82: core::option::Option<()>;\n    let mut _83: isize;\n    let mut _84: &[u8];\n    let mut _85: &[u8];\n    let mut _86: &[u8];\n    let mut _87: &[u8];\n    debug self => _1;\n    debug stash => _2;\n    debug name => _3;\n    debug section => _6;\n    debug data => _7;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _13;\n    debug flags => _14;\n    debug header => _23;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _23;\n    debug size => _30;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _30;\n    debug buf => _31;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => ();\n    debug debug_name => _37;\n    debug compressed_section => _49;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _49;\n    debug data => _50;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _56;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _65;\n    debug size => _79;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _77;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _79;\n    debug buf => _80;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => ();\n    bb0: {\n        StorageLive(_4);\n        _4 = backtrace_rs::symbolize::gimli::elf::Object::<'_>::section_header(_1, _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = discriminant(_4);\n        switchInt(move _5) -> [1: bb2, 0: bb37, otherwise: bb6];\n    }\n    bb2: {\n        _6 = ((_4 as variant#1).0: &object::elf::SectionHeader64<object::LittleEndian>);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = ((*_1).1: &[u8]);\n        _10 = <object::elf::SectionHeader64<object::LittleEndian> as object::read::elf::SectionHeader>::data::<'_, &[u8]>(_6, object::LittleEndian, move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _9 = core::result::Result::<&[u8], object::Error>::ok(move _10) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_10);\n        _8 = <core::option::Option<&[u8]> as core::ops::Try>::branch(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        _12 = discriminant(_8);\n        switchInt(move _12) -> [0: bb7, 1: bb8, otherwise: bb6];\n    }\n    bb6: {\n        unreachable;\n    }\n    bb7: {\n        _13 = ((_8 as variant#0).0: &[u8]);\n        _7 = Bytes(_13);\n        StorageDead(_8);\n        StorageLive(_15);\n        _15 = <object::elf::SectionHeader64<object::LittleEndian> as object::read::elf::SectionHeader>::sh_flags(_6, object::LittleEndian) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_8);\n        goto -> bb93;\n    }\n    bb10: {\n        _14 = <u64 as core::convert::Into<u64>>::into(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = <u64 as core::convert::From<u32>>::from(object::elf::SHF_COMPRESSED) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _16 = BitAnd(_14, move _17);\n        StorageDead(_17);\n        switchInt(move _16) -> [0: bb13, otherwise: bb14];\n    }\n    bb13: {\n        StorageDead(_16);\n        _85 = (_7.0: &[u8]);\n        _0 = core::option::Option::Some(_85);\n        goto -> bb92;\n    }\n    bb14: {\n        StorageDead(_16);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        _21 = &mut _7;\n        _20 = object::Bytes::<'_>::read::<object::elf::CompressionHeader64<object::LittleEndian>>(move _21) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_21);\n        _19 = core::result::Result::<&object::elf::CompressionHeader64<object::LittleEndian>, ()>::ok(move _20) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_20);\n        _18 = <core::option::Option<&object::elf::CompressionHeader64<object::LittleEndian>> as core::ops::Try>::branch(move _19) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_19);\n        _22 = discriminant(_18);\n        switchInt(move _22) -> [0: bb18, 1: bb19, otherwise: bb6];\n    }\n    bb18: {\n        _23 = ((_18 as variant#0).0: &object::elf::CompressionHeader64<object::LittleEndian>);\n        StorageDead(_18);\n        StorageLive(_24);\n        _24 = <object::elf::CompressionHeader64<object::LittleEndian> as object::read::elf::CompressionHeader>::ch_type(_23, object::LittleEndian) -> [return: bb21, unwind unreachable];\n    }\n    bb19: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_18);\n        goto -> bb91;\n    }\n    bb21: {\n        switchInt(_24) -> [1: bb23, otherwise: bb22];\n    }\n    bb22: {\n        _0 = core::option::Option::None;\n        goto -> bb90;\n    }\n    bb23: {\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = <object::elf::CompressionHeader64<object::LittleEndian> as object::read::elf::CompressionHeader>::ch_size(_23, object::LittleEndian) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _27 = <usize as core::convert::TryFrom<u64>>::try_from(move _28) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_28);\n        _26 = core::result::Result::<usize, core::num::TryFromIntError>::ok(move _27) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_27);\n        _25 = <core::option::Option<usize> as core::ops::Try>::branch(move _26) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_26);\n        _29 = discriminant(_25);\n        switchInt(move _29) -> [0: bb28, 1: bb29, otherwise: bb6];\n    }\n    bb28: {\n        _30 = ((_25 as variant#0).0: usize);\n        StorageDead(_25);\n        _31 = backtrace_rs::symbolize::gimli::stash::Stash::allocate(_2, _30) -> [return: bb31, unwind unreachable];\n    }\n    bb29: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_25);\n        goto -> bb89;\n    }\n    bb31: {\n        StorageLive(_32);\n        StorageLive(_33);\n        _86 = (_7.0: &[u8]);\n        _33 = backtrace_rs::symbolize::gimli::elf::decompress_zlib(_86, _31) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        _32 = <core::option::Option<()> as core::ops::Try>::branch(move _33) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_33);\n        _34 = discriminant(_32);\n        switchInt(move _34) -> [0: bb34, 1: bb35, otherwise: bb6];\n    }\n    bb34: {\n        StorageDead(_32);\n        StorageLive(_35);\n        _35 = &(*_31);\n        _0 = core::option::Option::Some(move _35);\n        StorageDead(_35);\n        goto -> bb88;\n    }\n    bb35: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        StorageDead(_32);\n        goto -> bb88;\n    }\n    bb37: {\n        StorageDead(_4);\n        StorageLive(_36);\n        _36 = core::str::<impl str>::starts_with::<&str>(_3, \".debug_\") -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        switchInt(move _36) -> [0: bb40, otherwise: bb39];\n    }\n    bb39: {\n        StorageDead(_36);\n        StorageLive(_37);\n        StorageLive(_39);\n        _39 = RangeFrom(7_usize);\n        _38 = <str as core::ops::Index<core::ops::RangeFrom<usize>>>::index(_3, move _39) -> [return: bb41, unwind unreachable];\n    }\n    bb40: {\n        _0 = core::option::Option::None;\n        StorageDead(_36);\n        goto -> bb94;\n    }\n    bb41: {\n        StorageDead(_39);\n        _37 = core::str::<impl str>::as_bytes(_38) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageLive(_40);\n        StorageLive(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = &((*_1).2: object::read::elf::SectionTable<'_, object::elf::FileHeader64<object::LittleEndian>>);\n        _44 = object::read::elf::SectionTable::<'_, object::elf::FileHeader64<object::LittleEndian>>::iter(move _45) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_45);\n        StorageLive(_46);\n        StorageLive(_47);\n        _47 = &_37;\n        _46 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:258:25: 258:33}(_1, move _47);\n        StorageDead(_47);\n        _43 = <core::slice::Iter<'_, object::elf::SectionHeader64<object::LittleEndian>> as core::iter::Iterator>::filter_map::<&object::elf::SectionHeader64<object::LittleEndian>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:258:25: 258:33}>(move _44, move _46) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        _42 = &mut _43;\n        StorageDead(_46);\n        StorageDead(_44);\n        _41 = <core::iter::FilterMap<core::slice::Iter<'_, object::elf::SectionHeader64<object::LittleEndian>>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:258:25: 258:33}> as core::iter::Iterator>::next(move _42) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageDead(_42);\n        _40 = <core::option::Option<&object::elf::SectionHeader64<object::LittleEndian>> as core::ops::Try>::branch(move _41) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_41);\n        _48 = discriminant(_40);\n        switchInt(move _48) -> [0: bb47, 1: bb48, otherwise: bb6];\n    }\n    bb47: {\n        _49 = ((_40 as variant#0).0: &object::elf::SectionHeader64<object::LittleEndian>);\n        StorageDead(_43);\n        StorageDead(_40);\n        StorageLive(_50);\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = ((*_1).1: &[u8]);\n        _53 = <object::elf::SectionHeader64<object::LittleEndian> as object::read::elf::SectionHeader>::data::<'_, &[u8]>(_49, object::LittleEndian, move _54) -> [return: bb50, unwind unreachable];\n    }\n    bb48: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_43);\n        StorageDead(_40);\n        goto -> bb87;\n    }\n    bb50: {\n        StorageDead(_54);\n        _52 = core::result::Result::<&[u8], object::Error>::ok(move _53) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_53);\n        _51 = <core::option::Option<&[u8]> as core::ops::Try>::branch(move _52) -> [return: bb52, unwind unreachable];\n    }\n    bb52: {\n        StorageDead(_52);\n        _55 = discriminant(_51);\n        switchInt(move _55) -> [0: bb53, 1: bb54, otherwise: bb6];\n    }\n    bb53: {\n        _56 = ((_51 as variant#0).0: &[u8]);\n        _50 = Bytes(_56);\n        StorageDead(_51);\n        StorageLive(_57);\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = &mut _50;\n        _62 = object::Bytes::<'_>::read_bytes(move _63, 8_usize) -> [return: bb56, unwind unreachable];\n    }\n    bb54: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_51);\n        goto -> bb86;\n    }\n    bb56: {\n        StorageDead(_63);\n        _61 = core::result::Result::<object::Bytes<'_>, ()>::ok(move _62) -> [return: bb57, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_62);\n        _60 = <core::option::Option<object::Bytes<'_>> as core::ops::Try>::branch(move _61) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_61);\n        _64 = discriminant(_60);\n        switchInt(move _64) -> [0: bb59, 1: bb60, otherwise: bb6];\n    }\n    bb59: {\n        StorageLive(_65);\n        _65 = ((_60 as variant#0).0: object::Bytes<'_>);\n        _59 = _65;\n        StorageDead(_65);\n        _58 = &(_59.0: &[u8]);\n        StorageLive(_66);\n        _66 = backtrace_rs::symbolize::gimli::elf::Object::<'_>::section::promoted[0];\n        _57 = <&[u8] as core::cmp::PartialEq<&[u8; 8]>>::ne(move _58, move _66) -> [return: bb62, unwind unreachable];\n    }\n    bb60: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_58);\n        goto -> bb85;\n    }\n    bb62: {\n        switchInt(move _57) -> [0: bb64, otherwise: bb63];\n    }\n    bb63: {\n        StorageDead(_66);\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_58);\n        _0 = core::option::Option::None;\n        goto -> bb85;\n    }\n    bb64: {\n        StorageDead(_66);\n        StorageDead(_60);\n        StorageDead(_59);\n        StorageDead(_58);\n        StorageDead(_57);\n        StorageLive(_67);\n        StorageLive(_68);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        StorageLive(_72);\n        StorageLive(_73);\n        StorageLive(_74);\n        StorageLive(_75);\n        _75 = &mut _50;\n        _74 = object::Bytes::<'_>::read::<object::U32Bytes<object::BigEndian>>(move _75) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        StorageDead(_75);\n        _73 = core::result::Result::<&object::U32Bytes<object::BigEndian>, ()>::ok(move _74) -> [return: bb66, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_74);\n        _72 = <core::option::Option<&object::U32Bytes<object::BigEndian>> as core::ops::Try>::branch(move _73) -> [return: bb67, unwind unreachable];\n    }\n    bb67: {\n        StorageDead(_73);\n        _76 = discriminant(_72);\n        switchInt(move _76) -> [0: bb68, 1: bb69, otherwise: bb6];\n    }\n    bb68: {\n        _77 = ((_72 as variant#0).0: &object::U32Bytes<object::BigEndian>);\n        _71 = (*_77);\n        _70 = object::U32Bytes::<object::BigEndian>::get(move _71, object::BigEndian) -> [return: bb71, unwind unreachable];\n    }\n    bb69: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_71);\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageDead(_68);\n        goto -> bb83;\n    }\n    bb71: {\n        StorageDead(_71);\n        _69 = <usize as core::convert::TryFrom<u32>>::try_from(move _70) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        StorageDead(_70);\n        _68 = core::result::Result::<usize, core::num::TryFromIntError>::ok(move _69) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        StorageDead(_69);\n        _67 = <core::option::Option<usize> as core::ops::Try>::branch(move _68) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        StorageDead(_68);\n        _78 = discriminant(_67);\n        switchInt(move _78) -> [0: bb75, 1: bb76, otherwise: bb6];\n    }\n    bb75: {\n        _79 = ((_67 as variant#0).0: usize);\n        StorageDead(_72);\n        StorageDead(_67);\n        _80 = backtrace_rs::symbolize::gimli::stash::Stash::allocate(_2, _79) -> [return: bb77, unwind unreachable];\n    }\n    bb76: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb83, unwind unreachable];\n    }\n    bb77: {\n        StorageLive(_81);\n        StorageLive(_82);\n        _87 = (_50.0: &[u8]);\n        _82 = backtrace_rs::symbolize::gimli::elf::decompress_zlib(_87, _80) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        _81 = <core::option::Option<()> as core::ops::Try>::branch(move _82) -> [return: bb79, unwind unreachable];\n    }\n    bb79: {\n        StorageDead(_82);\n        _83 = discriminant(_81);\n        switchInt(move _83) -> [0: bb80, 1: bb81, otherwise: bb6];\n    }\n    bb80: {\n        StorageDead(_81);\n        StorageLive(_84);\n        _84 = &(*_80);\n        _0 = core::option::Option::Some(move _84);\n        StorageDead(_84);\n        StorageDead(_50);\n        StorageDead(_37);\n        goto -> bb94;\n    }\n    bb81: {\n        _0 = <core::option::Option<&[u8]> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        StorageDead(_81);\n        goto -> bb84;\n    }\n    bb83: {\n        StorageDead(_72);\n        StorageDead(_67);\n        goto -> bb84;\n    }\n    bb84: {\n        goto -> bb86;\n    }\n    bb85: {\n        StorageDead(_57);\n        goto -> bb86;\n    }\n    bb86: {\n        StorageDead(_50);\n        goto -> bb87;\n    }\n    bb87: {\n        StorageDead(_37);\n        goto -> bb94;\n    }\n    bb88: {\n        goto -> bb89;\n    }\n    bb89: {\n        goto -> bb90;\n    }\n    bb90: {\n        StorageDead(_24);\n        goto -> bb91;\n    }\n    bb91: {\n        goto -> bb92;\n    }\n    bb92: {\n        goto -> bb93;\n    }\n    bb93: {\n        StorageDead(_7);\n        StorageDead(_4);\n        goto -> bb94;\n    }\n    bb94: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}