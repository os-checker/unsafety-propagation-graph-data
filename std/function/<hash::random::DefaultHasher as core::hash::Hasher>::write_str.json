{
  "name": "<hash::random::DefaultHasher as core::hash::Hasher>::write_str",
  "safe": true,
  "callees": {
    "core::hash::Hasher::write_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a single `str` into this hasher.\n\n If you're implementing [`Hash`], you generally do not need to call this,\n as the `impl Hash for str` does, so you should prefer that instead.\n\n This includes the domain separator for prefix-freedom, so you should\n **not** call `Self::write_length_prefix` before calling this.\n\n # Note to Implementers\n\n There are at least two reasonable default ways to implement this.\n Which one will be the default is not yet decided, so for now\n you probably want to override it specifically.\n\n ## The general answer\n\n It's always correct to implement this with a length prefix:\n\n ```\n # #![feature(hasher_prefixfree_extras)]\n # struct Foo;\n # impl std::hash::Hasher for Foo {\n # fn finish(&self) -> u64 { unimplemented!() }\n # fn write(&mut self, _bytes: &[u8]) { unimplemented!() }\n fn write_str(&mut self, s: &str) {\n     self.write_length_prefix(s.len());\n     self.write(s.as_bytes());\n }\n # }\n ```\n\n And, if your `Hasher` works in `usize` chunks, this is likely a very\n efficient way to do it, as anything more complicated may well end up\n slower than just running the round with the length.\n\n ## If your `Hasher` works byte-wise\n\n One nice thing about `str` being UTF-8 is that the `b'\\xFF'` byte\n never happens.  That means that you can append that to the byte stream\n being hashed and maintain prefix-freedom:\n\n ```\n # #![feature(hasher_prefixfree_extras)]\n # struct Foo;\n # impl std::hash::Hasher for Foo {\n # fn finish(&self) -> u64 { unimplemented!() }\n # fn write(&mut self, _bytes: &[u8]) { unimplemented!() }\n fn write_str(&mut self, s: &str) {\n     self.write(s.as_bytes());\n     self.write_u8(0xff);\n }\n # }\n ```\n\n This does require that your implementation not add extra padding, and\n thus generally requires that you maintain a buffer, running a round\n only once that buffer is full (or `finish` is called).\n\n That's because if `write` pads data out to a fixed chunk size, it's\n likely that it does it in such a way that `\"a\"` and `\"a\\x00\"` would\n end up hashing the same sequence of things, introducing conflicts.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::hash::SipHasher13": [
      "MutRef"
    ],
    "hash::random::DefaultHasher": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<hash::random::DefaultHasher as core::hash::Hasher>::write_str"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/hash/random.rs:137:5: 139:6",
  "src": "fn write_str(&mut self, s: &str) {\n        self.0.write_str(s);\n    }",
  "mir": "fn <hash::random::DefaultHasher as core::hash::Hasher>::write_str(_1: &mut hash::random::DefaultHasher, _2: &str) -> () {\n    let mut _0: ();\n    let  _3: ();\n    let mut _4: &mut core::hash::SipHasher13;\n    debug self => _1;\n    debug s => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &mut ((*_1).0: core::hash::SipHasher13);\n        _3 = <core::hash::SipHasher13 as core::hash::Hasher>::write_str(move _4, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}