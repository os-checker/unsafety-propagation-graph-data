{
  "name": "panic::catch_unwind",
  "safe": true,
  "callees": {
    "panicking::catch_unwind": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2267,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:358:1: 360:2",
  "src": "pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n    unsafe { panicking::catch_unwind(f) }\n}",
  "mir": "fn panic::catch_unwind(_1: F) -> core::result::Result<R, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>> {\n    let mut _0: core::result::Result<R, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>;\n    debug f => _1;\n    bb0: {\n        _0 = panicking::catch_unwind::<R, F>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n\n This function will return `Ok` with the closure's result if the closure does\n not panic, and will return `Err(cause)` if the closure panics. The `cause`\n returned is the object with which panic was originally invoked.\n\n Rust functions that are expected to be called from foreign code that does\n not support unwinding (such as C compiled with `-fno-exceptions`) should be\n defined using `extern \"C\"`, which ensures that if the Rust code panics, it\n is automatically caught and the process is aborted. If this is the desired\n behavior, it is not necessary to use `catch_unwind` explicitly. This\n function should instead be used when more graceful error-handling is needed.\n\n It is **not** recommended to use this function for a general try/catch\n mechanism. The [`Result`] type is more appropriate to use for functions that\n can fail on a regular basis. Additionally, this function is not guaranteed\n to catch all panics, see the \"Notes\" section below.\n\n The closure provided is required to adhere to the [`UnwindSafe`] trait to\n ensure that all captured variables are safe to cross this boundary. The\n purpose of this bound is to encode the concept of [exception safety][rfc] in\n the type system. Most usage of this function should not need to worry about\n this bound as programs are naturally unwind safe without `unsafe` code. If\n it becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to\n quickly assert that the usage here is indeed unwind safe.\n\n [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n\n # Notes\n\n This function **might not catch all Rust panics**. A Rust panic is not\n always implemented via unwinding, but can be implemented by aborting the\n process as well. This function *only* catches unwinding panics, not those\n that abort the process.\n\n If a custom panic hook has been set, it will be invoked before the panic is\n caught, before unwinding.\n\n Although unwinding into Rust code with a foreign exception (e.g. an\n exception thrown from C++ code, or a `panic!` in Rust code compiled or\n linked with a different runtime) via an appropriate ABI (e.g. `\"C-unwind\"`)\n is permitted, catching such an exception using this function will have one\n of two behaviors, and it is unspecified which will occur:\n\n * The process aborts, after executing all destructors of `f` and the\n   functions it called.\n * The function returns a `Result::Err` containing an opaque type.\n\n Finally, be **careful in how you drop the result of this function**. If it\n is `Err`, it contains the panic payload, and dropping that may in turn\n panic!\n\n # Examples\n\n ```\n use std::panic;\n\n let result = panic::catch_unwind(|| {\n     println!(\"hello!\");\n });\n assert!(result.is_ok());\n\n let result = panic::catch_unwind(|| {\n     panic!(\"oh no!\");\n });\n assert!(result.is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}