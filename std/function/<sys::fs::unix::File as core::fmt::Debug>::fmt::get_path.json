{
  "name": "<sys::fs::unix::File as core::fmt::Debug>::fmt::get_path",
  "safe": true,
  "callees": {
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "alloc_crate::string::ToString::to_string": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts the given value to a `String`.\n\n # Examples\n\n ```\n let i = 5;\n let five = String::from(\"5\");\n\n assert_eq!(five, i.to_string());\n ```\n",
      "adt": {}
    },
    "path::PathBuf::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends `self` with `path`.\n\n If `path` is absolute, it replaces the current path.\n\n On Windows:\n\n * if `path` has a root but no prefix (e.g., `\\windows`), it\n   replaces everything except for the prefix (if any) of `self`.\n * if `path` has a prefix but no root, it replaces `self`.\n * if `self` has a verbatim prefix (e.g. `\\\\?\\C:\\windows`)\n   and `path` is not empty, the new path is normalized: all references\n   to `.` and `..` are removed.\n\n Consider using [`Path::join`] if you need a new `PathBuf` instead of\n using this function on a cloned `PathBuf`.\n\n # Examples\n\n Pushing a relative path extends the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"file.bk\");\n assert_eq!(path, PathBuf::from(\"/tmp/file.bk\"));\n ```\n\n Pushing an absolute path replaces the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"/etc\");\n assert_eq!(path, PathBuf::from(\"/etc\"));\n ```\n",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "sys::pal::common::small_c_string::run_path_with_cstr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `Result<T, E>` to [`Option<T>`].\n\n Converts `self` into an [`Option<T>`], consuming `self`,\n and discarding the error, if any.\n\n # Examples\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.ok(), Some(2));\n\n let x: Result<u32, &str> = Err(\"Nothing here\");\n assert_eq!(x.ok(), None);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "path::PathBuf": [
      "Plain",
      "MutRef",
      "Ref"
    ],
    "alloc_crate::string::String": [
      "Plain",
      "Ref"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<sys::fs::unix::File as core::fmt::Debug>::fmt::get_path"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1839:9: 1843:10",
  "src": "fn get_path(fd: c_int) -> Option<PathBuf> {\n            let mut p = PathBuf::from(\"/proc/self/fd\");\n            p.push(&fd.to_string());\n            run_path_with_cstr(&p, &readlink).ok()\n        }",
  "mir": "fn <sys::fs::unix::File as core::fmt::Debug>::fmt::get_path(_1: i32) -> core::option::Option<path::PathBuf> {\n    let mut _0: core::option::Option<path::PathBuf>;\n    let mut _2: path::PathBuf;\n    let  _3: ();\n    let mut _4: &mut path::PathBuf;\n    let mut _5: &alloc_crate::string::String;\n    let  _6: alloc_crate::string::String;\n    let mut _7: &i32;\n    let mut _8: core::result::Result<path::PathBuf, io::error::Error>;\n    let  _9: &path::Path;\n    let  _10: &path::PathBuf;\n    let mut _11: &dyn for<'a> core::ops::Fn(&'a core::ffi::CStr) -> core::result::Result<path::PathBuf, io::error::Error>;\n    let  _12: &for<'a> fn(&'a core::ffi::CStr) -> core::result::Result<path::PathBuf, io::error::Error> {sys::fs::unix::readlink};\n    debug fd => _1;\n    debug p => _2;\n    bb0: {\n        StorageLive(_2);\n        _2 = <path::PathBuf as core::convert::From<&str>>::from(\"/proc/self/fd\") -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = &mut _2;\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_1;\n        _6 = <i32 as alloc_crate::string::ToString>::to_string(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = &_6;\n        _3 = path::PathBuf::push::<&alloc_crate::string::String>(move _4, move _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        StorageDead(_4);\n        drop(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageLive(_8);\n        _10 = &_2;\n        _9 = <path::PathBuf as core::ops::Deref>::deref(_10) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_11);\n        _12 = <sys::fs::unix::File as core::fmt::Debug>::fmt::get_path::promoted[0];\n        _11 = _12 as &dyn for<'a> core::ops::Fn(&'a core::ffi::CStr) -> core::result::Result<path::PathBuf, io::error::Error>;\n        _8 = sys::pal::common::small_c_string::run_path_with_cstr::<path::PathBuf>(_9, move _11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_11);\n        _0 = core::result::Result::<path::PathBuf, io::error::Error>::ok(move _8) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        drop(_2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}