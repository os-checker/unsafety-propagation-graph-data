{
  "name": "path::Path::is_file",
  "safe": true,
  "callees": {
    "fs::metadata": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Given a path, queries the file system to get information about a file,\n directory, etc.\n\n This function will traverse symbolic links to query information about the\n destination file.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `stat` function on Unix\n and the `GetFileInformationByHandle` function on Windows.\n Note that, this [may change in the future][changes].\n\n [changes]: io#platform-specific-behavior\n\n # Errors\n\n This function will return an error in the following situations, but is not\n limited to just these cases:\n\n * The user lacks permissions to perform `metadata` call on `path`.\n * `path` does not exist.\n\n # Examples\n\n ```rust,no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let attr = fs::metadata(\"/some/file/path.txt\")?;\n     // inspect attr ...\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Result::unwrap_or_else\n\n # Examples\n\n ```\n let default = 2;\n let x: Result<u32, &str> = Ok(9);\n assert_eq!(x.unwrap_or(default), 9);\n\n let x: Result<u32, &str> = Err(\"error\");\n assert_eq!(x.unwrap_or(default), default);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2437,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:3475:5: 3477:6",
  "src": "pub fn is_file(&self) -> bool {\n        fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n    }",
  "mir": "fn path::Path::is_file(_1: &path::Path) -> bool {\n    let mut _0: bool;\n    let mut _2: core::result::Result<bool, io::error::Error>;\n    let mut _3: core::result::Result<fs::Metadata, io::error::Error>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = fs::metadata::<&path::Path>(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = core::result::Result::<fs::Metadata, io::error::Error>::map::<bool, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:3476:32: 3476:35}>(move _3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:3476:32: 3476:35}) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _0 = core::result::Result::<bool, io::error::Error>::unwrap_or(move _2, false) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns `true` if the path exists on disk and is pointing at a regular file.\n\n This function will traverse symbolic links to query information about the\n destination file.\n\n If you cannot access the metadata of the file, e.g. because of a\n permission error or broken symbolic links, this will return `false`.\n\n # Examples\n\n ```no_run\n use std::path::Path;\n assert_eq!(Path::new(\"./is_a_directory/\").is_file(), false);\n assert_eq!(Path::new(\"a_file.txt\").is_file(), true);\n ```\n\n # See Also\n\n This is a convenience function that coerces errors to false. If you want to\n check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n [`fs::Metadata::is_file`] if it was [`Ok`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`fs::File::open`] or\n [`fs::OpenOptions::open`] for more information.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}