{
  "name": "backtrace_rs::symbolize::gimli::elf::debug_path_exists",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicU8::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    },
    "path::Path::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Directly wraps a string slice as a `Path` slice.\n\n This is a cost-free conversion.\n\n # Examples\n\n ```\n use std::path::Path;\n\n Path::new(\"foo.txt\");\n ```\n\n You can create `Path`s from `String`s, or even other `Path`s:\n\n ```\n use std::path::Path;\n\n let string = String::from(\"foo.txt\");\n let from_string = Path::new(&string);\n let from_path = Path::new(&from_string);\n assert_eq!(from_string, from_path);\n ```\n",
      "adt": {}
    },
    "path::Path::is_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the path exists on disk and is pointing at a directory.\n\n This function will traverse symbolic links to query information about the\n destination file.\n\n If you cannot access the metadata of the file, e.g. because of a\n permission error or broken symbolic links, this will return `false`.\n\n # Examples\n\n ```no_run\n use std::path::Path;\n assert_eq!(Path::new(\"./is_a_directory/\").is_dir(), true);\n assert_eq!(Path::new(\"a_file.txt\").is_dir(), false);\n ```\n\n # See Also\n\n This is a convenience function that coerces errors to false. If you want to\n check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n [`fs::Metadata::is_dir`] if it was [`Ok`].\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicU8::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicU8": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "path::Path": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::elf::debug_path_exists"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/elf.rs:399:1: 419:2",
  "src": "fn debug_path_exists() -> bool {\n    cfg_if::cfg_if! {\n        if #[cfg(any(target_os = \"freebsd\", target_os = \"hurd\", target_os = \"linux\"))] {\n            use core::sync::atomic::{AtomicU8, Ordering};\n            static DEBUG_PATH_EXISTS: AtomicU8 = AtomicU8::new(0);\n\n            let mut exists = DEBUG_PATH_EXISTS.load(Ordering::Relaxed);\n            if exists == 0 {\n                exists = if Path::new(DEBUG_PATH).is_dir() {\n                    1\n                } else {\n                    2\n                };\n                DEBUG_PATH_EXISTS.store(exists, Ordering::Relaxed);\n            }\n            exists == 1\n        } else {\n            false\n        }\n    }\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::elf::debug_path_exists() -> bool {\n    let mut _0: bool;\n    let mut _1: u8;\n    let mut _2: &core::sync::atomic::AtomicU8;\n    let mut _3: core::sync::atomic::Ordering;\n    let mut _4: u8;\n    let mut _5: u8;\n    let mut _6: bool;\n    let  _7: &path::Path;\n    let mut _8: &str;\n    let  _9: ();\n    let mut _10: &core::sync::atomic::AtomicU8;\n    let mut _11: u8;\n    let mut _12: core::sync::atomic::Ordering;\n    let mut _13: u8;\n    debug exists => _1;\n    bb0: {\n        StorageLive(_1);\n        StorageLive(_2);\n        _2 = {alloc678: &core::sync::atomic::AtomicU8};\n        StorageLive(_3);\n        _3 = core::sync::atomic::Ordering::Relaxed;\n        _1 = core::sync::atomic::AtomicU8::load(move _2, move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageDead(_2);\n        StorageLive(_4);\n        _4 = _1;\n        switchInt(move _4) -> [0: bb2, otherwise: bb9];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_8);\n        _8 = backtrace_rs::symbolize::gimli::elf::DEBUG_PATH;\n        _7 = path::Path::new::<str>(move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_8);\n        _6 = path::Path::is_dir(_7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        switchInt(move _6) -> [0: bb6, otherwise: bb5];\n    }\n    bb5: {\n        _5 = 1_u8;\n        goto -> bb7;\n    }\n    bb6: {\n        _5 = 2_u8;\n        goto -> bb7;\n    }\n    bb7: {\n        StorageDead(_6);\n        _1 = move _5;\n        StorageDead(_5);\n        StorageLive(_10);\n        _10 = {alloc678: &core::sync::atomic::AtomicU8};\n        StorageLive(_11);\n        _11 = _1;\n        StorageLive(_12);\n        _12 = core::sync::atomic::Ordering::Relaxed;\n        _9 = core::sync::atomic::AtomicU8::store(move _10, move _11, move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb10;\n    }\n    bb9: {\n        StorageDead(_4);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_13);\n        _13 = _1;\n        _0 = Eq(move _13, 1_u8);\n        StorageDead(_13);\n        StorageDead(_1);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}