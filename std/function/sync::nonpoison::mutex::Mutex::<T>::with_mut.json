{
  "name": "sync::nonpoison::mutex::Mutex::<T>::with_mut",
  "safe": true,
  "callees": {
    "sync::nonpoison::mutex::Mutex::<T>::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Acquires a mutex, blocking the current thread until it is able to do so.\n\n This function will block the local thread until it is available to acquire\n the mutex. Upon returning, the thread is the only thread with the lock\n held. An RAII guard is returned to allow scoped unlock of the lock. When\n the guard goes out of scope, the mutex will be unlocked.\n\n The exact behavior on locking a mutex in the thread which already holds\n the lock is left unspecified. However, this function will not return on\n the second call (it might panic or deadlock, for example).\n\n # Panics\n\n This function might panic when called if the lock is already held by\n the current thread.\n\n # Examples\n\n ```\n #![feature(nonpoison_mutex)]\n\n use std::sync::{Arc, nonpoison::Mutex};\n use std::thread;\n\n let mutex = Arc::new(Mutex::new(0));\n let c_mutex = Arc::clone(&mutex);\n\n thread::spawn(move || {\n     *c_mutex.lock() = 10;\n }).join().expect(\"thread::spawn failed\");\n assert_eq!(*mutex.lock(), 10);\n ```\n",
      "adt": {
        "sync::nonpoison::mutex::Mutex": "ImmutableAsArgument",
        "sync::nonpoison::mutex::MutexGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::nonpoison::mutex::Mutex": [
      "Ref"
    ],
    "sync::nonpoison::mutex::MutexGuard": [
      "Plain",
      "MutRef"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::nonpoison::mutex::Mutex::<T>::with_mut"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/nonpoison/mutex.rs:407:5: 412:6",
  "src": "pub fn with_mut<F, R>(&self, f: F) -> R\n    where\n        F: FnOnce(&mut T) -> R,\n    {\n        f(&mut self.lock())\n    }",
  "mir": "fn sync::nonpoison::mutex::Mutex::<T>::with_mut(_1: &sync::nonpoison::mutex::Mutex<T>, _2: F) -> R {\n    let mut _0: R;\n    let mut _3: (&mut T,);\n    let mut _4: &mut T;\n    let mut _5: &mut sync::nonpoison::mutex::MutexGuard<'_, T>;\n    let mut _6: sync::nonpoison::mutex::MutexGuard<'_, T>;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_6);\n        _6 = sync::nonpoison::mutex::Mutex::<T>::lock(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &mut _6;\n        _4 = <sync::nonpoison::mutex::MutexGuard<'_, T> as core::ops::DerefMut>::deref_mut(_5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = (_4);\n        _0 = <F as core::ops::FnOnce<(&mut T,)>>::call_once(_2, move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        drop(_6) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Acquires the mutex and provides mutable access to the underlying data by passing\n a mutable reference to the given closure.\n\n This method acquires the lock, calls the provided closure with a mutable reference\n to the data, and returns the result of the closure. The lock is released after\n the closure completes, even if it panics.\n\n # Examples\n\n ```\n #![feature(lock_value_accessors, nonpoison_mutex)]\n\n use std::sync::nonpoison::Mutex;\n\n let mutex = Mutex::new(2);\n\n let result = mutex.with_mut(|data| {\n     *data += 3;\n\n     *data + 5\n });\n\n assert_eq!(*mutex.lock(), 5);\n assert_eq!(result, 10);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}