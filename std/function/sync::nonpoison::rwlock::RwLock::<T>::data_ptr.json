{
  "name": "sync::nonpoison::rwlock::RwLock::<T>::data_ptr",
  "safe": true,
  "callees": {
    "core::cell::UnsafeCell::<T>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the wrapped value.\n\n This can be cast to a pointer of any kind. When creating references, you must uphold the\n aliasing rules; see [the type-level docs][UnsafeCell#aliasing-rules] for more discussion and\n caveats.\n\n # Examples\n\n ```\n use std::cell::UnsafeCell;\n\n let uc = UnsafeCell::new(5);\n\n let five = uc.get();\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::cell::UnsafeCell": [
      "Ref"
    ],
    "sync::nonpoison::rwlock::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "Ref"
    ]
  },
  "path": 3113,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/nonpoison/rwlock.rs:498:5: 500:6",
  "src": "pub const fn data_ptr(&self) -> *mut T {\n        self.data.get()\n    }",
  "mir": "fn sync::nonpoison::rwlock::RwLock::<T>::data_ptr(_1: &sync::nonpoison::rwlock::RwLock<T>) -> *mut T {\n    let mut _0: *mut T;\n    let mut _2: &core::cell::UnsafeCell<T>;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = &((*_1).1: core::cell::UnsafeCell<T>);\n        _0 = core::cell::UnsafeCell::<T>::get(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Returns a raw pointer to the underlying data.\n\n The returned pointer is always non-null and properly aligned, but it is\n the user's responsibility to ensure that any reads and writes through it\n are properly synchronized to avoid data races, and that it is not read\n or written through after the lock is dropped.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}