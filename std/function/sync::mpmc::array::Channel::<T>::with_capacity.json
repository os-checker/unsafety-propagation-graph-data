{
  "name": "sync::mpmc::array::Channel::<T>::with_capacity",
  "safe": true,
  "callees": {
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "core::num::<impl usize>::next_power_of_two": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the smallest power of two greater than or equal to `self`.\n\n When return value overflows (i.e., `self > (1 << (N-1))` for type\n `uN`), it panics in debug mode and the return value is wrapped to 0 in\n release mode (the only situation in which this method can return 0).\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes a closure and creates an iterator which calls that closure on each\n element.\n\n `map()` transforms one iterator into another, by means of its argument:\n something that implements [`FnMut`]. It produces a new iterator which\n calls this closure on each element of the original iterator.\n\n If you are good at thinking in types, you can think of `map()` like this:\n If you have an iterator that gives you elements of some type `A`, and\n you want an iterator of some other type `B`, you can use `map()`,\n passing a closure that takes an `A` and returns a `B`.\n\n `map()` is conceptually similar to a [`for`] loop. However, as `map()` is\n lazy, it is best used when you're already working with other iterators.\n If you're doing some sort of looping for a side effect, it's considered\n more idiomatic to use [`for`] than `map()`.\n\n [`for`]: ../../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.iter().map(|x| 2 * x);\n\n assert_eq!(iter.next(), Some(2));\n assert_eq!(iter.next(), Some(4));\n assert_eq!(iter.next(), Some(6));\n assert_eq!(iter.next(), None);\n ```\n\n If you're doing some sort of side effect, prefer [`for`] to `map()`:\n\n ```\n # #![allow(unused_must_use)]\n // don't do this:\n (0..5).map(|x| println!(\"{x}\"));\n\n // it won't even execute, as it is lazy. Rust will warn you about this.\n\n // Instead, use a for-loop:\n for x in 0..5 {\n     println!(\"{x}\");\n }\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::collect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms an iterator into a collection.\n\n `collect()` can take anything iterable, and turn it into a relevant\n collection. This is one of the more powerful methods in the standard\n library, used in a variety of contexts.\n\n The most basic pattern in which `collect()` is used is to turn one\n collection into another. You take a collection, call [`iter`] on it,\n do a bunch of transformations, and then `collect()` at the end.\n\n `collect()` can also create instances of types that are not typical\n collections. For example, a [`String`] can be built from [`char`]s,\n and an iterator of [`Result<T, E>`][`Result`] items can be collected\n into `Result<Collection<T>, E>`. See the examples below for more.\n\n Because `collect()` is so general, it can cause problems with type\n inference. As such, `collect()` is one of the few times you'll see\n the syntax affectionately known as the 'turbofish': `::<>`. This\n helps the inference algorithm understand specifically which collection\n you're trying to collect into.\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n let doubled: Vec<i32> = a.iter()\n                          .map(|x| x * 2)\n                          .collect();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Note that we needed the `: Vec<i32>` on the left-hand side. This is because\n we could collect into, for example, a [`VecDeque<T>`] instead:\n\n [`VecDeque<T>`]: ../../std/collections/struct.VecDeque.html\n\n ```\n use std::collections::VecDeque;\n\n let a = [1, 2, 3];\n\n let doubled: VecDeque<i32> = a.iter().map(|x| x * 2).collect();\n\n assert_eq!(2, doubled[0]);\n assert_eq!(4, doubled[1]);\n assert_eq!(6, doubled[2]);\n ```\n\n Using the 'turbofish' instead of annotating `doubled`:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<i32>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Because `collect()` only cares about what you're collecting into, you can\n still use a partial type hint, `_`, with the turbofish:\n\n ```\n let a = [1, 2, 3];\n\n let doubled = a.iter().map(|x| x * 2).collect::<Vec<_>>();\n\n assert_eq!(vec![2, 4, 6], doubled);\n ```\n\n Using `collect()` to make a [`String`]:\n\n ```\n let chars = ['g', 'd', 'k', 'k', 'n'];\n\n let hello: String = chars.into_iter()\n     .map(|x| x as u8)\n     .map(|x| (x + 1) as char)\n     .collect();\n\n assert_eq!(\"hello\", hello);\n ```\n\n If you have a list of [`Result<T, E>`][`Result`]s, you can use `collect()` to\n see if any of them failed:\n\n ```\n let results = [Ok(1), Err(\"nope\"), Ok(3), Err(\"bad\")];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the first error\n assert_eq!(Err(\"nope\"), result);\n\n let results = [Ok(1), Ok(3)];\n\n let result: Result<Vec<_>, &str> = results.into_iter().collect();\n\n // gives us the list of answers\n assert_eq!(Ok(vec![1, 3]), result);\n ```\n\n [`iter`]: Iterator::next\n [`String`]: ../../std/string/struct.String.html\n [`char`]: type@char\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicUsize::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new atomic integer.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "sync::mpmc::utils::CachePadded::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Pads and aligns a value to the length of a cache line.\n",
      "adt": {
        "sync::mpmc::utils::CachePadded": "Constructor"
      }
    },
    "sync::mpmc::waker::SyncWaker::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `SyncWaker`.\n",
      "adt": {
        "sync::mpmc::waker::SyncWaker": "Constructor"
      }
    }
  },
  "adts": {
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ],
    "core::iter::Map": [
      "Plain"
    ],
    "alloc_crate::boxed::Box": [
      "Plain"
    ],
    "core::sync::atomic::AtomicUsize": [
      "Plain"
    ],
    "sync::mpmc::utils::CachePadded": [
      "Plain"
    ],
    "sync::mpmc::waker::SyncWaker": [
      "Plain"
    ],
    "sync::mpmc::array::Channel": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpmc::array::Channel::<T>::with_capacity"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/array.rs:90:5: 121:6",
  "src": "pub(crate) fn with_capacity(cap: usize) -> Self {\n        assert!(cap > 0, \"capacity must be positive\");\n\n        // Compute constants `mark_bit` and `one_lap`.\n        let mark_bit = (cap + 1).next_power_of_two();\n        let one_lap = mark_bit * 2;\n\n        // Head is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n        let head = 0;\n        // Tail is initialized to `{ lap: 0, mark: 0, index: 0 }`.\n        let tail = 0;\n\n        // Allocate a buffer of `cap` slots initialized\n        // with stamps.\n        let buffer: Box<[Slot<T>]> = (0..cap)\n            .map(|i| {\n                // Set the stamp to `{ lap: 0, mark: 0, index: i }`.\n                Slot { stamp: AtomicUsize::new(i), msg: UnsafeCell::new(MaybeUninit::uninit()) }\n            })\n            .collect();\n\n        Channel {\n            buffer,\n            cap,\n            one_lap,\n            mark_bit,\n            head: CachePadded::new(AtomicUsize::new(head)),\n            tail: CachePadded::new(AtomicUsize::new(tail)),\n            senders: SyncWaker::new(),\n            receivers: SyncWaker::new(),\n        }\n    }",
  "mir": "fn sync::mpmc::array::Channel::<T>::with_capacity(_1: usize) -> sync::mpmc::array::Channel<T> {\n    let mut _0: sync::mpmc::array::Channel<T>;\n    let mut _2: bool;\n    let  _3: !;\n    let mut _4: core::fmt::Arguments<'_>;\n    let  _5: usize;\n    let mut _6: usize;\n    let mut _7: (usize, bool);\n    let  _8: usize;\n    let mut _9: (usize, bool);\n    let  _10: alloc_crate::boxed::Box<[sync::mpmc::array::Slot<T>]>;\n    let mut _11: core::iter::Map<core::ops::Range<usize>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/array.rs:105:18: 105:21}>;\n    let mut _12: core::ops::Range<usize>;\n    let mut _13: sync::mpmc::utils::CachePadded<core::sync::atomic::AtomicUsize>;\n    let mut _14: core::sync::atomic::AtomicUsize;\n    let mut _15: usize;\n    let mut _16: sync::mpmc::utils::CachePadded<core::sync::atomic::AtomicUsize>;\n    let mut _17: core::sync::atomic::AtomicUsize;\n    let mut _18: usize;\n    let mut _19: sync::mpmc::waker::SyncWaker;\n    let mut _20: sync::mpmc::waker::SyncWaker;\n    debug cap => _1;\n    debug mark_bit => _5;\n    debug one_lap => _8;\n    debug head => 0_usize;\n    debug tail => 0_usize;\n    debug buffer => _10;\n    bb0: {\n        StorageLive(_2);\n        _2 = Gt(_1, 0_usize);\n        switchInt(move _2) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        StorageDead(_2);\n        StorageLive(_6);\n        _7 = CheckedAdd(_1, 1_usize);\n        assert(!move (_7.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _1, 1_usize) -> [success: bb4, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_4);\n        _4 = core::fmt::Arguments::<'_>::from_str(\"capacity must be positive\") -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _3 = core::panicking::panic_fmt(move _4) -> unwind unreachable;\n    }\n    bb4: {\n        _6 = move (_7.0: usize);\n        _5 = core::num::<impl usize>::next_power_of_two(move _6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_6);\n        _9 = CheckedMul(_5, 2_usize);\n        assert(!move (_9.1: bool), \"attempt to compute `{} * {}`, which would overflow\", _5, 2_usize) -> [success: bb6, unwind unreachable];\n    }\n    bb6: {\n        _8 = move (_9.0: usize);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = Range(0_usize, _1);\n        _11 = <core::ops::Range<usize> as core::iter::Iterator>::map::<sync::mpmc::array::Slot<T>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/array.rs:105:18: 105:21}>(move _12, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/array.rs:105:18: 105:21}) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_12);\n        _10 = <core::iter::Map<core::ops::Range<usize>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/array.rs:105:18: 105:21}> as core::iter::Iterator>::collect::<alloc_crate::boxed::Box<[sync::mpmc::array::Slot<T>]>>(move _11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = 0_usize;\n        _14 = core::sync::atomic::AtomicUsize::new(move _15) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_15);\n        _13 = sync::mpmc::utils::CachePadded::<core::sync::atomic::AtomicUsize>::new(move _14) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = 0_usize;\n        _17 = core::sync::atomic::AtomicUsize::new(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_18);\n        _16 = sync::mpmc::utils::CachePadded::<core::sync::atomic::AtomicUsize>::new(move _17) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_17);\n        StorageLive(_19);\n        _19 = sync::mpmc::waker::SyncWaker::new() -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_20);\n        _20 = sync::mpmc::waker::SyncWaker::new() -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _0 = Channel(move _13, move _16, _10, _1, _8, _5, move _19, move _20);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_16);\n        StorageDead(_13);\n        return;\n    }\n}\n",
  "doc": " Creates a bounded channel of capacity `cap`.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}