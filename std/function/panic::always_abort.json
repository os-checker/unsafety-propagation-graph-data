{
  "name": "panic::always_abort",
  "safe": true,
  "callees": {
    "panicking::panic_count::set_always_abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {},
  "path": 2266,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:426:1: 428:2",
  "src": "pub fn always_abort() {\n    crate::panicking::panic_count::set_always_abort();\n}",
  "mir": "fn panic::always_abort() -> () {\n    let mut _0: ();\n    let  _1: ();\n    bb0: {\n        _1 = panicking::panic_count::set_always_abort() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Makes all future panics abort directly without running the panic hook or unwinding.\n\n There is no way to undo this; the effect lasts until the process exits or\n execs (or the equivalent).\n\n # Use after fork\n\n This function is particularly useful for calling after `libc::fork`.  After `fork`, in a\n multithreaded program it is (on many platforms) not safe to call the allocator.  It is also\n generally highly undesirable for an unwind to unwind past the `fork`, because that results in\n the unwind propagating to code that was only ever expecting to run in the parent.\n\n `panic::always_abort()` helps avoid both of these.  It directly avoids any further unwinding,\n and if there is a panic, the abort will occur without allocating provided that the arguments to\n panic can be formatted without allocating.\n\n Examples\n\n ```no_run\n #![feature(panic_always_abort)]\n use std::panic;\n\n panic::always_abort();\n\n let _ = panic::catch_unwind(|| {\n     panic!(\"inside the catch\");\n });\n\n // We will have aborted already, due to the panic.\n unreachable!();\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}