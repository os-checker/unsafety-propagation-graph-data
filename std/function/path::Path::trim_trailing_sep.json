{
  "name": "path::Path::trim_trailing_sep",
  "safe": true,
  "callees": {
    "path::Path::has_trailing_sep": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checks whether the path ends in a trailing [separator](MAIN_SEPARATOR).\n\n This is generally done to ensure that a path is treated as a directory, not a file,\n although it does not actually guarantee that such a path is a directory on the underlying\n file system.\n\n Despite this behavior, two paths are still considered the same in Rust whether they have a\n trailing separator or not.\n\n # Examples\n\n ```\n #![feature(path_trailing_sep)]\n use std::path::Path;\n\n assert!(Path::new(\"dir/\").has_trailing_sep());\n assert!(!Path::new(\"file.rs\").has_trailing_sep());\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "path::Path::has_root": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the `Path` has a root.\n\n * On Unix, a path has a root if it begins with `/`.\n\n * On Windows, a path has a root if it:\n     * has no prefix and begins with a separator, e.g., `\\windows`\n     * has a prefix followed by a separator, e.g., `c:\\windows` but not `c:windows`\n     * has any non-disk prefix, e.g., `\\\\server\\share`\n\n # Examples\n\n ```\n use std::path::Path;\n\n assert!(Path::new(\"/etc/passwd\").has_root());\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "path::Path::parent": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the `Path` without its final component, if there is one.\n\n This means it returns `Some(\"\")` for relative paths with one component.\n\n Returns [`None`] if the path terminates in a root or prefix, or if it's\n the empty string.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let path = Path::new(\"/foo/bar\");\n let parent = path.parent().unwrap();\n assert_eq!(parent, Path::new(\"/foo\"));\n\n let grand_parent = parent.parent().unwrap();\n assert_eq!(grand_parent, Path::new(\"/\"));\n assert_eq!(grand_parent.parent(), None);\n\n let relative_path = Path::new(\"foo/bar\");\n let parent = relative_path.parent();\n assert_eq!(parent, Some(Path::new(\"foo\")));\n let grand_parent = parent.and_then(Path::parent);\n assert_eq!(grand_parent, Some(Path::new(\"\")));\n let great_grand_parent = grand_parent.and_then(Path::parent);\n assert_eq!(great_grand_parent, None);\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    },
    "ffi::os_str::OsStr::as_encoded_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n string slice, use the [`OsStr::from_encoded_bytes_unchecked`] function.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n be treated as opaque and only comparable within the same Rust version built for the same\n target platform.  For example, sending the slice over the network or storing it in a file\n will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n and [`std::ffi`] for platform-specific, specified conversions.\n\n [`std::ffi`]: crate::ffi\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::split_last": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n\n # Examples\n\n ```\n let x = &[0, 1, 2];\n\n if let Some((last, elements)) = x.split_last() {\n     assert_eq!(last, &2);\n     assert_eq!(elements, &[0, 1]);\n }\n ```\n",
      "adt": {}
    },
    "sys::path::unix::is_sep_byte": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "ffi::os_str::OsStr::from_encoded_bytes_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts a slice of bytes to an OS string slice without checking that the string contains\n valid `OsStr`-encoded data.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n See the [module's toplevel documentation about conversions][conversions] for safe,\n cross-platform [conversions] from/to native representations.\n\n # Safety\n\n As the encoding is unspecified, callers must pass in bytes that originated as a mixture of\n validated UTF-8 and bytes from [`OsStr::as_encoded_bytes`] from within the same Rust version\n built for the same target platform.  For example, reconstructing an `OsStr` from bytes sent\n over the network or stored in a file will likely violate these safety rules.\n\n Due to the encoding being self-synchronizing, the bytes from [`OsStr::as_encoded_bytes`] can be\n split either immediately before or immediately after any valid non-empty UTF-8 substring.\n\n # Example\n\n ```\n use std::ffi::OsStr;\n\n let os_str = OsStr::new(\"Mary had a little lamb\");\n let bytes = os_str.as_encoded_bytes();\n let words = bytes.split(|b| *b == b' ');\n let words: Vec<&OsStr> = words.map(|word| {\n     // SAFETY:\n     // - Each `word` only contains content that originated from `OsStr::as_encoded_bytes`\n     // - Only split with ASCII whitespace which is a non-empty UTF-8 substring\n     unsafe { OsStr::from_encoded_bytes_unchecked(word) }\n }).collect();\n ```\n\n [conversions]: super#conversions\n",
      "adt": {}
    },
    "path::Path::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Directly wraps a string slice as a `Path` slice.\n\n This is a cost-free conversion.\n\n # Examples\n\n ```\n use std::path::Path;\n\n Path::new(\"foo.txt\");\n ```\n\n You can create `Path`s from `String`s, or even other `Path`s:\n\n ```\n use std::path::Path;\n\n let string = String::from(\"foo.txt\");\n let from_string = Path::new(&string);\n let from_path = Path::new(&from_string);\n assert_eq!(from_string, from_path);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "path::Path": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 9923, kind: RigidTy(Tuple([Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) }])) }), Field(0, Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 9923, kind: RigidTy(Tuple([Ty { id: 4948, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) }])) }), Field(1, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })])"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::path::Path::trim_trailing_sep"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/path.rs:2955:5: 2969:6",
  "src": "pub fn trim_trailing_sep(&self) -> &Path {\n        if self.has_trailing_sep() && (!self.has_root() || self.parent().is_some()) {\n            let mut bytes = self.inner.as_encoded_bytes();\n            while let Some((last, init)) = bytes.split_last()\n                && is_sep_byte(*last)\n            {\n                bytes = init;\n            }\n\n            // SAFETY: Trimming trailing ASCII bytes will retain the validity of the string.\n            Path::new(unsafe { OsStr::from_encoded_bytes_unchecked(bytes) })\n        } else {\n            self\n        }\n    }",
  "mir": "fn path::Path::trim_trailing_sep(_1: &path::Path) -> &path::Path {\n    let mut _0: &path::Path;\n    let mut _2: bool;\n    let mut _3: bool;\n    let mut _4: bool;\n    let mut _5: &core::option::Option<&path::Path>;\n    let  _6: core::option::Option<&path::Path>;\n    let mut _7: &[u8];\n    let mut _8: &ffi::os_str::OsStr;\n    let mut _9: core::option::Option<(&u8, &[u8])>;\n    let mut _10: &[u8];\n    let mut _11: isize;\n    let  _12: &u8;\n    let  _13: &[u8];\n    let mut _14: bool;\n    let mut _15: u8;\n    let  _16: &path::Path;\n    let  _17: &ffi::os_str::OsStr;\n    let mut _18: &[u8];\n    debug self => _1;\n    debug bytes => _7;\n    debug last => _12;\n    debug init => _13;\n    bb0: {\n        StorageLive(_2);\n        _2 = path::Path::has_trailing_sep(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb21, otherwise: bb2];\n    }\n    bb2: {\n        StorageLive(_3);\n        _3 = path::Path::has_root(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _3) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = path::Path::parent(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        goto -> bb9;\n    }\n    bb6: {\n        _5 = &_6;\n        _4 = core::option::Option::<&path::Path>::is_some(move _5) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        switchInt(move _4) -> [0: bb20, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &((*_1).0: ffi::os_str::OsStr);\n        _7 = ffi::os_str::OsStr::as_encoded_bytes(move _8) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_8);\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = _7;\n        _9 = core::slice::<impl [u8]>::split_last(move _10) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_10);\n        _11 = discriminant(_9);\n        switchInt(move _11) -> [1: bb13, 0: bb17, otherwise: bb24];\n    }\n    bb13: {\n        StorageLive(_12);\n        _12 = (((_9 as variant#1).0: (&u8, &[u8])).0: &u8);\n        _13 = (((_9 as variant#1).0: (&u8, &[u8])).1: &[u8]);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = (*_12);\n        _14 = sys::path::unix::is_sep_byte(move _15) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _14) -> [0: bb16, otherwise: bb15];\n    }\n    bb15: {\n        StorageDead(_15);\n        _7 = _13;\n        StorageDead(_12);\n        StorageDead(_9);\n        StorageDead(_14);\n        goto -> bb11;\n    }\n    bb16: {\n        StorageDead(_15);\n        StorageDead(_12);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_9);\n        StorageDead(_14);\n        StorageLive(_16);\n        StorageLive(_18);\n        _18 = _7;\n        _17 = ffi::os_str::OsStr::from_encoded_bytes_unchecked(move _18) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_18);\n        _16 = path::Path::new::<ffi::os_str::OsStr>(_17) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _0 = _16;\n        StorageDead(_16);\n        StorageDead(_7);\n        goto -> bb23;\n    }\n    bb20: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb22;\n    }\n    bb21: {\n        goto -> bb22;\n    }\n    bb22: {\n        _0 = _1;\n        goto -> bb23;\n    }\n    bb23: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n    bb24: {\n        unreachable;\n    }\n}\n",
  "doc": " Trims a trailing [separator](MAIN_SEPARATOR) from a path, if possible.\n\n The resulting path will return false for [`has_trailing_sep`](Self::has_trailing_sep) for\n most paths.\n\n Some paths, like `/`, cannot be trimmed in this way.\n\n # Examples\n\n ```\n #![feature(path_trailing_sep)]\n use std::ffi::OsStr;\n use std::path::Path;\n\n assert_eq!(Path::new(\"dir//\").trim_trailing_sep().as_os_str(), OsStr::new(\"dir\"));\n assert_eq!(Path::new(\"dir/\").trim_trailing_sep().as_os_str(), OsStr::new(\"dir\"));\n assert_eq!(Path::new(\"dir\").trim_trailing_sep().as_os_str(), OsStr::new(\"dir\"));\n assert_eq!(Path::new(\"/\").trim_trailing_sep().as_os_str(), OsStr::new(\"/\"));\n assert_eq!(Path::new(\"//\").trim_trailing_sep().as_os_str(), OsStr::new(\"//\"));\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}