{
  "name": "sys::fs::unix::remove_dir_impl::remove_dir_all_recursive",
  "safe": true,
  "callees": {
    "sys::fs::unix::remove_dir_impl::openat_nofollow_dironly": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::ffi::CStr": "ImmutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor",
        "os::fd::owned::OwnedFd": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::error::Error::raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS error that this error represents (if any).\n\n If this [`Error`] was constructed via [`last_os_error`] or\n [`from_raw_os_error`], then this function will return [`Some`], otherwise\n it will return [`None`].\n\n [`last_os_error`]: Error::last_os_error\n [`from_raw_os_error`]: Error::from_raw_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_os_error(err: &Error) {\n     if let Some(raw_os_err) = err.raw_os_error() {\n         println!(\"raw OS error: {raw_os_err:?}\");\n     } else {\n         println!(\"Not an OS error\");\n     }\n }\n\n fn main() {\n     // Will print \"raw OS error: ...\".\n     print_os_error(&Error::last_os_error());\n     // Will print \"Not an OS error\".\n     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "core::option::Option": "Constructor",
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::ffi::CStr::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the inner pointer to this C string.\n\n The returned pointer will be valid for as long as `self` is, and points\n to a contiguous region of memory terminated with a 0 byte to represent\n the end of the string.\n\n The type of the returned pointer is\n [`*const c_char`][crate::ffi::c_char], and whether it's\n an alias for `*const i8` or `*const u8` is platform-specific.\n\n **WARNING**\n\n The returned pointer is read-only; writing to it (including passing it\n to C code that writes to it) causes undefined behavior.\n\n It is your responsibility to make sure that the underlying memory is not\n freed too early. For example, the following code will cause undefined\n behavior when `ptr` is used inside the `unsafe` block:\n\n ```no_run\n # #![expect(dangling_pointers_from_temporaries)]\n use std::ffi::{CStr, CString};\n\n // üíÄ The meaning of this entire program is undefined,\n // üíÄ and nothing about its behavior is guaranteed,\n // üíÄ not even that its behavior resembles the code as written,\n // üíÄ just because it contains a single instance of undefined behavior!\n\n // üö® creates a dangling pointer to a temporary `CString`\n // üö® that is deallocated at the end of the statement\n let ptr = CString::new(\"Hi!\".to_uppercase()).unwrap().as_ptr();\n\n // without undefined behavior, you would expect that `ptr` equals:\n dbg!(CStr::from_bytes_with_nul(b\"HI!\\0\").unwrap());\n\n // üôè Possibly the program behaved as expected so far,\n // üôè and this just shows `ptr` is now garbage..., but\n // üíÄ this violates `CStr::from_ptr`'s safety contract\n // üíÄ leading to a dereference of a dangling pointer,\n // üíÄ which is immediate undefined behavior.\n // üíÄ *BOOM*, you're dead, your entire program has no meaning.\n dbg!(unsafe { CStr::from_ptr(ptr) });\n ```\n\n This happens because, the pointer returned by `as_ptr` does not carry any\n lifetime information, and the `CString` is deallocated immediately after\n the expression that it is part of has been evaluated.\n To fix the problem, bind the `CString` to a local variable:\n\n ```\n use std::ffi::{CStr, CString};\n\n let c_str = CString::new(\"Hi!\".to_uppercase()).unwrap();\n let ptr = c_str.as_ptr();\n\n assert_eq!(unsafe { CStr::from_ptr(ptr) }, c\"HI!\");\n ```\n",
      "adt": {}
    },
    "libc::unlinkat": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "sys::fs::unix::remove_dir_impl::fdreaddir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor",
        "os::fd::owned::OwnedFd": "ImmutableAsArgument",
        "sys::fs::unix::ReadDir": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::IntoIterator::into_iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an iterator from a value.\n\n See the [module-level documentation] for more.\n\n [module-level documentation]: crate::iter\n\n # Examples\n\n ```\n let v = [1, 2, 3];\n let mut iter = v.into_iter();\n\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "sys::fs::unix::DirEntry::name_cstr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::DirEntry": "ImmutableAsArgument"
      }
    },
    "sys::fs::unix::remove_dir_impl::is_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::fs::unix::DirEntry": "ImmutableAsArgument"
      }
    },
    "sys::fs::unix::remove_dir_impl::remove_dir_all_recursive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::ffi::CStr": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::try_trait::residual_into_try_type": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::Try::from_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from its `Output` type.\n\n This should be implemented consistently with the `branch` method\n such that applying the `?` operator will get back the original value:\n `Try::from_output(x).branch() --> ControlFlow::Continue(x)`.\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::Try;\n\n assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n assert_eq!(<Option<_> as Try>::from_output(4), Some(4));\n assert_eq!(\n     <std::ops::ControlFlow<String, _> as Try>::from_output(5),\n     std::ops::ControlFlow::Continue(5),\n );\n\n # fn make_question_mark_work() -> Option<()> {\n assert_eq!(Option::from_output(4)?, 4);\n # None }\n # make_question_mark_work();\n\n // This is used, for example, on the accumulator in `try_fold`:\n let r = std::iter::empty().try_fold(4, |_, ()| -> Option<_> { unreachable!() });\n assert_eq!(r, Some(4));\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::is_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Err`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_err(), false);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_err(), true);\n ```\n",
      "adt": {}
    },
    "sys::fs::unix::remove_dir_impl::is_enoent": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "MutableAsArgument"
      }
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "sys_common::ignore_notfound": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    }
  },
  "adts": {
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 4221, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 4229, kind: RigidTy(Adt(AdtDef(DefId { id: 6250, name: \"sys::fs::unix::DirEntry\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 128, kind: RigidTy(Bool) })])"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8512, kind: RigidTy(Adt(AdtDef(DefId { id: 8314, name: \"os::fd::owned::OwnedFd\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 15909, kind: RigidTy(Tuple([Ty { id: 4214, kind: RigidTy(Adt(AdtDef(DefId { id: 6241, name: \"sys::fs::unix::ReadDir\" }), GenericArgs([]))) }, Ty { id: 44, kind: RigidTy(Int(I32)) }])) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 4229, kind: RigidTy(Adt(AdtDef(DefId { id: 6250, name: \"sys::fs::unix::DirEntry\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "io::error::Error": [
      "Ref",
      "Plain"
    ],
    "os::fd::owned::OwnedFd": [
      "Plain"
    ],
    "sys::fs::unix::ReadDir": [
      "Plain",
      "Unknown([Field(0, Ty { id: 4214, kind: RigidTy(Adt(AdtDef(DefId { id: 6241, name: \"sys::fs::unix::ReadDir\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "MutRef"
    ],
    "sys::fs::unix::DirEntry": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::fs::unix::remove_dir_impl::remove_dir_all_recursive"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:2526:5: 2579:6",
  "src": "fn remove_dir_all_recursive(parent_fd: Option<RawFd>, path: &CStr) -> io::Result<()> {\n        // try opening as directory\n        let fd = match openat_nofollow_dironly(parent_fd, &path) {\n            Err(err) if matches!(err.raw_os_error(), Some(libc::ENOTDIR | libc::ELOOP)) => {\n                // not a directory - don't traverse further\n                // (for symlinks, older Linux kernels may return ELOOP instead of ENOTDIR)\n                return match parent_fd {\n                    // unlink...\n                    Some(parent_fd) => {\n                        cvt(unsafe { unlinkat(parent_fd, path.as_ptr(), 0) }).map(drop)\n                    }\n                    // ...unless this was supposed to be the deletion root directory\n                    None => Err(err),\n                };\n            }\n            result => result?,\n        };\n\n        // open the directory passing ownership of the fd\n        let (dir, fd) = fdreaddir(fd)?;\n        for child in dir {\n            let child = child?;\n            let child_name = child.name_cstr();\n            // we need an inner try block, because if one of these\n            // directories has already been deleted, then we need to\n            // continue the loop, not return ok.\n            let result: io::Result<()> = try {\n                match is_dir(&child) {\n                    Some(true) => {\n                        remove_dir_all_recursive(Some(fd), child_name)?;\n                    }\n                    Some(false) => {\n                        cvt(unsafe { unlinkat(fd, child_name.as_ptr(), 0) })?;\n                    }\n                    None => {\n                        // POSIX specifies that calling unlink()/unlinkat(..., 0) on a directory can succeed\n                        // if the process has the appropriate privileges. This however can causing orphaned\n                        // directories requiring an fsck e.g. on Solaris and Illumos. So we try recursing\n                        // into it first instead of trying to unlink() it.\n                        remove_dir_all_recursive(Some(fd), child_name)?;\n                    }\n                }\n            };\n            if result.is_err() && !is_enoent(&result) {\n                return result;\n            }\n        }\n\n        // unlink the directory after removing its contents\n        ignore_notfound(cvt(unsafe {\n            unlinkat(parent_fd.unwrap_or(libc::AT_FDCWD), path.as_ptr(), libc::AT_REMOVEDIR)\n        }))?;\n        Ok(())\n    }",
  "mir": "fn sys::fs::unix::remove_dir_impl::remove_dir_all_recursive(_1: core::option::Option<i32>, _2: &core::ffi::CStr) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: core::result::Result<os::fd::owned::OwnedFd, io::error::Error>;\n    let  _4: &&core::ffi::CStr;\n    let mut _5: isize;\n    let  _6: io::error::Error;\n    let  _7: &io::error::Error;\n    let mut _8: bool;\n    let mut _9: core::option::Option<i32>;\n    let mut _10: isize;\n    let mut _11: isize;\n    let  _12: i32;\n    let mut _13: core::result::Result<i32, io::error::Error>;\n    let mut _14: i32;\n    let mut _15: *const u8;\n    let mut _16: io::error::Error;\n    let  _17: core::result::Result<os::fd::owned::OwnedFd, io::error::Error>;\n    let mut _18: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, os::fd::owned::OwnedFd>;\n    let mut _19: isize;\n    let  _20: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _21: os::fd::owned::OwnedFd;\n    let  _22: sys::fs::unix::ReadDir;\n    let  _23: i32;\n    let mut _24: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, (sys::fs::unix::ReadDir, i32)>;\n    let mut _25: core::result::Result<(sys::fs::unix::ReadDir, i32), io::error::Error>;\n    let mut _26: isize;\n    let  _27: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _28: (sys::fs::unix::ReadDir, i32);\n    let mut _29: sys::fs::unix::ReadDir;\n    let mut _30: sys::fs::unix::ReadDir;\n    let mut _31: core::option::Option<core::result::Result<sys::fs::unix::DirEntry, io::error::Error>>;\n    let mut _32: &mut sys::fs::unix::ReadDir;\n    let mut _33: isize;\n    let  _34: core::result::Result<sys::fs::unix::DirEntry, io::error::Error>;\n    let  _35: sys::fs::unix::DirEntry;\n    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, sys::fs::unix::DirEntry>;\n    let mut _37: isize;\n    let  _38: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _39: sys::fs::unix::DirEntry;\n    let  _40: &core::ffi::CStr;\n    let mut _41: &sys::fs::unix::DirEntry;\n    let  _42: core::result::Result<(), io::error::Error>;\n    let mut _43: core::option::Option<bool>;\n    let  _44: &sys::fs::unix::DirEntry;\n    let mut _45: isize;\n    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _47: core::result::Result<(), io::error::Error>;\n    let mut _48: core::option::Option<i32>;\n    let mut _49: isize;\n    let  _50: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _51: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _52: core::result::Result<i32, io::error::Error>;\n    let mut _53: i32;\n    let mut _54: *const u8;\n    let mut _55: isize;\n    let  _56: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _57: i32;\n    let mut _58: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _59: core::result::Result<(), io::error::Error>;\n    let mut _60: core::option::Option<i32>;\n    let mut _61: isize;\n    let  _62: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _63: bool;\n    let mut _64: &core::result::Result<(), io::error::Error>;\n    let mut _65: bool;\n    let  _66: &core::result::Result<(), io::error::Error>;\n    let mut _67: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _68: core::result::Result<(), io::error::Error>;\n    let mut _69: core::result::Result<i32, io::error::Error>;\n    let mut _70: i32;\n    let mut _71: i32;\n    let mut _72: *const u8;\n    let mut _73: isize;\n    let  _74: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _75: &core::ffi::CStr;\n    let mut _76: bool;\n    let mut _77: bool;\n    let mut _78: isize;\n    debug parent_fd => _1;\n    debug path => _2;\n    debug fd => _21;\n    debug err => _6;\n    debug err => _7;\n    debug parent_fd => _12;\n    debug result => _17;\n    debug residual => _20;\n    debug val => _21;\n    debug dir => _22;\n    debug fd => _23;\n    debug residual => _27;\n    debug val => _28;\n    debug iter => _30;\n    debug child => _34;\n    debug child => _35;\n    debug residual => _38;\n    debug val => _39;\n    debug child_name => _40;\n    debug result => _42;\n    debug residual => _50;\n    debug val => ();\n    debug residual => _56;\n    debug val => _57;\n    debug residual => _62;\n    debug val => ();\n    debug residual => _74;\n    debug val => ();\n    bb0: {\n        _77 = false;\n        _76 = false;\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &_2;\n        _75 = (*_4);\n        _3 = sys::fs::unix::remove_dir_impl::openat_nofollow_dironly(_1, _75) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _77 = true;\n        _5 = discriminant(_3);\n        switchInt(move _5) -> [1: bb3, 0: bb2, otherwise: bb11];\n    }\n    bb2: {\n        _77 = false;\n        _17 = move _3;\n        StorageLive(_18);\n        _18 = <core::result::Result<os::fd::owned::OwnedFd, io::error::Error> as core::ops::Try>::branch(_17) -> [return: bb18, unwind unreachable];\n    }\n    bb3: {\n        _7 = &((_3 as variant#1).0: io::error::Error);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = io::error::Error::raw_os_error(_7) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _10 = discriminant(_9);\n        switchInt(move _10) -> [1: bb6, 0: bb5, otherwise: bb11];\n    }\n    bb5: {\n        _8 = false;\n        goto -> bb8;\n    }\n    bb6: {\n        switchInt(((_9 as variant#1).0: i32)) -> [20: bb7, 40: bb7, otherwise: bb5];\n    }\n    bb7: {\n        _8 = true;\n        goto -> bb8;\n    }\n    bb8: {\n        switchInt(move _8) -> [0: bb10, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_6);\n        _76 = true;\n        _6 = move ((_3 as variant#1).0: io::error::Error);\n        _11 = discriminant(_1);\n        switchInt(move _11) -> [0: bb12, 1: bb13, otherwise: bb11];\n    }\n    bb10: {\n        StorageDead(_9);\n        StorageDead(_8);\n        goto -> bb2;\n    }\n    bb11: {\n        unreachable;\n    }\n    bb12: {\n        StorageLive(_16);\n        _76 = false;\n        _16 = move _6;\n        _0 = core::result::Result::Err(move _16);\n        StorageDead(_16);\n        goto -> bb89;\n    }\n    bb13: {\n        _12 = ((_1 as variant#1).0: i32);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = core::ffi::CStr::as_ptr(_2) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _14 = libc::unlinkat(_12, move _15, 0_i32) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_15);\n        _13 = sys::pal::unix::cvt::<i32>(move _14) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_14);\n        _0 = core::result::Result::<i32, io::error::Error>::map::<(), fn(i32) {core::mem::drop::<i32>}>(move _13, core::mem::drop::<i32>) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_13);\n        goto -> bb89;\n    }\n    bb18: {\n        _19 = discriminant(_18);\n        switchInt(move _19) -> [0: bb19, 1: bb20, otherwise: bb11];\n    }\n    bb19: {\n        _21 = move ((_18 as variant#0).0: os::fd::owned::OwnedFd);\n        StorageDead(_18);\n        StorageDead(_4);\n        _77 = false;\n        StorageDead(_3);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = sys::fs::unix::remove_dir_impl::fdreaddir(_21) -> [return: bb22, unwind unreachable];\n    }\n    bb20: {\n        _20 = move ((_18 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_20) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_18);\n        goto -> bb93;\n    }\n    bb22: {\n        _24 = <core::result::Result<(sys::fs::unix::ReadDir, i32), io::error::Error> as core::ops::Try>::branch(move _25) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_25);\n        _26 = discriminant(_24);\n        switchInt(move _26) -> [0: bb24, 1: bb25, otherwise: bb11];\n    }\n    bb24: {\n        _28 = move ((_24 as variant#0).0: (sys::fs::unix::ReadDir, i32));\n        _22 = (_28.0: sys::fs::unix::ReadDir);\n        _23 = (_28.1: i32);\n        StorageDead(_24);\n        StorageLive(_29);\n        _29 = <sys::fs::unix::ReadDir as core::iter::IntoIterator>::into_iter(_22) -> [return: bb27, unwind unreachable];\n    }\n    bb25: {\n        _27 = move ((_24 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_27) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_24);\n        goto -> bb86;\n    }\n    bb27: {\n        StorageLive(_30);\n        _30 = move _29;\n        goto -> bb28;\n    }\n    bb28: {\n        StorageLive(_31);\n        _32 = &mut _30;\n        _31 = <sys::fs::unix::ReadDir as core::iter::Iterator>::next(_32) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _33 = discriminant(_31);\n        switchInt(move _33) -> [0: bb31, 1: bb30, otherwise: bb11];\n    }\n    bb30: {\n        _34 = move ((_31 as variant#1).0: core::result::Result<sys::fs::unix::DirEntry, io::error::Error>);\n        StorageLive(_35);\n        StorageLive(_36);\n        _36 = <core::result::Result<sys::fs::unix::DirEntry, io::error::Error> as core::ops::Try>::branch(_34) -> [return: bb32, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_31);\n        drop(_30) -> [return: bb72, unwind unreachable];\n    }\n    bb32: {\n        _37 = discriminant(_36);\n        switchInt(move _37) -> [0: bb33, 1: bb34, otherwise: bb11];\n    }\n    bb33: {\n        StorageLive(_39);\n        _39 = move ((_36 as variant#0).0: sys::fs::unix::DirEntry);\n        _35 = move _39;\n        StorageDead(_39);\n        StorageDead(_36);\n        StorageLive(_41);\n        _41 = &_35;\n        _40 = sys::fs::unix::DirEntry::name_cstr(move _41) -> [return: bb36, unwind unreachable];\n    }\n    bb34: {\n        _38 = move ((_36 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_38) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_36);\n        goto -> bb82;\n    }\n    bb36: {\n        StorageDead(_41);\n        StorageLive(_42);\n        StorageLive(_43);\n        _44 = &_35;\n        _43 = sys::fs::unix::remove_dir_impl::is_dir(_44) -> [return: bb37, unwind unreachable];\n    }\n    bb37: {\n        _45 = discriminant(_43);\n        switchInt(move _45) -> [0: bb39, 1: bb38, otherwise: bb11];\n    }\n    bb38: {\n        switchInt(((_43 as variant#1).0: bool)) -> [0: bb40, otherwise: bb41];\n    }\n    bb39: {\n        StorageLive(_58);\n        StorageLive(_59);\n        StorageLive(_60);\n        _60 = core::option::Option::Some(_23);\n        _59 = sys::fs::unix::remove_dir_impl::remove_dir_all_recursive(move _60, _40) -> [return: bb54, unwind unreachable];\n    }\n    bb40: {\n        StorageLive(_51);\n        StorageLive(_52);\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = core::ffi::CStr::as_ptr(_40) -> [return: bb47, unwind unreachable];\n    }\n    bb41: {\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = core::option::Option::Some(_23);\n        _47 = sys::fs::unix::remove_dir_impl::remove_dir_all_recursive(move _48, _40) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_48);\n        _46 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _47) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_47);\n        _49 = discriminant(_46);\n        switchInt(move _49) -> [0: bb44, 1: bb45, otherwise: bb11];\n    }\n    bb44: {\n        StorageDead(_46);\n        goto -> bb59;\n    }\n    bb45: {\n        _50 = move ((_46 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _42 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_50) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_46);\n        goto -> bb61;\n    }\n    bb47: {\n        _53 = libc::unlinkat(_23, move _54, 0_i32) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        StorageDead(_54);\n        _52 = sys::pal::unix::cvt::<i32>(move _53) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_53);\n        _51 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _52) -> [return: bb50, unwind unreachable];\n    }\n    bb50: {\n        StorageDead(_52);\n        _55 = discriminant(_51);\n        switchInt(move _55) -> [0: bb51, 1: bb52, otherwise: bb11];\n    }\n    bb51: {\n        StorageLive(_57);\n        _57 = ((_51 as variant#0).0: i32);\n        StorageDead(_57);\n        StorageDead(_51);\n        goto -> bb59;\n    }\n    bb52: {\n        _56 = move ((_51 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _42 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_56) -> [return: bb53, unwind unreachable];\n    }\n    bb53: {\n        StorageDead(_51);\n        goto -> bb61;\n    }\n    bb54: {\n        StorageDead(_60);\n        _58 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _59) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_59);\n        _61 = discriminant(_58);\n        switchInt(move _61) -> [0: bb56, 1: bb57, otherwise: bb11];\n    }\n    bb56: {\n        StorageDead(_58);\n        goto -> bb59;\n    }\n    bb57: {\n        _62 = move ((_58 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _42 = core::ops::try_trait::residual_into_try_type::<core::result::Result<core::convert::Infallible, io::error::Error>, ()>(_62) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_58);\n        goto -> bb61;\n    }\n    bb59: {\n        _42 = <core::result::Result<(), io::error::Error> as core::ops::Try>::from_output(()) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        StorageDead(_43);\n        goto -> bb62;\n    }\n    bb61: {\n        StorageDead(_43);\n        goto -> bb62;\n    }\n    bb62: {\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = &_42;\n        _63 = core::result::Result::<(), io::error::Error>::is_err(move _64) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        switchInt(move _63) -> [0: bb68, otherwise: bb64];\n    }\n    bb64: {\n        StorageDead(_64);\n        StorageLive(_65);\n        _66 = &_42;\n        _65 = sys::fs::unix::remove_dir_impl::is_enoent(_66) -> [return: bb65, unwind unreachable];\n    }\n    bb65: {\n        switchInt(move _65) -> [0: bb67, otherwise: bb66];\n    }\n    bb66: {\n        goto -> bb69;\n    }\n    bb67: {\n        _0 = move _42;\n        StorageDead(_65);\n        StorageDead(_63);\n        StorageDead(_42);\n        drop(_35) -> [return: bb82, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_64);\n        goto -> bb69;\n    }\n    bb69: {\n        StorageDead(_65);\n        StorageDead(_63);\n        drop(_42) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        StorageDead(_42);\n        drop(_35) -> [return: bb71, unwind unreachable];\n    }\n    bb71: {\n        StorageDead(_35);\n        StorageDead(_31);\n        goto -> bb28;\n    }\n    bb72: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageLive(_67);\n        StorageLive(_68);\n        StorageLive(_69);\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = core::option::Option::<i32>::unwrap_or(_1, libc::AT_FDCWD) -> [return: bb73, unwind unreachable];\n    }\n    bb73: {\n        StorageLive(_72);\n        _72 = core::ffi::CStr::as_ptr(_2) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        _70 = libc::unlinkat(move _71, move _72, libc::AT_REMOVEDIR) -> [return: bb75, unwind unreachable];\n    }\n    bb75: {\n        StorageDead(_72);\n        StorageDead(_71);\n        _69 = sys::pal::unix::cvt::<i32>(move _70) -> [return: bb76, unwind unreachable];\n    }\n    bb76: {\n        StorageDead(_70);\n        _68 = sys_common::ignore_notfound::<i32>(move _69) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_69);\n        _67 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _68) -> [return: bb78, unwind unreachable];\n    }\n    bb78: {\n        StorageDead(_68);\n        _73 = discriminant(_67);\n        switchInt(move _73) -> [0: bb79, 1: bb80, otherwise: bb11];\n    }\n    bb79: {\n        StorageDead(_67);\n        _0 = core::result::Result::Ok(());\n        goto -> bb87;\n    }\n    bb80: {\n        _74 = move ((_67 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_74) -> [return: bb81, unwind unreachable];\n    }\n    bb81: {\n        StorageDead(_67);\n        goto -> bb84;\n    }\n    bb82: {\n        StorageDead(_35);\n        StorageDead(_31);\n        drop(_30) -> [return: bb83, unwind unreachable];\n    }\n    bb83: {\n        StorageDead(_30);\n        StorageDead(_29);\n        goto -> bb84;\n    }\n    bb84: {\n        goto -> bb86;\n    }\n    bb85: {\n        _76 = false;\n        StorageDead(_6);\n        goto -> bb93;\n    }\n    bb86: {\n        goto -> bb87;\n    }\n    bb87: {\n        return;\n    }\n    bb88: {\n        drop(_6) -> [return: bb85, unwind unreachable];\n    }\n    bb89: {\n        switchInt(_76) -> [0: bb85, otherwise: bb88];\n    }\n    bb90: {\n        _77 = false;\n        StorageDead(_4);\n        _77 = false;\n        StorageDead(_3);\n        goto -> bb86;\n    }\n    bb91: {\n        drop(_3) -> [return: bb90, unwind unreachable];\n    }\n    bb92: {\n        _78 = discriminant(_3);\n        switchInt(move _78) -> [1: bb90, 0: bb91, otherwise: bb11];\n    }\n    bb93: {\n        switchInt(_77) -> [0: bb90, otherwise: bb92];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}