{
  "name": "io::read_until",
  "safe": true,
  "callees": {
    "io::BufRead::fill_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contents of the internal buffer, filling it with more data, via `Read` methods, if empty.\n\n This is a lower-level method and is meant to be used together with [`consume`],\n which can be used to mark bytes that should not be returned by subsequent calls to `read`.\n\n [`consume`]: BufRead::consume\n\n Returns an empty buffer when the stream has reached EOF.\n\n # Errors\n\n This function will return an I/O error if a `Read` method was called, but returned an error.\n\n # Examples\n\n A locked standard input implements `BufRead`:\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n\n let stdin = io::stdin();\n let mut stdin = stdin.lock();\n\n let buffer = stdin.fill_buf()?;\n\n // work with buffer\n println!(\"{buffer:?}\");\n\n // mark the bytes we worked with as read\n let length = buffer.len();\n stdin.consume(length);\n # std::io::Result::Ok(())\n ```\n",
      "adt": {}
    },
    "io::error::Error::is_interrupted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::slice::memchr::memchr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the first index matching the byte `x` in `text`.\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T, A>::extend_from_slice": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Clones and appends all elements in a slice to the `Vec`.\n\n Iterates over the slice `other`, clones each element, and then appends\n it to this `Vec`. The `other` slice is traversed in-order.\n\n Note that this function is the same as [`extend`],\n except that it also works with slice elements that are Clone but not Copy.\n If Rust gets specialization this function may be deprecated.\n\n # Panics\n\n Panics if the new capacity exceeds `isize::MAX` _bytes_.\n\n # Examples\n\n ```\n let mut vec = vec![1];\n vec.extend_from_slice(&[2, 3, 4]);\n assert_eq!(vec, [1, 2, 3, 4]);\n ```\n\n [`extend`]: Vec::extend\n",
      "adt": {}
    },
    "core::ops::Index::index": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the indexing (`container[index]`) operation.\n\n # Panics\n\n May panic if the index is out of bounds.\n",
      "adt": {}
    },
    "io::BufRead::consume": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marks the given `amount` of additional bytes from the internal buffer as having been read.\n Subsequent calls to `read` only return bytes that have not been marked as read.\n\n This is a lower-level method and is meant to be used together with [`fill_buf`],\n which can be used to fill the internal buffer via `Read` methods.\n\n It is a logic error if `amount` exceeds the number of unread bytes in the internal buffer, which is returned by [`fill_buf`].\n\n # Examples\n\n Since `consume()` is meant to be used with [`fill_buf`],\n that method's example includes an example of `consume()`.\n\n [`fill_buf`]: BufRead::fill_buf\n",
      "adt": {}
    }
  },
  "adts": {
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 992, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 993, kind: RigidTy(Slice(Ty { id: 35, kind: RigidTy(Uint(U8)) })) }, Not)) })])"
    ],
    "io::error::Error": [
      "Ref",
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ],
    "core::ops::RangeToInclusive": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::read_until"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/mod.rs:2222:1: 2248:2",
  "src": "fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> Result<usize> {\n    let mut read = 0;\n    loop {\n        let (done, used) = {\n            let available = match r.fill_buf() {\n                Ok(n) => n,\n                Err(ref e) if e.is_interrupted() => continue,\n                Err(e) => return Err(e),\n            };\n            match memchr::memchr(delim, available) {\n                Some(i) => {\n                    buf.extend_from_slice(&available[..=i]);\n                    (true, i + 1)\n                }\n                None => {\n                    buf.extend_from_slice(available);\n                    (false, available.len())\n                }\n            }\n        };\n        r.consume(used);\n        read += used;\n        if done || used == 0 {\n            return Ok(read);\n        }\n    }\n}",
  "mir": "fn io::read_until(_1: &mut R, _2: u8, _3: &mut alloc_crate::vec::Vec<u8>) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _4: usize;\n    let  _5: bool;\n    let  _6: usize;\n    let mut _7: (bool, usize);\n    let mut _8: core::result::Result<&[u8], io::error::Error>;\n    let mut _9: isize;\n    let  _10: &[u8];\n    let  _11: &io::error::Error;\n    let  _12: &&io::error::Error;\n    let mut _13: bool;\n    let  _14: io::error::Error;\n    let mut _15: core::option::Option<usize>;\n    let mut _16: isize;\n    let  _17: usize;\n    let  _18: ();\n    let  _19: &[u8];\n    let mut _20: core::ops::RangeToInclusive<usize>;\n    let mut _21: usize;\n    let mut _22: (usize, bool);\n    let  _23: ();\n    let mut _24: usize;\n    let  _25: ();\n    let mut _26: (usize, bool);\n    let mut _27: usize;\n    let mut _28: &io::error::Error;\n    debug r => _1;\n    debug delim => _2;\n    debug buf => _3;\n    debug read => _4;\n    debug done => _5;\n    debug used => _6;\n    debug available => _10;\n    debug n => _10;\n    debug e => _11;\n    debug e => _12;\n    debug e => _14;\n    debug i => _17;\n    bb0: {\n        StorageLive(_4);\n        _4 = 0_usize;\n        goto -> bb1;\n    }\n    bb1: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = <R as io::BufRead>::fill_buf(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _9 = discriminant(_8);\n        switchInt(move _9) -> [0: bb5, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_12);\n        StorageLive(_11);\n        _11 = &((_8 as variant#1).0: io::error::Error);\n        _12 = &_11;\n        StorageLive(_13);\n        _28 = (*_12);\n        _13 = io::error::Error::is_interrupted(_28) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        _10 = ((_8 as variant#0).0: &[u8]);\n        StorageDead(_8);\n        StorageLive(_15);\n        _15 = core::slice::memchr::memchr(_2, _10) -> [return: bb9, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _13) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageDead(_12);\n        drop(_8) -> [return: bb23, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageDead(_11);\n        StorageDead(_12);\n        _14 = move ((_8 as variant#1).0: io::error::Error);\n        _0 = core::result::Result::Err(_14);\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb24;\n    }\n    bb9: {\n        _16 = discriminant(_15);\n        switchInt(move _16) -> [0: bb10, 1: bb11, otherwise: bb3];\n    }\n    bb10: {\n        _23 = alloc_crate::vec::Vec::<u8>::extend_from_slice(_3, _10) -> [return: bb15, unwind unreachable];\n    }\n    bb11: {\n        _17 = ((_15 as variant#1).0: usize);\n        StorageLive(_20);\n        _20 = RangeToInclusive(_17);\n        _19 = <[u8] as core::ops::Index<core::ops::RangeToInclusive<usize>>>::index(_10, move _20) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_20);\n        _18 = alloc_crate::vec::Vec::<u8>::extend_from_slice(_3, _19) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageLive(_21);\n        _22 = CheckedAdd(_17, 1_usize);\n        assert(!move (_22.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _17, 1_usize) -> [success: bb14, unwind unreachable];\n    }\n    bb14: {\n        _21 = move (_22.0: usize);\n        _7 = (true, move _21);\n        StorageDead(_21);\n        goto -> bb16;\n    }\n    bb15: {\n        StorageLive(_24);\n        _24 = PtrMetadata(_10);\n        _7 = (false, move _24);\n        StorageDead(_24);\n        goto -> bb16;\n    }\n    bb16: {\n        StorageDead(_15);\n        _5 = (_7.0: bool);\n        _6 = (_7.1: usize);\n        StorageDead(_7);\n        _25 = <R as io::BufRead>::consume(_1, _6) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _26 = CheckedAdd(_4, _6);\n        assert(!move (_26.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _4, _6) -> [success: bb18, unwind unreachable];\n    }\n    bb18: {\n        _4 = move (_26.0: usize);\n        switchInt(_5) -> [0: bb19, otherwise: bb21];\n    }\n    bb19: {\n        switchInt(_6) -> [0: bb20, otherwise: bb22];\n    }\n    bb20: {\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_27);\n        _27 = _4;\n        _0 = core::result::Result::Ok(move _27);\n        StorageDead(_27);\n        goto -> bb24;\n    }\n    bb22: {\n        goto -> bb1;\n    }\n    bb23: {\n        StorageDead(_8);\n        StorageDead(_7);\n        goto -> bb1;\n    }\n    bb24: {\n        StorageDead(_4);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}