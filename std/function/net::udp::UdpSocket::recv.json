{
  "name": "net::udp::UdpSocket::recv",
  "safe": true,
  "callees": {
    "sys::net::connection::socket::UdpSocket::recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::UdpSocket": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::net::connection::socket::UdpSocket": [
      "Ref"
    ],
    "net::udp::UdpSocket": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::net::udp::UdpSocket::recv"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/net/udp.rs:729:5: 731:6",
  "src": "pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n        self.0.recv(buf)\n    }",
  "mir": "fn net::udp::UdpSocket::recv(_1: &net::udp::UdpSocket, _2: &mut [u8]) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: &sys::net::connection::socket::UdpSocket;\n    debug self => _1;\n    debug buf => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::net::connection::socket::UdpSocket);\n        _0 = sys::net::connection::socket::UdpSocket::recv(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Receives a single datagram message on the socket from the remote address to\n which it is connected. On success, returns the number of bytes read.\n\n The function must be called with valid byte array `buf` of sufficient size to\n hold the message bytes. If a message is too long to fit in the supplied buffer,\n excess bytes may be discarded.\n\n [`UdpSocket::connect`] will connect this socket to a remote address. This\n method will fail if the socket is not connected.\n\n # Examples\n\n ```no_run\n use std::net::UdpSocket;\n\n let socket = UdpSocket::bind(\"127.0.0.1:34254\").expect(\"couldn't bind to address\");\n socket.connect(\"127.0.0.1:8080\").expect(\"connect function failed\");\n let mut buf = [0; 10];\n match socket.recv(&mut buf) {\n     Ok(received) => println!(\"received {received} bytes {:?}\", &buf[..received]),\n     Err(e) => println!(\"recv function failed: {e:?}\"),\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}