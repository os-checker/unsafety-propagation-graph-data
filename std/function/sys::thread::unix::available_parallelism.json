{
  "name": "sys::thread::unix::available_parallelism",
  "safe": true,
  "callees": {
    "sys::thread::unix::cgroups::quota": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns cgroup CPU quota in core-equivalents, rounded down or usize::MAX if the quota cannot\n be determined or is not set.\n",
      "adt": {}
    },
    "core::cmp::Ord::max": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the maximum of two values.\n\n Returns the second argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.max(2), 2);\n assert_eq!(2.max(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").max(Equal(\"other\")).0, \"other\");\n ```\n",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "libc::sched_getaffinity": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::CPU_COUNT": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::cmp::Ord::min": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Compares and returns the minimum of two values.\n\n Returns the first argument if the comparison determines them to be equal.\n\n # Examples\n\n ```\n assert_eq!(1.min(2), 1);\n assert_eq!(2.min(2), 2);\n ```\n ```\n use std::cmp::Ordering;\n\n #[derive(Eq)]\n struct Equal(&'static str);\n\n impl PartialEq for Equal {\n     fn eq(&self, other: &Self) -> bool { true }\n }\n impl PartialOrd for Equal {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(Ordering::Equal) }\n }\n impl Ord for Equal {\n     fn cmp(&self, other: &Self) -> Ordering { Ordering::Equal }\n }\n\n assert_eq!(Equal(\"self\").min(Equal(\"other\")).0, \"self\");\n ```\n",
      "adt": {}
    },
    "core::num::NonZero::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero if the given value is not zero.\n",
      "adt": {}
    },
    "libc::sysconf": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::num::NonZero::<T>::new_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a non-zero without checking whether the value is non-zero.\n This results in undefined behavior if the value is zero.\n\n # Safety\n\n The value must not be zero.\n",
      "adt": {}
    }
  },
  "adts": {
    "libc::cpu_set_t": [
      "Plain",
      "MutRef",
      "Deref",
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 629, kind: RigidTy(Adt(AdtDef(DefId { id: 4616, name: \"core::num::NonZero\" }), GenericArgs([Type(Ty { id: 393, kind: RigidTy(Uint(Usize)) })]))) })])"
    ],
    "core::num::NonZero": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "io::error::Error": [
      "Plain"
    ]
  },
  "path": 4346,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread/unix.rs:146:1: 321:2",
  "src": "pub fn available_parallelism() -> io::Result<NonZero<usize>> {\n    cfg_select! {\n        any(\n            target_os = \"android\",\n            target_os = \"emscripten\",\n            target_os = \"fuchsia\",\n            target_os = \"hurd\",\n            target_os = \"linux\",\n            target_os = \"aix\",\n            target_vendor = \"apple\",\n            target_os = \"cygwin\",\n        ) => {\n            #[allow(unused_assignments)]\n            #[allow(unused_mut)]\n            let mut quota = usize::MAX;\n\n            #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n            {\n                quota = cgroups::quota().max(1);\n                let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n                unsafe {\n                    if libc::sched_getaffinity(0, size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n                        let count = libc::CPU_COUNT(&set) as usize;\n                        let count = count.min(quota);\n\n                        // According to sched_getaffinity's API it should always be non-zero, but\n                        // some old MIPS kernels were buggy and zero-initialized the mask if\n                        // none was explicitly set.\n                        // In that case we use the sysconf fallback.\n                        if let Some(count) = NonZero::new(count) {\n                            return Ok(count)\n                        }\n                    }\n                }\n            }\n            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                -1 => Err(io::Error::last_os_error()),\n                0 => Err(io::Error::UNKNOWN_THREAD_COUNT),\n                cpus => {\n                    let count = cpus as usize;\n                    // Cover the unusual situation where we were able to get the quota but not the affinity mask\n                    let count = count.min(quota);\n                    Ok(unsafe { NonZero::new_unchecked(count) })\n                }\n            }\n        }\n        any(\n           target_os = \"freebsd\",\n           target_os = \"dragonfly\",\n           target_os = \"openbsd\",\n           target_os = \"netbsd\",\n        ) => {\n            use crate::ptr;\n\n            #[cfg(target_os = \"freebsd\")]\n            {\n                let mut set: libc::cpuset_t = unsafe { mem::zeroed() };\n                unsafe {\n                    if libc::cpuset_getaffinity(\n                        libc::CPU_LEVEL_WHICH,\n                        libc::CPU_WHICH_PID,\n                        -1,\n                        size_of::<libc::cpuset_t>(),\n                        &mut set,\n                    ) == 0 {\n                        let count = libc::CPU_COUNT(&set) as usize;\n                        if count > 0 {\n                            return Ok(NonZero::new_unchecked(count));\n                        }\n                    }\n                }\n            }\n\n            #[cfg(target_os = \"netbsd\")]\n            {\n                unsafe {\n                    let set = libc::_cpuset_create();\n                    if !set.is_null() {\n                        let mut count: usize = 0;\n                        if libc::pthread_getaffinity_np(libc::pthread_self(), libc::_cpuset_size(set), set) == 0 {\n                            for i in 0..libc::cpuid_t::MAX {\n                                match libc::_cpuset_isset(i, set) {\n                                    -1 => break,\n                                    0 => continue,\n                                    _ => count = count + 1,\n                                }\n                            }\n                        }\n                        libc::_cpuset_destroy(set);\n                        if let Some(count) = NonZero::new(count) {\n                            return Ok(count);\n                        }\n                    }\n                }\n            }\n\n            let mut cpus: libc::c_uint = 0;\n            let mut cpus_size = size_of_val(&cpus);\n\n            unsafe {\n                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n            }\n\n            // Fallback approach in case of errors or no hardware threads.\n            if cpus < 1 {\n                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n                let res = unsafe {\n                    libc::sysctl(\n                        mib.as_mut_ptr(),\n                        2,\n                        (&raw mut cpus) as *mut _,\n                        (&raw mut cpus_size) as *mut _,\n                        ptr::null_mut(),\n                        0,\n                    )\n                };\n\n                // Handle errors if any.\n                if res == -1 {\n                    return Err(io::Error::last_os_error());\n                } else if cpus == 0 {\n                    return Err(io::Error::UNKNOWN_THREAD_COUNT);\n                }\n            }\n\n            Ok(unsafe { NonZero::new_unchecked(cpus as usize) })\n        }\n        target_os = \"nto\" => {\n            unsafe {\n                use libc::_syspage_ptr;\n                if _syspage_ptr.is_null() {\n                    Err(io::const_error!(io::ErrorKind::NotFound, \"no syspage available\"))\n                } else {\n                    let cpus = (*_syspage_ptr).num_cpu;\n                    NonZero::new(cpus as usize)\n                        .ok_or(io::Error::UNKNOWN_THREAD_COUNT)\n                }\n            }\n        }\n        any(target_os = \"solaris\", target_os = \"illumos\") => {\n            let mut cpus = 0u32;\n            if unsafe { libc::pset_info(libc::PS_MYID, core::ptr::null_mut(), &mut cpus, core::ptr::null_mut()) } != 0 {\n                return Err(io::Error::UNKNOWN_THREAD_COUNT);\n            }\n            Ok(unsafe { NonZero::new_unchecked(cpus as usize) })\n        }\n        target_os = \"haiku\" => {\n            // system_info cpu_count field gets the static data set at boot time with `smp_set_num_cpus`\n            // `get_system_info` calls then `smp_get_num_cpus`\n            unsafe {\n                let mut sinfo: libc::system_info = crate::mem::zeroed();\n                let res = libc::get_system_info(&mut sinfo);\n\n                if res != libc::B_OK {\n                    return Err(io::Error::UNKNOWN_THREAD_COUNT);\n                }\n\n                Ok(NonZero::new_unchecked(sinfo.cpu_count as usize))\n            }\n        }\n        target_os = \"vxworks\" => {\n            // Note: there is also `vxCpuConfiguredGet`, closer to _SC_NPROCESSORS_CONF\n            // expectations than the actual cores availability.\n\n            // SAFETY: `vxCpuEnabledGet` always fetches a mask with at least one bit set\n            unsafe{\n                let set = libc::vxCpuEnabledGet();\n                Ok(NonZero::new_unchecked(set.count_ones() as usize))\n            }\n        }\n        _ => {\n            // FIXME: implement on Redox, l4re\n            Err(io::const_error!(io::ErrorKind::Unsupported, \"getting the number of hardware threads is not supported on the target platform\"))\n        }\n    }\n}",
  "mir": "fn sys::thread::unix::available_parallelism() -> core::result::Result<core::num::NonZero<usize>, io::error::Error> {\n    let mut _0: core::result::Result<core::num::NonZero<usize>, io::error::Error>;\n    let mut _1: usize;\n    let mut _2: usize;\n    let mut _3: usize;\n    let mut _4: libc::cpu_set_t;\n    let mut _5: i32;\n    let mut _6: usize;\n    let mut _7: *mut libc::cpu_set_t;\n    let mut _8: &mut libc::cpu_set_t;\n    let  _9: usize;\n    let mut _10: i32;\n    let  _11: &libc::cpu_set_t;\n    let  _12: usize;\n    let mut _13: usize;\n    let mut _14: core::option::Option<core::num::NonZero<usize>>;\n    let mut _15: isize;\n    let  _16: core::num::NonZero<usize>;\n    let mut _17: i64;\n    let mut _18: io::error::Error;\n    let  _19: usize;\n    let  _20: usize;\n    let mut _21: usize;\n    let mut _22: core::num::NonZero<usize>;\n    debug quota => _1;\n    debug set => _4;\n    debug count => _9;\n    debug count => _12;\n    debug count => _16;\n    debug cpus => _17;\n    debug count => _19;\n    debug count => _20;\n    bb0: {\n        StorageLive(_1);\n        _1 = core::num::<impl usize>::MAX;\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = sys::thread::unix::cgroups::quota() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = <usize as core::cmp::Ord>::max(move _3, 1_usize) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _1 = move _2;\n        StorageDead(_2);\n        StorageLive(_4);\n        _4 = core::mem::zeroed::<libc::cpu_set_t>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = core::mem::size_of::<libc::cpu_set_t>() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = &mut _4;\n        _7 = &raw mut (*_8);\n        _5 = libc::sched_getaffinity(0_i32, move _6, move _7) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        StorageDead(_6);\n        switchInt(move _5) -> [0: bb6, otherwise: bb12];\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_5);\n        StorageLive(_10);\n        _11 = &_4;\n        _10 = libc::CPU_COUNT(_11) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _9 = move _10 as usize;\n        StorageDead(_10);\n        StorageLive(_13);\n        _13 = _1;\n        _12 = <usize as core::cmp::Ord>::min(_9, move _13) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageLive(_14);\n        _14 = core::num::NonZero::<usize>::new(_12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _15 = discriminant(_14);\n        switchInt(move _15) -> [1: bb10, 0: bb11, otherwise: bb23];\n    }\n    bb10: {\n        _16 = ((_14 as variant#1).0: core::num::NonZero<usize>);\n        _0 = core::result::Result::Ok(_16);\n        StorageDead(_14);\n        StorageDead(_4);\n        StorageDead(_1);\n        goto -> bb22;\n    }\n    bb11: {\n        StorageDead(_14);\n        goto -> bb13;\n    }\n    bb12: {\n        StorageDead(_8);\n        StorageDead(_5);\n        goto -> bb13;\n    }\n    bb13: {\n        StorageDead(_4);\n        _17 = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(_17) -> [18446744073709551615: bb17, 0: bb16, otherwise: bb15];\n    }\n    bb15: {\n        _19 = _17 as usize;\n        StorageLive(_21);\n        _21 = _1;\n        _20 = <usize as core::cmp::Ord>::min(_19, move _21) -> [return: bb19, unwind unreachable];\n    }\n    bb16: {\n        _0 = core::result::Result::Err(io::error::Error::UNKNOWN_THREAD_COUNT);\n        goto -> bb21;\n    }\n    bb17: {\n        StorageLive(_18);\n        _18 = io::error::Error::last_os_error() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _0 = core::result::Result::Err(move _18);\n        StorageDead(_18);\n        goto -> bb21;\n    }\n    bb19: {\n        StorageDead(_21);\n        StorageLive(_22);\n        _22 = core::num::NonZero::<usize>::new_unchecked(_20) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        _0 = core::result::Result::Ok(move _22);\n        StorageDead(_22);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageDead(_1);\n        goto -> bb22;\n    }\n    bb22: {\n        return;\n    }\n    bb23: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}