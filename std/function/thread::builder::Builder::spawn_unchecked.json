{
  "name": "thread::builder::Builder::spawn_unchecked",
  "safe": false,
  "callees": {
    "thread::lifecycle::spawn_unchecked": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "thread::lifecycle::JoinInner": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "thread::builder::Builder": [
      "Unknown([Field(0, Ty { id: 495, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 493, kind: RigidTy(Adt(AdtDef(DefId { id: 4560, name: \"alloc_crate::string::String\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 496, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 393, kind: RigidTy(Uint(Usize)) })]))) })])",
      "Unknown([Field(2, Ty { id: 128, kind: RigidTy(Bool) })])",
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 508, kind: RigidTy(Adt(AdtDef(DefId { id: 4566, name: \"thread::lifecycle::JoinInner\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 396, kind: Param(ParamTy { index: 1, name: \"T\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "thread::lifecycle::JoinInner": [
      "Plain"
    ],
    "thread::join_handle::JoinHandle": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::thread::builder::Builder::spawn_unchecked"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/builder.rs:258:5: 266:6",
  "src": "pub unsafe fn spawn_unchecked<F, T>(self, f: F) -> io::Result<JoinHandle<T>>\n    where\n        F: FnOnce() -> T,\n        F: Send,\n        T: Send,\n    {\n        let Builder { name, stack_size, no_hooks } = self;\n        Ok(JoinHandle(unsafe { spawn_unchecked(name, stack_size, no_hooks, None, f) }?))\n    }",
  "mir": "fn thread::builder::Builder::spawn_unchecked(_1: thread::builder::Builder, _2: F) -> core::result::Result<thread::join_handle::JoinHandle<T>, io::error::Error> {\n    let mut _0: core::result::Result<thread::join_handle::JoinHandle<T>, io::error::Error>;\n    let  _3: core::option::Option<alloc_crate::string::String>;\n    let  _4: core::option::Option<usize>;\n    let  _5: bool;\n    let mut _6: thread::join_handle::JoinHandle<T>;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, thread::lifecycle::JoinInner<'_, T>>;\n    let mut _8: core::result::Result<thread::lifecycle::JoinInner<'_, T>, io::error::Error>;\n    let mut _9: core::option::Option<alloc_crate::sync::Arc<thread::scoped::ScopeData>>;\n    let mut _10: isize;\n    let  _11: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _12: thread::lifecycle::JoinInner<'_, T>;\n    debug self => _1;\n    debug f => _2;\n    debug name => _3;\n    debug stack_size => _4;\n    debug no_hooks => _5;\n    debug residual => _11;\n    debug val => _12;\n    bb0: {\n        _3 = move (_1.0: core::option::Option<alloc_crate::string::String>);\n        _4 = (_1.1: core::option::Option<usize>);\n        _5 = (_1.2: bool);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = core::option::Option::None;\n        _8 = thread::lifecycle::spawn_unchecked::<'_, F, T>(_3, _4, _5, move _9, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_9);\n        _7 = <core::result::Result<thread::lifecycle::JoinInner<'_, T>, io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_8);\n        _10 = discriminant(_7);\n        switchInt(move _10) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _12 = move ((_7 as variant#0).0: thread::lifecycle::JoinInner<'_, T>);\n        _6 = JoinHandle(_12);\n        _0 = core::result::Result::Ok(move _6);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb5: {\n        _11 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<thread::join_handle::JoinHandle<T>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_11) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n}\n",
  "doc": " Spawns a new thread without any lifetime restrictions by taking ownership\n of the `Builder`, and returns an [`io::Result`] to its [`JoinHandle`].\n\n The spawned thread may outlive the caller (unless the caller thread\n is the main thread; the whole process is terminated when the main\n thread finishes). The join handle can be used to block on\n termination of the spawned thread, including recovering its panics.\n\n This method is identical to [`thread::Builder::spawn`][`Builder::spawn`],\n except for the relaxed lifetime bounds, which render it unsafe.\n For a more complete documentation see [`thread::spawn`].\n\n # Errors\n\n Unlike the [`spawn`] free function, this method yields an\n [`io::Result`] to capture any failure to create the thread at\n the OS level.\n\n # Panics\n\n Panics if a thread name was set and it contained null bytes.\n\n # Safety\n\n The caller has to ensure that the spawned thread does not outlive any\n references in the supplied thread closure and its return type.\n This can be guaranteed in two ways:\n\n - ensure that [`join`][`JoinHandle::join`] is called before any referenced\n data is dropped\n - use only types with `'static` lifetime bounds, i.e., those with no or only\n `'static` references (both [`thread::Builder::spawn`][`Builder::spawn`]\n and [`thread::spawn`] enforce this property statically)\n\n # Examples\n\n ```\n use std::thread;\n\n let builder = thread::Builder::new();\n\n let x = 1;\n let thread_x = &x;\n\n let handler = unsafe {\n     builder.spawn_unchecked(move || {\n         println!(\"x = {}\", *thread_x);\n     }).unwrap()\n };\n\n // caller has to ensure `join()` is called, otherwise\n // it is possible to access freed memory if `x` gets\n // dropped before the thread closure is executed!\n handler.join().unwrap();\n ```\n\n [`io::Result`]: crate::io::Result\n [`thread::spawn`]: super::spawn\n [`spawn`]: super::spawn\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}