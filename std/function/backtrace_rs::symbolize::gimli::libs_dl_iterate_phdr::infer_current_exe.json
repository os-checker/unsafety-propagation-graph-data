{
  "name": "backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::infer_current_exe",
  "safe": true,
  "callees": {
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::iter": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an iterator over the slice.\n\n The iterator yields all items from start to end.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let mut iterator = x.iter();\n\n assert_eq!(iterator.next(), Some(&1));\n assert_eq!(iterator.next(), Some(&2));\n assert_eq!(iterator.next(), Some(&4));\n assert_eq!(iterator.next(), None);\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::find": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Searches for an element of an iterator that satisfies a predicate.\n\n `find()` takes a closure that returns `true` or `false`. It applies\n this closure to each element of the iterator, and if any of them return\n `true`, then `find()` returns [`Some(element)`]. If they all return\n `false`, it returns [`None`].\n\n `find()` is short-circuiting; in other words, it will stop processing\n as soon as the closure returns `true`.\n\n Because `find()` takes a reference, and many iterators iterate over\n references, this leads to a possibly confusing situation where the\n argument is a double reference. You can see this effect in the\n examples below, with `&&x`.\n\n If you need the index of the element, see [`position()`].\n\n [`Some(element)`]: Some\n [`position()`]: Iterator::position\n\n # Examples\n\n Basic usage:\n\n ```\n let a = [1, 2, 3];\n\n assert_eq!(a.into_iter().find(|&x| x == 2), Some(2));\n assert_eq!(a.into_iter().find(|&x| x == 5), None);\n ```\n\n Stopping at the first `true`:\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n assert_eq!(iter.find(|&x| x == 2), Some(2));\n\n // we can still use `iter`, as there are more elements.\n assert_eq!(iter.next(), Some(3));\n ```\n\n Note that `iter.find(f)` is equivalent to `iter.filter(f).next()`.\n",
      "adt": {}
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<&T>::cloned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n option.\n\n # Examples\n\n ```\n let x = 12;\n let opt_x = Some(&x);\n assert_eq!(opt_x, Some(&12));\n let cloned = opt_x.cloned();\n assert_eq!(cloned, Some(12));\n ```\n",
      "adt": {}
    },
    "env::current_exe": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the full filesystem path of the current running executable.\n\n # Platform-specific behavior\n\n If the executable was invoked through a symbolic link, some platforms will\n return the path of the symbolic link and other platforms will return the\n path of the symbolic linkâ€™s target.\n\n If the executable is renamed while it is running, platforms may return the\n path at the time it was loaded instead of the new path.\n\n # Errors\n\n Acquiring the path of the current executable is a platform-specific operation\n that can fail for a good number of reasons. Some errors can include, but not\n be limited to, filesystem operations failing or general syscall failures.\n\n # Security\n\n The output of this function should not be trusted for anything\n that might have security implications. Basically, if users can run\n the executable, they can change the output arbitrarily.\n\n As an example, you can easily introduce a race condition. It goes\n like this:\n\n 1. You get the path to the current executable using `current_exe()`, and\n    store it in a variable.\n 2. Time passes. A malicious actor removes the current executable, and\n    replaces it with a malicious one.\n 3. You then use the stored path to re-execute the current\n    executable.\n\n You expected to safely execute the current executable, but you're\n instead executing something completely different. The code you\n just executed run with your privileges.\n\n This sort of behavior has been known to [lead to privilege escalation] when\n used incorrectly.\n\n [lead to privilege escalation]: https://securityvulns.com/Wdocument183.html\n\n # Examples\n\n ```\n use std::env;\n\n match env::current_exe() {\n     Ok(exe_path) => println!(\"Path of this executable is: {}\",\n                              exe_path.display()),\n     Err(e) => println!(\"failed to get current exe path: {e}\"),\n };\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap_or_default": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or a default\n\n Consumes the `self` argument then, if [`Ok`], returns the contained\n value, otherwise if [`Err`], returns the default value for that\n type.\n\n # Examples\n\n Converts a string to an integer, turning poorly-formed strings\n into 0 (the default value for integers). [`parse`] converts\n a string to any other type that implements [`FromStr`], returning an\n [`Err`] on error.\n\n ```\n let good_year_from_input = \"1909\";\n let bad_year_from_input = \"190blarg\";\n let good_year = good_year_from_input.parse().unwrap_or_default();\n let bad_year = bad_year_from_input.parse().unwrap_or_default();\n\n assert_eq!(1909, good_year);\n assert_eq!(0, bad_year);\n ```\n\n [`parse`]: str::parse\n [`FromStr`]: crate::str::FromStr\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 18483, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 18486, kind: RigidTy(Adt(AdtDef(DefId { id: 12922, name: \"backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry\" }), GenericArgs([]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2791, kind: RigidTy(Adt(AdtDef(DefId { id: 5580, name: \"ffi::os_str::OsString\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "alloc_crate::vec::Vec": [
      "Ref"
    ],
    "core::slice::Iter": [
      "Plain",
      "MutRef"
    ],
    "ffi::os_str::OsString": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::infer_current_exe"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:32:1: 49:2",
  "src": "fn infer_current_exe(\n    maps: &Option<Vec<parse_running_mmaps::MapsEntry>>,\n    base_addr: usize,\n) -> OsString {\n    #[cfg(not(target_os = \"hurd\"))]\n    if let Some(entries) = maps {\n        let opt_path = entries\n            .iter()\n            .find(|e| e.ip_matches(base_addr) && e.pathname().len() > 0)\n            .map(|e| e.pathname())\n            .cloned();\n        if let Some(path) = opt_path {\n            return path;\n        }\n    }\n\n    env::current_exe().map(|e| e.into()).unwrap_or_default()\n}",
  "mir": "fn backtrace_rs::symbolize::gimli::libs_dl_iterate_phdr::infer_current_exe(_1: &core::option::Option<alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>>, _2: usize) -> ffi::os_str::OsString {\n    let mut _0: ffi::os_str::OsString;\n    let mut _3: isize;\n    let  _4: &alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let  _5: core::option::Option<ffi::os_str::OsString>;\n    let mut _6: core::option::Option<&ffi::os_str::OsString>;\n    let mut _7: core::option::Option<&backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let mut _8: &mut core::slice::Iter<'_, backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let mut _9: core::slice::Iter<'_, backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>;\n    let  _10: &[backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry];\n    let mut _11: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:40:19: 40:22};\n    let mut _12: &usize;\n    let mut _13: isize;\n    let  _14: ffi::os_str::OsString;\n    let mut _15: core::result::Result<ffi::os_str::OsString, io::error::Error>;\n    let mut _16: core::result::Result<path::PathBuf, io::error::Error>;\n    debug maps => _1;\n    debug base_addr => _2;\n    debug entries => _4;\n    debug opt_path => _5;\n    debug path => _14;\n    bb0: {\n        _3 = discriminant((*_1));\n        switchInt(move _3) -> [1: bb1, 0: bb9, otherwise: bb14];\n    }\n    bb1: {\n        _4 = &(((*_1) as variant#1).0: alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _10 = <alloc_crate::vec::Vec<backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry> as core::ops::Deref>::deref(_4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _9 = core::slice::<impl [backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry]>::iter(_10) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _8 = &mut _9;\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &_2;\n        _11 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:40:19: 40:22}(move _12);\n        StorageDead(_12);\n        _7 = <core::slice::Iter<'_, backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry> as core::iter::Iterator>::find::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:40:19: 40:22}>(move _8, move _11) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_11);\n        StorageDead(_8);\n        _6 = core::option::Option::<&backtrace_rs::symbolize::gimli::parse_running_mmaps::MapsEntry>::map::<&ffi::os_str::OsString, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:41:18: 41:21}>(move _7, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:41:18: 41:21}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_7);\n        _5 = core::option::Option::<&ffi::os_str::OsString>::cloned(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_9);\n        _13 = discriminant(_5);\n        switchInt(move _13) -> [1: bb7, 0: bb8, otherwise: bb14];\n    }\n    bb7: {\n        StorageLive(_14);\n        _14 = move ((_5 as variant#1).0: ffi::os_str::OsString);\n        _0 = move _14;\n        StorageDead(_14);\n        StorageDead(_5);\n        goto -> bb13;\n    }\n    bb8: {\n        StorageDead(_5);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = env::current_exe() -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        _15 = core::result::Result::<path::PathBuf, io::error::Error>::map::<ffi::os_str::OsString, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:48:28: 48:31}>(move _16, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/../../backtrace/src/symbolize/gimli/libs_dl_iterate_phdr.rs:48:28: 48:31}) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_16);\n        _0 = core::result::Result::<ffi::os_str::OsString, io::error::Error>::unwrap_or_default(move _15) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_15);\n        goto -> bb13;\n    }\n    bb13: {\n        return;\n    }\n    bb14: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}