{
  "name": "thread::scoped::scope",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicUsize::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new atomic integer.\n\n # Examples\n\n ```\n\n ```\n",
      "adt": {}
    },
    "thread::current::current_or_unnamed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a handle to the thread that invokes it. If the handle stored in thread-\n local storage was already destroyed, this creates a new unnamed temporary\n handle to allow thread parking in nearly all situations.\n",
      "adt": {
        "thread::thread::Thread": "Constructor"
      }
    },
    "core::sync::atomic::AtomicBool::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `AtomicBool`.\n\n # Examples\n\n ```\n use std::sync::atomic::AtomicBool;\n\n let atomic_true = AtomicBool::new(true);\n let atomic_false = AtomicBool::new(false);\n ```\n",
      "adt": {}
    },
    "alloc_crate::sync::Arc::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new `Arc<T>`.\n\n # Examples\n\n ```\n use std::sync::Arc;\n\n let five = Arc::new(5);\n ```\n",
      "adt": {}
    },
    "panic::catch_unwind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n\n This function will return `Ok` with the closure's result if the closure does\n not panic, and will return `Err(cause)` if the closure panics. The `cause`\n returned is the object with which panic was originally invoked.\n\n Rust functions that are expected to be called from foreign code that does\n not support unwinding (such as C compiled with `-fno-exceptions`) should be\n defined using `extern \"C\"`, which ensures that if the Rust code panics, it\n is automatically caught and the process is aborted. If this is the desired\n behavior, it is not necessary to use `catch_unwind` explicitly. This\n function should instead be used when more graceful error-handling is needed.\n\n It is **not** recommended to use this function for a general try/catch\n mechanism. The [`Result`] type is more appropriate to use for functions that\n can fail on a regular basis. Additionally, this function is not guaranteed\n to catch all panics, see the \"Notes\" section below.\n\n The closure provided is required to adhere to the [`UnwindSafe`] trait to\n ensure that all captured variables are safe to cross this boundary. The\n purpose of this bound is to encode the concept of [exception safety][rfc] in\n the type system. Most usage of this function should not need to worry about\n this bound as programs are naturally unwind safe without `unsafe` code. If\n it becomes a problem the [`AssertUnwindSafe`] wrapper struct can be used to\n quickly assert that the usage here is indeed unwind safe.\n\n [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n\n # Notes\n\n This function **might not catch all Rust panics**. A Rust panic is not\n always implemented via unwinding, but can be implemented by aborting the\n process as well. This function *only* catches unwinding panics, not those\n that abort the process.\n\n If a custom panic hook has been set, it will be invoked before the panic is\n caught, before unwinding.\n\n Although unwinding into Rust code with a foreign exception (e.g. an\n exception thrown from C++ code, or a `panic!` in Rust code compiled or\n linked with a different runtime) via an appropriate ABI (e.g. `\"C-unwind\"`)\n is permitted, catching such an exception using this function will have one\n of two behaviors, and it is unspecified which will occur:\n\n * The process aborts, after executing all destructors of `f` and the\n   functions it called.\n * The function returns a `Result::Err` containing an opaque type.\n\n Finally, be **careful in how you drop the result of this function**. If it\n is `Err`, it contains the panic payload, and dropping that may in turn\n panic!\n\n # Examples\n\n ```\n use std::panic;\n\n let result = panic::catch_unwind(|| {\n     println!(\"hello!\");\n });\n assert!(result.is_ok());\n\n let result = panic::catch_unwind(|| {\n     panic!(\"oh no!\");\n });\n assert!(result.is_err());\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "alloc_crate::boxed::Box": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicUsize::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    },
    "thread::thread::Thread::park": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Like the public [`park`], but callable on any handle. This is used to\n allow parking in TLS destructors.\n\n # Safety\n May only be called from the thread to which this handle belongs.\n\n [`park`]: super::park\n",
      "adt": {
        "thread::thread::Thread": "ImmutableAsArgument"
      }
    },
    "panic::resume_unwind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Triggers a panic without invoking the panic hook.\n\n This is designed to be used in conjunction with [`catch_unwind`] to, for\n example, carry a panic across a layer of C code.\n\n # Notes\n\n Note that panics in Rust are not always implemented via unwinding, but they\n may be implemented by aborting the process. If this function is called when\n panics are implemented this way then this function will abort the process,\n not trigger an unwind.\n\n # Examples\n\n ```should_panic\n use std::panic;\n\n let result = panic::catch_unwind(|| {\n     if 1 != 2 {\n         panic!(\"oh no!\");\n     }\n });\n\n if let Err(err) = result {\n     panic::resume_unwind(err);\n }\n ```\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicBool::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the bool.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering\n of this operation. Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n use std::sync::atomic::{AtomicBool, Ordering};\n\n let some_bool = AtomicBool::new(true);\n\n assert_eq!(some_bool.load(Ordering::Relaxed), true);\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicUsize": [
      "Plain",
      "Ref"
    ],
    "thread::thread::Thread": [
      "Plain",
      "Ref"
    ],
    "core::sync::atomic::AtomicBool": [
      "Plain",
      "Ref"
    ],
    "thread::scoped::ScopeData": [
      "Plain",
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "alloc_crate::sync::Arc": [
      "Plain",
      "Ref"
    ],
    "thread::scoped::Scope": [
      "Plain",
      "Ref",
      "Unknown([Field(0, Ty { id: 506, kind: RigidTy(Adt(AdtDef(DefId { id: 4653, name: \"alloc_crate::sync::Arc\" }), GenericArgs([Type(Ty { id: 738, kind: RigidTy(Adt(AdtDef(DefId { id: 4670, name: \"thread::scoped::ScopeData\" }), GenericArgs([]))) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::panic::AssertUnwindSafe": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 10, kind: RigidTy(Adt(AdtDef(DefId { id: 4386, name: \"alloc_crate::boxed::Box\" }), GenericArgs([Type(Ty { id: 18, kind: RigidTy(Dynamic([Binder { value: Trait(ExistentialTraitRef { def_id: TraitDef(DefId { id: 4633, name: \"core::any::Any\" }), generic_args: GenericArgs([]) }), bound_vars: [] }, Binder { value: AutoTrait(TraitDef(DefId { id: 4634, name: \"core::marker::Send\" })), bound_vars: [] }], Region { kind: ReErased })) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 515, kind: Param(ParamTy { index: 2, name: \"T\" }) })])"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "alloc_crate::boxed::Box": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ]
  },
  "path": 4534,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/scoped.rs:138:1: 171:2",
  "src": "pub fn scope<'env, F, T>(f: F) -> T\nwhere\n    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n{\n    // We put the `ScopeData` into an `Arc` so that other threads can finish their\n    // `decrement_num_running_threads` even after this function returns.\n    let scope = Scope {\n        data: Arc::new(ScopeData {\n            num_running_threads: AtomicUsize::new(0),\n            main_thread: current_or_unnamed(),\n            a_thread_panicked: AtomicBool::new(false),\n        }),\n        env: PhantomData,\n        scope: PhantomData,\n    };\n\n    // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n    let result = catch_unwind(AssertUnwindSafe(|| f(&scope)));\n\n    // Wait until all the threads are finished.\n    while scope.data.num_running_threads.load(Ordering::Acquire) != 0 {\n        // SAFETY: this is the main thread, the handle belongs to us.\n        unsafe { scope.data.main_thread.park() };\n    }\n\n    // Throw any panic from `f`, or the return value of `f` if no thread panicked.\n    match result {\n        Err(e) => resume_unwind(e),\n        Ok(_) if scope.data.a_thread_panicked.load(Ordering::Relaxed) => {\n            panic!(\"a scoped thread panicked\")\n        }\n        Ok(result) => result,\n    }\n}",
  "mir": "fn thread::scoped::scope(_1: F) -> T {\n    let mut _0: T;\n    let  _2: thread::scoped::Scope<'_, '_>;\n    let mut _3: alloc_crate::sync::Arc<thread::scoped::ScopeData>;\n    let mut _4: thread::scoped::ScopeData;\n    let mut _5: core::sync::atomic::AtomicUsize;\n    let mut _6: thread::thread::Thread;\n    let mut _7: core::sync::atomic::AtomicBool;\n    let  _8: core::result::Result<T, alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>>;\n    let mut _9: core::panic::AssertUnwindSafe<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/scoped.rs:155:48: 155:50}>;\n    let mut _10: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/scoped.rs:155:48: 155:50};\n    let mut _11: &thread::scoped::Scope<'_, '_>;\n    let mut _12: usize;\n    let mut _13: &core::sync::atomic::AtomicUsize;\n    let  _14: &thread::scoped::ScopeData;\n    let mut _15: &alloc_crate::sync::Arc<thread::scoped::ScopeData>;\n    let mut _16: core::sync::atomic::Ordering;\n    let  _17: ();\n    let mut _18: &thread::thread::Thread;\n    let  _19: &thread::scoped::ScopeData;\n    let mut _20: &alloc_crate::sync::Arc<thread::scoped::ScopeData>;\n    let mut _21: isize;\n    let  _22: alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>;\n    let mut _23: !;\n    let mut _24: bool;\n    let mut _25: &core::sync::atomic::AtomicBool;\n    let  _26: &thread::scoped::ScopeData;\n    let mut _27: &alloc_crate::sync::Arc<thread::scoped::ScopeData>;\n    let mut _28: core::sync::atomic::Ordering;\n    let  _29: !;\n    let mut _30: core::fmt::Arguments<'_>;\n    debug f => _1;\n    debug scope => _2;\n    debug result => _8;\n    debug e => _22;\n    debug result => _0;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = core::sync::atomic::AtomicUsize::new(0_usize) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = thread::current::current_or_unnamed() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        _7 = core::sync::atomic::AtomicBool::new(false) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = ScopeData(move _5, move _7, move _6);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageDead(_5);\n        _3 = alloc_crate::sync::Arc::<thread::scoped::ScopeData>::new(move _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        _2 = Scope(move _3, core::marker::PhantomData::<&mut &()>, core::marker::PhantomData::<&mut &()>);\n        StorageDead(_3);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &_2;\n        _10 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/scoped.rs:155:48: 155:50}(move _1, move _11);\n        StorageDead(_11);\n        _9 = AssertUnwindSafe(move _10);\n        StorageDead(_10);\n        _8 = panic::catch_unwind::<core::panic::AssertUnwindSafe<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/scoped.rs:155:48: 155:50}>, T>(move _9) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_9);\n        goto -> bb6;\n    }\n    bb6: {\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(_2.0: alloc_crate::sync::Arc<thread::scoped::ScopeData>);\n        _14 = <alloc_crate::sync::Arc<thread::scoped::ScopeData> as core::ops::Deref>::deref(move _15) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_15);\n        _13 = &((*_14).0: core::sync::atomic::AtomicUsize);\n        StorageLive(_16);\n        _16 = core::sync::atomic::Ordering::Acquire;\n        _12 = core::sync::atomic::AtomicUsize::load(move _13, move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        StorageDead(_13);\n        switchInt(move _12) -> [0: bb12, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = &(_2.0: alloc_crate::sync::Arc<thread::scoped::ScopeData>);\n        _19 = <alloc_crate::sync::Arc<thread::scoped::ScopeData> as core::ops::Deref>::deref(move _20) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_20);\n        _18 = &((*_19).2: thread::thread::Thread);\n        _17 = thread::thread::Thread::park(move _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_19);\n        StorageDead(_18);\n        goto -> bb6;\n    }\n    bb12: {\n        StorageDead(_14);\n        StorageDead(_12);\n        _21 = discriminant(_8);\n        switchInt(move _21) -> [0: bb14, 1: bb15, otherwise: bb13];\n    }\n    bb13: {\n        unreachable;\n    }\n    bb14: {\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = &(_2.0: alloc_crate::sync::Arc<thread::scoped::ScopeData>);\n        _26 = <alloc_crate::sync::Arc<thread::scoped::ScopeData> as core::ops::Deref>::deref(move _27) -> [return: bb16, unwind unreachable];\n    }\n    bb15: {\n        _22 = move ((_8 as variant#1).0: alloc_crate::boxed::Box<dyn core::any::Any + core::marker::Send>);\n        _23 = panic::resume_unwind(_22) -> unwind unreachable;\n    }\n    bb16: {\n        StorageDead(_27);\n        _25 = &((*_26).1: core::sync::atomic::AtomicBool);\n        StorageLive(_28);\n        _28 = core::sync::atomic::Ordering::Relaxed;\n        _24 = core::sync::atomic::AtomicBool::load(move _25, move _28) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        switchInt(move _24) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_28);\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageLive(_30);\n        _30 = core::fmt::Arguments::<'_>::from_str(\"a scoped thread panicked\") -> [return: bb20, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_28);\n        StorageDead(_26);\n        StorageDead(_25);\n        StorageDead(_24);\n        _0 = move ((_8 as variant#0).0: T);\n        StorageDead(_8);\n        drop(_2) -> [return: bb21, unwind unreachable];\n    }\n    bb20: {\n        _29 = core::panicking::panic_fmt(move _30) -> unwind unreachable;\n    }\n    bb21: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Creates a scope for spawning scoped threads.\n\n The function passed to `scope` will be provided a [`Scope`] object,\n through which scoped threads can be [spawned][`Scope::spawn`].\n\n Unlike non-scoped threads, scoped threads can borrow non-`'static` data,\n as the scope guarantees all threads will be joined at the end of the scope.\n\n All threads spawned within the scope that haven't been manually joined\n will be automatically joined before this function returns.\n\n # Panics\n\n If any of the automatically joined threads panicked, this function will panic.\n\n If you want to handle panics from spawned threads,\n [`join`][ScopedJoinHandle::join] them before the end of the scope.\n\n # Example\n\n ```\n use std::thread;\n\n let mut a = vec![1, 2, 3];\n let mut x = 0;\n\n thread::scope(|s| {\n     s.spawn(|| {\n         println!(\"hello from the first scoped thread\");\n         // We can borrow `a` here.\n         dbg!(&a);\n     });\n     s.spawn(|| {\n         println!(\"hello from the second scoped thread\");\n         // We can even mutably borrow `x` here,\n         // because no other threads are using it.\n         x += a[0] + a[2];\n     });\n     println!(\"hello from the main thread\");\n });\n\n // After the scope, we can modify and access our variables again:\n a.push(4);\n assert_eq!(x, a.len());\n ```\n\n # Lifetimes\n\n Scoped threads involve two lifetimes: `'scope` and `'env`.\n\n The `'scope` lifetime represents the lifetime of the scope itself.\n That is: the time during which new scoped threads may be spawned,\n and also the time during which they might still be running.\n Once this lifetime ends, all scoped threads are joined.\n This lifetime starts within the `scope` function, before `f` (the argument to `scope`) starts.\n It ends after `f` returns and all scoped threads have been joined, but before `scope` returns.\n\n The `'env` lifetime represents the lifetime of whatever is borrowed by the scoped threads.\n This lifetime must outlast the call to `scope`, and thus cannot be smaller than `'scope`.\n It can be as small as the call to `scope`, meaning that anything that outlives this call,\n such as local variables defined right before the scope, can be borrowed by the scoped threads.\n\n The `'env: 'scope` bound is part of the definition of the `Scope` type.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}