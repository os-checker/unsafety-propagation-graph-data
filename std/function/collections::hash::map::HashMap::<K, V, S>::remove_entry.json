{
  "name": "collections::hash::map::HashMap::<K, V, S>::remove_entry",
  "safe": true,
  "callees": {
    "hashbrown::HashMap::<K, V, S, A>::remove_entry": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Removes a key from the map, returning the stored key and value if the\n key was previously in the map. Keeps the allocated memory for reuse.\n\n The key may be any borrowed form of the map's key type, but\n [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n the key type.\n\n [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n [`Hash`]: https://doc.rust-lang.org/std/hash/trait.Hash.html\n\n # Examples\n\n ```\n use hashbrown::HashMap;\n\n let mut map = HashMap::new();\n // The map is empty\n assert!(map.is_empty() && map.capacity() == 0);\n\n map.insert(1, \"a\");\n\n assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n assert_eq!(map.remove(&1), None);\n\n // Now map hold none elements\n assert!(map.is_empty());\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "hashbrown::HashMap": [
      "MutRef"
    ],
    "collections::hash::map::HashMap": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::collections::hash::map::HashMap::<K, V, S>::remove_entry"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:1291:5: 1297:6",
  "src": "pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\n    where\n        K: Borrow<Q>,\n        Q: Hash + Eq,\n    {\n        self.base.remove_entry(k)\n    }",
  "mir": "fn collections::hash::map::HashMap::<K, V, S>::remove_entry(_1: &mut collections::hash::map::HashMap<K, V, S>, _2: &Q) -> core::option::Option<(K, V)> {\n    let mut _0: core::option::Option<(K, V)>;\n    let mut _3: &mut hashbrown::HashMap<K, V, S>;\n    debug self => _1;\n    debug k => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &mut ((*_1).0: hashbrown::HashMap<K, V, S>);\n        _0 = hashbrown::HashMap::<K, V, S>::remove_entry::<Q>(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Removes a key from the map, returning the stored key and value if the\n key was previously in the map.\n\n The key may be any borrowed form of the map's key type, but\n [`Hash`] and [`Eq`] on the borrowed form *must* match those for\n the key type.\n\n # Examples\n\n ```\n use std::collections::HashMap;\n\n # fn main() {\n let mut map = HashMap::new();\n map.insert(1, \"a\");\n assert_eq!(map.remove_entry(&1), Some((1, \"a\")));\n assert_eq!(map.remove(&1), None);\n # }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}