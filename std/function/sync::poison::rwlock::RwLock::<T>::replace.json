{
  "name": "sync::poison::rwlock::RwLock::<T>::replace",
  "safe": true,
  "callees": {
    "sync::poison::rwlock::RwLock::<T>::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks this `RwLock` with exclusive write access, blocking the current\n thread until it can be acquired.\n\n This function will not return while other writers or other readers\n currently have access to the lock.\n\n Returns an RAII guard which will drop the write access of this `RwLock`\n when dropped.\n\n # Errors\n\n This function will return an error if the `RwLock` is poisoned. An\n `RwLock` is poisoned whenever a writer panics while holding an exclusive\n lock. An error will be returned when the lock is acquired. The acquired\n lock guard will be contained in the returned error.\n\n # Panics\n\n This function might panic when called if the lock is already held by the current thread.\n\n # Examples\n\n ```\n use std::sync::RwLock;\n\n let lock = RwLock::new(1);\n\n let mut n = lock.write().unwrap();\n *n = 2;\n\n assert!(lock.try_read().is_err());\n ```\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::rwlock::RwLockWriteGuard": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::mem::replace": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Moves `src` into the referenced `dest`, returning the previous `dest` value.\n\n Neither value is dropped.\n\n * If you want to replace the values of two variables, see [`swap`].\n * If you want to replace with a default value, see [`take`].\n\n # Examples\n\n A simple example:\n\n ```\n use std::mem;\n\n let mut v: Vec<i32> = vec![1, 2];\n\n let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n assert_eq!(vec![1, 2], old_v);\n assert_eq!(vec![3, 4, 5], v);\n ```\n\n `replace` allows consumption of a struct field by replacing it with another value.\n Without `replace` you can run into issues like these:\n\n ```compile_fail,E0507\n struct Buffer<T> { buf: Vec<T> }\n\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         // error: cannot move out of dereference of `&mut`-pointer\n         let t = self.buf[i];\n         self.buf[i] = v;\n         t\n     }\n }\n ```\n\n Note that `T` does not necessarily implement [`Clone`], so we can't even clone `self.buf[i]` to\n avoid the move. But `replace` can be used to disassociate the original value at that index from\n `self`, allowing it to be returned:\n\n ```\n # #![allow(dead_code)]\n use std::mem;\n\n # struct Buffer<T> { buf: Vec<T> }\n impl<T> Buffer<T> {\n     fn replace_index(&mut self, i: usize, v: T) -> T {\n         mem::replace(&mut self.buf[i], v)\n     }\n }\n\n let mut buffer = Buffer { buf: vec![0, 1] };\n assert_eq!(buffer.buf[0], 0);\n\n assert_eq!(buffer.replace_index(0, 2), 0);\n assert_eq!(buffer.buf[0], 2);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::poison::rwlock::RwLock": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12274, kind: RigidTy(Adt(AdtDef(DefId { id: 9991, name: \"sync::poison::rwlock::RwLockWriteGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "sync::poison::rwlock::RwLockWriteGuard": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 3263,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/rwlock.rs:342:5: 347:6",
  "src": "pub fn replace(&self, value: T) -> LockResult<T> {\n        match self.write() {\n            Ok(mut guard) => Ok(mem::replace(&mut *guard, value)),\n            Err(_) => Err(PoisonError::new(value)),\n        }\n    }",
  "mir": "fn sync::poison::rwlock::RwLock::<T>::replace(_1: &sync::poison::rwlock::RwLock<T>, _2: T) -> core::result::Result<T, sync::poison::PoisonError<T>> {\n    let mut _0: core::result::Result<T, sync::poison::PoisonError<T>>;\n    let mut _3: core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>;\n    let mut _4: sync::poison::rwlock::RwLockWriteGuard<'_, T>;\n    let mut _5: T;\n    let mut _6: &mut T;\n    let mut _7: &mut sync::poison::rwlock::RwLockWriteGuard<'_, T>;\n    let mut _8: isize;\n    debug self => _1;\n    debug value => _2;\n    debug guard => _4;\n    bb0: {\n        StorageLive(_3);\n        _3 = sync::poison::rwlock::RwLock::<T>::write(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = move ((_3 as variant#0).0: sync::poison::rwlock::RwLockWriteGuard<'_, T>);\n        StorageLive(_5);\n        StorageLive(_7);\n        _7 = &mut _4;\n        _6 = <sync::poison::rwlock::RwLockWriteGuard<'_, T> as core::ops::DerefMut>::deref_mut(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _5 = core::mem::replace::<T>(_6, _2) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core::result::Result::Ok(move _5);\n        StorageDead(_5);\n        drop(_4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        _8 = discriminant(_3);\n        switchInt(move _8) -> [0: bb5, otherwise: bb6];\n    }\n    bb5: {\n        StorageDead(_3);\n        return;\n    }\n    bb6: {\n        unreachable;\n    }\n}\n",
  "doc": " Replaces the contained value with `value`, and returns the old contained value.\n\n # Errors\n\n This function will return an error containing the provided `value` if\n the `RwLock` is poisoned. An `RwLock` is poisoned whenever a writer\n panics while holding an exclusive lock.\n\n # Examples\n\n ```\n #![feature(lock_value_accessors)]\n\n use std::sync::RwLock;\n\n let mut lock = RwLock::new(7);\n\n assert_eq!(lock.replace(11).unwrap(), 7);\n assert_eq!(lock.get_cloned().unwrap(), 11);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}