{
  "name": "sync::once::Once::call_once",
  "safe": true,
  "callees": {
    "sys::sync::once::futex::Once::is_completed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::once::futex::Once": "ImmutableAsArgument"
      }
    },
    "sys::sync::once::futex::Once::call": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::once::futex::Once": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sys::sync::once::futex::Once": [
      "Ref"
    ],
    "sync::once::Once": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::option::Option": [
      "Plain",
      "MutRef"
    ]
  },
  "path": 3150,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/once.rs:149:5: 160:6",
  "src": "pub fn call_once<F>(&self, f: F)\n    where\n        F: FnOnce(),\n    {\n        // Fast path check\n        if self.inner.is_completed() {\n            return;\n        }\n\n        let mut f = Some(f);\n        self.inner.call(false, &mut |_| f.take().unwrap()());\n    }",
  "mir": "fn sync::once::Once::call_once(_1: &sync::once::Once, _2: F) -> () {\n    let mut _0: ();\n    let mut _3: bool;\n    let mut _4: &sys::sync::once::futex::Once;\n    let mut _5: core::option::Option<F>;\n    let mut _6: F;\n    let  _7: ();\n    let mut _8: &sys::sync::once::futex::Once;\n    let mut _9: &mut dyn for<'a> core::ops::FnMut(&'a sync::once::OnceState);\n    let mut _10: &mut {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/once.rs:159:37: 159:40};\n    let mut _11: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/once.rs:159:37: 159:40};\n    let mut _12: &mut core::option::Option<F>;\n    debug self => _1;\n    debug f => _2;\n    debug f => _5;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: sys::sync::once::futex::Once);\n        _3 = sys::sync::once::futex::Once::is_completed(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _3) -> [0: bb3, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_4);\n        StorageDead(_3);\n        drop(_2) -> [return: bb6, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = move _2;\n        _5 = core::option::Option::Some(move _6);\n        StorageDead(_6);\n        StorageLive(_8);\n        _8 = &((*_1).0: sys::sync::once::futex::Once);\n        StorageLive(_9);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut _5;\n        _11 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/once.rs:159:37: 159:40}(move _12);\n        StorageDead(_12);\n        _10 = &mut _11;\n        _9 = _10 as &mut dyn for<'a> core::ops::FnMut(&'a sync::once::OnceState);\n        _7 = sys::sync::once::futex::Once::call(move _8, false, move _9) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageDead(_11);\n        drop(_5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        goto -> bb6;\n    }\n    bb6: {\n        return;\n    }\n}\n",
  "doc": " Performs an initialization routine once and only once. The given closure\n will be executed if this is the first time `call_once` has been called,\n and otherwise the routine will *not* be invoked.\n\n This method will block the calling thread if another initialization\n routine is currently running.\n\n When this function returns, it is guaranteed that some initialization\n has run and completed (it might not be the closure specified). It is also\n guaranteed that any memory writes performed by the executed closure can\n be reliably observed by other threads at this point (there is a\n happens-before relation between the closure and code executing after the\n return).\n\n If the given closure recursively invokes `call_once` on the same [`Once`]\n instance, the exact behavior is not specified: allowed outcomes are\n a panic or a deadlock.\n\n # Examples\n\n ```\n use std::sync::Once;\n\n static mut VAL: usize = 0;\n static INIT: Once = Once::new();\n\n // Accessing a `static mut` is unsafe much of the time, but if we do so\n // in a synchronized fashion (e.g., write once or read all) then we're\n // good to go!\n //\n // This function will only call `expensive_computation` once, and will\n // otherwise always return the value returned from the first invocation.\n fn get_cached_val() -> usize {\n     unsafe {\n         INIT.call_once(|| {\n             VAL = expensive_computation();\n         });\n         VAL\n     }\n }\n\n fn expensive_computation() -> usize {\n     // ...\n # 2\n }\n ```\n\n # Panics\n\n The closure `f` will only be executed once even if this is called\n concurrently amongst many threads. If that closure panics, however, then\n it will *poison* this [`Once`] instance, causing all future invocations of\n `call_once` to also panic.\n\n This is similar to [poisoning with mutexes][poison], but this mechanism\n is guaranteed to never skip panics within `f`.\n\n [poison]: struct.Mutex.html#poisoning\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}