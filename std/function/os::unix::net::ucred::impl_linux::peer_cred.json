{
  "name": "os::unix::net::ucred::impl_linux::peer_cred",
  "safe": true,
  "callees": {
    "core::mem::size_of": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of a type in bytes.\n\n More specifically, this is the offset in bytes between successive elements\n in an array with that item type including alignment padding. Thus, for any\n type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n\n In general, the size of a type is not stable across compilations, but\n specific types such as primitives are.\n\n The following table gives the size for primitives.\n\n Type | `size_of::<Type>()`\n ---- | ---------------\n () | 0\n bool | 1\n u8 | 1\n u16 | 2\n u32 | 4\n u64 | 8\n u128 | 16\n i8 | 1\n i16 | 2\n i32 | 4\n i64 | 8\n i128 | 16\n f32 | 4\n f64 | 8\n char | 4\n\n Furthermore, `usize` and `isize` have the same size.\n\n The types [`*const T`], `&T`, [`Box<T>`], [`Option<&T>`], and `Option<Box<T>>` all have\n the same size. If `T` is `Sized`, all of those types have the same size as `usize`.\n\n The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n have the same size. Likewise for `*const T` and `*mut T`.\n\n # Size of `#[repr(C)]` items\n\n The `C` representation for items has a defined layout. With this layout,\n the size of items is also stable as long as all fields have a stable size.\n\n ## Size of Structs\n\n For `struct`s, the size is determined by the following algorithm.\n\n For each field in the struct ordered by declaration order:\n\n 1. Add the size of the field.\n 2. Round up the current size to the nearest multiple of the next field's [alignment].\n\n Finally, round the size of the struct to the nearest multiple of its [alignment].\n The alignment of the struct is usually the largest alignment of all its\n fields; this can be changed with the use of `repr(align(N))`.\n\n Unlike `C`, zero sized structs are not rounded up to one byte in size.\n\n ## Size of Enums\n\n Enums that carry no data other than the discriminant have the same size as C enums\n on the platform they are compiled for.\n\n ## Size of Unions\n\n The size of a union is the size of its largest field.\n\n Unlike `C`, zero sized unions are not rounded up to one byte in size.\n\n # Examples\n\n ```\n // Some primitives\n assert_eq!(4, size_of::<i32>());\n assert_eq!(8, size_of::<f64>());\n assert_eq!(0, size_of::<()>());\n\n // Some arrays\n assert_eq!(8, size_of::<[i32; 2]>());\n assert_eq!(12, size_of::<[i32; 3]>());\n assert_eq!(0, size_of::<[i32; 0]>());\n\n\n // Pointer size equality\n assert_eq!(size_of::<&i32>(), size_of::<*const i32>());\n assert_eq!(size_of::<&i32>(), size_of::<Box<i32>>());\n assert_eq!(size_of::<&i32>(), size_of::<Option<&i32>>());\n assert_eq!(size_of::<Box<i32>>(), size_of::<Option<Box<i32>>>());\n ```\n\n Using `#[repr(C)]`.\n\n ```\n #[repr(C)]\n struct FieldStruct {\n     first: u8,\n     second: u16,\n     third: u8\n }\n\n // The size of the first field is 1, so add 1 to the size. Size is 1.\n // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n // The size of the second field is 2, so add 2 to the size. Size is 4.\n // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n // The size of the third field is 1, so add 1 to the size. Size is 5.\n // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n // fields is 2), so add 1 to the size for padding. Size is 6.\n assert_eq!(6, size_of::<FieldStruct>());\n\n #[repr(C)]\n struct TupleStruct(u8, u16, u8);\n\n // Tuple structs follow the same rules.\n assert_eq!(6, size_of::<TupleStruct>());\n\n // Note that reordering the fields can lower the size. We can remove both padding bytes\n // by putting `third` before `second`.\n #[repr(C)]\n struct FieldStructOptimized {\n     first: u8,\n     third: u8,\n     second: u16\n }\n\n assert_eq!(4, size_of::<FieldStructOptimized>());\n\n // Union size is the size of the largest field.\n #[repr(C)]\n union ExampleUnion {\n     smaller: u8,\n     larger: u16\n }\n\n assert_eq!(2, size_of::<ExampleUnion>());\n ```\n\n [alignment]: align_of\n [`*const T`]: primitive@pointer\n [`Box<T>`]: ../../std/boxed/struct.Box.html\n [`Option<&T>`]: crate::option::Option\n\n",
      "adt": {}
    },
    "core::panicking::panic": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The underlying implementation of core's `panic!` macro when no formatting is used.\n",
      "adt": {}
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "libc::getsockopt": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    }
  },
  "adts": {
    "libc::ucred": [
      "Plain",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(2, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "os::unix::net::stream::UnixStream": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "os::unix::net::ucred::UCred": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "io::error::Error": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::os::unix::net::ucred::impl_linux::peer_cred"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/ucred.rs:48:5: 73:6",
  "src": "pub fn peer_cred(socket: &UnixStream) -> io::Result<UCred> {\n        let ucred_size = size_of::<ucred>();\n\n        // Trivial sanity checks.\n        assert!(size_of::<u32>() <= size_of::<usize>());\n        assert!(ucred_size <= u32::MAX as usize);\n\n        let mut ucred_size = ucred_size as socklen_t;\n        let mut ucred: ucred = ucred { pid: 1, uid: 1, gid: 1 };\n\n        unsafe {\n            let ret = getsockopt(\n                socket.as_raw_fd(),\n                SOL_SOCKET,\n                SO_PEERCRED,\n                (&raw mut ucred) as *mut c_void,\n                &mut ucred_size,\n            );\n\n            if ret == 0 && ucred_size as usize == size_of::<ucred>() {\n                Ok(UCred { uid: ucred.uid, gid: ucred.gid, pid: Some(ucred.pid) })\n            } else {\n                Err(io::Error::last_os_error())\n            }\n        }\n    }",
  "mir": "fn os::unix::net::ucred::impl_linux::peer_cred(_1: &os::unix::net::stream::UnixStream) -> core::result::Result<os::unix::net::ucred::UCred, io::error::Error> {\n    let mut _0: core::result::Result<os::unix::net::ucred::UCred, io::error::Error>;\n    let  _2: usize;\n    let mut _3: bool;\n    let mut _4: usize;\n    let mut _5: usize;\n    let mut _6: !;\n    let mut _7: bool;\n    let mut _8: usize;\n    let mut _9: !;\n    let mut _10: u32;\n    let mut _11: libc::ucred;\n    let  _12: i32;\n    let mut _13: i32;\n    let mut _14: *mut libc::c_void;\n    let mut _15: *mut libc::ucred;\n    let mut _16: *mut u32;\n    let mut _17: &mut u32;\n    let mut _18: bool;\n    let mut _19: usize;\n    let mut _20: u32;\n    let mut _21: usize;\n    let mut _22: os::unix::net::ucred::UCred;\n    let mut _23: u32;\n    let mut _24: u32;\n    let mut _25: core::option::Option<i32>;\n    let mut _26: i32;\n    let mut _27: io::error::Error;\n    debug socket => _1;\n    debug ucred_size => _2;\n    debug ucred_size => _10;\n    debug ucred => _11;\n    debug ret => _12;\n    bb0: {\n        _2 = core::mem::size_of::<libc::ucred>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = core::mem::size_of::<u32>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_5);\n        _5 = core::mem::size_of::<usize>() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _3 = Le(move _4, move _5);\n        switchInt(move _3) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_3);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = core::num::<impl u32>::MAX as usize;\n        _7 = Le(_2, move _8);\n        switchInt(move _7) -> [0: bb7, otherwise: bb6];\n    }\n    bb5: {\n        StorageDead(_5);\n        StorageDead(_4);\n        _6 = core::panicking::panic(\"assertion failed: size_of::<u32>() <= size_of::<usize>()\") -> unwind unreachable;\n    }\n    bb6: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        _10 = _2 as u32;\n        StorageLive(_11);\n        _11 = ucred(1_i32, 1_u32, 1_u32);\n        StorageLive(_13);\n        _13 = <os::unix::net::stream::UnixStream as os::fd::raw::AsRawFd>::as_raw_fd(_1) -> [return: bb8, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_8);\n        _9 = core::panicking::panic(\"assertion failed: ucred_size <= u32::MAX as usize\") -> unwind unreachable;\n    }\n    bb8: {\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &raw mut _11;\n        _14 = move _15 as *mut libc::c_void;\n        StorageDead(_15);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = &mut _10;\n        _16 = &raw mut (*_17);\n        _12 = libc::getsockopt(move _13, libc::SOL_SOCKET, libc::SO_PEERCRED, move _14, move _16) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_13);\n        StorageDead(_17);\n        switchInt(_12) -> [0: bb10, otherwise: bb14];\n    }\n    bb10: {\n        StorageLive(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = _10;\n        _19 = move _20 as usize;\n        StorageDead(_20);\n        StorageLive(_21);\n        _21 = core::mem::size_of::<libc::ucred>() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        _18 = Eq(move _19, move _21);\n        switchInt(move _18) -> [0: bb13, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_21);\n        StorageDead(_19);\n        StorageLive(_22);\n        StorageLive(_23);\n        _23 = (_11.1: u32);\n        StorageLive(_24);\n        _24 = (_11.2: u32);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = (_11.0: i32);\n        _25 = core::option::Option::Some(move _26);\n        StorageDead(_26);\n        _22 = UCred(move _23, move _24, move _25);\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        _0 = core::result::Result::Ok(move _22);\n        StorageDead(_22);\n        goto -> bb17;\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_19);\n        goto -> bb15;\n    }\n    bb14: {\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_27);\n        _27 = io::error::Error::last_os_error() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _0 = core::result::Result::Err(move _27);\n        StorageDead(_27);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_18);\n        StorageDead(_11);\n        StorageDead(_10);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}