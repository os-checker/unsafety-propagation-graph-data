{
  "name": "thread::local::LocalKey::<T>::try_with",
  "safe": true,
  "callees": {
    "core::ptr::const_ptr::<impl *const T>::as_ref": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n ```\n let ptr: *const u8 = &10u8 as *const u8;\n\n unsafe {\n     let val_back = &*ptr;\n     assert_eq!(val_back, &10);\n }\n ```\n\n # Examples\n\n ```\n let ptr: *const u8 = &10u8 as *const u8;\n\n unsafe {\n     if let Some(val_back) = ptr.as_ref() {\n         assert_eq!(val_back, &10);\n     }\n }\n ```\n\n\n [`is_null`]: #method.is_null\n [`as_uninit_ref`]: #method.as_uninit_ref\n",
      "adt": {}
    },
    "core::option::Option::<T>::ok_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Transforms the `Option<T>` into a [`Result<T, E>`], mapping [`Some(v)`] to\n [`Ok(v)`] and [`None`] to [`Err(err)`].\n\n Arguments passed to `ok_or` are eagerly evaluated; if you are passing the\n result of a function call, it is recommended to use [`ok_or_else`], which is\n lazily evaluated.\n\n [`Ok(v)`]: Ok\n [`Err(err)`]: Err\n [`Some(v)`]: Some\n [`ok_or_else`]: Option::ok_or_else\n\n # Examples\n\n ```\n let x = Some(\"foo\");\n assert_eq!(x.ok_or(0), Ok(\"foo\"));\n\n let x: Option<&str> = None;\n assert_eq!(x.ok_or(0), Err(0));\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FnOnce::call_once": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "thread::local::LocalKey": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 419, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) }, Not)) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::thread::local::LocalKey::<T>::try_with"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:508:5: 514:6",
  "src": "pub fn try_with<F, R>(&'static self, f: F) -> Result<R, AccessError>\n    where\n        F: FnOnce(&T) -> R,\n    {\n        let thread_local = unsafe { (self.inner)(None).as_ref().ok_or(AccessError)? };\n        Ok(f(thread_local))\n    }",
  "mir": "fn thread::local::LocalKey::<T>::try_with(_1: &thread::local::LocalKey<T>, _2: F) -> core::result::Result<R, thread::local::AccessError> {\n    let mut _0: core::result::Result<R, thread::local::AccessError>;\n    let mut _3: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, thread::local::AccessError>, &T>;\n    let mut _4: core::result::Result<&T, thread::local::AccessError>;\n    let mut _5: core::option::Option<&T>;\n    let mut _6: *const T;\n    let mut _7: for<'a> fn(core::option::Option<&'a mut core::option::Option<T>>) -> *const T;\n    let mut _8: core::option::Option<&mut core::option::Option<T>>;\n    let mut _9: isize;\n    let  _10: &T;\n    let mut _11: R;\n    let mut _12: F;\n    let mut _13: (&T,);\n    debug self => _1;\n    debug f => _2;\n    debug thread_local => _10;\n    debug residual => core::result::Result::<core::convert::Infallible, thread::local::AccessError>::Err(thread::local::AccessError);\n    debug val => _10;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = ((*_1).0: for<'a> fn(core::option::Option<&'a mut core::option::Option<T>>) -> *const T);\n        StorageLive(_8);\n        _8 = core::option::Option::None;\n        _6 = move _7(move _8) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_8);\n        StorageDead(_7);\n        _5 = core::ptr::const_ptr::<impl *const T>::as_ref::<'_>(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = core::option::Option::<&T>::ok_or::<thread::local::AccessError>(move _5, thread::local::AccessError) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_5);\n        _3 = <core::result::Result<&T, thread::local::AccessError> as core::ops::Try>::branch(move _4) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_4);\n        _9 = discriminant(_3);\n        switchInt(move _9) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        _10 = ((_3 as variant#0).0: &T);\n        StorageDead(_3);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = move _2;\n        StorageLive(_13);\n        _13 = (_10);\n        _11 = <F as core::ops::FnOnce<(&T,)>>::call_once(move _12, move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _0 = <core::result::Result<R, thread::local::AccessError> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, thread::local::AccessError>>>::from_residual(core::result::Result::<core::convert::Infallible, thread::local::AccessError>::Err(thread::local::AccessError)) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_3);\n        drop(_2) -> [return: bb10, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_13);\n        StorageDead(_12);\n        _0 = core::result::Result::Ok(move _11);\n        StorageDead(_11);\n        goto -> bb10;\n    }\n    bb10: {\n        return;\n    }\n}\n",
  "doc": " Acquires a reference to the value in this TLS key.\n\n This will lazily initialize the value if this thread has not referenced\n this key yet. If the key has been destroyed (which may happen if this is called\n in a destructor), this function will return an [`AccessError`].\n\n # Panics\n\n This function will still `panic!()` if the key is uninitialized and the\n key's initializer panics.\n\n # Examples\n\n ```\n thread_local! {\n     pub static STATIC: String = String::from(\"I am\");\n }\n\n assert_eq!(\n     STATIC.try_with(|original_value| format!(\"{original_value} initialized\")),\n     Ok(String::from(\"I am initialized\")),\n );\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}