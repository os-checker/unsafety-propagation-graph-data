{
  "name": "os::fd::net::<impl os::fd::raw::IntoRawFd for net::udp::UdpSocket>::into_raw_fd",
  "safe": true,
  "callees": {
    "sys_common::IntoInner::into_inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::net::connection::socket::UdpSocket::into_socket": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::unix::Socket": "Constructor"
      }
    },
    "os::fd::raw::IntoRawFd::into_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Consumes this object, returning the raw underlying file descriptor.\n\n This function is typically used to **transfer ownership** of the underlying\n file descriptor to the caller. When used in this way, callers are then the unique\n owners of the file descriptor and must close it once it's no longer needed.\n\n However, transferring ownership is not strictly required. Use a\n [`Into<OwnedFd>::into`] implementation for an API which strictly\n transfers ownership.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{IntoRawFd, RawFd};\n\n let f = File::open(\"foo.txt\")?;\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.into_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "net::udp::UdpSocket": [
      "Plain"
    ],
    "sys::net::connection::socket::UdpSocket": [
      "Plain"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Plain"
    ],
    "sys::fd::unix::FileDesc": [
      "Plain"
    ],
    "os::fd::owned::OwnedFd": [
      "Plain"
    ]
  },
  "path": 1971,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/fd/net.rs:40:13: 42:14",
  "src": "fn into_raw_fd(self) -> RawFd {\n                self.into_inner().into_socket().into_inner().into_inner().into_raw_fd()\n            }",
  "mir": "fn os::fd::net::<impl os::fd::raw::IntoRawFd for net::udp::UdpSocket>::into_raw_fd(_1: net::udp::UdpSocket) -> i32 {\n    let mut _0: i32;\n    let mut _2: os::fd::owned::OwnedFd;\n    let mut _3: sys::fd::unix::FileDesc;\n    let mut _4: sys::net::connection::socket::unix::Socket;\n    let mut _5: sys::net::connection::socket::UdpSocket;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = <net::udp::UdpSocket as sys_common::IntoInner<sys::net::connection::socket::UdpSocket>>::into_inner(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = sys::net::connection::socket::UdpSocket::into_socket(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_5);\n        _3 = <sys::net::connection::socket::unix::Socket as sys_common::IntoInner<sys::fd::unix::FileDesc>>::into_inner(move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        _2 = <sys::fd::unix::FileDesc as sys_common::IntoInner<os::fd::owned::OwnedFd>>::into_inner(move _3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        _0 = <os::fd::owned::OwnedFd as os::fd::raw::IntoRawFd>::into_raw_fd(move _2) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}