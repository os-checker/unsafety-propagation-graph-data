{
  "name": "sync::poison::rwlock::RwLock::<T>::get_cloned",
  "safe": true,
  "callees": {
    "sync::poison::rwlock::RwLock::<T>::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Locks this `RwLock` with shared read access, blocking the current thread\n until it can be acquired.\n\n The calling thread will be blocked until there are no more writers which\n hold the lock. There may be other readers currently inside the lock when\n this method returns. This method does not provide any guarantees with\n respect to the ordering of whether contentious readers or writers will\n acquire the lock first.\n\n Returns an RAII guard which will release this thread's shared access\n once it is dropped.\n\n # Errors\n\n This function will return an error if the `RwLock` is poisoned. An\n `RwLock` is poisoned whenever a writer panics while holding an exclusive\n lock. The failure will occur immediately after the lock has been\n acquired. The acquired lock guard will be contained in the returned\n error.\n\n # Panics\n\n This function might panic when called if the lock is already held by the current thread.\n\n # Examples\n\n ```\n use std::sync::{Arc, RwLock};\n use std::thread;\n\n let lock = Arc::new(RwLock::new(1));\n let c_lock = Arc::clone(&lock);\n\n let n = lock.read().unwrap();\n assert_eq!(*n, 1);\n\n thread::spawn(move || {\n     let r = c_lock.read();\n     assert!(r.is_ok());\n }).join().unwrap();\n ```\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::clone::Clone::clone": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a duplicate of the value.\n\n Note that what \"duplicate\" means varies by type:\n - For most types, this creates a deep, independent copy\n - For reference types like `&T`, this creates another reference to the same value\n - For smart pointers like [`Arc`] or [`Rc`], this increments the reference count\n   but still points to the same underlying data\n\n [`Arc`]: ../../std/sync/struct.Arc.html\n [`Rc`]: ../../std/rc/struct.Rc.html\n\n # Examples\n\n ```\n # #![allow(noop_method_call)]\n let hello = \"Hello\"; // &str implements Clone\n\n assert_eq!(\"Hello\", hello.clone());\n ```\n\n Example with a reference-counted type:\n\n ```\n use std::sync::{Arc, Mutex};\n\n let data = Arc::new(Mutex::new(vec![1, 2, 3]));\n let data_clone = data.clone(); // Creates another Arc pointing to the same Mutex\n\n {\n     let mut lock = data.lock().unwrap();\n     lock.push(4);\n }\n\n // Changes are visible through the clone because they share the same underlying data\n assert_eq!(*data_clone.lock().unwrap(), vec![1, 2, 3, 4]);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sync::poison::rwlock::RwLock": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12262, kind: RigidTy(Adt(AdtDef(DefId { id: 9986, name: \"sync::poison::rwlock::RwLockReadGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "sync::poison::rwlock::RwLockReadGuard": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::poison::rwlock::RwLock::<T>::get_cloned"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/rwlock.rs:270:5: 278:6",
  "src": "pub fn get_cloned(&self) -> Result<T, PoisonError<()>>\n    where\n        T: Clone,\n    {\n        match self.read() {\n            Ok(guard) => Ok((*guard).clone()),\n            Err(_) => Err(PoisonError::new(())),\n        }\n    }",
  "mir": "fn sync::poison::rwlock::RwLock::<T>::get_cloned(_1: &sync::poison::rwlock::RwLock<T>) -> core::result::Result<T, sync::poison::PoisonError<()>> {\n    let mut _0: core::result::Result<T, sync::poison::PoisonError<()>>;\n    let mut _2: core::result::Result<sync::poison::rwlock::RwLockReadGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockReadGuard<'_, T>>>;\n    let  _3: sync::poison::rwlock::RwLockReadGuard<'_, T>;\n    let mut _4: T;\n    let  _5: &T;\n    let mut _6: &sync::poison::rwlock::RwLockReadGuard<'_, T>;\n    let mut _7: isize;\n    debug self => _1;\n    debug guard => _3;\n    bb0: {\n        StorageLive(_2);\n        _2 = sync::poison::rwlock::RwLock::<T>::read(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        _3 = move ((_2 as variant#0).0: sync::poison::rwlock::RwLockReadGuard<'_, T>);\n        StorageLive(_4);\n        StorageLive(_6);\n        _6 = &_3;\n        _5 = <sync::poison::rwlock::RwLockReadGuard<'_, T> as core::ops::Deref>::deref(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _4 = <T as core::clone::Clone>::clone(_5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _0 = core::result::Result::Ok(move _4);\n        StorageDead(_4);\n        drop(_3) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_3);\n        _7 = discriminant(_2);\n        switchInt(move _7) -> [0: bb5, otherwise: bb6];\n    }\n    bb5: {\n        StorageDead(_2);\n        return;\n    }\n    bb6: {\n        unreachable;\n    }\n}\n",
  "doc": " Returns the contained value by cloning it.\n\n # Errors\n\n This function will return an error if the `RwLock` is poisoned. An\n `RwLock` is poisoned whenever a writer panics while holding an exclusive\n lock.\n\n # Examples\n\n ```\n #![feature(lock_value_accessors)]\n\n use std::sync::RwLock;\n\n let mut lock = RwLock::new(7);\n\n assert_eq!(lock.get_cloned().unwrap(), 7);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}