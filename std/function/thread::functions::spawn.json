{
  "name": "thread::functions::spawn",
  "safe": true,
  "callees": {
    "thread::builder::Builder::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Generates the base configuration for spawning a thread, from which\n configuration methods can be chained.\n\n # Examples\n\n ```\n use std::thread;\n\n let builder = thread::Builder::new()\n                               .name(\"foo\".into())\n                               .stack_size(32 * 1024);\n\n let handler = builder.spawn(|| {\n     // thread code\n }).unwrap();\n\n handler.join().unwrap();\n ```\n",
      "adt": {
        "thread::builder::Builder": "Constructor"
      }
    },
    "thread::builder::Builder::spawn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Spawns a new thread by taking ownership of the `Builder`, and returns an\n [`io::Result`] to its [`JoinHandle`].\n\n The spawned thread may outlive the caller (unless the caller thread\n is the main thread; the whole process is terminated when the main\n thread finishes). The join handle can be used to block on\n termination of the spawned thread, including recovering its panics.\n\n For a more complete documentation see [`thread::spawn`].\n\n # Errors\n\n Unlike the [`spawn`] free function, this method yields an\n [`io::Result`] to capture any failure to create the thread at\n the OS level.\n\n [`io::Result`]: crate::io::Result\n\n # Panics\n\n Panics if a thread name was set and it contained null bytes.\n\n # Examples\n\n ```\n use std::thread;\n\n let builder = thread::Builder::new();\n\n let handler = builder.spawn(|| {\n     // thread code\n }).unwrap();\n\n handler.join().unwrap();\n ```\n\n [`thread::spawn`]: super::spawn\n [`spawn`]: super::spawn\n",
      "adt": {
        "core::result::Result": "Constructor",
        "thread::join_handle::JoinHandle": "Constructor"
      }
    },
    "core::result::Result::<T, E>::expect": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Instead, prefer to use pattern matching and handle the [`Err`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`].\n\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message including the\n passed message, and the content of the [`Err`].\n\n\n # Examples\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n ```\n\n # Recommended Message Style\n\n We recommend that `expect` messages are used to describe the reason you\n _expect_ the `Result` should be `Ok`.\n\n ```should_panic\n let path = std::env::var(\"IMPORTANT_PATH\")\n     .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n ```\n\n **Hint**: If you're having trouble remembering how to phrase expect\n error messages remember to focus on the word \"should\" as in \"env\n variable should be set by blah\" or \"the given binary should be available\n and executable by the current user\".\n\n For more detail on expect message styles and the reasoning behind our recommendation please\n refer to the section on [\"Common Message\n Styles\"](../../std/error/index.html#common-message-styles) in the\n [`std::error`](../../std/error/index.html) module docs.\n",
      "adt": {}
    }
  },
  "adts": {
    "thread::builder::Builder": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "thread::join_handle::JoinHandle": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::thread::functions::spawn"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/functions.rs:125:1: 132:2",
  "src": "pub fn spawn<F, T>(f: F) -> JoinHandle<T>\nwhere\n    F: FnOnce() -> T,\n    F: Send + 'static,\n    T: Send + 'static,\n{\n    Builder::new().spawn(f).expect(\"failed to spawn thread\")\n}",
  "mir": "fn thread::functions::spawn(_1: F) -> thread::join_handle::JoinHandle<T> {\n    let mut _0: thread::join_handle::JoinHandle<T>;\n    let mut _2: core::result::Result<thread::join_handle::JoinHandle<T>, io::error::Error>;\n    let mut _3: thread::builder::Builder;\n    let mut _4: &str;\n    debug f => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = thread::builder::Builder::new() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = thread::builder::Builder::spawn::<F, T>(move _3, _1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = \"failed to spawn thread\";\n        _0 = core::result::Result::<thread::join_handle::JoinHandle<T>, io::error::Error>::expect(move _2, move _4) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_4);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Spawns a new thread, returning a [`JoinHandle`] for it.\n\n The join handle provides a [`join`] method that can be used to join the spawned\n thread. If the spawned thread panics, [`join`] will return an [`Err`] containing\n the argument given to [`panic!`].\n\n If the join handle is dropped, the spawned thread will implicitly be *detached*.\n In this case, the spawned thread may no longer be joined.\n (It is the responsibility of the program to either eventually join threads it\n creates or detach them; otherwise, a resource leak will result.)\n\n This function creates a thread with the default parameters of [`Builder`].\n To specify the new thread's stack size or the name, use [`Builder::spawn`].\n\n As you can see in the signature of `spawn` there are two constraints on\n both the closure given to `spawn` and its return value, let's explain them:\n\n - The `'static` constraint means that the closure and its return value\n   must have a lifetime of the whole program execution. The reason for this\n   is that threads can outlive the lifetime they have been created in.\n\n   Indeed if the thread, and by extension its return value, can outlive their\n   caller, we need to make sure that they will be valid afterwards, and since\n   we *can't* know when it will return we need to have them valid as long as\n   possible, that is until the end of the program, hence the `'static`\n   lifetime.\n - The [`Send`] constraint is because the closure will need to be passed\n   *by value* from the thread where it is spawned to the new thread. Its\n   return value will need to be passed from the new thread to the thread\n   where it is `join`ed.\n   As a reminder, the [`Send`] marker trait expresses that it is safe to be\n   passed from thread to thread. [`Sync`] expresses that it is safe to have a\n   reference be passed from thread to thread.\n\n # Panics\n\n Panics if the OS fails to create a thread; use [`Builder::spawn`]\n to recover from such errors.\n\n # Examples\n\n Creating a thread.\n\n ```\n use std::thread;\n\n let handler = thread::spawn(|| {\n     // thread code\n });\n\n handler.join().unwrap();\n ```\n\n As mentioned in the module documentation, threads are usually made to\n communicate using [`channels`], here is how it usually looks.\n\n This example also shows how to use `move`, in order to give ownership\n of values to a thread.\n\n ```\n use std::thread;\n use std::sync::mpsc::channel;\n\n let (tx, rx) = channel();\n\n let sender = thread::spawn(move || {\n     tx.send(\"Hello, thread\".to_owned())\n         .expect(\"Unable to send on channel\");\n });\n\n let receiver = thread::spawn(move || {\n     let value = rx.recv().expect(\"Unable to receive from channel\");\n     println!(\"{value}\");\n });\n\n sender.join().expect(\"The sender thread has panicked\");\n receiver.join().expect(\"The receiver thread has panicked\");\n ```\n\n A thread can also return a value through its [`JoinHandle`], you can use\n this to make asynchronous computations (futures might be more appropriate\n though).\n\n ```\n use std::thread;\n\n let computation = thread::spawn(|| {\n     // Some expensive computation.\n     42\n });\n\n let result = computation.join().unwrap();\n println!(\"{result}\");\n ```\n\n # Notes\n\n This function has the same minimal guarantee regarding \"foreign\" unwinding operations (e.g.\n an exception thrown from C++ code, or a `panic!` in Rust code compiled or linked with a\n different runtime) as [`catch_unwind`]; namely, if the thread created with `thread::spawn`\n unwinds all the way to the root with such an exception, one of two behaviors are possible,\n and it is unspecified which will occur:\n\n * The process aborts.\n * The process does not abort, and [`join`] will return a `Result::Err`\n   containing an opaque type.\n\n [`catch_unwind`]: ../../std/panic/fn.catch_unwind.html\n [`channels`]: crate::sync::mpsc\n [`join`]: JoinHandle::join\n [`Err`]: crate::result::Result::Err\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}