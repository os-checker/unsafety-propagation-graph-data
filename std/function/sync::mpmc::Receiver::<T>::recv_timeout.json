{
  "name": "sync::mpmc::Receiver::<T>::recv_timeout",
  "safe": true,
  "callees": {
    "time::Instant::now": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an instant corresponding to \"now\".\n\n # Examples\n\n ```\n use std::time::Instant;\n\n let now = Instant::now();\n ```\n",
      "adt": {
        "time::Instant": "Constructor"
      }
    },
    "time::Instant::checked_add": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `Some(t)` where `t` is the time `self + duration` if `t` can be represented as\n `Instant` (which means it's inside the bounds of the underlying data structure), `None`\n otherwise.\n",
      "adt": {
        "time::Instant": "Constructor",
        "core::time::Duration": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sync::mpmc::Receiver::<T>::recv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to wait for a value on this receiver, returning an error if the\n corresponding channel has hung up.\n\n This function will always block the current thread if there is no data\n available and it's possible for more data to be sent (at least one sender\n still exists). Once a message is sent to the corresponding [`Sender`],\n this receiver will wake up and return that message.\n\n If the corresponding [`Sender`] has disconnected, or it disconnects while\n this call is blocking, this call will wake up and return [`Err`] to\n indicate that no more messages can ever be received on this channel.\n However, since channels are buffered, messages sent before the disconnect\n will still be properly received.\n\n # Examples\n\n ```\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc;\n use std::thread;\n\n let (send, recv) = mpmc::channel();\n let handle = thread::spawn(move || {\n     send.send(1u8).unwrap();\n });\n\n handle.join().unwrap();\n\n assert_eq!(Ok(1), recv.recv());\n ```\n\n Buffering behavior:\n\n ```\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc;\n use std::thread;\n use std::sync::mpmc::RecvError;\n\n let (send, recv) = mpmc::channel();\n let handle = thread::spawn(move || {\n     send.send(1u8).unwrap();\n     send.send(2).unwrap();\n     send.send(3).unwrap();\n     drop(send);\n });\n\n // wait for the thread to join so we ensure the sender is dropped\n handle.join().unwrap();\n\n assert_eq!(Ok(1), recv.recv());\n assert_eq!(Ok(2), recv.recv());\n assert_eq!(Ok(3), recv.recv());\n assert_eq!(Err(RecvError), recv.recv());\n ```\n",
      "adt": {
        "sync::mpmc::Receiver": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "sync::mpmc::Receiver::<T>::recv_deadline": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to wait for a value on this receiver, returning an error if the\n corresponding channel has hung up, or if `deadline` is reached.\n\n This function will always block the current thread if there is no data\n available and it's possible for more data to be sent. Once a message is\n sent to the corresponding [`Sender`], then this receiver will wake up\n and return that message.\n\n If the corresponding [`Sender`] has disconnected, or it disconnects while\n this call is blocking, this call will wake up and return [`Err`] to\n indicate that no more messages can ever be received on this channel.\n However, since channels are buffered, messages sent before the disconnect\n will still be properly received.\n\n # Examples\n\n Successfully receiving value before reaching deadline:\n\n ```no_run\n #![feature(mpmc_channel)]\n\n use std::thread;\n use std::time::{Duration, Instant};\n use std::sync::mpmc;\n\n let (send, recv) = mpmc::channel();\n\n thread::spawn(move || {\n     send.send('a').unwrap();\n });\n\n assert_eq!(\n     recv.recv_deadline(Instant::now() + Duration::from_millis(400)),\n     Ok('a')\n );\n ```\n\n Receiving an error upon reaching deadline:\n\n ```no_run\n #![feature(mpmc_channel)]\n\n use std::thread;\n use std::time::{Duration, Instant};\n use std::sync::mpmc;\n\n let (send, recv) = mpmc::channel();\n\n thread::spawn(move || {\n     thread::sleep(Duration::from_millis(800));\n     send.send('a').unwrap();\n });\n\n assert_eq!(\n     recv.recv_deadline(Instant::now() + Duration::from_millis(400)),\n     Err(mpmc::RecvTimeoutError::Timeout)\n );\n ```\n",
      "adt": {
        "sync::mpmc::Receiver": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::map_err": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n contained [`Err`] value, leaving an [`Ok`] value untouched.\n\n This function can be used to pass through a successful result while handling\n an error.\n\n\n # Examples\n\n ```\n fn stringify(x: u32) -> String { format!(\"error code: {x}\") }\n\n let x: Result<u32, u32> = Ok(2);\n assert_eq!(x.map_err(stringify), Ok(2));\n\n let x: Result<u32, u32> = Err(13);\n assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n ```\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    }
  },
  "adts": {
    "time::Instant": [
      "Plain",
      "Ref"
    ],
    "core::time::Duration": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 613, kind: RigidTy(Adt(AdtDef(DefId { id: 4610, name: \"time::Instant\" }), GenericArgs([]))) })])"
    ],
    "sync::mpmc::Receiver": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpmc::Receiver::<T>::recv_timeout"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpmc/mod.rs:1049:5: 1055:6",
  "src": "pub fn recv_timeout(&self, timeout: Duration) -> Result<T, RecvTimeoutError> {\n        match Instant::now().checked_add(timeout) {\n            Some(deadline) => self.recv_deadline(deadline),\n            // So far in the future that it's practically the same as waiting indefinitely.\n            None => self.recv().map_err(RecvTimeoutError::from),\n        }\n    }",
  "mir": "fn sync::mpmc::Receiver::<T>::recv_timeout(_1: &sync::mpmc::Receiver<T>, _2: core::time::Duration) -> core::result::Result<T, sync::mpsc::RecvTimeoutError> {\n    let mut _0: core::result::Result<T, sync::mpsc::RecvTimeoutError>;\n    let mut _3: core::option::Option<time::Instant>;\n    let mut _4: &time::Instant;\n    let  _5: time::Instant;\n    let mut _6: isize;\n    let  _7: time::Instant;\n    let mut _8: core::result::Result<T, sync::mpsc::RecvError>;\n    debug self => _1;\n    debug timeout => _2;\n    debug deadline => _7;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = time::Instant::now() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = &_5;\n        _3 = time::Instant::checked_add(move _4, _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _6 = discriminant(_3);\n        switchInt(move _6) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        StorageLive(_8);\n        _8 = sync::mpmc::Receiver::<T>::recv(_1) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _7 = ((_3 as variant#1).0: time::Instant);\n        _0 = sync::mpmc::Receiver::<T>::recv_deadline(_1, _7) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        goto -> bb9;\n    }\n    bb7: {\n        _0 = core::result::Result::<T, sync::mpsc::RecvError>::map_err::<sync::mpsc::RecvTimeoutError, fn(sync::mpsc::RecvError) -> sync::mpsc::RecvTimeoutError {<sync::mpsc::RecvTimeoutError as core::convert::From<sync::mpsc::RecvError>>::from}>(move _8, <sync::mpsc::RecvTimeoutError as core::convert::From<sync::mpsc::RecvError>>::from) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_8);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_5);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Attempts to wait for a value on this receiver, returning an error if the\n corresponding channel has hung up, or if it waits more than `timeout`.\n\n This function will always block the current thread if there is no data\n available and it's possible for more data to be sent (at least one sender\n still exists). Once a message is sent to the corresponding [`Sender`],\n this receiver will wake up and return that message.\n\n If the corresponding [`Sender`] has disconnected, or it disconnects while\n this call is blocking, this call will wake up and return [`Err`] to\n indicate that no more messages can ever be received on this channel.\n However, since channels are buffered, messages sent before the disconnect\n will still be properly received.\n\n # Examples\n\n Successfully receiving value before encountering timeout:\n\n ```no_run\n #![feature(mpmc_channel)]\n\n use std::thread;\n use std::time::Duration;\n use std::sync::mpmc;\n\n let (send, recv) = mpmc::channel();\n\n thread::spawn(move || {\n     send.send('a').unwrap();\n });\n\n assert_eq!(\n     recv.recv_timeout(Duration::from_millis(400)),\n     Ok('a')\n );\n ```\n\n Receiving an error upon reaching timeout:\n\n ```no_run\n #![feature(mpmc_channel)]\n\n use std::thread;\n use std::time::Duration;\n use std::sync::mpmc;\n\n let (send, recv) = mpmc::channel();\n\n thread::spawn(move || {\n     thread::sleep(Duration::from_millis(800));\n     send.send('a').unwrap();\n });\n\n assert_eq!(\n     recv.recv_timeout(Duration::from_millis(400)),\n     Err(mpmc::RecvTimeoutError::Timeout)\n );\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}