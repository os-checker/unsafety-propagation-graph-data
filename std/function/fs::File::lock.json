{
  "name": "fs::File::lock",
  "safe": true,
  "callees": {
    "sys::fs::unix::File::lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::File": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sys::fs::unix::File": [
      "Ref"
    ],
    "fs::File": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1130,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:828:5: 830:6",
  "src": "pub fn lock(&self) -> io::Result<()> {\n        self.inner.lock()\n    }",
  "mir": "fn fs::File::lock(_1: &fs::File) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _2: &sys::fs::unix::File;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = &((*_1).0: sys::fs::unix::File);\n        _0 = sys::fs::unix::File::lock(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Acquire an exclusive lock on the file. Blocks until the lock can be acquired.\n\n This acquires an exclusive lock; no other file handle to this file may acquire another lock.\n\n This lock may be advisory or mandatory. This lock is meant to interact with [`lock`],\n [`try_lock`], [`lock_shared`], [`try_lock_shared`], and [`unlock`]. Its interactions with\n other methods, such as [`read`] and [`write`] are platform specific, and it may or may not\n cause non-lockholders to block.\n\n If this file handle/descriptor, or a clone of it, already holds a lock the exact behavior\n is unspecified and platform dependent, including the possibility that it will deadlock.\n However, if this method returns, then an exclusive lock is held.\n\n If the file is not open for writing, it is unspecified whether this function returns an error.\n\n The lock will be released when this file (along with any other file descriptors/handles\n duplicated or inherited from it) is closed, or if the [`unlock`] method is called.\n\n # Platform-specific behavior\n\n This function currently corresponds to the `flock` function on Unix with the `LOCK_EX` flag,\n and the `LockFileEx` function on Windows with the `LOCKFILE_EXCLUSIVE_LOCK` flag. Note that,\n this [may change in the future][changes].\n\n On Windows, locking a file will fail if the file is opened only for append. To lock a file,\n open it with one of `.read(true)`, `.read(true).append(true)`, or `.write(true)`.\n\n [changes]: io#platform-specific-behavior\n\n [`lock`]: File::lock\n [`lock_shared`]: File::lock_shared\n [`try_lock`]: File::try_lock\n [`try_lock_shared`]: File::try_lock_shared\n [`unlock`]: File::unlock\n [`read`]: Read::read\n [`write`]: Write::write\n\n # Examples\n\n ```no_run\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let f = File::create(\"foo.txt\")?;\n     f.lock()?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}