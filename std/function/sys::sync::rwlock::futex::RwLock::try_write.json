{
  "name": "sys::sync::rwlock::futex::RwLock::try_write",
  "safe": true,
  "callees": {
    "core::sync::atomic::AtomicU32::fetch_update": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Fetches the value, and applies a function to it that returns an optional\n new value. Returns a `Result` of `Ok(previous_value)` if the function returned `Some(_)`, else\n `Err(previous_value)`.\n\n Note: This may call the function multiple times if the value has been changed from other threads in\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n only once to the stored value.\n\n `fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n The first describes the required ordering for when the operation finally succeeds while the second\n describes the required ordering for loads. These correspond to the success and failure orderings of\n respectively.\n\n Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n [`Relaxed`]. The (failed) load ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`].\n\n **Note**: This method is only available on platforms that support atomic operations on\n\n # Considerations\n\n This method is not magic; it is not provided by the hardware, and does not act like a\n critical section or mutex.\n\n It is implemented on top of an atomic [compare-and-swap operation], and thus is subject to\n the usual drawbacks of CAS operations. In particular, be careful of the [ABA problem]\n if this atomic integer is an index or more generally if knowledge of only the *bitwise value*\n of the atomic is not in and of itself sufficient to ensure any required preconditions.\n\n [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n [compare-and-swap operation]: https://en.wikipedia.org/wiki/Compare-and-swap\n\n # Examples\n\n ```rust\n\n assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n assert_eq!(x.load(Ordering::SeqCst), 9);\n ```\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::is_ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Ok`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_ok(), true);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_ok(), false);\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "core::sync::atomic::AtomicU32": [
      "Ref"
    ],
    "sys::sync::rwlock::futex::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain",
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::sync::rwlock::futex::RwLock::try_write"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/rwlock/futex.rs:165:5: 169:6",
  "src": "pub fn try_write(&self) -> bool {\n        self.state\n            .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))\n            .is_ok()\n    }",
  "mir": "fn sys::sync::rwlock::futex::RwLock::try_write(_1: &sys::sync::rwlock::futex::RwLock) -> bool {\n    let mut _0: bool;\n    let mut _2: &core::result::Result<u32, u32>;\n    let  _3: core::result::Result<u32, u32>;\n    let mut _4: &core::sync::atomic::AtomicU32;\n    let mut _5: core::sync::atomic::Ordering;\n    let mut _6: core::sync::atomic::Ordering;\n    debug self => _1;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &((*_1).0: core::sync::atomic::AtomicU32);\n        StorageLive(_5);\n        _5 = core::sync::atomic::Ordering::Acquire;\n        StorageLive(_6);\n        _6 = core::sync::atomic::Ordering::Relaxed;\n        _3 = core::sync::atomic::AtomicU32::fetch_update::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/rwlock/futex.rs:167:45: 167:48}>(move _4, move _5, move _6, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/sync/rwlock/futex.rs:167:45: 167:48}) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = &_3;\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageDead(_4);\n        _0 = core::result::Result::<u32, u32>::is_ok(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}