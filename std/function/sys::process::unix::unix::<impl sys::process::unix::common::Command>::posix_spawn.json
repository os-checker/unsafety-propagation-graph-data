{
  "name": "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn",
  "safe": true,
  "callees": {
    "sys::process::unix::common::Command::get_gid": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::option::Option::<T>::is_some": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the option is a [`Some`] value.\n\n # Examples\n\n ```\n let x: Option<u32> = Some(2);\n assert_eq!(x.is_some(), true);\n\n let x: Option<u32> = None;\n assert_eq!(x.is_some(), false);\n ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_uid": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::common::Command::env_saw_path": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::common::Command::program_is_path": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::common::Command::get_closures": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument"
      }
    },
    "alloc_crate::vec::Vec::<T, A>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the vector contains no elements.\n\n # Examples\n\n ```\n let mut v = Vec::new();\n assert!(v.is_empty());\n\n v.push(1);\n assert!(!v.is_empty());\n ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_groups": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::common::Command::get_chroot": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::common::Command::get_create_pidfd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "core::sync::atomic::AtomicU8::load": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Loads a value from the atomic integer.\n\n `load` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Release`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n assert_eq!(some_var.load(Ordering::Relaxed), 5);\n ```\n",
      "adt": {}
    },
    "process::id": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS-assigned process identifier associated with this process.\n\n # Examples\n\n ```no_run\n use std::process;\n\n println!(\"My pid is {}\", process::id());\n ```\n",
      "adt": {}
    },
    "libc::syscall": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts native return values to Result using the *-1 means error is in `errno`*  convention.\n Non-error values are `Ok`-wrapped.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "io::error::Error::raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS error that this error represents (if any).\n\n If this [`Error`] was constructed via [`last_os_error`] or\n [`from_raw_os_error`], then this function will return [`Some`], otherwise\n it will return [`None`].\n\n [`last_os_error`]: Error::last_os_error\n [`from_raw_os_error`]: Error::from_raw_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_os_error(err: &Error) {\n     if let Some(raw_os_err) = err.raw_os_error() {\n         println!(\"raw OS error: {raw_os_err:?}\");\n     } else {\n         println!(\"Not an OS error\");\n     }\n }\n\n fn main() {\n     // Will print \"raw OS error: ...\".\n     print_os_error(&Error::last_os_error());\n     // Will print \"Not an OS error\".\n     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "core::option::Option": "Constructor",
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "sys::pal::unix::weak::weak_linkage::ExternWeak::<F>::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::pal::unix::weak::weak_linkage::ExternWeak": "ImmutableAsArgument"
      }
    },
    "core::option::Option::<T>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps an `Option<T>` to `Option<U>` by applying a function to a contained value (if `Some`) or returns `None` (if `None`).\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an\n <code>Option<[usize]></code>, consuming the original:\n\n [String]: ../../std/string/struct.String.html \"String\"\n ```\n let maybe_some_string = Some(String::from(\"Hello, World!\"));\n // `Option::map` takes self *by value*, consuming `maybe_some_string`\n let maybe_some_len = maybe_some_string.map(|s| s.len());\n assert_eq!(maybe_some_len, Some(13));\n\n let x: Option<&str> = None;\n assert_eq!(x.map(|s| s.len()), None);\n ```\n",
      "adt": {}
    },
    "libc::close": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::sync::atomic::AtomicU8::store": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Stores a value into the atomic integer.\n\n `store` takes an [`Ordering`] argument which describes the memory ordering of this operation.\n  Possible values are [`SeqCst`], [`Release`] and [`Relaxed`].\n\n # Panics\n\n Panics if `order` is [`Acquire`] or [`AcqRel`].\n\n # Examples\n\n ```\n\n\n some_var.store(10, Ordering::Relaxed);\n assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\n",
      "adt": {}
    },
    "core::panicking::assert_matches_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_match!`\n",
      "adt": {}
    },
    "sys::pal::unix::os::glibc_version": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::cmp::PartialOrd::lt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests less than (for `self` and `other`) and is used by the `<` operator.\n\n # Examples\n\n ```\n assert_eq!(1.0 < 1.0, false);\n assert_eq!(1.0 < 2.0, true);\n assert_eq!(2.0 < 1.0, false);\n ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_cwd": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::get_posix_spawn_addchdir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Get the function pointer for adding a chdir action to a\n `posix_spawn_file_actions_t`, if available, assuming a dynamic libc.\n\n Some platforms can set a new working directory for a spawned process in the\n `posix_spawn` path. This function looks up the function pointer for adding\n such an action to a `posix_spawn_file_actions_t` struct.\n",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::common::Command::get_pgroup": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "core::mem::MaybeUninit::<T>::uninit": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new `MaybeUninit<T>` in an uninitialized state.\n\n Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n It is your responsibility to make sure `T` gets dropped if it got initialized.\n\n See the [type-level documentation][MaybeUninit] for some examples.\n\n # Example\n\n ```\n use std::mem::MaybeUninit;\n\n let v: MaybeUninit<String> = MaybeUninit::uninit();\n ```\n",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<Vec<u32>>`.\n // This is okay because we initialized it.\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n x_vec.push(3);\n assert_eq!(x_vec.len(), 4);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &mut *x.as_mut_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ‚ö†Ô∏è\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {}
    },
    "libc::posix_spawnattr_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::cvt_nz": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": " Zero means `Ok()`, all other values are treated as raw OS errors. Does not look at `errno`.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::error::Error": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "libc::posix_spawn_file_actions_init": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::ChildStdio::fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::process::unix::common::ChildStdio": "MutableAsArgument"
      }
    },
    "libc::posix_spawn_file_actions_adddup2": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ffi::CStr::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the inner pointer to this C string.\n\n The returned pointer will be valid for as long as `self` is, and points\n to a contiguous region of memory terminated with a 0 byte to represent\n the end of the string.\n\n The type of the returned pointer is\n [`*const c_char`][crate::ffi::c_char], and whether it's\n an alias for `*const i8` or `*const u8` is platform-specific.\n\n **WARNING**\n\n The returned pointer is read-only; writing to it (including passing it\n to C code that writes to it) causes undefined behavior.\n\n It is your responsibility to make sure that the underlying memory is not\n freed too early. For example, the following code will cause undefined\n behavior when `ptr` is used inside the `unsafe` block:\n\n ```no_run\n # #![expect(dangling_pointers_from_temporaries)]\n use std::ffi::{CStr, CString};\n\n // üíÄ The meaning of this entire program is undefined,\n // üíÄ and nothing about its behavior is guaranteed,\n // üíÄ not even that its behavior resembles the code as written,\n // üíÄ just because it contains a single instance of undefined behavior!\n\n // üö® creates a dangling pointer to a temporary `CString`\n // üö® that is deallocated at the end of the statement\n let ptr = CString::new(\"Hi!\".to_uppercase()).unwrap().as_ptr();\n\n // without undefined behavior, you would expect that `ptr` equals:\n dbg!(CStr::from_bytes_with_nul(b\"HI!\\0\").unwrap());\n\n // üôè Possibly the program behaved as expected so far,\n // üôè and this just shows `ptr` is now garbage..., but\n // üíÄ this violates `CStr::from_ptr`'s safety contract\n // üíÄ leading to a dereference of a dangling pointer,\n // üíÄ which is immediate undefined behavior.\n // üíÄ *BOOM*, you're dead, your entire program has no meaning.\n dbg!(unsafe { CStr::from_ptr(ptr) });\n ```\n\n This happens because, the pointer returned by `as_ptr` does not carry any\n lifetime information, and the `CString` is deallocated immediately after\n the expression that it is part of has been evaluated.\n To fix the problem, bind the `CString` to a local variable:\n\n ```\n use std::ffi::{CStr, CString};\n\n let c_str = CString::new(\"Hi!\".to_uppercase()).unwrap();\n let ptr = c_str.as_ptr();\n\n assert_eq!(unsafe { CStr::from_ptr(ptr) }, c\"HI!\");\n ```\n",
      "adt": {}
    },
    "libc::posix_spawnattr_setpgroup": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::on_broken_pipe_flag_used": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::sigemptyset": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "libc::sigaddset": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::mem::MaybeUninit::<T>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a pointer to the contained value. Reading from this pointer or turning it\n into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n Writing to memory that this pointer (non-transitively) points to is undefined behavior\n (except inside an `UnsafeCell<T>`).\n\n # Examples\n\n Correct usage of this method:\n\n ```rust\n use std::mem::MaybeUninit;\n\n let mut x = MaybeUninit::<Vec<u32>>::uninit();\n x.write(vec![0, 1, 2]);\n // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n let x_vec = unsafe { &*x.as_ptr() };\n assert_eq!(x_vec.len(), 3);\n # // Prevent leaks for Miri\n # unsafe { MaybeUninit::assume_init_drop(&mut x); }\n ```\n\n *Incorrect* usage of this method:\n\n ```rust,no_run\n use std::mem::MaybeUninit;\n\n let x = MaybeUninit::<Vec<u32>>::uninit();\n let x_vec = unsafe { &*x.as_ptr() };\n // We have created a reference to an uninitialized vector! This is undefined behavior. ‚ö†Ô∏è\n ```\n\n (Notice that the rules around references to uninitialized data are not finalized yet, but\n until they are, it is advisable to avoid them.)\n",
      "adt": {}
    },
    "libc::posix_spawnattr_setsigdefault": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_setsid": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "dead_code"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* dead_code\n"
        ]
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "libc::posix_spawnattr_setflags": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::env::unix::env_read_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "core::option::Option::<T>::unwrap_or_else": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or computes it from a closure.\n\n # Examples\n\n ```\n let k = 10;\n assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);\n assert_eq!(None.unwrap_or_else(|| 2 * k), 20);\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use pattern matching and handle the [`None`]\n case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n [`unwrap_or_default`]. In functions returning `Option`, you can use\n [the `?` (try) operator][try-option].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-option]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#where-the--operator-can-be-used\n [`unwrap_or`]: Option::unwrap_or\n [`unwrap_or_else`]: Option::unwrap_or_else\n [`unwrap_or_default`]: Option::unwrap_or_default\n\n # Panics\n\n Panics if the self value equals [`None`].\n\n # Examples\n\n ```\n let x = Some(\"air\");\n assert_eq!(x.unwrap(), \"air\");\n ```\n\n ```should_panic\n let x: Option<&str> = None;\n assert_eq!(x.unwrap(), \"air\"); // fails\n ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_program_cstr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::common::Command::get_argv": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::common::cstring_array::CStringArray::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a pointer to the C-string array managed by this type.\n",
      "adt": {
        "sys::process::unix::common::cstring_array::CStringArray": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::unix::Process::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n `pidfd` must either be -1 (representing no file descriptor) or a valid, exclusively owned file\n descriptor (See [I/O Safety]).\n\n [I/O Safety]: crate::io#io-safety\n",
      "adt": {
        "sys::process::unix::unix::Process": "Constructor"
      }
    },
    "io::error::Error::kind": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the corresponding [`ErrorKind`] for this error.\n\n This may be a value set by Rust code constructing custom `io::Error`s,\n or if this `io::Error` was sourced from the operating system,\n it will be a value inferred from the system's error encoding.\n See [`last_os_error`] for more details.\n\n [`last_os_error`]: Error::last_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_error(err: Error) {\n     println!(\"{:?}\", err.kind());\n }\n\n fn main() {\n     // As no error has (visibly) occurred, this may print anything!\n     // It likely prints a placeholder for unidentified (non-)errors.\n     print_error(Error::last_os_error());\n     // Will print \"AddrInUse\".\n     print_error(Error::new(ErrorKind::AddrInUse, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "io::error::Error": "ImmutableAsArgument",
        "io::error::ErrorKind": "Constructor"
      }
    },
    "io::error::Error::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new I/O error from a known kind of error as well as an\n arbitrary error payload.\n\n This function is used to generically create I/O errors which do not\n originate from the OS itself. The `error` argument is an arbitrary\n payload which will be contained in this [`Error`].\n\n Note that this function allocates memory on the heap.\n If no extra payload is required, use the `From` conversion from\n `ErrorKind`.\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n // errors can be created from strings\n let custom_error = Error::new(ErrorKind::Other, \"oh no!\");\n\n // errors can also be created from other errors\n let custom_error2 = Error::new(ErrorKind::Interrupted, custom_error);\n\n // creating an error without payload (and without memory allocation)\n let eof_error = Error::from(ErrorKind::UnexpectedEof);\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "libc::posix_spawnp": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::pal::unix::weak::weak_linkage::ExternWeak::<F>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::pal::unix::weak::weak_linkage::ExternWeak": "Constructor"
      }
    }
  },
  "adts": {
    "sys::process::unix::common::Command": [
      "Ref",
      "Deref",
      "MutRef"
    ],
    "core::option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8135, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 44, kind: RigidTy(Int(I32)) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8135, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 44, kind: RigidTy(Int(I32)) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 14976, kind: RigidTy(Tuple([Ty { id: 393, kind: RigidTy(Uint(Usize)) }, Ty { id: 393, kind: RigidTy(Uint(Usize)) }])) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 774, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 779, kind: RigidTy(Adt(AdtDef(DefId { id: 4692, name: \"core::ffi::CStr\" }), GenericArgs([]))) }, Not)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17003, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 17049, kind: RigidTy(RawPtr(Ty { id: 17064, kind: RigidTy(Adt(AdtDef(DefId { id: 12285, name: \"libc::posix_spawn_file_actions_t\" }), GenericArgs([]))) }, Mut)) }, Ty { id: 37, kind: RigidTy(RawPtr(Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 44, kind: RigidTy(Int(I32)) }], c_variadic: false, safety: Unsafe, abi: C { unwind: false } }, bound_vars: [] })) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17001, kind: RigidTy(Tuple([Ty { id: 17003, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 17049, kind: RigidTy(RawPtr(Ty { id: 17064, kind: RigidTy(Adt(AdtDef(DefId { id: 12285, name: \"libc::posix_spawn_file_actions_t\" }), GenericArgs([]))) }, Mut)) }, Ty { id: 37, kind: RigidTy(RawPtr(Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 44, kind: RigidTy(Int(I32)) }], c_variadic: false, safety: Unsafe, abi: C { unwind: false } }, bound_vars: [] })) }, Ty { id: 774, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 779, kind: RigidTy(Adt(AdtDef(DefId { id: 4692, name: \"core::ffi::CStr\" }), GenericArgs([]))) }, Not)) }])) }), Field(0, Ty { id: 17003, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 17049, kind: RigidTy(RawPtr(Ty { id: 17064, kind: RigidTy(Adt(AdtDef(DefId { id: 12285, name: \"libc::posix_spawn_file_actions_t\" }), GenericArgs([]))) }, Mut)) }, Ty { id: 37, kind: RigidTy(RawPtr(Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 44, kind: RigidTy(Int(I32)) }], c_variadic: false, safety: Unsafe, abi: C { unwind: false } }, bound_vars: [] })) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 17001, kind: RigidTy(Tuple([Ty { id: 17003, kind: RigidTy(FnPtr(Binder { value: FnSig { inputs_and_output: [Ty { id: 17049, kind: RigidTy(RawPtr(Ty { id: 17064, kind: RigidTy(Adt(AdtDef(DefId { id: 12285, name: \"libc::posix_spawn_file_actions_t\" }), GenericArgs([]))) }, Mut)) }, Ty { id: 37, kind: RigidTy(RawPtr(Ty { id: 35, kind: RigidTy(Uint(U8)) }, Not)) }, Ty { id: 44, kind: RigidTy(Int(I32)) }], c_variadic: false, safety: Unsafe, abi: C { unwind: false } }, bound_vars: [] })) }, Ty { id: 774, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 779, kind: RigidTy(Adt(AdtDef(DefId { id: 4692, name: \"core::ffi::CStr\" }), GenericArgs([]))) }, Not)) }])) }), Field(1, Ty { id: 774, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 779, kind: RigidTy(Adt(AdtDef(DefId { id: 4692, name: \"core::ffi::CStr\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "sys::pal::unix::weak::weak_linkage::ExternWeak": [
      "Ref",
      "Plain"
    ],
    "core::sync::atomic::AtomicU8": [
      "Ref"
    ],
    "core::sync::atomic::Ordering": [
      "Plain"
    ],
    "io::error::Error": [
      "Ref",
      "Plain"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::mem::MaybeUninit": [
      "Plain",
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::PosixSpawnattr": [
      "Plain",
      "Unknown([Field(0, Ty { id: 17013, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17045, kind: RigidTy(Adt(AdtDef(DefId { id: 4679, name: \"core::mem::MaybeUninit\" }), GenericArgs([Type(Ty { id: 17063, kind: RigidTy(Adt(AdtDef(DefId { id: 12286, name: \"libc::posix_spawnattr_t\" }), GenericArgs([]))) })]))) }, Mut)) })])"
    ],
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::PosixSpawnFileActions": [
      "Plain",
      "Unknown([Field(0, Ty { id: 17011, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17048, kind: RigidTy(Adt(AdtDef(DefId { id: 4679, name: \"core::mem::MaybeUninit\" }), GenericArgs([Type(Ty { id: 17064, kind: RigidTy(Adt(AdtDef(DefId { id: 12285, name: \"libc::posix_spawn_file_actions_t\" }), GenericArgs([]))) })]))) }, Mut)) })])"
    ],
    "sys::process::unix::common::ChildStdio": [
      "Ref"
    ],
    "sys::process::unix::common::ChildPipes": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Ref"
    ],
    "sync::poison::rwlock::RwLockReadGuard": [
      "Plain"
    ],
    "sys::process::unix::common::cstring_array::CStringArray": [
      "Ref"
    ],
    "sys::process::unix::unix::Process": [
      "Plain",
      "Unknown([Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "io::error::ErrorKind": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:449:5: 829:6",
  "src": "fn posix_spawn(\n        &mut self,\n        stdio: &ChildPipes,\n        envp: Option<&CStringArray>,\n    ) -> io::Result<Option<Process>> {\n        #[cfg(target_os = \"linux\")]\n        use core::sync::atomic::{Atomic, AtomicU8, Ordering};\n\n        use crate::mem::MaybeUninit;\n        use crate::sys::{self, cvt_nz, on_broken_pipe_flag_used};\n\n        if self.get_gid().is_some()\n            || self.get_uid().is_some()\n            || (self.env_saw_path() && !self.program_is_path())\n            || !self.get_closures().is_empty()\n            || self.get_groups().is_some()\n            || self.get_chroot().is_some()\n        {\n            return Ok(None);\n        }\n\n        cfg_select! {\n            target_os = \"linux\" => {\n                use crate::sys::weak::weak;\n\n                weak!(\n                    fn pidfd_spawnp(\n                        pidfd: *mut libc::c_int,\n                        path: *const libc::c_char,\n                        file_actions: *const libc::posix_spawn_file_actions_t,\n                        attrp: *const libc::posix_spawnattr_t,\n                        argv: *const *mut libc::c_char,\n                        envp: *const *mut libc::c_char,\n                    ) -> libc::c_int;\n                );\n\n                weak!(\n                    fn pidfd_getpid(pidfd: libc::c_int) -> libc::c_int;\n                );\n\n                static PIDFD_SUPPORTED: Atomic<u8> = AtomicU8::new(0);\n                const UNKNOWN: u8 = 0;\n                const SPAWN: u8 = 1;\n                // Obtaining a pidfd via the fork+exec path might work\n                const FORK_EXEC: u8 = 2;\n                // Neither pidfd_spawn nor fork/exec will get us a pidfd.\n                // Instead we'll just posix_spawn if the other preconditions are met.\n                const NO: u8 = 3;\n\n                if self.get_create_pidfd() {\n                    let mut support = PIDFD_SUPPORTED.load(Ordering::Relaxed);\n                    if support == FORK_EXEC {\n                        return Ok(None);\n                    }\n                    if support == UNKNOWN {\n                        support = NO;\n                        let our_pid = crate::process::id();\n                        let pidfd = cvt(unsafe { libc::syscall(libc::SYS_pidfd_open, our_pid, 0) } as c_int);\n                        match pidfd {\n                            Ok(pidfd) => {\n                                support = FORK_EXEC;\n                                if let Some(Ok(pid)) = pidfd_getpid.get().map(|f| cvt(unsafe { f(pidfd) } as i32)) {\n                                    if pidfd_spawnp.get().is_some() && pid as u32 == our_pid {\n                                        support = SPAWN\n                                    }\n                                }\n                                unsafe { libc::close(pidfd) };\n                            }\n                            Err(e) if e.raw_os_error() == Some(libc::EMFILE) => {\n                                // We're temporarily(?) out of file descriptors.  In this case obtaining a pidfd would also fail\n                                // Don't update the support flag so we can probe again later.\n                                return Err(e)\n                            }\n                            _ => {}\n                        }\n                        PIDFD_SUPPORTED.store(support, Ordering::Relaxed);\n                        if support == FORK_EXEC {\n                            return Ok(None);\n                        }\n                    }\n                    core::assert_matches::debug_assert_matches!(support, SPAWN | NO);\n                }\n            }\n            _ => {\n                if self.get_create_pidfd() {\n                    unreachable!(\"only implemented on linux\")\n                }\n            }\n        }\n\n        // Only glibc 2.24+ posix_spawn() supports returning ENOENT directly.\n        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n        {\n            if let Some(version) = sys::os::glibc_version() {\n                if version < (2, 24) {\n                    return Ok(None);\n                }\n            } else {\n                return Ok(None);\n            }\n        }\n\n        // On QNX Neutrino, posix_spawnp can fail with EBADF in case \"another thread might have opened\n        // or closed a file descriptor while the posix_spawn() was occurring\".\n        // Documentation says \"... or try calling posix_spawn() again\". This is what we do here.\n        // See also http://www.qnx.com/developers/docs/7.1/#com.qnx.doc.neutrino.lib_ref/topic/p/posix_spawn.html\n        #[cfg(target_os = \"nto\")]\n        unsafe fn retrying_libc_posix_spawnp(\n            pid: *mut pid_t,\n            file: *const c_char,\n            file_actions: *const posix_spawn_file_actions_t,\n            attrp: *const posix_spawnattr_t,\n            argv: *const *mut c_char,\n            envp: *const *mut c_char,\n        ) -> io::Result<i32> {\n            let mut delay = MIN_FORKSPAWN_SLEEP;\n            loop {\n                match libc::posix_spawnp(pid, file, file_actions, attrp, argv, envp) {\n                    libc::EBADF => {\n                        if delay < get_clock_resolution() {\n                            // We cannot sleep this short (it would be longer).\n                            // Yield instead.\n                            thread::yield_now();\n                        } else if delay < MAX_FORKSPAWN_SLEEP {\n                            thread::sleep(delay);\n                        } else {\n                            return Err(io::const_error!(\n                                ErrorKind::WouldBlock,\n                                \"posix_spawnp returned EBADF too often\",\n                            ));\n                        }\n                        delay *= 2;\n                        continue;\n                    }\n                    r => {\n                        return Ok(r);\n                    }\n                }\n            }\n        }\n\n        type PosixSpawnAddChdirFn = unsafe extern \"C\" fn(\n            *mut libc::posix_spawn_file_actions_t,\n            *const libc::c_char,\n        ) -> libc::c_int;\n\n        /// Get the function pointer for adding a chdir action to a\n        /// `posix_spawn_file_actions_t`, if available, assuming a dynamic libc.\n        ///\n        /// Some platforms can set a new working directory for a spawned process in the\n        /// `posix_spawn` path. This function looks up the function pointer for adding\n        /// such an action to a `posix_spawn_file_actions_t` struct.\n        #[cfg(not(any(all(target_os = \"linux\", target_env = \"musl\"), target_os = \"cygwin\")))]\n        fn get_posix_spawn_addchdir() -> Option<PosixSpawnAddChdirFn> {\n            use crate::sys::weak::weak;\n\n            // POSIX.1-2024 standardizes this function:\n            // https://pubs.opengroup.org/onlinepubs/9799919799/functions/posix_spawn_file_actions_addchdir.html.\n            // The _np version is more widely available, though, so try that first.\n\n            weak!(\n                fn posix_spawn_file_actions_addchdir_np(\n                    file_actions: *mut libc::posix_spawn_file_actions_t,\n                    path: *const libc::c_char,\n                ) -> libc::c_int;\n            );\n\n            weak!(\n                fn posix_spawn_file_actions_addchdir(\n                    file_actions: *mut libc::posix_spawn_file_actions_t,\n                    path: *const libc::c_char,\n                ) -> libc::c_int;\n            );\n\n            posix_spawn_file_actions_addchdir_np\n                .get()\n                .or_else(|| posix_spawn_file_actions_addchdir.get())\n        }\n\n        /// Get the function pointer for adding a chdir action to a\n        /// `posix_spawn_file_actions_t`, if available, on platforms where the function\n        /// is known to exist.\n        ///\n        /// Weak symbol lookup doesn't work with statically linked libcs, so in cases\n        /// where static linking is possible we need to either check for the presence\n        /// of the symbol at compile time or know about it upfront.\n        ///\n        /// Cygwin doesn't support weak symbol, so just link it.\n        #[cfg(any(all(target_os = \"linux\", target_env = \"musl\"), target_os = \"cygwin\"))]\n        fn get_posix_spawn_addchdir() -> Option<PosixSpawnAddChdirFn> {\n            // Our minimum required musl supports this function, so we can just use it.\n            Some(libc::posix_spawn_file_actions_addchdir_np)\n        }\n\n        let addchdir = match self.get_cwd() {\n            Some(cwd) => {\n                if cfg!(target_vendor = \"apple\") {\n                    // There is a bug in macOS where a relative executable\n                    // path like \"../myprogram\" will cause `posix_spawn` to\n                    // successfully launch the program, but erroneously return\n                    // ENOENT when used with posix_spawn_file_actions_addchdir_np\n                    // which was introduced in macOS 10.15.\n                    if self.get_program_kind() == ProgramKind::Relative {\n                        return Ok(None);\n                    }\n                }\n                // Check for the availability of the posix_spawn addchdir\n                // function now. If it isn't available, bail and use the\n                // fork/exec path.\n                match get_posix_spawn_addchdir() {\n                    Some(f) => Some((f, cwd)),\n                    None => return Ok(None),\n                }\n            }\n            None => None,\n        };\n\n        let pgroup = self.get_pgroup();\n\n        struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n\n        impl Drop for PosixSpawnFileActions<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawn_file_actions_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        struct PosixSpawnattr<'a>(&'a mut MaybeUninit<libc::posix_spawnattr_t>);\n\n        impl Drop for PosixSpawnattr<'_> {\n            fn drop(&mut self) {\n                unsafe {\n                    libc::posix_spawnattr_destroy(self.0.as_mut_ptr());\n                }\n            }\n        }\n\n        unsafe {\n            let mut attrs = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawnattr_init(attrs.as_mut_ptr()))?;\n            let attrs = PosixSpawnattr(&mut attrs);\n\n            let mut flags = 0;\n\n            let mut file_actions = MaybeUninit::uninit();\n            cvt_nz(libc::posix_spawn_file_actions_init(file_actions.as_mut_ptr()))?;\n            let file_actions = PosixSpawnFileActions(&mut file_actions);\n\n            if let Some(fd) = stdio.stdin.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDIN_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stdout.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDOUT_FILENO,\n                ))?;\n            }\n            if let Some(fd) = stdio.stderr.fd() {\n                cvt_nz(libc::posix_spawn_file_actions_adddup2(\n                    file_actions.0.as_mut_ptr(),\n                    fd,\n                    libc::STDERR_FILENO,\n                ))?;\n            }\n            if let Some((f, cwd)) = addchdir {\n                cvt_nz(f(file_actions.0.as_mut_ptr(), cwd.as_ptr()))?;\n            }\n\n            if let Some(pgroup) = pgroup {\n                flags |= libc::POSIX_SPAWN_SETPGROUP;\n                cvt_nz(libc::posix_spawnattr_setpgroup(attrs.0.as_mut_ptr(), pgroup))?;\n            }\n\n            // Inherit the signal mask from this process rather than resetting it (i.e. do not call\n            // posix_spawnattr_setsigmask).\n\n            // If -Zon-broken-pipe is used, don't reset SIGPIPE to SIG_DFL.\n            // If -Zon-broken-pipe is not used, reset SIGPIPE to SIG_DFL for backward compatibility.\n            //\n            // -Zon-broken-pipe is an opportunity to change the default here.\n            if !on_broken_pipe_flag_used() {\n                let mut default_set = MaybeUninit::<libc::sigset_t>::uninit();\n                cvt(sigemptyset(default_set.as_mut_ptr()))?;\n                cvt(sigaddset(default_set.as_mut_ptr(), libc::SIGPIPE))?;\n                #[cfg(target_os = \"hurd\")]\n                {\n                    cvt(sigaddset(default_set.as_mut_ptr(), libc::SIGLOST))?;\n                }\n                cvt_nz(libc::posix_spawnattr_setsigdefault(\n                    attrs.0.as_mut_ptr(),\n                    default_set.as_ptr(),\n                ))?;\n                flags |= libc::POSIX_SPAWN_SETSIGDEF;\n            }\n\n            if self.get_setsid() {\n                cfg_select! {\n                    all(target_os = \"linux\", target_env = \"gnu\") => {\n                        flags |= libc::POSIX_SPAWN_SETSID;\n                    }\n                    _ => {\n                        return Ok(None);\n                    }\n                }\n            }\n\n            cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n\n            // Make sure we synchronize access to the global `environ` resource\n            let _env_lock = sys::env::env_read_lock();\n            let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::env::environ() as *const _);\n\n            #[cfg(not(target_os = \"nto\"))]\n            let spawn_fn = libc::posix_spawnp;\n            #[cfg(target_os = \"nto\")]\n            let spawn_fn = retrying_libc_posix_spawnp;\n\n            #[cfg(target_os = \"linux\")]\n            if self.get_create_pidfd() && PIDFD_SUPPORTED.load(Ordering::Relaxed) == SPAWN {\n                let mut pidfd: libc::c_int = -1;\n                let spawn_res = pidfd_spawnp.get().unwrap()(\n                    &mut pidfd,\n                    self.get_program_cstr().as_ptr(),\n                    file_actions.0.as_ptr(),\n                    attrs.0.as_ptr(),\n                    self.get_argv().as_ptr() as *const _,\n                    envp as *const _,\n                );\n\n                let spawn_res = cvt_nz(spawn_res);\n                if let Err(ref e) = spawn_res\n                    && e.raw_os_error() == Some(libc::ENOSYS)\n                {\n                    PIDFD_SUPPORTED.store(FORK_EXEC, Ordering::Relaxed);\n                    return Ok(None);\n                }\n                spawn_res?;\n\n                let pid = match cvt(pidfd_getpid.get().unwrap()(pidfd)) {\n                    Ok(pid) => pid,\n                    Err(e) => {\n                        // The child has been spawned and we are holding its pidfd.\n                        // But we cannot obtain its pid even though pidfd_getpid support was verified earlier.\n                        // This might happen if libc can't open procfs because the file descriptor limit has been reached.\n                        libc::close(pidfd);\n                        return Err(Error::new(\n                            e.kind(),\n                            \"pidfd_spawnp succeeded but the child's PID could not be obtained\",\n                        ));\n                    }\n                };\n\n                return Ok(Some(Process::new(pid, pidfd)));\n            }\n\n            // Safety: -1 indicates we don't have a pidfd.\n            let mut p = Process::new(0, -1);\n\n            let spawn_res = spawn_fn(\n                &mut p.pid,\n                self.get_program_cstr().as_ptr(),\n                file_actions.0.as_ptr(),\n                attrs.0.as_ptr(),\n                self.get_argv().as_ptr() as *const _,\n                envp as *const _,\n            );\n\n            #[cfg(target_os = \"nto\")]\n            let spawn_res = spawn_res?;\n\n            cvt_nz(spawn_res)?;\n            Ok(Some(p))\n        }\n    }",
  "mir": "fn sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn(_1: &mut sys::process::unix::common::Command, _2: &sys::process::unix::common::ChildPipes, _3: core::option::Option<&sys::process::unix::common::cstring_array::CStringArray>) -> core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> {\n    let mut _0: core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error>;\n    let mut _4: bool;\n    let mut _5: &core::option::Option<u32>;\n    let  _6: core::option::Option<u32>;\n    let mut _7: &sys::process::unix::common::Command;\n    let mut _8: bool;\n    let mut _9: &core::option::Option<u32>;\n    let  _10: core::option::Option<u32>;\n    let mut _11: &sys::process::unix::common::Command;\n    let mut _12: bool;\n    let mut _13: &sys::process::unix::common::Command;\n    let mut _14: bool;\n    let mut _15: &sys::process::unix::common::Command;\n    let mut _16: bool;\n    let mut _17: &alloc_crate::vec::Vec<alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let  _18: &mut alloc_crate::vec::Vec<alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>;\n    let mut _19: bool;\n    let mut _20: &core::option::Option<&[u32]>;\n    let  _21: core::option::Option<&[u32]>;\n    let mut _22: &sys::process::unix::common::Command;\n    let mut _23: bool;\n    let mut _24: &core::option::Option<&core::ffi::CStr>;\n    let  _25: core::option::Option<&core::ffi::CStr>;\n    let mut _26: &sys::process::unix::common::Command;\n    let mut _27: core::option::Option<sys::process::unix::unix::Process>;\n    let  _28: &sys::pal::unix::weak::weak_linkage::ExternWeak<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let mut _29: sys::pal::unix::weak::weak_linkage::ExternWeak<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let mut _30: core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let mut _31: *const core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let  _32: &sys::pal::unix::weak::weak_linkage::ExternWeak<unsafe extern \"C\" fn(i32) -> i32>;\n    let mut _33: sys::pal::unix::weak::weak_linkage::ExternWeak<unsafe extern \"C\" fn(i32) -> i32>;\n    let mut _34: core::option::Option<unsafe extern \"C\" fn(i32) -> i32>;\n    let mut _35: *const core::option::Option<unsafe extern \"C\" fn(i32) -> i32>;\n    let mut _36: bool;\n    let mut _37: &sys::process::unix::common::Command;\n    let mut _38: u8;\n    let mut _39: &core::sync::atomic::AtomicU8;\n    let mut _40: core::sync::atomic::Ordering;\n    let mut _41: bool;\n    let mut _42: u8;\n    let mut _43: core::option::Option<sys::process::unix::unix::Process>;\n    let mut _44: bool;\n    let mut _45: u8;\n    let  _46: u32;\n    let  _47: core::result::Result<i32, io::error::Error>;\n    let mut _48: i32;\n    let mut _49: i64;\n    let mut _50: isize;\n    let  _51: i32;\n    let mut _52: core::option::Option<core::result::Result<i32, io::error::Error>>;\n    let mut _53: core::option::Option<unsafe extern \"C\" fn(i32) -> i32>;\n    let mut _54: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:510:79: 510:82};\n    let mut _55: &i32;\n    let mut _56: isize;\n    let mut _57: isize;\n    let  _58: i32;\n    let mut _59: bool;\n    let mut _60: &core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let  _61: core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let mut _62: bool;\n    let mut _63: u32;\n    let  _64: i32;\n    let  _65: io::error::Error;\n    let  _66: &io::error::Error;\n    let mut _67: bool;\n    let mut _68: &core::option::Option<i32>;\n    let  _69: core::option::Option<i32>;\n    let mut _70: &core::option::Option<i32>;\n    let  _71: ();\n    let mut _72: &core::sync::atomic::AtomicU8;\n    let mut _73: u8;\n    let mut _74: core::sync::atomic::Ordering;\n    let mut _75: bool;\n    let mut _76: u8;\n    let mut _77: core::option::Option<sys::process::unix::unix::Process>;\n    let  _78: &u8;\n    let  _79: !;\n    let mut _80: &str;\n    let mut _81: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _82: core::option::Option<(usize, usize)>;\n    let mut _83: isize;\n    let  _84: (usize, usize);\n    let mut _85: bool;\n    let mut _86: &(usize, usize);\n    let mut _87: &(usize, usize);\n    let mut _88: core::option::Option<sys::process::unix::unix::Process>;\n    let mut _89: core::option::Option<sys::process::unix::unix::Process>;\n    let  _90: core::option::Option<(unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32, &core::ffi::CStr)>;\n    let mut _91: core::option::Option<&core::ffi::CStr>;\n    let mut _92: &sys::process::unix::common::Command;\n    let mut _93: isize;\n    let  _94: &core::ffi::CStr;\n    let mut _95: core::option::Option<unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32>;\n    let mut _96: isize;\n    let  _97: unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32;\n    let mut _98: (unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32, &core::ffi::CStr);\n    let mut _99: core::option::Option<sys::process::unix::unix::Process>;\n    let  _100: core::option::Option<i32>;\n    let mut _101: &sys::process::unix::common::Command;\n    let mut _102: core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _103: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _104: core::result::Result<(), io::error::Error>;\n    let mut _105: i32;\n    let mut _106: *mut libc::posix_spawnattr_t;\n    let mut _107: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _108: isize;\n    let  _109: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _110: sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::PosixSpawnattr<'_>;\n    let mut _111: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _112: i32;\n    let mut _113: core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _114: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _115: core::result::Result<(), io::error::Error>;\n    let mut _116: i32;\n    let mut _117: *mut libc::posix_spawn_file_actions_t;\n    let mut _118: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _119: isize;\n    let  _120: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _121: sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::PosixSpawnFileActions<'_>;\n    let mut _122: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _123: core::option::Option<i32>;\n    let mut _124: &sys::process::unix::common::ChildStdio;\n    let mut _125: isize;\n    let  _126: i32;\n    let mut _127: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _128: core::result::Result<(), io::error::Error>;\n    let mut _129: i32;\n    let mut _130: *mut libc::posix_spawn_file_actions_t;\n    let mut _131: isize;\n    let  _132: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _133: core::option::Option<i32>;\n    let mut _134: &sys::process::unix::common::ChildStdio;\n    let mut _135: isize;\n    let  _136: i32;\n    let mut _137: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _138: core::result::Result<(), io::error::Error>;\n    let mut _139: i32;\n    let mut _140: *mut libc::posix_spawn_file_actions_t;\n    let mut _141: isize;\n    let  _142: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _143: core::option::Option<i32>;\n    let mut _144: &sys::process::unix::common::ChildStdio;\n    let mut _145: isize;\n    let  _146: i32;\n    let mut _147: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _148: core::result::Result<(), io::error::Error>;\n    let mut _149: i32;\n    let mut _150: *mut libc::posix_spawn_file_actions_t;\n    let mut _151: isize;\n    let  _152: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _153: isize;\n    let  _154: unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32;\n    let  _155: &core::ffi::CStr;\n    let mut _156: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _157: core::result::Result<(), io::error::Error>;\n    let mut _158: i32;\n    let mut _159: *mut libc::posix_spawn_file_actions_t;\n    let mut _160: *const u8;\n    let mut _161: isize;\n    let  _162: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _163: isize;\n    let  _164: i32;\n    let mut _165: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _166: core::result::Result<(), io::error::Error>;\n    let mut _167: i32;\n    let mut _168: *mut libc::posix_spawnattr_t;\n    let mut _169: isize;\n    let  _170: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _171: bool;\n    let mut _172: core::mem::MaybeUninit<libc::sigset_t>;\n    let mut _173: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _174: core::result::Result<i32, io::error::Error>;\n    let mut _175: i32;\n    let mut _176: *mut libc::sigset_t;\n    let mut _177: &mut core::mem::MaybeUninit<libc::sigset_t>;\n    let mut _178: isize;\n    let  _179: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _180: i32;\n    let mut _181: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _182: core::result::Result<i32, io::error::Error>;\n    let mut _183: i32;\n    let mut _184: *mut libc::sigset_t;\n    let mut _185: &mut core::mem::MaybeUninit<libc::sigset_t>;\n    let mut _186: isize;\n    let  _187: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _188: i32;\n    let mut _189: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _190: core::result::Result<(), io::error::Error>;\n    let mut _191: i32;\n    let mut _192: *mut libc::posix_spawnattr_t;\n    let mut _193: *const libc::sigset_t;\n    let mut _194: &core::mem::MaybeUninit<libc::sigset_t>;\n    let mut _195: isize;\n    let  _196: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _197: bool;\n    let mut _198: &sys::process::unix::common::Command;\n    let mut _199: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _200: core::result::Result<(), io::error::Error>;\n    let mut _201: i32;\n    let mut _202: *mut libc::posix_spawnattr_t;\n    let mut _203: i16;\n    let mut _204: i32;\n    let mut _205: isize;\n    let  _206: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _207: sync::poison::rwlock::RwLockReadGuard<'_, ()>;\n    let  _208: *const *const u8;\n    let mut _209: core::option::Option<*const *const u8>;\n    let mut _210: bool;\n    let mut _211: &sys::process::unix::common::Command;\n    let mut _212: bool;\n    let mut _213: u8;\n    let mut _214: &core::sync::atomic::AtomicU8;\n    let mut _215: core::sync::atomic::Ordering;\n    let mut _216: i32;\n    let  _217: i32;\n    let mut _218: unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32;\n    let mut _219: core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>;\n    let mut _220: *mut i32;\n    let mut _221: &mut i32;\n    let mut _222: *const u8;\n    let  _223: &core::ffi::CStr;\n    let mut _224: &sys::process::unix::common::Command;\n    let mut _225: *const libc::posix_spawn_file_actions_t;\n    let mut _226: &core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _227: *const libc::posix_spawnattr_t;\n    let mut _228: &core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _229: *const *mut u8;\n    let mut _230: *const *const u8;\n    let  _231: &sys::process::unix::common::cstring_array::CStringArray;\n    let mut _232: &sys::process::unix::common::Command;\n    let mut _233: *const *mut u8;\n    let  _234: core::result::Result<(), io::error::Error>;\n    let mut _235: isize;\n    let  _236: &io::error::Error;\n    let mut _237: bool;\n    let mut _238: &core::option::Option<i32>;\n    let  _239: core::option::Option<i32>;\n    let mut _240: &core::option::Option<i32>;\n    let  _241: ();\n    let mut _242: &core::sync::atomic::AtomicU8;\n    let mut _243: core::sync::atomic::Ordering;\n    let mut _244: core::option::Option<sys::process::unix::unix::Process>;\n    let mut _245: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _246: core::result::Result<(), io::error::Error>;\n    let mut _247: isize;\n    let  _248: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _249: core::result::Result<i32, io::error::Error>;\n    let mut _250: i32;\n    let mut _251: unsafe extern \"C\" fn(i32) -> i32;\n    let mut _252: core::option::Option<unsafe extern \"C\" fn(i32) -> i32>;\n    let mut _253: i32;\n    let mut _254: isize;\n    let  _255: i32;\n    let  _256: io::error::Error;\n    let  _257: i32;\n    let mut _258: i32;\n    let mut _259: io::error::Error;\n    let mut _260: io::error::ErrorKind;\n    let mut _261: &io::error::Error;\n    let mut _262: core::option::Option<sys::process::unix::unix::Process>;\n    let mut _263: sys::process::unix::unix::Process;\n    let mut _264: i32;\n    let mut _265: sys::process::unix::unix::Process;\n    let  _266: i32;\n    let mut _267: *mut i32;\n    let mut _268: &mut i32;\n    let mut _269: *const u8;\n    let  _270: &core::ffi::CStr;\n    let mut _271: &sys::process::unix::common::Command;\n    let mut _272: *const libc::posix_spawn_file_actions_t;\n    let mut _273: &core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _274: *const libc::posix_spawnattr_t;\n    let mut _275: &core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _276: *const *mut u8;\n    let mut _277: *const *const u8;\n    let  _278: &sys::process::unix::common::cstring_array::CStringArray;\n    let mut _279: &sys::process::unix::common::Command;\n    let mut _280: *const *mut u8;\n    let mut _281: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _282: core::result::Result<(), io::error::Error>;\n    let mut _283: isize;\n    let  _284: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _285: core::option::Option<sys::process::unix::unix::Process>;\n    let mut _286: sys::process::unix::unix::Process;\n    let mut _287: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _288: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _289: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _290: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _291: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _292: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _293: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _294: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _295: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _296: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>;\n    let mut _297: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>;\n    let mut _298: bool;\n    let mut _299: bool;\n    let mut _300: isize;\n    let mut _301: isize;\n    let mut _302: *const ();\n    let mut _303: usize;\n    let mut _304: usize;\n    let mut _305: usize;\n    let mut _306: bool;\n    let mut _307: *const ();\n    let mut _308: usize;\n    let mut _309: usize;\n    let mut _310: usize;\n    let mut _311: bool;\n    let mut _312: *const ();\n    let mut _313: usize;\n    let mut _314: bool;\n    let mut _315: bool;\n    let mut _316: bool;\n    let mut _317: bool;\n    let mut _318: *const ();\n    let mut _319: usize;\n    let mut _320: bool;\n    let mut _321: bool;\n    let mut _322: bool;\n    let mut _323: bool;\n    debug self => _1;\n    debug stdio => _2;\n    debug envp => _3;\n    debug pidfd_spawnp => _28;\n    debug pidfd_getpid => _32;\n    debug support => _38;\n    debug our_pid => _46;\n    debug pidfd => _47;\n    debug pidfd => _51;\n    debug pid => _58;\n    debug e => _65;\n    debug e => _66;\n    debug left_val => _78;\n    debug version => _84;\n    debug addchdir => _90;\n    debug cwd => _94;\n    debug f => _97;\n    debug pgroup => _100;\n    debug attrs => _102;\n    debug residual => _109;\n    debug val => ();\n    debug attrs => _110;\n    debug flags => _112;\n    debug file_actions => _113;\n    debug residual => _120;\n    debug val => ();\n    debug file_actions => _121;\n    debug fd => _126;\n    debug residual => _132;\n    debug val => ();\n    debug fd => _136;\n    debug residual => _142;\n    debug val => ();\n    debug fd => _146;\n    debug residual => _152;\n    debug val => ();\n    debug f => _154;\n    debug cwd => _155;\n    debug residual => _162;\n    debug val => ();\n    debug pgroup => _164;\n    debug residual => _170;\n    debug val => ();\n    debug default_set => _172;\n    debug residual => _179;\n    debug val => _180;\n    debug residual => _187;\n    debug val => _188;\n    debug residual => _196;\n    debug val => ();\n    debug residual => _206;\n    debug val => ();\n    debug _env_lock => _207;\n    debug envp => _208;\n    debug spawn_fn => libc::posix_spawnp;\n    debug pidfd => _216;\n    debug spawn_res => _217;\n    debug spawn_res => _234;\n    debug e => _236;\n    debug residual => _248;\n    debug val => ();\n    debug pid => _255;\n    debug pid => _255;\n    debug e => _256;\n    debug p => _265;\n    debug spawn_res => _266;\n    debug residual => _284;\n    debug val => ();\n    bb0: {\n        _299 = false;\n        _298 = false;\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &(*_1);\n        _6 = sys::process::unix::common::Command::get_gid(move _7) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _5 = &_6;\n        StorageDead(_7);\n        _4 = core::option::Option::<u32>::is_some(move _5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _4) -> [0: bb4, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageDead(_5);\n        goto -> bb27;\n    }\n    bb4: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_8);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(*_1);\n        _10 = sys::process::unix::common::Command::get_uid(move _11) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _9 = &_10;\n        StorageDead(_11);\n        _8 = core::option::Option::<u32>::is_some(move _9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb8, otherwise: bb7];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageDead(_9);\n        goto -> bb27;\n    }\n    bb8: {\n        StorageDead(_10);\n        StorageDead(_9);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &(*_1);\n        _12 = sys::process::unix::common::Command::env_saw_path(move _13) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        switchInt(move _12) -> [0: bb14, otherwise: bb10];\n    }\n    bb10: {\n        StorageDead(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &(*_1);\n        _14 = sys::process::unix::common::Command::program_is_path(move _15) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        switchInt(move _14) -> [0: bb13, otherwise: bb12];\n    }\n    bb12: {\n        StorageDead(_15);\n        goto -> bb15;\n    }\n    bb13: {\n        StorageDead(_15);\n        goto -> bb27;\n    }\n    bb14: {\n        StorageDead(_13);\n        goto -> bb15;\n    }\n    bb15: {\n        StorageLive(_16);\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = sys::process::unix::common::Command::get_closures(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _17 = &(*_18);\n        _16 = alloc_crate::vec::Vec::<alloc_crate::boxed::Box<dyn core::ops::FnMut() -> core::result::Result<(), io::error::Error> + core::marker::Send + core::marker::Sync>>::is_empty(move _17) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        switchInt(move _16) -> [0: bb19, otherwise: bb18];\n    }\n    bb18: {\n        StorageDead(_17);\n        StorageDead(_18);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &(*_1);\n        _21 = sys::process::unix::common::Command::get_groups(move _22) -> [return: bb20, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_17);\n        StorageDead(_18);\n        goto -> bb27;\n    }\n    bb20: {\n        _20 = &_21;\n        StorageDead(_22);\n        _19 = core::option::Option::<&[u32]>::is_some(move _20) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        switchInt(move _19) -> [0: bb23, otherwise: bb22];\n    }\n    bb22: {\n        StorageDead(_21);\n        StorageDead(_20);\n        goto -> bb27;\n    }\n    bb23: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = &(*_1);\n        _25 = sys::process::unix::common::Command::get_chroot(move _26) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        _24 = &_25;\n        StorageDead(_26);\n        _23 = core::option::Option::<&core::ffi::CStr>::is_some(move _24) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        switchInt(move _23) -> [0: bb28, otherwise: bb26];\n    }\n    bb26: {\n        StorageDead(_25);\n        StorageDead(_24);\n        goto -> bb27;\n    }\n    bb27: {\n        StorageLive(_27);\n        _27 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _27);\n        StorageDead(_27);\n        StorageDead(_23);\n        StorageDead(_19);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_8);\n        StorageDead(_4);\n        goto -> bb265;\n    }\n    bb28: {\n        StorageDead(_25);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_19);\n        StorageDead(_16);\n        StorageDead(_14);\n        StorageDead(_12);\n        StorageDead(_8);\n        StorageDead(_4);\n        StorageLive(_29);\n        StorageLive(_30);\n        StorageLive(_31);\n        _31 = {alloc1757: *const core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>};\n        _307 = _31 as *const ();\n        _308 = _307 as usize;\n        _309 = Sub(<core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32> as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _310 = BitAnd(_308, _309);\n        _311 = Eq(_310, 0_usize);\n        assert(_311, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32> as core::mem::SizedTypeProperties>::ALIGN, _308) -> [success: bb275, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_30);\n        _28 = &_29;\n        StorageLive(_33);\n        StorageLive(_34);\n        StorageLive(_35);\n        _35 = {alloc1758: *const core::option::Option<unsafe extern \"C\" fn(i32) -> i32>};\n        _302 = _35 as *const ();\n        _303 = _302 as usize;\n        _304 = Sub(<core::option::Option<unsafe extern \"C\" fn(i32) -> i32> as core::mem::SizedTypeProperties>::ALIGN, 1_usize);\n        _305 = BitAnd(_303, _304);\n        _306 = Eq(_305, 0_usize);\n        assert(_306, \"misaligned pointer dereference: address must be a multiple of {} but is {}\",<core::option::Option<unsafe extern \"C\" fn(i32) -> i32> as core::mem::SizedTypeProperties>::ALIGN, _303) -> [success: bb274, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_34);\n        _32 = &_33;\n        StorageLive(_36);\n        StorageLive(_37);\n        _37 = &(*_1);\n        _36 = sys::process::unix::common::Command::get_create_pidfd(move _37) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        switchInt(move _36) -> [0: bb70, otherwise: bb32];\n    }\n    bb32: {\n        StorageDead(_37);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = {alloc443: &core::sync::atomic::AtomicU8};\n        StorageLive(_40);\n        _40 = core::sync::atomic::Ordering::Relaxed;\n        _38 = core::sync::atomic::AtomicU8::load(move _39, move _40) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_40);\n        StorageDead(_39);\n        StorageLive(_41);\n        StorageLive(_42);\n        _42 = _38;\n        _41 = Eq(move _42, sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::FORK_EXEC);\n        switchInt(move _41) -> [0: bb35, otherwise: bb34];\n    }\n    bb34: {\n        StorageDead(_42);\n        StorageLive(_43);\n        _43 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _43);\n        StorageDead(_43);\n        StorageDead(_41);\n        goto -> bb263;\n    }\n    bb35: {\n        StorageDead(_42);\n        StorageDead(_41);\n        StorageLive(_44);\n        StorageLive(_45);\n        _45 = _38;\n        _44 = Eq(move _45, sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::UNKNOWN);\n        switchInt(move _44) -> [0: bb37, otherwise: bb36];\n    }\n    bb36: {\n        StorageDead(_45);\n        _38 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::NO;\n        _46 = process::id() -> [return: bb38, unwind unreachable];\n    }\n    bb37: {\n        StorageDead(_45);\n        goto -> bb67;\n    }\n    bb38: {\n        StorageLive(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = libc::syscall(libc::SYS_pidfd_open, _46, 0_i32) -> [return: bb39, unwind unreachable];\n    }\n    bb39: {\n        _48 = move _49 as i32;\n        StorageDead(_49);\n        _47 = sys::pal::unix::cvt::<i32>(move _48) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        _298 = true;\n        StorageDead(_48);\n        _50 = discriminant(_47);\n        switchInt(move _50) -> [0: bb42, 1: bb41, otherwise: bb79];\n    }\n    bb41: {\n        _66 = &((_47 as variant#1).0: io::error::Error);\n        StorageLive(_67);\n        StorageLive(_68);\n        StorageLive(_69);\n        _69 = io::error::Error::raw_os_error(_66) -> [return: bb59, unwind unreachable];\n    }\n    bb42: {\n        _51 = ((_47 as variant#0).0: i32);\n        _38 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::FORK_EXEC;\n        StorageLive(_52);\n        StorageLive(_53);\n        _53 = sys::pal::unix::weak::weak_linkage::ExternWeak::<unsafe extern \"C\" fn(i32) -> i32>::get(_32) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = &_51;\n        _54 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:510:79: 510:82}(move _55);\n        StorageDead(_55);\n        _52 = core::option::Option::<unsafe extern \"C\" fn(i32) -> i32>::map::<core::result::Result<i32, io::error::Error>, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:510:79: 510:82}>(move _53, move _54) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_54);\n        StorageDead(_53);\n        _57 = discriminant(_52);\n        switchInt(move _57) -> [1: bb45, 0: bb54, otherwise: bb79];\n    }\n    bb45: {\n        _56 = discriminant(((_52 as variant#1).0: core::result::Result<i32, io::error::Error>));\n        switchInt(move _56) -> [0: bb46, 1: bb54, otherwise: bb79];\n    }\n    bb46: {\n        _58 = ((((_52 as variant#1).0: core::result::Result<i32, io::error::Error>) as variant#0).0: i32);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = sys::pal::unix::weak::weak_linkage::ExternWeak::<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>::get(_28) -> [return: bb47, unwind unreachable];\n    }\n    bb47: {\n        _60 = &_61;\n        _59 = core::option::Option::<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>::is_some(move _60) -> [return: bb48, unwind unreachable];\n    }\n    bb48: {\n        switchInt(move _59) -> [0: bb52, otherwise: bb49];\n    }\n    bb49: {\n        StorageDead(_61);\n        StorageDead(_60);\n        StorageLive(_62);\n        StorageLive(_63);\n        _63 = _58 as u32;\n        _62 = Eq(move _63, _46);\n        switchInt(move _62) -> [0: bb51, otherwise: bb50];\n    }\n    bb50: {\n        StorageDead(_63);\n        _38 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::SPAWN;\n        goto -> bb53;\n    }\n    bb51: {\n        StorageDead(_63);\n        goto -> bb53;\n    }\n    bb52: {\n        StorageDead(_61);\n        StorageDead(_60);\n        goto -> bb53;\n    }\n    bb53: {\n        StorageDead(_62);\n        StorageDead(_59);\n        drop(_52) -> [return: bb56, unwind unreachable];\n    }\n    bb54: {\n        drop(_52) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        StorageDead(_52);\n        goto -> bb57;\n    }\n    bb56: {\n        StorageDead(_52);\n        goto -> bb57;\n    }\n    bb57: {\n        StorageLive(_64);\n        _64 = libc::close(_51) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_64);\n        goto -> bb63;\n    }\n    bb59: {\n        _68 = &_69;\n        StorageLive(_70);\n        _70 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::promoted[3];\n        _67 = <core::option::Option<i32> as core::cmp::PartialEq>::eq(move _68, move _70) -> [return: bb60, unwind unreachable];\n    }\n    bb60: {\n        switchInt(move _67) -> [0: bb62, otherwise: bb61];\n    }\n    bb61: {\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_67);\n        _298 = false;\n        _65 = move ((_47 as variant#1).0: io::error::Error);\n        _0 = core::result::Result::Err(_65);\n        goto -> bb262;\n    }\n    bb62: {\n        StorageDead(_70);\n        StorageDead(_69);\n        StorageDead(_68);\n        StorageDead(_67);\n        goto -> bb63;\n    }\n    bb63: {\n        StorageLive(_72);\n        _72 = {alloc443: &core::sync::atomic::AtomicU8};\n        StorageLive(_73);\n        _73 = _38;\n        StorageLive(_74);\n        _74 = core::sync::atomic::Ordering::Relaxed;\n        _71 = core::sync::atomic::AtomicU8::store(move _72, move _73, move _74) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_74);\n        StorageDead(_73);\n        StorageDead(_72);\n        StorageLive(_75);\n        StorageLive(_76);\n        _76 = _38;\n        _75 = Eq(move _76, sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::FORK_EXEC);\n        switchInt(move _75) -> [0: bb66, otherwise: bb65];\n    }\n    bb65: {\n        StorageDead(_76);\n        StorageLive(_77);\n        _77 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _77);\n        StorageDead(_77);\n        StorageDead(_75);\n        goto -> bb262;\n    }\n    bb66: {\n        StorageDead(_76);\n        StorageDead(_75);\n        _300 = discriminant(_47);\n        switchInt(move _300) -> [1: bb267, 0: bb266, otherwise: bb79];\n    }\n    bb67: {\n        StorageDead(_44);\n        switchInt(_38) -> [1: bb69, 3: bb69, otherwise: bb68];\n    }\n    bb68: {\n        _78 = &_38;\n        StorageLive(_80);\n        _80 = \"SPAWN | NO\";\n        StorageLive(_81);\n        _81 = core::option::Option::None;\n        _79 = core::panicking::assert_matches_failed::<u8>(_78, move _80, move _81) -> unwind unreachable;\n    }\n    bb69: {\n        StorageDead(_38);\n        goto -> bb71;\n    }\n    bb70: {\n        StorageDead(_37);\n        goto -> bb71;\n    }\n    bb71: {\n        StorageDead(_36);\n        StorageLive(_82);\n        _82 = sys::pal::unix::os::glibc_version() -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        _83 = discriminant(_82);\n        switchInt(move _83) -> [1: bb73, 0: bb77, otherwise: bb79];\n    }\n    bb73: {\n        StorageLive(_84);\n        _84 = ((_82 as variant#1).0: (usize, usize));\n        StorageLive(_85);\n        StorageLive(_86);\n        _86 = &_84;\n        StorageLive(_87);\n        _87 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::promoted[2];\n        _85 = <(usize, usize) as core::cmp::PartialOrd>::lt(move _86, move _87) -> [return: bb74, unwind unreachable];\n    }\n    bb74: {\n        switchInt(move _85) -> [0: bb76, otherwise: bb75];\n    }\n    bb75: {\n        StorageDead(_87);\n        StorageDead(_86);\n        StorageLive(_88);\n        _88 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _88);\n        StorageDead(_88);\n        StorageDead(_85);\n        StorageDead(_84);\n        StorageDead(_82);\n        goto -> bb264;\n    }\n    bb76: {\n        StorageDead(_87);\n        StorageDead(_86);\n        StorageDead(_85);\n        StorageDead(_84);\n        StorageDead(_82);\n        StorageLive(_90);\n        StorageLive(_91);\n        StorageLive(_92);\n        _92 = &(*_1);\n        _91 = sys::process::unix::common::Command::get_cwd(move _92) -> [return: bb78, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_82);\n        StorageLive(_89);\n        _89 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _89);\n        StorageDead(_89);\n        goto -> bb264;\n    }\n    bb78: {\n        StorageDead(_92);\n        _93 = discriminant(_91);\n        switchInt(move _93) -> [0: bb80, 1: bb81, otherwise: bb79];\n    }\n    bb79: {\n        unreachable;\n    }\n    bb80: {\n        _90 = core::option::Option::None;\n        goto -> bb85;\n    }\n    bb81: {\n        _94 = ((_91 as variant#1).0: &core::ffi::CStr);\n        StorageLive(_95);\n        _95 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::get_posix_spawn_addchdir() -> [return: bb82, unwind unreachable];\n    }\n    bb82: {\n        _96 = discriminant(_95);\n        switchInt(move _96) -> [0: bb83, 1: bb84, otherwise: bb79];\n    }\n    bb83: {\n        StorageLive(_99);\n        _99 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _99);\n        StorageDead(_99);\n        StorageDead(_95);\n        StorageDead(_91);\n        goto -> bb261;\n    }\n    bb84: {\n        _97 = ((_95 as variant#1).0: unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32);\n        StorageLive(_98);\n        _98 = (_97, _94);\n        _90 = core::option::Option::Some(move _98);\n        StorageDead(_98);\n        StorageDead(_95);\n        goto -> bb85;\n    }\n    bb85: {\n        StorageDead(_91);\n        StorageLive(_100);\n        StorageLive(_101);\n        _101 = &(*_1);\n        _100 = sys::process::unix::common::Command::get_pgroup(move _101) -> [return: bb86, unwind unreachable];\n    }\n    bb86: {\n        StorageDead(_101);\n        StorageLive(_102);\n        _102 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::uninit() -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        StorageLive(_103);\n        StorageLive(_104);\n        StorageLive(_105);\n        StorageLive(_106);\n        StorageLive(_107);\n        _107 = &mut _102;\n        _106 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::as_mut_ptr(move _107) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        StorageDead(_107);\n        _105 = libc::posix_spawnattr_init(move _106) -> [return: bb89, unwind unreachable];\n    }\n    bb89: {\n        StorageDead(_106);\n        _104 = sys::pal::unix::cvt_nz(move _105) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        StorageDead(_105);\n        _103 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _104) -> [return: bb91, unwind unreachable];\n    }\n    bb91: {\n        StorageDead(_104);\n        _108 = discriminant(_103);\n        switchInt(move _108) -> [0: bb92, 1: bb93, otherwise: bb79];\n    }\n    bb92: {\n        StorageDead(_103);\n        StorageLive(_110);\n        _111 = &mut _102;\n        _110 = PosixSpawnattr(_111);\n        StorageLive(_112);\n        _112 = 0_i32;\n        StorageLive(_113);\n        _113 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::uninit() -> [return: bb95, unwind unreachable];\n    }\n    bb93: {\n        _109 = move ((_103 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_109) -> [return: bb94, unwind unreachable];\n    }\n    bb94: {\n        StorageDead(_103);\n        goto -> bb260;\n    }\n    bb95: {\n        StorageLive(_114);\n        StorageLive(_115);\n        StorageLive(_116);\n        StorageLive(_117);\n        StorageLive(_118);\n        _118 = &mut _113;\n        _117 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_mut_ptr(move _118) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        StorageDead(_118);\n        _116 = libc::posix_spawn_file_actions_init(move _117) -> [return: bb97, unwind unreachable];\n    }\n    bb97: {\n        StorageDead(_117);\n        _115 = sys::pal::unix::cvt_nz(move _116) -> [return: bb98, unwind unreachable];\n    }\n    bb98: {\n        StorageDead(_116);\n        _114 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _115) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        StorageDead(_115);\n        _119 = discriminant(_114);\n        switchInt(move _119) -> [0: bb100, 1: bb101, otherwise: bb79];\n    }\n    bb100: {\n        StorageDead(_114);\n        StorageLive(_121);\n        _122 = &mut _113;\n        _121 = PosixSpawnFileActions(_122);\n        StorageLive(_123);\n        StorageLive(_124);\n        _124 = &((*_2).0: sys::process::unix::common::ChildStdio);\n        _123 = sys::process::unix::common::ChildStdio::fd(move _124) -> [return: bb103, unwind unreachable];\n    }\n    bb101: {\n        _120 = move ((_114 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_120) -> [return: bb102, unwind unreachable];\n    }\n    bb102: {\n        StorageDead(_114);\n        goto -> bb258;\n    }\n    bb103: {\n        StorageDead(_124);\n        _125 = discriminant(_123);\n        switchInt(move _125) -> [1: bb104, 0: bb112, otherwise: bb79];\n    }\n    bb104: {\n        _126 = ((_123 as variant#1).0: i32);\n        StorageLive(_127);\n        StorageLive(_128);\n        StorageLive(_129);\n        StorageLive(_130);\n        _287 = (_121.0: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>);\n        _130 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_mut_ptr(_287) -> [return: bb105, unwind unreachable];\n    }\n    bb105: {\n        _129 = libc::posix_spawn_file_actions_adddup2(move _130, _126, libc::STDIN_FILENO) -> [return: bb106, unwind unreachable];\n    }\n    bb106: {\n        StorageDead(_130);\n        _128 = sys::pal::unix::cvt_nz(move _129) -> [return: bb107, unwind unreachable];\n    }\n    bb107: {\n        StorageDead(_129);\n        _127 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _128) -> [return: bb108, unwind unreachable];\n    }\n    bb108: {\n        StorageDead(_128);\n        _131 = discriminant(_127);\n        switchInt(move _131) -> [0: bb109, 1: bb110, otherwise: bb79];\n    }\n    bb109: {\n        StorageDead(_127);\n        StorageDead(_123);\n        goto -> bb113;\n    }\n    bb110: {\n        _132 = move ((_127 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_132) -> [return: bb111, unwind unreachable];\n    }\n    bb111: {\n        StorageDead(_127);\n        StorageDead(_123);\n        goto -> bb256;\n    }\n    bb112: {\n        StorageDead(_123);\n        goto -> bb113;\n    }\n    bb113: {\n        StorageLive(_133);\n        StorageLive(_134);\n        _134 = &((*_2).1: sys::process::unix::common::ChildStdio);\n        _133 = sys::process::unix::common::ChildStdio::fd(move _134) -> [return: bb114, unwind unreachable];\n    }\n    bb114: {\n        StorageDead(_134);\n        _135 = discriminant(_133);\n        switchInt(move _135) -> [1: bb115, 0: bb123, otherwise: bb79];\n    }\n    bb115: {\n        _136 = ((_133 as variant#1).0: i32);\n        StorageLive(_137);\n        StorageLive(_138);\n        StorageLive(_139);\n        StorageLive(_140);\n        _288 = (_121.0: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>);\n        _140 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_mut_ptr(_288) -> [return: bb116, unwind unreachable];\n    }\n    bb116: {\n        _139 = libc::posix_spawn_file_actions_adddup2(move _140, _136, libc::STDOUT_FILENO) -> [return: bb117, unwind unreachable];\n    }\n    bb117: {\n        StorageDead(_140);\n        _138 = sys::pal::unix::cvt_nz(move _139) -> [return: bb118, unwind unreachable];\n    }\n    bb118: {\n        StorageDead(_139);\n        _137 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _138) -> [return: bb119, unwind unreachable];\n    }\n    bb119: {\n        StorageDead(_138);\n        _141 = discriminant(_137);\n        switchInt(move _141) -> [0: bb120, 1: bb121, otherwise: bb79];\n    }\n    bb120: {\n        StorageDead(_137);\n        StorageDead(_133);\n        goto -> bb124;\n    }\n    bb121: {\n        _142 = move ((_137 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_142) -> [return: bb122, unwind unreachable];\n    }\n    bb122: {\n        StorageDead(_137);\n        StorageDead(_133);\n        goto -> bb256;\n    }\n    bb123: {\n        StorageDead(_133);\n        goto -> bb124;\n    }\n    bb124: {\n        StorageLive(_143);\n        StorageLive(_144);\n        _144 = &((*_2).2: sys::process::unix::common::ChildStdio);\n        _143 = sys::process::unix::common::ChildStdio::fd(move _144) -> [return: bb125, unwind unreachable];\n    }\n    bb125: {\n        StorageDead(_144);\n        _145 = discriminant(_143);\n        switchInt(move _145) -> [1: bb126, 0: bb134, otherwise: bb79];\n    }\n    bb126: {\n        _146 = ((_143 as variant#1).0: i32);\n        StorageLive(_147);\n        StorageLive(_148);\n        StorageLive(_149);\n        StorageLive(_150);\n        _289 = (_121.0: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>);\n        _150 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_mut_ptr(_289) -> [return: bb127, unwind unreachable];\n    }\n    bb127: {\n        _149 = libc::posix_spawn_file_actions_adddup2(move _150, _146, libc::STDERR_FILENO) -> [return: bb128, unwind unreachable];\n    }\n    bb128: {\n        StorageDead(_150);\n        _148 = sys::pal::unix::cvt_nz(move _149) -> [return: bb129, unwind unreachable];\n    }\n    bb129: {\n        StorageDead(_149);\n        _147 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _148) -> [return: bb130, unwind unreachable];\n    }\n    bb130: {\n        StorageDead(_148);\n        _151 = discriminant(_147);\n        switchInt(move _151) -> [0: bb131, 1: bb132, otherwise: bb79];\n    }\n    bb131: {\n        StorageDead(_147);\n        StorageDead(_143);\n        goto -> bb135;\n    }\n    bb132: {\n        _152 = move ((_147 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_152) -> [return: bb133, unwind unreachable];\n    }\n    bb133: {\n        StorageDead(_147);\n        StorageDead(_143);\n        goto -> bb256;\n    }\n    bb134: {\n        StorageDead(_143);\n        goto -> bb135;\n    }\n    bb135: {\n        _153 = discriminant(_90);\n        switchInt(move _153) -> [1: bb136, 0: bb145, otherwise: bb79];\n    }\n    bb136: {\n        _154 = (((_90 as variant#1).0: (unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32, &core::ffi::CStr)).0: unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32);\n        _155 = (((_90 as variant#1).0: (unsafe extern \"C\" fn(*mut libc::posix_spawn_file_actions_t, *const u8) -> i32, &core::ffi::CStr)).1: &core::ffi::CStr);\n        StorageLive(_156);\n        StorageLive(_157);\n        StorageLive(_158);\n        StorageLive(_159);\n        _290 = (_121.0: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>);\n        _159 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_mut_ptr(_290) -> [return: bb137, unwind unreachable];\n    }\n    bb137: {\n        StorageLive(_160);\n        _160 = core::ffi::CStr::as_ptr(_155) -> [return: bb138, unwind unreachable];\n    }\n    bb138: {\n        _158 = _154(move _159, move _160) -> [return: bb139, unwind unreachable];\n    }\n    bb139: {\n        StorageDead(_160);\n        StorageDead(_159);\n        _157 = sys::pal::unix::cvt_nz(move _158) -> [return: bb140, unwind unreachable];\n    }\n    bb140: {\n        StorageDead(_158);\n        _156 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _157) -> [return: bb141, unwind unreachable];\n    }\n    bb141: {\n        StorageDead(_157);\n        _161 = discriminant(_156);\n        switchInt(move _161) -> [0: bb142, 1: bb143, otherwise: bb79];\n    }\n    bb142: {\n        StorageDead(_156);\n        goto -> bb145;\n    }\n    bb143: {\n        _162 = move ((_156 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_162) -> [return: bb144, unwind unreachable];\n    }\n    bb144: {\n        StorageDead(_156);\n        goto -> bb256;\n    }\n    bb145: {\n        _163 = discriminant(_100);\n        switchInt(move _163) -> [1: bb146, 0: bb154, otherwise: bb79];\n    }\n    bb146: {\n        _164 = ((_100 as variant#1).0: i32);\n        _112 = BitOr(_112, libc::POSIX_SPAWN_SETPGROUP);\n        StorageLive(_165);\n        StorageLive(_166);\n        StorageLive(_167);\n        StorageLive(_168);\n        _291 = (_110.0: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>);\n        _168 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::as_mut_ptr(_291) -> [return: bb147, unwind unreachable];\n    }\n    bb147: {\n        _167 = libc::posix_spawnattr_setpgroup(move _168, _164) -> [return: bb148, unwind unreachable];\n    }\n    bb148: {\n        StorageDead(_168);\n        _166 = sys::pal::unix::cvt_nz(move _167) -> [return: bb149, unwind unreachable];\n    }\n    bb149: {\n        StorageDead(_167);\n        _165 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _166) -> [return: bb150, unwind unreachable];\n    }\n    bb150: {\n        StorageDead(_166);\n        _169 = discriminant(_165);\n        switchInt(move _169) -> [0: bb151, 1: bb152, otherwise: bb79];\n    }\n    bb151: {\n        StorageDead(_165);\n        goto -> bb154;\n    }\n    bb152: {\n        _170 = move ((_165 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_170) -> [return: bb153, unwind unreachable];\n    }\n    bb153: {\n        StorageDead(_165);\n        goto -> bb256;\n    }\n    bb154: {\n        StorageLive(_171);\n        _171 = sys::pal::unix::on_broken_pipe_flag_used() -> [return: bb155, unwind unreachable];\n    }\n    bb155: {\n        switchInt(move _171) -> [0: bb156, otherwise: bb180];\n    }\n    bb156: {\n        StorageLive(_172);\n        _172 = core::mem::MaybeUninit::<libc::sigset_t>::uninit() -> [return: bb157, unwind unreachable];\n    }\n    bb157: {\n        StorageLive(_173);\n        StorageLive(_174);\n        StorageLive(_175);\n        StorageLive(_176);\n        StorageLive(_177);\n        _177 = &mut _172;\n        _176 = core::mem::MaybeUninit::<libc::sigset_t>::as_mut_ptr(move _177) -> [return: bb158, unwind unreachable];\n    }\n    bb158: {\n        StorageDead(_177);\n        _175 = libc::sigemptyset(move _176) -> [return: bb159, unwind unreachable];\n    }\n    bb159: {\n        StorageDead(_176);\n        _174 = sys::pal::unix::cvt::<i32>(move _175) -> [return: bb160, unwind unreachable];\n    }\n    bb160: {\n        StorageDead(_175);\n        _173 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _174) -> [return: bb161, unwind unreachable];\n    }\n    bb161: {\n        StorageDead(_174);\n        _178 = discriminant(_173);\n        switchInt(move _178) -> [0: bb162, 1: bb163, otherwise: bb79];\n    }\n    bb162: {\n        StorageLive(_180);\n        _180 = ((_173 as variant#0).0: i32);\n        StorageDead(_180);\n        StorageDead(_173);\n        StorageLive(_181);\n        StorageLive(_182);\n        StorageLive(_183);\n        StorageLive(_184);\n        StorageLive(_185);\n        _185 = &mut _172;\n        _184 = core::mem::MaybeUninit::<libc::sigset_t>::as_mut_ptr(move _185) -> [return: bb165, unwind unreachable];\n    }\n    bb163: {\n        _179 = move ((_173 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_179) -> [return: bb164, unwind unreachable];\n    }\n    bb164: {\n        StorageDead(_173);\n        goto -> bb255;\n    }\n    bb165: {\n        StorageDead(_185);\n        _183 = libc::sigaddset(move _184, libc::SIGPIPE) -> [return: bb166, unwind unreachable];\n    }\n    bb166: {\n        StorageDead(_184);\n        _182 = sys::pal::unix::cvt::<i32>(move _183) -> [return: bb167, unwind unreachable];\n    }\n    bb167: {\n        StorageDead(_183);\n        _181 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _182) -> [return: bb168, unwind unreachable];\n    }\n    bb168: {\n        StorageDead(_182);\n        _186 = discriminant(_181);\n        switchInt(move _186) -> [0: bb169, 1: bb170, otherwise: bb79];\n    }\n    bb169: {\n        StorageLive(_188);\n        _188 = ((_181 as variant#0).0: i32);\n        StorageDead(_188);\n        StorageDead(_181);\n        StorageLive(_189);\n        StorageLive(_190);\n        StorageLive(_191);\n        StorageLive(_192);\n        _292 = (_110.0: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>);\n        _192 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::as_mut_ptr(_292) -> [return: bb172, unwind unreachable];\n    }\n    bb170: {\n        _187 = move ((_181 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_187) -> [return: bb171, unwind unreachable];\n    }\n    bb171: {\n        StorageDead(_181);\n        goto -> bb255;\n    }\n    bb172: {\n        StorageLive(_193);\n        StorageLive(_194);\n        _194 = &_172;\n        _193 = core::mem::MaybeUninit::<libc::sigset_t>::as_ptr(move _194) -> [return: bb173, unwind unreachable];\n    }\n    bb173: {\n        StorageDead(_194);\n        _191 = libc::posix_spawnattr_setsigdefault(move _192, move _193) -> [return: bb174, unwind unreachable];\n    }\n    bb174: {\n        StorageDead(_193);\n        StorageDead(_192);\n        _190 = sys::pal::unix::cvt_nz(move _191) -> [return: bb175, unwind unreachable];\n    }\n    bb175: {\n        StorageDead(_191);\n        _189 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _190) -> [return: bb176, unwind unreachable];\n    }\n    bb176: {\n        StorageDead(_190);\n        _195 = discriminant(_189);\n        switchInt(move _195) -> [0: bb177, 1: bb178, otherwise: bb79];\n    }\n    bb177: {\n        StorageDead(_189);\n        _112 = BitOr(_112, libc::POSIX_SPAWN_SETSIGDEF);\n        StorageDead(_172);\n        goto -> bb180;\n    }\n    bb178: {\n        _196 = move ((_189 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_196) -> [return: bb179, unwind unreachable];\n    }\n    bb179: {\n        StorageDead(_189);\n        goto -> bb255;\n    }\n    bb180: {\n        StorageDead(_171);\n        StorageLive(_197);\n        StorageLive(_198);\n        _198 = &(*_1);\n        _197 = sys::process::unix::common::Command::get_setsid(move _198) -> [return: bb181, unwind unreachable];\n    }\n    bb181: {\n        switchInt(move _197) -> [0: bb183, otherwise: bb182];\n    }\n    bb182: {\n        StorageDead(_198);\n        _112 = BitOr(_112, libc::POSIX_SPAWN_SETSID);\n        goto -> bb184;\n    }\n    bb183: {\n        StorageDead(_198);\n        goto -> bb184;\n    }\n    bb184: {\n        StorageDead(_197);\n        StorageLive(_199);\n        StorageLive(_200);\n        StorageLive(_201);\n        StorageLive(_202);\n        _293 = (_110.0: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>);\n        _202 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::as_mut_ptr(_293) -> [return: bb185, unwind unreachable];\n    }\n    bb185: {\n        StorageLive(_204);\n        _204 = _112;\n        _203 = move _204 as i16;\n        StorageDead(_204);\n        _201 = libc::posix_spawnattr_setflags(move _202, _203) -> [return: bb186, unwind unreachable];\n    }\n    bb186: {\n        StorageDead(_202);\n        _200 = sys::pal::unix::cvt_nz(move _201) -> [return: bb187, unwind unreachable];\n    }\n    bb187: {\n        StorageDead(_201);\n        _199 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _200) -> [return: bb188, unwind unreachable];\n    }\n    bb188: {\n        StorageDead(_200);\n        _205 = discriminant(_199);\n        switchInt(move _205) -> [0: bb189, 1: bb190, otherwise: bb79];\n    }\n    bb189: {\n        StorageDead(_199);\n        StorageLive(_207);\n        _207 = sys::env::unix::env_read_lock() -> [return: bb192, unwind unreachable];\n    }\n    bb190: {\n        _206 = move ((_199 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_206) -> [return: bb191, unwind unreachable];\n    }\n    bb191: {\n        StorageDead(_199);\n        goto -> bb256;\n    }\n    bb192: {\n        StorageLive(_209);\n        _209 = core::option::Option::<&sys::process::unix::common::cstring_array::CStringArray>::map::<*const *const u8, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:766:33: 766:36}>(_3, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:766:33: 766:36}) -> [return: bb193, unwind unreachable];\n    }\n    bb193: {\n        _208 = core::option::Option::<*const *const u8>::unwrap_or_else::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:766:64: 766:66}>(move _209, ZeroSized: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:766:64: 766:66}) -> [return: bb194, unwind unreachable];\n    }\n    bb194: {\n        StorageDead(_209);\n        StorageLive(_210);\n        StorageLive(_211);\n        _211 = &(*_1);\n        _210 = sys::process::unix::common::Command::get_create_pidfd(move _211) -> [return: bb195, unwind unreachable];\n    }\n    bb195: {\n        switchInt(move _210) -> [0: bb231, otherwise: bb196];\n    }\n    bb196: {\n        StorageDead(_211);\n        StorageLive(_212);\n        StorageLive(_213);\n        StorageLive(_214);\n        _214 = {alloc443: &core::sync::atomic::AtomicU8};\n        StorageLive(_215);\n        _215 = core::sync::atomic::Ordering::Relaxed;\n        _213 = core::sync::atomic::AtomicU8::load(move _214, move _215) -> [return: bb197, unwind unreachable];\n    }\n    bb197: {\n        StorageDead(_215);\n        StorageDead(_214);\n        _212 = Eq(move _213, sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::SPAWN);\n        switchInt(move _212) -> [0: bb230, otherwise: bb198];\n    }\n    bb198: {\n        StorageDead(_213);\n        StorageLive(_216);\n        _216 = -1_i32;\n        StorageLive(_218);\n        StorageLive(_219);\n        _219 = sys::pal::unix::weak::weak_linkage::ExternWeak::<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>::get(_28) -> [return: bb199, unwind unreachable];\n    }\n    bb199: {\n        _218 = core::option::Option::<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>::unwrap(move _219) -> [return: bb200, unwind unreachable];\n    }\n    bb200: {\n        StorageDead(_219);\n        StorageLive(_220);\n        StorageLive(_221);\n        _221 = &mut _216;\n        _220 = &raw mut (*_221);\n        StorageLive(_222);\n        StorageLive(_224);\n        _224 = &(*_1);\n        _223 = sys::process::unix::common::Command::get_program_cstr(move _224) -> [return: bb201, unwind unreachable];\n    }\n    bb201: {\n        StorageDead(_224);\n        _222 = core::ffi::CStr::as_ptr(_223) -> [return: bb202, unwind unreachable];\n    }\n    bb202: {\n        StorageLive(_225);\n        StorageLive(_226);\n        _294 = (_121.0: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>);\n        _226 = &(*_294);\n        _225 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_ptr(move _226) -> [return: bb203, unwind unreachable];\n    }\n    bb203: {\n        StorageDead(_226);\n        StorageLive(_227);\n        StorageLive(_228);\n        _295 = (_110.0: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>);\n        _228 = &(*_295);\n        _227 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::as_ptr(move _228) -> [return: bb204, unwind unreachable];\n    }\n    bb204: {\n        StorageDead(_228);\n        StorageLive(_230);\n        StorageLive(_232);\n        _232 = &(*_1);\n        _231 = sys::process::unix::common::Command::get_argv(move _232) -> [return: bb205, unwind unreachable];\n    }\n    bb205: {\n        StorageDead(_232);\n        _230 = sys::process::unix::common::cstring_array::CStringArray::as_ptr(_231) -> [return: bb206, unwind unreachable];\n    }\n    bb206: {\n        _229 = move _230 as *const *mut u8;\n        StorageDead(_230);\n        _233 = _208 as *const *mut u8;\n        _217 = move _218(move _220, move _222, move _225, move _227, _229, _233) -> [return: bb207, unwind unreachable];\n    }\n    bb207: {\n        StorageDead(_227);\n        StorageDead(_225);\n        StorageDead(_222);\n        StorageDead(_220);\n        StorageDead(_218);\n        StorageDead(_221);\n        StorageLive(_234);\n        _234 = sys::pal::unix::cvt_nz(_217) -> [return: bb208, unwind unreachable];\n    }\n    bb208: {\n        _299 = true;\n        _235 = discriminant(_234);\n        switchInt(move _235) -> [1: bb209, 0: bb215, otherwise: bb79];\n    }\n    bb209: {\n        _236 = &((_234 as variant#1).0: io::error::Error);\n        StorageLive(_237);\n        StorageLive(_238);\n        StorageLive(_239);\n        _239 = io::error::Error::raw_os_error(_236) -> [return: bb210, unwind unreachable];\n    }\n    bb210: {\n        _238 = &_239;\n        StorageLive(_240);\n        _240 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::promoted[0];\n        _237 = <core::option::Option<i32> as core::cmp::PartialEq>::eq(move _238, move _240) -> [return: bb211, unwind unreachable];\n    }\n    bb211: {\n        switchInt(move _237) -> [0: bb214, otherwise: bb212];\n    }\n    bb212: {\n        StorageDead(_240);\n        StorageDead(_239);\n        StorageDead(_238);\n        StorageLive(_242);\n        _242 = {alloc443: &core::sync::atomic::AtomicU8};\n        StorageLive(_243);\n        _243 = core::sync::atomic::Ordering::Relaxed;\n        _241 = core::sync::atomic::AtomicU8::store(move _242, sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn::FORK_EXEC, move _243) -> [return: bb213, unwind unreachable];\n    }\n    bb213: {\n        StorageDead(_243);\n        StorageDead(_242);\n        StorageLive(_244);\n        _244 = core::option::Option::None;\n        _0 = core::result::Result::Ok(move _244);\n        StorageDead(_244);\n        StorageDead(_237);\n        goto -> bb270;\n    }\n    bb214: {\n        StorageDead(_240);\n        StorageDead(_239);\n        StorageDead(_238);\n        goto -> bb215;\n    }\n    bb215: {\n        StorageDead(_237);\n        StorageLive(_245);\n        StorageLive(_246);\n        _299 = false;\n        _246 = move _234;\n        _245 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _246) -> [return: bb216, unwind unreachable];\n    }\n    bb216: {\n        StorageDead(_246);\n        _247 = discriminant(_245);\n        switchInt(move _247) -> [0: bb217, 1: bb218, otherwise: bb79];\n    }\n    bb217: {\n        StorageDead(_245);\n        StorageLive(_249);\n        StorageLive(_250);\n        StorageLive(_251);\n        StorageLive(_252);\n        _252 = sys::pal::unix::weak::weak_linkage::ExternWeak::<unsafe extern \"C\" fn(i32) -> i32>::get(_32) -> [return: bb220, unwind unreachable];\n    }\n    bb218: {\n        _248 = move ((_245 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_248) -> [return: bb219, unwind unreachable];\n    }\n    bb219: {\n        StorageDead(_245);\n        goto -> bb270;\n    }\n    bb220: {\n        _251 = core::option::Option::<unsafe extern \"C\" fn(i32) -> i32>::unwrap(move _252) -> [return: bb221, unwind unreachable];\n    }\n    bb221: {\n        StorageDead(_252);\n        StorageLive(_253);\n        _253 = _216;\n        _250 = move _251(move _253) -> [return: bb222, unwind unreachable];\n    }\n    bb222: {\n        StorageDead(_253);\n        StorageDead(_251);\n        _249 = sys::pal::unix::cvt::<i32>(move _250) -> [return: bb223, unwind unreachable];\n    }\n    bb223: {\n        StorageDead(_250);\n        _254 = discriminant(_249);\n        switchInt(move _254) -> [0: bb225, 1: bb224, otherwise: bb79];\n    }\n    bb224: {\n        StorageLive(_256);\n        _256 = move ((_249 as variant#1).0: io::error::Error);\n        StorageLive(_257);\n        StorageLive(_258);\n        _258 = _216;\n        _257 = libc::close(move _258) -> [return: bb226, unwind unreachable];\n    }\n    bb225: {\n        _255 = ((_249 as variant#0).0: i32);\n        StorageDead(_249);\n        StorageLive(_262);\n        StorageLive(_263);\n        StorageLive(_264);\n        _264 = _216;\n        _263 = sys::process::unix::unix::Process::new(_255, move _264) -> [return: bb229, unwind unreachable];\n    }\n    bb226: {\n        StorageDead(_258);\n        StorageDead(_257);\n        StorageLive(_259);\n        StorageLive(_260);\n        StorageLive(_261);\n        _261 = &_256;\n        _260 = io::error::Error::kind(move _261) -> [return: bb227, unwind unreachable];\n    }\n    bb227: {\n        StorageDead(_261);\n        _259 = io::error::Error::new::<&str>(move _260, \"pidfd_spawnp succeeded but the child's PID could not be obtained\") -> [return: bb228, unwind unreachable];\n    }\n    bb228: {\n        StorageDead(_260);\n        _0 = core::result::Result::Err(move _259);\n        StorageDead(_259);\n        drop(_256) -> [return: bb250, unwind unreachable];\n    }\n    bb229: {\n        StorageDead(_264);\n        _262 = core::option::Option::Some(move _263);\n        StorageDead(_263);\n        _0 = core::result::Result::Ok(move _262);\n        StorageDead(_262);\n        goto -> bb251;\n    }\n    bb230: {\n        StorageDead(_213);\n        goto -> bb232;\n    }\n    bb231: {\n        StorageDead(_211);\n        goto -> bb232;\n    }\n    bb232: {\n        StorageDead(_212);\n        StorageDead(_210);\n        StorageLive(_265);\n        _265 = sys::process::unix::unix::Process::new(0_i32, -1_i32) -> [return: bb233, unwind unreachable];\n    }\n    bb233: {\n        StorageLive(_267);\n        StorageLive(_268);\n        _268 = &mut (_265.0: i32);\n        _267 = &raw mut (*_268);\n        StorageLive(_269);\n        StorageLive(_271);\n        _271 = &(*_1);\n        _270 = sys::process::unix::common::Command::get_program_cstr(move _271) -> [return: bb234, unwind unreachable];\n    }\n    bb234: {\n        StorageDead(_271);\n        _269 = core::ffi::CStr::as_ptr(_270) -> [return: bb235, unwind unreachable];\n    }\n    bb235: {\n        StorageLive(_272);\n        StorageLive(_273);\n        _296 = (_121.0: &mut core::mem::MaybeUninit<libc::posix_spawn_file_actions_t>);\n        _273 = &(*_296);\n        _272 = core::mem::MaybeUninit::<libc::posix_spawn_file_actions_t>::as_ptr(move _273) -> [return: bb236, unwind unreachable];\n    }\n    bb236: {\n        StorageDead(_273);\n        StorageLive(_274);\n        StorageLive(_275);\n        _297 = (_110.0: &mut core::mem::MaybeUninit<libc::posix_spawnattr_t>);\n        _275 = &(*_297);\n        _274 = core::mem::MaybeUninit::<libc::posix_spawnattr_t>::as_ptr(move _275) -> [return: bb237, unwind unreachable];\n    }\n    bb237: {\n        StorageDead(_275);\n        StorageLive(_277);\n        StorageLive(_279);\n        _279 = &(*_1);\n        _278 = sys::process::unix::common::Command::get_argv(move _279) -> [return: bb238, unwind unreachable];\n    }\n    bb238: {\n        StorageDead(_279);\n        _277 = sys::process::unix::common::cstring_array::CStringArray::as_ptr(_278) -> [return: bb239, unwind unreachable];\n    }\n    bb239: {\n        _276 = move _277 as *const *mut u8;\n        StorageDead(_277);\n        _280 = _208 as *const *mut u8;\n        _266 = libc::posix_spawnp(move _267, move _269, move _272, move _274, _276, _280) -> [return: bb240, unwind unreachable];\n    }\n    bb240: {\n        StorageDead(_274);\n        StorageDead(_272);\n        StorageDead(_269);\n        StorageDead(_267);\n        StorageDead(_268);\n        StorageLive(_281);\n        StorageLive(_282);\n        _282 = sys::pal::unix::cvt_nz(_266) -> [return: bb241, unwind unreachable];\n    }\n    bb241: {\n        _281 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _282) -> [return: bb242, unwind unreachable];\n    }\n    bb242: {\n        StorageDead(_282);\n        _283 = discriminant(_281);\n        switchInt(move _283) -> [0: bb243, 1: bb244, otherwise: bb79];\n    }\n    bb243: {\n        StorageDead(_281);\n        StorageLive(_285);\n        StorageLive(_286);\n        _286 = move _265;\n        _285 = core::option::Option::Some(move _286);\n        StorageDead(_286);\n        _0 = core::result::Result::Ok(move _285);\n        StorageDead(_285);\n        StorageDead(_265);\n        drop(_207) -> [return: bb246, unwind unreachable];\n    }\n    bb244: {\n        _284 = move ((_281 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_284) -> [return: bb245, unwind unreachable];\n    }\n    bb245: {\n        StorageDead(_281);\n        drop(_265) -> [return: bb249, unwind unreachable];\n    }\n    bb246: {\n        StorageDead(_207);\n        drop(_121) -> [return: bb247, unwind unreachable];\n    }\n    bb247: {\n        StorageDead(_121);\n        StorageDead(_113);\n        StorageDead(_112);\n        drop(_110) -> [return: bb248, unwind unreachable];\n    }\n    bb248: {\n        StorageDead(_110);\n        StorageDead(_102);\n        StorageDead(_100);\n        StorageDead(_90);\n        StorageDead(_33);\n        StorageDead(_29);\n        goto -> bb265;\n    }\n    bb249: {\n        StorageDead(_265);\n        goto -> bb253;\n    }\n    bb250: {\n        StorageDead(_256);\n        StorageDead(_249);\n        goto -> bb251;\n    }\n    bb251: {\n        goto -> bb270;\n    }\n    bb252: {\n        _299 = false;\n        StorageDead(_234);\n        StorageDead(_216);\n        StorageDead(_212);\n        StorageDead(_210);\n        goto -> bb253;\n    }\n    bb253: {\n        drop(_207) -> [return: bb254, unwind unreachable];\n    }\n    bb254: {\n        StorageDead(_207);\n        goto -> bb256;\n    }\n    bb255: {\n        StorageDead(_172);\n        StorageDead(_171);\n        goto -> bb256;\n    }\n    bb256: {\n        drop(_121) -> [return: bb257, unwind unreachable];\n    }\n    bb257: {\n        StorageDead(_121);\n        goto -> bb258;\n    }\n    bb258: {\n        StorageDead(_113);\n        StorageDead(_112);\n        drop(_110) -> [return: bb259, unwind unreachable];\n    }\n    bb259: {\n        StorageDead(_110);\n        goto -> bb260;\n    }\n    bb260: {\n        StorageDead(_102);\n        StorageDead(_100);\n        goto -> bb261;\n    }\n    bb261: {\n        StorageDead(_90);\n        goto -> bb264;\n    }\n    bb262: {\n        _301 = discriminant(_47);\n        switchInt(move _301) -> [1: bb272, 0: bb271, otherwise: bb79];\n    }\n    bb263: {\n        StorageDead(_38);\n        StorageDead(_36);\n        goto -> bb264;\n    }\n    bb264: {\n        StorageDead(_33);\n        StorageDead(_29);\n        goto -> bb265;\n    }\n    bb265: {\n        return;\n    }\n    bb266: {\n        _298 = false;\n        StorageDead(_47);\n        goto -> bb67;\n    }\n    bb267: {\n        switchInt(_298) -> [0: bb266, otherwise: bb268];\n    }\n    bb268: {\n        drop(((_47 as variant#1).0: io::error::Error)) -> [return: bb266, unwind unreachable];\n    }\n    bb269: {\n        drop(_234) -> [return: bb252, unwind unreachable];\n    }\n    bb270: {\n        switchInt(_299) -> [0: bb252, otherwise: bb269];\n    }\n    bb271: {\n        _298 = false;\n        StorageDead(_47);\n        StorageDead(_44);\n        goto -> bb263;\n    }\n    bb272: {\n        switchInt(_298) -> [0: bb271, otherwise: bb273];\n    }\n    bb273: {\n        drop(((_47 as variant#1).0: io::error::Error)) -> [return: bb271, unwind unreachable];\n    }\n    bb274: {\n        _318 = _35 as *const ();\n        _319 = _318 as usize;\n        _320 = Ne(<core::option::Option<unsafe extern \"C\" fn(i32) -> i32> as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _321 = Eq(_319, 0_usize);\n        _322 = BitAnd(_321, _320);\n        _323 = Not(_322);\n        assert(_323, \"null pointer dereference occurred\") -> [success: bb277, unwind unreachable];\n    }\n    bb275: {\n        _312 = _31 as *const ();\n        _313 = _312 as usize;\n        _314 = Ne(<core::option::Option<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32> as core::mem::SizedTypeProperties>::SIZE, 0_usize);\n        _315 = Eq(_313, 0_usize);\n        _316 = BitAnd(_315, _314);\n        _317 = Not(_316);\n        assert(_317, \"null pointer dereference occurred\") -> [success: bb276, unwind unreachable];\n    }\n    bb276: {\n        _30 = (*_31);\n        StorageDead(_31);\n        _29 = sys::pal::unix::weak::weak_linkage::ExternWeak::<unsafe extern \"C\" fn(*mut i32, *const u8, *const libc::posix_spawn_file_actions_t, *const libc::posix_spawnattr_t, *const *mut u8, *const *mut u8) -> i32>::new(move _30) -> [return: bb29, unwind unreachable];\n    }\n    bb277: {\n        _34 = (*_35);\n        StorageDead(_35);\n        _33 = sys::pal::unix::weak::weak_linkage::ExternWeak::<unsafe extern \"C\" fn(i32) -> i32>::new(move _34) -> [return: bb30, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}