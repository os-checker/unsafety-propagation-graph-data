{
  "name": "sys::io::kernel_copy::linux::FdMeta::copy_file_range_candidate",
  "safe": true,
  "callees": {
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "fs::Metadata::is_file": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if this metadata is for a regular file. The\n result is mutually exclusive to the result of\n [`Metadata::is_dir`], and will be false for symlink metadata\n obtained from [`symlink_metadata`].\n\n When the goal is simply to read from (or write to) the source, the most\n reliable way to test the source can be read (or written to) is to open\n it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n a Unix-like system for example. See [`File::open`] or\n [`OpenOptions::open`] for more information.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert!(metadata.is_file());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument"
      }
    },
    "fs::Metadata::len": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the file, in bytes, this metadata is for.\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     let metadata = fs::metadata(\"foo.txt\")?;\n\n     assert_eq!(0, metadata.len());\n     Ok(())\n }\n ```\n",
      "adt": {
        "fs::Metadata": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "sys::io::kernel_copy::linux::FdMeta": [
      "Deref",
      "Unknown([Deref, Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 3692, kind: RigidTy(Adt(AdtDef(DefId { id: 6032, name: \"fs::Metadata\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "fs::Metadata": [
      "Ref"
    ],
    "sys::io::kernel_copy::linux::FdHandle": [
      "Ref",
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::io::kernel_copy::linux::FdMeta::copy_file_range_candidate"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/io/kernel_copy/linux.rs:125:5: 135:6",
  "src": "fn copy_file_range_candidate(&self, f: FdHandle) -> bool {\n        match self {\n            // copy_file_range will fail on empty procfs files. `read` can determine whether EOF has been reached\n            // without extra cost and skip the write, thus there is no benefit in attempting copy_file_range\n            FdMeta::Metadata(meta) if f == FdHandle::Input && meta.is_file() && meta.len() > 0 => {\n                true\n            }\n            FdMeta::Metadata(meta) if f == FdHandle::Output && meta.is_file() => true,\n            _ => false,\n        }\n    }",
  "mir": "fn sys::io::kernel_copy::linux::FdMeta::copy_file_range_candidate(_1: &sys::io::kernel_copy::linux::FdMeta, _2: sys::io::kernel_copy::linux::FdHandle) -> bool {\n    let mut _0: bool;\n    let mut _3: isize;\n    let  _4: &fs::Metadata;\n    let  _5: &&fs::Metadata;\n    let mut _6: bool;\n    let mut _7: &sys::io::kernel_copy::linux::FdHandle;\n    let mut _8: &sys::io::kernel_copy::linux::FdHandle;\n    let mut _9: bool;\n    let mut _10: bool;\n    let mut _11: u64;\n    let  _12: &fs::Metadata;\n    let  _13: &&fs::Metadata;\n    let mut _14: bool;\n    let mut _15: &sys::io::kernel_copy::linux::FdHandle;\n    let mut _16: &sys::io::kernel_copy::linux::FdHandle;\n    let mut _17: bool;\n    let mut _18: &fs::Metadata;\n    let mut _19: &fs::Metadata;\n    let mut _20: &fs::Metadata;\n    debug self => _1;\n    debug f => _2;\n    debug meta => _4;\n    debug meta => _5;\n    debug meta => _12;\n    debug meta => _13;\n    bb0: {\n        _3 = discriminant((*_1));\n        switchInt(move _3) -> [0: bb2, otherwise: bb1];\n    }\n    bb1: {\n        _0 = false;\n        goto -> bb20;\n    }\n    bb2: {\n        StorageLive(_5);\n        StorageLive(_4);\n        _4 = &(((*_1) as variant#0).0: fs::Metadata);\n        _5 = &_4;\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &_2;\n        StorageLive(_8);\n        _8 = sys::io::kernel_copy::linux::FdMeta::copy_file_range_candidate::promoted[1];\n        _6 = <sys::io::kernel_copy::linux::FdHandle as core::cmp::PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _6) -> [0: bb11, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_9);\n        _18 = (*_5);\n        _9 = fs::Metadata::is_file(_18) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        switchInt(move _9) -> [0: bb10, otherwise: bb6];\n    }\n    bb6: {\n        StorageDead(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _19 = (*_5);\n        _11 = fs::Metadata::len(_19) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        _10 = Gt(move _11, 0_u64);\n        switchInt(move _10) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _0 = true;\n        StorageDead(_4);\n        StorageDead(_5);\n        goto -> bb20;\n    }\n    bb9: {\n        StorageDead(_11);\n        StorageDead(_10);\n        goto -> bb12;\n    }\n    bb10: {\n        StorageDead(_9);\n        goto -> bb12;\n    }\n    bb11: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        goto -> bb12;\n    }\n    bb12: {\n        StorageDead(_4);\n        StorageDead(_5);\n        StorageLive(_13);\n        StorageLive(_12);\n        _12 = &(((*_1) as variant#0).0: fs::Metadata);\n        _13 = &_12;\n        StorageLive(_14);\n        StorageLive(_15);\n        _15 = &_2;\n        StorageLive(_16);\n        _16 = sys::io::kernel_copy::linux::FdMeta::copy_file_range_candidate::promoted[0];\n        _14 = <sys::io::kernel_copy::linux::FdHandle as core::cmp::PartialEq>::eq(move _15, move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        switchInt(move _14) -> [0: bb18, otherwise: bb14];\n    }\n    bb14: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageLive(_17);\n        _20 = (*_13);\n        _17 = fs::Metadata::is_file(_20) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        switchInt(move _17) -> [0: bb17, otherwise: bb16];\n    }\n    bb16: {\n        StorageDead(_17);\n        _0 = true;\n        StorageDead(_12);\n        StorageDead(_13);\n        goto -> bb20;\n    }\n    bb17: {\n        StorageDead(_17);\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_16);\n        StorageDead(_15);\n        StorageDead(_14);\n        goto -> bb19;\n    }\n    bb19: {\n        StorageDead(_12);\n        StorageDead(_13);\n        goto -> bb1;\n    }\n    bb20: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}