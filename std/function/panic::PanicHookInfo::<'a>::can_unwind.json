{
  "name": "panic::PanicHookInfo::<'a>::can_unwind",
  "safe": true,
  "callees": {},
  "adts": {
    "panic::PanicHookInfo": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "Ref"
    ]
  },
  "path": 2275,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/panic.rs:182:5: 184:6",
  "src": "pub fn can_unwind(&self) -> bool {\n        self.can_unwind\n    }",
  "mir": "fn panic::PanicHookInfo::<'a>::can_unwind(_1: &panic::PanicHookInfo<'_>) -> bool {\n    let mut _0: bool;\n    debug self => _1;\n    bb0: {\n        _0 = ((*_1).2: bool);\n        return;\n    }\n}\n",
  "doc": " Returns whether the panic handler is allowed to unwind the stack from\n the point where the panic occurred.\n\n This is true for most kinds of panics with the exception of panics\n caused by trying to unwind out of a `Drop` implementation or a function\n whose ABI does not support unwinding.\n\n It is safe for a panic handler to unwind even when this function returns\n false, however this will simply cause the panic handler to be called\n again.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}