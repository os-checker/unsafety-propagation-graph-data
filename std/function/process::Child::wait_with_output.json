{
  "name": "process::Child::wait_with_output",
  "safe": true,
  "callees": {
    "core::option::Option::<T>::take": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes the value out of the option, leaving a [`None`] in its place.\n\n # Examples\n\n ```\n let mut x = Some(2);\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, Some(2));\n\n let mut x: Option<u32> = None;\n let y = x.take();\n assert_eq!(x, None);\n assert_eq!(y, None);\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "alloc_crate::vec::Vec::<T>::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new, empty `Vec<T>`.\n\n The vector will not allocate until elements are pushed onto it.\n\n # Examples\n\n ```\n # #![allow(unused_mut)]\n let mut vec: Vec<i32> = Vec::new();\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::pipe::read2": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "io::Read::read_to_end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reads all bytes until EOF in this source, placing them into `buf`.\n\n All bytes read from this source will be appended to the specified buffer\n `buf`. This function will continuously call [`read()`] to append more data to\n `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n non-[`ErrorKind::Interrupted`] kind.\n\n If successful, this function will return the total number of bytes read.\n\n # Errors\n\n If this function encounters an error of the kind\n [`ErrorKind::Interrupted`] then the error is ignored and the operation\n will continue.\n\n If any other read error is encountered then this function immediately\n returns. Any bytes which have already been read will be appended to\n `buf`.\n\n # Examples\n\n [`File`]s implement `Read`:\n\n [`read()`]: Read::read\n [`Ok(0)`]: Ok\n [`File`]: crate::fs::File\n\n ```no_run\n use std::io;\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> io::Result<()> {\n     let mut f = File::open(\"foo.txt\")?;\n     let mut buffer = Vec::new();\n\n     // read the whole file\n     f.read_to_end(&mut buffer)?;\n     Ok(())\n }\n ```\n\n (See also the [`std::fs::read`] convenience function for reading from a\n file.)\n\n [`std::fs::read`]: crate::fs::read\n\n ## Implementing `read_to_end`\n\n When implementing the `io::Read` trait, it is recommended to allocate\n memory using [`Vec::try_reserve`]. However, this behavior is not guaranteed\n by all implementations, and `read_to_end` may not handle out-of-memory\n situations gracefully.\n\n ```no_run\n # use std::io::{self, BufRead};\n # struct Example { example_datasource: io::Empty } impl Example {\n # fn get_some_data_for_the_example(&self) -> &'static [u8] { &[] }\n fn read_to_end(&mut self, dest_vec: &mut Vec<u8>) -> io::Result<usize> {\n     let initial_vec_len = dest_vec.len();\n     loop {\n         let src_buf = self.example_datasource.fill_buf()?;\n         if src_buf.is_empty() {\n             break;\n         }\n         dest_vec.try_reserve(src_buf.len())?;\n         dest_vec.extend_from_slice(src_buf);\n\n         // Any irreversible side effects should happen after `try_reserve` succeeds,\n         // to avoid losing data on allocation error.\n         let read = src_buf.len();\n         self.example_datasource.consume(read);\n     }\n     Ok(dest_vec.len() - initial_vec_len)\n }\n # }\n ```\n\n # Usage Notes\n\n `read_to_end` attempts to read a source until EOF, but many sources are continuous streams\n that do not send EOF. In these cases, `read_to_end` will block indefinitely. Standard input\n is one such stream which may be finite if piped, but is typically continuous. For example,\n `cat file | my-rust-program` will correctly terminate with an `EOF` upon closure of cat.\n Reading user input or running programs that remain open indefinitely will never terminate\n the stream with `EOF` (e.g. `yes | my-rust-program`).\n\n Using `.lines()` with a [`BufReader`] or using [`read`] can provide a better solution\n\n[`read`]: Read::read\n\n [`Vec::try_reserve`]: crate::vec::Vec::try_reserve\n",
      "adt": {
        "alloc_crate::vec::Vec": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "process::Child::wait": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Waits for the child to exit completely, returning the status that it\n exited with. This function will continue to have the same return value\n after it has been called at least once.\n\n The stdin handle to the child process, if any, will be closed\n before waiting. This helps avoid deadlock: it ensures that the\n child does not block waiting for input from the parent, while\n the parent waits for the child to exit.\n\n # Examples\n\n ```no_run\n use std::process::Command;\n\n let mut command = Command::new(\"ls\");\n if let Ok(mut child) = command.spawn() {\n     child.wait().expect(\"command wasn't running\");\n     println!(\"Child has finished its execution!\");\n } else {\n     println!(\"ls command didn't start\");\n }\n ```\n",
      "adt": {
        "process::Child": "MutableAsArgument",
        "core::result::Result": "Constructor",
        "process::ExitStatus": "Constructor"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "MutRef",
      "Plain",
      "Unknown([Field(0, Ty { id: 10107, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8888, kind: RigidTy(Adt(AdtDef(DefId { id: 8523, name: \"process::ChildStdout\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 10108, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8893, kind: RigidTy(Adt(AdtDef(DefId { id: 8526, name: \"process::ChildStderr\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(0, Ty { id: 10107, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8888, kind: RigidTy(Adt(AdtDef(DefId { id: 8523, name: \"process::ChildStdout\" }), GenericArgs([]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8888, kind: RigidTy(Adt(AdtDef(DefId { id: 8523, name: \"process::ChildStdout\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 10108, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8893, kind: RigidTy(Adt(AdtDef(DefId { id: 8526, name: \"process::ChildStderr\" }), GenericArgs([]))) })]))) }), Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8893, kind: RigidTy(Adt(AdtDef(DefId { id: 8526, name: \"process::ChildStderr\" }), GenericArgs([]))) })])"
    ],
    "process::Child": [
      "Unknown([Field(1, Ty { id: 10106, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8882, kind: RigidTy(Adt(AdtDef(DefId { id: 8518, name: \"process::ChildStdin\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(2, Ty { id: 10107, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8888, kind: RigidTy(Adt(AdtDef(DefId { id: 8523, name: \"process::ChildStdout\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(3, Ty { id: 10108, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8893, kind: RigidTy(Adt(AdtDef(DefId { id: 8526, name: \"process::ChildStderr\" }), GenericArgs([]))) })]))) })])",
      "Plain",
      "MutRef"
    ],
    "alloc_crate::vec::Vec": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Field(1, Ty { id: 1195, kind: RigidTy(Adt(AdtDef(DefId { id: 4768, name: \"alloc_crate::vec::Vec\" }), GenericArgs([Type(Ty { id: 35, kind: RigidTy(Uint(U8)) }), Type(Ty { id: 19, kind: RigidTy(Adt(AdtDef(DefId { id: 4635, name: \"alloc_crate::alloc::Global\" }), GenericArgs([]))) })]))) })])",
      "MutRef"
    ],
    "process::ChildStdout": [
      "Plain",
      "Unknown([Field(0, Ty { id: 8883, kind: RigidTy(Adt(AdtDef(DefId { id: 8520, name: \"sys::pal::unix::pipe::AnonPipe\" }), GenericArgs([]))) })])",
      "MutRef"
    ],
    "process::ChildStderr": [
      "Plain",
      "Unknown([Field(0, Ty { id: 8883, kind: RigidTy(Adt(AdtDef(DefId { id: 8520, name: \"sys::pal::unix::pipe::AnonPipe\" }), GenericArgs([]))) })])",
      "MutRef"
    ],
    "sys::pal::unix::pipe::AnonPipe": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8803, kind: RigidTy(Adt(AdtDef(DefId { id: 8478, name: \"process::ExitStatus\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "process::ExitStatus": [
      "Plain"
    ],
    "process::Output": [
      "Plain"
    ]
  },
  "path": 2565,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/process.rs:2368:5: 2390:6",
  "src": "pub fn wait_with_output(mut self) -> io::Result<Output> {\n        drop(self.stdin.take());\n\n        let (mut stdout, mut stderr) = (Vec::new(), Vec::new());\n        match (self.stdout.take(), self.stderr.take()) {\n            (None, None) => {}\n            (Some(mut out), None) => {\n                let res = out.read_to_end(&mut stdout);\n                res.unwrap();\n            }\n            (None, Some(mut err)) => {\n                let res = err.read_to_end(&mut stderr);\n                res.unwrap();\n            }\n            (Some(out), Some(err)) => {\n                let res = read2(out.inner, &mut stdout, err.inner, &mut stderr);\n                res.unwrap();\n            }\n        }\n\n        let status = self.wait()?;\n        Ok(Output { status, stdout, stderr })\n    }",
  "mir": "fn process::Child::wait_with_output(_1: process::Child) -> core::result::Result<process::Output, io::error::Error> {\n    let mut _0: core::result::Result<process::Output, io::error::Error>;\n    let  _2: ();\n    let mut _3: core::option::Option<process::ChildStdin>;\n    let mut _4: &mut core::option::Option<process::ChildStdin>;\n    let mut _5: alloc_crate::vec::Vec<u8>;\n    let mut _6: alloc_crate::vec::Vec<u8>;\n    let mut _7: (alloc_crate::vec::Vec<u8>, alloc_crate::vec::Vec<u8>);\n    let mut _8: alloc_crate::vec::Vec<u8>;\n    let mut _9: alloc_crate::vec::Vec<u8>;\n    let mut _10: (core::option::Option<process::ChildStdout>, core::option::Option<process::ChildStderr>);\n    let mut _11: core::option::Option<process::ChildStdout>;\n    let mut _12: &mut core::option::Option<process::ChildStdout>;\n    let mut _13: core::option::Option<process::ChildStderr>;\n    let mut _14: &mut core::option::Option<process::ChildStderr>;\n    let mut _15: isize;\n    let mut _16: isize;\n    let mut _17: isize;\n    let mut _18: process::ChildStdout;\n    let  _19: core::result::Result<usize, io::error::Error>;\n    let mut _20: &mut process::ChildStdout;\n    let mut _21: &mut alloc_crate::vec::Vec<u8>;\n    let  _22: usize;\n    let mut _23: process::ChildStderr;\n    let  _24: core::result::Result<usize, io::error::Error>;\n    let mut _25: &mut process::ChildStderr;\n    let mut _26: &mut alloc_crate::vec::Vec<u8>;\n    let  _27: usize;\n    let  _28: process::ChildStdout;\n    let  _29: process::ChildStderr;\n    let  _30: core::result::Result<(), io::error::Error>;\n    let mut _31: sys::pal::unix::pipe::AnonPipe;\n    let mut _32: &mut alloc_crate::vec::Vec<u8>;\n    let mut _33: sys::pal::unix::pipe::AnonPipe;\n    let mut _34: &mut alloc_crate::vec::Vec<u8>;\n    let  _35: ();\n    let mut _36: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, process::ExitStatus>;\n    let mut _37: core::result::Result<process::ExitStatus, io::error::Error>;\n    let mut _38: &mut process::Child;\n    let mut _39: isize;\n    let  _40: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _41: process::ExitStatus;\n    let mut _42: process::Output;\n    let mut _43: alloc_crate::vec::Vec<u8>;\n    let mut _44: alloc_crate::vec::Vec<u8>;\n    debug self => _1;\n    debug stdout => _5;\n    debug stderr => _6;\n    debug out => _18;\n    debug res => _19;\n    debug err => _23;\n    debug res => _24;\n    debug out => _28;\n    debug err => _29;\n    debug res => _30;\n    debug status => _41;\n    debug residual => _40;\n    debug val => _41;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = &mut (_1.1: core::option::Option<process::ChildStdin>);\n        _3 = core::option::Option::<process::ChildStdin>::take(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        _2 = core::mem::drop::<core::option::Option<process::ChildStdin>>(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = alloc_crate::vec::Vec::<u8>::new() -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageLive(_9);\n        _9 = alloc_crate::vec::Vec::<u8>::new() -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = (move _8, move _9);\n        StorageDead(_9);\n        StorageDead(_8);\n        StorageLive(_5);\n        _5 = move (_7.0: alloc_crate::vec::Vec<u8>);\n        StorageLive(_6);\n        _6 = move (_7.1: alloc_crate::vec::Vec<u8>);\n        StorageDead(_7);\n        StorageLive(_10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = &mut (_1.2: core::option::Option<process::ChildStdout>);\n        _11 = core::option::Option::<process::ChildStdout>::take(move _12) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &mut (_1.3: core::option::Option<process::ChildStderr>);\n        _13 = core::option::Option::<process::ChildStderr>::take(move _14) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_14);\n        _10 = (move _11, move _13);\n        StorageDead(_13);\n        StorageDead(_11);\n        _17 = discriminant((_10.0: core::option::Option<process::ChildStdout>));\n        switchInt(move _17) -> [0: bb8, 1: bb9, otherwise: bb7];\n    }\n    bb7: {\n        unreachable;\n    }\n    bb8: {\n        _15 = discriminant((_10.1: core::option::Option<process::ChildStderr>));\n        switchInt(move _15) -> [0: bb29, 1: bb11, otherwise: bb7];\n    }\n    bb9: {\n        _16 = discriminant((_10.1: core::option::Option<process::ChildStderr>));\n        switchInt(move _16) -> [0: bb12, 1: bb10, otherwise: bb7];\n    }\n    bb10: {\n        StorageLive(_28);\n        _28 = move (((_10.0: core::option::Option<process::ChildStdout>) as variant#1).0: process::ChildStdout);\n        StorageLive(_29);\n        _29 = move (((_10.1: core::option::Option<process::ChildStderr>) as variant#1).0: process::ChildStderr);\n        StorageLive(_31);\n        _31 = move (_28.0: sys::pal::unix::pipe::AnonPipe);\n        _32 = &mut _5;\n        StorageLive(_33);\n        _33 = move (_29.0: sys::pal::unix::pipe::AnonPipe);\n        _34 = &mut _6;\n        _30 = sys::pal::unix::pipe::read2(move _31, _32, move _33, _34) -> [return: bb19, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_23);\n        _23 = move (((_10.1: core::option::Option<process::ChildStderr>) as variant#1).0: process::ChildStderr);\n        StorageLive(_25);\n        _25 = &mut _23;\n        _26 = &mut _6;\n        _24 = <process::ChildStderr as io::Read>::read_to_end(move _25, _26) -> [return: bb16, unwind unreachable];\n    }\n    bb12: {\n        StorageLive(_18);\n        _18 = move (((_10.0: core::option::Option<process::ChildStdout>) as variant#1).0: process::ChildStdout);\n        StorageLive(_20);\n        _20 = &mut _18;\n        _21 = &mut _5;\n        _19 = <process::ChildStdout as io::Read>::read_to_end(move _20, _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = core::result::Result::<usize, io::error::Error>::unwrap(_19) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_22);\n        drop(_18) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_18);\n        goto -> bb29;\n    }\n    bb16: {\n        StorageDead(_25);\n        StorageLive(_27);\n        _27 = core::result::Result::<usize, io::error::Error>::unwrap(_24) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        StorageDead(_27);\n        drop(_23) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_23);\n        goto -> bb29;\n    }\n    bb19: {\n        StorageDead(_33);\n        StorageDead(_31);\n        _35 = core::result::Result::<(), io::error::Error>::unwrap(_30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_29);\n        StorageDead(_28);\n        goto -> bb29;\n    }\n    bb21: {\n        StorageDead(_38);\n        _36 = <core::result::Result<process::ExitStatus, io::error::Error> as core::ops::Try>::branch(move _37) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_37);\n        _39 = discriminant(_36);\n        switchInt(move _39) -> [0: bb23, 1: bb24, otherwise: bb7];\n    }\n    bb23: {\n        _41 = ((_36 as variant#0).0: process::ExitStatus);\n        StorageDead(_36);\n        StorageLive(_42);\n        StorageLive(_43);\n        _43 = move _5;\n        StorageLive(_44);\n        _44 = move _6;\n        _42 = Output(_41, move _43, move _44);\n        StorageDead(_44);\n        StorageDead(_43);\n        _0 = core::result::Result::Ok(move _42);\n        StorageDead(_42);\n        StorageDead(_6);\n        StorageDead(_5);\n        drop(_1) -> [return: bb28, unwind unreachable];\n    }\n    bb24: {\n        _40 = move ((_36 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<process::Output, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_40) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_36);\n        drop(_6) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_6);\n        drop(_5) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_5);\n        drop(_1) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        return;\n    }\n    bb29: {\n        StorageDead(_10);\n        StorageLive(_36);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = &mut _1;\n        _37 = process::Child::wait(move _38) -> [return: bb21, unwind unreachable];\n    }\n}\n",
  "doc": " Simultaneously waits for the child to exit and collect all remaining\n output on the stdout/stderr handles, returning an `Output`\n instance.\n\n The stdin handle to the child process, if any, will be closed\n before waiting. This helps avoid deadlock: it ensures that the\n child does not block waiting for input from the parent, while\n the parent waits for the child to exit.\n\n By default, stdin, stdout and stderr are inherited from the parent.\n In order to capture the output into this `Result<Output>` it is\n necessary to create new pipes between parent and child. Use\n `stdout(Stdio::piped())` or `stderr(Stdio::piped())`, respectively.\n\n # Examples\n\n ```should_panic\n use std::process::{Command, Stdio};\n\n let child = Command::new(\"/bin/cat\")\n     .arg(\"file.txt\")\n     .stdout(Stdio::piped())\n     .spawn()\n     .expect(\"failed to execute child\");\n\n let output = child\n     .wait_with_output()\n     .expect(\"failed to wait on child\");\n\n assert!(output.status.success());\n ```\n\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}