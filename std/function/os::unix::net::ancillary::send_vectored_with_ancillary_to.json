{
  "name": "os::unix::net::ancillary::send_vectored_with_ancillary_to",
  "safe": true,
  "callees": {
    "os::unix::net::addr::sockaddr_un": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "libc::sockaddr_un": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::cast": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Casts to a pointer of another type.\n",
      "adt": {}
    },
    "sys::net::connection::socket::unix::Socket::send_msg": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "libc::msghdr": "MutableAsArgument",
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 2754, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 2756, kind: RigidTy(Adt(AdtDef(DefId { id: 5564, name: \"path::Path\" }), GenericArgs([]))) }, Not)) })])"
    ],
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8104, kind: RigidTy(Tuple([Ty { id: 8110, kind: RigidTy(Adt(AdtDef(DefId { id: 8100, name: \"libc::sockaddr_un\" }), GenericArgs([]))) }, Ty { id: 608, kind: RigidTy(Uint(U32)) }])) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "libc::sockaddr_un": [
      "Plain",
      "Unknown([Field(0, Ty { id: 8110, kind: RigidTy(Adt(AdtDef(DefId { id: 8100, name: \"libc::sockaddr_un\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])"
    ],
    "libc::msghdr": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(1, Ty { id: 608, kind: RigidTy(Uint(U32)) })])",
      "Unknown([Field(2, Ty { id: 8190, kind: RigidTy(RawPtr(Ty { id: 8201, kind: RigidTy(Adt(AdtDef(DefId { id: 8157, name: \"libc::iovec\" }), GenericArgs([]))) }, Mut)) })])",
      "Unknown([Field(3, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(5, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])",
      "Unknown([Field(4, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])",
      "MutRef"
    ],
    "os::unix::net::ancillary::SocketAncillary": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(2)))",
      "MutRef"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Ref"
    ]
  },
  "path": 2114,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/ancillary.rs:63:1: 88:2",
  "src": "pub(super) fn send_vectored_with_ancillary_to(\n    socket: &Socket,\n    path: Option<&Path>,\n    bufs: &[IoSlice<'_>],\n    ancillary: &mut SocketAncillary<'_>,\n) -> io::Result<usize> {\n    unsafe {\n        let (mut msg_name, msg_namelen) =\n            if let Some(path) = path { sockaddr_un(path)? } else { (zeroed(), 0) };\n\n        let mut msg: libc::msghdr = zeroed();\n        msg.msg_name = (&raw mut msg_name) as *mut _;\n        msg.msg_namelen = msg_namelen;\n        msg.msg_iov = bufs.as_ptr() as *mut _;\n        msg.msg_iovlen = bufs.len() as _;\n        msg.msg_controllen = ancillary.length as _;\n        // macos requires that the control pointer is null when the len is 0.\n        if msg.msg_controllen > 0 {\n            msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n        }\n\n        ancillary.truncated = false;\n\n        socket.send_msg(&mut msg)\n    }\n}",
  "mir": "fn os::unix::net::ancillary::send_vectored_with_ancillary_to(_1: &sys::net::connection::socket::unix::Socket, _2: core::option::Option<&path::Path>, _3: &[io::IoSlice<'_>], _4: &mut os::unix::net::ancillary::SocketAncillary<'_>) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _5: libc::sockaddr_un;\n    let  _6: u32;\n    let mut _7: (libc::sockaddr_un, u32);\n    let mut _8: isize;\n    let  _9: &path::Path;\n    let mut _10: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, (libc::sockaddr_un, u32)>;\n    let mut _11: core::result::Result<(libc::sockaddr_un, u32), io::error::Error>;\n    let mut _12: isize;\n    let  _13: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _14: (libc::sockaddr_un, u32);\n    let mut _15: libc::sockaddr_un;\n    let mut _16: libc::msghdr;\n    let mut _17: *mut libc::c_void;\n    let mut _18: *mut libc::sockaddr_un;\n    let mut _19: *mut libc::iovec;\n    let mut _20: *const io::IoSlice<'_>;\n    let mut _21: usize;\n    let mut _22: usize;\n    let mut _23: bool;\n    let mut _24: usize;\n    let mut _25: *mut libc::c_void;\n    let mut _26: *mut u8;\n    let mut _27: &mut libc::msghdr;\n    let mut _28: &mut [u8];\n    debug socket => _1;\n    debug path => _2;\n    debug bufs => _3;\n    debug ancillary => _4;\n    debug msg_name => _5;\n    debug msg_namelen => _6;\n    debug path => _9;\n    debug residual => _13;\n    debug val => _14;\n    debug msg => _16;\n    bb0: {\n        StorageLive(_7);\n        _8 = discriminant(_2);\n        switchInt(move _8) -> [1: bb1, 0: bb8, otherwise: bb4];\n    }\n    bb1: {\n        _9 = ((_2 as variant#1).0: &path::Path);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = os::unix::net::addr::sockaddr_un(_9) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _10 = <core::result::Result<(libc::sockaddr_un, u32), io::error::Error> as core::ops::Try>::branch(move _11) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_11);\n        _12 = discriminant(_10);\n        switchInt(move _12) -> [0: bb5, 1: bb6, otherwise: bb4];\n    }\n    bb4: {\n        unreachable;\n    }\n    bb5: {\n        StorageLive(_14);\n        _14 = ((_10 as variant#0).0: (libc::sockaddr_un, u32));\n        _7 = _14;\n        StorageDead(_14);\n        StorageDead(_10);\n        goto -> bb10;\n    }\n    bb6: {\n        _13 = move ((_10 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<usize, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_13) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_10);\n        StorageDead(_7);\n        goto -> bb19;\n    }\n    bb8: {\n        StorageLive(_15);\n        _15 = core::mem::zeroed::<libc::sockaddr_un>() -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        _7 = (move _15, 0_u32);\n        StorageDead(_15);\n        goto -> bb10;\n    }\n    bb10: {\n        StorageLive(_5);\n        _5 = (_7.0: libc::sockaddr_un);\n        _6 = (_7.1: u32);\n        StorageDead(_7);\n        StorageLive(_16);\n        _16 = core::mem::zeroed::<libc::msghdr>() -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageLive(_18);\n        _18 = &raw mut _5;\n        _17 = move _18 as *mut libc::c_void;\n        StorageDead(_18);\n        (_16.0: *mut libc::c_void) = _17;\n        (_16.1: u32) = _6;\n        StorageLive(_20);\n        _20 = core::slice::<impl [io::IoSlice<'_>]>::as_ptr(_3) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _19 = move _20 as *mut libc::iovec;\n        StorageDead(_20);\n        (_16.2: *mut libc::iovec) = _19;\n        _21 = PtrMetadata(_3);\n        (_16.3: usize) = _21;\n        _22 = ((*_4).1: usize);\n        (_16.5: usize) = _22;\n        StorageLive(_23);\n        StorageLive(_24);\n        _24 = (_16.5: usize);\n        _23 = Gt(move _24, 0_usize);\n        switchInt(move _23) -> [0: bb16, otherwise: bb13];\n    }\n    bb13: {\n        StorageDead(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _28 = ((*_4).0: &mut [u8]);\n        _26 = core::slice::<impl [u8]>::as_mut_ptr(_28) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        _25 = core::ptr::mut_ptr::<impl *mut u8>::cast::<libc::c_void>(move _26) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_26);\n        (_16.4: *mut libc::c_void) = move _25;\n        StorageDead(_25);\n        goto -> bb17;\n    }\n    bb16: {\n        StorageDead(_24);\n        goto -> bb17;\n    }\n    bb17: {\n        StorageDead(_23);\n        ((*_4).2: bool) = false;\n        _27 = &mut _16;\n        _0 = sys::net::connection::socket::unix::Socket::send_msg(_1, _27) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_16);\n        StorageDead(_5);\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}