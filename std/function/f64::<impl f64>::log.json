{
  "name": "f64::<impl f64>::log",
  "safe": true,
  "callees": {
    "f64::<impl f64>::ln": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the natural logarithm of the number.\n\n This returns NaN when the number is negative, and negative infinity when number is zero.\n\n # Unspecified precision\n\n The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\n can even differ within the same execution from one invocation to the next.\n\n # Examples\n\n ```\n let one = 1.0_f64;\n // e^1\n let e = one.exp();\n\n // ln(e) - 1 == 0\n let abs_difference = (e.ln() - 1.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n\n Non-positive values:\n ```\n assert_eq!(0_f64.ln(), f64::NEG_INFINITY);\n assert!((-42_f64).ln().is_nan());\n ```\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "std::f64::<impl f64>::log"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/num/f64.rs:507:5: 509:6",
  "src": "pub fn log(self, base: f64) -> f64 {\n        self.ln() / base.ln()\n    }",
  "mir": "fn f64::<impl f64>::log(_1: f64, _2: f64) -> f64 {\n    let mut _0: f64;\n    let mut _3: f64;\n    let mut _4: f64;\n    debug self => _1;\n    debug base => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = f64::<impl f64>::ln(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_4);\n        _4 = f64::<impl f64>::ln(_2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _0 = Div(move _3, move _4);\n        StorageDead(_4);\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Returns the logarithm of the number with respect to an arbitrary base.\n\n This returns NaN when the number is negative, and negative infinity when number is zero.\n\n The result might not be correctly rounded owing to implementation details;\n `self.log2()` can produce more accurate results for base 2, and\n `self.log10()` can produce more accurate results for base 10.\n\n # Unspecified precision\n\n The precision of this function is non-deterministic. This means it varies by platform, Rust version, and\n can even differ within the same execution from one invocation to the next.\n\n # Examples\n\n ```\n let twenty_five = 25.0_f64;\n\n // log5(25) - 2 == 0\n let abs_difference = (twenty_five.log(5.0) - 2.0).abs();\n\n assert!(abs_difference < 1e-10);\n ```\n\n Non-positive values:\n ```\n assert_eq!(0_f64.log(10.0), f64::NEG_INFINITY);\n assert!((-42_f64).log(10.0).is_nan());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}