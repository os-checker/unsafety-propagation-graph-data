{
  "name": "sys::pal::unix::pipe::read2",
  "safe": true,
  "callees": {
    "sys_common::IntoInner::into_inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::fd::unix::FileDesc::set_nonblocking": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fd::unix::FileDesc": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "os::fd::raw::AsRawFd::as_raw_fd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extracts the raw file descriptor.\n\n This function is typically used to **borrow** an owned file descriptor.\n When used in this way, this method does **not** pass ownership of the\n raw file descriptor to the caller, and the file descriptor is only\n guaranteed to be valid while the original object has not yet been\n destroyed.\n\n However, borrowing is not strictly required. See [`AsFd::as_fd`]\n for an API which strictly borrows a file descriptor.\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{AsRawFd, RawFd};\n\n let mut f = File::open(\"foo.txt\")?;\n // Note that `raw_fd` is only valid as long as `f` exists.\n #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.as_raw_fd();\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::cvt_r": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " `-1` → look at `errno` → retry on `EINTR`. Otherwise `Ok()`-wrap the closure return value.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "sys::pal::unix::pipe::read2::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fd::unix::FileDesc": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "alloc_crate::vec::Vec": "MutableAsArgument"
      }
    },
    "sys::fd::unix::FileDesc::read_to_end": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fd::unix::FileDesc": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "alloc_crate::vec::Vec": "MutableAsArgument"
      }
    },
    "core::result::Result::<T, E>::map": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n contained [`Ok`] value, leaving an [`Err`] value untouched.\n\n This function can be used to compose the results of two functions.\n\n # Examples\n\n Print the numbers on each line of a string multiplied by two.\n\n ```\n let line = \"1\\n2\\n3\\n4\\n\";\n\n for num in line.lines() {\n     match num.parse::<i32>().map(|i| i * 2) {\n         Ok(n) => println!(\"{n}\"),\n         Err(..) => {}\n     }\n }\n ```\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::pal::unix::pipe::AnonPipe": [
      "Plain"
    ],
    "sys::fd::unix::FileDesc": [
      "Plain",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 128, kind: RigidTy(Bool) })])"
    ],
    "alloc_crate::vec::Vec": [
      "MutRef"
    ]
  },
  "path": 3935,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/pipe.rs:107:1: 153:2",
  "src": "pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n    // Set both pipes into nonblocking mode as we're gonna be reading from both\n    // in the `select` loop below, and we wouldn't want one to block the other!\n    let p1 = p1.into_inner();\n    let p2 = p2.into_inner();\n    p1.set_nonblocking(true)?;\n    p2.set_nonblocking(true)?;\n\n    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n    fds[0].fd = p1.as_raw_fd();\n    fds[0].events = libc::POLLIN;\n    fds[1].fd = p2.as_raw_fd();\n    fds[1].events = libc::POLLIN;\n    loop {\n        // wait for either pipe to become readable using `poll`\n        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n\n        if fds[0].revents != 0 && read(&p1, v1)? {\n            p2.set_nonblocking(false)?;\n            return p2.read_to_end(v2).map(drop);\n        }\n        if fds[1].revents != 0 && read(&p2, v2)? {\n            p1.set_nonblocking(false)?;\n            return p1.read_to_end(v1).map(drop);\n        }\n    }\n\n    // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n    // EAGAIN. If we hit EOF, then this will happen because the underlying\n    // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n    // this case we flip the other fd back into blocking mode and read\n    // whatever's leftover on that file descriptor.\n    fn read(fd: &FileDesc, dst: &mut Vec<u8>) -> Result<bool, io::Error> {\n        match fd.read_to_end(dst) {\n            Ok(_) => Ok(true),\n            Err(e) => {\n                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n                    || e.raw_os_error() == Some(libc::EAGAIN)\n                {\n                    Ok(false)\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n}",
  "mir": "fn sys::pal::unix::pipe::read2(_1: sys::pal::unix::pipe::AnonPipe, _2: &mut alloc_crate::vec::Vec<u8>, _3: sys::pal::unix::pipe::AnonPipe, _4: &mut alloc_crate::vec::Vec<u8>) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let  _5: sys::fd::unix::FileDesc;\n    let  _6: sys::fd::unix::FileDesc;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _8: core::result::Result<(), io::error::Error>;\n    let mut _9: &sys::fd::unix::FileDesc;\n    let mut _10: isize;\n    let  _11: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _12: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _13: core::result::Result<(), io::error::Error>;\n    let mut _14: &sys::fd::unix::FileDesc;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _17: [libc::pollfd; 2];\n    let mut _18: i32;\n    let mut _19: &sys::fd::unix::FileDesc;\n    let  _20: usize;\n    let mut _21: bool;\n    let  _22: usize;\n    let mut _23: bool;\n    let mut _24: i32;\n    let mut _25: &sys::fd::unix::FileDesc;\n    let  _26: usize;\n    let mut _27: bool;\n    let  _28: usize;\n    let mut _29: bool;\n    let mut _30: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _31: core::result::Result<i32, io::error::Error>;\n    let mut _32: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/pipe.rs:122:15: 122:17};\n    let mut _33: &mut [libc::pollfd; 2];\n    let mut _34: isize;\n    let  _35: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _36: i32;\n    let mut _37: i16;\n    let  _38: usize;\n    let mut _39: bool;\n    let mut _40: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, bool>;\n    let mut _41: core::result::Result<bool, io::error::Error>;\n    let  _42: &sys::fd::unix::FileDesc;\n    let mut _43: isize;\n    let  _44: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _45: bool;\n    let mut _46: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _47: core::result::Result<(), io::error::Error>;\n    let mut _48: &sys::fd::unix::FileDesc;\n    let mut _49: isize;\n    let  _50: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _51: core::result::Result<usize, io::error::Error>;\n    let mut _52: &sys::fd::unix::FileDesc;\n    let mut _53: i16;\n    let  _54: usize;\n    let mut _55: bool;\n    let mut _56: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, bool>;\n    let mut _57: core::result::Result<bool, io::error::Error>;\n    let  _58: &sys::fd::unix::FileDesc;\n    let mut _59: isize;\n    let  _60: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _61: bool;\n    let mut _62: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _63: core::result::Result<(), io::error::Error>;\n    let mut _64: &sys::fd::unix::FileDesc;\n    let mut _65: isize;\n    let  _66: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _67: core::result::Result<usize, io::error::Error>;\n    let mut _68: &sys::fd::unix::FileDesc;\n    debug p1 => _1;\n    debug v1 => _2;\n    debug p2 => _3;\n    debug v2 => _4;\n    debug p1 => _5;\n    debug p2 => _6;\n    debug residual => _11;\n    debug val => ();\n    debug residual => _16;\n    debug val => ();\n    debug fds => _17;\n    debug residual => _35;\n    debug val => _36;\n    debug residual => _44;\n    debug val => _45;\n    debug residual => _50;\n    debug val => ();\n    debug residual => _60;\n    debug val => _61;\n    debug residual => _66;\n    debug val => ();\n    bb0: {\n        StorageLive(_5);\n        _5 = <sys::pal::unix::pipe::AnonPipe as sys_common::IntoInner<sys::fd::unix::FileDesc>>::into_inner(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        _6 = <sys::pal::unix::pipe::AnonPipe as sys_common::IntoInner<sys::fd::unix::FileDesc>>::into_inner(_3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &_5;\n        _8 = sys::fd::unix::FileDesc::set_nonblocking(move _9, true) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_9);\n        _7 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _10 = discriminant(_7);\n        switchInt(move _10) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageDead(_7);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = &_6;\n        _13 = sys::fd::unix::FileDesc::set_nonblocking(move _14, true) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _11 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_11) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_7);\n        goto -> bb62;\n    }\n    bb9: {\n        StorageDead(_14);\n        _12 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_13);\n        _15 = discriminant(_12);\n        switchInt(move _15) -> [0: bb11, 1: bb12, otherwise: bb5];\n    }\n    bb11: {\n        StorageDead(_12);\n        StorageLive(_17);\n        _17 = core::mem::zeroed::<[libc::pollfd; 2]>() -> [return: bb14, unwind unreachable];\n    }\n    bb12: {\n        _16 = move ((_12 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_12);\n        goto -> bb62;\n    }\n    bb14: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &_5;\n        _18 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        StorageLive(_20);\n        _20 = 0_usize;\n        _21 = Lt(_20, 2_usize);\n        assert(move _21, \"index out of bounds: the length is {} but the index is {}\", 2_usize, _20) -> [success: bb16, unwind unreachable];\n    }\n    bb16: {\n        (_17[_20].0: i32) = move _18;\n        StorageDead(_18);\n        StorageDead(_20);\n        StorageLive(_22);\n        _22 = 0_usize;\n        _23 = Lt(_22, 2_usize);\n        assert(move _23, \"index out of bounds: the length is {} but the index is {}\", 2_usize, _22) -> [success: bb17, unwind unreachable];\n    }\n    bb17: {\n        (_17[_22].1: i16) = libc::POLLIN;\n        StorageDead(_22);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = &_6;\n        _24 = <sys::fd::unix::FileDesc as os::fd::raw::AsRawFd>::as_raw_fd(move _25) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_25);\n        StorageLive(_26);\n        _26 = 1_usize;\n        _27 = Lt(_26, 2_usize);\n        assert(move _27, \"index out of bounds: the length is {} but the index is {}\", 2_usize, _26) -> [success: bb19, unwind unreachable];\n    }\n    bb19: {\n        (_17[_26].0: i32) = move _24;\n        StorageDead(_24);\n        StorageDead(_26);\n        StorageLive(_28);\n        _28 = 1_usize;\n        _29 = Lt(_28, 2_usize);\n        assert(move _29, \"index out of bounds: the length is {} but the index is {}\", 2_usize, _28) -> [success: bb20, unwind unreachable];\n    }\n    bb20: {\n        (_17[_28].1: i16) = libc::POLLIN;\n        StorageDead(_28);\n        goto -> bb21;\n    }\n    bb21: {\n        StorageLive(_30);\n        StorageLive(_31);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = &mut _17;\n        _32 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/pipe.rs:122:15: 122:17}(move _33);\n        StorageDead(_33);\n        _31 = sys::pal::unix::cvt_r::<i32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/pipe.rs:122:15: 122:17}>(move _32) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_32);\n        _30 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _31) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_31);\n        _34 = discriminant(_30);\n        switchInt(move _34) -> [0: bb24, 1: bb25, otherwise: bb5];\n    }\n    bb24: {\n        StorageLive(_36);\n        _36 = ((_30 as variant#0).0: i32);\n        StorageDead(_36);\n        StorageDead(_30);\n        StorageLive(_37);\n        StorageLive(_38);\n        _38 = 0_usize;\n        _39 = Lt(_38, 2_usize);\n        assert(move _39, \"index out of bounds: the length is {} but the index is {}\", 2_usize, _38) -> [success: bb27, unwind unreachable];\n    }\n    bb25: {\n        _35 = move ((_30 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_35) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        StorageDead(_30);\n        goto -> bb61;\n    }\n    bb27: {\n        _37 = (_17[_38].2: i16);\n        switchInt(move _37) -> [0: bb41, otherwise: bb28];\n    }\n    bb28: {\n        StorageDead(_38);\n        StorageDead(_37);\n        StorageLive(_40);\n        StorageLive(_41);\n        _42 = &_5;\n        _41 = sys::pal::unix::pipe::read2::read(_42, _2) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        _40 = <core::result::Result<bool, io::error::Error> as core::ops::Try>::branch(move _41) -> [return: bb30, unwind unreachable];\n    }\n    bb30: {\n        StorageDead(_41);\n        _43 = discriminant(_40);\n        switchInt(move _43) -> [0: bb31, 1: bb32, otherwise: bb5];\n    }\n    bb31: {\n        _45 = ((_40 as variant#0).0: bool);\n        switchInt(_45) -> [0: bb66, otherwise: bb65];\n    }\n    bb32: {\n        _44 = move ((_40 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_44) -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageDead(_40);\n        goto -> bb60;\n    }\n    bb34: {\n        StorageDead(_48);\n        _46 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _47) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_47);\n        _49 = discriminant(_46);\n        switchInt(move _49) -> [0: bb36, 1: bb37, otherwise: bb5];\n    }\n    bb36: {\n        StorageDead(_46);\n        StorageLive(_51);\n        StorageLive(_52);\n        _52 = &_6;\n        _51 = sys::fd::unix::FileDesc::read_to_end(move _52, _4) -> [return: bb39, unwind unreachable];\n    }\n    bb37: {\n        _50 = move ((_46 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_50) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_46);\n        goto -> bb60;\n    }\n    bb39: {\n        StorageDead(_52);\n        _0 = core::result::Result::<usize, io::error::Error>::map::<(), fn(usize) {core::mem::drop::<usize>}>(move _51, core::mem::drop::<usize>) -> [return: bb40, unwind unreachable];\n    }\n    bb40: {\n        StorageDead(_51);\n        goto -> bb60;\n    }\n    bb41: {\n        StorageDead(_38);\n        StorageDead(_37);\n        goto -> bb42;\n    }\n    bb42: {\n        StorageLive(_53);\n        StorageLive(_54);\n        _54 = 1_usize;\n        _55 = Lt(_54, 2_usize);\n        assert(move _55, \"index out of bounds: the length is {} but the index is {}\", 2_usize, _54) -> [success: bb43, unwind unreachable];\n    }\n    bb43: {\n        _53 = (_17[_54].2: i16);\n        switchInt(move _53) -> [0: bb57, otherwise: bb44];\n    }\n    bb44: {\n        StorageDead(_54);\n        StorageDead(_53);\n        StorageLive(_56);\n        StorageLive(_57);\n        _58 = &_6;\n        _57 = sys::pal::unix::pipe::read2::read(_58, _4) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        _56 = <core::result::Result<bool, io::error::Error> as core::ops::Try>::branch(move _57) -> [return: bb46, unwind unreachable];\n    }\n    bb46: {\n        StorageDead(_57);\n        _59 = discriminant(_56);\n        switchInt(move _59) -> [0: bb47, 1: bb48, otherwise: bb5];\n    }\n    bb47: {\n        _61 = ((_56 as variant#0).0: bool);\n        switchInt(_61) -> [0: bb68, otherwise: bb67];\n    }\n    bb48: {\n        _60 = move ((_56 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_60) -> [return: bb49, unwind unreachable];\n    }\n    bb49: {\n        StorageDead(_56);\n        goto -> bb59;\n    }\n    bb50: {\n        StorageDead(_64);\n        _62 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _63) -> [return: bb51, unwind unreachable];\n    }\n    bb51: {\n        StorageDead(_63);\n        _65 = discriminant(_62);\n        switchInt(move _65) -> [0: bb52, 1: bb53, otherwise: bb5];\n    }\n    bb52: {\n        StorageDead(_62);\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = &_5;\n        _67 = sys::fd::unix::FileDesc::read_to_end(move _68, _2) -> [return: bb55, unwind unreachable];\n    }\n    bb53: {\n        _66 = move ((_62 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_66) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        StorageDead(_62);\n        goto -> bb59;\n    }\n    bb55: {\n        StorageDead(_68);\n        _0 = core::result::Result::<usize, io::error::Error>::map::<(), fn(usize) {core::mem::drop::<usize>}>(move _67, core::mem::drop::<usize>) -> [return: bb56, unwind unreachable];\n    }\n    bb56: {\n        StorageDead(_67);\n        goto -> bb59;\n    }\n    bb57: {\n        StorageDead(_54);\n        StorageDead(_53);\n        goto -> bb58;\n    }\n    bb58: {\n        goto -> bb21;\n    }\n    bb59: {\n        goto -> bb61;\n    }\n    bb60: {\n        goto -> bb61;\n    }\n    bb61: {\n        StorageDead(_17);\n        goto -> bb62;\n    }\n    bb62: {\n        drop(_6) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_6);\n        drop(_5) -> [return: bb64, unwind unreachable];\n    }\n    bb64: {\n        StorageDead(_5);\n        return;\n    }\n    bb65: {\n        StorageDead(_40);\n        StorageLive(_46);\n        StorageLive(_47);\n        StorageLive(_48);\n        _48 = &_6;\n        _47 = sys::fd::unix::FileDesc::set_nonblocking(move _48, false) -> [return: bb34, unwind unreachable];\n    }\n    bb66: {\n        StorageDead(_40);\n        goto -> bb42;\n    }\n    bb67: {\n        StorageDead(_56);\n        StorageLive(_62);\n        StorageLive(_63);\n        StorageLive(_64);\n        _64 = &_5;\n        _63 = sys::fd::unix::FileDesc::set_nonblocking(move _64, false) -> [return: bb50, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_56);\n        goto -> bb58;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}