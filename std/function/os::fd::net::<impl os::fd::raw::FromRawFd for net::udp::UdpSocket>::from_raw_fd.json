{
  "name": "os::fd::net::<impl os::fd::raw::FromRawFd for net::udp::UdpSocket>::from_raw_fd",
  "safe": false,
  "callees": {
    "os::fd::raw::FromRawFd::from_raw_fd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new instance of `Self` from the given raw file\n descriptor.\n\n This function is typically used to **consume ownership** of the\n specified file descriptor. When used in this way, the returned object\n will take responsibility for closing it when the object goes out of\n scope.\n\n However, consuming ownership is not strictly required. Use a\n [`From<OwnedFd>::from`] implementation for an API which strictly\n consumes ownership.\n\n # Safety\n\n The `fd` passed in must be an [owned file descriptor][io-safety];\n in particular, it must be open.\n\n [io-safety]: io#io-safety\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{FromRawFd, IntoRawFd, RawFd};\n\n let f = File::open(\"foo.txt\")?;\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.into_raw_fd();\n // SAFETY: no other functions should call `from_raw_fd`, so there\n // is only one owner for the file descriptor.\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let f = unsafe { File::from_raw_fd(raw_fd) };\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    },
    "sys_common::FromInner::from_inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    }
  },
  "adts": {
    "os::fd::owned::OwnedFd": [
      "Plain"
    ],
    "sys::fd::unix::FileDesc": [
      "Plain"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Plain"
    ],
    "sys::net::connection::socket::UdpSocket": [
      "Plain"
    ],
    "net::udp::UdpSocket": [
      "Plain"
    ]
  },
  "path": 1970,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/fd/net.rs:24:13: 29:14",
  "src": "unsafe fn from_raw_fd(fd: RawFd) -> net::$t {\n                unsafe {\n                    let socket = sys::net::Socket::from_inner(FromInner::from_inner(OwnedFd::from_raw_fd(fd)));\n                    net::$t::from_inner(sys::net::$t::from_inner(socket))\n                }\n            }",
  "mir": "fn os::fd::net::<impl os::fd::raw::FromRawFd for net::udp::UdpSocket>::from_raw_fd(_1: i32) -> net::udp::UdpSocket {\n    let mut _0: net::udp::UdpSocket;\n    let  _2: sys::net::connection::socket::unix::Socket;\n    let mut _3: sys::fd::unix::FileDesc;\n    let mut _4: os::fd::owned::OwnedFd;\n    let mut _5: sys::net::connection::socket::UdpSocket;\n    debug fd => _1;\n    debug socket => _2;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = <os::fd::owned::OwnedFd as os::fd::raw::FromRawFd>::from_raw_fd(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = <sys::fd::unix::FileDesc as sys_common::FromInner<os::fd::owned::OwnedFd>>::from_inner(move _4) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _2 = <sys::net::connection::socket::unix::Socket as sys_common::FromInner<sys::fd::unix::FileDesc>>::from_inner(move _3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_3);\n        StorageLive(_5);\n        _5 = <sys::net::connection::socket::UdpSocket as sys_common::FromInner<sys::net::connection::socket::unix::Socket>>::from_inner(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _0 = <net::udp::UdpSocket as sys_common::FromInner<sys::net::connection::socket::UdpSocket>>::from_inner(move _5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_5);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}