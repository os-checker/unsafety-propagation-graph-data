{
  "name": "os::unix::process::CommandExt::before_exec",
  "safe": false,
  "callees": {
    "os::unix::process::CommandExt::pre_exec": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Schedules a closure to be run just before the `exec` function is\n invoked.\n\n The closure is allowed to return an I/O error whose OS error code will\n be communicated back to the parent and returned as an error from when\n the spawn was requested.\n\n Multiple closures can be registered and they will be called in order of\n their registration. If a closure returns `Err` then no further closures\n will be called and the spawn operation will immediately return with a\n failure.\n\n # Notes and Safety\n\n This closure will be run in the context of the child process after a\n `fork`. This primarily means that any modifications made to memory on\n behalf of this closure will **not** be visible to the parent process.\n This is often a very constrained environment where normal operations\n like `malloc`, accessing environment variables through [`std::env`]\n or acquiring a mutex are not guaranteed to work (due to\n other threads perhaps still running when the `fork` was run).\n\n Note that the list of allocating functions includes [`Error::new`] and\n [`Error::other`]. To signal a non-trivial error, prefer [`panic!`].\n\n For further details refer to the [POSIX fork() specification]\n and the equivalent documentation for any targeted\n platform, especially the requirements around *async-signal-safety*.\n\n This also means that all resources such as file descriptors and\n memory-mapped regions got duplicated. It is your responsibility to make\n sure that the closure does not violate library invariants by making\n invalid use of these duplicates.\n\n Panicking in the closure is safe only if all the format arguments for the\n panic message can be safely formatted; this is because although\n `Command` calls [`std::panic::always_abort`](crate::panic::always_abort)\n before calling the pre_exec hook, panic will still try to format the\n panic message.\n\n When this closure is run, aspects such as the stdio file descriptors and\n working directory have successfully been changed, so output to these\n locations might not appear where intended.\n\n [POSIX fork() specification]:\n     https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html\n [`std::env`]: mod@crate::env\n [`Error::new`]: crate::io::Error::new\n [`Error::other`]: crate::io::Error::other\n",
      "adt": {}
    }
  },
  "adts": {
    "process::Command": [
      "MutRef"
    ]
  },
  "path": {
    "type": "External",
    "path": "os::unix::process::CommandExt::before_exec"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/process.rs:128:5: 133:6",
  "src": "unsafe fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n    where\n        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n    {\n        unsafe { self.pre_exec(f) }\n    }",
  "mir": "fn os::unix::process::CommandExt::before_exec(_1: &mut Self, _2: F) -> &mut process::Command {\n    let mut _0: &mut process::Command;\n    debug self => _1;\n    debug f => _2;\n    bb0: {\n        _0 = <Self as os::unix::process::CommandExt>::pre_exec::<F>(_1, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        return;\n    }\n}\n",
  "doc": " Schedules a closure to be run just before the `exec` function is\n invoked.\n\n `before_exec` used to be a safe method, but it needs to be unsafe since the closure may only\n perform operations that are *async-signal-safe*. Hence it got deprecated in favor of the\n unsafe [`pre_exec`]. Meanwhile, Rust gained the ability to make an existing safe method\n fully unsafe in a new edition, which is how `before_exec` became `unsafe`. It still also\n remains deprecated; `pre_exec` should be used instead.\n\n [`pre_exec`]: CommandExt::pre_exec\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}