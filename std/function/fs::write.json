{
  "name": "fs::write",
  "safe": true,
  "callees": {
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "fs::write::inner": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 1077,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/fs.rs:383:1: 388:2",
  "src": "pub fn write<P: AsRef<Path>, C: AsRef<[u8]>>(path: P, contents: C) -> io::Result<()> {\n    fn inner(path: &Path, contents: &[u8]) -> io::Result<()> {\n        File::create(path)?.write_all(contents)\n    }\n    inner(path.as_ref(), contents.as_ref())\n}",
  "mir": "fn fs::write(_1: P, _2: C) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let  _3: &path::Path;\n    let mut _4: &P;\n    let  _5: &[u8];\n    let mut _6: &C;\n    debug path => _1;\n    debug contents => _2;\n    bb0: {\n        StorageLive(_4);\n        _4 = &_1;\n        _3 = <P as core::convert::AsRef<path::Path>>::as_ref(move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_6);\n        _6 = &_2;\n        _5 = <C as core::convert::AsRef<[u8]>>::as_ref(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_6);\n        _0 = fs::write::inner(_3, _5) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        drop(_2) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        drop(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        return;\n    }\n}\n",
  "doc": " Writes a slice as the entire contents of a file.\n\n This function will create a file if it does not exist,\n and will entirely replace its contents if it does.\n\n Depending on the platform, this function may fail if the\n full directory path does not exist.\n\n This is a convenience function for using [`File::create`] and [`write_all`]\n with fewer imports.\n\n [`write_all`]: Write::write_all\n\n # Examples\n\n ```no_run\n use std::fs;\n\n fn main() -> std::io::Result<()> {\n     fs::write(\"foo.txt\", b\"Lorem ipsum\")?;\n     fs::write(\"bar.txt\", \"dolor sit\")?;\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}