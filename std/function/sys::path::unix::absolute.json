{
  "name": "sys::path::unix::absolute",
  "safe": true,
  "callees": {
    "path::Path::strip_prefix": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a path that, when joined onto `base`, yields `self`.\n\n # Errors\n\n If `base` is not a prefix of `self` (i.e., [`starts_with`]\n returns `false`), returns [`Err`].\n\n [`starts_with`]: Path::starts_with\n\n # Examples\n\n ```\n use std::path::{Path, PathBuf};\n\n let path = Path::new(\"/test/haha/foo.txt\");\n\n assert_eq!(path.strip_prefix(\"/\"), Ok(Path::new(\"test/haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test\"), Ok(Path::new(\"haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n\n assert!(path.strip_prefix(\"test\").is_err());\n assert!(path.strip_prefix(\"/te\").is_err());\n assert!(path.strip_prefix(\"/haha\").is_err());\n\n let prefix = PathBuf::from(\"/test/\");\n assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::result::Result::<T, E>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Result::unwrap_or_else\n\n # Examples\n\n ```\n let default = 2;\n let x: Result<u32, &str> = Ok(9);\n assert_eq!(x.unwrap_or(default), 9);\n\n let x: Result<u32, &str> = Err(\"error\");\n assert_eq!(x.unwrap_or(default), default);\n ```\n",
      "adt": {}
    },
    "path::Path::components": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Produces an iterator over the [`Component`]s of the path.\n\n When parsing the path, there is a small amount of normalization:\n\n * Repeated separators are ignored, so `a/b` and `a//b` both have\n   `a` and `b` as components.\n\n * Occurrences of `.` are normalized away, except if they are at the\n   beginning of the path. For example, `a/./b`, `a/b/`, `a/b/.` and\n   `a/b` all have `a` and `b` as components, but `./a/b` starts with\n   an additional [`CurDir`] component.\n\n * Trailing separators are normalized away, so `/a/b` and `/a/b/` are equivalent.\n\n Note that no other normalization takes place; in particular, `a/c`\n and `a/b/../c` are distinct, to account for the possibility that `b`\n is a symbolic link (so its parent isn't `a`).\n\n # Examples\n\n ```\n use std::path::{Path, Component};\n use std::ffi::OsStr;\n\n let mut components = Path::new(\"/tmp/foo.txt\").components();\n\n assert_eq!(components.next(), Some(Component::RootDir));\n assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"tmp\"))));\n assert_eq!(components.next(), Some(Component::Normal(OsStr::new(\"foo.txt\"))));\n assert_eq!(components.next(), None)\n ```\n\n [`CurDir`]: Component::CurDir\n",
      "adt": {
        "path::Path": "ImmutableAsArgument",
        "path::Components": "Constructor"
      }
    },
    "path::Path::as_os_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields the underlying [`OsStr`] slice.\n\n # Examples\n\n ```\n use std::path::Path;\n\n let os_str = Path::new(\"foo.txt\").as_os_str();\n assert_eq!(os_str, std::ffi::OsStr::new(\"foo.txt\"));\n ```\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "ffi::os_str::OsStr::as_encoded_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts an OS string slice to a byte slice.  To convert the byte slice back into an OS\n string slice, use the [`OsStr::from_encoded_bytes_unchecked`] function.\n\n The byte encoding is an unspecified, platform-specific, self-synchronizing superset of UTF-8.\n By being a self-synchronizing superset of UTF-8, this encoding is also a superset of 7-bit\n ASCII.\n\n Note: As the encoding is unspecified, any sub-slice of bytes that is not valid UTF-8 should\n be treated as opaque and only comparable within the same Rust version built for the same\n target platform.  For example, sending the slice over the network or storing it in a file\n will likely result in incompatible byte slices.  See [`OsString`] for more encoding details\n and [`std::ffi`] for platform-specific, specified conversions.\n\n [`std::ffi`]: crate::ffi\n",
      "adt": {
        "ffi::os_str::OsStr": "ImmutableAsArgument"
      }
    },
    "path::Path::is_absolute": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "deprecated"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* deprecated\n"
        ]
      },
      "doc": " Returns `true` if the `Path` is absolute, i.e., if it is independent of\n the current directory.\n\n * On Unix, a path is absolute if it starts with the root, so\n `is_absolute` and [`has_root`] are equivalent.\n\n * On Windows, a path is absolute if it has a prefix and starts with the\n root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not.\n\n # Examples\n\n ```\n use std::path::Path;\n\n assert!(!Path::new(\"foo.txt\").is_absolute());\n ```\n\n [`has_root`]: Path::has_root\n",
      "adt": {
        "path::Path": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::starts_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `needle` is a prefix of the slice or equal to the slice.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert!(v.starts_with(&[10]));\n assert!(v.starts_with(&[10, 40]));\n assert!(v.starts_with(&v));\n assert!(!v.starts_with(&[50]));\n assert!(!v.starts_with(&[10, 50]));\n ```\n\n Always returns `true` if `needle` is an empty slice:\n\n ```\n let v = &[10, 40, 30];\n assert!(v.starts_with(&[]));\n let v: &[u8] = &[];\n assert!(v.starts_with(&[]));\n ```\n",
      "adt": {}
    },
    "core::iter::Iterator::next": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Advances the iterator and returns the next value.\n\n Returns [`None`] when iteration is finished. Individual iterator\n implementations may choose to resume iteration, and so calling `next()`\n again may or may not eventually start returning [`Some(Item)`] again at some\n point.\n\n [`Some(Item)`]: Some\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n\n let mut iter = a.into_iter();\n\n // A call to next() returns the next value...\n assert_eq!(Some(1), iter.next());\n assert_eq!(Some(2), iter.next());\n assert_eq!(Some(3), iter.next());\n\n // ... and then None once it's over.\n assert_eq!(None, iter.next());\n\n // More calls may or may not return `None`. Here, they always will.\n assert_eq!(None, iter.next());\n assert_eq!(None, iter.next());\n ```\n",
      "adt": {}
    },
    "core::convert::From::from": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts to this type from the input type.\n",
      "adt": {}
    },
    "path::PathBuf::new": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Allocates an empty `PathBuf`.\n\n # Examples\n\n ```\n use std::path::PathBuf;\n\n let path = PathBuf::new();\n ```\n",
      "adt": {
        "path::PathBuf": "Constructor"
      }
    },
    "env::current_dir": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the current working directory as a [`PathBuf`].\n\n # Platform-specific behavior\n\n This function [currently] corresponds to the `getcwd` function on Unix\n and the `GetCurrentDirectoryW` function on Windows.\n\n [currently]: crate::io#platform-specific-behavior\n\n # Errors\n\n Returns an [`Err`] if the current working directory value is invalid.\n Possible cases:\n\n * Current directory does not exist.\n * There are insufficient permissions to access the current directory.\n\n # Examples\n\n ```\n use std::env;\n\n fn main() -> std::io::Result<()> {\n     let path = env::current_dir()?;\n     println!(\"The current directory is {}\", path.display());\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor",
        "path::PathBuf": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::iter::Extend::extend": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends a collection with the contents of an iterator.\n\n As this is the only required method for this trait, the [trait-level] docs\n contain more details.\n\n [trait-level]: Extend\n\n # Examples\n\n ```\n // You can extend a String with some chars:\n let mut message = String::from(\"abc\");\n\n message.extend(['d', 'e', 'f'].iter());\n\n assert_eq!(\"abcdef\", &message);\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::ends_with": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if `needle` is a suffix of the slice or equal to the slice.\n\n # Examples\n\n ```\n let v = [10, 40, 30];\n assert!(v.ends_with(&[30]));\n assert!(v.ends_with(&[40, 30]));\n assert!(v.ends_with(&v));\n assert!(!v.ends_with(&[50]));\n assert!(!v.ends_with(&[50, 30]));\n ```\n\n Always returns `true` if `needle` is an empty slice:\n\n ```\n let v = &[10, 40, 30];\n assert!(v.ends_with(&[]));\n let v: &[u8] = &[];\n assert!(v.ends_with(&[]));\n ```\n",
      "adt": {}
    },
    "path::PathBuf::push": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Extends `self` with `path`.\n\n If `path` is absolute, it replaces the current path.\n\n On Windows:\n\n * if `path` has a root but no prefix (e.g., `\\windows`), it\n   replaces everything except for the prefix (if any) of `self`.\n * if `path` has a prefix but no root, it replaces `self`.\n * if `self` has a verbatim prefix (e.g. `\\\\?\\C:\\windows`)\n   and `path` is not empty, the new path is normalized: all references\n   to `.` and `..` are removed.\n\n Consider using [`Path::join`] if you need a new `PathBuf` instead of\n using this function on a cloned `PathBuf`.\n\n # Examples\n\n Pushing a relative path extends the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"file.bk\");\n assert_eq!(path, PathBuf::from(\"/tmp/file.bk\"));\n ```\n\n Pushing an absolute path replaces the existing path:\n\n ```\n use std::path::PathBuf;\n\n let mut path = PathBuf::from(\"/tmp\");\n path.push(\"/etc\");\n assert_eq!(path, PathBuf::from(\"/etc\"));\n ```\n",
      "adt": {
        "path::PathBuf": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "path::Path": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "path::Components": [
      "Plain",
      "MutRef"
    ],
    "ffi::os_str::OsStr": [
      "Ref"
    ],
    "core::option::Option": [
      "Plain"
    ],
    "path::PathBuf": [
      "Plain",
      "MutRef"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1226, kind: RigidTy(Adt(AdtDef(DefId { id: 5561, name: \"path::PathBuf\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ]
  },
  "path": 4050,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/path/unix.rs:25:1: 63:2",
  "src": "pub(crate) fn absolute(path: &Path) -> io::Result<PathBuf> {\n    // This is mostly a wrapper around collecting `Path::components`, with\n    // exceptions made where this conflicts with the POSIX specification.\n    // See 4.13 Pathname Resolution, IEEE Std 1003.1-2017\n    // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13\n\n    // Get the components, skipping the redundant leading \".\" component if it exists.\n    let mut components = path.strip_prefix(\".\").unwrap_or(path).components();\n    let path_os = path.as_os_str().as_encoded_bytes();\n\n    let mut normalized = if path.is_absolute() {\n        // \"If a pathname begins with two successive <slash> characters, the\n        // first component following the leading <slash> characters may be\n        // interpreted in an implementation-defined manner, although more than\n        // two leading <slash> characters shall be treated as a single <slash>\n        // character.\"\n        if path_os.starts_with(b\"//\") && !path_os.starts_with(b\"///\") {\n            components.next();\n            PathBuf::from(\"//\")\n        } else {\n            PathBuf::new()\n        }\n    } else {\n        env::current_dir()?\n    };\n    normalized.extend(components);\n\n    // \"Interfaces using pathname resolution may specify additional constraints\n    // when a pathname that does not name an existing directory contains at\n    // least one non- <slash> character and contains one or more trailing\n    // <slash> characters\".\n    // A trailing <slash> is also meaningful if \"a symbolic link is\n    // encountered during pathname resolution\".\n    if path_os.ends_with(b\"/\") {\n        normalized.push(\"\");\n    }\n\n    Ok(normalized)\n}",
  "mir": "fn sys::path::unix::absolute(_1: &path::Path) -> core::result::Result<path::PathBuf, io::error::Error> {\n    let mut _0: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _2: path::Components<'_>;\n    let  _3: &path::Path;\n    let mut _4: core::result::Result<&path::Path, path::StripPrefixError>;\n    let  _5: &[u8];\n    let  _6: &ffi::os_str::OsStr;\n    let mut _7: path::PathBuf;\n    let mut _8: bool;\n    let mut _9: bool;\n    let mut _10: &[u8];\n    let mut _11: &[u8; 2];\n    let mut _12: bool;\n    let mut _13: &[u8];\n    let mut _14: &[u8; 3];\n    let  _15: core::option::Option<path::Component<'_>>;\n    let mut _16: &mut path::Components<'_>;\n    let mut _17: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, path::PathBuf>;\n    let mut _18: core::result::Result<path::PathBuf, io::error::Error>;\n    let mut _19: isize;\n    let  _20: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _21: path::PathBuf;\n    let  _22: ();\n    let mut _23: &mut path::PathBuf;\n    let mut _24: path::Components<'_>;\n    let mut _25: bool;\n    let mut _26: &[u8];\n    let mut _27: &[u8; 1];\n    let  _28: ();\n    let mut _29: &mut path::PathBuf;\n    let mut _30: path::PathBuf;\n    debug path => _1;\n    debug components => _2;\n    debug path_os => _5;\n    debug normalized => _7;\n    debug residual => _20;\n    debug val => _21;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_4);\n        _4 = path::Path::strip_prefix::<&str>(_1, \".\") -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _3 = core::result::Result::<&path::Path, path::StripPrefixError>::unwrap_or(move _4, _1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_4);\n        _2 = path::Path::components(_3) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = path::Path::as_os_str(_1) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _5 = ffi::os_str::OsStr::as_encoded_bytes(_6) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = path::Path::is_absolute(_1) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        switchInt(move _8) -> [0: bb17, otherwise: bb7];\n    }\n    bb7: {\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = b\"//\";\n        _10 = move _11 as &[u8];\n        StorageDead(_11);\n        _9 = core::slice::<impl [u8]>::starts_with(_5, move _10) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        switchInt(move _9) -> [0: bb14, otherwise: bb9];\n    }\n    bb9: {\n        StorageDead(_10);\n        StorageLive(_12);\n        StorageLive(_13);\n        StorageLive(_14);\n        _14 = b\"///\";\n        _13 = move _14 as &[u8];\n        StorageDead(_14);\n        _12 = core::slice::<impl [u8]>::starts_with(_5, move _13) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        switchInt(move _12) -> [0: bb12, otherwise: bb11];\n    }\n    bb11: {\n        StorageDead(_13);\n        goto -> bb15;\n    }\n    bb12: {\n        StorageDead(_13);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &mut _2;\n        _15 = <path::Components<'_> as core::iter::Iterator>::next(move _16) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_16);\n        StorageDead(_15);\n        _7 = <path::PathBuf as core::convert::From<&str>>::from(\"//\") -> [return: bb16, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_10);\n        goto -> bb15;\n    }\n    bb15: {\n        _7 = path::PathBuf::new() -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_12);\n        StorageDead(_9);\n        goto -> bb24;\n    }\n    bb17: {\n        StorageLive(_17);\n        StorageLive(_18);\n        _18 = env::current_dir() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _17 = <core::result::Result<path::PathBuf, io::error::Error> as core::ops::Try>::branch(move _18) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_18);\n        _19 = discriminant(_17);\n        switchInt(move _19) -> [0: bb21, 1: bb22, otherwise: bb20];\n    }\n    bb20: {\n        unreachable;\n    }\n    bb21: {\n        StorageLive(_21);\n        _21 = move ((_17 as variant#0).0: path::PathBuf);\n        _7 = move _21;\n        StorageDead(_21);\n        StorageDead(_17);\n        goto -> bb24;\n    }\n    bb22: {\n        _20 = move ((_17 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<path::PathBuf, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_20) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        StorageDead(_17);\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_2);\n        goto -> bb31;\n    }\n    bb24: {\n        StorageDead(_8);\n        StorageLive(_23);\n        _23 = &mut _7;\n        StorageLive(_24);\n        _24 = move _2;\n        _22 = <path::PathBuf as core::iter::Extend<path::Component<'_>>>::extend::<path::Components<'_>>(move _23, move _24) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageLive(_25);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = b\"/\";\n        _26 = move _27 as &[u8];\n        StorageDead(_27);\n        _25 = core::slice::<impl [u8]>::ends_with(_5, move _26) -> [return: bb26, unwind unreachable];\n    }\n    bb26: {\n        switchInt(move _25) -> [0: bb29, otherwise: bb27];\n    }\n    bb27: {\n        StorageDead(_26);\n        StorageLive(_29);\n        _29 = &mut _7;\n        _28 = path::PathBuf::push::<&str>(move _29, \"\") -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_29);\n        goto -> bb30;\n    }\n    bb29: {\n        StorageDead(_26);\n        goto -> bb30;\n    }\n    bb30: {\n        StorageDead(_25);\n        StorageLive(_30);\n        _30 = move _7;\n        _0 = core::result::Result::Ok(move _30);\n        StorageDead(_30);\n        StorageDead(_7);\n        StorageDead(_2);\n        goto -> bb31;\n    }\n    bb31: {\n        return;\n    }\n}\n",
  "doc": " Make a POSIX path absolute without changing its semantics.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}