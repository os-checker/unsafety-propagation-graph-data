{
  "name": "os::unix::net::listener::UnixListener::accept",
  "safe": true,
  "callees": {
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "core::mem::size_of_val": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the size of the pointed-to value in bytes.\n\n This is usually the same as [`size_of::<T>()`]. However, when `T` *has* no\n statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n then `size_of_val` can be used to get the dynamically-known size.\n\n [trait object]: ../../book/ch17-02-trait-objects.html\n\n # Examples\n\n ```\n assert_eq!(4, size_of_val(&5i32));\n\n let x: [u8; 13] = [0; 13];\n let y: &[u8] = &x;\n assert_eq!(13, size_of_val(y));\n ```\n\n [`size_of::<T>()`]: size_of\n",
      "adt": {}
    },
    "sys::net::connection::socket::unix::Socket::accept": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::net::connection::socket::unix::Socket": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "os::unix::net::addr::SocketAddr::from_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::result::Result": "Constructor",
        "os::unix::net::addr::SocketAddr": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "libc::sockaddr_un": [
      "Plain",
      "Ref"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Ref",
      "Plain"
    ],
    "os::unix::net::listener::UnixListener": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8202, kind: RigidTy(Adt(AdtDef(DefId { id: 8147, name: \"sys::net::connection::socket::unix::Socket\" }), GenericArgs([]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8141, kind: RigidTy(Adt(AdtDef(DefId { id: 8110, name: \"os::unix::net::addr::SocketAddr\" }), GenericArgs([]))) })])"
    ],
    "os::unix::net::addr::SocketAddr": [
      "Plain"
    ],
    "os::unix::net::stream::UnixStream": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::os::unix::net::listener::UnixListener::accept"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/listener.rs:178:5: 184:6",
  "src": "pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n        let mut len = size_of_val(&storage) as libc::socklen_t;\n        let sock = self.0.accept((&raw mut storage) as *mut _, &mut len)?;\n        let addr = SocketAddr::from_parts(storage, len)?;\n        Ok((UnixStream(sock), addr))\n    }",
  "mir": "fn os::unix::net::listener::UnixListener::accept(_1: &os::unix::net::listener::UnixListener) -> core::result::Result<(os::unix::net::stream::UnixStream, os::unix::net::addr::SocketAddr), io::error::Error> {\n    let mut _0: core::result::Result<(os::unix::net::stream::UnixStream, os::unix::net::addr::SocketAddr), io::error::Error>;\n    let mut _2: libc::sockaddr_un;\n    let mut _3: u32;\n    let mut _4: usize;\n    let  _5: &libc::sockaddr_un;\n    let  _6: sys::net::connection::socket::unix::Socket;\n    let mut _7: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, sys::net::connection::socket::unix::Socket>;\n    let mut _8: core::result::Result<sys::net::connection::socket::unix::Socket, io::error::Error>;\n    let mut _9: &sys::net::connection::socket::unix::Socket;\n    let mut _10: *mut libc::sockaddr;\n    let mut _11: *mut libc::sockaddr_un;\n    let mut _12: *mut u32;\n    let mut _13: &mut u32;\n    let mut _14: isize;\n    let  _15: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _16: sys::net::connection::socket::unix::Socket;\n    let mut _17: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, os::unix::net::addr::SocketAddr>;\n    let mut _18: core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>;\n    let mut _19: libc::sockaddr_un;\n    let mut _20: u32;\n    let mut _21: isize;\n    let  _22: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _23: os::unix::net::addr::SocketAddr;\n    let mut _24: (os::unix::net::stream::UnixStream, os::unix::net::addr::SocketAddr);\n    let mut _25: os::unix::net::stream::UnixStream;\n    let mut _26: sys::net::connection::socket::unix::Socket;\n    debug self => _1;\n    debug storage => _2;\n    debug len => _3;\n    debug sock => _6;\n    debug residual => _15;\n    debug val => _16;\n    debug addr => _23;\n    debug residual => _22;\n    debug val => _23;\n    bb0: {\n        StorageLive(_2);\n        _2 = core::mem::zeroed::<libc::sockaddr_un>() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _5 = &_2;\n        _4 = core::mem::size_of_val::<libc::sockaddr_un>(_5) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _3 = move _4 as u32;\n        StorageDead(_4);\n        StorageLive(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = &((*_1).0: sys::net::connection::socket::unix::Socket);\n        StorageLive(_11);\n        _11 = &raw mut _2;\n        _10 = move _11 as *mut libc::sockaddr;\n        StorageDead(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &mut _3;\n        _12 = &raw mut (*_13);\n        _8 = sys::net::connection::socket::unix::Socket::accept(move _9, _10, move _12) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        StorageDead(_12);\n        StorageDead(_9);\n        _7 = <core::result::Result<sys::net::connection::socket::unix::Socket, io::error::Error> as core::ops::Try>::branch(move _8) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_8);\n        _14 = discriminant(_7);\n        switchInt(move _14) -> [0: bb6, 1: bb7, otherwise: bb5];\n    }\n    bb5: {\n        unreachable;\n    }\n    bb6: {\n        StorageLive(_16);\n        _16 = move ((_7 as variant#0).0: sys::net::connection::socket::unix::Socket);\n        _6 = move _16;\n        StorageDead(_16);\n        StorageDead(_13);\n        StorageDead(_7);\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = _2;\n        StorageLive(_20);\n        _20 = _3;\n        _18 = os::unix::net::addr::SocketAddr::from_parts(move _19, move _20) -> [return: bb9, unwind unreachable];\n    }\n    bb7: {\n        _15 = move ((_7 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(os::unix::net::stream::UnixStream, os::unix::net::addr::SocketAddr), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_15) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_13);\n        StorageDead(_7);\n        goto -> bb14;\n    }\n    bb9: {\n        StorageDead(_20);\n        StorageDead(_19);\n        _17 = <core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error> as core::ops::Try>::branch(move _18) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_18);\n        _21 = discriminant(_17);\n        switchInt(move _21) -> [0: bb11, 1: bb12, otherwise: bb5];\n    }\n    bb11: {\n        _23 = move ((_17 as variant#0).0: os::unix::net::addr::SocketAddr);\n        StorageDead(_17);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = move _6;\n        _25 = UnixStream(move _26);\n        StorageDead(_26);\n        _24 = (move _25, _23);\n        StorageDead(_25);\n        _0 = core::result::Result::Ok(move _24);\n        StorageDead(_24);\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb15;\n    }\n    bb12: {\n        _22 = move ((_17 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(os::unix::net::stream::UnixStream, os::unix::net::addr::SocketAddr), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_22) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        drop(_6) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_6);\n        StorageDead(_3);\n        StorageDead(_2);\n        goto -> bb15;\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": " Accepts a new incoming connection to this listener.\n\n This function will block the calling thread until a new Unix connection\n is established. When established, the corresponding [`UnixStream`] and\n the remote peer's address will be returned.\n\n [`UnixStream`]: crate::os::unix::net::UnixStream\n\n # Examples\n\n ```no_run\n use std::os::unix::net::UnixListener;\n\n fn main() -> std::io::Result<()> {\n     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n\n     match listener.accept() {\n         Ok((socket, addr)) => println!(\"Got a client: {addr:?}\"),\n         Err(e) => println!(\"accept function failed: {e:?}\"),\n     }\n     Ok(())\n }\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}