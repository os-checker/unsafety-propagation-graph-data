{
  "name": "sync::mpsc::SyncSender::<T>::send",
  "safe": true,
  "callees": {
    "sync::mpmc::Sender::<T>::send": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to send a value on this channel, returning it back if it could\n not be sent.\n\n A successful send occurs when it is determined that the other end of\n the channel has not hung up already. An unsuccessful send would be one\n where the corresponding receiver has already been deallocated. Note\n that a return value of [`Err`] means that the data will never be\n received, but a return value of [`Ok`] does *not* mean that the data\n will be received. It is possible for the corresponding receiver to\n hang up immediately after this function returns [`Ok`]. However, if\n the channel is zero-capacity, it acts as a rendezvous channel and a\n return value of [`Ok`] means that the data has been received.\n\n If the channel is full and not disconnected, this call will block until\n the send operation can proceed. If the channel becomes disconnected,\n this call will wake up and return an error. The returned error contains\n the original message.\n\n If called on a zero-capacity channel, this method will wait for a receive\n operation to appear on the other side of the channel.\n\n # Examples\n\n ```\n #![feature(mpmc_channel)]\n\n use std::sync::mpmc::channel;\n\n let (tx, rx) = channel();\n\n // This send is always successful\n tx.send(1).unwrap();\n\n // This send will fail because the receiver is gone\n drop(rx);\n assert!(tx.send(1).is_err());\n ```\n",
      "adt": {
        "sync::mpmc::Sender": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "sync::mpmc::Sender": [
      "Ref"
    ],
    "sync::mpsc::SyncSender": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::mpsc::SyncSender::<T>::send"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/mpsc.rs:673:5: 675:6",
  "src": "pub fn send(&self, t: T) -> Result<(), SendError<T>> {\n        self.inner.send(t)\n    }",
  "mir": "fn sync::mpsc::SyncSender::<T>::send(_1: &sync::mpsc::SyncSender<T>, _2: T) -> core::result::Result<(), sync::mpsc::SendError<T>> {\n    let mut _0: core::result::Result<(), sync::mpsc::SendError<T>>;\n    let mut _3: &sync::mpmc::Sender<T>;\n    debug self => _1;\n    debug t => _2;\n    bb0: {\n        StorageLive(_3);\n        _3 = &((*_1).0: sync::mpmc::Sender<T>);\n        _0 = sync::mpmc::Sender::<T>::send(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": " Sends a value on this synchronous channel.\n\n This function will *block* until space in the internal buffer becomes\n available or a receiver is available to hand off the message to.\n\n Note that a successful send does *not* guarantee that the receiver will\n ever see the data if there is a buffer on this channel. Items may be\n enqueued in the internal buffer for the receiver to receive at a later\n time. If the buffer size is 0, however, the channel becomes a rendezvous\n channel and it guarantees that the receiver has indeed received\n the data if this function returns success.\n\n This function will never panic, but it may return [`Err`] if the\n [`Receiver`] has disconnected and is no longer able to receive\n information.\n\n # Examples\n\n ```rust\n use std::sync::mpsc::sync_channel;\n use std::thread;\n\n // Create a rendezvous sync_channel with buffer size 0\n let (sync_sender, receiver) = sync_channel(0);\n\n thread::spawn(move || {\n    println!(\"sending message...\");\n    sync_sender.send(1).unwrap();\n    // Thread is now blocked until the message is received\n\n    println!(\"...message received!\");\n });\n\n let msg = receiver.recv().unwrap();\n assert_eq!(1, msg);\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}