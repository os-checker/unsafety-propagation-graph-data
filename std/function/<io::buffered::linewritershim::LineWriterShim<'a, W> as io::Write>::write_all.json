{
  "name": "<io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_all",
  "safe": true,
  "callees": {
    "core::slice::memchr::memrchr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the last index matching the byte `x` in `text`.\n",
      "adt": {}
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::flush_if_completed_line": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Flushes the buffer iff the last byte is a newline (indicating that an\n earlier write only succeeded partially, and we want to retry flushing\n the buffered line before continuing with a subsequent write).\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "MutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "io::Write::write_all": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to write an entire buffer into this writer.\n\n This method will continuously call [`write`] until there is no more data\n to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n returned. This method will not return until the entire buffer has been\n successfully written or such an error occurs. The first error that is\n not of [`ErrorKind::Interrupted`] kind generated from this method will be\n returned.\n\n If the buffer contains no data, this will never call [`write`].\n\n # Errors\n\n This function will return the first error of\n non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n\n [`write`]: Write::write\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     buffer.write_all(b\"some bytes\")?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::buffered": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets the content currently buffered in self.buffer\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::is_empty": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the slice has a length of 0.\n\n # Examples\n\n ```\n let a = [1, 2, 3];\n assert!(!a.is_empty());\n\n let b: &[i32] = &[];\n assert!(b.is_empty());\n ```\n",
      "adt": {}
    },
    "io::buffered::linewritershim::LineWriterShim::<'a, W>::inner_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a mutable reference to the inner writer (that is, the writer\n wrapped by the BufWriter). Be careful with this writer, as writes to\n it will bypass the buffer.\n",
      "adt": {
        "io::buffered::linewritershim::LineWriterShim": "MutableAsArgument"
      }
    },
    "io::buffered::bufwriter::BufWriter::<W>::flush_buf": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Send data in our local buffer into the inner writer, looping as\n necessary until either it's all been sent or an error occurs.\n\n Because all the data in the buffer has been reported to our owner as\n \"successfully written\" (by returning nonzero success values from\n `write`), any 0-length writes from `inner` must be reported as i/o\n errors from this method.\n",
      "adt": {
        "core::result::Result": "Constructor",
        "io::buffered::bufwriter::BufWriter": "MutableAsArgument"
      }
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "io::buffered::linewritershim::LineWriterShim": [
      "MutRef",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref",
      "Deref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "io::buffered::bufwriter::BufWriter": [
      "MutRef"
    ]
  },
  "path": 1383,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/buffered/linewritershim.rs:268:5: 296:6",
  "src": "fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n        match memchr::memrchr(b'\\n', buf) {\n            // If there are no new newlines (that is, if this write is less than\n            // one line), just do a regular buffered write (which may flush if\n            // we exceed the inner buffer's size)\n            None => {\n                self.flush_if_completed_line()?;\n                self.buffer.write_all(buf)\n            }\n            Some(newline_idx) => {\n                let (lines, tail) = buf.split_at(newline_idx + 1);\n\n                if self.buffered().is_empty() {\n                    self.inner_mut().write_all(lines)?;\n                } else {\n                    // If there is any buffered data, we add the incoming lines\n                    // to that buffer before flushing, which saves us at least\n                    // one write call. We can't really do this with `write`,\n                    // since we can't do this *and* not suppress errors *and*\n                    // report a consistent state to the caller in a return\n                    // value, but here in write_all it's fine.\n                    self.buffer.write_all(lines)?;\n                    self.buffer.flush_buf()?;\n                }\n\n                self.buffer.write_all(tail)\n            }\n        }\n    }",
  "mir": "fn <io::buffered::linewritershim::LineWriterShim<'a, W> as io::Write>::write_all(_1: &mut io::buffered::linewritershim::LineWriterShim<'_, W>, _2: &[u8]) -> core::result::Result<(), io::error::Error> {\n    let mut _0: core::result::Result<(), io::error::Error>;\n    let mut _3: core::option::Option<usize>;\n    let mut _4: isize;\n    let mut _5: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _6: core::result::Result<(), io::error::Error>;\n    let mut _7: isize;\n    let  _8: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _9: usize;\n    let  _10: &[u8];\n    let  _11: &[u8];\n    let mut _12: (&[u8], &[u8]);\n    let mut _13: usize;\n    let mut _14: (usize, bool);\n    let mut _15: bool;\n    let  _16: &[u8];\n    let mut _17: &io::buffered::linewritershim::LineWriterShim<'_, W>;\n    let mut _18: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _19: core::result::Result<(), io::error::Error>;\n    let mut _20: &mut W;\n    let mut _21: isize;\n    let  _22: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _24: core::result::Result<(), io::error::Error>;\n    let mut _25: isize;\n    let  _26: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _27: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>>;\n    let mut _28: core::result::Result<(), io::error::Error>;\n    let mut _29: isize;\n    let  _30: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let mut _31: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _32: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _33: &mut io::buffered::bufwriter::BufWriter<W>;\n    let mut _34: &mut io::buffered::bufwriter::BufWriter<W>;\n    debug self => _1;\n    debug buf => _2;\n    debug residual => _8;\n    debug val => ();\n    debug newline_idx => _9;\n    debug lines => _10;\n    debug tail => _11;\n    debug residual => _22;\n    debug val => ();\n    debug residual => _26;\n    debug val => ();\n    debug residual => _30;\n    debug val => ();\n    bb0: {\n        StorageLive(_3);\n        _3 = core::slice::memchr::memrchr(10_u8, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _4 = discriminant(_3);\n        switchInt(move _4) -> [0: bb4, 1: bb3, otherwise: bb2];\n    }\n    bb2: {\n        unreachable;\n    }\n    bb3: {\n        _9 = ((_3 as variant#1).0: usize);\n        StorageLive(_12);\n        StorageLive(_13);\n        _14 = CheckedAdd(_9, 1_usize);\n        assert(!move (_14.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _9, 1_usize) -> [success: bb11, unwind unreachable];\n    }\n    bb4: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = io::buffered::linewritershim::LineWriterShim::<'_, W>::flush_if_completed_line(_1) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _5 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _6) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_6);\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb7, 1: bb8, otherwise: bb2];\n    }\n    bb7: {\n        StorageDead(_5);\n        _31 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _0 = <io::buffered::bufwriter::BufWriter<W> as io::Write>::write_all(_31, _2) -> [return: bb10, unwind unreachable];\n    }\n    bb8: {\n        _8 = move ((_5 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_8) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_5);\n        goto -> bb37;\n    }\n    bb10: {\n        goto -> bb35;\n    }\n    bb11: {\n        _13 = move (_14.0: usize);\n        _12 = core::slice::<impl [u8]>::split_at(_2, move _13) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_13);\n        _10 = (_12.0: &[u8]);\n        _11 = (_12.1: &[u8]);\n        StorageDead(_12);\n        StorageLive(_15);\n        StorageLive(_17);\n        _17 = &(*_1);\n        _16 = io::buffered::linewritershim::LineWriterShim::<'_, W>::buffered(move _17) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_17);\n        _15 = core::slice::<impl [u8]>::is_empty(_16) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        switchInt(move _15) -> [0: bb22, otherwise: bb15];\n    }\n    bb15: {\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = io::buffered::linewritershim::LineWriterShim::<'_, W>::inner_mut(_1) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        _19 = <W as io::Write>::write_all(_20, _10) -> [return: bb17, unwind unreachable];\n    }\n    bb17: {\n        _18 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _19) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_19);\n        _21 = discriminant(_18);\n        switchInt(move _21) -> [0: bb19, 1: bb20, otherwise: bb2];\n    }\n    bb19: {\n        StorageDead(_18);\n        goto -> bb33;\n    }\n    bb20: {\n        _22 = move ((_18 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_22) -> [return: bb21, unwind unreachable];\n    }\n    bb21: {\n        StorageDead(_18);\n        goto -> bb36;\n    }\n    bb22: {\n        StorageLive(_23);\n        StorageLive(_24);\n        _32 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _24 = <io::buffered::bufwriter::BufWriter<W> as io::Write>::write_all(_32, _10) -> [return: bb23, unwind unreachable];\n    }\n    bb23: {\n        _23 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _24) -> [return: bb24, unwind unreachable];\n    }\n    bb24: {\n        StorageDead(_24);\n        _25 = discriminant(_23);\n        switchInt(move _25) -> [0: bb25, 1: bb26, otherwise: bb2];\n    }\n    bb25: {\n        StorageDead(_23);\n        StorageLive(_27);\n        StorageLive(_28);\n        _33 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _28 = io::buffered::bufwriter::BufWriter::<W>::flush_buf(_33) -> [return: bb28, unwind unreachable];\n    }\n    bb26: {\n        _26 = move ((_23 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_26) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        StorageDead(_23);\n        goto -> bb36;\n    }\n    bb28: {\n        _27 = <core::result::Result<(), io::error::Error> as core::ops::Try>::branch(move _28) -> [return: bb29, unwind unreachable];\n    }\n    bb29: {\n        StorageDead(_28);\n        _29 = discriminant(_27);\n        switchInt(move _29) -> [0: bb30, 1: bb31, otherwise: bb2];\n    }\n    bb30: {\n        StorageDead(_27);\n        goto -> bb33;\n    }\n    bb31: {\n        _30 = move ((_27 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_30) -> [return: bb32, unwind unreachable];\n    }\n    bb32: {\n        StorageDead(_27);\n        goto -> bb36;\n    }\n    bb33: {\n        StorageDead(_15);\n        _34 = ((*_1).0: &mut io::buffered::bufwriter::BufWriter<W>);\n        _0 = <io::buffered::bufwriter::BufWriter<W> as io::Write>::write_all(_34, _11) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        goto -> bb35;\n    }\n    bb35: {\n        StorageDead(_3);\n        goto -> bb38;\n    }\n    bb36: {\n        StorageDead(_15);\n        goto -> bb37;\n    }\n    bb37: {\n        StorageDead(_3);\n        goto -> bb38;\n    }\n    bb38: {\n        return;\n    }\n}\n",
  "doc": " Writes some data into this BufReader with line buffering.\n\n This means that, if any newlines are present in the data, the data up to\n the last newline is sent directly to the underlying writer, and data\n after it is buffered.\n\n Because this function attempts to send completed lines to the underlying\n writer, it will also flush the existing buffer if it contains any\n newlines, even if the incoming data does not contain any newlines.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}