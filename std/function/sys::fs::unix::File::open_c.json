{
  "name": "sys::fs::unix::File::open_c",
  "safe": true,
  "callees": {
    "sys::fs::unix::OpenOptions::get_access_mode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "sys::fs::unix::OpenOptions::get_creation_mode": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::fs::unix::OpenOptions": "ImmutableAsArgument",
        "core::result::Result": "Constructor"
      }
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::cvt_r": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " `-1` → look at `errno` → retry on `EINTR`. Otherwise `Ok()`-wrap the closure return value.\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    },
    "os::fd::raw::FromRawFd::from_raw_fd": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs a new instance of `Self` from the given raw file\n descriptor.\n\n This function is typically used to **consume ownership** of the\n specified file descriptor. When used in this way, the returned object\n will take responsibility for closing it when the object goes out of\n scope.\n\n However, consuming ownership is not strictly required. Use a\n [`From<OwnedFd>::from`] implementation for an API which strictly\n consumes ownership.\n\n # Safety\n\n The `fd` passed in must be an [owned file descriptor][io-safety];\n in particular, it must be open.\n\n [io-safety]: io#io-safety\n\n # Example\n\n ```no_run\n use std::fs::File;\n # use std::io;\n #[cfg(any(unix, target_os = \"wasi\"))]\n use std::os::fd::{FromRawFd, IntoRawFd, RawFd};\n\n let f = File::open(\"foo.txt\")?;\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let raw_fd: RawFd = f.into_raw_fd();\n // SAFETY: no other functions should call `from_raw_fd`, so there\n // is only one owner for the file descriptor.\n # #[cfg(any(unix, target_os = \"wasi\"))]\n let f = unsafe { File::from_raw_fd(raw_fd) };\n # Ok::<(), io::Error>(())\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::fs::unix::OpenOptions": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(6)))"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])"
    ],
    "core::ffi::CStr": [
      "Ref"
    ],
    "sys::fd::unix::FileDesc": [
      "Plain"
    ],
    "sys::fs::unix::File": [
      "Plain"
    ]
  },
  "path": 3524,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1206:5: 1217:6",
  "src": "pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n        let flags = libc::O_CLOEXEC\n            | opts.get_access_mode()?\n            | opts.get_creation_mode()?\n            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n        // The third argument of `open64` is documented to have type `mode_t`. On\n        // some platforms (like macOS, where `open64` is actually `open`), `mode_t` is `u16`.\n        // However, since this is a variadic function, C integer promotion rules mean that on\n        // the ABI level, this still gets passed as `c_int` (aka `u32` on Unix platforms).\n        let fd = cvt_r(|| unsafe { open64(path.as_ptr(), flags, opts.mode as c_int) })?;\n        Ok(File(unsafe { FileDesc::from_raw_fd(fd) }))\n    }",
  "mir": "fn sys::fs::unix::File::open_c(_1: &core::ffi::CStr, _2: &sys::fs::unix::OpenOptions) -> core::result::Result<sys::fs::unix::File, io::error::Error> {\n    let mut _0: core::result::Result<sys::fs::unix::File, io::error::Error>;\n    let  _3: i32;\n    let mut _4: i32;\n    let mut _5: i32;\n    let mut _6: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _7: core::result::Result<i32, io::error::Error>;\n    let mut _8: isize;\n    let  _9: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _10: i32;\n    let mut _11: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _12: core::result::Result<i32, io::error::Error>;\n    let mut _13: isize;\n    let  _14: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _15: i32;\n    let mut _16: i32;\n    let mut _17: i32;\n    let mut _18: i32;\n    let mut _19: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _20: core::result::Result<i32, io::error::Error>;\n    let mut _21: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1215:24: 1215:26};\n    let mut _22: &i32;\n    let mut _23: isize;\n    let  _24: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _25: i32;\n    let mut _26: sys::fs::unix::File;\n    let mut _27: sys::fd::unix::FileDesc;\n    debug path => _1;\n    debug opts => _2;\n    debug flags => _3;\n    debug residual => _9;\n    debug val => _10;\n    debug residual => _14;\n    debug val => _15;\n    debug fd => _25;\n    debug residual => _24;\n    debug val => _25;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = sys::fs::unix::OpenOptions::get_access_mode(_2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _6 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _7) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_7);\n        _8 = discriminant(_6);\n        switchInt(move _8) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _10 = ((_6 as variant#0).0: i32);\n        _5 = BitOr(libc::O_CLOEXEC, _10);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = sys::fs::unix::OpenOptions::get_creation_mode(_2) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _9 = move ((_6 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<sys::fs::unix::File, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_9) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_5);\n        StorageDead(_4);\n        goto -> bb20;\n    }\n    bb7: {\n        _11 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        _13 = discriminant(_11);\n        switchInt(move _13) -> [0: bb9, 1: bb10, otherwise: bb3];\n    }\n    bb9: {\n        _15 = ((_11 as variant#0).0: i32);\n        _4 = BitOr(move _5, _15);\n        StorageDead(_5);\n        StorageLive(_16);\n        StorageLive(_17);\n        _17 = ((*_2).6: i32);\n        StorageLive(_18);\n        _18 = Not(libc::O_ACCMODE);\n        _16 = BitAnd(move _17, move _18);\n        StorageDead(_18);\n        StorageDead(_17);\n        _3 = BitOr(move _4, move _16);\n        StorageDead(_16);\n        StorageDead(_4);\n        StorageDead(_11);\n        StorageDead(_6);\n        StorageLive(_19);\n        StorageLive(_20);\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_3;\n        _21 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1215:24: 1215:26}(_1, move _22, _2);\n        StorageDead(_22);\n        _20 = sys::pal::unix::cvt_r::<i32, {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/fs/unix.rs:1215:24: 1215:26}>(move _21) -> [return: bb12, unwind unreachable];\n    }\n    bb10: {\n        _14 = move ((_11 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<sys::fs::unix::File, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_14) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_5);\n        StorageDead(_4);\n        StorageDead(_11);\n        goto -> bb20;\n    }\n    bb12: {\n        StorageDead(_21);\n        _19 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _20) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_20);\n        _23 = discriminant(_19);\n        switchInt(move _23) -> [0: bb14, 1: bb15, otherwise: bb3];\n    }\n    bb14: {\n        _25 = ((_19 as variant#0).0: i32);\n        StorageDead(_19);\n        StorageLive(_26);\n        StorageLive(_27);\n        _27 = <sys::fd::unix::FileDesc as os::fd::raw::FromRawFd>::from_raw_fd(_25) -> [return: bb17, unwind unreachable];\n    }\n    bb15: {\n        _24 = move ((_19 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<sys::fs::unix::File, io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_24) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_19);\n        goto -> bb18;\n    }\n    bb17: {\n        _26 = File(move _27);\n        StorageDead(_27);\n        _0 = core::result::Result::Ok(move _26);\n        StorageDead(_26);\n        StorageDead(_3);\n        goto -> bb19;\n    }\n    bb18: {\n        StorageDead(_3);\n        goto -> bb19;\n    }\n    bb19: {\n        return;\n    }\n    bb20: {\n        StorageDead(_6);\n        goto -> bb18;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}