{
  "name": "sync::poison::rwlock::RwLock::<T>::try_write",
  "safe": true,
  "callees": {
    "sys::sync::rwlock::futex::RwLock::try_write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::sync::rwlock::futex::RwLock": "ImmutableAsArgument"
      }
    },
    "sync::poison::rwlock::RwLockWriteGuard::<'rwlock, T>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of `RwLockWriteGuard<T>` from a `RwLock<T>`.\n\n # Safety\n\n This function is safe if and only if the same thread has successfully and safely called\n `lock.inner.write()`, `lock.inner.try_write()`, or `lock.inner.try_upgrade` before\n instantiating this object.\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::rwlock::RwLockWriteGuard": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "sys::sync::rwlock::futex::RwLock": [
      "Ref"
    ],
    "sync::poison::rwlock::RwLock": [
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(0)))",
      "Ref"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12274, kind: RigidTy(Adt(AdtDef(DefId { id: 9991, name: \"sync::poison::rwlock::RwLockWriteGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12302, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 12277, kind: RigidTy(Adt(AdtDef(DefId { id: 9910, name: \"sync::poison::PoisonError\" }), GenericArgs([Type(Ty { id: 12274, kind: RigidTy(Adt(AdtDef(DefId { id: 9991, name: \"sync::poison::rwlock::RwLockWriteGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })]))) })])"
    ],
    "sync::poison::rwlock::RwLockWriteGuard": [
      "Plain"
    ],
    "sync::poison::TryLockError": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::poison::rwlock::RwLock::<T>::try_write"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/rwlock.rs:535:5: 543:6",
  "src": "pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<'_, T>> {\n        unsafe {\n            if self.inner.try_write() {\n                Ok(RwLockWriteGuard::new(self)?)\n            } else {\n                Err(TryLockError::WouldBlock)\n            }\n        }\n    }",
  "mir": "fn sync::poison::rwlock::RwLock::<T>::try_write(_1: &sync::poison::rwlock::RwLock<T>) -> core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::TryLockError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>> {\n    let mut _0: core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::TryLockError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>;\n    let mut _2: bool;\n    let mut _3: &sys::sync::rwlock::futex::RwLock;\n    let mut _4: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>, sync::poison::rwlock::RwLockWriteGuard<'_, T>>;\n    let mut _5: core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>;\n    let mut _6: isize;\n    let  _7: core::result::Result<core::convert::Infallible, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>;\n    let  _8: sync::poison::rwlock::RwLockWriteGuard<'_, T>;\n    let mut _9: sync::poison::TryLockError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>;\n    debug self => _1;\n    debug residual => _7;\n    debug val => _8;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = &((*_1).0: sys::sync::rwlock::futex::RwLock);\n        _2 = sys::sync::rwlock::futex::RwLock::try_write(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        switchInt(move _2) -> [0: bb8, otherwise: bb2];\n    }\n    bb2: {\n        StorageDead(_3);\n        StorageLive(_4);\n        StorageLive(_5);\n        _5 = sync::poison::rwlock::RwLockWriteGuard::<'_, T>::new(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = <core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>> as core::ops::Try>::branch(move _5) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        StorageDead(_5);\n        _6 = discriminant(_4);\n        switchInt(move _6) -> [1: bb6, 0: bb5, otherwise: bb11];\n    }\n    bb5: {\n        _8 = move ((_4 as variant#0).0: sync::poison::rwlock::RwLockWriteGuard<'_, T>);\n        _0 = core::result::Result::Ok(_8);\n        StorageDead(_4);\n        goto -> bb9;\n    }\n    bb6: {\n        _7 = move ((_4 as variant#1).0: core::result::Result<core::convert::Infallible, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>);\n        _0 = <core::result::Result<sync::poison::rwlock::RwLockWriteGuard<'_, T>, sync::poison::TryLockError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, sync::poison::PoisonError<sync::poison::rwlock::RwLockWriteGuard<'_, T>>>>>::from_residual(_7) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_4);\n        StorageDead(_2);\n        goto -> bb10;\n    }\n    bb8: {\n        StorageDead(_3);\n        StorageLive(_9);\n        _9 = sync::poison::TryLockError::WouldBlock;\n        _0 = core::result::Result::Err(move _9);\n        StorageDead(_9);\n        goto -> bb9;\n    }\n    bb9: {\n        StorageDead(_2);\n        goto -> bb10;\n    }\n    bb10: {\n        return;\n    }\n    bb11: {\n        unreachable;\n    }\n}\n",
  "doc": " Attempts to lock this `RwLock` with exclusive write access.\n\n If the lock could not be acquired at this time, then `Err` is returned.\n Otherwise, an RAII guard is returned which will release the lock when\n it is dropped.\n\n This function does not block.\n\n This function does not provide any guarantees with respect to the ordering\n of whether contentious readers or writers will acquire the lock first.\n\n # Errors\n\n This function will return the [`Poisoned`] error if the `RwLock` is\n poisoned. An `RwLock` is poisoned whenever a writer panics while holding\n an exclusive lock. `Poisoned` will only be returned if the lock would\n have otherwise been acquired. An acquired lock guard will be contained\n in the returned error.\n\n This function will return the [`WouldBlock`] error if the `RwLock` could\n not be acquired because it was already locked.\n\n [`Poisoned`]: TryLockError::Poisoned\n [`WouldBlock`]: TryLockError::WouldBlock\n\n\n # Examples\n\n ```\n use std::sync::RwLock;\n\n let lock = RwLock::new(1);\n\n let n = lock.read().unwrap();\n assert_eq!(*n, 1);\n\n assert!(lock.try_write().is_err());\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}