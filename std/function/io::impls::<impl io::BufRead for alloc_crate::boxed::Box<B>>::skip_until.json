{
  "name": "io::impls::<impl io::BufRead for alloc_crate::boxed::Box<B>>::skip_until",
  "safe": true,
  "callees": {
    "io::BufRead::skip_until": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Skips all bytes until the delimiter `byte` or EOF is reached.\n\n This function will read (and discard) bytes from the underlying stream until the\n delimiter or EOF is found.\n\n If successful, this function will return the total number of bytes read,\n including the delimiter byte if found.\n\n This is useful for efficiently skipping data such as NUL-terminated strings\n in binary file formats without buffering.\n\n This function is blocking and should be used carefully: it is possible for\n an attacker to continuously send bytes without ever sending the delimiter\n or EOF.\n\n # Errors\n\n This function will ignore all instances of [`ErrorKind::Interrupted`] and\n will otherwise return any errors returned by [`fill_buf`].\n\n If an I/O error is encountered then all bytes read so far will be\n present in `buf` and its length will have been adjusted appropriately.\n\n [`fill_buf`]: BufRead::fill_buf\n\n # Examples\n\n [`std::io::Cursor`][`Cursor`] is a type that implements `BufRead`. In\n this example, we use [`Cursor`] to read some NUL-terminated information\n about Ferris from a binary string, skipping the fun fact:\n\n ```\n use std::io::{self, BufRead};\n\n let mut cursor = io::Cursor::new(b\"Ferris\\0Likes long walks on the beach\\0Crustacean\\0!\");\n\n // read name\n let mut name = Vec::new();\n let num_bytes = cursor.read_until(b'\\0', &mut name)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 7);\n assert_eq!(name, b\"Ferris\\0\");\n\n // skip fun fact\n let num_bytes = cursor.skip_until(b'\\0')\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 30);\n\n // read animal type\n let mut animal = Vec::new();\n let num_bytes = cursor.read_until(b'\\0', &mut animal)\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 11);\n assert_eq!(animal, b\"Crustacean\\0\");\n\n // reach EOF\n let num_bytes = cursor.skip_until(b'\\0')\n     .expect(\"reading from cursor won't fail\");\n assert_eq!(num_bytes, 1);\n ```\n",
      "adt": {
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "alloc_crate::boxed::Box": [
      "Plain",
      "Deref",
      "Unknown([Field(0, Ty { id: 5832, kind: RigidTy(Adt(AdtDef(DefId { id: 4689, name: \"core::ptr::Unique\" }), GenericArgs([Type(Ty { id: 2967, kind: Param(ParamTy { index: 0, name: \"B\" }) })]))) }), Field(0, Ty { id: 5833, kind: RigidTy(Adt(AdtDef(DefId { id: 4690, name: \"core::ptr::NonNull\" }), GenericArgs([Type(Ty { id: 2967, kind: Param(ParamTy { index: 0, name: \"B\" }) })]))) })])",
      "MutRef"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::io::impls::<impl io::BufRead for alloc_crate::boxed::Box<B>>::skip_until"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/io/impls.rs:280:5: 282:6",
  "src": "fn skip_until(&mut self, byte: u8) -> io::Result<usize> {\n        (**self).skip_until(byte)\n    }",
  "mir": "fn io::impls::<impl io::BufRead for alloc_crate::boxed::Box<B>>::skip_until(_1: &mut alloc_crate::boxed::Box<B>, _2: u8) -> core::result::Result<usize, io::error::Error> {\n    let mut _0: core::result::Result<usize, io::error::Error>;\n    let mut _3: &mut B;\n    let mut _4: alloc_crate::boxed::Box<B>;\n    let mut _5: *const B;\n    debug self => _1;\n    debug byte => _2;\n    bb0: {\n        StorageLive(_3);\n        _4 = (*_1);\n        _5 = ((_4.0: core::ptr::Unique<B>).0: core::ptr::NonNull<B>) as *const B;\n        _3 = &mut (*_5);\n        _0 = <B as io::BufRead>::skip_until(move _3, _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}