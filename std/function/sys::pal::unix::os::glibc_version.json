{
  "name": "sys::pal::unix::os::glibc_version",
  "safe": true,
  "callees": {
    "sys::pal::unix::os::glibc_version::gnu_get_libc_version": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ffi::CStr::from_ptr": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Wraps a raw C string with a safe C string wrapper.\n\n This function will wrap the provided `ptr` with a `CStr` wrapper, which\n allows inspection and interoperation of non-owned C strings. The total\n size of the terminated buffer must be smaller than [`isize::MAX`] **bytes**\n in memory (a restriction from [`slice::from_raw_parts`]).\n\n # Safety\n\n * The memory pointed to by `ptr` must contain a valid nul terminator at the\n   end of the string.\n\n * `ptr` must be [valid] for reads of bytes up to and including the nul terminator.\n   This means in particular:\n\n     * The entire memory range of this `CStr` must be contained within a single allocation!\n     * `ptr` must be non-null even for a zero-length cstr.\n\n * The memory referenced by the returned `CStr` must not be mutated for\n   the duration of lifetime `'a`.\n\n * The nul terminator must be within `isize::MAX` from `ptr`\n\n > **Note**: This operation is intended to be a 0-cost cast but it is\n > currently implemented with an up-front calculation of the length of\n > the string. This is not guaranteed to always be the case.\n\n # Caveat\n\n The lifetime for the returned slice is inferred from its usage. To prevent accidental misuse,\n it's suggested to tie the lifetime to whichever source lifetime is safe in the context,\n such as by providing a helper function taking the lifetime of a host value for the slice,\n or by explicit annotation.\n\n # Examples\n\n ```\n use std::ffi::{c_char, CStr};\n\n fn my_string() -> *const c_char {\n     c\"hello\".as_ptr()\n }\n\n unsafe {\n     let slice = CStr::from_ptr(my_string());\n     assert_eq!(slice.to_str().unwrap(), \"hello\");\n }\n ```\n\n ```\n use std::ffi::{c_char, CStr};\n\n const HELLO_PTR: *const c_char = {\n     const BYTES: &[u8] = b\"Hello, world!\\0\";\n     BYTES.as_ptr().cast()\n };\n const HELLO: &CStr = unsafe { CStr::from_ptr(HELLO_PTR) };\n\n assert_eq!(c\"Hello, world!\", HELLO);\n ```\n\n [valid]: core::ptr#safety\n",
      "adt": {}
    },
    "core::ffi::CStr::to_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.\n\n If the contents of the `CStr` are valid UTF-8 data, this\n function will return the corresponding <code>&[str]</code> slice. Otherwise,\n it will return an error with details of where UTF-8 validation failed.\n\n [str]: prim@str \"str\"\n\n # Examples\n\n ```\n assert_eq!(c\"foo\".to_str(), Ok(\"foo\"));\n ```\n",
      "adt": {}
    },
    "sys::pal::unix::os::parse_glibc_version": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    }
  },
  "adts": {
    "core::ffi::CStr": [
      "Ref"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 7, kind: RigidTy(Ref(Region { kind: ReErased }, Ty { id: 17, kind: RigidTy(Str) }, Not)) })])"
    ],
    "core::option::Option": [
      "Plain"
    ]
  },
  "path": 3919,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/os.rs:680:1: 690:2",
  "src": "pub fn glibc_version() -> Option<(usize, usize)> {\n    unsafe extern \"C\" {\n        fn gnu_get_libc_version() -> *const libc::c_char;\n    }\n    let version_cstr = unsafe { CStr::from_ptr(gnu_get_libc_version()) };\n    if let Ok(version_str) = version_cstr.to_str() {\n        parse_glibc_version(version_str)\n    } else {\n        None\n    }\n}",
  "mir": "fn sys::pal::unix::os::glibc_version() -> core::option::Option<(usize, usize)> {\n    let mut _0: core::option::Option<(usize, usize)>;\n    let  _1: &core::ffi::CStr;\n    let mut _2: *const u8;\n    let mut _3: core::result::Result<&str, core::str::Utf8Error>;\n    let mut _4: isize;\n    let  _5: &str;\n    debug version_cstr => _1;\n    debug version_str => _5;\n    bb0: {\n        StorageLive(_2);\n        _2 = sys::pal::unix::os::glibc_version::gnu_get_libc_version() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _1 = core::ffi::CStr::from_ptr::<'_>(move _2) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_2);\n        StorageLive(_3);\n        _3 = core::ffi::CStr::to_str(_1) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        _4 = discriminant(_3);\n        switchInt(move _4) -> [0: bb4, 1: bb6, otherwise: bb8];\n    }\n    bb4: {\n        _5 = ((_3 as variant#0).0: &str);\n        _0 = sys::pal::unix::os::parse_glibc_version(_5) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_3);\n        goto -> bb7;\n    }\n    bb6: {\n        StorageDead(_3);\n        _0 = core::option::Option::None;\n        goto -> bb7;\n    }\n    bb7: {\n        return;\n    }\n    bb8: {\n        unreachable;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}