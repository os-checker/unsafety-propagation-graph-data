{
  "name": "thread::current::with_current_name",
  "safe": true,
  "callees": {
    "thread::current::try_with_current": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Gets a reference to the handle of the thread that invokes it, if the handle\n has been initialized.\n",
      "adt": {}
    }
  },
  "adts": {},
  "path": {
    "type": "Local",
    "path": "std::thread::current::with_current_name"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/current.rs:212:1: 236:2",
  "src": "pub(crate) fn with_current_name<F, R>(f: F) -> R\nwhere\n    F: FnOnce(Option<&str>) -> R,\n{\n    try_with_current(|thread| {\n        let name = if let Some(thread) = thread {\n            // If there is a current thread handle, try to use the name stored\n            // there.\n            thread.name()\n        } else if let Some(main) = main_thread::get()\n            && let Some(id) = id::get()\n            && id == main\n        {\n            // The main thread doesn't always have a thread handle, we must\n            // identify it through its ID instead. The checks are ordered so\n            // that the current ID is only loaded if it is actually needed,\n            // since loading it from TLS might need multiple expensive accesses.\n            Some(\"main\")\n        } else {\n            None\n        };\n\n        f(name)\n    })\n}",
  "mir": "fn thread::current::with_current_name(_1: F) -> R {\n    let mut _0: R;\n    let mut _2: {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/current.rs:216:22: 216:30};\n    debug f => _1;\n    bb0: {\n        StorageLive(_2);\n        _2 = {closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/current.rs:216:22: 216:30}(move _1);\n        _0 = thread::current::try_with_current::<{closure@/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/current.rs:216:22: 216:30}, R>(move _2) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_2);\n        return;\n    }\n}\n",
  "doc": " Run a function with the current thread's name.\n\n Modulo thread local accesses, this function is safe to call from signal\n handlers and in similar circumstances where allocations are not possible.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}