{
  "name": "sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn",
  "safe": true,
  "callees": {
    "sys::process::unix::common::Command::capture_env": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument",
        "core::option::Option": "Constructor"
      }
    },
    "sys::process::unix::common::Command::saw_nul": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "io::error::Error::from_static_message": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Creates a new I/O error from a known kind of error as well as a constant\n message.\n\n This function does not allocate.\n\n You should not use this directly, and instead use the `const_error!`\n macro: `io::const_error!(ErrorKind::Something, \"some_message\")`.\n\n This function should maybe change to `from_static_message<const MSG: &'static\n str>(kind: ErrorKind)` in the future, when const generics allow that.\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::hint::must_use": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An identity function that causes an `unused_must_use` warning to be\n triggered if the given value is not used (returned, stored in a variable,\n etc) by the caller.\n\n This is primarily intended for use in macro-generated code, in which a\n [`#[must_use]` attribute][must_use] either on a type or a function would not\n be convenient.\n\n [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n\n # Example\n\n ```\n #![feature(hint_must_use)]\n\n use core::fmt;\n\n pub struct Error(/* ... */);\n\n #[macro_export]\n macro_rules! make_error {\n     ($($args:expr),*) => {\n         core::hint::must_use({\n             let error = $crate::make_error(core::format_args!($($args),*));\n             error\n         })\n     };\n }\n\n // Implementation detail of make_error! macro.\n #[doc(hidden)]\n pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n     Error(/* ... */)\n }\n\n fn demo() -> Option<Error> {\n     if true {\n         // Oops, meant to write `return Some(make_error!(\"...\"));`\n         Some(make_error!(\"...\"));\n     }\n     None\n }\n #\n # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n # fn main() {}\n ```\n\n In the above example, we'd like an `unused_must_use` lint to apply to the\n value created by `make_error!`. However, neither `#[must_use]` on a struct\n nor `#[must_use]` on a function is appropriate here, so the macro expands\n using `core::hint::must_use` instead.\n\n - We wouldn't want `#[must_use]` on the `struct Error` because that would\n   make the following unproblematic code trigger a warning:\n\n   ```\n   # struct Error;\n   #\n   fn f(arg: &str) -> Result<(), Error>\n   # { Ok(()) }\n\n   #[test]\n   fn t() {\n       // Assert that `f` returns error if passed an empty string.\n       // A value of type `Error` is unused here but that's not a problem.\n       f(\"\").unwrap_err();\n   }\n   ```\n\n - Using `#[must_use]` on `fn make_error` can't help because the return value\n   *is* used, as the right-hand side of a `let` statement. The `let`\n   statement looks useless but is in fact necessary for ensuring that\n   temporaries within the `format_args` expansion are not kept alive past the\n   creation of the `Error`, as keeping them alive past that point can cause\n   autotrait issues in async code:\n\n   ```\n   # #![feature(hint_must_use)]\n   #\n   # struct Error;\n   #\n   # macro_rules! make_error {\n   #     ($($args:expr),*) => {\n   #         core::hint::must_use({\n   #             // If `let` isn't used, then `f()` produces a non-Send future.\n   #             let error = make_error(core::format_args!($($args),*));\n   #             error\n   #         })\n   #     };\n   # }\n   #\n   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n   #     Error\n   # }\n   #\n   async fn f() {\n       // Using `let` inside the make_error expansion causes temporaries like\n       // `unsync()` to drop at the semicolon of that `let` statement, which\n       // is prior to the await point. They would otherwise stay around until\n       // the semicolon on *this* statement, which is after the await point,\n       // and the enclosing Future would not implement Send.\n       log(make_error!(\"look: {:p}\", unsync())).await;\n   }\n\n   async fn log(error: Error) {/* ... */}\n\n   // Returns something without a Sync impl.\n   fn unsync() -> *const () {\n       0 as *const ()\n   }\n   #\n   # fn test() {\n   #     fn assert_send(_: impl Send) {}\n   #     assert_send(f());\n   # }\n   ```\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::setup_io": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "sys::process::unix::common::Stdio": "ImmutableAsArgument",
        "process::StdioPipes": "Constructor",
        "sys::process::unix::common::ChildPipes": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "core::option::Option::<T>::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts from `&Option<T>` to `Option<&T>`.\n\n # Examples\n\n Calculates the length of an <code>Option<[String]></code> as an <code>Option<[usize]></code>\n without moving the [`String`]. The [`map`] method takes the `self` argument by value,\n consuming the original, so this technique uses `as_ref` to first take an `Option` to a\n reference to the value inside the original.\n\n [`map`]: Option::map\n [String]: ../../std/string/struct.String.html \"String\"\n [`String`]: ../../std/string/struct.String.html \"String\"\n\n ```\n let text: Option<String> = Some(\"Hello, world!\".to_string());\n // First, cast `Option<String>` to `Option<&String>` with `as_ref`,\n // then consume *that* with `map`, leaving `text` on the stack.\n let text_length: Option<usize> = text.as_ref().map(|s| s.len());\n println!(\"still can print text: {text:?}\");\n ```\n",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument",
        "core::option::Option": "Constructor",
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "sys::process::unix::common::ChildPipes": "ImmutableAsArgument",
        "sys::process::unix::unix::Process": "Constructor"
      }
    },
    "sys::net::connection::socket::unix::Socket::new_pair": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "sys::net::connection::socket::unix::Socket": "Constructor"
      }
    },
    "sys::env::unix::env_read_lock": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_fork": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument",
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "panic::always_abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Makes all future panics abort directly without running the panic hook or unwinding.\n\n There is no way to undo this; the effect lasts until the process exits or\n execs (or the equivalent).\n\n # Use after fork\n\n This function is particularly useful for calling after `libc::fork`.  After `fork`, in a\n multithreaded program it is (on many platforms) not safe to call the allocator.  It is also\n generally highly undesirable for an unwind to unwind past the `fork`, because that results in\n the unwind propagating to code that was only ever expecting to run in the parent.\n\n `panic::always_abort()` helps avoid both of these.  It directly avoids any further unwinding,\n and if there is a panic, the abort will occur without allocating provided that the arguments to\n panic can be formatted without allocating.\n\n Examples\n\n ```no_run\n #![feature(panic_always_abort)]\n use std::panic;\n\n panic::always_abort();\n\n let _ = panic::catch_unwind(|| {\n     panic!(\"inside the catch\");\n });\n\n // We will have aborted already, due to the panic.\n unreachable!();\n ```\n",
      "adt": {}
    },
    "core::mem::forget": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Takes ownership and \"forgets\" about the value **without running its destructor**.\n\n Any resources the value manages, such as heap memory or a file handle, will linger\n forever in an unreachable state. However, it does not guarantee that pointers\n to this memory will remain valid.\n\n * If you want to leak memory, see [`Box::leak`].\n * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`].\n * If you want to dispose of a value properly, running its destructor, see\n   [`mem::drop`].\n\n # Safety\n\n `forget` is not marked as `unsafe`, because Rust's safety guarantees\n do not include a guarantee that destructors will always run. For example,\n a program can create a reference cycle using [`Rc`][rc], or call\n [`process::exit`][exit] to exit without running destructors. Thus, allowing\n `mem::forget` from safe code does not fundamentally change Rust's safety\n guarantees.\n\n That said, leaking resources such as memory or I/O objects is usually undesirable.\n The need comes up in some specialized use cases for FFI or unsafe code, but even\n then, [`ManuallyDrop`] is typically preferred.\n\n Because forgetting a value is allowed, any `unsafe` code you write must\n allow for this possibility. You cannot return a value and expect that the\n caller will necessarily run the value's destructor.\n\n [rc]: ../../std/rc/struct.Rc.html\n [exit]: ../../std/process/fn.exit.html\n\n # Examples\n\n The canonical safe use of `mem::forget` is to circumvent a value's destructor\n implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n the space taken by the variable but never close the underlying system resource:\n\n ```no_run\n use std::mem;\n use std::fs::File;\n\n let file = File::open(\"foo.txt\").unwrap();\n mem::forget(file);\n ```\n\n This is useful when the ownership of the underlying resource was previously\n transferred to code outside of Rust, for example by transmitting the raw\n file descriptor to C code.\n\n # Relationship with `ManuallyDrop`\n\n While `mem::forget` can also be used to transfer *memory* ownership, doing so is error-prone.\n [`ManuallyDrop`] should be used instead. Consider, for example, this code:\n\n ```\n use std::mem;\n\n let mut v = vec![65, 122];\n // Build a `String` using the contents of `v`\n let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), v.len(), v.capacity()) };\n // leak `v` because its memory is now managed by `s`\n mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n There are two issues with the above example:\n\n * If more code were added between the construction of `String` and the invocation of\n   `mem::forget()`, a panic within it would cause a double free because the same memory\n   is handled by both `v` and `s`.\n * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n   the `v` value is invalid. Even when a value is just moved to `mem::forget` (which won't\n   inspect it), some types have strict requirements on their values that\n   make them invalid when dangling or no longer owned. Using invalid values in any\n   way, including passing them to or returning them from functions, constitutes\n   undefined behavior and may break the assumptions made by the compiler.\n\n Switching to `ManuallyDrop` avoids both issues:\n\n ```\n use std::mem::ManuallyDrop;\n\n let v = vec![65, 122];\n // Before we disassemble `v` into its raw parts, make sure it\n // does not get dropped!\n let mut v = ManuallyDrop::new(v);\n // Now disassemble `v`. These operations cannot panic, so there cannot be a leak.\n let (ptr, len, cap) = (v.as_mut_ptr(), v.len(), v.capacity());\n // Finally, build a `String`.\n let s = unsafe { String::from_raw_parts(ptr, len, cap) };\n assert_eq!(s, \"Az\");\n // `s` is implicitly dropped and its memory deallocated.\n ```\n\n `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n argument, forcing us to call it only after extracting anything we need from `v`. Even\n if a panic were introduced between construction of `ManuallyDrop` and building the\n string (which cannot happen in the code as shown), it would result in a leak and not a\n double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n erring on the side of (double-)dropping.\n\n Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n ownership to `s` â€” the final step of interacting with `v` to dispose of it without\n running its destructor is entirely avoided.\n\n [`Box`]: ../../std/boxed/struct.Box.html\n [`Box::leak`]: ../../std/boxed/struct.Box.html#method.leak\n [`Box::into_raw`]: ../../std/boxed/struct.Box.html#method.into_raw\n [`mem::drop`]: drop\n [ub]: ../../reference/behavior-considered-undefined.html\n",
      "adt": {}
    },
    "core::mem::drop": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Disposes of a value.\n\n This effectively does nothing for types which implement `Copy`, e.g.\n integers. Such values are copied and _then_ moved into the function, so the\n value persists after this function call.\n\n This function is not magic; it is literally defined as\n\n ```\n pub fn drop<T>(_x: T) {}\n ```\n\n Because `_x` is moved into the function, it is automatically [dropped][drop] before\n the function returns.\n\n [drop]: Drop\n\n # Examples\n\n Basic usage:\n\n ```\n let v = vec![1, 2, 3];\n\n drop(v); // explicitly drop the vector\n ```\n\n Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n release a [`RefCell`] borrow:\n\n ```\n use std::cell::RefCell;\n\n let x = RefCell::new(1);\n\n let mut mutable_borrow = x.borrow_mut();\n *mutable_borrow = 1;\n\n drop(mutable_borrow); // relinquish the mutable borrow on this slot\n\n let borrow = x.borrow();\n println!(\"{}\", *borrow);\n ```\n\n Integers and other types implementing [`Copy`] are unaffected by `drop`.\n\n ```\n # #![allow(dropping_copy_types)]\n #[derive(Copy, Clone)]\n struct Foo(u8);\n\n let x = 1;\n let y = Foo(2);\n drop(x); // a copy of `x` is moved and dropped\n drop(y); // a copy of `y` is moved and dropped\n\n println!(\"x: {}, y: {}\", x, y.0); // still available\n ```\n\n [`RefCell`]: crate::cell::RefCell\n",
      "adt": {}
    },
    "sys::process::unix::common::Command::get_create_pidfd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "MutableAsArgument",
        "core::option::Option": "ImmutableAsArgument",
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor"
      }
    },
    "io::error::Error::raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the OS error that this error represents (if any).\n\n If this [`Error`] was constructed via [`last_os_error`] or\n [`from_raw_os_error`], then this function will return [`Some`], otherwise\n it will return [`None`].\n\n [`last_os_error`]: Error::last_os_error\n [`from_raw_os_error`]: Error::from_raw_os_error\n\n # Examples\n\n ```\n use std::io::{Error, ErrorKind};\n\n fn print_os_error(err: &Error) {\n     if let Some(raw_os_err) = err.raw_os_error() {\n         println!(\"raw OS error: {raw_os_err:?}\");\n     } else {\n         println!(\"Not an OS error\");\n     }\n }\n\n fn main() {\n     // Will print \"raw OS error: ...\".\n     print_os_error(&Error::last_os_error());\n     // Will print \"Not an OS error\".\n     print_os_error(&Error::new(ErrorKind::Other, \"oh no!\"));\n }\n ```\n",
      "adt": {
        "core::option::Option": "Constructor",
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::option::Option::<T>::unwrap_or": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Some`] value or a provided default.\n\n Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n the result of a function call, it is recommended to use [`unwrap_or_else`],\n which is lazily evaluated.\n\n [`unwrap_or_else`]: Option::unwrap_or_else\n\n # Examples\n\n ```\n assert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\n assert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n ```\n",
      "adt": {}
    },
    "core::num::<impl u32>::to_be_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the memory representation of this integer as a byte array in\n big-endian (network) byte order.\n\n\n # Examples\n\n ```\n ```\n",
      "adt": {}
    },
    "sys::net::connection::socket::unix::Socket::write": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument"
      }
    },
    "core::result::Result::<T, E>::is_ok": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns `true` if the result is [`Ok`].\n\n # Examples\n\n ```\n let x: Result<i32, &str> = Ok(-3);\n assert_eq!(x.is_ok(), true);\n\n let x: Result<i32, &str> = Err(\"Some error message\");\n assert_eq!(x.is_ok(), false);\n ```\n",
      "adt": {}
    },
    "sys::stdio::unix::panic_output": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor",
        "sys::stdio::unix::Stderr": "Constructor"
      }
    },
    "core::fmt::Arguments::<'a>::from_str_nonconst": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "io::Write::write_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Writes a formatted string into this writer, returning any error\n encountered.\n\n This method is primarily used to interface with the\n [`format_args!()`] macro, and it is rare that this should\n explicitly be called. The [`write!()`] macro should be favored to\n invoke this method instead.\n\n This function internally uses the [`write_all`] method on\n this trait and hence will continuously write data so long as no errors\n are received. This also means that partial writes are not indicated in\n this signature.\n\n [`write_all`]: Write::write_all\n\n # Errors\n\n This function will return any I/O error reported while formatting.\n\n # Examples\n\n ```no_run\n use std::io::prelude::*;\n use std::fs::File;\n\n fn main() -> std::io::Result<()> {\n     let mut buffer = File::create(\"foo.txt\")?;\n\n     // this call\n     write!(buffer, \"{:.*}\", 2, 1.234567)?;\n     // turns into this:\n     buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567))?;\n     Ok(())\n }\n ```\n",
      "adt": {
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "core::fmt::Arguments": "ImmutableAsArgument"
      }
    },
    "process::abort": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Terminates the process in an abnormal fashion.\n\n The function will never return and will immediately terminate the current\n process in a platform specific \"abnormal\" manner. As a consequence,\n no destructors on the current stack or any other thread's stack\n will be run, Rust IO buffers (eg, from `BufWriter`) will not be flushed,\n and C stdio buffers will (on most platforms) not be flushed.\n\n This is in contrast to the default behavior of [`panic!`] which unwinds\n the current thread's stack and calls all destructors.\n When `panic=\"abort\"` is set, either as an argument to `rustc` or in a\n crate's Cargo.toml, [`panic!`] and `abort` are similar. However,\n [`panic!`] will still call the [panic hook] while `abort` will not.\n\n If a clean shutdown is needed it is recommended to only call\n this function at a known point where there are no more destructors left\n to run.\n\n The process's termination will be similar to that from the C `abort()`\n function.  On Unix, the process will terminate with signal `SIGABRT`, which\n typically means that the shell prints \"Aborted\".\n\n # Examples\n\n ```no_run\n use std::process;\n\n fn main() {\n     println!(\"aborting\");\n\n     process::abort();\n\n     // execution never gets here\n }\n ```\n\n The `abort` function terminates the process, so the destructor will not\n get run on the example below:\n\n ```no_run\n use std::process;\n\n struct HasDrop;\n\n impl Drop for HasDrop {\n     fn drop(&mut self) {\n         println!(\"This will never be printed!\");\n     }\n }\n\n fn main() {\n     let _x = HasDrop;\n     process::abort();\n     // the destructor implemented for HasDrop will never get run\n }\n ```\n\n [panic hook]: crate::panic::set_hook\n",
      "adt": {}
    },
    "libc::_exit": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "sys::process::unix::unix::<impl sys::process::unix::common::Command>::recv_pidfd": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sys::process::unix::common::Command": "ImmutableAsArgument",
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::unix::Process::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " # Safety\n\n `pidfd` must either be -1 (representing no file descriptor) or a valid, exclusively owned file\n descriptor (See [I/O Safety]).\n\n [I/O Safety]: crate::io#io-safety\n",
      "adt": {
        "sys::process::unix::unix::Process": "Constructor"
      }
    },
    "sys::net::connection::socket::unix::Socket::read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "sys::net::connection::socket::unix::Socket": "ImmutableAsArgument"
      }
    },
    "sys::process::unix::unix::Process::wait": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor",
        "sys::process::unix::unix::Process": "MutableAsArgument"
      }
    },
    "io::error::Error::is_interrupted": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "ImmutableAsArgument"
      }
    },
    "core::slice::<impl [T]>::split_at": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Divides one slice into two at an index.\n\n The first will contain all indices from `[0, mid)` (excluding\n the index `mid` itself) and the second will contain all\n indices from `[mid, len)` (excluding the index `len` itself).\n\n # Panics\n\n Panics if `mid > len`.  For a non-panicking alternative see\n [`split_at_checked`](slice::split_at_checked).\n\n # Examples\n\n ```\n let v = ['a', 'b', 'c'];\n\n {\n    let (left, right) = v.split_at(0);\n    assert_eq!(left, []);\n    assert_eq!(right, ['a', 'b', 'c']);\n }\n\n {\n     let (left, right) = v.split_at(2);\n     assert_eq!(left, ['a', 'b']);\n     assert_eq!(right, ['c']);\n }\n\n {\n     let (left, right) = v.split_at(3);\n     assert_eq!(left, ['a', 'b', 'c']);\n     assert_eq!(right, []);\n }\n ```\n",
      "adt": {}
    },
    "core::cmp::PartialEq::eq": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Tests for `self` and `other` values to be equal, and is used by `==`.\n",
      "adt": {}
    },
    "core::convert::TryInto::try_into": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the conversion.\n",
      "adt": {}
    },
    "core::fmt::rt::Argument::<'_>::new_debug": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::assert_failed": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Internal function for `assert_eq!` and `assert_ne!` macros\n",
      "adt": {}
    },
    "core::result::Result::<T, E>::unwrap": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the contained [`Ok`] value, consuming the `self` value.\n\n Because this function may panic, its use is generally discouraged.\n Panics are meant for unrecoverable errors, and\n [may abort the entire program][panic-abort].\n\n Instead, prefer to use [the `?` (try) operator][try-operator], or pattern matching\n to handle the [`Err`] case explicitly, or call [`unwrap_or`],\n [`unwrap_or_else`], or [`unwrap_or_default`].\n\n [panic-abort]: https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html\n [try-operator]: https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator\n [`unwrap_or`]: Result::unwrap_or\n [`unwrap_or_else`]: Result::unwrap_or_else\n [`unwrap_or_default`]: Result::unwrap_or_default\n\n # Panics\n\n Panics if the value is an [`Err`], with a panic message provided by the\n [`Err`]'s value.\n\n\n # Examples\n\n Basic usage:\n\n ```\n let x: Result<u32, &str> = Ok(2);\n assert_eq!(x.unwrap(), 2);\n ```\n\n ```should_panic\n let x: Result<u32, &str> = Err(\"emergency failure\");\n x.unwrap(); // panics with `emergency failure`\n ```\n",
      "adt": {}
    },
    "core::num::<impl i32>::from_be_bytes": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates an integer value from its representation as a byte array in\n big endian.\n\n\n # Examples\n\n ```\n ```\n\n When starting from a slice rather than an array, fallible conversion APIs can be used:\n\n ```\n     *input = rest;\n }\n ```\n",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "io::error::Error::from_raw_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a new instance of an [`Error`] from a particular OS error code.\n\n # Examples\n\n On Linux:\n\n ```\n # if cfg!(target_os = \"linux\") {\n use std::io;\n\n let error = io::Error::from_raw_os_error(22);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n\n On Windows:\n\n ```\n # if cfg!(windows) {\n use std::io;\n\n let error = io::Error::from_raw_os_error(10022);\n assert_eq!(error.kind(), io::ErrorKind::InvalidInput);\n # }\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    }
  },
  "adts": {
    "sys::process::unix::common::Command": [
      "MutRef",
      "Ref",
      "Deref"
    ],
    "core::option::Option": [
      "Plain",
      "Ref",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 8866, kind: RigidTy(Adt(AdtDef(DefId { id: 8505, name: \"sys::process::unix::unix::Process\" }), GenericArgs([]))) })])"
    ],
    "io::error::Error": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })])",
      "Ref",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 393, kind: RigidTy(Uint(Usize)) })])"
    ],
    "sys::process::unix::common::Stdio": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 16779, kind: RigidTy(Tuple([Ty { id: 10101, kind: RigidTy(Adt(AdtDef(DefId { id: 9038, name: \"process::StdioPipes\" }), GenericArgs([]))) }, Ty { id: 16786, kind: RigidTy(Adt(AdtDef(DefId { id: 12176, name: \"sys::process::unix::common::ChildPipes\" }), GenericArgs([]))) }])) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 510, kind: RigidTy(Adt(AdtDef(DefId { id: 4389, name: \"core::result::Result\" }), GenericArgs([Type(Ty { id: 427, kind: RigidTy(Adt(AdtDef(DefId { id: 4570, name: \"core::convert::Infallible\" }), GenericArgs([]))) }), Type(Ty { id: 20, kind: RigidTy(Adt(AdtDef(DefId { id: 4564, name: \"io::error::Error\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 16898, kind: RigidTy(Adt(AdtDef(DefId { id: 4387, name: \"core::option::Option\" }), GenericArgs([Type(Ty { id: 8866, kind: RigidTy(Adt(AdtDef(DefId { id: 8505, name: \"sys::process::unix::unix::Process\" }), GenericArgs([]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 8382, kind: RigidTy(Tuple([Ty { id: 8202, kind: RigidTy(Adt(AdtDef(DefId { id: 8147, name: \"sys::net::connection::socket::unix::Socket\" }), GenericArgs([]))) }, Ty { id: 8202, kind: RigidTy(Adt(AdtDef(DefId { id: 8147, name: \"sys::net::connection::socket::unix::Socket\" }), GenericArgs([]))) }])) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 44, kind: RigidTy(Int(I32)) })])"
    ],
    "process::StdioPipes": [
      "Plain",
      "Unknown([Field(0, Ty { id: 10101, kind: RigidTy(Adt(AdtDef(DefId { id: 9038, name: \"process::StdioPipes\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 16786, kind: RigidTy(Adt(AdtDef(DefId { id: 12176, name: \"sys::process::unix::common::ChildPipes\" }), GenericArgs([]))) })])"
    ],
    "sys::process::unix::common::ChildPipes": [
      "Plain",
      "Unknown([Field(0, Ty { id: 10101, kind: RigidTy(Adt(AdtDef(DefId { id: 9038, name: \"process::StdioPipes\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 16786, kind: RigidTy(Adt(AdtDef(DefId { id: 12176, name: \"sys::process::unix::common::ChildPipes\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "sys::process::unix::unix::Process": [
      "Plain",
      "MutRef"
    ],
    "sys::net::connection::socket::unix::Socket": [
      "Plain",
      "Unknown([Field(0, Ty { id: 8202, kind: RigidTy(Adt(AdtDef(DefId { id: 8147, name: \"sys::net::connection::socket::unix::Socket\" }), GenericArgs([]))) })])",
      "Unknown([Field(1, Ty { id: 8202, kind: RigidTy(Adt(AdtDef(DefId { id: 8147, name: \"sys::net::connection::socket::unix::Socket\" }), GenericArgs([]))) })])",
      "Ref"
    ],
    "sync::poison::rwlock::RwLockReadGuard": [
      "Plain"
    ],
    "sys::stdio::unix::Stderr": [
      "MutRef",
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::panicking::AssertKind": [
      "Plain"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ]
  },
  "path": 4160,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/process/unix/unix.rs:55:5: 165:6",
  "src": "pub fn spawn(\n        &mut self,\n        default: Stdio,\n        needs_stdin: bool,\n    ) -> io::Result<(Process, StdioPipes)> {\n        const CLOEXEC_MSG_FOOTER: [u8; 4] = *b\"NOEX\";\n\n        let envp = self.capture_env();\n\n        if self.saw_nul() {\n            return Err(io::const_error!(\n                ErrorKind::InvalidInput,\n                \"nul byte found in provided data\",\n            ));\n        }\n\n        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n\n        if let Some(ret) = self.posix_spawn(&theirs, envp.as_ref())? {\n            return Ok((ret, ours));\n        }\n\n        #[cfg(target_os = \"linux\")]\n        let (input, output) = sys::net::Socket::new_pair(libc::AF_UNIX, libc::SOCK_SEQPACKET)?;\n\n        #[cfg(not(target_os = \"linux\"))]\n        let (input, output) = sys::pipe::anon_pipe()?;\n\n        // Whatever happens after the fork is almost for sure going to touch or\n        // look at the environment in one way or another (PATH in `execvp` or\n        // accessing the `environ` pointer ourselves). Make sure no other thread\n        // is accessing the environment when we do the fork itself.\n        //\n        // Note that as soon as we're done with the fork there's no need to hold\n        // a lock any more because the parent won't do anything and the child is\n        // in its own process. Thus the parent drops the lock guard immediately.\n        // The child calls `mem::forget` to leak the lock, which is crucial because\n        // releasing a lock is not async-signal-safe.\n        let env_lock = sys::env::env_read_lock();\n        let pid = unsafe { self.do_fork()? };\n\n        if pid == 0 {\n            crate::panic::always_abort();\n            mem::forget(env_lock); // avoid non-async-signal-safe unlocking\n            drop(input);\n            #[cfg(target_os = \"linux\")]\n            if self.get_create_pidfd() {\n                self.send_pidfd(&output);\n            }\n            let Err(err) = unsafe { self.do_exec(theirs, envp.as_ref()) };\n            let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n            let errno = errno.to_be_bytes();\n            let bytes = [\n                errno[0],\n                errno[1],\n                errno[2],\n                errno[3],\n                CLOEXEC_MSG_FOOTER[0],\n                CLOEXEC_MSG_FOOTER[1],\n                CLOEXEC_MSG_FOOTER[2],\n                CLOEXEC_MSG_FOOTER[3],\n            ];\n            // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n            // we want to be sure we *don't* run at_exit destructors as\n            // we're being torn down regardless\n            rtassert!(output.write(&bytes).is_ok());\n            unsafe { libc::_exit(1) }\n        }\n\n        drop(env_lock);\n        drop(output);\n\n        #[cfg(target_os = \"linux\")]\n        let pidfd = if self.get_create_pidfd() { self.recv_pidfd(&input) } else { -1 };\n\n        #[cfg(not(target_os = \"linux\"))]\n        let pidfd = -1;\n\n        // Safety: We obtained the pidfd (on Linux) using SOCK_SEQPACKET, so it's valid.\n        let mut p = unsafe { Process::new(pid, pidfd) };\n        let mut bytes = [0; 8];\n\n        // loop to handle EINTR\n        loop {\n            match input.read(&mut bytes) {\n                Ok(0) => return Ok((p, ours)),\n                Ok(8) => {\n                    let (errno, footer) = bytes.split_at(4);\n                    assert_eq!(\n                        CLOEXEC_MSG_FOOTER, footer,\n                        \"Validation on the CLOEXEC pipe failed: {:?}\",\n                        bytes\n                    );\n                    let errno = i32::from_be_bytes(errno.try_into().unwrap());\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    return Err(Error::from_raw_os_error(errno));\n                }\n                Err(ref e) if e.is_interrupted() => {}\n                Err(e) => {\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    panic!(\"the CLOEXEC pipe failed: {e:?}\")\n                }\n                Ok(..) => {\n                    // pipe I/O up to PIPE_BUF bytes should be atomic\n                    // similarly SOCK_SEQPACKET messages should arrive whole\n                    assert!(p.wait().is_ok(), \"wait() should either return Ok or panic\");\n                    panic!(\"short read on the CLOEXEC pipe\")\n                }\n            }\n        }\n    }",
  "mir": "fn sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn(_1: &mut sys::process::unix::common::Command, _2: sys::process::unix::common::Stdio, _3: bool) -> core::result::Result<(sys::process::unix::unix::Process, process::StdioPipes), io::error::Error> {\n    let mut _0: core::result::Result<(sys::process::unix::unix::Process, process::StdioPipes), io::error::Error>;\n    let  _4: core::option::Option<sys::process::unix::common::cstring_array::CStringArray>;\n    let mut _5: bool;\n    let mut _6: &sys::process::unix::common::Command;\n    let mut _7: io::error::Error;\n    let mut _8: io::error::Error;\n    let  _9: process::StdioPipes;\n    let  _10: sys::process::unix::common::ChildPipes;\n    let mut _11: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, (process::StdioPipes, sys::process::unix::common::ChildPipes)>;\n    let mut _12: core::result::Result<(process::StdioPipes, sys::process::unix::common::ChildPipes), io::error::Error>;\n    let mut _13: &sys::process::unix::common::Command;\n    let mut _14: sys::process::unix::common::Stdio;\n    let mut _15: isize;\n    let  _16: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _17: (process::StdioPipes, sys::process::unix::common::ChildPipes);\n    let mut _18: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, core::option::Option<sys::process::unix::unix::Process>>;\n    let mut _19: core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error>;\n    let  _20: &sys::process::unix::common::ChildPipes;\n    let mut _21: core::option::Option<&sys::process::unix::common::cstring_array::CStringArray>;\n    let mut _22: &core::option::Option<sys::process::unix::common::cstring_array::CStringArray>;\n    let mut _23: isize;\n    let  _24: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _25: core::option::Option<sys::process::unix::unix::Process>;\n    let mut _26: isize;\n    let  _27: sys::process::unix::unix::Process;\n    let mut _28: (sys::process::unix::unix::Process, process::StdioPipes);\n    let mut _29: process::StdioPipes;\n    let  _30: sys::net::connection::socket::unix::Socket;\n    let  _31: sys::net::connection::socket::unix::Socket;\n    let mut _32: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, (sys::net::connection::socket::unix::Socket, sys::net::connection::socket::unix::Socket)>;\n    let mut _33: core::result::Result<(sys::net::connection::socket::unix::Socket, sys::net::connection::socket::unix::Socket), io::error::Error>;\n    let mut _34: isize;\n    let  _35: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _36: (sys::net::connection::socket::unix::Socket, sys::net::connection::socket::unix::Socket);\n    let  _37: sync::poison::rwlock::RwLockReadGuard<'_, ()>;\n    let mut _38: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, io::error::Error>, i32>;\n    let mut _39: core::result::Result<i32, io::error::Error>;\n    let mut _40: isize;\n    let  _41: core::result::Result<core::convert::Infallible, io::error::Error>;\n    let  _42: i32;\n    let  _43: ();\n    let  _44: ();\n    let mut _45: sync::poison::rwlock::RwLockReadGuard<'_, ()>;\n    let  _46: ();\n    let mut _47: sys::net::connection::socket::unix::Socket;\n    let mut _48: bool;\n    let mut _49: &sys::process::unix::common::Command;\n    let  _50: ();\n    let mut _51: &sys::process::unix::common::Command;\n    let  _52: &sys::net::connection::socket::unix::Socket;\n    let  _53: io::error::Error;\n    let mut _54: core::result::Result<!, io::error::Error>;\n    let mut _55: sys::process::unix::common::ChildPipes;\n    let mut _56: core::option::Option<&sys::process::unix::common::cstring_array::CStringArray>;\n    let mut _57: &core::option::Option<sys::process::unix::common::cstring_array::CStringArray>;\n    let  _58: u32;\n    let mut _59: i32;\n    let mut _60: core::option::Option<i32>;\n    let mut _61: &io::error::Error;\n    let  _62: [u8; 4];\n    let  _63: [u8; 8];\n    let mut _64: u8;\n    let  _65: usize;\n    let mut _66: bool;\n    let mut _67: u8;\n    let  _68: usize;\n    let mut _69: bool;\n    let mut _70: u8;\n    let  _71: usize;\n    let mut _72: bool;\n    let mut _73: u8;\n    let  _74: usize;\n    let mut _75: bool;\n    let mut _76: u8;\n    let mut _77: [u8; 4];\n    let  _78: usize;\n    let mut _79: bool;\n    let mut _80: u8;\n    let mut _81: [u8; 4];\n    let  _82: usize;\n    let mut _83: bool;\n    let mut _84: u8;\n    let mut _85: [u8; 4];\n    let  _86: usize;\n    let mut _87: bool;\n    let mut _88: u8;\n    let mut _89: [u8; 4];\n    let  _90: usize;\n    let mut _91: bool;\n    let mut _92: bool;\n    let mut _93: &core::result::Result<usize, io::error::Error>;\n    let  _94: core::result::Result<usize, io::error::Error>;\n    let mut _95: &sys::net::connection::socket::unix::Socket;\n    let mut _96: &[u8];\n    let  _97: &[u8; 8];\n    let mut _98: core::option::Option<sys::stdio::unix::Stderr>;\n    let mut _99: isize;\n    let mut _100: sys::stdio::unix::Stderr;\n    let mut _101: core::result::Result<(), io::error::Error>;\n    let mut _102: &mut sys::stdio::unix::Stderr;\n    let mut _103: core::fmt::Arguments<'_>;\n    let  _104: !;\n    let mut _105: !;\n    let  _106: ();\n    let mut _107: sync::poison::rwlock::RwLockReadGuard<'_, ()>;\n    let  _108: ();\n    let mut _109: sys::net::connection::socket::unix::Socket;\n    let  _110: i32;\n    let mut _111: bool;\n    let mut _112: &sys::process::unix::common::Command;\n    let mut _113: &sys::process::unix::common::Command;\n    let  _114: &sys::net::connection::socket::unix::Socket;\n    let mut _115: sys::process::unix::unix::Process;\n    let mut _116: i32;\n    let mut _117: [u8; 8];\n    let mut _118: core::result::Result<usize, io::error::Error>;\n    let mut _119: &sys::net::connection::socket::unix::Socket;\n    let mut _120: &mut [u8];\n    let mut _121: &mut [u8; 8];\n    let mut _122: isize;\n    let mut _123: (sys::process::unix::unix::Process, process::StdioPipes);\n    let mut _124: sys::process::unix::unix::Process;\n    let mut _125: process::StdioPipes;\n    let  _126: &[u8];\n    let  _127: &[u8];\n    let mut _128: (&[u8], &[u8]);\n    let mut _129: &[u8];\n    let mut _130: &[u8; 8];\n    let mut _131: (&[u8; 4], &&[u8]);\n    let mut _132: &[u8; 4];\n    let mut _133: &&[u8];\n    let  _134: &[u8; 4];\n    let  _135: &&[u8];\n    let mut _136: bool;\n    let  _137: core::panicking::AssertKind;\n    let  _138: !;\n    let mut _139: core::option::Option<core::fmt::Arguments<'_>>;\n    let mut _140: core::fmt::Arguments<'_>;\n    let  _141: (&[u8; 8],);\n    let mut _142: &[u8; 8];\n    let  _143: [core::fmt::rt::Argument<'_>; 1];\n    let mut _144: core::fmt::rt::Argument<'_>;\n    let mut _145: &[u8; 42];\n    let  _146: &[core::fmt::rt::Argument<'_>; 1];\n    let  _147: i32;\n    let mut _148: [u8; 4];\n    let mut _149: core::result::Result<[u8; 4], core::array::TryFromSliceError>;\n    let mut _150: bool;\n    let mut _151: &core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let  _152: core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let mut _153: &mut sys::process::unix::unix::Process;\n    let  _154: !;\n    let mut _155: core::fmt::Arguments<'_>;\n    let mut _156: io::error::Error;\n    let  _157: &io::error::Error;\n    let  _158: &&io::error::Error;\n    let mut _159: bool;\n    let  _160: io::error::Error;\n    let mut _161: bool;\n    let mut _162: &core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let  _163: core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let mut _164: &mut sys::process::unix::unix::Process;\n    let  _165: !;\n    let mut _166: core::fmt::Arguments<'_>;\n    let  _167: !;\n    let mut _168: core::fmt::Arguments<'_>;\n    let  _169: (&io::error::Error,);\n    let mut _170: &io::error::Error;\n    let  _171: [core::fmt::rt::Argument<'_>; 1];\n    let mut _172: core::fmt::rt::Argument<'_>;\n    let mut _173: &[u8; 28];\n    let  _174: &[core::fmt::rt::Argument<'_>; 1];\n    let mut _175: bool;\n    let mut _176: &core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let  _177: core::result::Result<sys::process::unix::unix::ExitStatus, io::error::Error>;\n    let mut _178: &mut sys::process::unix::unix::Process;\n    let  _179: !;\n    let mut _180: core::fmt::Arguments<'_>;\n    let  _181: !;\n    let mut _182: core::fmt::Arguments<'_>;\n    let mut _183: &io::error::Error;\n    let mut _184: &[u8; 8];\n    let mut _185: &io::error::Error;\n    let mut _186: bool;\n    let mut _187: bool;\n    let mut _188: bool;\n    let mut _189: bool;\n    let mut _190: bool;\n    debug self => _1;\n    debug default => _2;\n    debug needs_stdin => _3;\n    debug envp => _4;\n    debug ours => _9;\n    debug theirs => _10;\n    debug residual => _16;\n    debug val => _17;\n    debug residual => _24;\n    debug val => _25;\n    debug ret => _27;\n    debug input => _30;\n    debug output => _31;\n    debug residual => _35;\n    debug val => _36;\n    debug env_lock => _37;\n    debug pid => _42;\n    debug residual => _41;\n    debug val => _42;\n    debug err => _53;\n    debug errno => _58;\n    debug errno => _62;\n    debug bytes => _63;\n    debug out => sys::stdio::unix::Stderr;\n    debug pidfd => _110;\n    debug p => _115;\n    debug bytes => _117;\n    debug errno => _126;\n    debug footer => _127;\n    debug left_val => _134;\n    debug right_val => _135;\n    debug kind => _137;\n    debug args => _141;\n    debug args => _143;\n    debug errno => _147;\n    debug e => _157;\n    debug e => _158;\n    debug e => _160;\n    debug args => _169;\n    debug args => _171;\n    bb0: {\n        _190 = false;\n        _189 = false;\n        _188 = false;\n        _187 = false;\n        _186 = false;\n        _190 = true;\n        StorageLive(_4);\n        _4 = sys::process::unix::common::Command::capture_env(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_5);\n        StorageLive(_6);\n        _6 = &(*_1);\n        _5 = sys::process::unix::common::Command::saw_nul(move _6) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        switchInt(move _5) -> [0: bb6, otherwise: bb3];\n    }\n    bb3: {\n        StorageDead(_6);\n        StorageLive(_7);\n        StorageLive(_8);\n        _8 = io::error::Error::from_static_message(sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn::{constant#1}) -> [return: bb4, unwind unreachable];\n    }\n    bb4: {\n        _7 = core::hint::must_use::<io::error::Error>(move _8) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        _0 = core::result::Result::Err(move _7);\n        StorageDead(_7);\n        StorageDead(_5);\n        goto -> bb131;\n    }\n    bb6: {\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_11);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = &(*_1);\n        StorageLive(_14);\n        _190 = false;\n        _14 = move _2;\n        _12 = sys::process::unix::common::Command::setup_io(move _13, move _14, _3) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_14);\n        StorageDead(_13);\n        _11 = <core::result::Result<(process::StdioPipes, sys::process::unix::common::ChildPipes), io::error::Error> as core::ops::Try>::branch(move _12) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_12);\n        _15 = discriminant(_11);\n        switchInt(move _15) -> [0: bb10, 1: bb11, otherwise: bb9];\n    }\n    bb9: {\n        unreachable;\n    }\n    bb10: {\n        _17 = move ((_11 as variant#0).0: (process::StdioPipes, sys::process::unix::common::ChildPipes));\n        StorageLive(_9);\n        _189 = true;\n        _9 = (_17.0: process::StdioPipes);\n        StorageLive(_10);\n        _10 = (_17.1: sys::process::unix::common::ChildPipes);\n        StorageDead(_11);\n        StorageLive(_18);\n        StorageLive(_19);\n        _20 = &_10;\n        StorageLive(_21);\n        StorageLive(_22);\n        _22 = &_4;\n        _21 = core::option::Option::<sys::process::unix::common::cstring_array::CStringArray>::as_ref(move _22) -> [return: bb13, unwind unreachable];\n    }\n    bb11: {\n        _16 = move ((_11 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::unix::Process, process::StdioPipes), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_16) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_11);\n        goto -> bb131;\n    }\n    bb13: {\n        StorageDead(_22);\n        _19 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::posix_spawn(_1, _20, move _21) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_21);\n        _18 = <core::result::Result<core::option::Option<sys::process::unix::unix::Process>, io::error::Error> as core::ops::Try>::branch(move _19) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        StorageDead(_19);\n        _23 = discriminant(_18);\n        switchInt(move _23) -> [0: bb16, 1: bb17, otherwise: bb9];\n    }\n    bb16: {\n        _25 = move ((_18 as variant#0).0: core::option::Option<sys::process::unix::unix::Process>);\n        _26 = discriminant(_25);\n        switchInt(move _26) -> [1: bb20, 0: bb19, otherwise: bb9];\n    }\n    bb17: {\n        _24 = move ((_18 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::unix::Process, process::StdioPipes), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_24) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        goto -> bb127;\n    }\n    bb19: {\n        StorageDead(_18);\n        StorageLive(_32);\n        StorageLive(_33);\n        _33 = sys::net::connection::socket::unix::Socket::new_pair(libc::AF_UNIX, libc::SOCK_SEQPACKET) -> [return: bb21, unwind unreachable];\n    }\n    bb20: {\n        _27 = ((_25 as variant#1).0: sys::process::unix::unix::Process);\n        StorageLive(_28);\n        StorageLive(_29);\n        _189 = false;\n        _29 = move _9;\n        _28 = (_27, move _29);\n        StorageDead(_29);\n        _0 = core::result::Result::Ok(move _28);\n        StorageDead(_28);\n        goto -> bb127;\n    }\n    bb21: {\n        _32 = <core::result::Result<(sys::net::connection::socket::unix::Socket, sys::net::connection::socket::unix::Socket), io::error::Error> as core::ops::Try>::branch(move _33) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageDead(_33);\n        _34 = discriminant(_32);\n        switchInt(move _34) -> [0: bb23, 1: bb24, otherwise: bb9];\n    }\n    bb23: {\n        _36 = move ((_32 as variant#0).0: (sys::net::connection::socket::unix::Socket, sys::net::connection::socket::unix::Socket));\n        StorageLive(_30);\n        _30 = (_36.0: sys::net::connection::socket::unix::Socket);\n        StorageLive(_31);\n        _188 = true;\n        _31 = (_36.1: sys::net::connection::socket::unix::Socket);\n        StorageDead(_32);\n        StorageLive(_37);\n        _37 = sys::env::unix::env_read_lock() -> [return: bb26, unwind unreachable];\n    }\n    bb24: {\n        _35 = move ((_32 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::unix::Process, process::StdioPipes), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_35) -> [return: bb25, unwind unreachable];\n    }\n    bb25: {\n        StorageDead(_32);\n        goto -> bb128;\n    }\n    bb26: {\n        _187 = true;\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_fork(_1) -> [return: bb27, unwind unreachable];\n    }\n    bb27: {\n        _38 = <core::result::Result<i32, io::error::Error> as core::ops::Try>::branch(move _39) -> [return: bb28, unwind unreachable];\n    }\n    bb28: {\n        StorageDead(_39);\n        _40 = discriminant(_38);\n        switchInt(move _40) -> [0: bb29, 1: bb30, otherwise: bb9];\n    }\n    bb29: {\n        _42 = ((_38 as variant#0).0: i32);\n        StorageDead(_38);\n        switchInt(_42) -> [0: bb32, otherwise: bb67];\n    }\n    bb30: {\n        _41 = move ((_38 as variant#1).0: core::result::Result<core::convert::Infallible, io::error::Error>);\n        _0 = <core::result::Result<(sys::process::unix::unix::Process, process::StdioPipes), io::error::Error> as core::ops::FromResidual<core::result::Result<core::convert::Infallible, io::error::Error>>>::from_residual(_41) -> [return: bb31, unwind unreachable];\n    }\n    bb31: {\n        StorageDead(_38);\n        goto -> bb123;\n    }\n    bb32: {\n        _43 = panic::always_abort() -> [return: bb33, unwind unreachable];\n    }\n    bb33: {\n        StorageLive(_45);\n        _187 = false;\n        _45 = move _37;\n        _44 = core::mem::forget::<sync::poison::rwlock::RwLockReadGuard<'_, ()>>(move _45) -> [return: bb34, unwind unreachable];\n    }\n    bb34: {\n        StorageDead(_45);\n        StorageLive(_47);\n        _47 = move _30;\n        _46 = core::mem::drop::<sys::net::connection::socket::unix::Socket>(move _47) -> [return: bb35, unwind unreachable];\n    }\n    bb35: {\n        StorageDead(_47);\n        StorageLive(_48);\n        StorageLive(_49);\n        _49 = &(*_1);\n        _48 = sys::process::unix::common::Command::get_create_pidfd(move _49) -> [return: bb36, unwind unreachable];\n    }\n    bb36: {\n        switchInt(move _48) -> [0: bb39, otherwise: bb37];\n    }\n    bb37: {\n        StorageDead(_49);\n        StorageLive(_51);\n        _51 = &(*_1);\n        _52 = &_31;\n        _50 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::send_pidfd(move _51, _52) -> [return: bb38, unwind unreachable];\n    }\n    bb38: {\n        StorageDead(_51);\n        goto -> bb40;\n    }\n    bb39: {\n        StorageDead(_49);\n        goto -> bb40;\n    }\n    bb40: {\n        StorageDead(_48);\n        StorageLive(_54);\n        StorageLive(_55);\n        _55 = move _10;\n        StorageLive(_56);\n        StorageLive(_57);\n        _57 = &_4;\n        _56 = core::option::Option::<sys::process::unix::common::cstring_array::CStringArray>::as_ref(move _57) -> [return: bb41, unwind unreachable];\n    }\n    bb41: {\n        StorageDead(_57);\n        _54 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::do_exec(_1, move _55, move _56) -> [return: bb42, unwind unreachable];\n    }\n    bb42: {\n        StorageDead(_56);\n        StorageDead(_55);\n        StorageLive(_53);\n        _53 = move ((_54 as variant#1).0: io::error::Error);\n        StorageDead(_54);\n        StorageLive(_59);\n        StorageLive(_60);\n        StorageLive(_61);\n        _61 = &_53;\n        _60 = io::error::Error::raw_os_error(move _61) -> [return: bb43, unwind unreachable];\n    }\n    bb43: {\n        StorageDead(_61);\n        _59 = core::option::Option::<i32>::unwrap_or(move _60, libc::EINVAL) -> [return: bb44, unwind unreachable];\n    }\n    bb44: {\n        StorageDead(_60);\n        _58 = move _59 as u32;\n        StorageDead(_59);\n        StorageLive(_62);\n        _62 = core::num::<impl u32>::to_be_bytes(_58) -> [return: bb45, unwind unreachable];\n    }\n    bb45: {\n        StorageLive(_63);\n        StorageLive(_64);\n        StorageLive(_65);\n        _65 = 0_usize;\n        _66 = Lt(_65, 4_usize);\n        assert(move _66, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _65) -> [success: bb46, unwind unreachable];\n    }\n    bb46: {\n        _64 = _62[_65];\n        StorageLive(_67);\n        StorageLive(_68);\n        _68 = 1_usize;\n        _69 = Lt(_68, 4_usize);\n        assert(move _69, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _68) -> [success: bb47, unwind unreachable];\n    }\n    bb47: {\n        _67 = _62[_68];\n        StorageLive(_70);\n        StorageLive(_71);\n        _71 = 2_usize;\n        _72 = Lt(_71, 4_usize);\n        assert(move _72, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _71) -> [success: bb48, unwind unreachable];\n    }\n    bb48: {\n        _70 = _62[_71];\n        StorageLive(_73);\n        StorageLive(_74);\n        _74 = 3_usize;\n        _75 = Lt(_74, 4_usize);\n        assert(move _75, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _74) -> [success: bb49, unwind unreachable];\n    }\n    bb49: {\n        _73 = _62[_74];\n        StorageLive(_76);\n        StorageLive(_77);\n        _77 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn::CLOEXEC_MSG_FOOTER;\n        StorageLive(_78);\n        _78 = 0_usize;\n        _79 = Lt(_78, 4_usize);\n        assert(move _79, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _78) -> [success: bb50, unwind unreachable];\n    }\n    bb50: {\n        _76 = _77[_78];\n        StorageLive(_80);\n        StorageLive(_81);\n        _81 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn::CLOEXEC_MSG_FOOTER;\n        StorageLive(_82);\n        _82 = 1_usize;\n        _83 = Lt(_82, 4_usize);\n        assert(move _83, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _82) -> [success: bb51, unwind unreachable];\n    }\n    bb51: {\n        _80 = _81[_82];\n        StorageLive(_84);\n        StorageLive(_85);\n        _85 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn::CLOEXEC_MSG_FOOTER;\n        StorageLive(_86);\n        _86 = 2_usize;\n        _87 = Lt(_86, 4_usize);\n        assert(move _87, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _86) -> [success: bb52, unwind unreachable];\n    }\n    bb52: {\n        _84 = _85[_86];\n        StorageLive(_88);\n        StorageLive(_89);\n        _89 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn::CLOEXEC_MSG_FOOTER;\n        StorageLive(_90);\n        _90 = 3_usize;\n        _91 = Lt(_90, 4_usize);\n        assert(move _91, \"index out of bounds: the length is {} but the index is {}\", 4_usize, _90) -> [success: bb53, unwind unreachable];\n    }\n    bb53: {\n        _88 = _89[_90];\n        _63 = [move _64, move _67, move _70, move _73, move _76, move _80, move _84, move _88];\n        StorageDead(_88);\n        StorageDead(_84);\n        StorageDead(_80);\n        StorageDead(_76);\n        StorageDead(_73);\n        StorageDead(_70);\n        StorageDead(_67);\n        StorageDead(_64);\n        StorageDead(_90);\n        StorageDead(_89);\n        StorageDead(_86);\n        StorageDead(_85);\n        StorageDead(_82);\n        StorageDead(_81);\n        StorageDead(_78);\n        StorageDead(_77);\n        StorageDead(_74);\n        StorageDead(_71);\n        StorageDead(_68);\n        StorageDead(_65);\n        StorageLive(_92);\n        StorageLive(_93);\n        StorageLive(_94);\n        StorageLive(_95);\n        _95 = &_31;\n        StorageLive(_96);\n        _97 = &_63;\n        _96 = _97 as &[u8];\n        _94 = sys::net::connection::socket::unix::Socket::write(move _95, move _96) -> [return: bb54, unwind unreachable];\n    }\n    bb54: {\n        _93 = &_94;\n        StorageDead(_96);\n        StorageDead(_95);\n        _92 = core::result::Result::<usize, io::error::Error>::is_ok(move _93) -> [return: bb55, unwind unreachable];\n    }\n    bb55: {\n        switchInt(move _92) -> [0: bb57, otherwise: bb56];\n    }\n    bb56: {\n        StorageDead(_93);\n        drop(_94) -> [return: bb66, unwind unreachable];\n    }\n    bb57: {\n        StorageDead(_93);\n        drop(_94) -> [return: bb58, unwind unreachable];\n    }\n    bb58: {\n        StorageDead(_94);\n        StorageLive(_98);\n        _98 = sys::stdio::unix::panic_output() -> [return: bb59, unwind unreachable];\n    }\n    bb59: {\n        _99 = discriminant(_98);\n        switchInt(move _99) -> [1: bb60, 0: bb64, otherwise: bb9];\n    }\n    bb60: {\n        StorageLive(_101);\n        _102 = &mut _100;\n        StorageLive(_103);\n        _103 = core::fmt::Arguments::<'_>::from_str_nonconst(\"fatal runtime error: assertion failed: output.write(&bytes).is_ok(), aborting\\n\") -> [return: bb61, unwind unreachable];\n    }\n    bb61: {\n        _101 = <sys::stdio::unix::Stderr as io::Write>::write_fmt(_102, move _103) -> [return: bb62, unwind unreachable];\n    }\n    bb62: {\n        StorageDead(_103);\n        drop(_101) -> [return: bb63, unwind unreachable];\n    }\n    bb63: {\n        StorageDead(_101);\n        StorageDead(_98);\n        goto -> bb65;\n    }\n    bb64: {\n        StorageDead(_98);\n        goto -> bb65;\n    }\n    bb65: {\n        _104 = process::abort() -> unwind unreachable;\n    }\n    bb66: {\n        StorageDead(_94);\n        StorageDead(_92);\n        _105 = libc::_exit(1_i32) -> unwind unreachable;\n    }\n    bb67: {\n        StorageLive(_107);\n        _187 = false;\n        _107 = move _37;\n        _106 = core::mem::drop::<sync::poison::rwlock::RwLockReadGuard<'_, ()>>(move _107) -> [return: bb68, unwind unreachable];\n    }\n    bb68: {\n        StorageDead(_107);\n        StorageLive(_109);\n        _188 = false;\n        _109 = move _31;\n        _108 = core::mem::drop::<sys::net::connection::socket::unix::Socket>(move _109) -> [return: bb69, unwind unreachable];\n    }\n    bb69: {\n        StorageDead(_109);\n        StorageLive(_110);\n        StorageLive(_111);\n        StorageLive(_112);\n        _112 = &(*_1);\n        _111 = sys::process::unix::common::Command::get_create_pidfd(move _112) -> [return: bb70, unwind unreachable];\n    }\n    bb70: {\n        switchInt(move _111) -> [0: bb73, otherwise: bb71];\n    }\n    bb71: {\n        StorageDead(_112);\n        StorageLive(_113);\n        _113 = &(*_1);\n        _114 = &_30;\n        _110 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::recv_pidfd(move _113, _114) -> [return: bb72, unwind unreachable];\n    }\n    bb72: {\n        StorageDead(_113);\n        goto -> bb74;\n    }\n    bb73: {\n        StorageDead(_112);\n        _110 = -1_i32;\n        goto -> bb74;\n    }\n    bb74: {\n        StorageDead(_111);\n        StorageLive(_115);\n        StorageLive(_116);\n        _116 = _110;\n        _115 = sys::process::unix::unix::Process::new(_42, move _116) -> [return: bb75, unwind unreachable];\n    }\n    bb75: {\n        _186 = true;\n        StorageDead(_116);\n        StorageLive(_117);\n        _117 = [0_u8; 8];\n        goto -> bb76;\n    }\n    bb76: {\n        StorageLive(_118);\n        StorageLive(_119);\n        _119 = &_30;\n        StorageLive(_120);\n        _121 = &mut _117;\n        _120 = _121 as &mut [u8];\n        _118 = sys::net::connection::socket::unix::Socket::read(move _119, move _120) -> [return: bb77, unwind unreachable];\n    }\n    bb77: {\n        StorageDead(_120);\n        StorageDead(_119);\n        _122 = discriminant(_118);\n        switchInt(move _122) -> [0: bb78, 1: bb80, otherwise: bb9];\n    }\n    bb78: {\n        switchInt(((_118 as variant#0).0: usize)) -> [0: bb82, 8: bb81, otherwise: bb79];\n    }\n    bb79: {\n        StorageLive(_175);\n        StorageLive(_176);\n        StorageLive(_177);\n        StorageLive(_178);\n        _178 = &mut _115;\n        _177 = sys::process::unix::unix::Process::wait(move _178) -> [return: bb112, unwind unreachable];\n    }\n    bb80: {\n        StorageLive(_158);\n        StorageLive(_157);\n        _157 = &((_118 as variant#1).0: io::error::Error);\n        _158 = &_157;\n        StorageLive(_159);\n        _183 = (*_158);\n        _159 = io::error::Error::is_interrupted(_183) -> [return: bb100, unwind unreachable];\n    }\n    bb81: {\n        StorageLive(_128);\n        StorageLive(_129);\n        StorageLive(_130);\n        _130 = &_117;\n        _129 = move _130 as &[u8];\n        StorageDead(_130);\n        _128 = core::slice::<impl [u8]>::split_at(move _129, 4_usize) -> [return: bb83, unwind unreachable];\n    }\n    bb82: {\n        StorageLive(_123);\n        StorageLive(_124);\n        _186 = false;\n        _124 = move _115;\n        StorageLive(_125);\n        _189 = false;\n        _125 = move _9;\n        _123 = (move _124, move _125);\n        StorageDead(_125);\n        StorageDead(_124);\n        _0 = core::result::Result::Ok(move _123);\n        StorageDead(_123);\n        goto -> bb121;\n    }\n    bb83: {\n        StorageDead(_129);\n        _126 = (_128.0: &[u8]);\n        StorageLive(_127);\n        _127 = (_128.1: &[u8]);\n        StorageDead(_128);\n        StorageLive(_131);\n        StorageLive(_132);\n        _132 = sys::process::unix::unix::<impl sys::process::unix::common::Command>::spawn::promoted[0];\n        StorageLive(_133);\n        _133 = &_127;\n        _131 = (move _132, move _133);\n        StorageDead(_133);\n        StorageDead(_132);\n        _134 = (_131.0: &[u8; 4]);\n        _135 = (_131.1: &&[u8]);\n        StorageLive(_136);\n        _136 = <[u8; 4] as core::cmp::PartialEq<&[u8]>>::eq(_134, _135) -> [return: bb84, unwind unreachable];\n    }\n    bb84: {\n        switchInt(move _136) -> [0: bb86, otherwise: bb85];\n    }\n    bb85: {\n        StorageDead(_136);\n        StorageDead(_131);\n        StorageLive(_148);\n        StorageLive(_149);\n        _149 = <&[u8] as core::convert::TryInto<[u8; 4]>>::try_into(_126) -> [return: bb89, unwind unreachable];\n    }\n    bb86: {\n        _137 = core::panicking::AssertKind::Eq;\n        StorageLive(_139);\n        StorageLive(_140);\n        StorageLive(_141);\n        StorageLive(_142);\n        _142 = &_117;\n        _141 = (move _142);\n        StorageDead(_142);\n        StorageLive(_143);\n        StorageLive(_144);\n        _184 = (_141.0: &[u8; 8]);\n        _144 = core::fmt::rt::Argument::<'_>::new_debug::<[u8; 8]>(_184) -> [return: bb87, unwind unreachable];\n    }\n    bb87: {\n        _143 = [move _144];\n        StorageDead(_144);\n        StorageLive(_145);\n        _145 = b\"\\'Validation on the CLOEXEC pipe failed: \\xc0\\x00\";\n        _146 = &_143;\n        _140 = core::fmt::Arguments::<'_>::new::<42, 1>(move _145, _146) -> [return: bb88, unwind unreachable];\n    }\n    bb88: {\n        StorageDead(_145);\n        _139 = core::option::Option::Some(move _140);\n        StorageDead(_140);\n        _138 = core::panicking::assert_failed::<[u8; 4], &[u8]>(_137, _134, _135, move _139) -> unwind unreachable;\n    }\n    bb89: {\n        _148 = core::result::Result::<[u8; 4], core::array::TryFromSliceError>::unwrap(move _149) -> [return: bb90, unwind unreachable];\n    }\n    bb90: {\n        StorageDead(_149);\n        _147 = core::num::<impl i32>::from_be_bytes(move _148) -> [return: bb91, unwind unreachable];\n    }\n    bb91: {\n        StorageDead(_148);\n        StorageLive(_150);\n        StorageLive(_151);\n        StorageLive(_152);\n        StorageLive(_153);\n        _153 = &mut _115;\n        _152 = sys::process::unix::unix::Process::wait(move _153) -> [return: bb92, unwind unreachable];\n    }\n    bb92: {\n        _151 = &_152;\n        StorageDead(_153);\n        _150 = core::result::Result::<sys::process::unix::unix::ExitStatus, io::error::Error>::is_ok(move _151) -> [return: bb93, unwind unreachable];\n    }\n    bb93: {\n        switchInt(move _150) -> [0: bb95, otherwise: bb94];\n    }\n    bb94: {\n        StorageDead(_151);\n        drop(_152) -> [return: bb98, unwind unreachable];\n    }\n    bb95: {\n        StorageDead(_151);\n        drop(_152) -> [return: bb96, unwind unreachable];\n    }\n    bb96: {\n        StorageDead(_152);\n        StorageLive(_155);\n        _155 = core::fmt::Arguments::<'_>::from_str(\"wait() should either return Ok or panic\") -> [return: bb97, unwind unreachable];\n    }\n    bb97: {\n        _154 = core::panicking::panic_fmt(move _155) -> unwind unreachable;\n    }\n    bb98: {\n        StorageDead(_152);\n        StorageDead(_150);\n        StorageLive(_156);\n        _156 = io::error::Error::from_raw_os_error(_147) -> [return: bb99, unwind unreachable];\n    }\n    bb99: {\n        _0 = core::result::Result::Err(move _156);\n        StorageDead(_156);\n        StorageDead(_127);\n        goto -> bb121;\n    }\n    bb100: {\n        switchInt(move _159) -> [0: bb102, otherwise: bb101];\n    }\n    bb101: {\n        StorageDead(_159);\n        StorageDead(_157);\n        StorageDead(_158);\n        drop(_118) -> [return: bb120, unwind unreachable];\n    }\n    bb102: {\n        StorageDead(_159);\n        StorageDead(_157);\n        StorageDead(_158);\n        StorageLive(_160);\n        _160 = move ((_118 as variant#1).0: io::error::Error);\n        StorageLive(_161);\n        StorageLive(_162);\n        StorageLive(_163);\n        StorageLive(_164);\n        _164 = &mut _115;\n        _163 = sys::process::unix::unix::Process::wait(move _164) -> [return: bb103, unwind unreachable];\n    }\n    bb103: {\n        _162 = &_163;\n        StorageDead(_164);\n        _161 = core::result::Result::<sys::process::unix::unix::ExitStatus, io::error::Error>::is_ok(move _162) -> [return: bb104, unwind unreachable];\n    }\n    bb104: {\n        switchInt(move _161) -> [0: bb106, otherwise: bb105];\n    }\n    bb105: {\n        StorageDead(_162);\n        drop(_163) -> [return: bb109, unwind unreachable];\n    }\n    bb106: {\n        StorageDead(_162);\n        drop(_163) -> [return: bb107, unwind unreachable];\n    }\n    bb107: {\n        StorageDead(_163);\n        StorageLive(_166);\n        _166 = core::fmt::Arguments::<'_>::from_str(\"wait() should either return Ok or panic\") -> [return: bb108, unwind unreachable];\n    }\n    bb108: {\n        _165 = core::panicking::panic_fmt(move _166) -> unwind unreachable;\n    }\n    bb109: {\n        StorageDead(_163);\n        StorageDead(_161);\n        StorageLive(_168);\n        StorageLive(_169);\n        StorageLive(_170);\n        _170 = &_160;\n        _169 = (move _170);\n        StorageDead(_170);\n        StorageLive(_171);\n        StorageLive(_172);\n        _185 = (_169.0: &io::error::Error);\n        _172 = core::fmt::rt::Argument::<'_>::new_debug::<io::error::Error>(_185) -> [return: bb110, unwind unreachable];\n    }\n    bb110: {\n        _171 = [move _172];\n        StorageDead(_172);\n        StorageLive(_173);\n        _173 = b\"\\x19the CLOEXEC pipe failed: \\xc0\\x00\";\n        _174 = &_171;\n        _168 = core::fmt::Arguments::<'_>::new::<28, 1>(move _173, _174) -> [return: bb111, unwind unreachable];\n    }\n    bb111: {\n        StorageDead(_173);\n        _167 = core::panicking::panic_fmt(move _168) -> unwind unreachable;\n    }\n    bb112: {\n        _176 = &_177;\n        StorageDead(_178);\n        _175 = core::result::Result::<sys::process::unix::unix::ExitStatus, io::error::Error>::is_ok(move _176) -> [return: bb113, unwind unreachable];\n    }\n    bb113: {\n        switchInt(move _175) -> [0: bb115, otherwise: bb114];\n    }\n    bb114: {\n        StorageDead(_176);\n        drop(_177) -> [return: bb118, unwind unreachable];\n    }\n    bb115: {\n        StorageDead(_176);\n        drop(_177) -> [return: bb116, unwind unreachable];\n    }\n    bb116: {\n        StorageDead(_177);\n        StorageLive(_180);\n        _180 = core::fmt::Arguments::<'_>::from_str(\"wait() should either return Ok or panic\") -> [return: bb117, unwind unreachable];\n    }\n    bb117: {\n        _179 = core::panicking::panic_fmt(move _180) -> unwind unreachable;\n    }\n    bb118: {\n        StorageDead(_177);\n        StorageDead(_175);\n        StorageLive(_182);\n        _182 = core::fmt::Arguments::<'_>::from_str(\"short read on the CLOEXEC pipe\") -> [return: bb119, unwind unreachable];\n    }\n    bb119: {\n        _181 = core::panicking::panic_fmt(move _182) -> unwind unreachable;\n    }\n    bb120: {\n        StorageDead(_118);\n        goto -> bb76;\n    }\n    bb121: {\n        StorageDead(_118);\n        StorageDead(_117);\n        switchInt(_186) -> [0: bb122, otherwise: bb134];\n    }\n    bb122: {\n        _186 = false;\n        StorageDead(_115);\n        StorageDead(_110);\n        goto -> bb123;\n    }\n    bb123: {\n        switchInt(_187) -> [0: bb124, otherwise: bb135];\n    }\n    bb124: {\n        _187 = false;\n        StorageDead(_37);\n        switchInt(_188) -> [0: bb125, otherwise: bb136];\n    }\n    bb125: {\n        _188 = false;\n        StorageDead(_31);\n        drop(_30) -> [return: bb126, unwind unreachable];\n    }\n    bb126: {\n        StorageDead(_30);\n        goto -> bb128;\n    }\n    bb127: {\n        StorageDead(_18);\n        goto -> bb128;\n    }\n    bb128: {\n        drop(_10) -> [return: bb129, unwind unreachable];\n    }\n    bb129: {\n        StorageDead(_10);\n        switchInt(_189) -> [0: bb130, otherwise: bb137];\n    }\n    bb130: {\n        _189 = false;\n        StorageDead(_9);\n        goto -> bb131;\n    }\n    bb131: {\n        drop(_4) -> [return: bb132, unwind unreachable];\n    }\n    bb132: {\n        StorageDead(_4);\n        switchInt(_190) -> [0: bb133, otherwise: bb138];\n    }\n    bb133: {\n        return;\n    }\n    bb134: {\n        drop(_115) -> [return: bb122, unwind unreachable];\n    }\n    bb135: {\n        drop(_37) -> [return: bb124, unwind unreachable];\n    }\n    bb136: {\n        drop(_31) -> [return: bb125, unwind unreachable];\n    }\n    bb137: {\n        drop(_9) -> [return: bb130, unwind unreachable];\n    }\n    bb138: {\n        drop(_2) -> [return: bb133, unwind unreachable];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}