{
  "name": "<os::unix::net::addr::SocketAddr as os::net::linux_ext::addr::SocketAddrExt>::from_abstract_name",
  "safe": true,
  "callees": {
    "core::convert::AsRef::as_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Converts this type into a shared reference of the (usually inferred) input type.\n",
      "adt": {}
    },
    "core::mem::zeroed": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the value of type `T` represented by the all-zero byte-pattern.\n\n This means that, for example, the padding byte in `(u8, u16)` is not\n necessarily zeroed.\n\n There is no guarantee that an all-zero byte-pattern represents a valid value\n of some type `T`. For example, the all-zero byte-pattern is not a valid value\n for reference types (`&T`, `&mut T`) and function pointers. Using `zeroed`\n on such types causes immediate [undefined behavior][ub] because [the Rust\n compiler assumes][inv] that there always is a valid value in a variable it\n considers initialized.\n\n This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n It is useful for FFI sometimes, but should generally be avoided.\n\n [zeroed]: MaybeUninit::zeroed\n [ub]: ../../reference/behavior-considered-undefined.html\n [inv]: MaybeUninit#initialization-invariant\n\n # Examples\n\n Correct usage of this function: initializing an integer with zero.\n\n ```\n use std::mem;\n\n let x: i32 = unsafe { mem::zeroed() };\n assert_eq!(0, x);\n ```\n\n *Incorrect* usage of this function: initializing a reference with zero.\n\n ```rust,no_run\n # #![allow(invalid_value)]\n use std::mem;\n\n let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n let _y: fn() = unsafe { mem::zeroed() }; // And again!\n ```\n",
      "adt": {}
    },
    "io::error::Error::from_static_message": {
      "safe": true,
      "tags": {
        "tags": [
          {
            "tag": {
              "typ": null,
              "name": "hidden"
            },
            "args": []
          }
        ],
        "spec": {},
        "docs": [
          "* hidden\n"
        ]
      },
      "doc": " Creates a new I/O error from a known kind of error as well as a constant\n message.\n\n This function does not allocate.\n\n You should not use this directly, and instead use the `const_error!`\n macro: `io::const_error!(ErrorKind::Something, \"some_message\")`.\n\n This function should maybe change to `from_static_message<const MSG: &'static\n str>(kind: ErrorKind)` in the future, when const generics allow that.\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::hint::must_use": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " An identity function that causes an `unused_must_use` warning to be\n triggered if the given value is not used (returned, stored in a variable,\n etc) by the caller.\n\n This is primarily intended for use in macro-generated code, in which a\n [`#[must_use]` attribute][must_use] either on a type or a function would not\n be convenient.\n\n [must_use]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n\n # Example\n\n ```\n #![feature(hint_must_use)]\n\n use core::fmt;\n\n pub struct Error(/* ... */);\n\n #[macro_export]\n macro_rules! make_error {\n     ($($args:expr),*) => {\n         core::hint::must_use({\n             let error = $crate::make_error(core::format_args!($($args),*));\n             error\n         })\n     };\n }\n\n // Implementation detail of make_error! macro.\n #[doc(hidden)]\n pub fn make_error(args: fmt::Arguments<'_>) -> Error {\n     Error(/* ... */)\n }\n\n fn demo() -> Option<Error> {\n     if true {\n         // Oops, meant to write `return Some(make_error!(\"...\"));`\n         Some(make_error!(\"...\"));\n     }\n     None\n }\n #\n # // Make rustdoc not wrap the whole snippet in fn main, so that $crate::make_error works\n # fn main() {}\n ```\n\n In the above example, we'd like an `unused_must_use` lint to apply to the\n value created by `make_error!`. However, neither `#[must_use]` on a struct\n nor `#[must_use]` on a function is appropriate here, so the macro expands\n using `core::hint::must_use` instead.\n\n - We wouldn't want `#[must_use]` on the `struct Error` because that would\n   make the following unproblematic code trigger a warning:\n\n   ```\n   # struct Error;\n   #\n   fn f(arg: &str) -> Result<(), Error>\n   # { Ok(()) }\n\n   #[test]\n   fn t() {\n       // Assert that `f` returns error if passed an empty string.\n       // A value of type `Error` is unused here but that's not a problem.\n       f(\"\").unwrap_err();\n   }\n   ```\n\n - Using `#[must_use]` on `fn make_error` can't help because the return value\n   *is* used, as the right-hand side of a `let` statement. The `let`\n   statement looks useless but is in fact necessary for ensuring that\n   temporaries within the `format_args` expansion are not kept alive past the\n   creation of the `Error`, as keeping them alive past that point can cause\n   autotrait issues in async code:\n\n   ```\n   # #![feature(hint_must_use)]\n   #\n   # struct Error;\n   #\n   # macro_rules! make_error {\n   #     ($($args:expr),*) => {\n   #         core::hint::must_use({\n   #             // If `let` isn't used, then `f()` produces a non-Send future.\n   #             let error = make_error(core::format_args!($($args),*));\n   #             error\n   #         })\n   #     };\n   # }\n   #\n   # fn make_error(args: core::fmt::Arguments<'_>) -> Error {\n   #     Error\n   # }\n   #\n   async fn f() {\n       // Using `let` inside the make_error expansion causes temporaries like\n       // `unsync()` to drop at the semicolon of that `let` statement, which\n       // is prior to the await point. They would otherwise stay around until\n       // the semicolon on *this* statement, which is after the await point,\n       // and the enclosing Future would not implement Send.\n       log(make_error!(\"look: {:p}\", unsync())).await;\n   }\n\n   async fn log(error: Error) {/* ... */}\n\n   // Returns something without a Sync impl.\n   fn unsync() -> *const () {\n       0 as *const ()\n   }\n   #\n   # fn test() {\n   #     fn assert_send(_: impl Send) {}\n   #     assert_send(f());\n   # }\n   ```\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns a raw pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n The caller must also ensure that the memory the pointer (non-transitively) points to\n is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &[1, 2, 4];\n let x_ptr = x.as_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         assert_eq!(x.get_unchecked(i), &*x_ptr.add(i));\n     }\n }\n ```\n\n [`as_mut_ptr`]: slice::as_mut_ptr\n",
      "adt": {}
    },
    "core::slice::<impl [T]>::as_mut_ptr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an unsafe mutable pointer to the slice's buffer.\n\n The caller must ensure that the slice outlives the pointer this\n function returns, or else it will end up dangling.\n\n Modifying the container referenced by this slice may cause its buffer\n to be reallocated, which would also make any pointers to it invalid.\n\n # Examples\n\n ```\n let x = &mut [1, 2, 4];\n let x_ptr = x.as_mut_ptr();\n\n unsafe {\n     for i in 0..x.len() {\n         *x_ptr.add(i) += 2;\n     }\n }\n assert_eq!(x, &[3, 4, 6]);\n ```\n",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::add": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n # Examples\n\n ```\n let mut s: String = \"123\".to_string();\n let ptr: *mut u8 = s.as_mut_ptr();\n\n unsafe {\n     assert_eq!('2', *ptr.add(1) as char);\n     assert_eq!('3', *ptr.add(2) as char);\n }\n ```\n",
      "adt": {}
    },
    "core::ptr::copy_nonoverlapping": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n and destination must *not* overlap.\n\n For regions of memory which might overlap, use [`copy`] instead.\n\n `copy_nonoverlapping` is semantically equivalent to C's [`memcpy`], but\n with the source and destination arguments swapped,\n and `count` counting the number of `T`s instead of bytes.\n\n The copy is \"untyped\" in the sense that data may be uninitialized or otherwise violate the\n requirements of `T`. The initialization state is preserved exactly.\n\n [`memcpy`]: https://en.cppreference.com/w/c/string/byte/memcpy\n\n # Safety\n\n Behavior is undefined if any of the following conditions are violated:\n\n * `src` must be [valid] for reads of `count * size_of::<T>()` bytes.\n\n * `dst` must be [valid] for writes of `count * size_of::<T>()` bytes.\n\n * Both `src` and `dst` must be properly aligned.\n\n * The region of memory beginning at `src` with a size of `count *\n   size_of::<T>()` bytes must *not* overlap with the region of memory\n   beginning at `dst` with the same size.\n\n Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n in the region beginning at `*src` and the region beginning at `*dst` can\n [violate memory safety][read-ownership].\n\n Note that even if the effectively copied size (`count * size_of::<T>()`) is\n `0`, the pointers must be properly aligned.\n\n [`read`]: crate::ptr::read\n [read-ownership]: crate::ptr::read#ownership-of-the-returned-value\n [valid]: crate::ptr#safety\n\n # Examples\n\n Manually implement [`Vec::append`]:\n\n ```\n use std::ptr;\n\n /// Moves all the elements of `src` into `dst`, leaving `src` empty.\n fn append<T>(dst: &mut Vec<T>, src: &mut Vec<T>) {\n     let src_len = src.len();\n     let dst_len = dst.len();\n\n     // Ensure that `dst` has enough capacity to hold all of `src`.\n     dst.reserve(src_len);\n\n     unsafe {\n         // The call to add is always safe because `Vec` will never\n         // allocate more than `isize::MAX` bytes.\n         let dst_ptr = dst.as_mut_ptr().add(dst_len);\n         let src_ptr = src.as_ptr();\n\n         // Truncate `src` without dropping its contents. We do this first,\n         // to avoid problems in case something further down panics.\n         src.set_len(0);\n\n         // The two regions cannot overlap because mutable references do\n         // not alias, and two different vectors cannot own the same\n         // memory.\n         ptr::copy_nonoverlapping(src_ptr, dst_ptr, src_len);\n\n         // Notify `dst` that it now holds the contents of `src`.\n         dst.set_len(dst_len + src_len);\n     }\n }\n\n let mut a = vec!['r'];\n let mut b = vec!['u', 's', 't'];\n\n append(&mut a, &mut b);\n\n assert_eq!(a, &['r', 'u', 's', 't']);\n assert!(b.is_empty());\n ```\n\n [`Vec::append`]: ../../std/vec/struct.Vec.html#method.append\n",
      "adt": {}
    },
    "os::unix::net::addr::SocketAddr::from_parts": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "io::error::Error": "Constructor",
        "core::result::Result": "Constructor"
      }
    }
  },
  "adts": {
    "libc::sockaddr_un": [
      "Plain",
      "Unknown([Field(0, Ty { id: 1225, kind: RigidTy(Uint(U16)) })])",
      "Unknown([Field(1, Ty { id: 8105, kind: RigidTy(Array(Ty { id: 35, kind: RigidTy(Uint(U8)) }, TyConst { kind: Value(Ty { id: 393, kind: RigidTy(Uint(Usize)) }, Allocation { bytes: [Some(108), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0), Some(0)], provenance: ProvenanceMap { ptrs: [] }, align: 8, mutability: Mut }), id: TyConstId(23, ThreadLocalIndex) })) })])"
    ],
    "io::error::Error": [
      "Plain"
    ],
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": 2103,
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/os/unix/net/addr.rs:267:5: 291:6",
  "src": "fn from_abstract_name<N>(name: N) -> crate::io::Result<Self>\n    where\n        N: AsRef<[u8]>,\n    {\n        let name = name.as_ref();\n        unsafe {\n            let mut addr: libc::sockaddr_un = mem::zeroed();\n            addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n\n            if name.len() + 1 > addr.sun_path.len() {\n                return Err(io::const_error!(\n                    io::ErrorKind::InvalidInput,\n                    \"abstract socket name must be shorter than SUN_LEN\",\n                ));\n            }\n\n            crate::ptr::copy_nonoverlapping(\n                name.as_ptr(),\n                addr.sun_path.as_mut_ptr().add(1) as *mut u8,\n                name.len(),\n            );\n            let len = (SUN_PATH_OFFSET + 1 + name.len()) as libc::socklen_t;\n            SocketAddr::from_parts(addr, len)\n        }\n    }",
  "mir": "fn <os::unix::net::addr::SocketAddr as os::net::linux_ext::addr::SocketAddrExt>::from_abstract_name(_1: N) -> core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error> {\n    let mut _0: core::result::Result<os::unix::net::addr::SocketAddr, io::error::Error>;\n    let  _2: &[u8];\n    let mut _3: &N;\n    let mut _4: libc::sockaddr_un;\n    let mut _5: bool;\n    let mut _6: usize;\n    let mut _7: usize;\n    let mut _8: (usize, bool);\n    let mut _9: usize;\n    let mut _10: &[u8];\n    let mut _11: &[u8; 108];\n    let mut _12: io::error::Error;\n    let mut _13: io::error::Error;\n    let  _14: ();\n    let mut _15: *const u8;\n    let mut _16: *mut u8;\n    let mut _17: *mut u8;\n    let mut _18: &mut [u8];\n    let mut _19: &mut [u8; 108];\n    let mut _20: usize;\n    let  _21: u32;\n    let mut _22: usize;\n    let mut _23: usize;\n    let mut _24: (usize, bool);\n    let mut _25: usize;\n    let mut _26: (usize, bool);\n    let mut _27: libc::sockaddr_un;\n    debug name => _1;\n    debug name => _2;\n    debug addr => _4;\n    debug len => _21;\n    bb0: {\n        StorageLive(_3);\n        _3 = &_1;\n        _2 = <N as core::convert::AsRef<[u8]>>::as_ref(move _3) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_3);\n        StorageLive(_4);\n        _4 = core::mem::zeroed::<libc::sockaddr_un>() -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        (_4.0: u16) = libc::AF_UNIX as u16;\n        StorageLive(_5);\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = PtrMetadata(_2);\n        _8 = CheckedAdd(_7, 1_usize);\n        assert(!move (_8.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _7, 1_usize) -> [success: bb3, unwind unreachable];\n    }\n    bb3: {\n        _6 = move (_8.0: usize);\n        StorageDead(_7);\n        StorageLive(_9);\n        StorageLive(_10);\n        StorageLive(_11);\n        _11 = &(_4.1: [u8; 108]);\n        _10 = move _11 as &[u8];\n        StorageDead(_11);\n        _9 = PtrMetadata(move _10);\n        StorageDead(_10);\n        _5 = Gt(move _6, move _9);\n        switchInt(move _5) -> [0: bb7, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_9);\n        StorageDead(_6);\n        StorageLive(_12);\n        StorageLive(_13);\n        _13 = io::error::Error::from_static_message(<os::unix::net::addr::SocketAddr as os::net::linux_ext::addr::SocketAddrExt>::from_abstract_name::<N>::{constant#0}) -> [return: bb5, unwind unreachable];\n    }\n    bb5: {\n        _12 = core::hint::must_use::<io::error::Error>(move _13) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_13);\n        _0 = core::result::Result::Err(move _12);\n        StorageDead(_12);\n        StorageDead(_5);\n        StorageDead(_4);\n        drop(_1) -> [return: bb15, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_9);\n        StorageDead(_6);\n        StorageDead(_5);\n        StorageLive(_15);\n        _15 = core::slice::<impl [u8]>::as_ptr(_2) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageLive(_17);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut (_4.1: [u8; 108]);\n        _18 = move _19 as &mut [u8];\n        StorageDead(_19);\n        _17 = core::slice::<impl [u8]>::as_mut_ptr(move _18) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_18);\n        _16 = core::ptr::mut_ptr::<impl *mut u8>::add(move _17, 1_usize) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_17);\n        StorageLive(_20);\n        _20 = PtrMetadata(_2);\n        _14 = core::ptr::copy_nonoverlapping::<u8>(move _15, _16, move _20) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_20);\n        StorageDead(_15);\n        StorageLive(_22);\n        StorageLive(_23);\n        _24 = CheckedAdd(os::unix::net::addr::SUN_PATH_OFFSET, 1_usize);\n        assert(!move (_24.1: bool), \"attempt to compute `{} + {}`, which would overflow\", os::unix::net::addr::SUN_PATH_OFFSET, 1_usize) -> [success: bb12, unwind unreachable];\n    }\n    bb12: {\n        _23 = move (_24.0: usize);\n        StorageLive(_25);\n        _25 = PtrMetadata(_2);\n        _26 = CheckedAdd(_23, _25);\n        assert(!move (_26.1: bool), \"attempt to compute `{} + {}`, which would overflow\", move _23, move _25) -> [success: bb13, unwind unreachable];\n    }\n    bb13: {\n        _22 = move (_26.0: usize);\n        StorageDead(_25);\n        StorageDead(_23);\n        _21 = move _22 as u32;\n        StorageDead(_22);\n        StorageLive(_27);\n        _27 = _4;\n        _0 = os::unix::net::addr::SocketAddr::from_parts(move _27, _21) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_27);\n        StorageDead(_4);\n        drop(_1) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}