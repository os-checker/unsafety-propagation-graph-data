{
  "name": "sys::io::kernel_copy::linux::CopyRead::drain_to",
  "safe": true,
  "callees": {},
  "adts": {
    "core::result::Result": [
      "Plain"
    ]
  },
  "path": "sys::io::kernel_copy::linux::CopyRead::drain_to",
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/io/kernel_copy/linux.rs:277:5: 279:6",
  "src": "fn drain_to<W: Write>(&mut self, _writer: &mut W, _limit: u64) -> Result<u64> {\n        Ok(0)\n    }",
  "mir": "fn sys::io::kernel_copy::linux::CopyRead::drain_to(_1: &mut Self, _2: &mut W, _3: u64) -> core::result::Result<u64, io::error::Error> {\n    let mut _0: core::result::Result<u64, io::error::Error>;\n    debug self => _1;\n    debug _writer => _2;\n    debug _limit => _3;\n    bb0: {\n        _0 = core::result::Result::Ok(0_u64);\n        return;\n    }\n}\n",
  "doc": " Implementations that contain buffers (i.e. `BufReader`) must transfer data from their internal\n buffers into `writer` until either the buffers are emptied or `limit` bytes have been\n transferred, whichever occurs sooner.\n If nested buffers are present the outer buffers must be drained first.\n\n This is necessary to directly bypass the wrapper types while preserving the data order\n when operating directly on the underlying file descriptors.\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}