{
  "name": "<sync::poison::rwlock::RwLock<T> as core::fmt::Debug>::fmt",
  "safe": true,
  "callees": {
    "core::fmt::Formatter::<'a>::debug_struct": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Creates a [`DebugStruct`] builder designed to assist with creation of\n [`fmt::Debug`] implementations for structs.\n\n [`fmt::Debug`]: self::Debug\n\n # Examples\n\n ```rust\n use std::fmt;\n use std::net::Ipv4Addr;\n\n struct Foo {\n     bar: i32,\n     baz: String,\n     addr: Ipv4Addr,\n }\n\n impl fmt::Debug for Foo {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Foo\")\n             .field(\"bar\", &self.bar)\n             .field(\"baz\", &self.baz)\n             .field(\"addr\", &format_args!(\"{}\", self.addr))\n             .finish()\n     }\n }\n\n assert_eq!(\n     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n     format!(\"{:?}\", Foo {\n         bar: 10,\n         baz: \"Hello World\".to_string(),\n         addr: Ipv4Addr::new(127, 0, 0, 1),\n     })\n );\n ```\n",
      "adt": {}
    },
    "sync::poison::rwlock::RwLock::<T>::try_read": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Attempts to acquire this `RwLock` with shared read access.\n\n If the access could not be granted at this time, then `Err` is returned.\n Otherwise, an RAII guard is returned which will release the shared access\n when it is dropped.\n\n This function does not block.\n\n This function does not provide any guarantees with respect to the ordering\n of whether contentious readers or writers will acquire the lock first.\n\n # Errors\n\n This function will return the [`Poisoned`] error if the `RwLock` is\n poisoned. An `RwLock` is poisoned whenever a writer panics while holding\n an exclusive lock. `Poisoned` will only be returned if the lock would\n have otherwise been acquired. An acquired lock guard will be contained\n in the returned error.\n\n This function will return the [`WouldBlock`] error if the `RwLock` could\n not be acquired because it was already locked exclusively.\n\n [`Poisoned`]: TryLockError::Poisoned\n [`WouldBlock`]: TryLockError::WouldBlock\n\n # Examples\n\n ```\n use std::sync::RwLock;\n\n let lock = RwLock::new(1);\n\n match lock.try_read() {\n     Ok(n) => assert_eq!(*n, 1),\n     Err(_) => unreachable!(),\n };\n ```\n",
      "adt": {
        "sync::poison::rwlock::RwLock": "ImmutableAsArgument",
        "core::result::Result": "Constructor",
        "sync::poison::rwlock::RwLockReadGuard": "Constructor"
      }
    },
    "core::fmt::Arguments::<'a>::from_str": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Create a `fmt::Arguments` object for a single static string.\n\n Formatting this `fmt::Arguments` will just produce the string as-is.\n",
      "adt": {}
    },
    "sync::poison::PoisonError::<T>::get_ref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Reaches into this error indicating that a lock is poisoned, returning a\n reference to the associated data.\n",
      "adt": {
        "sync::poison::PoisonError": "ImmutableAsArgument"
      }
    },
    "core::ops::Deref::deref": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Dereferences the value.\n",
      "adt": {}
    },
    "core::fmt::DebugStruct::<'a, 'b>::field": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Adds a new field to the generated struct output.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     another: String,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar) // We add `bar` field.\n            .field(\"another\", &self.another) // We add `another` field.\n            // We even add a field which doesn't exist (because why not?).\n            .field(\"nonexistent_field\", &1)\n            .finish() // We're good to go!\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n     r#\"Bar { bar: 10, another: \"Hello World\", nonexistent_field: 1 }\"#,\n );\n ```\n",
      "adt": {}
    },
    "core::fmt::DebugStruct::<'a, 'b>::finish_non_exhaustive": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Marks the struct as non-exhaustive, indicating to the reader that there are some other\n fields that are not shown in the debug representation.\n\n # Examples\n\n ```\n use std::fmt;\n\n struct Bar {\n     bar: i32,\n     hidden: f32,\n }\n\n impl fmt::Debug for Bar {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt.debug_struct(\"Bar\")\n            .field(\"bar\", &self.bar)\n            .finish_non_exhaustive() // Show that some other field(s) exist.\n     }\n }\n\n assert_eq!(\n     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n     \"Bar { bar: 10, .. }\",\n );\n ```\n",
      "adt": {}
    },
    "sync::poison::Flag::get": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "sync::poison::Flag": "ImmutableAsArgument"
      }
    }
  },
  "adts": {
    "core::fmt::Formatter": [
      "MutRef"
    ],
    "core::fmt::DebugStruct": [
      "Plain",
      "MutRef"
    ],
    "sync::poison::rwlock::RwLock": [
      "Ref",
      "DerefVariantField(VariantIdx(None)-FieldIdx(Some(1)))"
    ],
    "core::result::Result": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12288, kind: RigidTy(Adt(AdtDef(DefId { id: 9938, name: \"sync::poison::TryLockError\" }), GenericArgs([Type(Ty { id: 12262, kind: RigidTy(Adt(AdtDef(DefId { id: 9986, name: \"sync::poison::rwlock::RwLockReadGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 12288, kind: RigidTy(Adt(AdtDef(DefId { id: 9938, name: \"sync::poison::TryLockError\" }), GenericArgs([Type(Ty { id: 12262, kind: RigidTy(Adt(AdtDef(DefId { id: 9986, name: \"sync::poison::rwlock::RwLockReadGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) }), Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12266, kind: RigidTy(Adt(AdtDef(DefId { id: 9910, name: \"sync::poison::PoisonError\" }), GenericArgs([Type(Ty { id: 12262, kind: RigidTy(Adt(AdtDef(DefId { id: 9986, name: \"sync::poison::rwlock::RwLockReadGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })]))) })])",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12262, kind: RigidTy(Adt(AdtDef(DefId { id: 9986, name: \"sync::poison::rwlock::RwLockReadGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "core::fmt::Arguments": [
      "Plain",
      "Ref"
    ],
    "sync::poison::PoisonError": [
      "Plain",
      "Ref"
    ],
    "sync::poison::rwlock::RwLockReadGuard": [
      "Ref",
      "Plain"
    ],
    "sync::poison::Flag": [
      "Ref"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::<sync::poison::rwlock::RwLock<T> as core::fmt::Debug>::fmt"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/rwlock.rs:683:5: 698:6",
  "src": "fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut d = f.debug_struct(\"RwLock\");\n        match self.try_read() {\n            Ok(guard) => {\n                d.field(\"data\", &&*guard);\n            }\n            Err(TryLockError::Poisoned(err)) => {\n                d.field(\"data\", &&**err.get_ref());\n            }\n            Err(TryLockError::WouldBlock) => {\n                d.field(\"data\", &format_args!(\"<locked>\"));\n            }\n        }\n        d.field(\"poisoned\", &self.poison.get());\n        d.finish_non_exhaustive()\n    }",
  "mir": "fn <sync::poison::rwlock::RwLock<T> as core::fmt::Debug>::fmt(_1: &sync::poison::rwlock::RwLock<T>, _2: &mut core::fmt::Formatter<'_>) -> core::result::Result<(), core::fmt::Error> {\n    let mut _0: core::result::Result<(), core::fmt::Error>;\n    let mut _3: core::fmt::DebugStruct<'_, '_>;\n    let mut _4: &str;\n    let mut _5: core::result::Result<sync::poison::rwlock::RwLockReadGuard<'_, T>, sync::poison::TryLockError<sync::poison::rwlock::RwLockReadGuard<'_, T>>>;\n    let mut _6: isize;\n    let mut _7: isize;\n    let  _8: sync::poison::rwlock::RwLockReadGuard<'_, T>;\n    let  _9: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _10: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _11: &str;\n    let mut _12: &dyn core::fmt::Debug;\n    let  _13: &&T;\n    let  _14: &T;\n    let  _15: &T;\n    let mut _16: &sync::poison::rwlock::RwLockReadGuard<'_, T>;\n    let  _17: sync::poison::PoisonError<sync::poison::rwlock::RwLockReadGuard<'_, T>>;\n    let  _18: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _19: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _20: &str;\n    let mut _21: &dyn core::fmt::Debug;\n    let  _22: &&T;\n    let  _23: &T;\n    let  _24: &T;\n    let  _25: &sync::poison::rwlock::RwLockReadGuard<'_, T>;\n    let mut _26: &sync::poison::PoisonError<sync::poison::rwlock::RwLockReadGuard<'_, T>>;\n    let  _27: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _28: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _29: &str;\n    let mut _30: &dyn core::fmt::Debug;\n    let  _31: &core::fmt::Arguments<'_>;\n    let  _32: core::fmt::Arguments<'_>;\n    let  _33: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _34: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _35: &str;\n    let mut _36: &dyn core::fmt::Debug;\n    let  _37: &bool;\n    let  _38: bool;\n    let mut _39: &sync::poison::Flag;\n    let mut _40: &mut core::fmt::DebugStruct<'_, '_>;\n    let mut _41: isize;\n    debug self => _1;\n    debug f => _2;\n    debug d => _3;\n    debug guard => _8;\n    debug err => _17;\n    bb0: {\n        StorageLive(_3);\n        StorageLive(_4);\n        _4 = \"RwLock\";\n        _3 = core::fmt::Formatter::<'_>::debug_struct(_2, move _4) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageDead(_4);\n        StorageLive(_5);\n        _5 = sync::poison::rwlock::RwLock::<T>::try_read(_1) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        _7 = discriminant(_5);\n        switchInt(move _7) -> [0: bb7, 1: bb4, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _6 = discriminant(((_5 as variant#1).0: sync::poison::TryLockError<sync::poison::rwlock::RwLockReadGuard<'_, T>>));\n        switchInt(move _6) -> [0: bb6, 1: bb5, otherwise: bb3];\n    }\n    bb5: {\n        StorageLive(_27);\n        StorageLive(_28);\n        _28 = &mut _3;\n        StorageLive(_29);\n        _29 = \"data\";\n        StorageLive(_30);\n        StorageLive(_32);\n        _32 = core::fmt::Arguments::<'_>::from_str(\"<locked>\") -> [return: bb15, unwind unreachable];\n    }\n    bb6: {\n        StorageLive(_17);\n        _17 = move ((((_5 as variant#1).0: sync::poison::TryLockError<sync::poison::rwlock::RwLockReadGuard<'_, T>>) as variant#0).0: sync::poison::PoisonError<sync::poison::rwlock::RwLockReadGuard<'_, T>>);\n        StorageLive(_18);\n        StorageLive(_19);\n        _19 = &mut _3;\n        StorageLive(_20);\n        _20 = \"data\";\n        StorageLive(_21);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_26);\n        _26 = &_17;\n        _25 = sync::poison::PoisonError::<sync::poison::rwlock::RwLockReadGuard<'_, T>>::get_ref(move _26) -> [return: bb11, unwind unreachable];\n    }\n    bb7: {\n        StorageLive(_8);\n        _8 = move ((_5 as variant#0).0: sync::poison::rwlock::RwLockReadGuard<'_, T>);\n        StorageLive(_9);\n        StorageLive(_10);\n        _10 = &mut _3;\n        StorageLive(_11);\n        _11 = \"data\";\n        StorageLive(_12);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_8;\n        _15 = <sync::poison::rwlock::RwLockReadGuard<'_, T> as core::ops::Deref>::deref(move _16) -> [return: bb8, unwind unreachable];\n    }\n    bb8: {\n        StorageDead(_16);\n        _14 = _15;\n        _13 = &_14;\n        _12 = _13 as &dyn core::fmt::Debug;\n        _9 = core::fmt::DebugStruct::<'_, '_>::field(move _10, move _11, move _12) -> [return: bb9, unwind unreachable];\n    }\n    bb9: {\n        StorageDead(_12);\n        StorageDead(_11);\n        StorageDead(_10);\n        StorageDead(_15);\n        StorageDead(_14);\n        StorageDead(_9);\n        drop(_8) -> [return: bb10, unwind unreachable];\n    }\n    bb10: {\n        StorageDead(_8);\n        goto -> bb22;\n    }\n    bb11: {\n        StorageDead(_26);\n        _24 = <sync::poison::rwlock::RwLockReadGuard<'_, T> as core::ops::Deref>::deref(_25) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _23 = _24;\n        _22 = &_23;\n        _21 = _22 as &dyn core::fmt::Debug;\n        _18 = core::fmt::DebugStruct::<'_, '_>::field(move _19, move _20, move _21) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        StorageDead(_21);\n        StorageDead(_20);\n        StorageDead(_19);\n        StorageDead(_24);\n        StorageDead(_23);\n        StorageDead(_18);\n        drop(_17) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_17);\n        goto -> bb22;\n    }\n    bb15: {\n        _31 = &_32;\n        _30 = _31 as &dyn core::fmt::Debug;\n        _27 = core::fmt::DebugStruct::<'_, '_>::field(move _28, move _29, move _30) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        StorageDead(_30);\n        StorageDead(_29);\n        StorageDead(_28);\n        StorageDead(_32);\n        StorageDead(_27);\n        goto -> bb22;\n    }\n    bb17: {\n        StorageDead(_39);\n        _37 = &_38;\n        _36 = _37 as &dyn core::fmt::Debug;\n        _33 = core::fmt::DebugStruct::<'_, '_>::field(move _34, move _35, move _36) -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        StorageDead(_36);\n        StorageDead(_35);\n        StorageDead(_34);\n        StorageDead(_38);\n        StorageDead(_33);\n        StorageLive(_40);\n        _40 = &mut _3;\n        _0 = core::fmt::DebugStruct::<'_, '_>::finish_non_exhaustive(move _40) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        StorageDead(_40);\n        StorageDead(_3);\n        return;\n    }\n    bb20: {\n        StorageDead(_5);\n        StorageLive(_33);\n        StorageLive(_34);\n        _34 = &mut _3;\n        StorageLive(_35);\n        _35 = \"poisoned\";\n        StorageLive(_36);\n        StorageLive(_38);\n        StorageLive(_39);\n        _39 = &((*_1).1: sync::poison::Flag);\n        _38 = sync::poison::Flag::get(move _39) -> [return: bb17, unwind unreachable];\n    }\n    bb21: {\n        goto -> bb20;\n    }\n    bb22: {\n        _41 = discriminant(_5);\n        switchInt(move _41) -> [0: bb20, 1: bb21, otherwise: bb3];\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}