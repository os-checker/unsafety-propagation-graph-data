{
  "name": "sync::poison::condvar::Condvar::wait_timeout_while",
  "safe": true,
  "callees": {
    "time::Instant::now": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an instant corresponding to \"now\".\n\n # Examples\n\n ```\n use std::time::Instant;\n\n let now = Instant::now();\n ```\n",
      "adt": {
        "time::Instant": "Constructor"
      }
    },
    "core::ops::DerefMut::deref_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Mutably dereferences the value.\n",
      "adt": {}
    },
    "core::ops::FnMut::call_mut": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Performs the call operation.\n",
      "adt": {}
    },
    "time::Instant::elapsed": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns the amount of time elapsed since this instant.\n\n # Panics\n\n Previous Rust versions panicked when the current time was earlier than self. Currently this\n method returns a Duration of zero in that case. Future versions may reintroduce the panic.\n See [Monotonicity].\n\n [Monotonicity]: Instant#monotonicity\n\n # Examples\n\n ```no_run\n use std::thread::sleep;\n use std::time::{Duration, Instant};\n\n let instant = Instant::now();\n let three_secs = Duration::from_secs(3);\n sleep(three_secs);\n assert!(instant.elapsed() >= three_secs);\n ```\n",
      "adt": {
        "time::Instant": "MutableAsArgument",
        "core::time::Duration": "Constructor"
      }
    },
    "core::time::Duration::checked_sub": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n if the result would be negative or if overflow occurred.\n\n # Examples\n\n ```\n use std::time::Duration;\n\n assert_eq!(Duration::new(0, 1).checked_sub(Duration::new(0, 0)), Some(Duration::new(0, 1)));\n assert_eq!(Duration::new(0, 0).checked_sub(Duration::new(0, 1)), None);\n ```\n",
      "adt": {}
    },
    "sync::poison::condvar::Condvar::wait_timeout": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Waits on this condition variable for a notification, timing out after a\n specified duration.\n\n The semantics of this function are equivalent to [`wait`] except that\n the thread will be blocked for roughly no longer than `dur`. This\n method should not be used for precise timing due to anomalies such as\n preemption or platform differences that might not cause the maximum\n amount of time waited to be precisely `dur`.\n\n Note that the best effort is made to ensure that the time waited is\n measured with a monotonic clock, and not affected by the changes made to\n the system time. This function is susceptible to spurious wakeups.\n Condition variables normally have a boolean predicate associated with\n them, and the predicate must always be checked each time this function\n returns to protect against spurious wakeups. Furthermore, since the timeout\n is given relative to the moment this function is called, it needs to be adjusted\n when this function is called in a loop. The [`wait_timeout_while`] method\n lets you wait with a timeout while a predicate is true, taking care of all these concerns.\n\n The returned [`WaitTimeoutResult`] value indicates if the timeout is\n known to have elapsed.\n\n Like [`wait`], the lock specified will be re-acquired when this function\n returns, regardless of whether the timeout elapsed or not.\n\n [`wait`]: Self::wait\n [`wait_timeout_while`]: Self::wait_timeout_while\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex, Condvar};\n use std::thread;\n use std::time::Duration;\n\n let pair = Arc::new((Mutex::new(false), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut started = lock.lock().unwrap();\n     *started = true;\n     // We notify the condvar that the value has changed.\n     cvar.notify_one();\n });\n\n // wait for the thread to start up\n let (lock, cvar) = &*pair;\n let mut started = lock.lock().unwrap();\n // as long as the value inside the `Mutex<bool>` is `false`, we wait\n loop {\n     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n     // 10 milliseconds have passed, or maybe the value changed!\n     started = result.0;\n     if *started == true {\n         // We received the notification and the value has been updated, we can leave.\n         break\n     }\n }\n ```\n",
      "adt": {
        "sync::poison::mutex::MutexGuard": "Constructor",
        "sync::WaitTimeoutResult": "Constructor",
        "core::result::Result": "Constructor",
        "sync::poison::condvar::Condvar": "ImmutableAsArgument"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    }
  },
  "adts": {
    "time::Instant": [
      "Plain",
      "Ref"
    ],
    "sync::poison::mutex::MutexGuard": [
      "MutRef",
      "Plain",
      "Unknown([Field(0, Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "core::time::Duration": [
      "Plain"
    ],
    "sync::WaitTimeoutResult": [
      "Plain",
      "Unknown([Field(0, Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) })])"
    ],
    "core::result::Result": [
      "Plain"
    ],
    "core::option::Option": [
      "Plain",
      "Unknown([Downcast(VariantIdx(1, ThreadLocalIndex)), Field(0, Ty { id: 609, kind: RigidTy(Adt(AdtDef(DefId { id: 4607, name: \"core::time::Duration\" }), GenericArgs([]))) })])"
    ],
    "sync::poison::condvar::Condvar": [
      "Ref"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 12102, kind: RigidTy(Tuple([Ty { id: 12070, kind: RigidTy(Adt(AdtDef(DefId { id: 7214, name: \"sync::poison::mutex::MutexGuard\" }), GenericArgs([Lifetime(Region { kind: ReErased }), Type(Ty { id: 9, kind: Param(ParamTy { index: 0, name: \"T\" }) })]))) }, Ty { id: 11761, kind: RigidTy(Adt(AdtDef(DefId { id: 9778, name: \"sync::WaitTimeoutResult\" }), GenericArgs([]))) }])) })])"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sync::poison::condvar::Condvar::wait_timeout_while"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sync/poison/condvar.rs:390:5: 410:6",
  "src": "pub fn wait_timeout_while<'a, T, F>(\n        &self,\n        mut guard: MutexGuard<'a, T>,\n        dur: Duration,\n        mut condition: F,\n    ) -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)>\n    where\n        F: FnMut(&mut T) -> bool,\n    {\n        let start = Instant::now();\n        loop {\n            if !condition(&mut *guard) {\n                return Ok((guard, WaitTimeoutResult(false)));\n            }\n            let timeout = match dur.checked_sub(start.elapsed()) {\n                Some(timeout) => timeout,\n                None => return Ok((guard, WaitTimeoutResult(true))),\n            };\n            guard = self.wait_timeout(guard, timeout)?.0;\n        }\n    }",
  "mir": "fn sync::poison::condvar::Condvar::wait_timeout_while(_1: &sync::poison::condvar::Condvar, _2: sync::poison::mutex::MutexGuard<'_, T>, _3: core::time::Duration, _4: F) -> core::result::Result<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult), sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>> {\n    let mut _0: core::result::Result<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult), sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>>;\n    let  _5: time::Instant;\n    let mut _6: bool;\n    let mut _7: &mut F;\n    let mut _8: (&mut T,);\n    let mut _9: &mut T;\n    let mut _10: &mut sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _11: (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult);\n    let mut _12: sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _13: sync::WaitTimeoutResult;\n    let mut _14: core::option::Option<core::time::Duration>;\n    let mut _15: core::time::Duration;\n    let mut _16: &time::Instant;\n    let mut _17: isize;\n    let  _18: core::time::Duration;\n    let mut _19: (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult);\n    let mut _20: sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _21: sync::WaitTimeoutResult;\n    let mut _22: sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _23: core::ops::ControlFlow<core::result::Result<core::convert::Infallible, sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>>, (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>;\n    let mut _24: core::result::Result<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult), sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>>;\n    let mut _25: sync::poison::mutex::MutexGuard<'_, T>;\n    let mut _26: isize;\n    let  _27: core::result::Result<core::convert::Infallible, sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>>;\n    let  _28: (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult);\n    debug self => _1;\n    debug guard => _2;\n    debug dur => _3;\n    debug condition => _4;\n    debug start => _5;\n    debug timeout => _18;\n    debug timeout => _18;\n    debug residual => _27;\n    debug val => _28;\n    bb0: {\n        StorageLive(_5);\n        _5 = time::Instant::now() -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        StorageLive(_6);\n        StorageLive(_7);\n        _7 = &mut _4;\n        StorageLive(_8);\n        StorageLive(_10);\n        _10 = &mut _2;\n        _9 = <sync::poison::mutex::MutexGuard<'_, T> as core::ops::DerefMut>::deref_mut(move _10) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_10);\n        _8 = (_9);\n        _6 = <F as core::ops::FnMut<(&mut T,)>>::call_mut(move _7, move _8) -> [return: bb3, unwind unreachable];\n    }\n    bb3: {\n        switchInt(move _6) -> [0: bb5, otherwise: bb4];\n    }\n    bb4: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageDead(_6);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = &_5;\n        _15 = time::Instant::elapsed(move _16) -> [return: bb6, unwind unreachable];\n    }\n    bb5: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_11);\n        StorageLive(_12);\n        _12 = move _2;\n        StorageLive(_13);\n        _13 = WaitTimeoutResult(false);\n        _11 = (move _12, move _13);\n        StorageDead(_13);\n        StorageDead(_12);\n        _0 = core::result::Result::Ok(move _11);\n        StorageDead(_11);\n        StorageDead(_6);\n        goto -> bb14;\n    }\n    bb6: {\n        StorageDead(_16);\n        _14 = core::time::Duration::checked_sub(_3, move _15) -> [return: bb7, unwind unreachable];\n    }\n    bb7: {\n        StorageDead(_15);\n        _17 = discriminant(_14);\n        switchInt(move _17) -> [0: bb9, 1: bb10, otherwise: bb8];\n    }\n    bb8: {\n        unreachable;\n    }\n    bb9: {\n        StorageLive(_19);\n        StorageLive(_20);\n        _20 = move _2;\n        StorageLive(_21);\n        _21 = WaitTimeoutResult(true);\n        _19 = (move _20, move _21);\n        StorageDead(_21);\n        StorageDead(_20);\n        _0 = core::result::Result::Ok(move _19);\n        StorageDead(_19);\n        StorageDead(_14);\n        goto -> bb14;\n    }\n    bb10: {\n        _18 = ((_14 as variant#1).0: core::time::Duration);\n        StorageDead(_14);\n        StorageLive(_22);\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        _25 = move _2;\n        _24 = sync::poison::condvar::Condvar::wait_timeout::<T>(_1, move _25, _18) -> [return: bb11, unwind unreachable];\n    }\n    bb11: {\n        StorageDead(_25);\n        _23 = <core::result::Result<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult), sync::poison::PoisonError<(sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult)>> as core::ops::Try>::branch(move _24) -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        StorageDead(_24);\n        _26 = discriminant(_23);\n        switchInt(move _26) -> [0: bb13, otherwise: bb8];\n    }\n    bb13: {\n        _28 = move ((_23 as variant#0).0: (sync::poison::mutex::MutexGuard<'_, T>, sync::WaitTimeoutResult));\n        _22 = (_28.0: sync::poison::mutex::MutexGuard<'_, T>);\n        _2 = move _22;\n        StorageDead(_22);\n        StorageDead(_23);\n        goto -> bb1;\n    }\n    bb14: {\n        StorageDead(_5);\n        drop(_4) -> [return: bb15, unwind unreachable];\n    }\n    bb15: {\n        return;\n    }\n}\n",
  "doc": " Waits on this condition variable for a notification, timing out after a\n specified duration.\n\n The semantics of this function are equivalent to [`wait_while`] except\n that the thread will be blocked for roughly no longer than `dur`. This\n method should not be used for precise timing due to anomalies such as\n preemption or platform differences that might not cause the maximum\n amount of time waited to be precisely `dur`.\n\n Note that the best effort is made to ensure that the time waited is\n measured with a monotonic clock, and not affected by the changes made to\n the system time.\n\n The returned [`WaitTimeoutResult`] value indicates if the timeout is\n known to have elapsed without the condition being met.\n\n Like [`wait_while`], the lock specified will be re-acquired when this\n function returns, regardless of whether the timeout elapsed or not.\n\n [`wait_while`]: Self::wait_while\n [`wait_timeout`]: Self::wait_timeout\n\n # Examples\n\n ```\n use std::sync::{Arc, Mutex, Condvar};\n use std::thread;\n use std::time::Duration;\n\n let pair = Arc::new((Mutex::new(true), Condvar::new()));\n let pair2 = Arc::clone(&pair);\n\n thread::spawn(move || {\n     let (lock, cvar) = &*pair2;\n     let mut pending = lock.lock().unwrap();\n     *pending = false;\n     // We notify the condvar that the value has changed.\n     cvar.notify_one();\n });\n\n // wait for the thread to start up\n let (lock, cvar) = &*pair;\n let result = cvar.wait_timeout_while(\n     lock.lock().unwrap(),\n     Duration::from_millis(100),\n     |&mut pending| pending,\n ).unwrap();\n if result.1.timed_out() {\n     // timed-out without the condition ever evaluating to false.\n }\n // access the locked mutex via result.0\n ```\n",
  "tags": {
    "tags": [],
    "spec": {},
    "docs": []
  }
}