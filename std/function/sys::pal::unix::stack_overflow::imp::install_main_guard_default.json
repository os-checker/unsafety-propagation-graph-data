{
  "name": "sys::pal::unix::stack_overflow::imp::install_main_guard_default",
  "safe": false,
  "callees": {
    "sys::pal::unix::stack_overflow::imp::stack_start_aligned": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {
        "core::option::Option": "Constructor"
      }
    },
    "core::ops::Try::branch": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Used in `?` to decide whether the operator should produce a value\n (because this returned [`ControlFlow::Continue`])\n or propagate a value back to the caller\n (because this returned [`ControlFlow::Break`]).\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, Try};\n\n assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n assert_eq!(Err::<String, _>(3).branch(), ControlFlow::Break(Err(3)));\n\n assert_eq!(Some(3).branch(), ControlFlow::Continue(3));\n assert_eq!(None::<String>.branch(), ControlFlow::Break(None));\n\n assert_eq!(ControlFlow::<String, _>::Continue(3).branch(), ControlFlow::Continue(3));\n assert_eq!(\n     ControlFlow::<_, String>::Break(3).branch(),\n     ControlFlow::Break(ControlFlow::Break(3)),\n );\n ```\n",
      "adt": {}
    },
    "libc::mmap64": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ops::FromResidual::from_residual": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Constructs the type from a compatible `Residual` type.\n\n This should be implemented consistently with the `branch` method such\n that applying the `?` operator will get back an equivalent residual:\n `FromResidual::from_residual(r).branch() --> ControlFlow::Break(r)`.\n (The residual is not mandated to be *identical* when interconversion is involved.)\n\n # Examples\n\n ```\n #![feature(try_trait_v2)]\n use std::ops::{ControlFlow, FromResidual};\n\n assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));\n assert_eq!(Option::<String>::from_residual(None), None);\n assert_eq!(\n     ControlFlow::<_, String>::from_residual(ControlFlow::Break(5)),\n     ControlFlow::Break(5),\n );\n ```\n",
      "adt": {}
    },
    "io::error::Error::last_os_error": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " Returns an error representing the last OS error which occurred.\n\n This function reads the value of `errno` for the target platform (e.g.\n `GetLastError` on Windows) and will return a corresponding instance of\n [`Error`] for the error code.\n\n This should be called immediately after a call to a platform function,\n otherwise the state of the error value is indeterminate. In particular,\n other standard library functions may call platform functions that may\n (or may not) reset the error value even if they succeed.\n\n # Examples\n\n ```\n use std::io::Error;\n\n let os_error = Error::last_os_error();\n println!(\"last OS error: {os_error:?}\");\n ```\n",
      "adt": {
        "io::error::Error": "Constructor"
      }
    },
    "core::fmt::rt::Argument::<'_>::new_display": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::fmt::Arguments::<'a>::new": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::panicking::panic_fmt": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": " The entry point for panicking with a formatted message.\n\n This is designed to reduce the amount of code required at the call\n site as much as possible (so that `panic!()` has as low an impact\n on (e.g.) the inlining of other functions as possible), by moving\n the actual formatting into this shared place.\n",
      "adt": {}
    },
    "libc::mprotect": {
      "safe": false,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "",
      "adt": {}
    },
    "core::ptr::mut_ptr::<impl *mut T>::addr": {
      "safe": true,
      "tags": {
        "tags": [],
        "spec": {},
        "docs": []
      },
      "doc": "\n [without_provenance]: without_provenance_mut\n",
      "adt": {}
    }
  },
  "adts": {
    "core::option::Option": [
      "Plain"
    ],
    "core::ops::ControlFlow": [
      "Plain",
      "Unknown([Downcast(VariantIdx(0, ThreadLocalIndex)), Field(0, Ty { id: 1128, kind: RigidTy(RawPtr(Ty { id: 1135, kind: RigidTy(Adt(AdtDef(DefId { id: 8156, name: \"libc::c_void\" }), GenericArgs([]))) }, Mut)) })])"
    ],
    "io::error::Error": [
      "Plain",
      "Ref",
      "RefVariantField(VariantIdx(None)-FieldIdx(Some(0)))"
    ],
    "core::fmt::rt::Argument": [
      "Plain"
    ],
    "core::fmt::Arguments": [
      "Plain"
    ],
    "core::ops::Range": [
      "Plain"
    ]
  },
  "path": {
    "type": "Local",
    "path": "std::sys::pal::unix::stack_overflow::imp::install_main_guard_default"
  },
  "span": "/home/gh-zjp-CN/.rustup/toolchains/nightly-2025-12-06-aarch64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/pal/unix/stack_overflow.rs:505:5: 537:6",
  "src": "unsafe fn install_main_guard_default(page_size: usize) -> Option<Range<usize>> {\n        // Reallocate the last page of the stack.\n        // This ensures SIGBUS will be raised on\n        // stack overflow.\n        // Systems which enforce strict PAX MPROTECT do not allow\n        // to mprotect() a mapping with less restrictive permissions\n        // than the initial mmap() used, so we mmap() here with\n        // read/write permissions and only then mprotect() it to\n        // no permissions at all. See issue #50313.\n        let stackptr = stack_start_aligned(page_size)?;\n        let result = unsafe {\n            mmap64(\n                stackptr,\n                page_size,\n                PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                -1,\n                0,\n            )\n        };\n        if result != stackptr || result == MAP_FAILED {\n            panic!(\"failed to allocate a guard page: {}\", io::Error::last_os_error());\n        }\n\n        let result = unsafe { mprotect(stackptr, page_size, PROT_NONE) };\n        if result != 0 {\n            panic!(\"failed to protect the guard page: {}\", io::Error::last_os_error());\n        }\n\n        let guardaddr = stackptr.addr();\n\n        Some(guardaddr..guardaddr + page_size)\n    }",
  "mir": "fn sys::pal::unix::stack_overflow::imp::install_main_guard_default(_1: usize) -> core::option::Option<core::ops::Range<usize>> {\n    let mut _0: core::option::Option<core::ops::Range<usize>>;\n    let mut _2: core::ops::ControlFlow<core::option::Option<core::convert::Infallible>, *mut libc::c_void>;\n    let mut _3: core::option::Option<*mut libc::c_void>;\n    let mut _4: isize;\n    let  _5: *mut libc::c_void;\n    let  _6: *mut libc::c_void;\n    let mut _7: i32;\n    let mut _8: i32;\n    let mut _9: i32;\n    let mut _10: bool;\n    let mut _11: bool;\n    let  _12: !;\n    let mut _13: core::fmt::Arguments<'_>;\n    let  _14: (&io::error::Error,);\n    let mut _15: &io::error::Error;\n    let  _16: io::error::Error;\n    let  _17: [core::fmt::rt::Argument<'_>; 1];\n    let mut _18: core::fmt::rt::Argument<'_>;\n    let mut _19: &[u8; 36];\n    let  _20: &[core::fmt::rt::Argument<'_>; 1];\n    let  _21: i32;\n    let  _22: !;\n    let mut _23: core::fmt::Arguments<'_>;\n    let  _24: (&io::error::Error,);\n    let mut _25: &io::error::Error;\n    let  _26: io::error::Error;\n    let  _27: [core::fmt::rt::Argument<'_>; 1];\n    let mut _28: core::fmt::rt::Argument<'_>;\n    let mut _29: &[u8; 37];\n    let  _30: &[core::fmt::rt::Argument<'_>; 1];\n    let  _31: usize;\n    let mut _32: core::ops::Range<usize>;\n    let mut _33: usize;\n    let mut _34: (usize, bool);\n    let mut _35: &io::error::Error;\n    let mut _36: &io::error::Error;\n    debug page_size => _1;\n    debug stackptr => _5;\n    debug residual => core::option::Option::<core::convert::Infallible>::None;\n    debug val => _5;\n    debug result => _6;\n    debug args => _14;\n    debug args => _17;\n    debug result => _21;\n    debug args => _24;\n    debug args => _27;\n    debug guardaddr => _31;\n    bb0: {\n        StorageLive(_2);\n        StorageLive(_3);\n        _3 = sys::pal::unix::stack_overflow::imp::stack_start_aligned(_1) -> [return: bb1, unwind unreachable];\n    }\n    bb1: {\n        _2 = <core::option::Option<*mut libc::c_void> as core::ops::Try>::branch(move _3) -> [return: bb2, unwind unreachable];\n    }\n    bb2: {\n        StorageDead(_3);\n        _4 = discriminant(_2);\n        switchInt(move _4) -> [0: bb4, 1: bb5, otherwise: bb3];\n    }\n    bb3: {\n        unreachable;\n    }\n    bb4: {\n        _5 = ((_2 as variant#0).0: *mut libc::c_void);\n        StorageDead(_2);\n        StorageLive(_7);\n        _7 = BitOr(libc::PROT_READ, libc::PROT_WRITE);\n        StorageLive(_8);\n        StorageLive(_9);\n        _9 = BitOr(libc::MAP_PRIVATE, libc::MAP_ANON);\n        _8 = BitOr(move _9, libc::MAP_FIXED);\n        StorageDead(_9);\n        _6 = libc::mmap64(_5, _1, move _7, move _8, -1_i32, 0_i64) -> [return: bb7, unwind unreachable];\n    }\n    bb5: {\n        _0 = <core::option::Option<core::ops::Range<usize>> as core::ops::FromResidual<core::option::Option<core::convert::Infallible>>>::from_residual(core::option::Option::<core::convert::Infallible>::None) -> [return: bb6, unwind unreachable];\n    }\n    bb6: {\n        StorageDead(_2);\n        goto -> bb24;\n    }\n    bb7: {\n        StorageDead(_8);\n        StorageDead(_7);\n        StorageLive(_10);\n        _10 = Ne(_6, _5);\n        switchInt(move _10) -> [0: bb9, otherwise: bb8];\n    }\n    bb8: {\n        goto -> bb11;\n    }\n    bb9: {\n        StorageLive(_11);\n        _11 = Eq(_6, libc::MAP_FAILED);\n        switchInt(move _11) -> [0: bb15, otherwise: bb10];\n    }\n    bb10: {\n        goto -> bb11;\n    }\n    bb11: {\n        StorageLive(_13);\n        StorageLive(_14);\n        StorageLive(_15);\n        StorageLive(_16);\n        _16 = io::error::Error::last_os_error() -> [return: bb12, unwind unreachable];\n    }\n    bb12: {\n        _15 = &_16;\n        _14 = (move _15);\n        StorageDead(_15);\n        StorageLive(_17);\n        StorageLive(_18);\n        _35 = (_14.0: &io::error::Error);\n        _18 = core::fmt::rt::Argument::<'_>::new_display::<io::error::Error>(_35) -> [return: bb13, unwind unreachable];\n    }\n    bb13: {\n        _17 = [move _18];\n        StorageDead(_18);\n        StorageLive(_19);\n        _19 = b\"!failed to allocate a guard page: \\xc0\\x00\";\n        _20 = &_17;\n        _13 = core::fmt::Arguments::<'_>::new::<36, 1>(move _19, _20) -> [return: bb14, unwind unreachable];\n    }\n    bb14: {\n        StorageDead(_19);\n        _12 = core::panicking::panic_fmt(move _13) -> unwind unreachable;\n    }\n    bb15: {\n        StorageDead(_11);\n        StorageDead(_10);\n        _21 = libc::mprotect(_5, _1, libc::PROT_NONE) -> [return: bb16, unwind unreachable];\n    }\n    bb16: {\n        switchInt(_21) -> [0: bb21, otherwise: bb17];\n    }\n    bb17: {\n        StorageLive(_23);\n        StorageLive(_24);\n        StorageLive(_25);\n        StorageLive(_26);\n        _26 = io::error::Error::last_os_error() -> [return: bb18, unwind unreachable];\n    }\n    bb18: {\n        _25 = &_26;\n        _24 = (move _25);\n        StorageDead(_25);\n        StorageLive(_27);\n        StorageLive(_28);\n        _36 = (_24.0: &io::error::Error);\n        _28 = core::fmt::rt::Argument::<'_>::new_display::<io::error::Error>(_36) -> [return: bb19, unwind unreachable];\n    }\n    bb19: {\n        _27 = [move _28];\n        StorageDead(_28);\n        StorageLive(_29);\n        _29 = b\"\\\"failed to protect the guard page: \\xc0\\x00\";\n        _30 = &_27;\n        _23 = core::fmt::Arguments::<'_>::new::<37, 1>(move _29, _30) -> [return: bb20, unwind unreachable];\n    }\n    bb20: {\n        StorageDead(_29);\n        _22 = core::panicking::panic_fmt(move _23) -> unwind unreachable;\n    }\n    bb21: {\n        _31 = core::ptr::mut_ptr::<impl *mut libc::c_void>::addr(_5) -> [return: bb22, unwind unreachable];\n    }\n    bb22: {\n        StorageLive(_32);\n        StorageLive(_33);\n        _34 = CheckedAdd(_31, _1);\n        assert(!move (_34.1: bool), \"attempt to compute `{} + {}`, which would overflow\", _31, _1) -> [success: bb23, unwind unreachable];\n    }\n    bb23: {\n        _33 = move (_34.0: usize);\n        _32 = Range(_31, move _33);\n        StorageDead(_33);\n        _0 = core::option::Option::Some(move _32);\n        StorageDead(_32);\n        goto -> bb24;\n    }\n    bb24: {\n        return;\n    }\n}\n",
  "doc": "",
  "tags": {
    "tags": [
      {
        "tag": {
          "typ": null,
          "name": "unsafe_op_in_unsafe_fn"
        },
        "args": []
      }
    ],
    "spec": {},
    "docs": [
      "* unsafe_op_in_unsafe_fn\n"
    ]
  }
}